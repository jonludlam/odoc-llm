{
  "package": "astring",
  "version": "0.8.5",
  "metadata": null,
  "modules": [
    {
      "elements": [
        {
          "kind": "section",
          "title": "Predicates",
          "level": 2,
          "content": ""
        },
        {
          "kind": "value",
          "name": "is_valid",
          "signature": "val is_valid : char -> bool",
          "documentation": "is_valid c is true iff c is an US-ASCII character, that is a byte in the range [0x00;0x7F].",
          "anchor": "val-is_valid"
        },
        {
          "kind": "value",
          "name": "is_digit",
          "signature": "val is_digit : char -> bool",
          "documentation": "is_digit c is true iff c is an US-ASCII digit '0' ... '9', that is a byte in the range [0x30;0x39].",
          "anchor": "val-is_digit"
        },
        {
          "kind": "value",
          "name": "is_hex_digit",
          "signature": "val is_hex_digit : char -> bool",
          "documentation": "is_hex_digit c is true iff c is an US-ASCII hexadecimal digit '0' ... '9', 'a' ... 'f', 'A' ... 'F', that is a byte in one of the ranges [0x30;0x39], [0x41;0x46], [0x61;0x66].",
          "anchor": "val-is_hex_digit"
        },
        {
          "kind": "value",
          "name": "is_upper",
          "signature": "val is_upper : char -> bool",
          "documentation": "is_upper c is true iff c is an US-ASCII uppercase letter 'A' ... 'Z', that is a byte in the range [0x41;0x5A].",
          "anchor": "val-is_upper"
        },
        {
          "kind": "value",
          "name": "is_lower",
          "signature": "val is_lower : char -> bool",
          "documentation": "is_lower c is true iff c is an US-ASCII lowercase letter 'a' ... 'z', that is a byte in the range [0x61;0x7A].",
          "anchor": "val-is_lower"
        },
        {
          "kind": "value",
          "name": "is_letter",
          "signature": "val is_letter : char -> bool",
          "documentation": "is_letter c is is_lower c || is_upper c.",
          "anchor": "val-is_letter"
        },
        {
          "kind": "value",
          "name": "is_alphanum",
          "signature": "val is_alphanum : char -> bool",
          "documentation": "is_alphanum c is is_letter c || is_digit c.",
          "anchor": "val-is_alphanum"
        },
        {
          "kind": "value",
          "name": "is_white",
          "signature": "val is_white : char -> bool",
          "documentation": "is_white c is true iff c is an US-ASCII white space character, that is one of space ' ' (0x20), tab '\\t' (0x09), newline '\\n' (0x0A), vertical tab (0x0B), form feed (0x0C), carriage return '\\r' (0x0D).",
          "anchor": "val-is_white"
        },
        {
          "kind": "value",
          "name": "is_blank",
          "signature": "val is_blank : char -> bool",
          "documentation": "is_blank c is true iff c is an US-ASCII blank character, that is either space ' ' (0x20) or tab '\\t' (0x09).",
          "anchor": "val-is_blank"
        },
        {
          "kind": "value",
          "name": "is_graphic",
          "signature": "val is_graphic : char -> bool",
          "documentation": "is_graphic c is true iff c is an US-ASCII graphic character that is a byte in the range [0x21;0x7E].",
          "anchor": "val-is_graphic"
        },
        {
          "kind": "value",
          "name": "is_print",
          "signature": "val is_print : char -> bool",
          "documentation": "is_print c is is_graphic c || c = ' '.",
          "anchor": "val-is_print"
        },
        {
          "kind": "value",
          "name": "is_control",
          "signature": "val is_control : char -> bool",
          "documentation": "is_control c is true iff c is an US-ASCII control character, that is a byte in the range [0x00;0x1F] or 0x7F.",
          "anchor": "val-is_control"
        },
        {
          "kind": "section",
          "title": "Casing transforms",
          "level": 2,
          "content": ""
        },
        {
          "kind": "value",
          "name": "uppercase",
          "signature": "val uppercase : char -> char",
          "documentation": "uppercase c is c with US-ASCII characters 'a' to 'z' mapped to 'A' to 'Z'.",
          "anchor": "val-uppercase"
        },
        {
          "kind": "value",
          "name": "lowercase",
          "signature": "val lowercase : char -> char",
          "documentation": "lowercase c is c with US-ASCII characters 'A' to 'Z' mapped to 'a' to 'z'.",
          "anchor": "val-lowercase"
        },
        {
          "kind": "section",
          "title": "Escaping to printable US-ASCII",
          "level": 2,
          "content": ""
        },
        {
          "kind": "value",
          "name": "escape",
          "signature": "val escape : char -> string",
          "documentation": "escape c escapes c with:",
          "anchor": "val-escape"
        },
        {
          "kind": "value",
          "name": "escape_char",
          "signature": "val escape_char : char -> string",
          "documentation": "escape_char c is like escape except is escapes s according to OCaml's lexical conventions for characters with:",
          "anchor": "val-escape_char"
        }
      ],
      "types": [],
      "values": [
        {
          "kind": "value",
          "name": "is_valid",
          "signature": "val is_valid : char -> bool",
          "documentation": "is_valid c is true iff c is an US-ASCII character, that is a byte in the range [0x00;0x7F].",
          "anchor": "val-is_valid"
        },
        {
          "kind": "value",
          "name": "is_digit",
          "signature": "val is_digit : char -> bool",
          "documentation": "is_digit c is true iff c is an US-ASCII digit '0' ... '9', that is a byte in the range [0x30;0x39].",
          "anchor": "val-is_digit"
        },
        {
          "kind": "value",
          "name": "is_hex_digit",
          "signature": "val is_hex_digit : char -> bool",
          "documentation": "is_hex_digit c is true iff c is an US-ASCII hexadecimal digit '0' ... '9', 'a' ... 'f', 'A' ... 'F', that is a byte in one of the ranges [0x30;0x39], [0x41;0x46], [0x61;0x66].",
          "anchor": "val-is_hex_digit"
        },
        {
          "kind": "value",
          "name": "is_upper",
          "signature": "val is_upper : char -> bool",
          "documentation": "is_upper c is true iff c is an US-ASCII uppercase letter 'A' ... 'Z', that is a byte in the range [0x41;0x5A].",
          "anchor": "val-is_upper"
        },
        {
          "kind": "value",
          "name": "is_lower",
          "signature": "val is_lower : char -> bool",
          "documentation": "is_lower c is true iff c is an US-ASCII lowercase letter 'a' ... 'z', that is a byte in the range [0x61;0x7A].",
          "anchor": "val-is_lower"
        },
        {
          "kind": "value",
          "name": "is_letter",
          "signature": "val is_letter : char -> bool",
          "documentation": "is_letter c is is_lower c || is_upper c.",
          "anchor": "val-is_letter"
        },
        {
          "kind": "value",
          "name": "is_alphanum",
          "signature": "val is_alphanum : char -> bool",
          "documentation": "is_alphanum c is is_letter c || is_digit c.",
          "anchor": "val-is_alphanum"
        },
        {
          "kind": "value",
          "name": "is_white",
          "signature": "val is_white : char -> bool",
          "documentation": "is_white c is true iff c is an US-ASCII white space character, that is one of space ' ' (0x20), tab '\\t' (0x09), newline '\\n' (0x0A), vertical tab (0x0B), form feed (0x0C), carriage return '\\r' (0x0D).",
          "anchor": "val-is_white"
        },
        {
          "kind": "value",
          "name": "is_blank",
          "signature": "val is_blank : char -> bool",
          "documentation": "is_blank c is true iff c is an US-ASCII blank character, that is either space ' ' (0x20) or tab '\\t' (0x09).",
          "anchor": "val-is_blank"
        },
        {
          "kind": "value",
          "name": "is_graphic",
          "signature": "val is_graphic : char -> bool",
          "documentation": "is_graphic c is true iff c is an US-ASCII graphic character that is a byte in the range [0x21;0x7E].",
          "anchor": "val-is_graphic"
        },
        {
          "kind": "value",
          "name": "is_print",
          "signature": "val is_print : char -> bool",
          "documentation": "is_print c is is_graphic c || c = ' '.",
          "anchor": "val-is_print"
        },
        {
          "kind": "value",
          "name": "is_control",
          "signature": "val is_control : char -> bool",
          "documentation": "is_control c is true iff c is an US-ASCII control character, that is a byte in the range [0x00;0x1F] or 0x7F.",
          "anchor": "val-is_control"
        },
        {
          "kind": "value",
          "name": "uppercase",
          "signature": "val uppercase : char -> char",
          "documentation": "uppercase c is c with US-ASCII characters 'a' to 'z' mapped to 'A' to 'Z'.",
          "anchor": "val-uppercase"
        },
        {
          "kind": "value",
          "name": "lowercase",
          "signature": "val lowercase : char -> char",
          "documentation": "lowercase c is c with US-ASCII characters 'A' to 'Z' mapped to 'a' to 'z'.",
          "anchor": "val-lowercase"
        },
        {
          "kind": "value",
          "name": "escape",
          "signature": "val escape : char -> string",
          "documentation": "escape c escapes c with:",
          "anchor": "val-escape"
        },
        {
          "kind": "value",
          "name": "escape_char",
          "signature": "val escape_char : char -> string",
          "documentation": "escape_char c is like escape except is escapes s according to OCaml's lexical conventions for characters with:",
          "anchor": "val-escape_char"
        }
      ],
      "modules": [],
      "module_documentation": "US-ASCII character support\nThe following functions act only on US-ASCII code points, that is on the bytes in range [0x00;0x7F]. The functions can be safely used on UTF-8 encoded strings, they will of course only deal with US-ASCII related matters.\nReferences.",
      "sections": [
        {
          "kind": "section",
          "title": "Predicates",
          "level": 2,
          "content": ""
        },
        {
          "kind": "section",
          "title": "Casing transforms",
          "level": 2,
          "content": ""
        },
        {
          "kind": "section",
          "title": "Escaping to printable US-ASCII",
          "level": 2,
          "content": ""
        }
      ],
      "package": "astring",
      "version": "0.8.5",
      "file_path": "doc/astring/Astring-Char-Ascii.md",
      "library": "astring",
      "module_path": [
        "Astring",
        "Char",
        "Ascii"
      ]
    },
    {
      "elements": [
        {
          "kind": "section",
          "title": "String sets",
          "level": 2,
          "content": ""
        },
        {
          "kind": "type",
          "name": "t",
          "signature": "type t = set",
          "anchor": "type-t"
        },
        {
          "kind": "value",
          "name": "min_elt",
          "signature": "val min_elt : set -> string option",
          "documentation": "Exception safe Set.S.min_elt.",
          "anchor": "val-min_elt"
        },
        {
          "kind": "value",
          "name": "get_min_elt",
          "signature": "val get_min_elt : set -> string",
          "documentation": "get_min_elt is like min_elt but",
          "anchor": "val-get_min_elt"
        },
        {
          "kind": "value",
          "name": "max_elt",
          "signature": "val max_elt : set -> string option",
          "documentation": "Exception safe Set.S.max_elt.",
          "anchor": "val-max_elt"
        },
        {
          "kind": "value",
          "name": "get_max_elt",
          "signature": "val get_max_elt : set -> string",
          "documentation": "get_max_elt is like max_elt but",
          "anchor": "val-get_max_elt"
        },
        {
          "kind": "value",
          "name": "choose",
          "signature": "val choose : set -> string option",
          "documentation": "Exception safe Set.S.choose.",
          "anchor": "val-choose"
        },
        {
          "kind": "value",
          "name": "get_any_elt",
          "signature": "val get_any_elt : set -> string",
          "documentation": "get_any_elt is like choose but",
          "anchor": "val-get_any_elt"
        },
        {
          "kind": "value",
          "name": "find",
          "signature": "val find : string -> set -> string option",
          "documentation": "Exception safe Set.S.find.",
          "anchor": "val-find"
        },
        {
          "kind": "value",
          "name": "get",
          "signature": "val get : string -> set -> string",
          "documentation": "get is like Set.S.find but",
          "anchor": "val-get"
        },
        {
          "kind": "value",
          "name": "of_list",
          "signature": "val of_list : string list -> set",
          "documentation": "of_list ss is a set from the list ss.",
          "anchor": "val-of_list"
        },
        {
          "kind": "value",
          "name": "of_stdlib_set",
          "signature": "val of_stdlib_set : Set.Make(String).t -> set",
          "documentation": "of_stdlib_set s is a set from the stdlib-compatible set s.",
          "anchor": "val-of_stdlib_set"
        },
        {
          "kind": "value",
          "name": "to_stdlib_set",
          "signature": "val to_stdlib_set : set -> Set.Make(String).t",
          "documentation": "to_stdlib_set s is the stdlib-compatible set equivalent to s.",
          "anchor": "val-to_stdlib_set"
        },
        {
          "kind": "value",
          "name": "pp",
          "signature": "val pp : ?sep:(Format.formatter -> unit -> unit) ->\n  (Format.formatter -> string -> unit) ->\n  Format.formatter ->\n  set ->\n  unit",
          "documentation": "pp ~sep pp_elt ppf ss formats the elements of ss on ppf. Each element is formatted with pp_elt and elements are separated by ~sep (defaults to Format.pp_print_cut. If the set is empty leaves ppf untouched.",
          "anchor": "val-pp"
        },
        {
          "kind": "value",
          "name": "dump",
          "signature": "val dump : Format.formatter -> set -> unit",
          "documentation": "dump ppf ss prints an unspecified representation of ss on ppf.",
          "anchor": "val-dump"
        }
      ],
      "types": [
        {
          "kind": "type",
          "name": "t",
          "signature": "type t = set",
          "anchor": "type-t"
        }
      ],
      "values": [
        {
          "kind": "value",
          "name": "min_elt",
          "signature": "val min_elt : set -> string option",
          "documentation": "Exception safe Set.S.min_elt.",
          "anchor": "val-min_elt"
        },
        {
          "kind": "value",
          "name": "get_min_elt",
          "signature": "val get_min_elt : set -> string",
          "documentation": "get_min_elt is like min_elt but",
          "anchor": "val-get_min_elt"
        },
        {
          "kind": "value",
          "name": "max_elt",
          "signature": "val max_elt : set -> string option",
          "documentation": "Exception safe Set.S.max_elt.",
          "anchor": "val-max_elt"
        },
        {
          "kind": "value",
          "name": "get_max_elt",
          "signature": "val get_max_elt : set -> string",
          "documentation": "get_max_elt is like max_elt but",
          "anchor": "val-get_max_elt"
        },
        {
          "kind": "value",
          "name": "choose",
          "signature": "val choose : set -> string option",
          "documentation": "Exception safe Set.S.choose.",
          "anchor": "val-choose"
        },
        {
          "kind": "value",
          "name": "get_any_elt",
          "signature": "val get_any_elt : set -> string",
          "documentation": "get_any_elt is like choose but",
          "anchor": "val-get_any_elt"
        },
        {
          "kind": "value",
          "name": "find",
          "signature": "val find : string -> set -> string option",
          "documentation": "Exception safe Set.S.find.",
          "anchor": "val-find"
        },
        {
          "kind": "value",
          "name": "get",
          "signature": "val get : string -> set -> string",
          "documentation": "get is like Set.S.find but",
          "anchor": "val-get"
        },
        {
          "kind": "value",
          "name": "of_list",
          "signature": "val of_list : string list -> set",
          "documentation": "of_list ss is a set from the list ss.",
          "anchor": "val-of_list"
        },
        {
          "kind": "value",
          "name": "of_stdlib_set",
          "signature": "val of_stdlib_set : Set.Make(String).t -> set",
          "documentation": "of_stdlib_set s is a set from the stdlib-compatible set s.",
          "anchor": "val-of_stdlib_set"
        },
        {
          "kind": "value",
          "name": "to_stdlib_set",
          "signature": "val to_stdlib_set : set -> Set.Make(String).t",
          "documentation": "to_stdlib_set s is the stdlib-compatible set equivalent to s.",
          "anchor": "val-to_stdlib_set"
        },
        {
          "kind": "value",
          "name": "pp",
          "signature": "val pp : ?sep:(Format.formatter -> unit -> unit) ->\n  (Format.formatter -> string -> unit) ->\n  Format.formatter ->\n  set ->\n  unit",
          "documentation": "pp ~sep pp_elt ppf ss formats the elements of ss on ppf. Each element is formatted with pp_elt and elements are separated by ~sep (defaults to Format.pp_print_cut. If the set is empty leaves ppf untouched.",
          "anchor": "val-pp"
        },
        {
          "kind": "value",
          "name": "dump",
          "signature": "val dump : Format.formatter -> set -> unit",
          "documentation": "dump ppf ss prints an unspecified representation of ss on ppf.",
          "anchor": "val-dump"
        }
      ],
      "modules": [],
      "module_documentation": "String sets.",
      "sections": [
        {
          "kind": "section",
          "title": "String sets",
          "level": 2,
          "content": ""
        }
      ],
      "package": "astring",
      "version": "0.8.5",
      "file_path": "doc/astring/Astring-String-Set.md",
      "library": "astring",
      "module_path": [
        "Astring",
        "String",
        "Set"
      ]
    },
    {
      "elements": [
        {
          "kind": "section",
          "title": "Substrings",
          "level": 2,
          "content": ""
        },
        {
          "kind": "type",
          "name": "t",
          "signature": "type t = sub",
          "anchor": "type-t"
        },
        {
          "kind": "value",
          "name": "empty",
          "signature": "val empty : sub",
          "documentation": "empty is the empty substring of the empty string String.empty.",
          "anchor": "val-empty"
        },
        {
          "kind": "value",
          "name": "v",
          "signature": "val v : ?start:int -> ?stop:int -> string -> sub",
          "documentation": "v ~start ~stop s is the substring of s that starts at position start (defaults to 0) and stops at position stop (defaults to String.length s).",
          "anchor": "val-v"
        },
        {
          "kind": "value",
          "name": "start_pos",
          "signature": "val start_pos : sub -> int",
          "documentation": "start_pos s is s's start position in the base string.",
          "anchor": "val-start_pos"
        },
        {
          "kind": "value",
          "name": "stop_pos",
          "signature": "val stop_pos : sub -> int",
          "documentation": "stop_pos s is s's stop position in the base string.",
          "anchor": "val-stop_pos"
        },
        {
          "kind": "value",
          "name": "base_string",
          "signature": "val base_string : sub -> string",
          "documentation": "base_string s is s's base string.",
          "anchor": "val-base_string"
        },
        {
          "kind": "value",
          "name": "length",
          "signature": "val length : sub -> int",
          "documentation": "length s is the number of bytes in s.",
          "anchor": "val-length"
        },
        {
          "kind": "value",
          "name": "get",
          "signature": "val get : sub -> int -> char",
          "documentation": "get s i is the byte of s at its zero-based index i.",
          "anchor": "val-get"
        },
        {
          "kind": "value",
          "name": "get_byte",
          "signature": "val get_byte : sub -> int -> int",
          "documentation": "get_byte s i is Char.to_int (get s i).",
          "anchor": "val-get_byte"
        },
        {
          "kind": "value",
          "name": "head",
          "signature": "val head : ?rev:bool -> sub -> char option",
          "documentation": "head s is Some (get s h) with h = 0 if rev = false (default) or h = length s - 1 if rev = true. None is returned if s is empty.",
          "anchor": "val-head"
        },
        {
          "kind": "value",
          "name": "get_head",
          "signature": "val get_head : ?rev:bool -> sub -> char",
          "documentation": "get_head s is like head but",
          "anchor": "val-get_head"
        },
        {
          "kind": "value",
          "name": "of_string",
          "signature": "val of_string : string -> sub",
          "documentation": "of_string s is v s",
          "anchor": "val-of_string"
        },
        {
          "kind": "value",
          "name": "to_string",
          "signature": "val to_string : sub -> string",
          "documentation": "to_string s is the bytes of s as a string.",
          "anchor": "val-to_string"
        },
        {
          "kind": "value",
          "name": "rebase",
          "signature": "val rebase : sub -> sub",
          "documentation": "rebase s is v (to_string s). This puts s on a base string made solely of its bytes.",
          "anchor": "val-rebase"
        },
        {
          "kind": "value",
          "name": "hash",
          "signature": "val hash : sub -> int",
          "documentation": "hash s is Hashtbl.hashs.",
          "anchor": "val-hash"
        },
        {
          "kind": "section",
          "title": "Stretching substrings",
          "level": 2,
          "content": "See the graphical guide."
        },
        {
          "kind": "value",
          "name": "start",
          "signature": "val start : sub -> sub",
          "documentation": "start s is the empty substring at the start position of s.",
          "anchor": "val-start"
        },
        {
          "kind": "value",
          "name": "stop",
          "signature": "val stop : sub -> sub",
          "documentation": "stop s is the empty substring at the stop position of s.",
          "anchor": "val-stop"
        },
        {
          "kind": "value",
          "name": "base",
          "signature": "val base : sub -> sub",
          "documentation": "base s is a substring that spans the whole base string of s.",
          "anchor": "val-base"
        },
        {
          "kind": "value",
          "name": "tail",
          "signature": "val tail : ?rev:bool -> sub -> sub",
          "documentation": "tail s is s without its first (rev is false, default) or last (rev is true) byte or s if it is empty.",
          "anchor": "val-tail"
        },
        {
          "kind": "value",
          "name": "extend",
          "signature": "val extend : ?rev:bool -> ?max:int -> ?sat:(char -> bool) -> sub -> sub",
          "documentation": "extend ~rev ~max ~sat s extends s by at most max consecutive sat satisfiying bytes of the base string located after stop s (rev is false, default) or before start s (rev is true). If max is unspecified the extension is limited by the extents of the base string of s. sat defaults to fun _ -> true.",
          "anchor": "val-extend"
        },
        {
          "kind": "value",
          "name": "reduce",
          "signature": "val reduce : ?rev:bool -> ?max:int -> ?sat:(char -> bool) -> sub -> sub",
          "documentation": "reduce ~rev ~max ~sat s reduces s by at most max consecutive sat satisfying bytes of s located before stop s (rev is false, default) or after start s (rev is true). If max is unspecified the reduction is limited by the extents of the substring s. sat defaults to fun _ -> true.",
          "anchor": "val-reduce"
        },
        {
          "kind": "value",
          "name": "extent",
          "signature": "val extent : sub -> sub -> sub",
          "documentation": "extent s s' is the smallest substring that includes all the positions of s and s'.",
          "anchor": "val-extent"
        },
        {
          "kind": "value",
          "name": "overlap",
          "signature": "val overlap : sub -> sub -> sub option",
          "documentation": "overlap s s' is the smallest substring that includes all the positions common to s and s' or None if there are no such positions. Note that the overlap substring may be empty.",
          "anchor": "val-overlap"
        },
        {
          "kind": "section",
          "title": "Appending substrings",
          "level": 2,
          "content": ""
        },
        {
          "kind": "value",
          "name": "append",
          "signature": "val append : sub -> sub -> sub",
          "documentation": "append s s' is like Appending strings. The substrings can be on different bases and the result is on a base string that holds exactly the appended bytes.",
          "anchor": "val-append"
        },
        {
          "kind": "value",
          "name": "concat",
          "signature": "val concat : ?sep:sub -> sub list -> sub",
          "documentation": "concat ~sep ss is like String.concat. The substrings can all be on different bases and the result is on a base string that holds exactly the concatenated bytes.",
          "anchor": "val-concat"
        },
        {
          "kind": "section",
          "title": "Predicates",
          "level": 2,
          "content": ""
        },
        {
          "kind": "value",
          "name": "is_empty",
          "signature": "val is_empty : sub -> bool",
          "documentation": "is_empty s is length s = 0.",
          "anchor": "val-is_empty"
        },
        {
          "kind": "value",
          "name": "is_prefix",
          "signature": "val is_prefix : affix:sub -> sub -> bool",
          "documentation": "is_prefix is like String.is_prefix. Only bytes are compared, affix can be on a different base string.",
          "anchor": "val-is_prefix"
        },
        {
          "kind": "value",
          "name": "is_infix",
          "signature": "val is_infix : affix:sub -> sub -> bool",
          "documentation": "is_infix is like String.is_infix. Only bytes are compared, affix can be on a different base string.",
          "anchor": "val-is_infix"
        },
        {
          "kind": "value",
          "name": "is_suffix",
          "signature": "val is_suffix : affix:sub -> sub -> bool",
          "documentation": "is_suffix is like String.is_suffix. Only bytes are compared, affix can be on a different base string.",
          "anchor": "val-is_suffix"
        },
        {
          "kind": "value",
          "name": "for_all",
          "signature": "val for_all : (char -> bool) -> sub -> bool",
          "documentation": "for_all is like String.for_all on the substring.",
          "anchor": "val-for_all"
        },
        {
          "kind": "value",
          "name": "exists",
          "signature": "val exists : (char -> bool) -> sub -> bool",
          "documentation": "exists is like String.exists on the substring.",
          "anchor": "val-exists"
        },
        {
          "kind": "value",
          "name": "same_base",
          "signature": "val same_base : sub -> sub -> bool",
          "documentation": "same_base s s' is true iff the substrings s and s' have the same base string according to physical equality.",
          "anchor": "val-same_base"
        },
        {
          "kind": "value",
          "name": "equal_bytes",
          "signature": "val equal_bytes : sub -> sub -> bool",
          "documentation": "equal_bytes s s' is true iff the substrings s and s' have exactly the same bytes. The substrings can be on a different base string.",
          "anchor": "val-equal_bytes"
        },
        {
          "kind": "value",
          "name": "compare_bytes",
          "signature": "val compare_bytes : sub -> sub -> int",
          "documentation": "compare_bytes s s' compares the bytes of s and s' in lexicographical order. The substrings can be on a different base string.",
          "anchor": "val-compare_bytes"
        },
        {
          "kind": "value",
          "name": "equal",
          "signature": "val equal : sub -> sub -> bool",
          "documentation": "equal s s' is true iff s and s' have the same positions.",
          "anchor": "val-equal"
        },
        {
          "kind": "value",
          "name": "compare",
          "signature": "val compare : sub -> sub -> int",
          "documentation": "compare s s' compares the positions of s and s' in lexicographical order.",
          "anchor": "val-compare"
        },
        {
          "kind": "section",
          "title": "Extracting substrings",
          "level": 2,
          "content": "Extracted substrings are always on the same base string as the substring s acted upon."
        },
        {
          "kind": "value",
          "name": "with_range",
          "signature": "val with_range : ?first:int -> ?len:int -> sub -> sub",
          "documentation": "with_range is like String.sub_with_range. The indices are the substring's zero-based ones, not those in the base string.",
          "anchor": "val-with_range"
        },
        {
          "kind": "value",
          "name": "with_index_range",
          "signature": "val with_index_range : ?first:int -> ?last:int -> sub -> sub",
          "documentation": "with_index_range is like String.sub_with_index_range. The indices are the substring's zero-based ones, not those in the base string.",
          "anchor": "val-with_index_range"
        },
        {
          "kind": "value",
          "name": "trim",
          "signature": "val trim : ?drop:(char -> bool) -> sub -> sub",
          "documentation": "trim is like String.trim. If all bytes are dropped returns an empty string located in the middle of the argument.",
          "anchor": "val-trim"
        },
        {
          "kind": "value",
          "name": "span",
          "signature": "val span : ?rev:bool ->\n  ?min:int ->\n  ?max:int ->\n  ?sat:(char -> bool) ->\n  sub ->\n  sub * sub",
          "documentation": "span is like String.span. For a substring s a left empty span is start s and a right empty span is stop s.",
          "anchor": "val-span"
        },
        {
          "kind": "value",
          "name": "take",
          "signature": "val take : ?rev:bool ->\n  ?min:int ->\n  ?max:int ->\n  ?sat:(char -> bool) ->\n  sub ->\n  sub",
          "documentation": "take is like String.take.",
          "anchor": "val-take"
        },
        {
          "kind": "value",
          "name": "drop",
          "signature": "val drop : ?rev:bool ->\n  ?min:int ->\n  ?max:int ->\n  ?sat:(char -> bool) ->\n  sub ->\n  sub",
          "documentation": "drop is like String.drop.",
          "anchor": "val-drop"
        },
        {
          "kind": "value",
          "name": "cut",
          "signature": "val cut : ?rev:bool -> sep:sub -> sub -> (sub * sub) option",
          "documentation": "cut is like String.cut. sep can be on a different base string",
          "anchor": "val-cut"
        },
        {
          "kind": "value",
          "name": "cuts",
          "signature": "val cuts : ?rev:bool -> ?empty:bool -> sep:sub -> sub -> sub list",
          "documentation": "cuts is like String.cuts. sep can be on a different base string",
          "anchor": "val-cuts"
        },
        {
          "kind": "value",
          "name": "fields",
          "signature": "val fields : ?empty:bool -> ?is_sep:(char -> bool) -> sub -> sub list",
          "documentation": "fields is like String.fields.",
          "anchor": "val-fields"
        },
        {
          "kind": "section",
          "title": "Traversing substrings",
          "level": 2,
          "content": ""
        },
        {
          "kind": "value",
          "name": "find",
          "signature": "val find : ?rev:bool -> (char -> bool) -> sub -> sub option",
          "documentation": "find ~rev sat s is the substring of s (if any) that spans the first byte that satisfies sat in s after position start s (rev is false, default) or before stop s (rev is true). None is returned if there is no matching byte in s.",
          "anchor": "val-find"
        },
        {
          "kind": "value",
          "name": "find_sub",
          "signature": "val find_sub : ?rev:bool -> sub:sub -> sub -> sub option",
          "documentation": "find_sub ~rev ~sub s is the substring of s (if any) that spans the first match of sub in s after position start s (rev is false, default) or before stop s (rev is true). Only bytes are compared and sub can be on a different base string. None is returned if there is no match of sub in s.",
          "anchor": "val-find_sub"
        },
        {
          "kind": "value",
          "name": "filter",
          "signature": "val filter : (char -> bool) -> sub -> sub",
          "documentation": "filter sat s is like String.filter. The result is on a base string that holds only the filtered bytes.",
          "anchor": "val-filter"
        },
        {
          "kind": "value",
          "name": "filter_map",
          "signature": "val filter_map : (char -> char option) -> sub -> sub",
          "documentation": "filter_map f s is like String.filter_map. The result is on a base string that holds only the filtered bytes.",
          "anchor": "val-filter_map"
        },
        {
          "kind": "value",
          "name": "map",
          "signature": "val map : (char -> char) -> sub -> sub",
          "documentation": "map is like String.map. The result is on a base string that holds only the mapped bytes.",
          "anchor": "val-map"
        },
        {
          "kind": "value",
          "name": "mapi",
          "signature": "val mapi : (int -> char -> char) -> sub -> sub",
          "documentation": "mapi is like String.mapi. The result is on a base string that holds only the mapped bytes. The indices are the substring's zero-based ones, not those in the base string.",
          "anchor": "val-mapi"
        },
        {
          "kind": "value",
          "name": "fold_left",
          "signature": "val fold_left : ('a -> char -> 'a) -> 'a -> sub -> 'a",
          "documentation": "fold_left is like String.fold_left.",
          "anchor": "val-fold_left"
        },
        {
          "kind": "value",
          "name": "fold_right",
          "signature": "val fold_right : (char -> 'a -> 'a) -> sub -> 'a -> 'a",
          "documentation": "fold_right is like String.fold_right.",
          "anchor": "val-fold_right"
        },
        {
          "kind": "value",
          "name": "iter",
          "signature": "val iter : (char -> unit) -> sub -> unit",
          "documentation": "iter is like String.iter.",
          "anchor": "val-iter"
        },
        {
          "kind": "value",
          "name": "iteri",
          "signature": "val iteri : (int -> char -> unit) -> sub -> unit",
          "documentation": "iteri is like String.iteri. The indices are the substring's zero-based ones, not those in the base string.",
          "anchor": "val-iteri"
        },
        {
          "kind": "section",
          "title": "Pretty printing",
          "level": 2,
          "content": ""
        },
        {
          "kind": "value",
          "name": "pp",
          "signature": "val pp : Format.formatter -> sub -> unit",
          "documentation": "pp ppf s prints s's bytes on ppf.",
          "anchor": "val-pp"
        },
        {
          "kind": "value",
          "name": "dump",
          "signature": "val dump : Format.formatter -> sub -> unit",
          "documentation": "dump ppf s prints s as a syntactically valid OCaml string on ppf using Ascii.escape_string.",
          "anchor": "val-dump"
        },
        {
          "kind": "value",
          "name": "dump_raw",
          "signature": "val dump_raw : Format.formatter -> sub -> unit",
          "documentation": "dump_raw ppf s prints an unspecified raw internal representation of s on ppf.",
          "anchor": "val-dump_raw"
        },
        {
          "kind": "section",
          "title": "OCaml base type conversions",
          "level": 2,
          "content": ""
        },
        {
          "kind": "value",
          "name": "of_char",
          "signature": "val of_char : char -> sub",
          "documentation": "of_char c is a string that contains the byte c.",
          "anchor": "val-of_char"
        },
        {
          "kind": "value",
          "name": "to_char",
          "signature": "val to_char : sub -> char option",
          "documentation": "to_char s is the single byte in s or None if there is no byte or more than one in s.",
          "anchor": "val-to_char"
        },
        {
          "kind": "value",
          "name": "of_bool",
          "signature": "val of_bool : bool -> sub",
          "documentation": "of_bool b is a string representation for b. Relies on Stdlib.string_of_bool.",
          "anchor": "val-of_bool"
        },
        {
          "kind": "value",
          "name": "to_bool",
          "signature": "val to_bool : sub -> bool option",
          "documentation": "to_bool s is a bool from s, if any. Relies on Stdlib.bool_of_string.",
          "anchor": "val-to_bool"
        },
        {
          "kind": "value",
          "name": "of_int",
          "signature": "val of_int : int -> sub",
          "documentation": "of_int i is a string representation for i. Relies on Stdlib.string_of_int.",
          "anchor": "val-of_int"
        },
        {
          "kind": "value",
          "name": "to_int",
          "signature": "val to_int : sub -> int option",
          "documentation": "to_int is an int from s, if any. Relies on Stdlib.int_of_string.",
          "anchor": "val-to_int"
        },
        {
          "kind": "value",
          "name": "of_nativeint",
          "signature": "val of_nativeint : nativeint -> sub",
          "documentation": "of_nativeint i is a string representation for i. Relies on Nativeint.of_string.",
          "anchor": "val-of_nativeint"
        },
        {
          "kind": "value",
          "name": "to_nativeint",
          "signature": "val to_nativeint : sub -> nativeint option",
          "documentation": "to_nativeint is an nativeint from s, if any. Relies on Nativeint.to_string.",
          "anchor": "val-to_nativeint"
        },
        {
          "kind": "value",
          "name": "of_int32",
          "signature": "val of_int32 : int32 -> sub",
          "documentation": "of_int32 i is a string representation for i. Relies on Int32.of_string.",
          "anchor": "val-of_int32"
        },
        {
          "kind": "value",
          "name": "to_int32",
          "signature": "val to_int32 : sub -> int32 option",
          "documentation": "to_int32 is an int32 from s, if any. Relies on Int32.to_string.",
          "anchor": "val-to_int32"
        },
        {
          "kind": "value",
          "name": "of_int64",
          "signature": "val of_int64 : int64 -> sub",
          "documentation": "of_int64 i is a string representation for i. Relies on Int64.of_string.",
          "anchor": "val-of_int64"
        },
        {
          "kind": "value",
          "name": "to_int64",
          "signature": "val to_int64 : sub -> int64 option",
          "documentation": "to_int64 is an int64 from s, if any. Relies on Int64.to_string.",
          "anchor": "val-to_int64"
        },
        {
          "kind": "value",
          "name": "of_float",
          "signature": "val of_float : float -> sub",
          "documentation": "of_float f is a string representation for f. Relies on Stdlib.string_of_float.",
          "anchor": "val-of_float"
        },
        {
          "kind": "value",
          "name": "to_float",
          "signature": "val to_float : sub -> float option",
          "documentation": "to_float s is a float from s, if any. Relies on Stdlib.float_of_string.",
          "anchor": "val-to_float"
        },
        {
          "kind": "section",
          "title": "Substring stretching graphical guide",
          "level": 2,
          "content": ""
        }
      ],
      "types": [
        {
          "kind": "type",
          "name": "t",
          "signature": "type t = sub",
          "anchor": "type-t"
        }
      ],
      "values": [
        {
          "kind": "value",
          "name": "empty",
          "signature": "val empty : sub",
          "documentation": "empty is the empty substring of the empty string String.empty.",
          "anchor": "val-empty"
        },
        {
          "kind": "value",
          "name": "v",
          "signature": "val v : ?start:int -> ?stop:int -> string -> sub",
          "documentation": "v ~start ~stop s is the substring of s that starts at position start (defaults to 0) and stops at position stop (defaults to String.length s).",
          "anchor": "val-v"
        },
        {
          "kind": "value",
          "name": "start_pos",
          "signature": "val start_pos : sub -> int",
          "documentation": "start_pos s is s's start position in the base string.",
          "anchor": "val-start_pos"
        },
        {
          "kind": "value",
          "name": "stop_pos",
          "signature": "val stop_pos : sub -> int",
          "documentation": "stop_pos s is s's stop position in the base string.",
          "anchor": "val-stop_pos"
        },
        {
          "kind": "value",
          "name": "base_string",
          "signature": "val base_string : sub -> string",
          "documentation": "base_string s is s's base string.",
          "anchor": "val-base_string"
        },
        {
          "kind": "value",
          "name": "length",
          "signature": "val length : sub -> int",
          "documentation": "length s is the number of bytes in s.",
          "anchor": "val-length"
        },
        {
          "kind": "value",
          "name": "get",
          "signature": "val get : sub -> int -> char",
          "documentation": "get s i is the byte of s at its zero-based index i.",
          "anchor": "val-get"
        },
        {
          "kind": "value",
          "name": "get_byte",
          "signature": "val get_byte : sub -> int -> int",
          "documentation": "get_byte s i is Char.to_int (get s i).",
          "anchor": "val-get_byte"
        },
        {
          "kind": "value",
          "name": "head",
          "signature": "val head : ?rev:bool -> sub -> char option",
          "documentation": "head s is Some (get s h) with h = 0 if rev = false (default) or h = length s - 1 if rev = true. None is returned if s is empty.",
          "anchor": "val-head"
        },
        {
          "kind": "value",
          "name": "get_head",
          "signature": "val get_head : ?rev:bool -> sub -> char",
          "documentation": "get_head s is like head but",
          "anchor": "val-get_head"
        },
        {
          "kind": "value",
          "name": "of_string",
          "signature": "val of_string : string -> sub",
          "documentation": "of_string s is v s",
          "anchor": "val-of_string"
        },
        {
          "kind": "value",
          "name": "to_string",
          "signature": "val to_string : sub -> string",
          "documentation": "to_string s is the bytes of s as a string.",
          "anchor": "val-to_string"
        },
        {
          "kind": "value",
          "name": "rebase",
          "signature": "val rebase : sub -> sub",
          "documentation": "rebase s is v (to_string s). This puts s on a base string made solely of its bytes.",
          "anchor": "val-rebase"
        },
        {
          "kind": "value",
          "name": "hash",
          "signature": "val hash : sub -> int",
          "documentation": "hash s is Hashtbl.hashs.",
          "anchor": "val-hash"
        },
        {
          "kind": "value",
          "name": "start",
          "signature": "val start : sub -> sub",
          "documentation": "start s is the empty substring at the start position of s.",
          "anchor": "val-start"
        },
        {
          "kind": "value",
          "name": "stop",
          "signature": "val stop : sub -> sub",
          "documentation": "stop s is the empty substring at the stop position of s.",
          "anchor": "val-stop"
        },
        {
          "kind": "value",
          "name": "base",
          "signature": "val base : sub -> sub",
          "documentation": "base s is a substring that spans the whole base string of s.",
          "anchor": "val-base"
        },
        {
          "kind": "value",
          "name": "tail",
          "signature": "val tail : ?rev:bool -> sub -> sub",
          "documentation": "tail s is s without its first (rev is false, default) or last (rev is true) byte or s if it is empty.",
          "anchor": "val-tail"
        },
        {
          "kind": "value",
          "name": "extend",
          "signature": "val extend : ?rev:bool -> ?max:int -> ?sat:(char -> bool) -> sub -> sub",
          "documentation": "extend ~rev ~max ~sat s extends s by at most max consecutive sat satisfiying bytes of the base string located after stop s (rev is false, default) or before start s (rev is true). If max is unspecified the extension is limited by the extents of the base string of s. sat defaults to fun _ -> true.",
          "anchor": "val-extend"
        },
        {
          "kind": "value",
          "name": "reduce",
          "signature": "val reduce : ?rev:bool -> ?max:int -> ?sat:(char -> bool) -> sub -> sub",
          "documentation": "reduce ~rev ~max ~sat s reduces s by at most max consecutive sat satisfying bytes of s located before stop s (rev is false, default) or after start s (rev is true). If max is unspecified the reduction is limited by the extents of the substring s. sat defaults to fun _ -> true.",
          "anchor": "val-reduce"
        },
        {
          "kind": "value",
          "name": "extent",
          "signature": "val extent : sub -> sub -> sub",
          "documentation": "extent s s' is the smallest substring that includes all the positions of s and s'.",
          "anchor": "val-extent"
        },
        {
          "kind": "value",
          "name": "overlap",
          "signature": "val overlap : sub -> sub -> sub option",
          "documentation": "overlap s s' is the smallest substring that includes all the positions common to s and s' or None if there are no such positions. Note that the overlap substring may be empty.",
          "anchor": "val-overlap"
        },
        {
          "kind": "value",
          "name": "append",
          "signature": "val append : sub -> sub -> sub",
          "documentation": "append s s' is like Appending strings. The substrings can be on different bases and the result is on a base string that holds exactly the appended bytes.",
          "anchor": "val-append"
        },
        {
          "kind": "value",
          "name": "concat",
          "signature": "val concat : ?sep:sub -> sub list -> sub",
          "documentation": "concat ~sep ss is like String.concat. The substrings can all be on different bases and the result is on a base string that holds exactly the concatenated bytes.",
          "anchor": "val-concat"
        },
        {
          "kind": "value",
          "name": "is_empty",
          "signature": "val is_empty : sub -> bool",
          "documentation": "is_empty s is length s = 0.",
          "anchor": "val-is_empty"
        },
        {
          "kind": "value",
          "name": "is_prefix",
          "signature": "val is_prefix : affix:sub -> sub -> bool",
          "documentation": "is_prefix is like String.is_prefix. Only bytes are compared, affix can be on a different base string.",
          "anchor": "val-is_prefix"
        },
        {
          "kind": "value",
          "name": "is_infix",
          "signature": "val is_infix : affix:sub -> sub -> bool",
          "documentation": "is_infix is like String.is_infix. Only bytes are compared, affix can be on a different base string.",
          "anchor": "val-is_infix"
        },
        {
          "kind": "value",
          "name": "is_suffix",
          "signature": "val is_suffix : affix:sub -> sub -> bool",
          "documentation": "is_suffix is like String.is_suffix. Only bytes are compared, affix can be on a different base string.",
          "anchor": "val-is_suffix"
        },
        {
          "kind": "value",
          "name": "for_all",
          "signature": "val for_all : (char -> bool) -> sub -> bool",
          "documentation": "for_all is like String.for_all on the substring.",
          "anchor": "val-for_all"
        },
        {
          "kind": "value",
          "name": "exists",
          "signature": "val exists : (char -> bool) -> sub -> bool",
          "documentation": "exists is like String.exists on the substring.",
          "anchor": "val-exists"
        },
        {
          "kind": "value",
          "name": "same_base",
          "signature": "val same_base : sub -> sub -> bool",
          "documentation": "same_base s s' is true iff the substrings s and s' have the same base string according to physical equality.",
          "anchor": "val-same_base"
        },
        {
          "kind": "value",
          "name": "equal_bytes",
          "signature": "val equal_bytes : sub -> sub -> bool",
          "documentation": "equal_bytes s s' is true iff the substrings s and s' have exactly the same bytes. The substrings can be on a different base string.",
          "anchor": "val-equal_bytes"
        },
        {
          "kind": "value",
          "name": "compare_bytes",
          "signature": "val compare_bytes : sub -> sub -> int",
          "documentation": "compare_bytes s s' compares the bytes of s and s' in lexicographical order. The substrings can be on a different base string.",
          "anchor": "val-compare_bytes"
        },
        {
          "kind": "value",
          "name": "equal",
          "signature": "val equal : sub -> sub -> bool",
          "documentation": "equal s s' is true iff s and s' have the same positions.",
          "anchor": "val-equal"
        },
        {
          "kind": "value",
          "name": "compare",
          "signature": "val compare : sub -> sub -> int",
          "documentation": "compare s s' compares the positions of s and s' in lexicographical order.",
          "anchor": "val-compare"
        },
        {
          "kind": "value",
          "name": "with_range",
          "signature": "val with_range : ?first:int -> ?len:int -> sub -> sub",
          "documentation": "with_range is like String.sub_with_range. The indices are the substring's zero-based ones, not those in the base string.",
          "anchor": "val-with_range"
        },
        {
          "kind": "value",
          "name": "with_index_range",
          "signature": "val with_index_range : ?first:int -> ?last:int -> sub -> sub",
          "documentation": "with_index_range is like String.sub_with_index_range. The indices are the substring's zero-based ones, not those in the base string.",
          "anchor": "val-with_index_range"
        },
        {
          "kind": "value",
          "name": "trim",
          "signature": "val trim : ?drop:(char -> bool) -> sub -> sub",
          "documentation": "trim is like String.trim. If all bytes are dropped returns an empty string located in the middle of the argument.",
          "anchor": "val-trim"
        },
        {
          "kind": "value",
          "name": "span",
          "signature": "val span : ?rev:bool ->\n  ?min:int ->\n  ?max:int ->\n  ?sat:(char -> bool) ->\n  sub ->\n  sub * sub",
          "documentation": "span is like String.span. For a substring s a left empty span is start s and a right empty span is stop s.",
          "anchor": "val-span"
        },
        {
          "kind": "value",
          "name": "take",
          "signature": "val take : ?rev:bool ->\n  ?min:int ->\n  ?max:int ->\n  ?sat:(char -> bool) ->\n  sub ->\n  sub",
          "documentation": "take is like String.take.",
          "anchor": "val-take"
        },
        {
          "kind": "value",
          "name": "drop",
          "signature": "val drop : ?rev:bool ->\n  ?min:int ->\n  ?max:int ->\n  ?sat:(char -> bool) ->\n  sub ->\n  sub",
          "documentation": "drop is like String.drop.",
          "anchor": "val-drop"
        },
        {
          "kind": "value",
          "name": "cut",
          "signature": "val cut : ?rev:bool -> sep:sub -> sub -> (sub * sub) option",
          "documentation": "cut is like String.cut. sep can be on a different base string",
          "anchor": "val-cut"
        },
        {
          "kind": "value",
          "name": "cuts",
          "signature": "val cuts : ?rev:bool -> ?empty:bool -> sep:sub -> sub -> sub list",
          "documentation": "cuts is like String.cuts. sep can be on a different base string",
          "anchor": "val-cuts"
        },
        {
          "kind": "value",
          "name": "fields",
          "signature": "val fields : ?empty:bool -> ?is_sep:(char -> bool) -> sub -> sub list",
          "documentation": "fields is like String.fields.",
          "anchor": "val-fields"
        },
        {
          "kind": "value",
          "name": "find",
          "signature": "val find : ?rev:bool -> (char -> bool) -> sub -> sub option",
          "documentation": "find ~rev sat s is the substring of s (if any) that spans the first byte that satisfies sat in s after position start s (rev is false, default) or before stop s (rev is true). None is returned if there is no matching byte in s.",
          "anchor": "val-find"
        },
        {
          "kind": "value",
          "name": "find_sub",
          "signature": "val find_sub : ?rev:bool -> sub:sub -> sub -> sub option",
          "documentation": "find_sub ~rev ~sub s is the substring of s (if any) that spans the first match of sub in s after position start s (rev is false, default) or before stop s (rev is true). Only bytes are compared and sub can be on a different base string. None is returned if there is no match of sub in s.",
          "anchor": "val-find_sub"
        },
        {
          "kind": "value",
          "name": "filter",
          "signature": "val filter : (char -> bool) -> sub -> sub",
          "documentation": "filter sat s is like String.filter. The result is on a base string that holds only the filtered bytes.",
          "anchor": "val-filter"
        },
        {
          "kind": "value",
          "name": "filter_map",
          "signature": "val filter_map : (char -> char option) -> sub -> sub",
          "documentation": "filter_map f s is like String.filter_map. The result is on a base string that holds only the filtered bytes.",
          "anchor": "val-filter_map"
        },
        {
          "kind": "value",
          "name": "map",
          "signature": "val map : (char -> char) -> sub -> sub",
          "documentation": "map is like String.map. The result is on a base string that holds only the mapped bytes.",
          "anchor": "val-map"
        },
        {
          "kind": "value",
          "name": "mapi",
          "signature": "val mapi : (int -> char -> char) -> sub -> sub",
          "documentation": "mapi is like String.mapi. The result is on a base string that holds only the mapped bytes. The indices are the substring's zero-based ones, not those in the base string.",
          "anchor": "val-mapi"
        },
        {
          "kind": "value",
          "name": "fold_left",
          "signature": "val fold_left : ('a -> char -> 'a) -> 'a -> sub -> 'a",
          "documentation": "fold_left is like String.fold_left.",
          "anchor": "val-fold_left"
        },
        {
          "kind": "value",
          "name": "fold_right",
          "signature": "val fold_right : (char -> 'a -> 'a) -> sub -> 'a -> 'a",
          "documentation": "fold_right is like String.fold_right.",
          "anchor": "val-fold_right"
        },
        {
          "kind": "value",
          "name": "iter",
          "signature": "val iter : (char -> unit) -> sub -> unit",
          "documentation": "iter is like String.iter.",
          "anchor": "val-iter"
        },
        {
          "kind": "value",
          "name": "iteri",
          "signature": "val iteri : (int -> char -> unit) -> sub -> unit",
          "documentation": "iteri is like String.iteri. The indices are the substring's zero-based ones, not those in the base string.",
          "anchor": "val-iteri"
        },
        {
          "kind": "value",
          "name": "pp",
          "signature": "val pp : Format.formatter -> sub -> unit",
          "documentation": "pp ppf s prints s's bytes on ppf.",
          "anchor": "val-pp"
        },
        {
          "kind": "value",
          "name": "dump",
          "signature": "val dump : Format.formatter -> sub -> unit",
          "documentation": "dump ppf s prints s as a syntactically valid OCaml string on ppf using Ascii.escape_string.",
          "anchor": "val-dump"
        },
        {
          "kind": "value",
          "name": "dump_raw",
          "signature": "val dump_raw : Format.formatter -> sub -> unit",
          "documentation": "dump_raw ppf s prints an unspecified raw internal representation of s on ppf.",
          "anchor": "val-dump_raw"
        },
        {
          "kind": "value",
          "name": "of_char",
          "signature": "val of_char : char -> sub",
          "documentation": "of_char c is a string that contains the byte c.",
          "anchor": "val-of_char"
        },
        {
          "kind": "value",
          "name": "to_char",
          "signature": "val to_char : sub -> char option",
          "documentation": "to_char s is the single byte in s or None if there is no byte or more than one in s.",
          "anchor": "val-to_char"
        },
        {
          "kind": "value",
          "name": "of_bool",
          "signature": "val of_bool : bool -> sub",
          "documentation": "of_bool b is a string representation for b. Relies on Stdlib.string_of_bool.",
          "anchor": "val-of_bool"
        },
        {
          "kind": "value",
          "name": "to_bool",
          "signature": "val to_bool : sub -> bool option",
          "documentation": "to_bool s is a bool from s, if any. Relies on Stdlib.bool_of_string.",
          "anchor": "val-to_bool"
        },
        {
          "kind": "value",
          "name": "of_int",
          "signature": "val of_int : int -> sub",
          "documentation": "of_int i is a string representation for i. Relies on Stdlib.string_of_int.",
          "anchor": "val-of_int"
        },
        {
          "kind": "value",
          "name": "to_int",
          "signature": "val to_int : sub -> int option",
          "documentation": "to_int is an int from s, if any. Relies on Stdlib.int_of_string.",
          "anchor": "val-to_int"
        },
        {
          "kind": "value",
          "name": "of_nativeint",
          "signature": "val of_nativeint : nativeint -> sub",
          "documentation": "of_nativeint i is a string representation for i. Relies on Nativeint.of_string.",
          "anchor": "val-of_nativeint"
        },
        {
          "kind": "value",
          "name": "to_nativeint",
          "signature": "val to_nativeint : sub -> nativeint option",
          "documentation": "to_nativeint is an nativeint from s, if any. Relies on Nativeint.to_string.",
          "anchor": "val-to_nativeint"
        },
        {
          "kind": "value",
          "name": "of_int32",
          "signature": "val of_int32 : int32 -> sub",
          "documentation": "of_int32 i is a string representation for i. Relies on Int32.of_string.",
          "anchor": "val-of_int32"
        },
        {
          "kind": "value",
          "name": "to_int32",
          "signature": "val to_int32 : sub -> int32 option",
          "documentation": "to_int32 is an int32 from s, if any. Relies on Int32.to_string.",
          "anchor": "val-to_int32"
        },
        {
          "kind": "value",
          "name": "of_int64",
          "signature": "val of_int64 : int64 -> sub",
          "documentation": "of_int64 i is a string representation for i. Relies on Int64.of_string.",
          "anchor": "val-of_int64"
        },
        {
          "kind": "value",
          "name": "to_int64",
          "signature": "val to_int64 : sub -> int64 option",
          "documentation": "to_int64 is an int64 from s, if any. Relies on Int64.to_string.",
          "anchor": "val-to_int64"
        },
        {
          "kind": "value",
          "name": "of_float",
          "signature": "val of_float : float -> sub",
          "documentation": "of_float f is a string representation for f. Relies on Stdlib.string_of_float.",
          "anchor": "val-of_float"
        },
        {
          "kind": "value",
          "name": "to_float",
          "signature": "val to_float : sub -> float option",
          "documentation": "to_float s is a float from s, if any. Relies on Stdlib.float_of_string.",
          "anchor": "val-to_float"
        }
      ],
      "modules": [],
      "module_documentation": "Substrings.\nA substring defines a possibly empty subsequence of bytes in a base string.\nThe positions of a string s of length l are the slits found before each byte and after the last byte of the string. They are labelled from left to right by increasing number in the range [0;l].\nThe ith byte index is between positions i and i+1.\nFormally we define a substring of s as being a subsequence of bytes defined by a start and a stop position. The former is always smaller or equal to the latter. When both positions are equal the substring is empty. Note that for a given base string there are as many empty substrings as there are positions in the string.\nLike in strings, we index the bytes of a substring using zero-based indices.\nSee how to use substrings to parse data.",
      "sections": [
        {
          "kind": "section",
          "title": "Substrings",
          "level": 2,
          "content": ""
        },
        {
          "kind": "section",
          "title": "Stretching substrings",
          "level": 2,
          "content": "See the graphical guide."
        },
        {
          "kind": "section",
          "title": "Appending substrings",
          "level": 2,
          "content": ""
        },
        {
          "kind": "section",
          "title": "Predicates",
          "level": 2,
          "content": ""
        },
        {
          "kind": "section",
          "title": "Extracting substrings",
          "level": 2,
          "content": "Extracted substrings are always on the same base string as the substring s acted upon."
        },
        {
          "kind": "section",
          "title": "Traversing substrings",
          "level": 2,
          "content": ""
        },
        {
          "kind": "section",
          "title": "Pretty printing",
          "level": 2,
          "content": ""
        },
        {
          "kind": "section",
          "title": "OCaml base type conversions",
          "level": 2,
          "content": ""
        },
        {
          "kind": "section",
          "title": "Substring stretching graphical guide",
          "level": 2,
          "content": ""
        }
      ],
      "package": "astring",
      "version": "0.8.5",
      "file_path": "doc/astring/Astring-String-Sub.md",
      "library": "astring",
      "module_path": [
        "Astring",
        "String",
        "Sub"
      ]
    },
    {
      "elements": [
        {
          "kind": "section",
          "title": "String maps",
          "level": 2,
          "content": ""
        },
        {
          "kind": "value",
          "name": "min_binding",
          "signature": "val min_binding : 'a t -> (string * 'a) option",
          "documentation": "Exception safe Map.S.min_binding.",
          "anchor": "val-min_binding"
        },
        {
          "kind": "value",
          "name": "get_min_binding",
          "signature": "val get_min_binding : 'a t -> string * 'a",
          "documentation": "get_min_binding is like min_binding but",
          "anchor": "val-get_min_binding"
        },
        {
          "kind": "value",
          "name": "max_binding",
          "signature": "val max_binding : 'a t -> (string * 'a) option",
          "documentation": "Exception safe Map.S.max_binding.",
          "anchor": "val-max_binding"
        },
        {
          "kind": "value",
          "name": "get_max_binding",
          "signature": "val get_max_binding : 'a t -> string * 'a",
          "documentation": "get_max_binding is like max_binding but",
          "anchor": "val-get_max_binding"
        },
        {
          "kind": "value",
          "name": "choose",
          "signature": "val choose : 'a t -> (string * 'a) option",
          "documentation": "Exception safe Map.S.choose.",
          "anchor": "val-choose"
        },
        {
          "kind": "value",
          "name": "get_any_binding",
          "signature": "val get_any_binding : 'a t -> string * 'a",
          "documentation": "get_any_binding is like choose but",
          "anchor": "val-get_any_binding"
        },
        {
          "kind": "value",
          "name": "find",
          "signature": "val find : string -> 'a t -> 'a option",
          "documentation": "Exception safe Map.S.find.",
          "anchor": "val-find"
        },
        {
          "kind": "value",
          "name": "get",
          "signature": "val get : string -> 'a t -> 'a",
          "documentation": "get k m is like Map.S.find but raises Invalid_argument if k is not bound in m.",
          "anchor": "val-get"
        },
        {
          "kind": "value",
          "name": "dom",
          "signature": "val dom : 'a t -> set",
          "documentation": "dom m is the domain of m.",
          "anchor": "val-dom"
        },
        {
          "kind": "value",
          "name": "of_list",
          "signature": "val of_list : (string * 'a) list -> 'a t",
          "documentation": "of_list bs is List.fold_left (fun m (k, v) -> add k v m) empty bs.",
          "anchor": "val-of_list"
        },
        {
          "kind": "value",
          "name": "of_stdlib_map",
          "signature": "val of_stdlib_map : 'a Map.Make(String).t -> 'a t",
          "documentation": "of_stdlib_map m is a map from the stdlib-compatible map m.",
          "anchor": "val-of_stdlib_map"
        },
        {
          "kind": "value",
          "name": "to_stdlib_map",
          "signature": "val to_stdlib_map : 'a t -> 'a Map.Make(String).t",
          "documentation": "to_stdlib_map m is the stdlib-compatible map equivalent to m.",
          "anchor": "val-to_stdlib_map"
        },
        {
          "kind": "value",
          "name": "pp",
          "signature": "val pp : ?sep:(Format.formatter -> unit -> unit) ->\n  (Format.formatter -> (string * 'a) -> unit) ->\n  Format.formatter ->\n  'a t ->\n  unit",
          "documentation": "pp ~sep pp_binding ppf m formats the bindings of m on ppf. Each binding is formatted with pp_binding and bindings are separated by sep (defaults to Format.pp_print_cut). If the map is empty leaves ppf untouched.",
          "anchor": "val-pp"
        },
        {
          "kind": "value",
          "name": "dump",
          "signature": "val dump : (Format.formatter -> 'a -> unit) -> Format.formatter -> 'a t -> unit",
          "documentation": "dump pp_v ppf m prints an unspecified representation of m on ppf using pp_v to print the map codomain elements.",
          "anchor": "val-dump"
        },
        {
          "kind": "value",
          "name": "dump_string_map",
          "signature": "val dump_string_map : Format.formatter -> string t -> unit",
          "documentation": "dump_string_map ppf m prints an unspecified representation of the string map m on ppf.",
          "anchor": "val-dump_string_map"
        }
      ],
      "types": [],
      "values": [
        {
          "kind": "value",
          "name": "min_binding",
          "signature": "val min_binding : 'a t -> (string * 'a) option",
          "documentation": "Exception safe Map.S.min_binding.",
          "anchor": "val-min_binding"
        },
        {
          "kind": "value",
          "name": "get_min_binding",
          "signature": "val get_min_binding : 'a t -> string * 'a",
          "documentation": "get_min_binding is like min_binding but",
          "anchor": "val-get_min_binding"
        },
        {
          "kind": "value",
          "name": "max_binding",
          "signature": "val max_binding : 'a t -> (string * 'a) option",
          "documentation": "Exception safe Map.S.max_binding.",
          "anchor": "val-max_binding"
        },
        {
          "kind": "value",
          "name": "get_max_binding",
          "signature": "val get_max_binding : 'a t -> string * 'a",
          "documentation": "get_max_binding is like max_binding but",
          "anchor": "val-get_max_binding"
        },
        {
          "kind": "value",
          "name": "choose",
          "signature": "val choose : 'a t -> (string * 'a) option",
          "documentation": "Exception safe Map.S.choose.",
          "anchor": "val-choose"
        },
        {
          "kind": "value",
          "name": "get_any_binding",
          "signature": "val get_any_binding : 'a t -> string * 'a",
          "documentation": "get_any_binding is like choose but",
          "anchor": "val-get_any_binding"
        },
        {
          "kind": "value",
          "name": "find",
          "signature": "val find : string -> 'a t -> 'a option",
          "documentation": "Exception safe Map.S.find.",
          "anchor": "val-find"
        },
        {
          "kind": "value",
          "name": "get",
          "signature": "val get : string -> 'a t -> 'a",
          "documentation": "get k m is like Map.S.find but raises Invalid_argument if k is not bound in m.",
          "anchor": "val-get"
        },
        {
          "kind": "value",
          "name": "dom",
          "signature": "val dom : 'a t -> set",
          "documentation": "dom m is the domain of m.",
          "anchor": "val-dom"
        },
        {
          "kind": "value",
          "name": "of_list",
          "signature": "val of_list : (string * 'a) list -> 'a t",
          "documentation": "of_list bs is List.fold_left (fun m (k, v) -> add k v m) empty bs.",
          "anchor": "val-of_list"
        },
        {
          "kind": "value",
          "name": "of_stdlib_map",
          "signature": "val of_stdlib_map : 'a Map.Make(String).t -> 'a t",
          "documentation": "of_stdlib_map m is a map from the stdlib-compatible map m.",
          "anchor": "val-of_stdlib_map"
        },
        {
          "kind": "value",
          "name": "to_stdlib_map",
          "signature": "val to_stdlib_map : 'a t -> 'a Map.Make(String).t",
          "documentation": "to_stdlib_map m is the stdlib-compatible map equivalent to m.",
          "anchor": "val-to_stdlib_map"
        },
        {
          "kind": "value",
          "name": "pp",
          "signature": "val pp : ?sep:(Format.formatter -> unit -> unit) ->\n  (Format.formatter -> (string * 'a) -> unit) ->\n  Format.formatter ->\n  'a t ->\n  unit",
          "documentation": "pp ~sep pp_binding ppf m formats the bindings of m on ppf. Each binding is formatted with pp_binding and bindings are separated by sep (defaults to Format.pp_print_cut). If the map is empty leaves ppf untouched.",
          "anchor": "val-pp"
        },
        {
          "kind": "value",
          "name": "dump",
          "signature": "val dump : (Format.formatter -> 'a -> unit) -> Format.formatter -> 'a t -> unit",
          "documentation": "dump pp_v ppf m prints an unspecified representation of m on ppf using pp_v to print the map codomain elements.",
          "anchor": "val-dump"
        },
        {
          "kind": "value",
          "name": "dump_string_map",
          "signature": "val dump_string_map : Format.formatter -> string t -> unit",
          "documentation": "dump_string_map ppf m prints an unspecified representation of the string map m on ppf.",
          "anchor": "val-dump_string_map"
        }
      ],
      "modules": [],
      "module_documentation": "String maps.",
      "sections": [
        {
          "kind": "section",
          "title": "String maps",
          "level": 2,
          "content": ""
        }
      ],
      "package": "astring",
      "version": "0.8.5",
      "file_path": "doc/astring/Astring-String-Map.md",
      "library": "astring",
      "module_path": [
        "Astring",
        "String",
        "Map"
      ]
    },
    {
      "elements": [
        {
          "kind": "section",
          "title": "Predicates",
          "level": 2,
          "content": ""
        },
        {
          "kind": "value",
          "name": "is_valid",
          "signature": "val is_valid : string -> bool",
          "documentation": "is_valid s is true iff only for all indices i of s, s.[i] is an US-ASCII character, i.e. a byte in the range [0x00;0x7F].",
          "anchor": "val-is_valid"
        },
        {
          "kind": "section",
          "title": "Casing transforms",
          "level": 2,
          "content": "The following functions act only on US-ASCII code points that is on bytes in range [0x00;0x7F], leaving any other byte intact. The functions can be safely used on UTF-8 encoded strings; they will of course only deal with US-ASCII casings."
        },
        {
          "kind": "value",
          "name": "uppercase",
          "signature": "val uppercase : string -> string",
          "documentation": "uppercase s is s with US-ASCII characters 'a' to 'z' mapped to 'A' to 'Z'.",
          "anchor": "val-uppercase"
        },
        {
          "kind": "value",
          "name": "lowercase",
          "signature": "val lowercase : string -> string",
          "documentation": "lowercase s is s with US-ASCII characters 'A' to 'Z' mapped to 'a' to 'z'.",
          "anchor": "val-lowercase"
        },
        {
          "kind": "value",
          "name": "capitalize",
          "signature": "val capitalize : string -> string",
          "documentation": "capitalize s is like uppercase but performs the map only on s.[0].",
          "anchor": "val-capitalize"
        },
        {
          "kind": "value",
          "name": "uncapitalize",
          "signature": "val uncapitalize : string -> string",
          "documentation": "uncapitalize s is like lowercase but performs the map only on s.[0].",
          "anchor": "val-uncapitalize"
        },
        {
          "kind": "section",
          "title": "Escaping to printable US-ASCII",
          "level": 2,
          "content": ""
        },
        {
          "kind": "value",
          "name": "escape",
          "signature": "val escape : string -> string",
          "documentation": "escape s is s with:",
          "anchor": "val-escape"
        },
        {
          "kind": "value",
          "name": "unescape",
          "signature": "val unescape : string -> string option",
          "documentation": "unescape s unescapes what escape did. The letters of hex escapes can be upper, lower or mixed case, and any two letter hex escape is decoded to its corresponding byte. Any other escape not defined by escape or truncated escape makes the function return None.",
          "anchor": "val-unescape"
        },
        {
          "kind": "value",
          "name": "escape_string",
          "signature": "val escape_string : string -> string",
          "documentation": "escape_string s is like escape except it escapes s according to OCaml's lexical conventions for strings with:",
          "anchor": "val-escape_string"
        },
        {
          "kind": "value",
          "name": "unescape_string",
          "signature": "val unescape_string : string -> string option",
          "documentation": "unescape_string is to escape_string what unescape is to escape and also additionally unescapes the sequence \"\\\\'\" (0x5C,0x27) to \"'\" (0x27).",
          "anchor": "val-unescape_string"
        }
      ],
      "types": [],
      "values": [
        {
          "kind": "value",
          "name": "is_valid",
          "signature": "val is_valid : string -> bool",
          "documentation": "is_valid s is true iff only for all indices i of s, s.[i] is an US-ASCII character, i.e. a byte in the range [0x00;0x7F].",
          "anchor": "val-is_valid"
        },
        {
          "kind": "value",
          "name": "uppercase",
          "signature": "val uppercase : string -> string",
          "documentation": "uppercase s is s with US-ASCII characters 'a' to 'z' mapped to 'A' to 'Z'.",
          "anchor": "val-uppercase"
        },
        {
          "kind": "value",
          "name": "lowercase",
          "signature": "val lowercase : string -> string",
          "documentation": "lowercase s is s with US-ASCII characters 'A' to 'Z' mapped to 'a' to 'z'.",
          "anchor": "val-lowercase"
        },
        {
          "kind": "value",
          "name": "capitalize",
          "signature": "val capitalize : string -> string",
          "documentation": "capitalize s is like uppercase but performs the map only on s.[0].",
          "anchor": "val-capitalize"
        },
        {
          "kind": "value",
          "name": "uncapitalize",
          "signature": "val uncapitalize : string -> string",
          "documentation": "uncapitalize s is like lowercase but performs the map only on s.[0].",
          "anchor": "val-uncapitalize"
        },
        {
          "kind": "value",
          "name": "escape",
          "signature": "val escape : string -> string",
          "documentation": "escape s is s with:",
          "anchor": "val-escape"
        },
        {
          "kind": "value",
          "name": "unescape",
          "signature": "val unescape : string -> string option",
          "documentation": "unescape s unescapes what escape did. The letters of hex escapes can be upper, lower or mixed case, and any two letter hex escape is decoded to its corresponding byte. Any other escape not defined by escape or truncated escape makes the function return None.",
          "anchor": "val-unescape"
        },
        {
          "kind": "value",
          "name": "escape_string",
          "signature": "val escape_string : string -> string",
          "documentation": "escape_string s is like escape except it escapes s according to OCaml's lexical conventions for strings with:",
          "anchor": "val-escape_string"
        },
        {
          "kind": "value",
          "name": "unescape_string",
          "signature": "val unescape_string : string -> string option",
          "documentation": "unescape_string is to escape_string what unescape is to escape and also additionally unescapes the sequence \"\\\\'\" (0x5C,0x27) to \"'\" (0x27).",
          "anchor": "val-unescape_string"
        }
      ],
      "modules": [],
      "module_documentation": "US-ASCII string support.\nReferences.",
      "sections": [
        {
          "kind": "section",
          "title": "Predicates",
          "level": 2,
          "content": ""
        },
        {
          "kind": "section",
          "title": "Casing transforms",
          "level": 2,
          "content": "The following functions act only on US-ASCII code points that is on bytes in range [0x00;0x7F], leaving any other byte intact. The functions can be safely used on UTF-8 encoded strings; they will of course only deal with US-ASCII casings."
        },
        {
          "kind": "section",
          "title": "Escaping to printable US-ASCII",
          "level": 2,
          "content": ""
        }
      ],
      "package": "astring",
      "version": "0.8.5",
      "file_path": "doc/astring/Astring-String-Ascii.md",
      "library": "astring",
      "module_path": [
        "Astring",
        "String",
        "Ascii"
      ]
    },
    {
      "elements": [
        {
          "kind": "section",
          "title": "String",
          "level": 2,
          "content": ""
        },
        {
          "kind": "type",
          "name": "t",
          "signature": "type t = string",
          "anchor": "type-t"
        },
        {
          "kind": "value",
          "name": "empty",
          "signature": "val empty : string",
          "documentation": "empty is an empty string.",
          "anchor": "val-empty"
        },
        {
          "kind": "value",
          "name": "v",
          "signature": "val v : len:int -> (int -> char) -> string",
          "documentation": "v len f is a string s of length len with s.[i] = f i for all indices i of s. f is invoked in increasing index order.",
          "anchor": "val-v"
        },
        {
          "kind": "value",
          "name": "length",
          "signature": "val length : string -> int",
          "documentation": "length s is the number of bytes in s.",
          "anchor": "val-length"
        },
        {
          "kind": "value",
          "name": "get",
          "signature": "val get : string -> int -> char",
          "documentation": "get s i is the byte of s' at index i. This is equivalent to the s.[i] notation.",
          "anchor": "val-get"
        },
        {
          "kind": "value",
          "name": "get_byte",
          "signature": "val get_byte : string -> int -> int",
          "documentation": "get_byte s i is Char.to_int (get s i)",
          "anchor": "val-get_byte"
        },
        {
          "kind": "value",
          "name": "head",
          "signature": "val head : ?rev:bool -> string -> char option",
          "documentation": "head s is Some (get s h) with h = 0 if rev = false (default) or h = length s - 1 if rev = true. None is returned if s is empty.",
          "anchor": "val-head"
        },
        {
          "kind": "value",
          "name": "get_head",
          "signature": "val get_head : ?rev:bool -> string -> char",
          "documentation": "get_head s is like head but",
          "anchor": "val-get_head"
        },
        {
          "kind": "value",
          "name": "hash",
          "signature": "val hash : string -> int",
          "documentation": "hash s is Hashtbl.hashs.",
          "anchor": "val-hash"
        },
        {
          "kind": "section",
          "title": "Appending strings",
          "level": 2,
          "content": ""
        },
        {
          "kind": "value",
          "name": "append",
          "signature": "val append : string -> string -> string",
          "documentation": "append s s' appends s' to s. This is equivalent to s ^ s'.",
          "anchor": "val-append"
        },
        {
          "kind": "value",
          "name": "concat",
          "signature": "val concat : ?sep:string -> string list -> string",
          "documentation": "concat ~sep ss concatenates the list of strings ss, separating each consecutive elements in the list ss with sep (defaults to empty).",
          "anchor": "val-concat"
        },
        {
          "kind": "section",
          "title": "Predicates",
          "level": 2,
          "content": ""
        },
        {
          "kind": "value",
          "name": "is_empty",
          "signature": "val is_empty : string -> bool",
          "documentation": "is_empty s is length s = 0.",
          "anchor": "val-is_empty"
        },
        {
          "kind": "value",
          "name": "is_prefix",
          "signature": "val is_prefix : affix:string -> string -> bool",
          "documentation": "is_prefix ~affix s is true iff affix.[i] = s.[i] for all indices i of affix.",
          "anchor": "val-is_prefix"
        },
        {
          "kind": "value",
          "name": "is_infix",
          "signature": "val is_infix : affix:string -> string -> bool",
          "documentation": "is_infix ~affix s is true iff there exists an index j in s such that for all indices i of affix we have affix.[i] = s.[j + i].",
          "anchor": "val-is_infix"
        },
        {
          "kind": "value",
          "name": "is_suffix",
          "signature": "val is_suffix : affix:string -> string -> bool",
          "documentation": "is_suffix ~affix s is true iff affix.[n - i] = s.[m - i] for all indices i of affix with n = String.length affix - 1 and m = String.length s - 1.",
          "anchor": "val-is_suffix"
        },
        {
          "kind": "value",
          "name": "for_all",
          "signature": "val for_all : (char -> bool) -> string -> bool",
          "documentation": "for_all p s is true iff for all indices i of s, p s.[i] = true.",
          "anchor": "val-for_all"
        },
        {
          "kind": "value",
          "name": "exists",
          "signature": "val exists : (char -> bool) -> string -> bool",
          "documentation": "exists p s is true iff there exists an index i of s with p s.[i] = true.",
          "anchor": "val-exists"
        },
        {
          "kind": "value",
          "name": "equal",
          "signature": "val equal : string -> string -> bool",
          "documentation": "equal s s' is s = s'.",
          "anchor": "val-equal"
        },
        {
          "kind": "value",
          "name": "compare",
          "signature": "val compare : string -> string -> int",
          "documentation": "compare s s' is Stdlib.compare s s', it compares the byte sequences of s and s' in lexicographical order.",
          "anchor": "val-compare"
        },
        {
          "kind": "section",
          "title": "Extracting substrings",
          "level": 2,
          "content": "Tip. These functions extract substrings as new strings. Using substrings may be less wasteful and more flexible."
        },
        {
          "kind": "value",
          "name": "with_range",
          "signature": "val with_range : ?first:int -> ?len:int -> string -> string",
          "documentation": "with_range ~first ~len s are the consecutive bytes of s whose indices exist in the range [first;first + len - 1].",
          "anchor": "val-with_range"
        },
        {
          "kind": "value",
          "name": "with_index_range",
          "signature": "val with_index_range : ?first:int -> ?last:int -> string -> string",
          "documentation": "with_index_range ~first ~last s are the consecutive bytes of s whose indices exist in the range [first;last].",
          "anchor": "val-with_index_range"
        },
        {
          "kind": "value",
          "name": "trim",
          "signature": "val trim : ?drop:(char -> bool) -> string -> string",
          "documentation": "trim ~drop s is s with prefix and suffix bytes satisfying drop in s removed. drop defaults to Char.Ascii.is_white.",
          "anchor": "val-trim"
        },
        {
          "kind": "value",
          "name": "span",
          "signature": "val span : ?rev:bool ->\n  ?min:int ->\n  ?max:int ->\n  ?sat:(char -> bool) ->\n  string ->\n  string * string",
          "documentation": "span ~rev ~min ~max ~sat s is (l, r) where:",
          "anchor": "val-span"
        },
        {
          "kind": "value",
          "name": "take",
          "signature": "val take : ?rev:bool ->\n  ?min:int ->\n  ?max:int ->\n  ?sat:(char -> bool) ->\n  string ->\n  string",
          "documentation": "take ~rev ~min ~max ~sat s is the matching span of span without the remaining one. In other words:",
          "anchor": "val-take"
        },
        {
          "kind": "value",
          "name": "drop",
          "signature": "val drop : ?rev:bool ->\n  ?min:int ->\n  ?max:int ->\n  ?sat:(char -> bool) ->\n  string ->\n  string",
          "documentation": "drop ~rev ~min ~max ~sat s is the remaining span of span without the matching span. In other words:",
          "anchor": "val-drop"
        },
        {
          "kind": "value",
          "name": "cut",
          "signature": "val cut : ?rev:bool -> sep:string -> string -> (string * string) option",
          "documentation": "cut ~sep s is either the pair Some (l,r) of the two (possibly empty) substrings of s that are delimited by the first match of the non empty separator string sep or None if sep can't be matched in s. Matching starts from the beginning of s (rev is false, default) or the end (rev is true).",
          "anchor": "val-cut"
        },
        {
          "kind": "value",
          "name": "cuts",
          "signature": "val cuts : ?rev:bool -> ?empty:bool -> sep:string -> string -> string list",
          "documentation": "cuts sep s is the list of all substrings of s that are delimited by matches of the non empty separator string sep. Empty substrings are omitted in the list if empty is false (defaults to true).",
          "anchor": "val-cuts"
        },
        {
          "kind": "value",
          "name": "fields",
          "signature": "val fields : ?empty:bool -> ?is_sep:(char -> bool) -> string -> string list",
          "documentation": "fields ~empty ~is_sep s is the list of (possibly empty) substrings that are delimited by bytes for which is_sep is true. Empty substrings are omitted in the list if empty is false (defaults to true). is_sep defaults to Char.Ascii.is_white.",
          "anchor": "val-fields"
        },
        {
          "kind": "section",
          "title": "Substrings",
          "level": 2,
          "content": ""
        },
        {
          "kind": "type",
          "name": "sub",
          "signature": "type sub",
          "anchor": "type-sub"
        },
        {
          "kind": "value",
          "name": "sub",
          "signature": "val sub : ?start:int -> ?stop:int -> string -> sub",
          "documentation": "sub is Sub.v.",
          "anchor": "val-sub"
        },
        {
          "kind": "value",
          "name": "sub_with_range",
          "signature": "val sub_with_range : ?first:int -> ?len:int -> string -> sub",
          "documentation": "sub_with_range is like with_range but returns a substring value. If first is smaller than 0 the empty string at the start of s is returned. If first is greater than the last index of s the empty string at the end of s is returned.",
          "anchor": "val-sub_with_range"
        },
        {
          "kind": "value",
          "name": "sub_with_index_range",
          "signature": "val sub_with_index_range : ?first:int -> ?last:int -> string -> sub",
          "documentation": "sub_with_index_range is like with_index_range but returns a substring value. If first and last are smaller than 0 the empty string at the start of s is returned. If first and is greater than the last index of s the empty string at the end of s is returned. If first > last and first is an index of s the empty string at first is returned.",
          "anchor": "val-sub_with_index_range"
        },
        {
          "name": "Sub",
          "kind": "module"
        },
        {
          "kind": "section",
          "title": "Traversing strings",
          "level": 2,
          "content": ""
        },
        {
          "kind": "value",
          "name": "find",
          "signature": "val find : ?rev:bool -> ?start:int -> (char -> bool) -> string -> int option",
          "documentation": "find ~rev ~start sat s is:",
          "anchor": "val-find"
        },
        {
          "kind": "value",
          "name": "find_sub",
          "signature": "val find_sub : ?rev:bool -> ?start:int -> sub:string -> string -> int option",
          "documentation": "find_sub ~rev ~start ~sub s is:",
          "anchor": "val-find_sub"
        },
        {
          "kind": "value",
          "name": "filter",
          "signature": "val filter : (char -> bool) -> string -> string",
          "documentation": "filter sat s is the string made of the bytes of s that satisfy sat, in the same order.",
          "anchor": "val-filter"
        },
        {
          "kind": "value",
          "name": "filter_map",
          "signature": "val filter_map : (char -> char option) -> string -> string",
          "documentation": "filter_map f s is the string made of the bytes of s as mapped by f, in the same order.",
          "anchor": "val-filter_map"
        },
        {
          "kind": "value",
          "name": "map",
          "signature": "val map : (char -> char) -> string -> string",
          "documentation": "map f s is s' with s'.[i] = f s.[i] for all indices i of s. f is invoked in increasing index order.",
          "anchor": "val-map"
        },
        {
          "kind": "value",
          "name": "mapi",
          "signature": "val mapi : (int -> char -> char) -> string -> string",
          "documentation": "mapi f s is s' with s'.[i] = f i s.[i] for all indices i of s. f is invoked in increasing index order.",
          "anchor": "val-mapi"
        },
        {
          "kind": "value",
          "name": "fold_left",
          "signature": "val fold_left : ('a -> char -> 'a) -> 'a -> string -> 'a",
          "documentation": "fold_left f acc s is f (...(f (f acc s.[0]) s.[1])...) s.[m] with m = String.length s - 1.",
          "anchor": "val-fold_left"
        },
        {
          "kind": "value",
          "name": "fold_right",
          "signature": "val fold_right : (char -> 'a -> 'a) -> string -> 'a -> 'a",
          "documentation": "fold_right f s acc is f s.[0] (f s.[1] (...(f s.[m] acc) )...) with m = String.length s - 1.",
          "anchor": "val-fold_right"
        },
        {
          "kind": "value",
          "name": "iter",
          "signature": "val iter : (char -> unit) -> string -> unit",
          "documentation": "iter f s is f s.[0]; f s.[1]; ... f s.[m] with m = String.length s - 1.",
          "anchor": "val-iter"
        },
        {
          "kind": "value",
          "name": "iteri",
          "signature": "val iteri : (int -> char -> unit) -> string -> unit",
          "documentation": "iteri f s is f 0 s.[0]; f 1 s.[1]; ... f m s.[m] with m = String.length s - 1.",
          "anchor": "val-iteri"
        },
        {
          "kind": "section",
          "title": "Uniqueness",
          "level": 2,
          "content": ""
        },
        {
          "kind": "value",
          "name": "uniquify",
          "signature": "val uniquify : string list -> string list",
          "documentation": "uniquify ss is ss without duplicates, the list order is preserved.",
          "anchor": "val-uniquify"
        },
        {
          "kind": "section",
          "title": "Strings as US-ASCII character sequences",
          "level": 2,
          "content": ""
        },
        {
          "name": "Ascii",
          "kind": "module"
        },
        {
          "kind": "section",
          "title": "Pretty printing",
          "level": 2,
          "content": ""
        },
        {
          "kind": "value",
          "name": "pp",
          "signature": "val pp : Format.formatter -> string -> unit",
          "documentation": "pp ppf s prints s's bytes on ppf.",
          "anchor": "val-pp"
        },
        {
          "kind": "value",
          "name": "dump",
          "signature": "val dump : Format.formatter -> string -> unit",
          "documentation": "dump ppf s prints s as a syntactically valid OCaml string on ppf using Ascii.escape_string.",
          "anchor": "val-dump"
        },
        {
          "kind": "section",
          "title": "String sets and maps",
          "level": 2,
          "content": ""
        },
        {
          "kind": "type",
          "name": "set",
          "signature": "type set",
          "anchor": "type-set"
        },
        {
          "name": "Set",
          "kind": "module"
        },
        {
          "name": "Map",
          "kind": "module"
        },
        {
          "kind": "section",
          "title": "OCaml base type conversions",
          "level": 2,
          "content": ""
        },
        {
          "kind": "value",
          "name": "of_char",
          "signature": "val of_char : char -> string",
          "documentation": "of_char c is a string that contains the byte c.",
          "anchor": "val-of_char"
        },
        {
          "kind": "value",
          "name": "to_char",
          "signature": "val to_char : string -> char option",
          "documentation": "to_char s is the single byte in s or None if there is no byte or more than one in s.",
          "anchor": "val-to_char"
        },
        {
          "kind": "value",
          "name": "of_bool",
          "signature": "val of_bool : bool -> string",
          "documentation": "of_bool b is a string representation for b. Relies on Stdlib.string_of_bool.",
          "anchor": "val-of_bool"
        },
        {
          "kind": "value",
          "name": "to_bool",
          "signature": "val to_bool : string -> bool option",
          "documentation": "to_bool s is a bool from s, if any. Relies on Stdlib.bool_of_string.",
          "anchor": "val-to_bool"
        },
        {
          "kind": "value",
          "name": "of_int",
          "signature": "val of_int : int -> string",
          "documentation": "of_int i is a string representation for i. Relies on Stdlib.string_of_int.",
          "anchor": "val-of_int"
        },
        {
          "kind": "value",
          "name": "to_int",
          "signature": "val to_int : string -> int option",
          "documentation": "to_int is an int from s, if any. Relies on Stdlib.int_of_string.",
          "anchor": "val-to_int"
        },
        {
          "kind": "value",
          "name": "of_nativeint",
          "signature": "val of_nativeint : nativeint -> string",
          "documentation": "of_nativeint i is a string representation for i. Relies on Nativeint.of_string.",
          "anchor": "val-of_nativeint"
        },
        {
          "kind": "value",
          "name": "to_nativeint",
          "signature": "val to_nativeint : string -> nativeint option",
          "documentation": "to_nativeint is an nativeint from s, if any. Relies on Nativeint.to_string.",
          "anchor": "val-to_nativeint"
        },
        {
          "kind": "value",
          "name": "of_int32",
          "signature": "val of_int32 : int32 -> string",
          "documentation": "of_int32 i is a string representation for i. Relies on Int32.of_string.",
          "anchor": "val-of_int32"
        },
        {
          "kind": "value",
          "name": "to_int32",
          "signature": "val to_int32 : string -> int32 option",
          "documentation": "to_int32 is an int32 from s, if any. Relies on Int32.to_string.",
          "anchor": "val-to_int32"
        },
        {
          "kind": "value",
          "name": "of_int64",
          "signature": "val of_int64 : int64 -> string",
          "documentation": "of_int64 i is a string representation for i. Relies on Int64.of_string.",
          "anchor": "val-of_int64"
        },
        {
          "kind": "value",
          "name": "to_int64",
          "signature": "val to_int64 : string -> int64 option",
          "documentation": "to_int64 is an int64 from s, if any. Relies on Int64.to_string.",
          "anchor": "val-to_int64"
        },
        {
          "kind": "value",
          "name": "of_float",
          "signature": "val of_float : float -> string",
          "documentation": "of_float f is a string representation for f. Relies on Stdlib.string_of_float.",
          "anchor": "val-of_float"
        },
        {
          "kind": "value",
          "name": "to_float",
          "signature": "val to_float : string -> float option",
          "documentation": "to_float s is a float from s, if any. Relies on Stdlib.float_of_string.",
          "anchor": "val-to_float"
        }
      ],
      "types": [
        {
          "kind": "type",
          "name": "t",
          "signature": "type t = string",
          "anchor": "type-t"
        },
        {
          "kind": "type",
          "name": "sub",
          "signature": "type sub",
          "anchor": "type-sub"
        },
        {
          "kind": "type",
          "name": "set",
          "signature": "type set",
          "anchor": "type-set"
        }
      ],
      "values": [
        {
          "kind": "value",
          "name": "empty",
          "signature": "val empty : string",
          "documentation": "empty is an empty string.",
          "anchor": "val-empty"
        },
        {
          "kind": "value",
          "name": "v",
          "signature": "val v : len:int -> (int -> char) -> string",
          "documentation": "v len f is a string s of length len with s.[i] = f i for all indices i of s. f is invoked in increasing index order.",
          "anchor": "val-v"
        },
        {
          "kind": "value",
          "name": "length",
          "signature": "val length : string -> int",
          "documentation": "length s is the number of bytes in s.",
          "anchor": "val-length"
        },
        {
          "kind": "value",
          "name": "get",
          "signature": "val get : string -> int -> char",
          "documentation": "get s i is the byte of s' at index i. This is equivalent to the s.[i] notation.",
          "anchor": "val-get"
        },
        {
          "kind": "value",
          "name": "get_byte",
          "signature": "val get_byte : string -> int -> int",
          "documentation": "get_byte s i is Char.to_int (get s i)",
          "anchor": "val-get_byte"
        },
        {
          "kind": "value",
          "name": "head",
          "signature": "val head : ?rev:bool -> string -> char option",
          "documentation": "head s is Some (get s h) with h = 0 if rev = false (default) or h = length s - 1 if rev = true. None is returned if s is empty.",
          "anchor": "val-head"
        },
        {
          "kind": "value",
          "name": "get_head",
          "signature": "val get_head : ?rev:bool -> string -> char",
          "documentation": "get_head s is like head but",
          "anchor": "val-get_head"
        },
        {
          "kind": "value",
          "name": "hash",
          "signature": "val hash : string -> int",
          "documentation": "hash s is Hashtbl.hashs.",
          "anchor": "val-hash"
        },
        {
          "kind": "value",
          "name": "append",
          "signature": "val append : string -> string -> string",
          "documentation": "append s s' appends s' to s. This is equivalent to s ^ s'.",
          "anchor": "val-append"
        },
        {
          "kind": "value",
          "name": "concat",
          "signature": "val concat : ?sep:string -> string list -> string",
          "documentation": "concat ~sep ss concatenates the list of strings ss, separating each consecutive elements in the list ss with sep (defaults to empty).",
          "anchor": "val-concat"
        },
        {
          "kind": "value",
          "name": "is_empty",
          "signature": "val is_empty : string -> bool",
          "documentation": "is_empty s is length s = 0.",
          "anchor": "val-is_empty"
        },
        {
          "kind": "value",
          "name": "is_prefix",
          "signature": "val is_prefix : affix:string -> string -> bool",
          "documentation": "is_prefix ~affix s is true iff affix.[i] = s.[i] for all indices i of affix.",
          "anchor": "val-is_prefix"
        },
        {
          "kind": "value",
          "name": "is_infix",
          "signature": "val is_infix : affix:string -> string -> bool",
          "documentation": "is_infix ~affix s is true iff there exists an index j in s such that for all indices i of affix we have affix.[i] = s.[j + i].",
          "anchor": "val-is_infix"
        },
        {
          "kind": "value",
          "name": "is_suffix",
          "signature": "val is_suffix : affix:string -> string -> bool",
          "documentation": "is_suffix ~affix s is true iff affix.[n - i] = s.[m - i] for all indices i of affix with n = String.length affix - 1 and m = String.length s - 1.",
          "anchor": "val-is_suffix"
        },
        {
          "kind": "value",
          "name": "for_all",
          "signature": "val for_all : (char -> bool) -> string -> bool",
          "documentation": "for_all p s is true iff for all indices i of s, p s.[i] = true.",
          "anchor": "val-for_all"
        },
        {
          "kind": "value",
          "name": "exists",
          "signature": "val exists : (char -> bool) -> string -> bool",
          "documentation": "exists p s is true iff there exists an index i of s with p s.[i] = true.",
          "anchor": "val-exists"
        },
        {
          "kind": "value",
          "name": "equal",
          "signature": "val equal : string -> string -> bool",
          "documentation": "equal s s' is s = s'.",
          "anchor": "val-equal"
        },
        {
          "kind": "value",
          "name": "compare",
          "signature": "val compare : string -> string -> int",
          "documentation": "compare s s' is Stdlib.compare s s', it compares the byte sequences of s and s' in lexicographical order.",
          "anchor": "val-compare"
        },
        {
          "kind": "value",
          "name": "with_range",
          "signature": "val with_range : ?first:int -> ?len:int -> string -> string",
          "documentation": "with_range ~first ~len s are the consecutive bytes of s whose indices exist in the range [first;first + len - 1].",
          "anchor": "val-with_range"
        },
        {
          "kind": "value",
          "name": "with_index_range",
          "signature": "val with_index_range : ?first:int -> ?last:int -> string -> string",
          "documentation": "with_index_range ~first ~last s are the consecutive bytes of s whose indices exist in the range [first;last].",
          "anchor": "val-with_index_range"
        },
        {
          "kind": "value",
          "name": "trim",
          "signature": "val trim : ?drop:(char -> bool) -> string -> string",
          "documentation": "trim ~drop s is s with prefix and suffix bytes satisfying drop in s removed. drop defaults to Char.Ascii.is_white.",
          "anchor": "val-trim"
        },
        {
          "kind": "value",
          "name": "span",
          "signature": "val span : ?rev:bool ->\n  ?min:int ->\n  ?max:int ->\n  ?sat:(char -> bool) ->\n  string ->\n  string * string",
          "documentation": "span ~rev ~min ~max ~sat s is (l, r) where:",
          "anchor": "val-span"
        },
        {
          "kind": "value",
          "name": "take",
          "signature": "val take : ?rev:bool ->\n  ?min:int ->\n  ?max:int ->\n  ?sat:(char -> bool) ->\n  string ->\n  string",
          "documentation": "take ~rev ~min ~max ~sat s is the matching span of span without the remaining one. In other words:",
          "anchor": "val-take"
        },
        {
          "kind": "value",
          "name": "drop",
          "signature": "val drop : ?rev:bool ->\n  ?min:int ->\n  ?max:int ->\n  ?sat:(char -> bool) ->\n  string ->\n  string",
          "documentation": "drop ~rev ~min ~max ~sat s is the remaining span of span without the matching span. In other words:",
          "anchor": "val-drop"
        },
        {
          "kind": "value",
          "name": "cut",
          "signature": "val cut : ?rev:bool -> sep:string -> string -> (string * string) option",
          "documentation": "cut ~sep s is either the pair Some (l,r) of the two (possibly empty) substrings of s that are delimited by the first match of the non empty separator string sep or None if sep can't be matched in s. Matching starts from the beginning of s (rev is false, default) or the end (rev is true).",
          "anchor": "val-cut"
        },
        {
          "kind": "value",
          "name": "cuts",
          "signature": "val cuts : ?rev:bool -> ?empty:bool -> sep:string -> string -> string list",
          "documentation": "cuts sep s is the list of all substrings of s that are delimited by matches of the non empty separator string sep. Empty substrings are omitted in the list if empty is false (defaults to true).",
          "anchor": "val-cuts"
        },
        {
          "kind": "value",
          "name": "fields",
          "signature": "val fields : ?empty:bool -> ?is_sep:(char -> bool) -> string -> string list",
          "documentation": "fields ~empty ~is_sep s is the list of (possibly empty) substrings that are delimited by bytes for which is_sep is true. Empty substrings are omitted in the list if empty is false (defaults to true). is_sep defaults to Char.Ascii.is_white.",
          "anchor": "val-fields"
        },
        {
          "kind": "value",
          "name": "sub",
          "signature": "val sub : ?start:int -> ?stop:int -> string -> sub",
          "documentation": "sub is Sub.v.",
          "anchor": "val-sub"
        },
        {
          "kind": "value",
          "name": "sub_with_range",
          "signature": "val sub_with_range : ?first:int -> ?len:int -> string -> sub",
          "documentation": "sub_with_range is like with_range but returns a substring value. If first is smaller than 0 the empty string at the start of s is returned. If first is greater than the last index of s the empty string at the end of s is returned.",
          "anchor": "val-sub_with_range"
        },
        {
          "kind": "value",
          "name": "sub_with_index_range",
          "signature": "val sub_with_index_range : ?first:int -> ?last:int -> string -> sub",
          "documentation": "sub_with_index_range is like with_index_range but returns a substring value. If first and last are smaller than 0 the empty string at the start of s is returned. If first and is greater than the last index of s the empty string at the end of s is returned. If first > last and first is an index of s the empty string at first is returned.",
          "anchor": "val-sub_with_index_range"
        },
        {
          "kind": "value",
          "name": "find",
          "signature": "val find : ?rev:bool -> ?start:int -> (char -> bool) -> string -> int option",
          "documentation": "find ~rev ~start sat s is:",
          "anchor": "val-find"
        },
        {
          "kind": "value",
          "name": "find_sub",
          "signature": "val find_sub : ?rev:bool -> ?start:int -> sub:string -> string -> int option",
          "documentation": "find_sub ~rev ~start ~sub s is:",
          "anchor": "val-find_sub"
        },
        {
          "kind": "value",
          "name": "filter",
          "signature": "val filter : (char -> bool) -> string -> string",
          "documentation": "filter sat s is the string made of the bytes of s that satisfy sat, in the same order.",
          "anchor": "val-filter"
        },
        {
          "kind": "value",
          "name": "filter_map",
          "signature": "val filter_map : (char -> char option) -> string -> string",
          "documentation": "filter_map f s is the string made of the bytes of s as mapped by f, in the same order.",
          "anchor": "val-filter_map"
        },
        {
          "kind": "value",
          "name": "map",
          "signature": "val map : (char -> char) -> string -> string",
          "documentation": "map f s is s' with s'.[i] = f s.[i] for all indices i of s. f is invoked in increasing index order.",
          "anchor": "val-map"
        },
        {
          "kind": "value",
          "name": "mapi",
          "signature": "val mapi : (int -> char -> char) -> string -> string",
          "documentation": "mapi f s is s' with s'.[i] = f i s.[i] for all indices i of s. f is invoked in increasing index order.",
          "anchor": "val-mapi"
        },
        {
          "kind": "value",
          "name": "fold_left",
          "signature": "val fold_left : ('a -> char -> 'a) -> 'a -> string -> 'a",
          "documentation": "fold_left f acc s is f (...(f (f acc s.[0]) s.[1])...) s.[m] with m = String.length s - 1.",
          "anchor": "val-fold_left"
        },
        {
          "kind": "value",
          "name": "fold_right",
          "signature": "val fold_right : (char -> 'a -> 'a) -> string -> 'a -> 'a",
          "documentation": "fold_right f s acc is f s.[0] (f s.[1] (...(f s.[m] acc) )...) with m = String.length s - 1.",
          "anchor": "val-fold_right"
        },
        {
          "kind": "value",
          "name": "iter",
          "signature": "val iter : (char -> unit) -> string -> unit",
          "documentation": "iter f s is f s.[0]; f s.[1]; ... f s.[m] with m = String.length s - 1.",
          "anchor": "val-iter"
        },
        {
          "kind": "value",
          "name": "iteri",
          "signature": "val iteri : (int -> char -> unit) -> string -> unit",
          "documentation": "iteri f s is f 0 s.[0]; f 1 s.[1]; ... f m s.[m] with m = String.length s - 1.",
          "anchor": "val-iteri"
        },
        {
          "kind": "value",
          "name": "uniquify",
          "signature": "val uniquify : string list -> string list",
          "documentation": "uniquify ss is ss without duplicates, the list order is preserved.",
          "anchor": "val-uniquify"
        },
        {
          "kind": "value",
          "name": "pp",
          "signature": "val pp : Format.formatter -> string -> unit",
          "documentation": "pp ppf s prints s's bytes on ppf.",
          "anchor": "val-pp"
        },
        {
          "kind": "value",
          "name": "dump",
          "signature": "val dump : Format.formatter -> string -> unit",
          "documentation": "dump ppf s prints s as a syntactically valid OCaml string on ppf using Ascii.escape_string.",
          "anchor": "val-dump"
        },
        {
          "kind": "value",
          "name": "of_char",
          "signature": "val of_char : char -> string",
          "documentation": "of_char c is a string that contains the byte c.",
          "anchor": "val-of_char"
        },
        {
          "kind": "value",
          "name": "to_char",
          "signature": "val to_char : string -> char option",
          "documentation": "to_char s is the single byte in s or None if there is no byte or more than one in s.",
          "anchor": "val-to_char"
        },
        {
          "kind": "value",
          "name": "of_bool",
          "signature": "val of_bool : bool -> string",
          "documentation": "of_bool b is a string representation for b. Relies on Stdlib.string_of_bool.",
          "anchor": "val-of_bool"
        },
        {
          "kind": "value",
          "name": "to_bool",
          "signature": "val to_bool : string -> bool option",
          "documentation": "to_bool s is a bool from s, if any. Relies on Stdlib.bool_of_string.",
          "anchor": "val-to_bool"
        },
        {
          "kind": "value",
          "name": "of_int",
          "signature": "val of_int : int -> string",
          "documentation": "of_int i is a string representation for i. Relies on Stdlib.string_of_int.",
          "anchor": "val-of_int"
        },
        {
          "kind": "value",
          "name": "to_int",
          "signature": "val to_int : string -> int option",
          "documentation": "to_int is an int from s, if any. Relies on Stdlib.int_of_string.",
          "anchor": "val-to_int"
        },
        {
          "kind": "value",
          "name": "of_nativeint",
          "signature": "val of_nativeint : nativeint -> string",
          "documentation": "of_nativeint i is a string representation for i. Relies on Nativeint.of_string.",
          "anchor": "val-of_nativeint"
        },
        {
          "kind": "value",
          "name": "to_nativeint",
          "signature": "val to_nativeint : string -> nativeint option",
          "documentation": "to_nativeint is an nativeint from s, if any. Relies on Nativeint.to_string.",
          "anchor": "val-to_nativeint"
        },
        {
          "kind": "value",
          "name": "of_int32",
          "signature": "val of_int32 : int32 -> string",
          "documentation": "of_int32 i is a string representation for i. Relies on Int32.of_string.",
          "anchor": "val-of_int32"
        },
        {
          "kind": "value",
          "name": "to_int32",
          "signature": "val to_int32 : string -> int32 option",
          "documentation": "to_int32 is an int32 from s, if any. Relies on Int32.to_string.",
          "anchor": "val-to_int32"
        },
        {
          "kind": "value",
          "name": "of_int64",
          "signature": "val of_int64 : int64 -> string",
          "documentation": "of_int64 i is a string representation for i. Relies on Int64.of_string.",
          "anchor": "val-of_int64"
        },
        {
          "kind": "value",
          "name": "to_int64",
          "signature": "val to_int64 : string -> int64 option",
          "documentation": "to_int64 is an int64 from s, if any. Relies on Int64.to_string.",
          "anchor": "val-to_int64"
        },
        {
          "kind": "value",
          "name": "of_float",
          "signature": "val of_float : float -> string",
          "documentation": "of_float f is a string representation for f. Relies on Stdlib.string_of_float.",
          "anchor": "val-of_float"
        },
        {
          "kind": "value",
          "name": "to_float",
          "signature": "val to_float : string -> float option",
          "documentation": "to_float s is a float from s, if any. Relies on Stdlib.float_of_string.",
          "anchor": "val-to_float"
        }
      ],
      "modules": [
        {
          "name": "Sub",
          "kind": "module"
        },
        {
          "name": "Ascii",
          "kind": "module"
        },
        {
          "name": "Set",
          "kind": "module"
        },
        {
          "name": "Map",
          "kind": "module"
        }
      ],
      "module_documentation": "Strings, substrings, string sets and maps.\nA string s of length l is a zero-based indexed sequence of l bytes. An index i of s is an integer in the range [0;l-1], it represents the ith byte of s which can be accessed using the string indexing operator s.[i].\nImportant. OCaml's strings became immutable since 4.02. Whenever possible compile your code with the -safe-string option. This module does not expose any mutable operation on strings and assumes strings are immutable. See the porting guide.",
      "sections": [
        {
          "kind": "section",
          "title": "String",
          "level": 2,
          "content": ""
        },
        {
          "kind": "section",
          "title": "Appending strings",
          "level": 2,
          "content": ""
        },
        {
          "kind": "section",
          "title": "Predicates",
          "level": 2,
          "content": ""
        },
        {
          "kind": "section",
          "title": "Extracting substrings",
          "level": 2,
          "content": "Tip. These functions extract substrings as new strings. Using substrings may be less wasteful and more flexible."
        },
        {
          "kind": "section",
          "title": "Substrings",
          "level": 2,
          "content": ""
        },
        {
          "kind": "section",
          "title": "Traversing strings",
          "level": 2,
          "content": ""
        },
        {
          "kind": "section",
          "title": "Uniqueness",
          "level": 2,
          "content": ""
        },
        {
          "kind": "section",
          "title": "Strings as US-ASCII character sequences",
          "level": 2,
          "content": ""
        },
        {
          "kind": "section",
          "title": "Pretty printing",
          "level": 2,
          "content": ""
        },
        {
          "kind": "section",
          "title": "String sets and maps",
          "level": 2,
          "content": ""
        },
        {
          "kind": "section",
          "title": "OCaml base type conversions",
          "level": 2,
          "content": ""
        }
      ],
      "package": "astring",
      "version": "0.8.5",
      "file_path": "doc/astring/Astring-String.md",
      "library": "astring",
      "module_path": [
        "Astring",
        "String"
      ]
    },
    {
      "elements": [
        {
          "kind": "section",
          "title": "Bytes",
          "level": 2,
          "content": ""
        },
        {
          "kind": "type",
          "name": "t",
          "signature": "type t = char",
          "anchor": "type-t"
        },
        {
          "kind": "value",
          "name": "of_byte",
          "signature": "val of_byte : int -> char",
          "documentation": "of_byte b is a byte from b.",
          "anchor": "val-of_byte"
        },
        {
          "kind": "value",
          "name": "of_int",
          "signature": "val of_int : int -> char option",
          "documentation": "of_int b is a byte from b. None is returned if b is not in the range [0x00;0xFF].",
          "anchor": "val-of_int"
        },
        {
          "kind": "value",
          "name": "to_int",
          "signature": "val to_int : char -> int",
          "documentation": "to_int b is the byte b as an integer.",
          "anchor": "val-to_int"
        },
        {
          "kind": "value",
          "name": "hash",
          "signature": "val hash : char -> int",
          "documentation": "hash is Hashtbl.hash.",
          "anchor": "val-hash"
        },
        {
          "kind": "section",
          "title": "Predicates",
          "level": 2,
          "content": ""
        },
        {
          "kind": "value",
          "name": "equal",
          "signature": "val equal : char -> char -> bool",
          "documentation": "equal b b' is b = b'.",
          "anchor": "val-equal"
        },
        {
          "kind": "value",
          "name": "compare",
          "signature": "val compare : char -> char -> int",
          "documentation": "compare b b' is Stdlib.compareb b'.",
          "anchor": "val-compare"
        },
        {
          "kind": "section",
          "title": "Bytes as US-ASCII characters",
          "level": 2,
          "content": ""
        },
        {
          "name": "Ascii",
          "kind": "module"
        },
        {
          "kind": "section",
          "title": "Pretty printing",
          "level": 2,
          "content": ""
        },
        {
          "kind": "value",
          "name": "pp",
          "signature": "val pp : Format.formatter -> char -> unit",
          "documentation": "pp ppf c prints c on ppf.",
          "anchor": "val-pp"
        },
        {
          "kind": "value",
          "name": "dump",
          "signature": "val dump : Format.formatter -> char -> unit",
          "documentation": "dump ppf c prints c as a syntactically valid OCaml char on ppf using Ascii.escape_char",
          "anchor": "val-dump"
        }
      ],
      "types": [
        {
          "kind": "type",
          "name": "t",
          "signature": "type t = char",
          "anchor": "type-t"
        }
      ],
      "values": [
        {
          "kind": "value",
          "name": "of_byte",
          "signature": "val of_byte : int -> char",
          "documentation": "of_byte b is a byte from b.",
          "anchor": "val-of_byte"
        },
        {
          "kind": "value",
          "name": "of_int",
          "signature": "val of_int : int -> char option",
          "documentation": "of_int b is a byte from b. None is returned if b is not in the range [0x00;0xFF].",
          "anchor": "val-of_int"
        },
        {
          "kind": "value",
          "name": "to_int",
          "signature": "val to_int : char -> int",
          "documentation": "to_int b is the byte b as an integer.",
          "anchor": "val-to_int"
        },
        {
          "kind": "value",
          "name": "hash",
          "signature": "val hash : char -> int",
          "documentation": "hash is Hashtbl.hash.",
          "anchor": "val-hash"
        },
        {
          "kind": "value",
          "name": "equal",
          "signature": "val equal : char -> char -> bool",
          "documentation": "equal b b' is b = b'.",
          "anchor": "val-equal"
        },
        {
          "kind": "value",
          "name": "compare",
          "signature": "val compare : char -> char -> int",
          "documentation": "compare b b' is Stdlib.compareb b'.",
          "anchor": "val-compare"
        },
        {
          "kind": "value",
          "name": "pp",
          "signature": "val pp : Format.formatter -> char -> unit",
          "documentation": "pp ppf c prints c on ppf.",
          "anchor": "val-pp"
        },
        {
          "kind": "value",
          "name": "dump",
          "signature": "val dump : Format.formatter -> char -> unit",
          "documentation": "dump ppf c prints c as a syntactically valid OCaml char on ppf using Ascii.escape_char",
          "anchor": "val-dump"
        }
      ],
      "modules": [
        {
          "name": "Ascii",
          "kind": "module"
        }
      ],
      "module_documentation": "Characters (bytes in fact).",
      "sections": [
        {
          "kind": "section",
          "title": "Bytes",
          "level": 2,
          "content": ""
        },
        {
          "kind": "section",
          "title": "Predicates",
          "level": 2,
          "content": ""
        },
        {
          "kind": "section",
          "title": "Bytes as US-ASCII characters",
          "level": 2,
          "content": ""
        },
        {
          "kind": "section",
          "title": "Pretty printing",
          "level": 2,
          "content": ""
        }
      ],
      "package": "astring",
      "version": "0.8.5",
      "file_path": "doc/astring/Astring-Char.md",
      "library": "astring",
      "module_path": [
        "Astring",
        "Char"
      ]
    },
    {
      "elements": [
        {
          "kind": "section",
          "title": "String",
          "level": 2,
          "content": ""
        },
        {
          "kind": "value",
          "name": "strf",
          "signature": "val strf : ('a, Format.formatter, unit, string) format4 -> 'a",
          "documentation": "strf is Format.asprintf.",
          "anchor": "val-strf"
        },
        {
          "name": "Char",
          "kind": "module"
        },
        {
          "name": "String",
          "kind": "module"
        },
        {
          "kind": "section",
          "title": "Differences with the OCaml String module",
          "level": 2,
          "content": "First note that it is not a goal of Astring to maintain compatibility with the OCaml String module.\nIn Astring:"
        },
        {
          "kind": "section",
          "title": "Porting guide",
          "level": 2,
          "content": "Opening Astring at the top of a module that uses the OCaml standard library in a project that compiles with -safe-string will either result in typing errors or compatible behaviour except for uses of the String.trim function, see below.\nIf for some reason you can't compile your project with -safe-string this may not be a problem. However you have to make sure that your code does not depend on fresh strings being returned by functions of the String module. The functions of Astring.String assume strings to be immutable and thus do not always allocate fresh strings for their results. This is the case for example for the (^) operator redefinition: no string is allocated whenever one of its arguments is an empty string. That being said it is still better to first make your project compile with -safe-string and then port to Astring.\nThe String.sub function is renamed to String.with_range. If you are working with String.find you may find it easier to use String.with_index_range which takes indices as arguments and is thus directly usable with the result of String.find. But in general index based string processing should be frowned upon and replaced by substring extraction combinators."
        },
        {
          "kind": "section",
          "title": "Porting String.trim usages",
          "level": 3,
          "content": "The standard OCaml String.trim function only trims the characters ' ', '\\t', '\\n', '\\012', '\\r'. In Astring the default set adds vertical tab (0x0B) to the set to match the behaviour of the C isspace(3) function.\nIf you want to preserve the behaviour of the original function you can replace any use of String.trim with the following std_ocaml_trim function:"
        },
        {
          "kind": "section",
          "title": "Examples",
          "level": 2,
          "content": "We show how to use substrings to quickly devise LL(1) parsers. To keep it simple we do not implement precise error report, but note that it would be easy to add it by replacing the raise Exit calls by an exception with more information: we have everything at hand at these call points to report good error messages.\nThe first example parses version numbers structured as follows:"
        }
      ],
      "types": [],
      "values": [
        {
          "kind": "value",
          "name": "strf",
          "signature": "val strf : ('a, Format.formatter, unit, string) format4 -> 'a",
          "documentation": "strf is Format.asprintf.",
          "anchor": "val-strf"
        }
      ],
      "modules": [
        {
          "name": "Char",
          "kind": "module"
        },
        {
          "name": "String",
          "kind": "module"
        }
      ],
      "module_documentation": "Alternative Char and String modules.\nOpen the module to use it. This defines one value in your scope, redefines the (^) operator, the Char module and the String module.\nConsult the differences with the OCaml String module, the porting guide and a few examples.",
      "sections": [
        {
          "kind": "section",
          "title": "String",
          "level": 2,
          "content": ""
        },
        {
          "kind": "section",
          "title": "Differences with the OCaml String module",
          "level": 2,
          "content": "First note that it is not a goal of Astring to maintain compatibility with the OCaml String module.\nIn Astring:"
        },
        {
          "kind": "section",
          "title": "Porting guide",
          "level": 2,
          "content": "Opening Astring at the top of a module that uses the OCaml standard library in a project that compiles with -safe-string will either result in typing errors or compatible behaviour except for uses of the String.trim function, see below.\nIf for some reason you can't compile your project with -safe-string this may not be a problem. However you have to make sure that your code does not depend on fresh strings being returned by functions of the String module. The functions of Astring.String assume strings to be immutable and thus do not always allocate fresh strings for their results. This is the case for example for the (^) operator redefinition: no string is allocated whenever one of its arguments is an empty string. That being said it is still better to first make your project compile with -safe-string and then port to Astring.\nThe String.sub function is renamed to String.with_range. If you are working with String.find you may find it easier to use String.with_index_range which takes indices as arguments and is thus directly usable with the result of String.find. But in general index based string processing should be frowned upon and replaced by substring extraction combinators."
        },
        {
          "kind": "section",
          "title": "Porting String.trim usages",
          "level": 3,
          "content": "The standard OCaml String.trim function only trims the characters ' ', '\\t', '\\n', '\\012', '\\r'. In Astring the default set adds vertical tab (0x0B) to the set to match the behaviour of the C isspace(3) function.\nIf you want to preserve the behaviour of the original function you can replace any use of String.trim with the following std_ocaml_trim function:"
        },
        {
          "kind": "section",
          "title": "Examples",
          "level": 2,
          "content": "We show how to use substrings to quickly devise LL(1) parsers. To keep it simple we do not implement precise error report, but note that it would be easy to add it by replacing the raise Exit calls by an exception with more information: we have everything at hand at these call points to report good error messages.\nThe first example parses version numbers structured as follows:"
        }
      ],
      "package": "astring",
      "version": "0.8.5",
      "file_path": "doc/astring/Astring.md",
      "library": "astring",
      "module_path": [
        "Astring"
      ]
    }
  ],
  "package_documentation": {
    "LICENSE": {
      "content": "Copyright (c) 2016 The astring programmers\n\nPermission to use, copy, modify, and/or distribute this software for any purpose with or without fee is hereby granted, provided that the above copyright notice and this permission notice appear in all copies.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n",
      "type": "documentation",
      "package": "astring",
      "version": "0.8.5",
      "file_path": "doc/LICENSE.md",
      "library": null,
      "module_path": [
        "LICENSE"
      ]
    },
    "README": {
      "content": "\n### Astring  Alternative String module for OCaml\n\nv0.8.5\n\nAstring exposes an alternative `String` module for OCaml. This module tries to balance minimality and expressiveness for basic, index-free, string processing and provides types and functions for substrings, string sets and string maps.\n\nRemaining compatible with the OCaml `String` module is a non-goal. The `String` module exposed by Astring has exception safe functions, removes deprecated and rarely used functions, alters some signatures and names, adds a few missing functions and fully exploits OCaml's newfound string immutability.\n\nAstring depends only on the OCaml standard library. It is distributed under the ISC license.\n\nHome page: http://erratique.ch/software/astring\n\n\n### Installation\n\nAstring can be installed with `opam`:\n\n```ocaml\nopam install astring\n```\nIf you don't use `opam` consult the [`opam`](opam) file for build instructions.\n\n\n### Documentation\n\nThe documentation and API reference is automatically generated by `ocamldoc` from the interfaces. It can be consulted [online](http://erratique.ch/software/astring/doc/) or via `odig doc astring`.\n\n\n### Sample programs\n\nIf you installed Astring with `opam` sample programs are located in the directory `opam config var astring:doc`.\n",
      "type": "documentation",
      "package": "astring",
      "version": "0.8.5",
      "file_path": "doc/README.md",
      "library": null,
      "module_path": [
        "README"
      ]
    },
    "INDEX": {
      "content": "\n# astring\n\n\n## API\n\n\n### Library astring\n\n[`Astring`](./astring/Astring.md) Alternative Char and String modules.",
      "type": "documentation",
      "package": "astring",
      "version": "0.8.5",
      "file_path": "doc/index.md",
      "library": null,
      "module_path": [
        "doc"
      ]
    },
    "CHANGES": {
      "content": "\n### v0.8.5 2020-08-08 Zagreb\n\n- Support OCaml 4\\.12 injectiviy annotation of Map.S (\\#18). Thanks to Jeremy Yallop for the patch.\n\n### v0.8.4 2020-06-18 Zagreb\n\n- Handle `Pervasives`'s deprecation.\n- Require OCaml 4\\.05\n- Add conversions to/from Stdlib sets and maps. Thanks to Hezekiah M. Carty for the patch.\n\n### v0.8.3 2016-09-12 Zagreb\n\n- Fix potential segfault on 32-bit platforms due to overflow in `String[.Sub].concat`. Spotted by Jeremy Yallop in the standard library. The same bug was present in Astring.\n\n### v0.8.2 2016-08-26 Zagreb\n\n- Fix `String.Set.pp` not using the `sep` argument.\n- Build depend on topkg.\n- Relicense from BSD3 to ISC.\n\n### v0.8.1 2015-02-22 La Forclaz (VS)\n\n- Fix a bug in `String.Sub.span`.\n\n### v0.8.0 2015-12-14 Cambridge (UK)\n\nFirst release.\n",
      "type": "documentation",
      "package": "astring",
      "version": "0.8.5",
      "file_path": "doc/CHANGES.md",
      "library": null,
      "module_path": [
        "CHANGES"
      ]
    }
  },
  "documentation": {},
  "statistics": {
    "total_modules": 8,
    "total_types": 6,
    "total_values": 190,
    "total_submodules": 7,
    "total_elements": 240
  }
}