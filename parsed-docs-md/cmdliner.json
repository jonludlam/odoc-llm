{
  "package": "cmdliner",
  "version": "1.3.0",
  "metadata": null,
  "modules": [
    {
      "elements": [
        {
          "kind": "section",
          "title": "Terms",
          "level": 2,
          "content": ""
        },
        {
          "kind": "value",
          "name": "const",
          "signature": "val const : 'a -> 'a t",
          "documentation": "const v is a term that evaluates to v.",
          "anchor": "val-const"
        },
        {
          "kind": "value",
          "name": "app",
          "signature": "val app : ('a -> 'b) t -> 'a t -> 'b t",
          "documentation": "app is ($).",
          "anchor": "val-app"
        },
        {
          "kind": "value",
          "name": "map",
          "signature": "val map : ('a -> 'b) -> 'a t -> 'b t",
          "documentation": "map f t is app (const f) t.",
          "anchor": "val-map"
        },
        {
          "kind": "value",
          "name": "product",
          "signature": "val product : 'a t -> 'b t -> ('a * 'b) t",
          "documentation": "product t0 t1 is app (app (map (fun x y -> (x, y)) t0) t1)",
          "anchor": "val-product"
        },
        {
          "name": "Syntax",
          "kind": "module"
        },
        {
          "kind": "section",
          "title": "Interacting with Cmdliner's evaluation",
          "level": 2,
          "content": ""
        },
        {
          "kind": "value",
          "name": "term_result",
          "signature": "val term_result : ?usage:bool -> ('a, [ `Msg of string ]) result t -> 'a t",
          "documentation": "term_result ~usage t evaluates to",
          "anchor": "val-term_result"
        },
        {
          "kind": "value",
          "name": "cli_parse_result",
          "signature": "val cli_parse_result : ('a, [ `Msg of string ]) result t -> 'a t",
          "documentation": "cli_parse_result t is a term that evaluates to:",
          "anchor": "val-cli_parse_result"
        },
        {
          "kind": "value",
          "name": "main_name",
          "signature": "val main_name : string t",
          "documentation": "main_name is a term that evaluates to the main command name; that is the name of the tool.",
          "anchor": "val-main_name"
        },
        {
          "kind": "value",
          "name": "choice_names",
          "signature": "val choice_names : string list t",
          "documentation": "choice_names is a term that evaluates to the names of the commands that are children of the main command.",
          "anchor": "val-choice_names"
        },
        {
          "kind": "value",
          "name": "with_used_args",
          "signature": "val with_used_args : 'a t -> ('a * string list) t",
          "documentation": "with_used_args t is a term that evaluates to t tupled with the arguments from the command line that where used to evaluate t.",
          "anchor": "val-with_used_args"
        },
        {
          "kind": "value",
          "name": "ret",
          "signature": "val ret : 'a ret t -> 'a t",
          "documentation": "ret v is a term whose evaluation depends on the case to which v evaluates. With :",
          "anchor": "val-ret"
        },
        {
          "kind": "section",
          "title": "Deprecated Term evaluation interface",
          "level": 2,
          "content": "This interface is deprecated in favor of Cmdliner.Cmd. Follow the compiler deprecation warning hints to transition."
        },
        {
          "kind": "section",
          "title": "Term information",
          "level": 3,
          "content": "Term information defines the name and man page of a term. For simple evaluation this is the name of the program and its man page. For multiple term evaluation, this is the name of a command and its man page."
        },
        {
          "kind": "type",
          "name": "exit_info",
          "signature": "type exit_info",
          "anchor": "type-exit_info"
        },
        {
          "kind": "value",
          "name": "exit_info",
          "signature": "val exit_info : ?docs:string -> ?doc:string -> ?max:int -> int -> exit_info",
          "documentation": "exit_info ~docs ~doc min ~max describe the range of exit statuses from min to max (defaults to min). doc is the man page information for the statuses, defaults to \"undocumented\". docs is the title of the man page section in which the statuses will be listed, it defaults to Manpage.s_exit_status.",
          "anchor": "val-exit_info"
        },
        {
          "kind": "value",
          "name": "default_exits",
          "signature": "val default_exits : exit_info list",
          "documentation": "default_exits is information for exit status exit_status_success added to default_error_exits.",
          "anchor": "val-default_exits"
        },
        {
          "kind": "value",
          "name": "default_error_exits",
          "signature": "val default_error_exits : exit_info list",
          "documentation": "default_error_exits is information for exit statuses exit_status_cli_error and exit_status_internal_error.",
          "anchor": "val-default_error_exits"
        },
        {
          "kind": "type",
          "name": "env_info",
          "signature": "type env_info",
          "anchor": "type-env_info"
        },
        {
          "kind": "value",
          "name": "env_info",
          "signature": "val env_info : ?docs:string -> ?doc:string -> string -> env_info",
          "documentation": "env_info ~docs ~doc var describes an environment variable var. doc is the man page information of the environment variable, defaults to \"undocumented\". docs is the title of the man page section in which the environment variable will be listed, it defaults to Cmdliner.Manpage.s_environment.",
          "anchor": "val-env_info"
        },
        {
          "kind": "type",
          "name": "info",
          "signature": "type info",
          "anchor": "type-info"
        },
        {
          "kind": "value",
          "name": "info",
          "signature": "val info : ?man_xrefs:Manpage.xref list ->\n  ?man:Manpage.block list ->\n  ?envs:env_info list ->\n  ?exits:exit_info list ->\n  ?sdocs:string ->\n  ?docs:string ->\n  ?doc:string ->\n  ?version:string ->\n  string ->\n  info",
          "documentation": "info sdocs man docs doc version name is a term information such that:",
          "anchor": "val-info"
        },
        {
          "kind": "value",
          "name": "name",
          "signature": "val name : info -> string",
          "documentation": "name ti is the name of the term information.",
          "anchor": "val-name"
        },
        {
          "kind": "section",
          "title": "Evaluation",
          "level": 3,
          "content": ""
        },
        {
          "kind": "value",
          "name": "eval",
          "signature": "val eval : ?help:Format.formatter ->\n  ?err:Format.formatter ->\n  ?catch:bool ->\n  ?env:(string -> string option) ->\n  ?argv:string array ->\n  ('a t * info) ->\n  'a result",
          "documentation": "eval help err catch argv (t,i) is the evaluation result of t with command line arguments argv (defaults to Sys.argv).",
          "anchor": "val-eval"
        },
        {
          "kind": "value",
          "name": "eval_choice",
          "signature": "val eval_choice : ?help:Format.formatter ->\n  ?err:Format.formatter ->\n  ?catch:bool ->\n  ?env:(string -> string option) ->\n  ?argv:string array ->\n  ('a t * info) ->\n  ('a t * info) list ->\n  'a result",
          "documentation": "eval_choice help err catch argv (t,i) choices is like eval except that if the first argument on the command line is not an option name it will look in choices for a term whose information has this name and evaluate it.",
          "anchor": "val-eval_choice"
        },
        {
          "kind": "value",
          "name": "eval_peek_opts",
          "signature": "val eval_peek_opts : ?version_opt:bool ->\n  ?env:(string -> string option) ->\n  ?argv:string array ->\n  'a t ->\n  'a option * 'a result",
          "documentation": "eval_peek_opts version_opt argv t evaluates t, a term made of optional arguments only, with the command line argv (defaults to Sys.argv). In this evaluation, unknown optional arguments and positional arguments are ignored.",
          "anchor": "val-eval_peek_opts"
        },
        {
          "kind": "section",
          "title": "Turning evaluation results into exit codes",
          "level": 3,
          "content": "Note. If you are using the following functions to handle the evaluation result of a term you should add default_exits to the term's information ~exits argument.\nWARNING. You should avoid status codes strictly greater than 125 as those may be used by some shells."
        },
        {
          "kind": "value",
          "name": "exit_status_success",
          "signature": "val exit_status_success : int",
          "documentation": "exit_status_success is 0, the exit status for success.",
          "anchor": "val-exit_status_success"
        },
        {
          "kind": "value",
          "name": "exit_status_cli_error",
          "signature": "val exit_status_cli_error : int",
          "documentation": "exit_status_cli_error is 124, an exit status for command line parsing errors.",
          "anchor": "val-exit_status_cli_error"
        },
        {
          "kind": "value",
          "name": "exit_status_internal_error",
          "signature": "val exit_status_internal_error : int",
          "documentation": "exit_status_internal_error is 125, an exit status for unexpected internal errors.",
          "anchor": "val-exit_status_internal_error"
        },
        {
          "kind": "value",
          "name": "exit_status_of_result",
          "signature": "val exit_status_of_result : ?term_err:int -> unit result -> int",
          "documentation": "exit_status_of_result ~term_err r is an exit(3) status code determined from r as follows:",
          "anchor": "val-exit_status_of_result"
        },
        {
          "kind": "value",
          "name": "exit_status_of_status_result",
          "signature": "val exit_status_of_status_result : ?term_err:int -> int result -> int",
          "documentation": "exit_status_of_status_result is like exit_status_of_result except for `Ok n where n is used as the status exit code.",
          "anchor": "val-exit_status_of_status_result"
        },
        {
          "kind": "value",
          "name": "exit",
          "signature": "val exit : ?term_err:int -> unit result -> unit",
          "documentation": "exit ~term_err r is Stdlib.exit @@ exit_status_of_result ~term_err r",
          "anchor": "val-exit"
        },
        {
          "kind": "value",
          "name": "exit_status",
          "signature": "val exit_status : ?term_err:int -> int result -> unit",
          "documentation": "exit_status ~term_err r is Stdlib.exit @@ exit_status_of_status_result ~term_err r",
          "anchor": "val-exit_status"
        }
      ],
      "types": [
        {
          "kind": "type",
          "name": "exit_info",
          "signature": "type exit_info",
          "anchor": "type-exit_info"
        },
        {
          "kind": "type",
          "name": "env_info",
          "signature": "type env_info",
          "anchor": "type-env_info"
        },
        {
          "kind": "type",
          "name": "info",
          "signature": "type info",
          "anchor": "type-info"
        }
      ],
      "values": [
        {
          "kind": "value",
          "name": "const",
          "signature": "val const : 'a -> 'a t",
          "documentation": "const v is a term that evaluates to v.",
          "anchor": "val-const"
        },
        {
          "kind": "value",
          "name": "app",
          "signature": "val app : ('a -> 'b) t -> 'a t -> 'b t",
          "documentation": "app is ($).",
          "anchor": "val-app"
        },
        {
          "kind": "value",
          "name": "map",
          "signature": "val map : ('a -> 'b) -> 'a t -> 'b t",
          "documentation": "map f t is app (const f) t.",
          "anchor": "val-map"
        },
        {
          "kind": "value",
          "name": "product",
          "signature": "val product : 'a t -> 'b t -> ('a * 'b) t",
          "documentation": "product t0 t1 is app (app (map (fun x y -> (x, y)) t0) t1)",
          "anchor": "val-product"
        },
        {
          "kind": "value",
          "name": "term_result",
          "signature": "val term_result : ?usage:bool -> ('a, [ `Msg of string ]) result t -> 'a t",
          "documentation": "term_result ~usage t evaluates to",
          "anchor": "val-term_result"
        },
        {
          "kind": "value",
          "name": "cli_parse_result",
          "signature": "val cli_parse_result : ('a, [ `Msg of string ]) result t -> 'a t",
          "documentation": "cli_parse_result t is a term that evaluates to:",
          "anchor": "val-cli_parse_result"
        },
        {
          "kind": "value",
          "name": "main_name",
          "signature": "val main_name : string t",
          "documentation": "main_name is a term that evaluates to the main command name; that is the name of the tool.",
          "anchor": "val-main_name"
        },
        {
          "kind": "value",
          "name": "choice_names",
          "signature": "val choice_names : string list t",
          "documentation": "choice_names is a term that evaluates to the names of the commands that are children of the main command.",
          "anchor": "val-choice_names"
        },
        {
          "kind": "value",
          "name": "with_used_args",
          "signature": "val with_used_args : 'a t -> ('a * string list) t",
          "documentation": "with_used_args t is a term that evaluates to t tupled with the arguments from the command line that where used to evaluate t.",
          "anchor": "val-with_used_args"
        },
        {
          "kind": "value",
          "name": "ret",
          "signature": "val ret : 'a ret t -> 'a t",
          "documentation": "ret v is a term whose evaluation depends on the case to which v evaluates. With :",
          "anchor": "val-ret"
        },
        {
          "kind": "value",
          "name": "exit_info",
          "signature": "val exit_info : ?docs:string -> ?doc:string -> ?max:int -> int -> exit_info",
          "documentation": "exit_info ~docs ~doc min ~max describe the range of exit statuses from min to max (defaults to min). doc is the man page information for the statuses, defaults to \"undocumented\". docs is the title of the man page section in which the statuses will be listed, it defaults to Manpage.s_exit_status.",
          "anchor": "val-exit_info"
        },
        {
          "kind": "value",
          "name": "default_exits",
          "signature": "val default_exits : exit_info list",
          "documentation": "default_exits is information for exit status exit_status_success added to default_error_exits.",
          "anchor": "val-default_exits"
        },
        {
          "kind": "value",
          "name": "default_error_exits",
          "signature": "val default_error_exits : exit_info list",
          "documentation": "default_error_exits is information for exit statuses exit_status_cli_error and exit_status_internal_error.",
          "anchor": "val-default_error_exits"
        },
        {
          "kind": "value",
          "name": "env_info",
          "signature": "val env_info : ?docs:string -> ?doc:string -> string -> env_info",
          "documentation": "env_info ~docs ~doc var describes an environment variable var. doc is the man page information of the environment variable, defaults to \"undocumented\". docs is the title of the man page section in which the environment variable will be listed, it defaults to Cmdliner.Manpage.s_environment.",
          "anchor": "val-env_info"
        },
        {
          "kind": "value",
          "name": "info",
          "signature": "val info : ?man_xrefs:Manpage.xref list ->\n  ?man:Manpage.block list ->\n  ?envs:env_info list ->\n  ?exits:exit_info list ->\n  ?sdocs:string ->\n  ?docs:string ->\n  ?doc:string ->\n  ?version:string ->\n  string ->\n  info",
          "documentation": "info sdocs man docs doc version name is a term information such that:",
          "anchor": "val-info"
        },
        {
          "kind": "value",
          "name": "name",
          "signature": "val name : info -> string",
          "documentation": "name ti is the name of the term information.",
          "anchor": "val-name"
        },
        {
          "kind": "value",
          "name": "eval",
          "signature": "val eval : ?help:Format.formatter ->\n  ?err:Format.formatter ->\n  ?catch:bool ->\n  ?env:(string -> string option) ->\n  ?argv:string array ->\n  ('a t * info) ->\n  'a result",
          "documentation": "eval help err catch argv (t,i) is the evaluation result of t with command line arguments argv (defaults to Sys.argv).",
          "anchor": "val-eval"
        },
        {
          "kind": "value",
          "name": "eval_choice",
          "signature": "val eval_choice : ?help:Format.formatter ->\n  ?err:Format.formatter ->\n  ?catch:bool ->\n  ?env:(string -> string option) ->\n  ?argv:string array ->\n  ('a t * info) ->\n  ('a t * info) list ->\n  'a result",
          "documentation": "eval_choice help err catch argv (t,i) choices is like eval except that if the first argument on the command line is not an option name it will look in choices for a term whose information has this name and evaluate it.",
          "anchor": "val-eval_choice"
        },
        {
          "kind": "value",
          "name": "eval_peek_opts",
          "signature": "val eval_peek_opts : ?version_opt:bool ->\n  ?env:(string -> string option) ->\n  ?argv:string array ->\n  'a t ->\n  'a option * 'a result",
          "documentation": "eval_peek_opts version_opt argv t evaluates t, a term made of optional arguments only, with the command line argv (defaults to Sys.argv). In this evaluation, unknown optional arguments and positional arguments are ignored.",
          "anchor": "val-eval_peek_opts"
        },
        {
          "kind": "value",
          "name": "exit_status_success",
          "signature": "val exit_status_success : int",
          "documentation": "exit_status_success is 0, the exit status for success.",
          "anchor": "val-exit_status_success"
        },
        {
          "kind": "value",
          "name": "exit_status_cli_error",
          "signature": "val exit_status_cli_error : int",
          "documentation": "exit_status_cli_error is 124, an exit status for command line parsing errors.",
          "anchor": "val-exit_status_cli_error"
        },
        {
          "kind": "value",
          "name": "exit_status_internal_error",
          "signature": "val exit_status_internal_error : int",
          "documentation": "exit_status_internal_error is 125, an exit status for unexpected internal errors.",
          "anchor": "val-exit_status_internal_error"
        },
        {
          "kind": "value",
          "name": "exit_status_of_result",
          "signature": "val exit_status_of_result : ?term_err:int -> unit result -> int",
          "documentation": "exit_status_of_result ~term_err r is an exit(3) status code determined from r as follows:",
          "anchor": "val-exit_status_of_result"
        },
        {
          "kind": "value",
          "name": "exit_status_of_status_result",
          "signature": "val exit_status_of_status_result : ?term_err:int -> int result -> int",
          "documentation": "exit_status_of_status_result is like exit_status_of_result except for `Ok n where n is used as the status exit code.",
          "anchor": "val-exit_status_of_status_result"
        },
        {
          "kind": "value",
          "name": "exit",
          "signature": "val exit : ?term_err:int -> unit result -> unit",
          "documentation": "exit ~term_err r is Stdlib.exit @@ exit_status_of_result ~term_err r",
          "anchor": "val-exit"
        },
        {
          "kind": "value",
          "name": "exit_status",
          "signature": "val exit_status : ?term_err:int -> int result -> unit",
          "documentation": "exit_status ~term_err r is Stdlib.exit @@ exit_status_of_status_result ~term_err r",
          "anchor": "val-exit_status"
        }
      ],
      "modules": [
        {
          "name": "Syntax",
          "kind": "module"
        }
      ],
      "module_documentation": "Terms.\nA term is evaluated by a program to produce a result, which can be turned into an exit status. A term made of terms referring to command line arguments implicitly defines a command line syntax.",
      "sections": [
        {
          "kind": "section",
          "title": "Terms",
          "level": 2,
          "content": ""
        },
        {
          "kind": "section",
          "title": "Interacting with Cmdliner's evaluation",
          "level": 2,
          "content": ""
        },
        {
          "kind": "section",
          "title": "Deprecated Term evaluation interface",
          "level": 2,
          "content": "This interface is deprecated in favor of Cmdliner.Cmd. Follow the compiler deprecation warning hints to transition."
        },
        {
          "kind": "section",
          "title": "Term information",
          "level": 3,
          "content": "Term information defines the name and man page of a term. For simple evaluation this is the name of the program and its man page. For multiple term evaluation, this is the name of a command and its man page."
        },
        {
          "kind": "section",
          "title": "Evaluation",
          "level": 3,
          "content": ""
        },
        {
          "kind": "section",
          "title": "Turning evaluation results into exit codes",
          "level": 3,
          "content": "Note. If you are using the following functions to handle the evaluation result of a term you should add default_exits to the term's information ~exits argument.\nWARNING. You should avoid status codes strictly greater than 125 as those may be used by some shells."
        }
      ],
      "package": "cmdliner",
      "version": "1.3.0",
      "file_path": "doc/cmdliner/Cmdliner-Term.md",
      "library": "cmdliner",
      "module_path": [
        "Cmdliner",
        "Term"
      ]
    },
    {
      "elements": [
        {
          "kind": "section",
          "title": "Argument converters",
          "level": 2,
          "content": "An argument converter transforms a string argument of the command line to an OCaml value. Predefined converters are provided for many types of the standard library."
        },
        {
          "kind": "value",
          "name": "conv",
          "signature": "val conv : ?docv:string ->\n  ((string -> ('a, [ `Msg of string ]) result) * 'a printer) ->\n  'a conv",
          "documentation": "conv ~docv (parse, print) is an argument converter parsing values with parse and printing them with print. docv is a documentation meta-variable used in the documentation to stand for the argument value, defaults to \"VALUE\".",
          "anchor": "val-conv"
        },
        {
          "kind": "value",
          "name": "conv_parser",
          "signature": "val conv_parser : 'a conv -> string -> ('a, [ `Msg of string ]) result",
          "documentation": "conv_parser c is the parser of c.",
          "anchor": "val-conv_parser"
        },
        {
          "kind": "value",
          "name": "conv_printer",
          "signature": "val conv_printer : 'a conv -> 'a printer",
          "documentation": "conv_printer c is the printer of c.",
          "anchor": "val-conv_printer"
        },
        {
          "kind": "value",
          "name": "conv_docv",
          "signature": "val conv_docv : 'a conv -> string",
          "documentation": "conv_docv c is c's documentation meta-variable.",
          "anchor": "val-conv_docv"
        },
        {
          "kind": "value",
          "name": "parser_of_kind_of_string",
          "signature": "val parser_of_kind_of_string : kind:string ->\n  (string -> 'a option) ->\n  string ->\n  ('a, [ `Msg of string ]) result",
          "documentation": "parser_of_kind_of_string ~kind kind_of_string is an argument parser using the kind_of_string function for parsing and kind to report errors (e.g. could be \"an integer\" for an int parser.).",
          "anchor": "val-parser_of_kind_of_string"
        },
        {
          "kind": "value",
          "name": "some",
          "signature": "val some : ?none:string -> 'a conv -> 'a option conv",
          "documentation": "some ?none c is like some' but none is described as a string that will be rendered in bold.",
          "anchor": "val-some"
        },
        {
          "kind": "section",
          "title": "Arguments and their information",
          "level": 2,
          "content": "Argument information defines the man page information of an argument and, for optional arguments, its names. An environment variable can also be specified to read the argument value from if the argument is absent from the command line and the variable is defined."
        },
        {
          "kind": "type",
          "name": "info",
          "signature": "type info",
          "anchor": "type-info"
        },
        {
          "kind": "value",
          "name": "info",
          "signature": "val info : ?deprecated:string ->\n  ?absent:string ->\n  ?docs:string ->\n  ?docv:string ->\n  ?doc:string ->\n  ?env:Cmd.Env.info ->\n  string list ->\n  info",
          "documentation": "info docs docv doc env names defines information for an argument.",
          "anchor": "val-info"
        },
        {
          "kind": "section",
          "title": "Optional arguments",
          "level": 2,
          "content": "The information of an optional argument must have at least one name or Invalid_argument is raised."
        },
        {
          "kind": "value",
          "name": "flag",
          "signature": "val flag : info -> bool t",
          "documentation": "flag i is a bool argument defined by an optional flag that may appear at most once on the command line under one of the names specified by i. The argument holds true if the flag is present on the command line and false otherwise.",
          "anchor": "val-flag"
        },
        {
          "kind": "value",
          "name": "flag_all",
          "signature": "val flag_all : info -> bool list t",
          "documentation": "flag_all is like flag except the flag may appear more than once. The argument holds a list that contains one true value per occurrence of the flag. It holds the empty list if the flag is absent from the command line.",
          "anchor": "val-flag_all"
        },
        {
          "kind": "value",
          "name": "vflag",
          "signature": "val vflag : 'a -> ('a * info) list -> 'a t",
          "documentation": "vflag v [v0,i0;…] is an 'a argument defined by an optional flag that may appear at most once on the command line under one of the names specified in the ik values. The argument holds v if the flag is absent from the command line and the value vk if the name under which it appears is in ik.",
          "anchor": "val-vflag"
        },
        {
          "kind": "value",
          "name": "vflag_all",
          "signature": "val vflag_all : 'a list -> ('a * info) list -> 'a list t",
          "documentation": "vflag_all v l is like vflag except the flag may appear more than once. The argument holds the list v if the flag is absent from the command line. Otherwise it holds a list that contains one corresponding value per occurrence of the flag, in the order found on the command line.",
          "anchor": "val-vflag_all"
        },
        {
          "kind": "value",
          "name": "opt",
          "signature": "val opt : ?vopt:'a -> 'a conv -> 'a -> info -> 'a t",
          "documentation": "opt vopt c v i is an 'a argument defined by the value of an optional argument that may appear at most once on the command line under one of the names specified by i. The argument holds v if the option is absent from the command line. Otherwise it has the value of the option as converted by c.",
          "anchor": "val-opt"
        },
        {
          "kind": "value",
          "name": "opt_all",
          "signature": "val opt_all : ?vopt:'a -> 'a conv -> 'a list -> info -> 'a list t",
          "documentation": "opt_all vopt c v i is like opt except the optional argument may appear more than once. The argument holds a list that contains one value per occurrence of the flag in the order found on the command line. It holds the list v if the flag is absent from the command line.",
          "anchor": "val-opt_all"
        },
        {
          "kind": "section",
          "title": "Positional arguments",
          "level": 2,
          "content": "The information of a positional argument must have no name or Invalid_argument is raised. Positional arguments indexing is zero-based.\nWarning. The following combinators allow to specify and extract a given positional argument with more than one term. This should not be done as it will likely confuse end users and documentation generation. These over-specifications may be prevented by raising Invalid_argument in the future. But for now it is the client's duty to make sure this doesn't happen."
        },
        {
          "kind": "value",
          "name": "pos",
          "signature": "val pos : ?rev:bool -> int -> 'a conv -> 'a -> info -> 'a t",
          "documentation": "pos rev n c v i is an 'a argument defined by the nth positional argument of the command line as converted by c. If the positional argument is absent from the command line the argument is v.",
          "anchor": "val-pos"
        },
        {
          "kind": "value",
          "name": "pos_all",
          "signature": "val pos_all : 'a conv -> 'a list -> info -> 'a list t",
          "documentation": "pos_all c v i is an 'a list argument that holds all the positional arguments of the command line as converted by c or v if there are none.",
          "anchor": "val-pos_all"
        },
        {
          "kind": "value",
          "name": "pos_left",
          "signature": "val pos_left : ?rev:bool -> int -> 'a conv -> 'a list -> info -> 'a list t",
          "documentation": "pos_left rev n c v i is an 'a list argument that holds all the positional arguments as converted by c found on the left of the nth positional argument or v if there are none.",
          "anchor": "val-pos_left"
        },
        {
          "kind": "value",
          "name": "pos_right",
          "signature": "val pos_right : ?rev:bool -> int -> 'a conv -> 'a list -> info -> 'a list t",
          "documentation": "pos_right is like pos_left except it holds all the positional arguments found on the right of the specified positional argument.",
          "anchor": "val-pos_right"
        },
        {
          "kind": "section",
          "title": "Arguments as terms",
          "level": 2,
          "content": ""
        },
        {
          "kind": "value",
          "name": "value",
          "signature": "val value : 'a t -> 'a Term.t",
          "documentation": "value a is a term that evaluates to a's value.",
          "anchor": "val-value"
        },
        {
          "kind": "value",
          "name": "required",
          "signature": "val required : 'a option t -> 'a Term.t",
          "documentation": "required a is a term that fails if a's value is None and evaluates to the value of Some otherwise. Use this for required positional arguments (it can also be used for defining required optional arguments, but from a user interface perspective this shouldn't be done, it is a contradiction in terms).",
          "anchor": "val-required"
        },
        {
          "kind": "value",
          "name": "non_empty",
          "signature": "val non_empty : 'a list t -> 'a list Term.t",
          "documentation": "non_empty a is term that fails if a's list is empty and evaluates to a's list otherwise. Use this for non empty lists of positional arguments.",
          "anchor": "val-non_empty"
        },
        {
          "kind": "value",
          "name": "last",
          "signature": "val last : 'a list t -> 'a Term.t",
          "documentation": "last a is a term that fails if a's list is empty and evaluates to the value of the last element of the list otherwise. Use this for lists of flags or options where the last occurrence takes precedence over the others.",
          "anchor": "val-last"
        },
        {
          "kind": "section",
          "title": "Predefined arguments",
          "level": 2,
          "content": ""
        },
        {
          "kind": "value",
          "name": "man_format",
          "signature": "val man_format : Manpage.format Term.t",
          "documentation": "man_format is a term that defines a --man-format option and evaluates to a value that can be used with Manpage.print.",
          "anchor": "val-man_format"
        },
        {
          "kind": "section",
          "title": "Predefined converters",
          "level": 2,
          "content": ""
        },
        {
          "kind": "value",
          "name": "bool",
          "signature": "val bool : bool conv",
          "documentation": "bool converts values with bool_of_string.",
          "anchor": "val-bool"
        },
        {
          "kind": "value",
          "name": "char",
          "signature": "val char : char conv",
          "documentation": "char converts values by ensuring the argument has a single char.",
          "anchor": "val-char"
        },
        {
          "kind": "value",
          "name": "int",
          "signature": "val int : int conv",
          "documentation": "int converts values with int_of_string.",
          "anchor": "val-int"
        },
        {
          "kind": "value",
          "name": "nativeint",
          "signature": "val nativeint : nativeint conv",
          "documentation": "nativeint converts values with Nativeint.of_string.",
          "anchor": "val-nativeint"
        },
        {
          "kind": "value",
          "name": "int32",
          "signature": "val int32 : int32 conv",
          "documentation": "int32 converts values with Int32.of_string.",
          "anchor": "val-int32"
        },
        {
          "kind": "value",
          "name": "int64",
          "signature": "val int64 : int64 conv",
          "documentation": "int64 converts values with Int64.of_string.",
          "anchor": "val-int64"
        },
        {
          "kind": "value",
          "name": "float",
          "signature": "val float : float conv",
          "documentation": "float converts values with float_of_string.",
          "anchor": "val-float"
        },
        {
          "kind": "value",
          "name": "string",
          "signature": "val string : string conv",
          "documentation": "string converts values with the identity function.",
          "anchor": "val-string"
        },
        {
          "kind": "value",
          "name": "enum",
          "signature": "val enum : (string * 'a) list -> 'a conv",
          "documentation": "enum l p converts values such that unambiguous prefixes of string names in l map to the corresponding value of type 'a.",
          "anchor": "val-enum"
        },
        {
          "kind": "value",
          "name": "file",
          "signature": "val file : string conv",
          "documentation": "file converts a value with the identity function and checks with Sys.file_exists that a file with that name exists.",
          "anchor": "val-file"
        },
        {
          "kind": "value",
          "name": "dir",
          "signature": "val dir : string conv",
          "documentation": "dir converts a value with the identity function and checks with Sys.file_exists and Sys.is_directory that a directory with that name exists.",
          "anchor": "val-dir"
        },
        {
          "kind": "value",
          "name": "non_dir_file",
          "signature": "val non_dir_file : string conv",
          "documentation": "non_dir_file converts a value with the identity function and checks with Sys.file_exists and Sys.is_directory that a non directory file with that name exists.",
          "anchor": "val-non_dir_file"
        },
        {
          "kind": "value",
          "name": "list",
          "signature": "val list : ?sep:char -> 'a conv -> 'a list conv",
          "documentation": "list sep c splits the argument at each sep (defaults to ',') character and converts each substrings with c.",
          "anchor": "val-list"
        },
        {
          "kind": "value",
          "name": "array",
          "signature": "val array : ?sep:char -> 'a conv -> 'a array conv",
          "documentation": "array sep c splits the argument at each sep (defaults to ',') character and converts each substring with c.",
          "anchor": "val-array"
        },
        {
          "kind": "value",
          "name": "pair",
          "signature": "val pair : ?sep:char -> 'a conv -> 'b conv -> ('a * 'b) conv",
          "documentation": "pair sep c0 c1 splits the argument at the first sep character (defaults to ',') and respectively converts the substrings with c0 and c1.",
          "anchor": "val-pair"
        },
        {
          "kind": "value",
          "name": "t2",
          "signature": "val t2 : ?sep:char -> 'a conv -> 'b conv -> ('a * 'b) conv",
          "documentation": "t2 is pair.",
          "anchor": "val-t2"
        },
        {
          "kind": "value",
          "name": "t3",
          "signature": "val t3 : ?sep:char -> 'a conv -> 'b conv -> 'c conv -> ('a * 'b * 'c) conv",
          "documentation": "t3 sep c0 c1 c2 splits the argument at the first two sep characters (defaults to ',') and respectively converts the substrings with c0, c1 and c2.",
          "anchor": "val-t3"
        },
        {
          "kind": "value",
          "name": "t4",
          "signature": "val t4 : ?sep:char ->\n  'a conv ->\n  'b conv ->\n  'c conv ->\n  'd conv ->\n  ('a * 'b * 'c * 'd) conv",
          "documentation": "t4 sep c0 c1 c2 c3 splits the argument at the first three sep characters (defaults to ',') respectively converts the substrings with c0, c1, c2 and c3.",
          "anchor": "val-t4"
        },
        {
          "kind": "section",
          "title": "Documentation formatting helpers",
          "level": 2,
          "content": ""
        },
        {
          "kind": "value",
          "name": "doc_quote",
          "signature": "val doc_quote : string -> string",
          "documentation": "doc_quote s quotes the string s.",
          "anchor": "val-doc_quote"
        },
        {
          "kind": "value",
          "name": "doc_alts",
          "signature": "val doc_alts : ?quoted:bool -> string list -> string",
          "documentation": "doc_alts alts documents the alternative tokens alts according the number of alternatives. If quoted is:",
          "anchor": "val-doc_alts"
        },
        {
          "kind": "value",
          "name": "doc_alts_enum",
          "signature": "val doc_alts_enum : ?quoted:bool -> (string * 'a) list -> string",
          "documentation": "doc_alts_enum quoted alts is doc_alts quoted (List.map fst alts).",
          "anchor": "val-doc_alts_enum"
        },
        {
          "kind": "section",
          "title": "Deprecated",
          "level": 2,
          "content": ""
        },
        {
          "kind": "value",
          "name": "pconv",
          "signature": "val pconv : ?docv:string -> ('a parser * 'a printer) -> 'a conv",
          "documentation": "pconv is like conv or conv', but uses a deprecated parser signature.",
          "anchor": "val-pconv"
        },
        {
          "kind": "type",
          "name": "env",
          "signature": "type env = Cmd.Env.info",
          "anchor": "type-env"
        },
        {
          "kind": "value",
          "name": "env_var",
          "signature": "val env_var : ?deprecated:string ->\n  ?docs:string ->\n  ?doc:string ->\n  Cmd.Env.var ->\n  Cmd.Env.info",
          "documentation": "See Cmd.Env.info.",
          "anchor": "val-env_var"
        }
      ],
      "types": [
        {
          "kind": "type",
          "name": "info",
          "signature": "type info",
          "anchor": "type-info"
        },
        {
          "kind": "type",
          "name": "env",
          "signature": "type env = Cmd.Env.info",
          "anchor": "type-env"
        }
      ],
      "values": [
        {
          "kind": "value",
          "name": "conv",
          "signature": "val conv : ?docv:string ->\n  ((string -> ('a, [ `Msg of string ]) result) * 'a printer) ->\n  'a conv",
          "documentation": "conv ~docv (parse, print) is an argument converter parsing values with parse and printing them with print. docv is a documentation meta-variable used in the documentation to stand for the argument value, defaults to \"VALUE\".",
          "anchor": "val-conv"
        },
        {
          "kind": "value",
          "name": "conv_parser",
          "signature": "val conv_parser : 'a conv -> string -> ('a, [ `Msg of string ]) result",
          "documentation": "conv_parser c is the parser of c.",
          "anchor": "val-conv_parser"
        },
        {
          "kind": "value",
          "name": "conv_printer",
          "signature": "val conv_printer : 'a conv -> 'a printer",
          "documentation": "conv_printer c is the printer of c.",
          "anchor": "val-conv_printer"
        },
        {
          "kind": "value",
          "name": "conv_docv",
          "signature": "val conv_docv : 'a conv -> string",
          "documentation": "conv_docv c is c's documentation meta-variable.",
          "anchor": "val-conv_docv"
        },
        {
          "kind": "value",
          "name": "parser_of_kind_of_string",
          "signature": "val parser_of_kind_of_string : kind:string ->\n  (string -> 'a option) ->\n  string ->\n  ('a, [ `Msg of string ]) result",
          "documentation": "parser_of_kind_of_string ~kind kind_of_string is an argument parser using the kind_of_string function for parsing and kind to report errors (e.g. could be \"an integer\" for an int parser.).",
          "anchor": "val-parser_of_kind_of_string"
        },
        {
          "kind": "value",
          "name": "some",
          "signature": "val some : ?none:string -> 'a conv -> 'a option conv",
          "documentation": "some ?none c is like some' but none is described as a string that will be rendered in bold.",
          "anchor": "val-some"
        },
        {
          "kind": "value",
          "name": "info",
          "signature": "val info : ?deprecated:string ->\n  ?absent:string ->\n  ?docs:string ->\n  ?docv:string ->\n  ?doc:string ->\n  ?env:Cmd.Env.info ->\n  string list ->\n  info",
          "documentation": "info docs docv doc env names defines information for an argument.",
          "anchor": "val-info"
        },
        {
          "kind": "value",
          "name": "flag",
          "signature": "val flag : info -> bool t",
          "documentation": "flag i is a bool argument defined by an optional flag that may appear at most once on the command line under one of the names specified by i. The argument holds true if the flag is present on the command line and false otherwise.",
          "anchor": "val-flag"
        },
        {
          "kind": "value",
          "name": "flag_all",
          "signature": "val flag_all : info -> bool list t",
          "documentation": "flag_all is like flag except the flag may appear more than once. The argument holds a list that contains one true value per occurrence of the flag. It holds the empty list if the flag is absent from the command line.",
          "anchor": "val-flag_all"
        },
        {
          "kind": "value",
          "name": "vflag",
          "signature": "val vflag : 'a -> ('a * info) list -> 'a t",
          "documentation": "vflag v [v0,i0;…] is an 'a argument defined by an optional flag that may appear at most once on the command line under one of the names specified in the ik values. The argument holds v if the flag is absent from the command line and the value vk if the name under which it appears is in ik.",
          "anchor": "val-vflag"
        },
        {
          "kind": "value",
          "name": "vflag_all",
          "signature": "val vflag_all : 'a list -> ('a * info) list -> 'a list t",
          "documentation": "vflag_all v l is like vflag except the flag may appear more than once. The argument holds the list v if the flag is absent from the command line. Otherwise it holds a list that contains one corresponding value per occurrence of the flag, in the order found on the command line.",
          "anchor": "val-vflag_all"
        },
        {
          "kind": "value",
          "name": "opt",
          "signature": "val opt : ?vopt:'a -> 'a conv -> 'a -> info -> 'a t",
          "documentation": "opt vopt c v i is an 'a argument defined by the value of an optional argument that may appear at most once on the command line under one of the names specified by i. The argument holds v if the option is absent from the command line. Otherwise it has the value of the option as converted by c.",
          "anchor": "val-opt"
        },
        {
          "kind": "value",
          "name": "opt_all",
          "signature": "val opt_all : ?vopt:'a -> 'a conv -> 'a list -> info -> 'a list t",
          "documentation": "opt_all vopt c v i is like opt except the optional argument may appear more than once. The argument holds a list that contains one value per occurrence of the flag in the order found on the command line. It holds the list v if the flag is absent from the command line.",
          "anchor": "val-opt_all"
        },
        {
          "kind": "value",
          "name": "pos",
          "signature": "val pos : ?rev:bool -> int -> 'a conv -> 'a -> info -> 'a t",
          "documentation": "pos rev n c v i is an 'a argument defined by the nth positional argument of the command line as converted by c. If the positional argument is absent from the command line the argument is v.",
          "anchor": "val-pos"
        },
        {
          "kind": "value",
          "name": "pos_all",
          "signature": "val pos_all : 'a conv -> 'a list -> info -> 'a list t",
          "documentation": "pos_all c v i is an 'a list argument that holds all the positional arguments of the command line as converted by c or v if there are none.",
          "anchor": "val-pos_all"
        },
        {
          "kind": "value",
          "name": "pos_left",
          "signature": "val pos_left : ?rev:bool -> int -> 'a conv -> 'a list -> info -> 'a list t",
          "documentation": "pos_left rev n c v i is an 'a list argument that holds all the positional arguments as converted by c found on the left of the nth positional argument or v if there are none.",
          "anchor": "val-pos_left"
        },
        {
          "kind": "value",
          "name": "pos_right",
          "signature": "val pos_right : ?rev:bool -> int -> 'a conv -> 'a list -> info -> 'a list t",
          "documentation": "pos_right is like pos_left except it holds all the positional arguments found on the right of the specified positional argument.",
          "anchor": "val-pos_right"
        },
        {
          "kind": "value",
          "name": "value",
          "signature": "val value : 'a t -> 'a Term.t",
          "documentation": "value a is a term that evaluates to a's value.",
          "anchor": "val-value"
        },
        {
          "kind": "value",
          "name": "required",
          "signature": "val required : 'a option t -> 'a Term.t",
          "documentation": "required a is a term that fails if a's value is None and evaluates to the value of Some otherwise. Use this for required positional arguments (it can also be used for defining required optional arguments, but from a user interface perspective this shouldn't be done, it is a contradiction in terms).",
          "anchor": "val-required"
        },
        {
          "kind": "value",
          "name": "non_empty",
          "signature": "val non_empty : 'a list t -> 'a list Term.t",
          "documentation": "non_empty a is term that fails if a's list is empty and evaluates to a's list otherwise. Use this for non empty lists of positional arguments.",
          "anchor": "val-non_empty"
        },
        {
          "kind": "value",
          "name": "last",
          "signature": "val last : 'a list t -> 'a Term.t",
          "documentation": "last a is a term that fails if a's list is empty and evaluates to the value of the last element of the list otherwise. Use this for lists of flags or options where the last occurrence takes precedence over the others.",
          "anchor": "val-last"
        },
        {
          "kind": "value",
          "name": "man_format",
          "signature": "val man_format : Manpage.format Term.t",
          "documentation": "man_format is a term that defines a --man-format option and evaluates to a value that can be used with Manpage.print.",
          "anchor": "val-man_format"
        },
        {
          "kind": "value",
          "name": "bool",
          "signature": "val bool : bool conv",
          "documentation": "bool converts values with bool_of_string.",
          "anchor": "val-bool"
        },
        {
          "kind": "value",
          "name": "char",
          "signature": "val char : char conv",
          "documentation": "char converts values by ensuring the argument has a single char.",
          "anchor": "val-char"
        },
        {
          "kind": "value",
          "name": "int",
          "signature": "val int : int conv",
          "documentation": "int converts values with int_of_string.",
          "anchor": "val-int"
        },
        {
          "kind": "value",
          "name": "nativeint",
          "signature": "val nativeint : nativeint conv",
          "documentation": "nativeint converts values with Nativeint.of_string.",
          "anchor": "val-nativeint"
        },
        {
          "kind": "value",
          "name": "int32",
          "signature": "val int32 : int32 conv",
          "documentation": "int32 converts values with Int32.of_string.",
          "anchor": "val-int32"
        },
        {
          "kind": "value",
          "name": "int64",
          "signature": "val int64 : int64 conv",
          "documentation": "int64 converts values with Int64.of_string.",
          "anchor": "val-int64"
        },
        {
          "kind": "value",
          "name": "float",
          "signature": "val float : float conv",
          "documentation": "float converts values with float_of_string.",
          "anchor": "val-float"
        },
        {
          "kind": "value",
          "name": "string",
          "signature": "val string : string conv",
          "documentation": "string converts values with the identity function.",
          "anchor": "val-string"
        },
        {
          "kind": "value",
          "name": "enum",
          "signature": "val enum : (string * 'a) list -> 'a conv",
          "documentation": "enum l p converts values such that unambiguous prefixes of string names in l map to the corresponding value of type 'a.",
          "anchor": "val-enum"
        },
        {
          "kind": "value",
          "name": "file",
          "signature": "val file : string conv",
          "documentation": "file converts a value with the identity function and checks with Sys.file_exists that a file with that name exists.",
          "anchor": "val-file"
        },
        {
          "kind": "value",
          "name": "dir",
          "signature": "val dir : string conv",
          "documentation": "dir converts a value with the identity function and checks with Sys.file_exists and Sys.is_directory that a directory with that name exists.",
          "anchor": "val-dir"
        },
        {
          "kind": "value",
          "name": "non_dir_file",
          "signature": "val non_dir_file : string conv",
          "documentation": "non_dir_file converts a value with the identity function and checks with Sys.file_exists and Sys.is_directory that a non directory file with that name exists.",
          "anchor": "val-non_dir_file"
        },
        {
          "kind": "value",
          "name": "list",
          "signature": "val list : ?sep:char -> 'a conv -> 'a list conv",
          "documentation": "list sep c splits the argument at each sep (defaults to ',') character and converts each substrings with c.",
          "anchor": "val-list"
        },
        {
          "kind": "value",
          "name": "array",
          "signature": "val array : ?sep:char -> 'a conv -> 'a array conv",
          "documentation": "array sep c splits the argument at each sep (defaults to ',') character and converts each substring with c.",
          "anchor": "val-array"
        },
        {
          "kind": "value",
          "name": "pair",
          "signature": "val pair : ?sep:char -> 'a conv -> 'b conv -> ('a * 'b) conv",
          "documentation": "pair sep c0 c1 splits the argument at the first sep character (defaults to ',') and respectively converts the substrings with c0 and c1.",
          "anchor": "val-pair"
        },
        {
          "kind": "value",
          "name": "t2",
          "signature": "val t2 : ?sep:char -> 'a conv -> 'b conv -> ('a * 'b) conv",
          "documentation": "t2 is pair.",
          "anchor": "val-t2"
        },
        {
          "kind": "value",
          "name": "t3",
          "signature": "val t3 : ?sep:char -> 'a conv -> 'b conv -> 'c conv -> ('a * 'b * 'c) conv",
          "documentation": "t3 sep c0 c1 c2 splits the argument at the first two sep characters (defaults to ',') and respectively converts the substrings with c0, c1 and c2.",
          "anchor": "val-t3"
        },
        {
          "kind": "value",
          "name": "t4",
          "signature": "val t4 : ?sep:char ->\n  'a conv ->\n  'b conv ->\n  'c conv ->\n  'd conv ->\n  ('a * 'b * 'c * 'd) conv",
          "documentation": "t4 sep c0 c1 c2 c3 splits the argument at the first three sep characters (defaults to ',') respectively converts the substrings with c0, c1, c2 and c3.",
          "anchor": "val-t4"
        },
        {
          "kind": "value",
          "name": "doc_quote",
          "signature": "val doc_quote : string -> string",
          "documentation": "doc_quote s quotes the string s.",
          "anchor": "val-doc_quote"
        },
        {
          "kind": "value",
          "name": "doc_alts",
          "signature": "val doc_alts : ?quoted:bool -> string list -> string",
          "documentation": "doc_alts alts documents the alternative tokens alts according the number of alternatives. If quoted is:",
          "anchor": "val-doc_alts"
        },
        {
          "kind": "value",
          "name": "doc_alts_enum",
          "signature": "val doc_alts_enum : ?quoted:bool -> (string * 'a) list -> string",
          "documentation": "doc_alts_enum quoted alts is doc_alts quoted (List.map fst alts).",
          "anchor": "val-doc_alts_enum"
        },
        {
          "kind": "value",
          "name": "pconv",
          "signature": "val pconv : ?docv:string -> ('a parser * 'a printer) -> 'a conv",
          "documentation": "pconv is like conv or conv', but uses a deprecated parser signature.",
          "anchor": "val-pconv"
        },
        {
          "kind": "value",
          "name": "env_var",
          "signature": "val env_var : ?deprecated:string ->\n  ?docs:string ->\n  ?doc:string ->\n  Cmd.Env.var ->\n  Cmd.Env.info",
          "documentation": "See Cmd.Env.info.",
          "anchor": "val-env_var"
        }
      ],
      "modules": [],
      "module_documentation": "Terms for command line arguments.\nThis module provides functions to define terms that evaluate to the arguments provided on the command line.\nBasic constraints, like the argument type or repeatability, are specified by defining a value of type Arg.t. Further constraints can be specified during the conversion to a term.",
      "sections": [
        {
          "kind": "section",
          "title": "Argument converters",
          "level": 2,
          "content": "An argument converter transforms a string argument of the command line to an OCaml value. Predefined converters are provided for many types of the standard library."
        },
        {
          "kind": "section",
          "title": "Arguments and their information",
          "level": 2,
          "content": "Argument information defines the man page information of an argument and, for optional arguments, its names. An environment variable can also be specified to read the argument value from if the argument is absent from the command line and the variable is defined."
        },
        {
          "kind": "section",
          "title": "Optional arguments",
          "level": 2,
          "content": "The information of an optional argument must have at least one name or Invalid_argument is raised."
        },
        {
          "kind": "section",
          "title": "Positional arguments",
          "level": 2,
          "content": "The information of a positional argument must have no name or Invalid_argument is raised. Positional arguments indexing is zero-based.\nWarning. The following combinators allow to specify and extract a given positional argument with more than one term. This should not be done as it will likely confuse end users and documentation generation. These over-specifications may be prevented by raising Invalid_argument in the future. But for now it is the client's duty to make sure this doesn't happen."
        },
        {
          "kind": "section",
          "title": "Arguments as terms",
          "level": 2,
          "content": ""
        },
        {
          "kind": "section",
          "title": "Predefined arguments",
          "level": 2,
          "content": ""
        },
        {
          "kind": "section",
          "title": "Predefined converters",
          "level": 2,
          "content": ""
        },
        {
          "kind": "section",
          "title": "Documentation formatting helpers",
          "level": 2,
          "content": ""
        },
        {
          "kind": "section",
          "title": "Deprecated",
          "level": 2,
          "content": ""
        }
      ],
      "package": "cmdliner",
      "version": "1.3.0",
      "file_path": "doc/cmdliner/Cmdliner-Arg.md",
      "library": "cmdliner",
      "module_path": [
        "Cmdliner",
        "Arg"
      ]
    },
    {
      "elements": [
        {
          "kind": "section",
          "title": "Command information",
          "level": 2,
          "content": "Command information defines the name and documentation of a command."
        },
        {
          "name": "Exit",
          "kind": "module"
        },
        {
          "name": "Env",
          "kind": "module"
        },
        {
          "kind": "type",
          "name": "info",
          "signature": "type info",
          "anchor": "type-info"
        },
        {
          "kind": "value",
          "name": "info",
          "signature": "val info : ?deprecated:string ->\n  ?man_xrefs:Manpage.xref list ->\n  ?man:Manpage.block list ->\n  ?envs:Env.info list ->\n  ?exits:Exit.info list ->\n  ?sdocs:string ->\n  ?docs:string ->\n  ?doc:string ->\n  ?version:string ->\n  string ->\n  info",
          "documentation": "info ?sdocs ?man ?docs ?doc ?version name is a term information such that:",
          "anchor": "val-info"
        },
        {
          "kind": "section",
          "title": "Commands",
          "level": 2,
          "content": ""
        },
        {
          "kind": "value",
          "name": "v",
          "signature": "val v : info -> 'a Term.t -> 'a t",
          "documentation": "v i t is a command with information i and command line syntax parsed by t.",
          "anchor": "val-v"
        },
        {
          "kind": "value",
          "name": "group",
          "signature": "val group : ?default:'a Term.t -> info -> 'a t list -> 'a t",
          "documentation": "group i ?default cmds is a command with information i that groups sub commands cmds. default is the command line syntax to parse if no sub command is specified on the command line. If default is None (default), the tool errors when no sub command is specified.",
          "anchor": "val-group"
        },
        {
          "kind": "value",
          "name": "name",
          "signature": "val name : 'a t -> string",
          "documentation": "name c is the name of c.",
          "anchor": "val-name"
        },
        {
          "kind": "section",
          "title": "Evaluation",
          "level": 2,
          "content": "These functions are meant to be composed with Stdlib.exit. The following exit codes may be returned by all these functions:"
        },
        {
          "kind": "value",
          "name": "eval",
          "signature": "val eval : ?help:Format.formatter ->\n  ?err:Format.formatter ->\n  ?catch:bool ->\n  ?env:(string -> string option) ->\n  ?argv:string array ->\n  ?term_err:Exit.code ->\n  unit t ->\n  Exit.code",
          "documentation": "eval cmd is Exit.ok if cmd evaluates to (). See eval_value for other arguments.",
          "anchor": "val-eval"
        },
        {
          "kind": "value",
          "name": "eval_result",
          "signature": "val eval_result : ?help:Format.formatter ->\n  ?err:Format.formatter ->\n  ?catch:bool ->\n  ?env:(string -> string option) ->\n  ?argv:string array ->\n  ?term_err:Exit.code ->\n  (unit, string) result t ->\n  Exit.code",
          "documentation": "eval_result cmd is:",
          "anchor": "val-eval_result"
        },
        {
          "kind": "section",
          "title": "Low level evaluation",
          "level": 3,
          "content": "This interface gives more information on command evaluation results and lets you choose how to map evaluation results to exit codes."
        },
        {
          "kind": "type",
          "name": "eval_error",
          "signature": "type eval_error = [",
          "anchor": "type-eval_error"
        },
        {
          "kind": "value",
          "name": "eval_value",
          "signature": "val eval_value : ?help:Format.formatter ->\n  ?err:Format.formatter ->\n  ?catch:bool ->\n  ?env:(string -> string option) ->\n  ?argv:string array ->\n  'a t ->\n  ('a eval_ok, eval_error) result",
          "documentation": "eval ~help ~err ~catch ~env ~argv cmd is the evaluation result of cmd with:",
          "anchor": "val-eval_value"
        },
        {
          "kind": "value",
          "name": "eval_peek_opts",
          "signature": "val eval_peek_opts : ?version_opt:bool ->\n  ?env:(string -> string option) ->\n  ?argv:string array ->\n  'a Term.t ->\n  'a option * ('a eval_ok, eval_error) result",
          "documentation": "eval_peek_opts version_opt argv t evaluates t, a term made of optional arguments only, with the command line argv (defaults to Sys.argv). In this evaluation, unknown optional arguments and positional arguments are ignored.",
          "anchor": "val-eval_peek_opts"
        }
      ],
      "types": [
        {
          "kind": "type",
          "name": "info",
          "signature": "type info",
          "anchor": "type-info"
        },
        {
          "kind": "type",
          "name": "eval_error",
          "signature": "type eval_error = [",
          "anchor": "type-eval_error"
        }
      ],
      "values": [
        {
          "kind": "value",
          "name": "info",
          "signature": "val info : ?deprecated:string ->\n  ?man_xrefs:Manpage.xref list ->\n  ?man:Manpage.block list ->\n  ?envs:Env.info list ->\n  ?exits:Exit.info list ->\n  ?sdocs:string ->\n  ?docs:string ->\n  ?doc:string ->\n  ?version:string ->\n  string ->\n  info",
          "documentation": "info ?sdocs ?man ?docs ?doc ?version name is a term information such that:",
          "anchor": "val-info"
        },
        {
          "kind": "value",
          "name": "v",
          "signature": "val v : info -> 'a Term.t -> 'a t",
          "documentation": "v i t is a command with information i and command line syntax parsed by t.",
          "anchor": "val-v"
        },
        {
          "kind": "value",
          "name": "group",
          "signature": "val group : ?default:'a Term.t -> info -> 'a t list -> 'a t",
          "documentation": "group i ?default cmds is a command with information i that groups sub commands cmds. default is the command line syntax to parse if no sub command is specified on the command line. If default is None (default), the tool errors when no sub command is specified.",
          "anchor": "val-group"
        },
        {
          "kind": "value",
          "name": "name",
          "signature": "val name : 'a t -> string",
          "documentation": "name c is the name of c.",
          "anchor": "val-name"
        },
        {
          "kind": "value",
          "name": "eval",
          "signature": "val eval : ?help:Format.formatter ->\n  ?err:Format.formatter ->\n  ?catch:bool ->\n  ?env:(string -> string option) ->\n  ?argv:string array ->\n  ?term_err:Exit.code ->\n  unit t ->\n  Exit.code",
          "documentation": "eval cmd is Exit.ok if cmd evaluates to (). See eval_value for other arguments.",
          "anchor": "val-eval"
        },
        {
          "kind": "value",
          "name": "eval_result",
          "signature": "val eval_result : ?help:Format.formatter ->\n  ?err:Format.formatter ->\n  ?catch:bool ->\n  ?env:(string -> string option) ->\n  ?argv:string array ->\n  ?term_err:Exit.code ->\n  (unit, string) result t ->\n  Exit.code",
          "documentation": "eval_result cmd is:",
          "anchor": "val-eval_result"
        },
        {
          "kind": "value",
          "name": "eval_value",
          "signature": "val eval_value : ?help:Format.formatter ->\n  ?err:Format.formatter ->\n  ?catch:bool ->\n  ?env:(string -> string option) ->\n  ?argv:string array ->\n  'a t ->\n  ('a eval_ok, eval_error) result",
          "documentation": "eval ~help ~err ~catch ~env ~argv cmd is the evaluation result of cmd with:",
          "anchor": "val-eval_value"
        },
        {
          "kind": "value",
          "name": "eval_peek_opts",
          "signature": "val eval_peek_opts : ?version_opt:bool ->\n  ?env:(string -> string option) ->\n  ?argv:string array ->\n  'a Term.t ->\n  'a option * ('a eval_ok, eval_error) result",
          "documentation": "eval_peek_opts version_opt argv t evaluates t, a term made of optional arguments only, with the command line argv (defaults to Sys.argv). In this evaluation, unknown optional arguments and positional arguments are ignored.",
          "anchor": "val-eval_peek_opts"
        }
      ],
      "modules": [
        {
          "name": "Exit",
          "kind": "module"
        },
        {
          "name": "Env",
          "kind": "module"
        }
      ],
      "module_documentation": "Commands.\nCommand line syntaxes are implicitely defined by Terms. A command value binds a syntax and its documentation to a command name.\nA command can group a list of sub commands (and recursively). In this case your tool defines a tree of commands, each with its own command line syntax. The root of that tree is called the main command; it represents your tool and its name.",
      "sections": [
        {
          "kind": "section",
          "title": "Command information",
          "level": 2,
          "content": "Command information defines the name and documentation of a command."
        },
        {
          "kind": "section",
          "title": "Commands",
          "level": 2,
          "content": ""
        },
        {
          "kind": "section",
          "title": "Evaluation",
          "level": 2,
          "content": "These functions are meant to be composed with Stdlib.exit. The following exit codes may be returned by all these functions:"
        },
        {
          "kind": "section",
          "title": "Low level evaluation",
          "level": 3,
          "content": "This interface gives more information on command evaluation results and lets you choose how to map evaluation results to exit codes."
        }
      ],
      "package": "cmdliner",
      "version": "1.3.0",
      "file_path": "doc/cmdliner/Cmdliner-Cmd.md",
      "library": "cmdliner",
      "module_path": [
        "Cmdliner",
        "Cmd"
      ]
    },
    {
      "elements": [
        {
          "name": "Manpage",
          "kind": "module"
        },
        {
          "name": "Term",
          "kind": "module"
        },
        {
          "name": "Cmd",
          "kind": "module"
        },
        {
          "name": "Arg",
          "kind": "module"
        }
      ],
      "types": [],
      "values": [],
      "modules": [
        {
          "name": "Manpage",
          "kind": "module"
        },
        {
          "name": "Term",
          "kind": "module"
        },
        {
          "name": "Cmd",
          "kind": "module"
        },
        {
          "name": "Arg",
          "kind": "module"
        }
      ],
      "module_documentation": "Declarative definition of command line interfaces.\nConsult the tutorial, details about the supported command line syntax and examples of use.\nOpen the module to use it, it defines only three modules in your scope.\nMan page specification.\nTerms.\nCommands.\nTerms for command line arguments.",
      "sections": [],
      "package": "cmdliner",
      "version": "1.3.0",
      "file_path": "doc/cmdliner/Cmdliner.md",
      "library": "cmdliner",
      "module_path": [
        "Cmdliner"
      ]
    },
    {
      "elements": [
        {
          "kind": "section",
          "title": "Man pages",
          "level": 2,
          "content": ""
        },
        {
          "kind": "type",
          "name": "block",
          "signature": "type block = [",
          "anchor": "type-block"
        },
        {
          "kind": "value",
          "name": "escape",
          "signature": "val escape : string -> string",
          "documentation": "escape s escapes s so that it doesn't get interpreted by the documentation markup language.",
          "anchor": "val-escape"
        },
        {
          "kind": "type",
          "name": "title",
          "signature": "type title = string * int * string * string * string",
          "anchor": "type-title"
        },
        {
          "kind": "type",
          "name": "t",
          "signature": "type t = title * block list",
          "anchor": "type-t"
        },
        {
          "kind": "type",
          "name": "xref",
          "signature": "type xref = [",
          "anchor": "type-xref"
        },
        {
          "kind": "section",
          "title": "Standard section names and content",
          "level": 2,
          "content": "The following are standard man page section names, roughly ordered in the order they conventionally appear. See also man man-pages for more elaborations about what sections should contain."
        },
        {
          "kind": "value",
          "name": "s_name",
          "signature": "val s_name : string",
          "documentation": "The NAME section. This section is automatically created by Cmdliner for your.",
          "anchor": "val-s_name"
        },
        {
          "kind": "value",
          "name": "s_synopsis",
          "signature": "val s_synopsis : string",
          "documentation": "The SYNOPSIS section. By default this section is automatically created by Cmdliner for you, unless it is the first section of your term's man page, in which case it will replace it with yours.",
          "anchor": "val-s_synopsis"
        },
        {
          "kind": "value",
          "name": "s_description",
          "signature": "val s_description : string",
          "documentation": "The DESCRIPTION section. This should be a description of what the tool does and provide a little bit of usage and documentation guidance.",
          "anchor": "val-s_description"
        },
        {
          "kind": "value",
          "name": "s_commands",
          "signature": "val s_commands : string",
          "documentation": "The COMMANDS section. By default subcommands get listed here.",
          "anchor": "val-s_commands"
        },
        {
          "kind": "value",
          "name": "s_arguments",
          "signature": "val s_arguments : string",
          "documentation": "The ARGUMENTS section. By default positional arguments get listed here.",
          "anchor": "val-s_arguments"
        },
        {
          "kind": "value",
          "name": "s_options",
          "signature": "val s_options : string",
          "documentation": "The OPTIONS section. By default optional arguments get listed here.",
          "anchor": "val-s_options"
        },
        {
          "kind": "value",
          "name": "s_common_options",
          "signature": "val s_common_options : string",
          "documentation": "The COMMON OPTIONS section. By default help and version options get listed here. For programs with multiple commands, optional arguments common to all commands can be added here.",
          "anchor": "val-s_common_options"
        },
        {
          "kind": "value",
          "name": "s_exit_status",
          "signature": "val s_exit_status : string",
          "documentation": "The EXIT STATUS section. By default term status exit codes get listed here.",
          "anchor": "val-s_exit_status"
        },
        {
          "kind": "value",
          "name": "s_environment",
          "signature": "val s_environment : string",
          "documentation": "The ENVIRONMENT section. By default environment variables get listed here.",
          "anchor": "val-s_environment"
        },
        {
          "kind": "value",
          "name": "s_environment_intro",
          "signature": "val s_environment_intro : block",
          "documentation": "s_environment_intro is the introduction content used by cmdliner when it creates the s_environment section.",
          "anchor": "val-s_environment_intro"
        },
        {
          "kind": "value",
          "name": "s_files",
          "signature": "val s_files : string",
          "documentation": "The FILES section.",
          "anchor": "val-s_files"
        },
        {
          "kind": "value",
          "name": "s_bugs",
          "signature": "val s_bugs : string",
          "documentation": "The BUGS section.",
          "anchor": "val-s_bugs"
        },
        {
          "kind": "value",
          "name": "s_examples",
          "signature": "val s_examples : string",
          "documentation": "The EXAMPLES section.",
          "anchor": "val-s_examples"
        },
        {
          "kind": "value",
          "name": "s_authors",
          "signature": "val s_authors : string",
          "documentation": "The AUTHORS section.",
          "anchor": "val-s_authors"
        },
        {
          "kind": "value",
          "name": "s_see_also",
          "signature": "val s_see_also : string",
          "documentation": "The SEE ALSO section.",
          "anchor": "val-s_see_also"
        },
        {
          "kind": "value",
          "name": "s_none",
          "signature": "val s_none : string",
          "documentation": "s_none is a special section named \"cmdliner-none\" that can be used whenever you do not want something to be listed.",
          "anchor": "val-s_none"
        },
        {
          "kind": "section",
          "title": "Output",
          "level": 2,
          "content": "The print function can be useful if the client wants to define other man pages (e.g. to implement a help command)."
        },
        {
          "kind": "type",
          "name": "format",
          "signature": "type format = [",
          "anchor": "type-format"
        },
        {
          "kind": "value",
          "name": "print",
          "signature": "val print : ?errs:Format.formatter ->\n  ?subst:(string -> string option) ->\n  format ->\n  Format.formatter ->\n  t ->\n  unit",
          "documentation": "print ~errs ~subst fmt ppf page prints page on ppf in the format fmt. subst can be used to perform variable substitution,(defaults to the identity). errs is used to print formatting errors, it defaults to Format.err_formatter.",
          "anchor": "val-print"
        }
      ],
      "types": [
        {
          "kind": "type",
          "name": "block",
          "signature": "type block = [",
          "anchor": "type-block"
        },
        {
          "kind": "type",
          "name": "title",
          "signature": "type title = string * int * string * string * string",
          "anchor": "type-title"
        },
        {
          "kind": "type",
          "name": "t",
          "signature": "type t = title * block list",
          "anchor": "type-t"
        },
        {
          "kind": "type",
          "name": "xref",
          "signature": "type xref = [",
          "anchor": "type-xref"
        },
        {
          "kind": "type",
          "name": "format",
          "signature": "type format = [",
          "anchor": "type-format"
        }
      ],
      "values": [
        {
          "kind": "value",
          "name": "escape",
          "signature": "val escape : string -> string",
          "documentation": "escape s escapes s so that it doesn't get interpreted by the documentation markup language.",
          "anchor": "val-escape"
        },
        {
          "kind": "value",
          "name": "s_name",
          "signature": "val s_name : string",
          "documentation": "The NAME section. This section is automatically created by Cmdliner for your.",
          "anchor": "val-s_name"
        },
        {
          "kind": "value",
          "name": "s_synopsis",
          "signature": "val s_synopsis : string",
          "documentation": "The SYNOPSIS section. By default this section is automatically created by Cmdliner for you, unless it is the first section of your term's man page, in which case it will replace it with yours.",
          "anchor": "val-s_synopsis"
        },
        {
          "kind": "value",
          "name": "s_description",
          "signature": "val s_description : string",
          "documentation": "The DESCRIPTION section. This should be a description of what the tool does and provide a little bit of usage and documentation guidance.",
          "anchor": "val-s_description"
        },
        {
          "kind": "value",
          "name": "s_commands",
          "signature": "val s_commands : string",
          "documentation": "The COMMANDS section. By default subcommands get listed here.",
          "anchor": "val-s_commands"
        },
        {
          "kind": "value",
          "name": "s_arguments",
          "signature": "val s_arguments : string",
          "documentation": "The ARGUMENTS section. By default positional arguments get listed here.",
          "anchor": "val-s_arguments"
        },
        {
          "kind": "value",
          "name": "s_options",
          "signature": "val s_options : string",
          "documentation": "The OPTIONS section. By default optional arguments get listed here.",
          "anchor": "val-s_options"
        },
        {
          "kind": "value",
          "name": "s_common_options",
          "signature": "val s_common_options : string",
          "documentation": "The COMMON OPTIONS section. By default help and version options get listed here. For programs with multiple commands, optional arguments common to all commands can be added here.",
          "anchor": "val-s_common_options"
        },
        {
          "kind": "value",
          "name": "s_exit_status",
          "signature": "val s_exit_status : string",
          "documentation": "The EXIT STATUS section. By default term status exit codes get listed here.",
          "anchor": "val-s_exit_status"
        },
        {
          "kind": "value",
          "name": "s_environment",
          "signature": "val s_environment : string",
          "documentation": "The ENVIRONMENT section. By default environment variables get listed here.",
          "anchor": "val-s_environment"
        },
        {
          "kind": "value",
          "name": "s_environment_intro",
          "signature": "val s_environment_intro : block",
          "documentation": "s_environment_intro is the introduction content used by cmdliner when it creates the s_environment section.",
          "anchor": "val-s_environment_intro"
        },
        {
          "kind": "value",
          "name": "s_files",
          "signature": "val s_files : string",
          "documentation": "The FILES section.",
          "anchor": "val-s_files"
        },
        {
          "kind": "value",
          "name": "s_bugs",
          "signature": "val s_bugs : string",
          "documentation": "The BUGS section.",
          "anchor": "val-s_bugs"
        },
        {
          "kind": "value",
          "name": "s_examples",
          "signature": "val s_examples : string",
          "documentation": "The EXAMPLES section.",
          "anchor": "val-s_examples"
        },
        {
          "kind": "value",
          "name": "s_authors",
          "signature": "val s_authors : string",
          "documentation": "The AUTHORS section.",
          "anchor": "val-s_authors"
        },
        {
          "kind": "value",
          "name": "s_see_also",
          "signature": "val s_see_also : string",
          "documentation": "The SEE ALSO section.",
          "anchor": "val-s_see_also"
        },
        {
          "kind": "value",
          "name": "s_none",
          "signature": "val s_none : string",
          "documentation": "s_none is a special section named \"cmdliner-none\" that can be used whenever you do not want something to be listed.",
          "anchor": "val-s_none"
        },
        {
          "kind": "value",
          "name": "print",
          "signature": "val print : ?errs:Format.formatter ->\n  ?subst:(string -> string option) ->\n  format ->\n  Format.formatter ->\n  t ->\n  unit",
          "documentation": "print ~errs ~subst fmt ppf page prints page on ppf in the format fmt. subst can be used to perform variable substitution,(defaults to the identity). errs is used to print formatting errors, it defaults to Format.err_formatter.",
          "anchor": "val-print"
        }
      ],
      "modules": [],
      "module_documentation": "Man page specification.\nMan page generation is automatically handled by Cmdliner, consult the details.\nThe Manpage.block type is used to define a man page's content. It's a good idea to follow the standard manual page structure.\nReferences.",
      "sections": [
        {
          "kind": "section",
          "title": "Man pages",
          "level": 2,
          "content": ""
        },
        {
          "kind": "section",
          "title": "Standard section names and content",
          "level": 2,
          "content": "The following are standard man page section names, roughly ordered in the order they conventionally appear. See also man man-pages for more elaborations about what sections should contain."
        },
        {
          "kind": "section",
          "title": "Output",
          "level": 2,
          "content": "The print function can be useful if the client wants to define other man pages (e.g. to implement a help command)."
        }
      ],
      "package": "cmdliner",
      "version": "1.3.0",
      "file_path": "doc/cmdliner/Cmdliner-Manpage.md",
      "library": "cmdliner",
      "module_path": [
        "Cmdliner",
        "Manpage"
      ]
    },
    {
      "elements": [
        {
          "kind": "section",
          "title": "Exit codes",
          "level": 2,
          "content": ""
        },
        {
          "kind": "type",
          "name": "code",
          "signature": "type code = int",
          "anchor": "type-code"
        },
        {
          "kind": "value",
          "name": "ok",
          "signature": "val ok : code",
          "documentation": "ok is 0, the exit status for success.",
          "anchor": "val-ok"
        },
        {
          "kind": "value",
          "name": "some_error",
          "signature": "val some_error : code",
          "documentation": "some_error is 123, an exit status for indisciminate errors reported on stderr.",
          "anchor": "val-some_error"
        },
        {
          "kind": "value",
          "name": "cli_error",
          "signature": "val cli_error : code",
          "documentation": "cli_error is 124, an exit status for command line parsing errors.",
          "anchor": "val-cli_error"
        },
        {
          "kind": "value",
          "name": "internal_error",
          "signature": "val internal_error : code",
          "documentation": "internal_error is 125, an exit status for unexpected internal errors.",
          "anchor": "val-internal_error"
        },
        {
          "kind": "section",
          "title": "Exit code information",
          "level": 2,
          "content": ""
        },
        {
          "kind": "type",
          "name": "info",
          "signature": "type info",
          "anchor": "type-info"
        },
        {
          "kind": "value",
          "name": "info",
          "signature": "val info : ?docs:string -> ?doc:string -> ?max:code -> code -> info",
          "documentation": "exit_info ~docs ~doc min ~max describe the range of exit statuses from min to max (defaults to min). doc is the man page information for the statuses, defaults to \"undocumented\". docs is the title of the man page section in which the statuses will be listed, it defaults to Manpage.s_exit_status.",
          "anchor": "val-info"
        },
        {
          "kind": "value",
          "name": "info_code",
          "signature": "val info_code : info -> code",
          "documentation": "info_code i is the minimal code of i.",
          "anchor": "val-info_code"
        },
        {
          "kind": "value",
          "name": "defaults",
          "signature": "val defaults : info list",
          "documentation": "defaults are exit code information for ok, some_error cli_error and internal_error.",
          "anchor": "val-defaults"
        }
      ],
      "types": [
        {
          "kind": "type",
          "name": "code",
          "signature": "type code = int",
          "anchor": "type-code"
        },
        {
          "kind": "type",
          "name": "info",
          "signature": "type info",
          "anchor": "type-info"
        }
      ],
      "values": [
        {
          "kind": "value",
          "name": "ok",
          "signature": "val ok : code",
          "documentation": "ok is 0, the exit status for success.",
          "anchor": "val-ok"
        },
        {
          "kind": "value",
          "name": "some_error",
          "signature": "val some_error : code",
          "documentation": "some_error is 123, an exit status for indisciminate errors reported on stderr.",
          "anchor": "val-some_error"
        },
        {
          "kind": "value",
          "name": "cli_error",
          "signature": "val cli_error : code",
          "documentation": "cli_error is 124, an exit status for command line parsing errors.",
          "anchor": "val-cli_error"
        },
        {
          "kind": "value",
          "name": "internal_error",
          "signature": "val internal_error : code",
          "documentation": "internal_error is 125, an exit status for unexpected internal errors.",
          "anchor": "val-internal_error"
        },
        {
          "kind": "value",
          "name": "info",
          "signature": "val info : ?docs:string -> ?doc:string -> ?max:code -> code -> info",
          "documentation": "exit_info ~docs ~doc min ~max describe the range of exit statuses from min to max (defaults to min). doc is the man page information for the statuses, defaults to \"undocumented\". docs is the title of the man page section in which the statuses will be listed, it defaults to Manpage.s_exit_status.",
          "anchor": "val-info"
        },
        {
          "kind": "value",
          "name": "info_code",
          "signature": "val info_code : info -> code",
          "documentation": "info_code i is the minimal code of i.",
          "anchor": "val-info_code"
        },
        {
          "kind": "value",
          "name": "defaults",
          "signature": "val defaults : info list",
          "documentation": "defaults are exit code information for ok, some_error cli_error and internal_error.",
          "anchor": "val-defaults"
        }
      ],
      "modules": [],
      "module_documentation": "Exit codes and their information.",
      "sections": [
        {
          "kind": "section",
          "title": "Exit codes",
          "level": 2,
          "content": ""
        },
        {
          "kind": "section",
          "title": "Exit code information",
          "level": 2,
          "content": ""
        }
      ],
      "package": "cmdliner",
      "version": "1.3.0",
      "file_path": "doc/cmdliner/Cmdliner-Cmd-Exit.md",
      "library": "cmdliner",
      "module_path": [
        "Cmdliner",
        "Cmd",
        "Exit"
      ]
    },
    {
      "elements": [],
      "types": [],
      "values": [],
      "modules": [],
      "module_documentation": "let operators.\n( let+ ) is map.\n( and* ) is product.",
      "sections": [],
      "package": "cmdliner",
      "version": "1.3.0",
      "file_path": "doc/cmdliner/Cmdliner-Term-Syntax.md",
      "library": "cmdliner",
      "module_path": [
        "Cmdliner",
        "Term",
        "Syntax"
      ]
    },
    {
      "elements": [
        {
          "kind": "section",
          "title": "Environment variables",
          "level": 2,
          "content": ""
        },
        {
          "kind": "type",
          "name": "var",
          "signature": "type var = string",
          "anchor": "type-var"
        },
        {
          "kind": "section",
          "title": "Environment variable information",
          "level": 2,
          "content": ""
        },
        {
          "kind": "type",
          "name": "info",
          "signature": "type info = Term.env_info",
          "anchor": "type-info"
        },
        {
          "kind": "value",
          "name": "info",
          "signature": "val info : ?deprecated:string -> ?docs:string -> ?doc:string -> var -> info",
          "documentation": "info ~docs ~doc var describes an environment variable var such that:",
          "anchor": "val-info"
        }
      ],
      "types": [
        {
          "kind": "type",
          "name": "var",
          "signature": "type var = string",
          "anchor": "type-var"
        },
        {
          "kind": "type",
          "name": "info",
          "signature": "type info = Term.env_info",
          "anchor": "type-info"
        }
      ],
      "values": [
        {
          "kind": "value",
          "name": "info",
          "signature": "val info : ?deprecated:string -> ?docs:string -> ?doc:string -> var -> info",
          "documentation": "info ~docs ~doc var describes an environment variable var such that:",
          "anchor": "val-info"
        }
      ],
      "modules": [],
      "module_documentation": "Environment variable and their information.",
      "sections": [
        {
          "kind": "section",
          "title": "Environment variables",
          "level": 2,
          "content": ""
        },
        {
          "kind": "section",
          "title": "Environment variable information",
          "level": 2,
          "content": ""
        }
      ],
      "package": "cmdliner",
      "version": "1.3.0",
      "file_path": "doc/cmdliner/Cmdliner-Cmd-Env.md",
      "library": "cmdliner",
      "module_path": [
        "Cmdliner",
        "Cmd",
        "Env"
      ]
    }
  ],
  "package_documentation": {
    "EXAMPLES": {
      "content": "\n# Examples\n\nThe examples are self-contained, cut and paste them in a file to play with them.\n\n\n## A `rm` command\n\nWe define the command line interface of an `rm` command with the synopsis:\n\n```\nrm [OPTION]… FILE…\n```\nThe `-f`, `-i` and `-I` flags define the prompt behaviour of `rm`. It is represented in our program by the `prompt` type. If more than one of these flags is present on the command line the last one takes precedence.\n\nTo implement this behaviour we map the presence of these flags to values of the `prompt` type by using [`Cmdliner.Arg.vflag_all`](./cmdliner/Cmdliner-Arg.md#val-vflag_all).\n\nThis argument will contain all occurrences of the flag on the command line and we just take the [`Cmdliner.Arg.last`](./cmdliner/Cmdliner-Arg.md#val-last) one to define our term value. If there is no occurrence the last value of the default list `[Always]` is taken. This means the default prompt behaviour is `Always`.\n\n```ocaml\n(* Implementation of the command, we just print the args. *)\n\ntype prompt = Always | Once | Never\nlet prompt_str = function\n| Always -> \"always\" | Once -> \"once\" | Never -> \"never\"\n\nlet rm prompt recurse files =\n  Printf.printf \"prompt = %s\\nrecurse = %B\\nfiles = %s\\n\"\n    (prompt_str prompt) recurse (String.concat \", \" files)\n\n(* Command line interface *)\n\nopen Cmdliner\n\nlet files = Arg.(non_empty & pos_all file [] & info [] ~docv:\"FILE\")\nlet prompt =\n  let always =\n    let doc = \"Prompt before every removal.\" in\n    Always, Arg.info [\"i\"] ~doc\n  in\n  let never =\n    let doc = \"Ignore nonexistent files and never prompt.\" in\n    Never, Arg.info [\"f\"; \"force\"] ~doc\n  in\n  let once =\n    let doc = \"Prompt once before removing more than three files, or when\n               removing recursively. Less intrusive than $(b,-i), while\n               still giving protection against most mistakes.\"\n    in\n    Once, Arg.info [\"I\"] ~doc\n  in\n  Arg.(last & vflag_all [Always] [always; never; once])\n\nlet recursive =\n  let doc = \"Remove directories and their contents recursively.\" in\n  Arg.(value & flag & info [\"r\"; \"R\"; \"recursive\"] ~doc)\n\nlet cmd =\n  let doc = \"Remove files or directories\" in\n  let man = [\n    `S Manpage.s_description;\n    `P \"$(tname) removes each specified $(i,FILE). By default it does not\n        remove directories, to also remove them and their contents, use the\n        option $(b,--recursive) ($(b,-r) or $(b,-R)).\";\n    `P \"To remove a file whose name starts with a $(b,-), for example\n        $(b,-foo), use one of these commands:\";\n    `Pre \"$(mname) $(b,-- -foo)\"; `Noblank;\n    `Pre \"$(mname) $(b,./-foo)\";\n    `P \"$(tname) removes symbolic links, not the files referenced by the\n        links.\";\n    `S Manpage.s_bugs; `P \"Report bugs to <bugs@example.org>.\";\n    `S Manpage.s_see_also; `P \"$(b,rmdir)(1), $(b,unlink)(2)\" ]\n  in\n  let info = Cmd.info \"rm\" ~version:\"v1.3.0\" ~doc ~man in\n  Cmd.v info Term.(const rm $ prompt $ recursive $ files)\n\nlet main () = exit (Cmd.eval cmd)\nlet () = main ()\n```\n\n## A `cp` command\n\nWe define the command line interface of a `cp` command with the synopsis:\n\n```\ncp [OPTION]… SOURCE… DEST\n```\nThe `DEST` argument must be a directory if there is more than one `SOURCE`. This constraint is too complex to be expressed by the combinators of [`Cmdliner.Arg`](./cmdliner/Cmdliner-Arg.md).\n\nHence we just give `DEST` the [`Cmdliner.Arg.string`](./cmdliner/Cmdliner-Arg.md#val-string) type and verify the constraint at the beginning of the implementation of `cp`. If the constraint is unsatisfied we return an ``Error` result. By using [`Cmdliner.Term.ret`](./cmdliner/Cmdliner-Term.md#val-ret) on the lifted result `cp_t` of `cp`, `Cmdliner` handles the error reporting.\n\n```ocaml\n(* Implementation, we check the dest argument and print the args *)\n\nlet cp verbose recurse force srcs dest =\n  let many = List.length srcs > 1 in\n  if many && (not (Sys.file_exists dest) || not (Sys.is_directory dest))\n  then `Error (false, dest ^ \": not a directory\") else\n  `Ok (Printf.printf\n         \"verbose = %B\\nrecurse = %B\\nforce = %B\\nsrcs = %s\\ndest = %s\\n\"\n         verbose recurse force (String.concat \", \" srcs) dest)\n\n(* Command line interface *)\n\nopen Cmdliner\n\nlet verbose =\n  let doc = \"Print file names as they are copied.\" in\n  Arg.(value & flag & info [\"v\"; \"verbose\"] ~doc)\n\nlet recurse =\n  let doc = \"Copy directories recursively.\" in\n  Arg.(value & flag & info [\"r\"; \"R\"; \"recursive\"] ~doc)\n\nlet force =\n  let doc = \"If a destination file cannot be opened, remove it and try again.\"in\n  Arg.(value & flag & info [\"f\"; \"force\"] ~doc)\n\nlet srcs =\n  let doc = \"Source file(s) to copy.\" in\n  Arg.(non_empty & pos_left ~rev:true 0 file [] & info [] ~docv:\"SOURCE\" ~doc)\n\nlet dest =\n  let doc = \"Destination of the copy. Must be a directory if there is more \\\n             than one $(i,SOURCE).\" in\n  let docv = \"DEST\" in\n  Arg.(required & pos ~rev:true 0 (some string) None & info [] ~docv ~doc)\n\nlet cmd =\n  let doc = \"Copy files\" in\n  let man_xrefs =\n    [ `Tool \"mv\"; `Tool \"scp\"; `Page (\"umask\", 2); `Page (\"symlink\", 7) ]\n  in\n  let man =\n    [ `S Manpage.s_bugs;\n      `P \"Email them to <bugs@example.org>.\"; ]\n  in\n  let info = Cmd.info \"cp\" ~version:\"v1.3.0\" ~doc ~man ~man_xrefs in\n  Cmd.v info Term.(ret (const cp $ verbose $ recurse $ force $ srcs $ dest))\n\n\nlet main () = exit (Cmd.eval cmd)\nlet () = main ()\n```\n\n## A `tail` command\n\nWe define the command line interface of a `tail` command with the synopsis:\n\n```\ntail [OPTION]… [FILE]…\n```\nThe `--lines` option whose value specifies the number of last lines to print has a special syntax where a `+` prefix indicates to start printing from that line number. In the program this is represented by the `loc` type. We define a custom `loc_arg` [argument converter](./cmdliner/Cmdliner-Arg.md#type-conv) for this option.\n\nThe `--follow` option has an optional enumerated value. The argument converter `follow`, created with [`Cmdliner.Arg.enum`](./cmdliner/Cmdliner-Arg.md#val-enum) parses the option value into the enumeration. By using [`Cmdliner.Arg.some`](./cmdliner/Cmdliner-Arg.md#val-some) and the `~vopt` argument of [`Cmdliner.Arg.opt`](./cmdliner/Cmdliner-Arg.md#val-opt), the term corresponding to the option `--follow` evaluates to `None` if `--follow` is absent from the command line, to `Some Descriptor` if present but without a value and to `Some v` if present with a value `v` specified.\n\n```ocaml\n(* Implementation of the command, we just print the args. *)\n\ntype loc = bool * int\ntype verb = Verbose | Quiet\ntype follow = Name | Descriptor\n\nlet str = Printf.sprintf\nlet opt_str sv = function None -> \"None\" | Some v -> str \"Some(%s)\" (sv v)\nlet loc_str (rev, k) = if rev then str \"%d\" k else str \"+%d\" k\nlet follow_str = function Name -> \"name\" | Descriptor -> \"descriptor\"\nlet verb_str = function Verbose -> \"verbose\" | Quiet -> \"quiet\"\n\nlet tail lines follow verb pid files =\n  Printf.printf\n    \"lines = %s\\nfollow = %s\\nverb = %s\\npid = %s\\nfiles = %s\\n\"\n    (loc_str lines) (opt_str follow_str follow) (verb_str verb)\n    (opt_str string_of_int pid) (String.concat \", \" files)\n\n(* Command line interface *)\n\nopen Cmdliner\n\nlet loc_arg =\n  let parse s =\n    try\n      if s <> \"\" && s.[0] <> '+'\n      then Ok (true, int_of_string s)\n      else Ok (false, int_of_string (String.sub s 1 (String.length s - 1)))\n    with Failure _ -> Error (`Msg \"unable to parse integer\")\n  in\n  let print ppf p = Format.fprintf ppf \"%s\" (loc_str p) in\n  Arg.conv ~docv:\"N\" (parse, print)\n\nlet lines =\n  let doc = \"Output the last $(docv) lines or use $(i,+)$(docv) to start \\\n             output after the $(i,N)-1th line.\"\n  in\n  Arg.(value & opt loc_arg (true, 10) & info [\"n\"; \"lines\"] ~docv:\"N\" ~doc)\n\nlet follow =\n  let doc = \"Output appended data as the file grows. $(docv) specifies how \\\n             the file should be tracked, by its $(b,name) or by its \\\n             $(b,descriptor).\"\n  in\n  let follow = Arg.enum [\"name\", Name; \"descriptor\", Descriptor] in\n  Arg.(value & opt (some follow) ~vopt:(Some Descriptor) None &\n       info [\"f\"; \"follow\"] ~docv:\"ID\" ~doc)\n\nlet verb =\n  let quiet =\n    let doc = \"Never output headers giving file names.\" in\n    Quiet, Arg.info [\"q\"; \"quiet\"; \"silent\"] ~doc\n  in\n  let verbose =\n    let doc = \"Always output headers giving file names.\" in\n    Verbose, Arg.info [\"v\"; \"verbose\"] ~doc\n  in\n  Arg.(last & vflag_all [Quiet] [quiet; verbose])\n\nlet pid =\n  let doc = \"With -f, terminate after process $(docv) dies.\" in\n  Arg.(value & opt (some int) None & info [\"pid\"] ~docv:\"PID\" ~doc)\n\nlet files = Arg.(value & (pos_all non_dir_file []) & info [] ~docv:\"FILE\")\n\nlet cmd =\n  let doc = \"Display the last part of a file\" in\n  let man = [\n    `S Manpage.s_description;\n    `P \"$(tname) prints the last lines of each $(i,FILE) to standard output. If\n        no file is specified reads standard input. The number of printed\n        lines can be  specified with the $(b,-n) option.\";\n    `S Manpage.s_bugs;\n    `P \"Report them to <bugs@example.org>.\";\n    `S Manpage.s_see_also;\n    `P \"$(b,cat)(1), $(b,head)(1)\" ]\n  in\n  let info = Cmd.info \"tail\" ~version:\"v1.3.0\" ~doc ~man in\n  Cmd.v info Term.(const tail $ lines $ follow $ verb $ pid $ files)\n\n\nlet main () = exit (Cmd.eval cmd)\nlet () = main ()\n```\n\n## A `darcs` command\n\nWe define the command line interface of a `darcs` command with the synopsis:\n\n```\ndarcs [COMMAND] …\n```\nThe `--debug`, `-q`, `-v` and `--prehook` options are available in each command. To avoid having to pass them individually to each command we gather them in a record of type `copts`. By lifting the record constructor `copts` into the term `copts_t` we now have a term that we can pass to the commands to stand for an argument of type `copts`. These options are documented in a section called `COMMON OPTIONS`, since we also want to put `--help` and `--version` in this section, the term information of commands makes a judicious use of the `sdocs` parameter of [`Cmdliner.Term.info`](./cmdliner/Cmdliner-Term.md#val-info).\n\nThe `help` command shows help about commands or other topics. The help shown for commands is generated by `Cmdliner` by making an appropriate use of [`Cmdliner.Term.ret`](./cmdliner/Cmdliner-Term.md#val-ret) on the lifted `help` function.\n\nIf the program is invoked without a command we just want to show the help of the program as printed by `Cmdliner` with `--help`. This is done by the `default_cmd` term.\n\n```ocaml\n(* Implementations, just print the args. *)\n\ntype verb = Normal | Quiet | Verbose\ntype copts = { debug : bool; verb : verb; prehook : string option }\n\nlet str = Printf.sprintf\nlet opt_str sv = function None -> \"None\" | Some v -> str \"Some(%s)\" (sv v)\nlet opt_str_str = opt_str (fun s -> s)\nlet verb_str = function\n  | Normal -> \"normal\" | Quiet -> \"quiet\" | Verbose -> \"verbose\"\n\nlet pr_copts oc copts = Printf.fprintf oc\n    \"debug = %B\\nverbosity = %s\\nprehook = %s\\n\"\n    copts.debug (verb_str copts.verb) (opt_str_str copts.prehook)\n\nlet initialize copts repodir = Printf.printf\n    \"%arepodir = %s\\n\" pr_copts copts repodir\n\nlet record copts name email all ask_deps files = Printf.printf\n    \"%aname = %s\\nemail = %s\\nall = %B\\nask-deps = %B\\nfiles = %s\\n\"\n    pr_copts copts (opt_str_str name) (opt_str_str email) all ask_deps\n    (String.concat \", \" files)\n\nlet help copts man_format cmds topic = match topic with\n| None -> `Help (`Pager, None) (* help about the program. *)\n| Some topic ->\n    let topics = \"topics\" :: \"patterns\" :: \"environment\" :: cmds in\n    let conv, _ = Cmdliner.Arg.enum (List.rev_map (fun s -> (s, s)) topics) in\n    match conv topic with\n    | `Error e -> `Error (false, e)\n    | `Ok t when t = \"topics\" -> List.iter print_endline topics; `Ok ()\n    | `Ok t when List.mem t cmds -> `Help (man_format, Some t)\n    | `Ok t ->\n        let page = (topic, 7, \"\", \"\", \"\"), [`S topic; `P \"Say something\";] in\n        `Ok (Cmdliner.Manpage.print man_format Format.std_formatter page)\n\nopen Cmdliner\n\n(* Help sections common to all commands *)\n\nlet help_secs = [\n `S Manpage.s_common_options;\n `P \"These options are common to all commands.\";\n `S \"MORE HELP\";\n `P \"Use $(mname) $(i,COMMAND) --help for help on a single command.\";`Noblank;\n `P \"Use $(mname) $(b,help patterns) for help on patch matching.\"; `Noblank;\n `P \"Use $(mname) $(b,help environment) for help on environment variables.\";\n `S Manpage.s_bugs; `P \"Check bug reports at http://bugs.example.org.\";]\n\n(* Options common to all commands *)\n\nlet copts debug verb prehook = { debug; verb; prehook }\nlet copts_t =\n  let docs = Manpage.s_common_options in\n  let debug =\n    let doc = \"Give only debug output.\" in\n    Arg.(value & flag & info [\"debug\"] ~docs ~doc)\n  in\n  let verb =\n    let doc = \"Suppress informational output.\" in\n    let quiet = Quiet, Arg.info [\"q\"; \"quiet\"] ~docs ~doc in\n    let doc = \"Give verbose output.\" in\n    let verbose = Verbose, Arg.info [\"v\"; \"verbose\"] ~docs ~doc in\n    Arg.(last & vflag_all [Normal] [quiet; verbose])\n  in\n  let prehook =\n    let doc = \"Specify command to run before this $(mname) command.\" in\n    Arg.(value & opt (some string) None & info [\"prehook\"] ~docs ~doc)\n  in\n  Term.(const copts $ debug $ verb $ prehook)\n\n(* Commands *)\n\nlet sdocs = Manpage.s_common_options\n\nlet initialize_cmd =\n  let repodir =\n    let doc = \"Run the program in repository directory $(docv).\" in\n    Arg.(value & opt file Filename.current_dir_name & info [\"repodir\"]\n           ~docv:\"DIR\" ~doc)\n  in\n  let doc = \"make the current directory a repository\" in\n  let man = [\n    `S Manpage.s_description;\n    `P \"Turns the current directory into a Darcs repository. Any\n       existing files and subdirectories become …\";\n    `Blocks help_secs; ]\n  in\n  let info = Cmd.info \"initialize\" ~doc ~sdocs ~man in\n  Cmd.v info Term.(const initialize $ copts_t $ repodir)\n\nlet record_cmd =\n  let pname =\n    let doc = \"Name of the patch.\" in\n    Arg.(value & opt (some string) None & info [\"m\"; \"patch-name\"] ~docv:\"NAME\"\n           ~doc)\n  in\n  let author =\n    let doc = \"Specifies the author's identity.\" in\n    Arg.(value & opt (some string) None & info [\"A\"; \"author\"] ~docv:\"EMAIL\"\n           ~doc)\n  in\n  let all =\n    let doc = \"Answer yes to all patches.\" in\n    Arg.(value & flag & info [\"a\"; \"all\"] ~doc)\n  in\n  let ask_deps =\n    let doc = \"Ask for extra dependencies.\" in\n    Arg.(value & flag & info [\"ask-deps\"] ~doc)\n  in\n  let files = Arg.(value & (pos_all file) [] & info [] ~docv:\"FILE or DIR\") in\n  let doc = \"create a patch from unrecorded changes\" in\n  let man =\n    [`S Manpage.s_description;\n     `P \"Creates a patch from changes in the working tree. If you specify\n         a set of files …\";\n     `Blocks help_secs; ]\n  in\n  let info = Cmd.info \"record\" ~doc ~sdocs ~man in\n  Cmd.v info\n    Term.(const record $ copts_t $ pname $ author $ all $ ask_deps $ files)\n\nlet help_cmd =\n  let topic =\n    let doc = \"The topic to get help on. $(b,topics) lists the topics.\" in\n    Arg.(value & pos 0 (some string) None & info [] ~docv:\"TOPIC\" ~doc)\n  in\n  let doc = \"display help about darcs and darcs commands\" in\n  let man =\n    [`S Manpage.s_description;\n     `P \"Prints help about darcs commands and other subjects…\";\n     `Blocks help_secs; ]\n  in\n  let info = Cmd.info \"help\" ~doc ~man in\n  Cmd.v info\n    Term.(ret (const help $ copts_t $ Arg.man_format $ Term.choice_names $\n               topic))\n\nlet main_cmd =\n  let doc = \"a revision control system\" in\n  let man = help_secs in\n  let info = Cmd.info \"darcs\" ~version:\"v1.3.0\" ~doc ~sdocs ~man in\n  let default = Term.(ret (const (fun _ -> `Help (`Pager, None)) $ copts_t)) in\n  Cmd.group info ~default [initialize_cmd; record_cmd; help_cmd]\n\nlet () = exit (Cmd.eval main_cmd)\n```",
      "type": "documentation",
      "package": "cmdliner",
      "version": "1.3.0",
      "file_path": "doc/examples.md",
      "library": null,
      "module_path": [
        "examples"
      ]
    },
    "LICENSE": {
      "content": "Copyright (c) 2011 The cmdliner programmers\n\nPermission to use, copy, modify, and/or distribute this software for any purpose with or without fee is hereby granted, provided that the above copyright notice and this permission notice appear in all copies.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n",
      "type": "documentation",
      "package": "cmdliner",
      "version": "1.3.0",
      "file_path": "doc/LICENSE.md",
      "library": null,
      "module_path": [
        "LICENSE"
      ]
    },
    "CLI": {
      "content": "\n# Command line interface\n\nFor tools evaluating a command without sub commands the most general form of invocation is:\n\n```ocaml\ntool [OPTION]… [ARG]…\n```\nThe tool automatically reponds to the `--help` option by printing the help. If a version string is provided in the [command information](./cmdliner/Cmdliner-Cmd.md#val-info), it also automatically responds to the `--version` option by printing this string on standard output.\n\nCommand line arguments are either [*optional*](./#optargs) or [*positional*](./#posargs). Both can be freely interleaved but since `Cmdliner` accepts many optional forms this may result in ambiguities. The special [token `--`](./#posargs) can be used to resolve them; anything that follows it is treated as a positional argument.\n\nTools evaluating commands with sub commands have this form of invocation\n\n```ocaml\ntool [COMMAND]… [OPTION]… [ARG]…\n```\nCommands automatically respond to the `--help` option by printing their help. The sequence of `COMMAND` strings must be the first strings following the tool name – as soon as an optional argument is seen the search for a sub command stops. Command names may be specified by a prefixe as long as they are not ambiguous.\n\n\n## Optional arguments\n\nAn optional argument is specified on the command line by a *name* possibly followed by a *value*.\n\nThe name of an option can be short or long.\n\n- A *short* name is a dash followed by a single alphanumeric character: `-h`, `-q`, `-I`.\n- A *long* name is two dashes followed by alphanumeric characters and dashes: `--help`, `--silent`, `--ignore-case`.\nMore than one name may refer to the same optional argument. For example in a given program the names `-q`, `--quiet` and `--silent` may all stand for the same boolean argument indicating the program to be quiet. Long names can be specified by any non ambiguous prefix.\n\nThe value of an option can be specified in three different ways.\n\n- As the next token on the command line: `-o a.out`, `--output a.out`.\n- Glued to a short name: `-oa.out`.\n- Glued to a long name after an equal character: `--output=a.out`.\nGlued forms are especially useful if the value itself starts with a dash as is the case for negative numbers, `--min=-10`.\n\nAn optional argument without a value is either a *flag* (see [`Cmdliner.Arg.flag`](./cmdliner/Cmdliner-Arg.md#val-flag), [`Cmdliner.Arg.vflag`](./cmdliner/Cmdliner-Arg.md#val-vflag)) or an optional argument with an optional value (see the `~vopt` argument of [`Cmdliner.Arg.opt`](./cmdliner/Cmdliner-Arg.md#val-opt)).\n\nShort flags can be grouped together to share a single dash and the group can end with a short option. For example assuming `-v` and `-x` are flags and `-f` is a short option:\n\n- `-vx` will be parsed as `-v -x`.\n- `-vxfopt` will be parsed as `-v -x -fopt`.\n- `-vxf opt` will be parsed as `-v -x -fopt`.\n- `-fvx` will be parsed as `-f=vx`.\n\n## Positional arguments\n\nPositional arguments are tokens on the command line that are not option names and are not the value of an optional argument. They are numbered from left to right starting with zero.\n\nSince positional arguments may be mistaken as the optional value of an optional argument or they may need to look like option names, anything that follows the special token `\"--\"` on the command line is considered to be a positional argument:\n\n```ocaml\ntool --option -- we -are --all positional --argu=ments\n```\n\n## Environment variables\n\nNon-required command line arguments can be backed up by an environment variable. If the argument is absent from the command line and that the environment variable is defined, its value is parsed using the argument converter and defines the value of the argument.\n\nFor [`Cmdliner.Arg.flag`](./cmdliner/Cmdliner-Arg.md#val-flag) and [`Cmdliner.Arg.flag_all`](./cmdliner/Cmdliner-Arg.md#val-flag_all) that do not have an argument converter a boolean is parsed from the lowercased variable value as follows:\n\n- `\"\"`, `\"false\"`, `\"no\"`, `\"n\"` or `\"0\"` is `false`.\n- `\"true\"`, `\"yes\"`, `\"y\"` or `\"1\"` is `true`.\n- Any other string is an error.\nNote that environment variables are not supported for [`Cmdliner.Arg.vflag`](./cmdliner/Cmdliner-Arg.md#val-vflag) and [`Cmdliner.Arg.vflag_all`](./cmdliner/Cmdliner-Arg.md#val-vflag_all).\n\n\n## Reserved option names\n\nUsing the cmdliner library puts the following constraints o\n\n- The option name `--cmdliner` is reserved by the library.\n- The option name `--help`, (and `--version` if you specify a version string) is reserved by the library. Using it as a term or option name may result in undefined behaviour.\n- Defining the same option or command name via two different arguments or terms is illegal and raises `Invalid_argument`.",
      "type": "documentation",
      "package": "cmdliner",
      "version": "1.3.0",
      "file_path": "doc/cli.md",
      "library": null,
      "module_path": [
        "cli"
      ]
    },
    "README": {
      "content": "\n### Cmdliner — Declarative definition of command line interfaces for OCaml\n\nv1.3.0\n\nCmdliner allows the declarative definition of command line interfaces for OCaml.\n\nIt provides a simple and compositional mechanism to convert command line arguments to OCaml values and pass them to your functions. The module automatically handles syntax errors, help messages and UNIX man page generation. It supports programs with single or multiple commands and respects most of the [POSIX](http://pubs.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap12.html) and [GNU](http://www.gnu.org/software/libc/manual/html_node/Argument-Syntax.html) conventions.\n\nCmdliner has no dependencies and is distributed under the ISC license.\n\nHome page: http://erratique.ch/software/cmdliner\n\n\n### Installation\n\nCmdliner can be installed with `opam`:\n\n```ocaml\nopam install cmdliner\n```\nIf you don't use `opam` consult the [`opam`](opam) file for build instructions.\n\n\n### Documentation\n\nThe documentation and API reference is automatically generated by from the source interfaces. It can be consulted [online](http://erratique.ch/software/cmdliner/doc/Cmdliner) or via `odig doc cmdliner`.\n\n\n### Sample programs\n\nIf you installed Cmdliner with `opam` sample programs are located in the directory `opam config var cmdliner:doc`. These programs define the command line of some classic programs.\n\nIn the distribution sample programs are located in the `test` directory of the distribution. They can be built and run with:\n\n```ocaml\ntopkg build --tests true && topkg test\n```",
      "type": "documentation",
      "package": "cmdliner",
      "version": "1.3.0",
      "file_path": "doc/README.md",
      "library": null,
      "module_path": [
        "README"
      ]
    },
    "TUTORIAL": {
      "content": "\n# Tutorial\n\n\n## Getting started\n\nWith `Cmdliner` your tool's `main` function evaluates a command.\n\nA command is a value of type [`Cmdliner.Cmd.t`](./cmdliner/Cmdliner-Cmd.md#type-t) which gathers a command name and a term of type [`Cmdliner.Term.t`](./cmdliner/Cmdliner-Term.md#type-t). A term is an expression to be evaluated. The type parameter of the term (and the command) indicates the type of the result of the evaluation.\n\nOne way to create terms is by lifting regular OCaml values with [`Cmdliner.Term.const`](./cmdliner/Cmdliner-Term.md#val-const). Terms can be applied to terms evaluating to functional values with [`Cmdliner.Term.($)`](./cmdliner/Cmdliner-Term.md#val-\\($\\)).\n\nFor example, in a `revolt.ml` file, for the function:\n\n```ocaml\nlet revolt () = print_endline \"Revolt!\"\n```\nthe term :\n\n```ocaml\nopen Cmdliner\n\nlet revolt_t = Term.(const revolt $ const ())\n```\nis a term that evaluates to the result (and effect) of the `revolt` function. This term can be attached to a command:\n\n```ocaml\nlet cmd = Cmd.v (Cmd.info \"revolt\") revolt_t\n```\nand evaluated with [`Cmdliner.Cmd.eval`](./cmdliner/Cmdliner-Cmd.md#val-eval):\n\n```ocaml\nlet () = exit (Cmd.eval cmd)\n```\nThis defines a command line tool named `\"revolt\"` (this name will be used in error reporting and documentation generation), without command line arguments, that just prints `\"Revolt!\"` on `stdout`.\n\n```ocaml\n> ocamlfind ocamlopt -linkpkg -package cmdliner -o revolt revolt.ml\n> ./revolt\nRevolt!\n```\nThe combinators in the [`Cmdliner.Arg`](./cmdliner/Cmdliner-Arg.md) module allow to extract command line arguments as terms. These terms can then be applied to lifted OCaml functions to be evaluated.\n\nTerms corresponding to command line argument data that are part of a term evaluation implicitly define a command line syntax. We show this on an concrete example.\n\nIn a `chorus.ml` file, consider the `chorus` function that prints repeatedly a given message :\n\n```ocaml\nlet chorus count msg = for i = 1 to count do print_endline msg done\n```\nwe want to make it available from the command line with the synopsis:\n\n```ocaml\nchorus [-c COUNT | --count=COUNT] [MSG]\n```\nwhere `COUNT` defaults to `10` and `MSG` defaults to `\"Revolt!\"`. We first define a term corresponding to the `--count` option:\n\n```ocaml\nlet count =\n  let doc = \"Repeat the message $(docv) times.\" in\n  Arg.(value & opt int 10 & info [\"c\"; \"count\"] ~docv:\"COUNT\" ~doc)\n```\nThis says that `count` is a term that evaluates to the value of an optional argument of type `int` that defaults to `10` if unspecified and whose option name is either `-c` or `--count`. The arguments `doc` and `docv` are used to generate the option's man page information.\n\nThe term for the positional argument `MSG` is:\n\n```ocaml\nlet msg =\n  let env =\n    let doc = \"Overrides the default message to print.\" in\n    Cmd.Env.info \"CHORUS_MSG\" ~doc\n  in\n  let doc = \"The message to print.\" in\n  Arg.(value & pos 0 string \"Revolt!\" & info [] ~env ~docv:\"MSG\" ~doc)\n```\nwhich says that `msg` is a term whose value is the positional argument at index `0` of type `string` and defaults to `\"Revolt!\"` or the value of the environment variable `CHORUS_MSG` if the argument is unspecified on the command line. Here again `doc` and `docv` are used for the man page information.\n\nThe term for executing `chorus` with these command line arguments is :\n\n```ocaml\nlet chorus_t = Term.(const chorus $ count $ msg)\n```\nWe are now ready to define the `main` function of our tool:\n\n```ocaml\nlet cmd =\n  let doc = \"print a customizable message repeatedly\" in\n  let man = [\n    `S Manpage.s_bugs;\n    `P \"Email bug reports to <bugs@example.org>.\" ]\n  in\n  let info = Cmd.info \"chorus\" ~version:\"%‌%VERSION%%\" ~doc ~man in\n  Cmd.v info chorus_t\n\nlet main () = exit (Cmd.eval cmd)\nlet () = main ()\n```\nThe `info` value created with [`Cmdliner.Cmd.info`](./cmdliner/Cmdliner-Cmd.md#val-info) gives more information about the term we execute and is used to generate the tool's man page. Since we provided a `~version` string, the tool will automatically respond to the `--version` option by printing this string.\n\nA tool using [`Cmdliner.Cmd.eval`](./cmdliner/Cmdliner-Cmd.md#val-eval) always responds to the `--help` option by showing the tool's man page generated using the information you provided with [`Cmdliner.Cmd.info`](./cmdliner/Cmdliner-Cmd.md#val-info) and [`Cmdliner.Arg.info`](./cmdliner/Cmdliner-Arg.md#val-info). Here is the output generated by our example:\n\n```\n> ocamlfind ocamlopt -linkpkg -package cmdliner -o chorus chorus.ml\n> ./chorus --help\nNAME\n       chorus - Print a customizable message repeatedly\n\nSYNOPSIS\n       chorus [--count=COUNT] [OPTION]… [MSG]\n\nARGUMENTS\n       MSG (absent=Revolt! or CHORUS_MSG env)\n           The message to print.\n\nOPTIONS\n       -c COUNT, --count=COUNT (absent=10)\n           Repeat the message COUNT times.\n\nCOMMON OPTIONS\n       --help[=FMT] (default=auto)\n           Show this help in format FMT. The value FMT must be one of auto,\n           pager, groff or plain. With auto, the format is pager or plain\n           whenever the TERM env var is dumb or undefined.\n\n       --version\n           Show version information.\n\nEXIT STATUS\n       chorus exits with the following status:\n\n       0   on success.\n\n       123 on indiscriminate errors reported on standard error.\n\n       124 on command line parsing errors.\n\n       125 on unexpected internal errors (bugs).\n\nENVIRONMENT\n       These environment variables affect the execution of chorus:\n\n       CHORUS_MSG\n           Overrides the default message to print.\n\nBUGS\n       Email bug reports to <bugs@example.org>.\n```\nIf a pager is available, this output is written to a pager. This help is also available in plain text or in the [groff](http://www.gnu.org/software/groff/groff.html) man page format by invoking the program with the option `--help=plain` or `--help=groff`.\n\nFor examples of more complex command line definitions look and run the [examples](./examples.md).\n\n\n## Sub commands\n\n`Cmdliner` also provides support for programs like `git` that have sub commands each with their own command line syntax and manual:\n\n```ocaml\ntool [COMMAND]… [OPTION]… ARG…\n```\nThese sub commands are defined by grouping them under a parent command via the [`Cmdliner.Cmd.group`](./cmdliner/Cmdliner-Cmd.md#val-group) function.\n",
      "type": "documentation",
      "package": "cmdliner",
      "version": "1.3.0",
      "file_path": "doc/tutorial.md",
      "library": null,
      "module_path": [
        "tutorial"
      ]
    },
    "INDEX": {
      "content": "\n# Cmdliner  <span class=\"version\">v1.3.0</span>\n\n`Cmdliner` provides a simple and compositional mechanism to convert command line arguments to OCaml values and pass them to your functions.\n\nThe library automatically handles syntax errors, help messages and UNIX man page generation. It supports programs with single or multiple commands (like `git`) and respect most of the [POSIX](http://www.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap12.html) and [GNU](http://www.gnu.org/software/libc/manual/html_node/Argument-Syntax.html) conventions.\n\n\n## Manuals\n\nThe following manuals are available.\n\n- The [tutorial](./tutorial.md) gets you through the steps to write your first command line interface with Cmdliner.\n- The [Command line interface manual](./cli.md) describes how command lines and environment variables are parsed by Cmdliner.\n- [Tool man pages](./tool_man.md) describes how Cmdliner generates man pages for your tools and how you can format them.\n- The [examples page](./examples.md) has a few annoted examples that show to express the command line interface of a few classic tools with Cmdliner\n\n## API\n\n[`Cmdliner`](./cmdliner/Cmdliner.md) Declarative definition of command line interfaces.",
      "type": "documentation",
      "package": "cmdliner",
      "version": "1.3.0",
      "file_path": "doc/index.md",
      "library": null,
      "module_path": [
        "doc"
      ]
    },
    "TOOL_MAN": {
      "content": "\n# Tool man pages\n\n\n## Manual\n\nMan page sections for a command are printed in the order specified by manual as given to [`Cmdliner.Cmd.info`](./cmdliner/Cmdliner-Cmd.md#val-info). Unless specified explicitly in the command's manual the following sections are automatically created and populated for you:\n\n- [`NAME`](./cmdliner/Cmdliner-Manpage.md#val-s_name) section.\n- [`SYNOPSIS`](./cmdliner/Cmdliner-Manpage.md#val-s_synopsis) section.\nThe various `doc` documentation strings specified by the command's term arguments get inserted at the end of the documentation section they respectively mention in their `docs` argument:\n\n1. For commands, see [`Cmdliner.Cmd.info`](./cmdliner/Cmdliner-Cmd.md#val-info).\n2. For positional arguments, see [`Cmdliner.Arg.info`](./cmdliner/Cmdliner-Arg.md#type-info). Those are listed iff both the `docv` and `doc` string is specified by [`Cmdliner.Arg.info`](./cmdliner/Cmdliner-Arg.md#val-info).\n3. For optional arguments, see [`Cmdliner.Arg.info`](./cmdliner/Cmdliner-Arg.md#val-info).\n4. For exit statuses, see [`Cmdliner.Cmd.Exit.info`](./cmdliner/Cmdliner-Cmd-Exit.md#val-info).\n5. For environment variables, see [`Cmdliner.Arg.env_var`](./cmdliner/Cmdliner-Arg.md#val-env_var) and [`Cmdliner.Cmd.Env.info`](./cmdliner/Cmdliner-Cmd-Env.md#val-info).\nIf a `docs` section name is mentioned and does not exist in the command's manual, an empty section is created for it, after which the `doc` strings are inserted, possibly prefixed by boilerplate text (e.g. for [`Cmdliner.Manpage.s_environment`](./cmdliner/Cmdliner-Manpage.md#val-s_environment) and [`Cmdliner.Manpage.s_exit_status`](./cmdliner/Cmdliner-Manpage.md#val-s_exit_status)).\n\nIf the created section is:\n\n- [standard](./cmdliner/Cmdliner-Manpage.md#standard_sections), it is inserted at the right place in the order specified [here](./cmdliner/Cmdliner-Manpage.md#standard_sections), but after a possible non-standard section explicitly specified by the command's manual since the latter get the order number of the last previously specified standard section or the order of [`Cmdliner.Manpage.s_synopsis`](./cmdliner/Cmdliner-Manpage.md#val-s_synopsis) if there is no such section.\n- non-standard, it is inserted before the [`Cmdliner.Manpage.s_commands`](./cmdliner/Cmdliner-Manpage.md#val-s_commands) section or the first subsequent existing standard section if it doesn't exist. Taking advantage of this behaviour is discouraged, you should declare manually your non standard section in the command's manual page.\nFinally note that the header of empty sections are dropped from the output. This allows you to share section placements among many commands and render them only if something actually gets inserted in it.\n\n\n## Documentation markup language\n\nManpage [blocks](./cmdliner/Cmdliner-Manpage.md#type-block) and doc strings support the following markup language.\n\n- Markup directives `$(i,text)` and `$(b,text)`, where `text` is raw text respectively rendered in italics and bold.\n- Outside markup directives, context dependent variables of the form `$(var)` are substituted by marked up data. For example in a term's man page `$(tname)` is substituted by the term name in bold.\n- Characters \\$, (, ) and \\\\ can respectively be escaped by \\\\\\$, \\\\(, \\\\) and \\\\\\\\ (in OCaml strings this will be `\"\\\\$\"`, `\"\\\\(\"`, `\"\\\\)\"`, `\"\\\\\\\\\"`). Escaping \\$ and \\\\ is mandatory everywhere. Escaping ) is mandatory only in markup directives. Escaping ( is only here for your symmetric pleasure. Any other sequence of characters starting with a \\\\ is an illegal character sequence.\n- Referring to unknown markup directives or variables will generate errors on standard error during documentation generation.",
      "type": "documentation",
      "package": "cmdliner",
      "version": "1.3.0",
      "file_path": "doc/tool_man.md",
      "library": null,
      "module_path": [
        "tool_man"
      ]
    },
    "CHANGES": {
      "content": "\n### v1.3.0 2024-05-23 La Forclaz (VS)\n\n- Add let operators in `Cmdliner.Term.Syntax` (\\#173). Thanks to Benoit Montagu for suggesting, Gabriel Scherer for reminding us of language punning obscurities and Sebastien Mondet for strengthening the case to add them.\n- Pager. Support full path command lookups on Windows. (\\#185). Thanks to @kit-ty-kate for the report.\n- In manpage specifications use `$(iname)` in the default introduction of the `ENVIRONMENT` section. Follow up to \\#168.\n- Add `Cmd.eval_value'` a variation on `Cmd.eval_value`.\n\n### v1.2.0 2023-04-10 La Forclaz (VS)\n\n- In manpage specification the new variable `$(iname)` substitutes the command invocation (from program name to subcommand) in bold (\\#168). This variable is now used in the default introduction of the `EXIT STATUS` section. Thanks to Ali Caglayan for suggesting.\n- Fix manpage rendering when `PAGER=less` is set (\\#167).\n- Plain text manpage rendering: fix broken handling of ``Noblank`. Thanks to Michael Richards and Reynir Björnsson for the report (\\#176).\n- Fix install to directory with spaces (\\#172). Thanks to @ZSFactory for reporting and suggesting the fix.\n- Fix manpage paging on Windows (\\#166). Thanks to Nicolás Ojeda Bär for the report and the solution.\n\n### v1.1.1 2022-03-23 La Forclaz (VS)\n\n- General documentation fixes, tweaks and improvements.\n- Docgen: suppress trailing whitespace in synopsis rendering.\n- Docgen: fix duplicate rendering of standard options when using `Term.ret` (\\#135).\n- Docgen: fix duplicate rendering of command name on `Term.ret (`Help (fmt, None)` (\\#135).\n\n### v1.1.0 2022-02-06 La Forclaz (VS)\n\n- Require OCaml 4\\.08.\n- Support for deprecating commands, arguments and environment variables (\\#66). See the `?deprecated` argument of `Cmd.info`, `Cmd.Env.info` and `Arg.info`.\n- Add `Manpage.s_none` a special section name to use whenever you want something not to be listed in a command's manpage.\n- Add `Arg.conv'` like `Arg.conv` but with a parser signature that returns untagged string errors.\n- Add `Term.{term,cli_parse}_result'` functions.\n- Add deprecation alerts on what is already deprecated.\n- On unices, use `command -v` rather than `type` to find commands.\n- Stop using backticks for left quotes. Use apostrophes everywhere. Thanks to Ryan Moore for reporting a typo that prompted the change (\\#128).\n- Rework documentation structure. Move out tutorial, examples and reference doc from the `.mli` to multiple `.mld` pages.\n- `Arg.doc_alts` and `Arg.doc_alts_enum`, change the default rendering to match the manpage convention which is to render these tokens in bold. If you want to recover the previous rendering or were using these functions outside man page rendering use an explicit `~quoted:true` (the optional argument is available on earlier versions).\n- The deprecated `Term.exit` and `Term.exit_status_of_result` now require a `unit` result. This avoids various errors to go undetected. Thanks to Thomas Leonard for the patch (\\#124).\n- Fix absent and default option values (`?none` string argument of `Arg.some`) rendering in manpages:\n  \n  1. They were not escaped, they now are.\n  2. They where not rendered in bold, they now are.\n  3. The documentation language was interpreted, it is no longer the case.\n  If you were relying on the third point via `?none` of `Arg.some`, use the new `?absent` optional argument of `Arg.info` instead. Besides a new `Arg.some'` function is added to specify a value for `?none` instead of a string. Thanks to David Allsopp for the patch (\\#111).\n  \n- Documentation generation use: `…` (U+2026) instead of `...` for ellipsis. See also UTF-8 manpage support below.\n- Documentation generation, improve command synopsis rendering on commands with few options (i.e. mention them).\n- Documentation generation, drop section heading in the output if the section is empty.\n\n#### New `Cmd` module and deprecation of the `Term` evaluation interface\n\nThis version of cmdliner deprecates the `Term.eval*` evaluation functions and `Term.info` information values in favor of the new `Cmdliner.Cmd` module.\n\nThe `Cmd` module generalizes the existing sub command support to allow arbitrarily nested sub commands each with its own man page and command line syntax represented by a `Term.t` value.\n\nThe mapping between the old interface and the new one should be rather straightforward. In particular `Term.info` and `Cmd.info` have exactly the same semantics and fields and a command value simply pairs a command information with a term.\n\nHowever in this transition the following things are changed or added:\n\n- All default values of `Cmd.info` match those of `Term.info` except for:\n  \n  - The `?exits` argument which defaults to `Cmd.Exit.defaults` rather than the empty list.\n  - The `?man_xrefs` which defaults to the list `[`Main]` rather than the empty list (this means that by default sub commands at any level automatically cross-reference the main command).\n  - The `?sdocs` argument which defaults to `Manpage.s_common_options` rather than `Manpage.s_options`.\n- The `Cmd.Exit.some_error` code is added to `Cmd.Exit.defaults` (which in turn is the default for `Cmd.info` see above). This is an error code clients can use when they don't want to bother about having precise exit codes. It is high so that low, meaningful, codes can later be added without breaking a tool's compatibility. In particular the convenience evaluation functions `Cmd.eval_result*` use this code when they evaluate to an error.\n- If you relied on `?term_err` defaulting to `1` in the various `Term.exit*` function, note that the new `Cmd.eval*` function use `Exit.cli_error` as a default. You may want to explicitly specify `1` instead if you use `Term.ret` with the ` `Error` case or `Term.term_result`.\nFinally be aware that if you replace, in an existing tool, an encoding of sub commands as positional arguments you will effectively break the command line compatibility of your tool since options can no longer be specified before the sub commands, i.e. your tool synopsis moves from:\n\n```ocaml\ntool cmd [OPTION]… SUBCMD [ARG]…\n```\nto\n\n```ocaml\ntool cmd SUBCMD [OPTION]… [ARG]…\n```\nThanks to Rudi Grinberg for prototyping the feature in \\#123.\n\n\n#### UTF-8 manpage support\n\nIt is now possible to write UTF-8 encoded text in your doc strings and man pages.\n\nThe man page renderer used on `--help` defaults to `mandoc` if available, then uses `groff` and then defaults to `nroff`. Starting with `mandoc` catches macOS whose `groff` as of 11\\.6 still doesn't support UTF-8 input and struggles to render some Unicode characters.\n\nThe invocations were also tweaked to remove the `-P-c` option which entails that the default pager `less` is now invoked with the `-R` option.\n\nIf you install UTF-8 encoded man pages output via `--help=groff`, in `man` directories bear in mind that these pages will look garbled on stock macOS (at least until 11\\.6). One way to work around is to instruct your users to change the `NROFF` definition in `/private/etc/man.conf` from:\n\n```ocaml\nNROFF       /usr/bin/groff -Wall -mtty-char -Tascii -mandoc -c\n```\nto:\n\n```ocaml\nNROFF       /usr/bin/mandoc -Tutf8 -c\n```\nThanks to Antonin Décimo for his knowledge and helping with these `man`gnificent intricacies (\\#27).\n\n\n### v1.0.4 2019-06-14 Zagreb\n\n- Change the way `Error (_, e)` term evaluation results are formatted. Instead of treating `e` as text, treat it as formatted lines.\n- Fix 4\\.08 `Pervasives` deprecation.\n- Fix 4\\.03 String deprecations.\n- Fix bootstrap build in absence of dynlink.\n- Make the `Makefile` bootstrap build reproducible. Thanks to Thomas Leonard for the patch.\n\n### v1.0.3 2018-11-26 Zagreb\n\n- Add `Term.with_used_args`. Thanks to Jeremie Dimino for the patch.\n- Use `Makefile` bootstrap build in opam file.\n- Drop ocamlbuild requirement for `Makefile` bootstrap build.\n- Drop support for ocaml \\< 4\\.03.0\n- Dune build support.\n\n### v1.0.2 2017-08-07 Zagreb\n\n- Don't remove the `Makefile` from the distribution.\n\n### v1.0.1 2017-08-03 Zagreb\n\n- Add a `Makefile` to build and install cmdliner without `topkg` and opam `.install` files. Helps bootstraping opam in OS package managers. Thanks to Hendrik Tews for the patches.\n\n### v1.0.0 2017-03-02 La Forclaz (VS)\n\n**IMPORTANT** The `Arg.converter` type is deprecated in favor of the `Arg.conv` type. For this release both types are equal but the next major release will drop the former and make the latter abstract. All users are kindly requested to migrate to use the new type and **only** via the new `Arg.[p]conv` and `Arg.conv_{parser,printer}` functions.\n\n- Allow terms to be used more than once in terms without tripping out documentation generation (\\#77). Thanks to François Bobot and Gabriel Radanne.\n- Disallow defining the same option (resp. command) name twice via two different arguments (resp. terms). Raises Invalid\\_argument, used to be undefined behaviour (in practice, an arbitrary one would be ignored).\n- Improve converter API (see important message above).\n- Add `Term.exit[_status]` and `Term.exit_status_of[_status]_result`. improves composition with `Pervasives.exit`.\n- Add `Term.term_result` and `Term.cli_parse_result` improves composition with terms evaluating to `result` types.\n- Add `Arg.parser_of_kind_of_string`.\n- Change semantics of `Arg.pos_left` (see \\#76 for details).\n- Deprecate `Term.man_format` in favor of `Arg.man_format`.\n- Reserve the `--cmdliner` option for library use. This is unused for now but will be in the future.\n- Relicense from BSD3 to ISC.\n- Safe-string support.\n- Build depend on topkg.\n\n#### End-user visible changes\n\nThe following changes affect the end-user behaviour of all binaries using cmdliner.\n\n- Required positional arguments. All missing required position arguments are now reported to the end-user, in the correct order (\\#39). Thanks to Dmitrii Kashin for the report.\n- Optional arguments. All unknown and ambiguous optional argument arguments are now reported to the end-user (instead of only the first one).\n- Change default behaviour of `--help[=FMT]` option. `FMT` no longer defaults to `pager` if unspecified. It defaults to the new value `auto` which prints the help as `pager` or `plain` whenever the `TERM` environment variable is `dumb` or undefined (\\#43). At the API level this changes the signature of the type `Term.ret` and values `Term.ret`, `Term.man_format` (deprecated) and `Manpage.print` to add the new ` `Auto` case to manual formats. These are now represented by the `Manpage.format` type rather than inlined polyvars.\n\n#### Doc specification improvements and fixes\n\n- Add `?envs` optional argument to `Term.info`. Documents environment variables that influence a term's evaluation and automatically integrate them in the manual.\n- Add `?exits` optional argument to `Term.info`. Documents exit statuses of the program. Use `Term.default_exits` if you are using the new `Term.exit` functions.\n- Add `?man_xrefs` optional argument to `Term.info`. Documents references to other manpages. Automatically formats a `SEE ALSO` section in the manual.\n- Add `Manpage.escape` to escape a string from the documentation markup language.\n- Add `Manpage.s_*` constants for standard man page section names.\n- Add a ` `Blocks` case to `Manpage.blocks` to allow block splicing (\\#69). This avoids having to concatenate block lists at the toplevel of your program.\n- `Arg.env_var`, change default environment variable section to the standard `ENVIRONMENT` manual section rather than `ENVIRONMENT VARIABLES`. If you previously manually positioned that section in your man page you will have to change the name. See also next point.\n- Fix automatic placement of default environment variable section (\\#44) whenever unspecified in the man page.\n- Better automatic insertions of man page sections (\\#73). See the API docs about manual specification. As a side effect the `NAME` section can now also be overridden manually.\n- Fix repeated environment variable printing for flags (\\#64). Thanks to Thomas Gazagnaire for the report.\n- Fix rendering of env vars in man pages, bold is standard (\\#71).\n- Fix plain help formatting for commands with empty description. Thanks to Maciek Starzyk for the patch.\n- Fix (implement really) groff man page escaping (\\#48).\n- Request `an` macros directly in the man page via `.mso` this makes man pages self-describing and avoids having to call `groff` with the `-man` option.\n- Document required optional arguments as such (\\#82). Thanks to Isaac Hodes for the report.\n\n#### Doc language sanitization\n\nThis release tries to bring sanity to the doc language. This may break the rendering of some of your man pages. Thanks to Gabriel Scherer, Ivan Gotovchits and Nicolás Ojeda Bär for the feedback.\n\n- It is only allowed to use the variables `$(var)` that are mentioned in the docs (`$(docv)`, `$(opt)`, etc.) and the markup directives `$({i,b},text)`. Any other unknown `$(var)` will generate errors on standard error during documentation generation.\n- Markup directives `$({i,b},text)` treat `text` as is, modulo escapes; see next point.\n- Characters `$`, `(`, `)` and `\\` can respectively be escaped by `\\$`, `\\(`, `\\)` and `\\\\`. Escaping `$` and `\\` is mandatory everywhere. Escaping `)` is mandatory only in markup directives. Escaping `(` is only here for your symmetric pleasure. Any other sequence of character starting with a `\\` is an illegal sequence.\n- Variables `$(mname)` and `$(tname)` are now marked up with bold when substituted. If you used to write `$(b,$(tname))` this will generate an error on standard output, since `$` is not escaped in the markup directive. Simply replace these by `$(tname)`.\n\n### v0.9.8 2015-10-11 Cambridge (UK)\n\n- Bring back support for OCaml 3\\.12.0\n- Support for pre-formatted paragraphs in man pages. This adds a \\```Pre\\`` case to the `Manpage.block` type which can break existing programs. Thanks to Guillaume Bury for suggesting and help.\n- Support for environment variables. If an argument is absent from the command line, its value can be read and parsed from an environment variable. This adds an `env` optional argument to the `Arg.info` function which can break existing programs.\n- Support for new variables in option documentation strings. `$(opt)` can be used to refer to the name of the option being documented and `$(env)` for the name of the option's the environment variable.\n- Deprecate `Term.pure` in favor of `Term.const`.\n- Man page generation. Keep undefined variables untouched. Previously a `$(undef)` would be turned into `undef`.\n- Turn a few mysterious and spurious `Not_found` exceptions into `Invalid_arg`. These can be triggered by client programming errors (e.g. an unclosed variable in a documentation string).\n- Positional arguments. Invoke the printer on the default (absent) value only if needed. See Optional arguments in the release notes of v0.9.6.\n\n### v0.9.7 2015-02-06 La Forclaz (VS)\n\n- Build system, don't depend on `ocamlfind`. The package no longer depends on ocamlfind. Thanks to Louis Gesbert for the patch.\n\n### v0.9.6 2014-11-18 La Forclaz (VS)\n\n- Optional arguments. Invoke the printer on the default (absent) value only if needed, i.e. if help is shown. Strictly speaking an interface breaking change – for example if the absent value was lazy it would be forced on each run. This is no longer the case.\n- Parsed command line syntax: allow short flags to be specified together under a single dash, possibly ending with a short option. This allows to specify e.g. `tar -xvzf archive.tgz` or `tar -xvzfarchive.tgz`. Previously this resulted in an error, all the short flags had to be specified separately. Backward compatible in the sense that only more command lines are parsed. Thanks to Hugo Heuzard for the patch.\n- End user error message improvements using heuristics and edit distance search in the optional argument and sub command name spaces. Thanks to Hugo Heuzard for the patch.\n- Adds `Arg.doc_{quote,alts,alts_enum}`, documentation string helpers.\n- Adds the `Term.eval_peek_opts` function for advanced usage scenarios.\n- The function `Arg.enum` now raises `Invalid_argument` if the enumeration is empty.\n- Improves help paging behaviour on Windows. Thanks to Romain Bardou for the help.\n\n### v0.9.5 2014-07-04 Cambridge (UK)\n\n- Add variance annotation to Term.t. Thanks to Peter Zotov for suggesting.\n- Fix section name formatting in plain text output. Thanks to Mikhail Sobolev for reporting.\n\n### v0.9.4 2014-02-09 La Forclaz (VS)\n\n- Remove temporary files created for paged help. Thanks to Kaustuv Chaudhuri for the suggestion.\n- Avoid linking against `Oo` (was used to get program uuid).\n- Check the environment for `$MANPAGER` as well. Thanks to Raphaël Proust for the patch.\n- OPAM friendly workflow and drop OASIS support.\n\n### v0.9.3 2013-01-04 La Forclaz (VS)\n\n- Allow user specified `SYNOPSIS` sections.\n\n### v0.9.2 2012-08-05 Lausanne\n\n- OASIS 0\\.3.0 support.\n\n### v0.9.1 2012-03-17 La Forclaz (VS)\n\n- OASIS support.\n- Fixed broken `Arg.pos_right`.\n- Variables `$(tname)` and `$(mname)` can be used in a term's man page to respectively refer to the term's name and the main term name.\n- Support for custom variable substitution in `Manpage.print`.\n- Adds `Term.man_format`, to facilitate the definition of help commands.\n- Rewrote the examples with a better and consistent style.\nIncompatible API changes:\n\n- The signature of `Term.eval` and `Term.eval_choice` changed to make it more regular: the given term and its info must be tupled together even for the main term and the tuple order was swapped to make it consistent with the one used for arguments.\n\n### v0.9.0 2011-05-27 Lausanne\n\n- First release.",
      "type": "documentation",
      "package": "cmdliner",
      "version": "1.3.0",
      "file_path": "doc/CHANGES.md",
      "library": null,
      "module_path": [
        "CHANGES"
      ]
    }
  },
  "documentation": {},
  "statistics": {
    "total_modules": 8,
    "total_types": 16,
    "total_values": 105,
    "total_submodules": 7,
    "total_elements": 154
  }
}