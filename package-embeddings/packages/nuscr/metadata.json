{
  "package": "nuscr",
  "embedding_model": "Qwen/Qwen3-Embedding-8B",
  "embedding_dimension": 4096,
  "total_modules": 21,
  "creation_timestamp": "2025-08-15T12:20:52.612642",
  "modules": [
    {
      "module_path": "Nuscrlib.Efsm.G.V",
      "library": "nuscr.lib",
      "description": "This module defines and manipulates labeled vertices for a persistent graph representation of an endpoint finite state machine. It supports creating vertices from labels, retrieving vertex labels, and comparing, hashing, and checking equality of vertices. It is used to represent and manage individual states within the graph structure of an EFSM.",
      "description_length": 347,
      "index": 0,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Nuscrlib.Efsm.G.E",
      "library": "nuscr.lib",
      "description": "This module represents directed edges in a state transition graph, where each edge connects two states and carries an action label. It provides operations to create edges, retrieve their source and destination states, access labels, and compare edges. Concrete use cases include modeling transitions in endpoint finite state machines and analyzing state paths with labeled actions.",
      "description_length": 381,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Nuscrlib.Names.VariableName",
      "library": "nuscr.lib",
      "description": "This module provides functions for handling identifiers with attached source locations, supporting operations like creation from strings, renaming, comparison based on identifier content, and structured serialization. It works with a composite type encapsulating a string identifier and its source span, enabling precise tracking of name origins in parsed or transformed data. Typical use cases involve managing symbolic variables in compilers, linters, or analyzers where source position fidelity is required for diagnostics or code manipulation.",
      "description_length": 547,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Nuscrlib.Ltype.LocalProtocolId",
      "library": "nuscr.lib",
      "description": "This module manages unique identifiers derived from protocol and role names, enabling precise identification and comparison of local protocol instances. It supports creation, equality checks, and ordering operations (e.g., `min`, `max`, `between`), along with clamping functions to enforce value ranges, either by raising exceptions or handling errors explicitly. These capabilities are particularly useful in distributed systems for validating protocol execution flows, coordinating state transitions, or ensuring consistency across roles in typed communication protocols.",
      "description_length": 573,
      "index": 3,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Nuscrlib.Names.LocalProtocolName",
      "library": "nuscr.lib",
      "description": "This module supports creation, transformation, and ordered comparison of identifiers paired with source locations, enabling precise name manipulation and ordering constraints. It works with a tuple-like type combining string identifiers and `Loc.t` location markers, offering operations like case-preserving modification, location-aware comparisons, and bounded sequence validation. Typical use cases include sorting protocol names with positional metadata, enforcing naming conventions across distributed systems, and tracking identifier provenance in compiler pipelines.",
      "description_length": 572,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Nuscrlib.Expr.Sexp",
      "library": "nuscr.lib",
      "description": "This module represents S-expressions with distinct constructors for literal strings and atoms, supporting structured data parsing and serialization. It provides a `to_string` function to convert S-expression values to string representations. Use cases include handling symbolic expressions in domain-specific languages and managing structured configuration data.",
      "description_length": 362,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Nuscrlib.Names.PayloadTypeName",
      "library": "nuscr.lib",
      "description": "This module encapsulates operations for creating and manipulating identifiers with associated source-code locations, represented as `PayloadTypeName.t` values combining a string identifier and `Loc.t` reference. It supports equality checks, ordering, and transformations\u2014including renaming, comparison combinators, and bidirectional conversions\u2014while enabling use cases like tracking named entities in compiler pipelines, managing scoped identifiers, or enforcing uniqueness constraints across distributed data structures. The utilities for hashing, S-expression serialization, and comparator generation further facilitate integration with persistent storage, analysis tools, or typed intermediate representations.",
      "description_length": 714,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Nuscrlib.Names.TypeVariableName",
      "library": "nuscr.lib",
      "description": "This library component supports creation, modification, and comparison of type variable names that pair identifiers with source locations, offering operations like hashing, string conversion, and precise location extraction. It provides ordering primitives such as `ascending`, `descending`, and range-based clamping to facilitate sorting and bounds enforcement in type variable collections. These capabilities are particularly useful in type inference systems or compiler passes requiring stable variable ordering and location-aware identifier management.",
      "description_length": 556,
      "index": 7,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Nuscrlib.Names.LabelName",
      "library": "nuscr.lib",
      "description": "This module enables precise manipulation of identifiers with source location tracking, offering operations to construct, rename, compare, and convert labeled names. It works with labeled name types that encapsulate identifiers and their associated source positions, supporting both semantic comparisons (e.g., ordering, clamping) and structural transformations (e.g., hashing, string representation). These capabilities are particularly useful in compiler pipelines or static analysis tools where maintaining and reasoning about identifier provenance is critical.",
      "description_length": 563,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Nuscrlib.Efsm.G",
      "library": "nuscr.lib",
      "description": "This library component offers a persistent graph representation for endpoint finite state machines (EFSMs), featuring labeled vertices and directed edges that carry action labels. It supports operations like connectivity checks, edge removal (including targeted or label-agnostic variants), and traversal of successor/predecessor states with associated transitions, making it suitable for modeling communication protocols and analyzing state transitions. The design enables functional-style modifications\u2014such as adding edges or mapping over graph elements\u2014while preserving immutability, which is useful for tasks like verifying behavioral properties of distributed systems.",
      "description_length": 674,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Nuscrlib.Names.Make",
      "library": "nuscr.lib",
      "description": "Provides operations for creating and manipulating names with associated source locations, including identifier transformation, comparison, hashing, and pretty-printing while preserving positional data. Supports ordering and type-safe comparisons for named entities through functions like `max`, `clamp`, and a standard comparator, making it suitable for compiler components or structured data processing tasks that require precise name management with location tracking.",
      "description_length": 470,
      "index": 10,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Nuscrlib.Names.ProtocolName",
      "library": "nuscr.lib",
      "description": "This module provides operations to construct, transform, and compare structured identifiers composed of a string and an associated source location. The core functionality supports name creation with optional location metadata, identifier mutation, location extraction, and semantic string formatting, while ensuring equality and ordering relations depend solely on the identifier component. These capabilities are particularly useful in systems requiring robust name resolution or comparison, such as protocol registries or distributed systems, where location metadata aids debugging but must not influence logical equivalence.",
      "description_length": 627,
      "index": 11,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Nuscrlib.Err",
      "library": "nuscr.lib",
      "description": "This module defines a rich set of error types for precise error reporting during parsing, type checking, and program analysis. It includes detailed variants for handling issues like undefined names, duplicate definitions, and inconsistent protocol usage, all enriched with location information. Functions convert errors to S-expressions or human-readable strings, and utilities raise exceptions for common error scenarios like unimplemented features or violated constraints.",
      "description_length": 474,
      "index": 12,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Nuscrlib.Names",
      "library": "nuscr.lib",
      "description": "This module defines structured identifier abstractions with source location metadata, supporting creation, transformation, comparison, and serialization of named entities. It operates on composite types pairing string identifiers with `Loc.t` values, enabling precise tracking and manipulation of names in contexts like compiler pipelines, protocol registries, and distributed systems. Concrete use cases include managing type variables with location fidelity, enforcing naming constraints in distributed data structures, and tracking identifier provenance for diagnostics in static analysis tools.",
      "description_length": 598,
      "index": 13,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Nuscrlib.Expr",
      "library": "nuscr.lib",
      "description": "This module provides operations for constructing and manipulating expressions with refinement type annotations, supporting substitution, free variable analysis, and SMT constraint generation. It works with a structured expression type (`t`) encompassing variables, literals, and operations, alongside a rich type system (`payload_type`) for modeling primitive, abstract, and predicate-refined types. These capabilities enable use cases like verifying type correctness in annotated code and producing SMT-encoded logical constraints for program analysis.",
      "description_length": 553,
      "index": 14,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Nuscrlib.Gtype",
      "library": "nuscr.lib",
      "description": "This module supports operations for modeling and manipulating multiparty session types, focusing on message passing, recursion, and protocol composition. It works with structured types like message definitions, recursive variables, nested protocols, and global type constructors for choices, delegation, and termination. These capabilities enable formal verification of distributed protocol correctness, normalization of recursive structures, and generation of human-readable protocol representations for analysis.",
      "description_length": 514,
      "index": 15,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Nuscrlib.Ltype",
      "library": "nuscr.lib",
      "description": "This module defines the structure of local types for modeling communication protocols, including operations for sending and receiving messages, making choices, handling recursion, and managing nested protocols with dynamic participants. It works with algebraic data types representing protocol actions and supports transformations like projection from global types, variable uniqueness enforcement, and identifier mapping. Concrete use cases include verifying role-specific communication sequences, generating unique protocol identifiers for distributed coordination, and structuring nested protocol interactions in systems with dynamic participant creation.",
      "description_length": 658,
      "index": 16,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Nuscrlib.Pragma",
      "library": "nuscr.lib",
      "description": "This module defines a set of boolean flags that control validation and refinement behaviors, such as enabling nested protocols or sender/receiver checks, with functions to convert these flags to strings, query their state, and update them via command-line arguments or pragma directives. It manages internal state through mutable references, supporting dynamic configuration changes and resets to default values. Typical use cases include adjusting refinement type validation rigor or protocol nesting depth during program initialization based on external inputs.",
      "description_length": 563,
      "index": 17,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Nuscrlib.Efsm",
      "library": "nuscr.lib",
      "description": "This module implements endpoint finite state machines (EFSMs) for modeling communication protocols, with states represented as integers and transitions labeled by send or receive actions annotated with variable updates. It provides operations to construct EFSMs from local types, analyze state behavior (e.g., send/receive classification), and extract role or payload type sets from transitions. The module also supports visualization via DOT output and maintains recursion variable metadata for protocol analysis tasks.",
      "description_length": 520,
      "index": 18,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Nuscrlib.Loc",
      "library": "nuscr.lib",
      "description": "This module represents and manipulates source code locations using pairs of Lexing.position values. It provides functions to create locations, merge overlapping regions, and format or compare located values with custom printers and serializers. Typical use cases include tracking positions in parsed files for error reporting or source-to-source transformations.",
      "description_length": 362,
      "index": 19,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Nuscrlib.LiteratureSyntax",
      "library": "nuscr.lib",
      "description": "This module defines algebraic data types for representing global and local multiparty session types, including branching, recursion, and type variables. It provides functions to convert session types from other internal representations (`Gtype.t` and `Ltype.t`) into this literature-style syntax and to serialize them into string formats. These operations support outputting session types in both MPSTK-compatible and LaTeX formats using the `mpstmacros` package.",
      "description_length": 463,
      "index": 20,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 23,
    "meaningful_modules": 21,
    "filtered_empty_modules": 2,
    "retention_rate": 0.9130434782608695
  },
  "statistics": {
    "max_description_length": 714,
    "min_description_length": 347,
    "avg_description_length": 528.1428571428571,
    "embedding_file_size_mb": 0.3047208786010742
  }
}