{
  "package": "nuscr",
  "embedding_model": "BAAI/bge-base-en-v1.5",
  "embedding_dimension": 1024,
  "total_modules": 24,
  "creation_timestamp": "2025-06-18T16:38:21.086451",
  "modules": [
    {
      "module_path": "Nuscrlib.Efsm.G.V",
      "description": "Compares, hashes, and checks equality of vertex representations based on their internal state. Constructs vertices from labels and retrieves labels from vertex instances. Used to manage unique vertex identities in graph algorithms requiring ordered and hashable elements.",
      "description_length": 271,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Nuscrlib.Efsm.G.E",
      "description": "Provides operations to compare edges, extract source and destination vertices, retrieve labels, and construct edges from vertices and labels. Works with edge structures represented as tuples of state, action, and state, and vertices identified by their type. Used to model transitions in state machines where edges represent actions between states.",
      "description_length": 348,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Nuscrlib.Expr.Sexp",
      "description": "Converts S-expressions to strings, handling literal strings and atoms distinctly. Works with nested lists and atomic values, preserving structural integrity. Used to generate human-readable representations of parsed data in configuration and query systems.",
      "description_length": 256,
      "index": 2,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Nuscrlib.Ltype.LocalProtocolId",
      "description": "This module handles operations for managing local protocol identifiers, focusing on comparison, range validation, and value clamping for composite types structured around protocol and role names. It enables tasks like ensuring IDs fall within defined bounds or sorting them hierarchically. The custom type supports serialization and equality checks, making it suitable for scenarios requiring strict validation or ordered processing of protocol-related data.",
      "description_length": 458,
      "index": 3,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Nuscrlib.Efsm.G",
      "description": "manages state machine graphs with vertex and edge operations, enabling structured representation and manipulation of transitions. Vertices are uniquely identified by their internal state, supporting equality checks, hashing, and label retrieval. Edges are constructed from state-action-state tuples, allowing source and destination extraction, label access, and comparison. This enables modeling of deterministic transitions, such as building and analyzing EFSM diagrams or validating state transitions.",
      "description_length": 503,
      "index": 4,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Nuscrlib.Names.Make",
      "description": "This module offers operations for managing named identifiers composed of strings and locations, including formatting, hashing, renaming, and comparison while handling location metadata flexibly. It also provides comparison, range-checking, and clamping functionalities for a type `t`, along with utilities for converting between tagged types, enabling use cases like symbolic name manipulation in compilers or range validation in numerical applications.",
      "description_length": 453,
      "index": 5,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Nuscrlib.Names.ProtocolName",
      "description": "This module provides operations for managing named identifiers with locations, including creating, modifying, and comparing these values through string manipulation, accessors, and hashing. It supports ordering, range validation, and clamping for generic type `t`, enabling use cases like parsing, validation, or data sorting where structured identifiers and numerical ranges require precise handling. The functions also include generic comparators and conversions, facilitating interoperability between tagged types.",
      "description_length": 517,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Nuscrlib.Names.PayloadTypeName",
      "description": "The module provides operations for creating, modifying, and comparing named identifiers composed of strings and locations, along with string manipulation, equality checks, and hashing. It also includes comparison and range functions for a type `t`, such as ordering, bound checking, and clamping, alongside a comparator and tagged type conversion. These capabilities are suited for tasks like parsing identifiers with positional metadata or managing bounded numerical ranges in data validation.",
      "description_length": 494,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Nuscrlib.Names.LabelName",
      "description": "The module provides operations for managing labeled identifiers, including creating, modifying, and comparing them via string and location handling, along with equality, ordering, and hashing. It supports range-based comparisons and clamping for a type `t`, utilizing a comparator witness for safe, type-specific operations. These functions are applicable in scenarios like parsing, symbol tracking, or validating value ranges in structured data.",
      "description_length": 446,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Nuscrlib.Names.RoleName",
      "description": "This module provides operations for managing named identifiers composed of strings and locations, including manipulation, comparison, and hashing, as well as ordering and range-based functions for a type `t`, such as bounds checking and clamping. It works with structured data like tagged identifiers and ordered values, enabling use cases such as symbolic name resolution in parsers or range validation in coordinate systems. Specific utilities include location-aware equality checks and generic comparator functions for flexible type handling.",
      "description_length": 545,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Nuscrlib.Names.VariableName",
      "description": "This module offers operations for creating, modifying, and comparing named identifiers represented by the `t` type, which includes string manipulation, accessors, and hashing while handling associated locations. It supports range-based comparisons, ordering, and clamping for `t` values, enabling use cases like compiler variable management, uniqueness checks, and ordered data processing. The functionality includes generic comparators and conversions between tagged types for flexible integration.",
      "description_length": 499,
      "index": 10,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Nuscrlib.Names.TypeVariableName",
      "description": "This module offers operations for manipulating type variable names, including string handling, location tracking, and equality/ordering comparisons based on identifiers. It also provides range-based functionalities for a type `t`, such as bounding checks and clamping, utilizing comparator witnesses for safe type-specific comparisons. These features are useful in scenarios like compiler type tracking and ordered data management where precise value constraints and comparisons are required.",
      "description_length": 492,
      "index": 11,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Nuscrlib.Names.LocalProtocolName",
      "description": "This module provides operations for managing named identifiers composed of strings and locations, including string manipulation, location handling, equality checks, comparisons, and hashing. It also supports ordering and range-based operations for a generic type `t`, enabling bounded value checks, clamping, and structured comparisons. These capabilities are useful in scenarios like parsing or symbolic computation, where precise identifier tracking and value range management are critical.",
      "description_length": 492,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Nuscrlib.Pragma",
      "description": "The module provides serialization, configuration access, and manipulation of boolean flags governing refinement types and protocol validation, operating on `t` for individual pragmas and `pragmas` for collections. It supports initializing global settings, adjusting verbosity, and loading configurations from structured data, enabling dynamic control over program behavior during execution.",
      "description_length": 390,
      "index": 13,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Nuscrlib.Expr",
      "description": "Converts nested S-expressions into structured string representations, distinguishing between literals, atoms, and lists. Supports recursive processing of complex data hierarchies, ensuring accurate formatting of embedded values. Operations include parsing, formatting, and traversal of S-expression trees. Example uses include generating debug output, serializing configuration data, and producing query strings from abstract syntax structures.",
      "description_length": 444,
      "index": 14,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Nuscrlib.Gtype",
      "description": "The module provides operations for manipulating and converting protocol-related data structures, including equality checks, serialization, string representation, and generating unique call labels, while also handling normalization and validation tasks like collapsing nested choices and unfolding fixpoints. It works with structured types such as `t`, `nested_t`, and `rec_var`, focusing on protocol definitions and recursive variable management. These functionalities are critical for ensuring consistency and correctness in communication protocols and recursive type systems.",
      "description_length": 577,
      "index": 15,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Nuscrlib.Ltype",
      "description": "Manages protocol and role-based identifiers with support for comparison, range checks, and value clamping. Custom types enable serialization, equality, and ordered processing of structured protocol data. Operations include validating IDs against defined ranges and sorting them hierarchically. Examples include ensuring protocol IDs remain within acceptable limits or organizing role-based access controls by sorted hierarchy.",
      "description_length": 426,
      "index": 16,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Nuscrlib.Efsm",
      "description": "manages state machine graphs with vertex and edge operations, enabling structured representation and manipulation of transitions. Vertices are uniquely identified by internal state, supporting equality checks, hashing, and label retrieval; edges are built from state-action-state tuples, allowing source and destination extraction, label access, and comparison. It facilitates modeling deterministic transitions, such as validating state transitions or analyzing EFSM diagrams. Users can construct graphs, traverse transitions, and verify state consistency.",
      "description_length": 557,
      "index": 17,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Nuscrlib.Err",
      "description": "Provides functions to generate and format user-facing error messages, including raising errors with positions and formatted strings. Works with `user_error` type and lexing positions to track error locations. Used to signal unimplemented features, violations, and custom errors with structured output.",
      "description_length": 301,
      "index": 18,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Nuscrlib.Names",
      "description": "This module provides operations for creating, manipulating, and comparing named identifiers, including string conversion, location extraction, hashing, and range-based ordering. It works with values of type `t`, which encapsulate names along with associated locations and support type-safe interactions across distinct name namespaces. Use cases include compiler symbol management, where precise name differentiation and range constraints are critical, and scenarios requiring safe interoperation between heterogeneous name spaces.",
      "description_length": 531,
      "index": 19,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Nuscrlib.Loc",
      "description": "Handles source code location tracking using a custom type `t` representing position ranges. Provides operations to create, merge, and serialize locations, along with helpers for formatting and comparing located values. Supports generating S-expressions, pretty-printed strings, and equality checks for data annotated with location information.",
      "description_length": 343,
      "index": 20,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Nuscrlib.LiteratureSyntax",
      "description": "Converts between internal representations and external formats for multiparty session types, including conversion from Gtype.t and Ltype.t. Outputs global and local types in MPSTK-compatible string formats and LaTeX using mpstmacros. Handles structured data with label-payload lists and supports precise type representation for protocol specification.",
      "description_length": 351,
      "index": 21,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "nuscr",
      "description": "Processes and transforms text by splitting lines, filtering empty entries, and normalizing whitespace. Operates on strings and lists of strings, extracting and refining textual content. Used to clean and prepare log entries for further analysis or display.",
      "description_length": 256,
      "index": 22,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Nuscrlib",
      "description": "manages protocol parsing, serialization, and manipulation through a suite of interrelated modules. It handles structured data conversion, error reporting, identifier management, and state machine modeling, with core types including `t`, `pragmas`, `nested_t`, and `rec_var`. Operations range from parsing S-expressions and generating error messages to validating protocol IDs and converting session types to LaTeX. Users can serialize configurations, trace source locations, and model state transitions with precise control over protocol behavior.",
      "description_length": 547,
      "index": 23,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 24,
    "meaningful_modules": 24,
    "filtered_empty_modules": 0,
    "retention_rate": 1.0
  },
  "statistics": {
    "max_description_length": 577,
    "min_description_length": 256,
    "avg_description_length": 437.375,
    "embedding_file_size_mb": 0.08764076232910156
  }
}