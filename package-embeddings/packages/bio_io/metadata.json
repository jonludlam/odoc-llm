{
  "package": "bio_io",
  "embedding_model": "Qwen/Qwen3-Embedding-8B",
  "embedding_dimension": 4096,
  "total_modules": 24,
  "creation_timestamp": "2025-08-15T12:19:53.336296",
  "modules": [
    {
      "module_path": "Bio_io.Btab.Record.Parsed.Fields.Direct",
      "library": "bio_io",
      "description": "This module provides direct access to individual fields of a fully parsed Btab record through operations like `iter`, `fold`, `map`, and `to_list`, enabling transformations and inspections of specific alignment data. It works with the `Bio_io.Btab.Record.Parsed.t` type, exposing fields such as query, target, percent identity, alignment length, start/end positions, E-value, and bit score. Use this module to process or filter BLAST tabular output programmatically, for example when extracting high-confidence hits or recalculating alignment metrics.",
      "description_length": 551,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bio_io.Btab.Record.Parsed.Fields",
      "library": "bio_io",
      "description": "This module provides type-safe construction, iteration, and transformation of fully parsed BLAST tabular records' fields, including query/target identifiers, alignment metrics (coordinates, scores, identity), and sequence lengths. It operates on records containing structured representations of BLAST hits, enabling programmatic analysis like filtering hits by e-value thresholds or identity percentages, and supports serialization workflows requiring complete pre-parsed data. The field-based API facilitates bulk operations for tasks such as converting alignments to structured formats or validating datasets against custom criteria.",
      "description_length": 635,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bio_io.Btab_queries.In_channel.T",
      "library": "bio_io",
      "description": "This module provides functions for reading and processing btab files where each query is treated as a single record. It supports operations like reading lines, parsing records, and iterating over file contents, working with input channels and strings. Use cases include parsing btab data from standard input or files, processing query records, and handling line-based or record-based input with optional Windows EOL fixes.",
      "description_length": 422,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bio_io.Btab.Record.Parsed",
      "library": "bio_io",
      "description": "This module provides a fully parsed OCaml record representation of BLAST tabular (btab) alignment records, including fields for query and target identifiers, alignment coordinates, scores, and sequence lengths. It supports operations like extracting alignment metrics, filtering hits based on criteria such as e-value or percent identity, and serializing records to and from s-expressions. Use this module when you need to work with pre-parsed, structured data for tasks like converting BLAST results into custom formats or applying validation rules across alignment datasets.",
      "description_length": 576,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bio_io.Record_in_channel.Make",
      "library": "bio_io",
      "description": "This module creates input channels for reading record-based data from files or standard input, supporting operations like reading individual records, folding over all records with or without indices, iterating over records for side effects, and collecting records into lists or sequences. It works with a parameterized record type `M.record` and manages input channels of type `M.t`, which represent sources of record data. Concrete use cases include parsing structured file formats like FASTA or CSV, processing large datasets without loading all records into memory, and performing aggregate calculations over sequential data entries.",
      "description_length": 636,
      "index": 4,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Bio_io.Fastq.Record",
      "library": "bio_io",
      "description": "This module enables creation, modification, and serialization of FASTQ records containing sequence data, with core fields like identifier, description, sequence, and quality scores. It supports in-place updates, sequence reversal, and IUPAC-based complement operations that produce new records with transformed sequences and adjusted quality values. These capabilities are particularly useful for processing high-throughput DNA sequencing data where operations like reverse-complementing reads or normalizing base representations are required.",
      "description_length": 543,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bio_io.Fastq.In_channel",
      "library": "bio_io",
      "description": "This module reads FASTQ records from input channels, supporting operations like iteration, folding, and conversion to lists or sequences. It works with FASTQ files by parsing each record into a `Record.t` type, handling standard input or named files. Use cases include processing sequence data for analysis, such as computing total sequence length or extracting record metadata.",
      "description_length": 378,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bio_io.Btab_queries.In_channel",
      "library": "bio_io",
      "description": "This module provides functions for reading and processing btab files by treating each query as a single record, supporting line-based and record-based input operations from channels, files, or strings. It works with Btab query records, offering folding, iteration, and index-tracking capabilities to handle scenarios like bioinformatics data aggregation where hits are grouped per query. Specific use cases include parsing files with mixed line endings, processing large datasets via streaming, and analyzing query-centric btab formats without requiring per-hit record management.",
      "description_length": 580,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bio_io.Btab.In_channel",
      "library": "bio_io",
      "description": "This module reads btab-formatted files record by record, providing functions to open, close, and iterate over input channels. It works directly with `Bio_io.Btab.Record.t` values, parsing each line of the file into a structured record. Use it to process BLAST tabular output files by folding over results, applying side-effecting functions, or collecting records into lists.",
      "description_length": 374,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bio_io.Private.In_channel",
      "library": "bio_io",
      "description": "This module provides low-level input operations for binary and text data, including reading raw bytes, integers, characters, and lines with optional line-ending normalization, alongside utilities for file positioning and length determination. It operates on in_channels and file paths, enabling efficient workflows like reading entire files into strings or lists and managing binary/text mode transitions. Its design particularly supports scenarios requiring compatibility with functors that expect non-binary channels, such as parsing structured binary records or line-oriented text formats with strict formatting constraints.",
      "description_length": 627,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bio_io.Fasta.In_channel",
      "library": "bio_io",
      "description": "This module reads FASTA records from input channels, supporting operations like iteration, folding, and list conversion. It works with FASTA files via the `t` type and handles individual `Record.t` entries. Use it to process sequence data, compute aggregate statistics (e.g., total sequence length), or extract records directly.",
      "description_length": 328,
      "index": 10,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bio_io.Btab.Record",
      "library": "bio_io",
      "description": "This module represents a single homology search hit from a tab-delimited input, providing access to alignment metrics such as percent identity, e-value, bit-score, and positional data. It operates on strings for input parsing and record serialization, with optional integer fields for sequence lengths. Use this module to extract and manipulate specific alignment data from BLAST or MMseqs2 output files, particularly when filtering or transforming individual hits based on alignment quality or position ranges.",
      "description_length": 511,
      "index": 11,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Bio_io.Fasta.Record",
      "library": "bio_io",
      "description": "This module defines a record type for representing entries in FASTA files, with fields for sequence identifier, description, and the sequence itself. It provides functions to create, modify, and manipulate these records, including operations to reverse or complement sequences according to IUPAC conventions. Use cases include parsing, transforming, and writing FASTA data in bioinformatics workflows.",
      "description_length": 401,
      "index": 12,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Bio_io.Btab_queries.Record",
      "library": "bio_io",
      "description": "This module represents btab records grouped by query sequence, providing operations to create and access query-specific hit lists. It works with strings for query identifiers and lists of `Btab.Record.t` for associated hits. Use this module to process homology search results where each query may have multiple target hits, such as analyzing BLAST output structured by query sequence.",
      "description_length": 384,
      "index": 13,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bio_io.Private.Peekable_in_channel",
      "library": "bio_io",
      "description": "This module wraps `Stdio.In_channel` with added `peek_char` and `peek_line` functions, enabling lookahead operations on input channels, including FIFOs and compressed streams. It supports standard input operations like reading lines, folding over lines, and reading entire contents, while allowing non-destructive inspection of upcoming characters or lines. It is used internally to handle bioinformatics input formats that require peeking, such as parsing sequence files from pipes or compressed sources.",
      "description_length": 505,
      "index": 14,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bio_io.Btab",
      "library": "bio_io",
      "description": "This module parses tab-delimited homology search results, such as BLAST or MMseqs2 output, into structured records representing individual alignment hits. It provides operations to read and process these records from files, supporting filtering and transformation based on alignment metrics like e-value, percent identity, and positional data. Use it to analyze or convert btab-formatted outputs into custom workflows without relying on external parsing logic.",
      "description_length": 460,
      "index": 15,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bio_io.Btab_queries",
      "library": "bio_io",
      "description": "Handles btab file parsing with query-centric record grouping. Provides data structures for query identifiers paired with hit lists and supports streaming input processing with indexed record access. Useful for analyzing BLAST-like homology search results where each query spans multiple hits.",
      "description_length": 292,
      "index": 16,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bio_io.Utils",
      "library": "bio_io",
      "description": "Handles DNA sequence transformations and error-tolerant function execution. Provides sequence complement and reverse-complement operations, along with wrappers for catching exceptions in unary and nullary functions. Works directly with strings representing DNA sequences and function values. Useful for bioinformatics pipelines where sequence manipulation and robust error handling are required.",
      "description_length": 395,
      "index": 17,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Bio_io.Cigar",
      "library": "bio_io",
      "description": "This module parses CIGAR strings into an internal representation and provides operations to analyze and visualize alignments. It supports Match (M), Insertion (I), and Deletion (D) operations, allowing computation of alignment length, gap count, match count, query length, and target length. It can convert CIGAR strings to structured data, render alignment diagrams, and handle parsing errors gracefully.",
      "description_length": 405,
      "index": 18,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Bio_io.Fasta",
      "library": "bio_io",
      "description": "This module parses FASTA files using a `Record` type that holds sequence identifiers, descriptions, and sequence data, supporting transformations like reverse and complement operations. It includes an `In_channel` module for reading and processing FASTA records from input streams through iteration, folding, and list conversion. Use it to analyze sequence data, calculate aggregate metrics such as total length, or filter and convert FASTA entries during bioinformatics pipelines.",
      "description_length": 481,
      "index": 19,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bio_io.Record_in_channel",
      "library": "bio_io",
      "description": "This module creates input channels for reading record-based data from files or standard input, supporting operations like reading individual records, folding over all records with or without indices, iterating over records for side effects, and collecting records into lists or sequences. It works with a parameterized record type `M.record` and manages input channels of type `M.t`, which represent sources of record data. Concrete use cases include parsing structured file formats like FASTA or CSV, processing large datasets without loading all records into memory, and performing aggregate calculations over sequential data entries.",
      "description_length": 636,
      "index": 20,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Bio_io.Private",
      "library": "bio_io",
      "description": "This module includes low-level input handling for binary and text data through `In_channel`, supporting operations like reading raw bytes, integers, and lines with precise control over file positioning and mode transitions. It also provides `Peekable_in_channel` for lookahead capabilities on input streams, enabling non-destructive inspection of characters and lines. These components are used for parsing structured bioinformatics formats from files, pipes, or compressed sources where strict formatting and lookahead are required.",
      "description_length": 533,
      "index": 21,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Bio_io.Fastq",
      "library": "bio_io",
      "description": "This module processes FASTQ files by parsing records and providing operations to manipulate sequence data. It works with FASTQ records containing identifier, description, sequence, and quality fields, supporting transformations like reverse-complement and in-place updates. Concrete use cases include analyzing high-throughput sequencing data, computing sequence statistics, and converting raw reads into structured formats for downstream processing.",
      "description_length": 450,
      "index": 22,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bio_io",
      "library": "bio_io",
      "description": "This module provides precise parsing and manipulation of bioinformatics file formats including FASTA, FASTQ, BLAST-like tabular output, and CIGAR strings. It supports structured data transformations, alignment analysis, and streaming input processing for large datasets. Concrete use cases include sequence manipulation, homology search result filtering, alignment diagram rendering, and custom pipeline development without reliance on external parsing tools.",
      "description_length": 459,
      "index": 23,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 24,
    "meaningful_modules": 24,
    "filtered_empty_modules": 0,
    "retention_rate": 1.0
  },
  "statistics": {
    "max_description_length": 636,
    "min_description_length": 292,
    "avg_description_length": 481.75,
    "embedding_file_size_mb": 0.34808826446533203
  }
}