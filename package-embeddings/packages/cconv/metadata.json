{
  "package": "cconv",
  "embedding_model": "Qwen/Qwen3-Embedding-8B",
  "embedding_dimension": 4096,
  "total_modules": 4,
  "creation_timestamp": "2025-08-14T22:56:07.026359",
  "modules": [
    {
      "module_path": "CConvPSexp",
      "library": "cconv.psexp",
      "description": "This module defines a type for S-expressions built from polymorphic variants, supporting direct parsing and serialization. It provides functions to convert values to and from this S-expression format, handling both atoms and nested lists. Use it to implement custom serializers or interpreters for configuration or data exchange formats without relying on external libraries.",
      "description_length": 375,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CConv.Encode",
      "library": "cconv",
      "description": "This module converts OCaml values into structured output formats, handling primitives (integers, strings, booleans), collections (lists, arrays, options), and composite types (records, tuples). It provides combinators for encoding product types (pairs, triples, quads) and sum types, including recursive structures via fixed-point encoding, enabling efficient serialization and hierarchical data transformation workflows.",
      "description_length": 421,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CConv.Decode",
      "library": "cconv",
      "description": "Provides decoding operations for structured data sources, handling basic types (integers, floats, characters) and composite structures like lists, options, records, tuples, and variant types. Uses combinators and field extraction utilities to parse nested data and key-value pairs, supporting use cases such as deserializing JSON, binary formats, or configuration data with optional or hierarchical fields.",
      "description_length": 406,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CConv",
      "library": "cconv",
      "description": "This module implements bidirectional serialization and deserialization for structured data, supporting both primitive and composite OCaml types such as records, variants, lists, and options. It provides low-level encoding and decoding combinators for building custom serializers to formats like JSON or binary, along with utilities for error reporting during conversion. Concrete use cases include parsing configuration files, marshaling data for network transmission, and converting between OCaml structures and external data representations with precise error handling.",
      "description_length": 571,
      "index": 3,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 4,
    "meaningful_modules": 4,
    "filtered_empty_modules": 0,
    "retention_rate": 1.0
  },
  "statistics": {
    "max_description_length": 571,
    "min_description_length": 375,
    "avg_description_length": 443.25,
    "embedding_file_size_mb": 0.05840873718261719
  }
}