{
  "package": "cconv",
  "embedding_model": "Qwen/Qwen3-Embedding-0.6B",
  "embedding_dimension": 1024,
  "total_modules": 4,
  "creation_timestamp": "2025-07-15T23:05:17.070629",
  "modules": [
    {
      "module_path": "CConvPSexp",
      "library": "cconv.psexp",
      "description": "This module defines a type for S-expressions using polymorphic variants, supporting atoms and lists of nested S-expressions. It provides functions to encode and decode values to and from this S-expression format, with support for error handling during decoding. Concrete use cases include serializing and parsing structured data in a format compatible with existing S-expression libraries, without requiring external dependencies.",
      "description_length": 430,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CConv.Decode",
      "library": "cconv",
      "description": "This module provides composable decoding functions that convert values from structured sources, such as lists or serialized data, into OCaml primitives (integers, strings, booleans) and container types (lists, arrays, options). It supports decoding complex structured data like records with named fields, variant types, and fixed-size collections (tuples, triples) by processing hierarchical or key-value-based representations. These capabilities are particularly useful for deserializing data from formats like JSON, binary encodings, or configuration files into idiomatic OCaml data structures.",
      "description_length": 596,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CConv.Encode",
      "library": "cconv",
      "description": "This module transforms OCaml values into structured formats through encoders for primitives (integers, strings, booleans), collections (lists, arrays, options), and algebraic data types (records, tuples, sum types). It supports recursive structures like trees and provides combinators for composing encodings of nested or variable-shaped data. Typical use cases include serializing complex data for storage, transmission, or inter-process communication, particularly when handling hierarchical or polymorphic types.",
      "description_length": 515,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CConv",
      "library": "cconv",
      "description": "This module enables bidirectional data conversion between OCaml values and structured formats like JSON, offering both decoders for parsing serialized data into typed values and encoders for transforming OCaml data into structured outputs. It supports primitives, containers, and algebraic types, allowing operations such as decoding JSON objects into records or encoding variant types into nested JSON structures. Submodules provide composable decoding of complex data like lists and named fields, and encoding of recursive and polymorphic types. Example uses include deserializing configuration files into typed structures and serializing application state for transmission.",
      "description_length": 676,
      "index": 3,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 4,
    "meaningful_modules": 4,
    "filtered_empty_modules": 0,
    "retention_rate": 1.0
  },
  "statistics": {
    "max_description_length": 676,
    "min_description_length": 430,
    "avg_description_length": 554.25,
    "embedding_file_size_mb": 0.014949798583984375
  }
}