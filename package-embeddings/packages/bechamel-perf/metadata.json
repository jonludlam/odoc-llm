{
  "package": "bechamel-perf",
  "embedding_model": "BAAI/bge-base-en-v1.5",
  "embedding_dimension": 1024,
  "total_modules": 4,
  "creation_timestamp": "2025-06-18T16:27:18.719362",
  "modules": [
    {
      "module_path": "Bechamel_perf.Extension",
      "description": "Measures low-level hardware and system performance counters, including CPU cycles, instructions, cache behavior, branch predictions, and memory events. It provides detailed metrics for profiling application behavior under varying workloads. Used to analyze performance bottlenecks in high-performance computing and system-level debugging.",
      "description_length": 338,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bechamel_perf.Instance",
      "description": "Measures low-level hardware and system performance counters, including CPU cycles, instructions, cache behavior, branch predictions, and memory events. Operates on performance witness types from the Bechamel library to capture detailed execution metrics. Used to analyze program efficiency, optimize code for specific hardware, and debug performance bottlenecks.",
      "description_length": 362,
      "index": 1,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "bechamel-perf",
      "description": "Records monotonic clock and garbage collection data to measure function performance. Operates on OCaml functions and timing intervals. Enables detailed performance analysis for optimization on Linux systems using perf metrics.",
      "description_length": 226,
      "index": 2,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Bechamel_perf",
      "description": "Provides low-level hardware and system performance monitoring through Linux's perf API, capturing detailed metrics such as CPU cycles, instructions, cache behavior, and memory events. It supports profiling application behavior, optimizing code for specific hardware, and debugging performance issues by leveraging performance witness types. Operations include initializing counters, starting and stopping measurements, and retrieving event data. Examples include analyzing cache misses in a computational kernel or tracking branch mispredictions in a tight loop.",
      "description_length": 562,
      "index": 3,
      "embedding_norm": 0.9999999403953552
    }
  ],
  "filtering": {
    "total_modules_in_package": 4,
    "meaningful_modules": 4,
    "filtered_empty_modules": 0,
    "retention_rate": 1.0
  },
  "statistics": {
    "max_description_length": 562,
    "min_description_length": 226,
    "avg_description_length": 372.0,
    "embedding_file_size_mb": 0.014936447143554688
  }
}