{
  "package": "sihl-type",
  "embedding_model": "Qwen/Qwen3-Embedding-0.6B",
  "embedding_dimension": 1024,
  "total_modules": 51,
  "creation_timestamp": "2025-07-15T23:16:13.033083",
  "modules": [
    {
      "module_path": "Sihl_type.User.Fields.Direct",
      "library": "sihl-type",
      "description": "This module provides operations to iterate over, fold, map, and query individual fields of a user record, including id, email, username, password, status, admin, confirmed, and created_at. It works directly with the `Sihl_type.User.t` type, handling primitive values like strings, booleans, and Ptime.t, as well as optional fields like username. Concrete use cases include transforming user data, validating field values, and extracting or updating specific user attributes based on their permissions and current state.",
      "description_length": 519,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sihl_type.Queue_workable_job.Fields.Direct",
      "library": "sihl-type",
      "description": "This module provides operations to iterate over, fold, map, and query individual fields of a `Queue_workable_job` record, including `name`, `work`, `failed`, `max_tries`, and `retry_delay`. It supports functional transformations and inspections of job fields with precise control over each attribute, enabling tasks like validation, serialization, or conditional updates. Use cases include processing job configurations, applying business logic conditionally per field, and building derived job structures.",
      "description_length": 506,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sihl_type.Queue_job.Fields.Direct",
      "library": "sihl-type",
      "description": "This module provides operations to iterate, fold, map, and query individual fields of queue job data structures with typed accessors and transformers. It works directly with `Sihl_type.Queue_job.t` instances, allowing precise manipulation of job properties like name, input/output handlers, retry policies, and execution logic. Concrete use cases include transforming queue job payloads, validating job configurations, and applying consistent processing logic across job fields.",
      "description_length": 478,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sihl_type.Email.Fields.Direct",
      "library": "sihl-type",
      "description": "This module provides operations to iterate, fold, map, and query individual fields of an email type with support for reading and setting values. It works directly with the `Sihl_type.Email.t` type, handling fields like sender, recipient, subject, content, and template data. Use cases include transforming email content, validating field values, or extracting specific data from email structures.",
      "description_length": 396,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sihl_type.Database.Ql.Page",
      "library": "sihl-type",
      "description": "This module defines a data structure for pagination parameters with optional `limit` and `offset` fields. It provides functions to construct, modify, and access these values, along with serialization and deserialization to JSON, S-expressions, and string representations. It is used to handle paginated database queries where specific subsets of results need to be requested by limiting the number of records and setting a starting point.",
      "description_length": 438,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sihl_type.Storage_file.Fields.Direct",
      "library": "sihl-type",
      "description": "This module provides direct access to storage file fields like `id`, `filename`, `filesize`, and `mime` through operations such as iteration, folding, mapping, and validation. It works specifically with `Sihl_type.Storage_file.t` records, allowing transformation and inspection of individual fields with precise control over read and write permissions. Concrete use cases include validating file metadata, transforming file paths, and aggregating file properties into lists or other structures.",
      "description_length": 494,
      "index": 5,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Sihl_type.Database.Ql.Sort",
      "library": "sihl-type",
      "description": "This module defines and manipulates sorting criteria for database queries, using a list of `criterion` values that represent ascending or descending sort directions for specific fields. It provides functions to convert criteria and lists of criteria to and from JSON, S-expressions, and string representations, ensuring structured serialization and comparison. Concrete use cases include building and transmitting sort instructions for queryable data structures in a type-safe manner.",
      "description_length": 484,
      "index": 6,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Sihl_type.Token_data.Fields.Direct",
      "library": "sihl-type",
      "description": "This module provides operations to iterate over, fold, filter, and transform the `user_id` field of a `Sihl_type.Token_data.t` value, with support for checking field existence and applying functions conditionally. It works directly with `Sihl_type.Token_data.t` and `Fieldslib.Field.t_with_perm` types, enabling precise manipulation of token data fields with read or set permissions. Concrete use cases include validating, mapping, or extracting values from the `user_id` field during token processing or authentication workflows.",
      "description_length": 530,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sihl_type.Queue_job_instance.Fields.Direct",
      "library": "sihl-type",
      "description": "This module provides direct access to individual fields of a queue job instance, enabling operations like iteration, mapping, folding, and validation over specific properties such as `id`, `name`, `input`, `tries`, `next_run_at`, `max_tries`, and `status`. It supports data types including strings, integers, optional strings, and time values (`Ptime.t`), and is used to manipulate and inspect job instance data during serialization, persistence, or execution logic. Concrete use cases include updating retry counts, checking execution status, and transforming job input or scheduling times.",
      "description_length": 591,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sihl_type.Email_template.Fields.Direct",
      "library": "sihl-type",
      "description": "This module provides operations to iterate over, fold, map, and query individual fields of an email template, including string-based fields like ID, name, text, and HTML content, as well as a Ptime-based created_at timestamp. Functions support transforming, validating, or extracting values from these fields in a structured way. Concrete use cases include updating template content, validating field values, or serializing templates to a list of field values.",
      "description_length": 460,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sihl_type.Database.Ql.Filter",
      "library": "sihl-type",
      "description": "This module provides types and helper functions for constructing and combining database query filters using equality checks, substring matching, and logical operations (AND/OR) over key-value pairs. It defines a recursive filter structure that supports comparison, pretty-printing, and composition, enabling dynamic query condition building. Serialization to S-expressions and Yojson facilitates storage, transmission, or programmatic manipulation of filters in JSON-based systems.",
      "description_length": 481,
      "index": 10,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Sihl_type.Token.Fields.Direct",
      "library": "sihl-type",
      "description": "This module directly manipulates individual fields of a `Sihl_type.Token.t` value, allowing iteration, folding, filtering, mapping, and validation over specific token properties. It supports operations on fields such as `id`, `value`, `data`, `kind`, `status`, `expires_at`, and `created_at`, each with typed accessors and transformers. Concrete use cases include validating token fields, transforming token data, and extracting structured information from tokens for processing or serialization.",
      "description_length": 496,
      "index": 11,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sihl_type.Storage_stored.Fields.Direct",
      "library": "sihl-type",
      "description": "This module provides operations to traverse, transform, and query stored data fields in a structured way. It supports iteration with `iter`, accumulation with `fold`, filtering with `for_all` and `exists`, and data extraction with `to_list` and `map`, handling both file and blob field types. It is used to manipulate storage records by applying functions to each field, such as migrating data, validating contents, or collecting metadata.",
      "description_length": 439,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sihl_type.Database.Ql.Sql",
      "library": "sihl-type",
      "description": "This module provides functions for constructing and manipulating SQL query fragments from structured query descriptions. It handles operations like filtering, sorting, limiting, and offsetting query results, working with data types such as string lists, filter criteria, and sort criteria. It is used to safely build parameterized SQL queries based on a whitelist of allowed fields, ensuring query validity and preventing injection attacks.",
      "description_length": 440,
      "index": 13,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sihl_type.Queue_job_instance.Fields",
      "library": "sihl-type",
      "description": "This module organizes access to individual properties of queue job instances, offering typed operations to transform, validate, and traverse fields like `id`, `tries`, `next_run_at`, and `status`. It supports direct manipulation of job data through mapping, folding, and filtering, working with values such as strings, integers, optional strings, and `Ptime.t`. Use it to update retry counts before rescheduling, validate job state before execution, or extract and transform job metadata during processing. Submodule functions provide field-specific access and transformations, integrating seamlessly with the broader job instance lifecycle.",
      "description_length": 641,
      "index": 14,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sihl_type.Token.Status",
      "library": "sihl-type",
      "description": "This module defines a polymorphic variant type with two values, `Active` and `Inactive`, representing the status of a token. It provides functions to convert the status to and from JSON, to display it as a string, to compare two statuses for equality, and to serialize or parse it from a string. These operations are used when handling token states in authentication or session management workflows.",
      "description_length": 399,
      "index": 15,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sihl_type.Database.Ql",
      "library": "sihl-type",
      "description": "This module enables the construction and manipulation of database queries with support for filtering, sorting, and pagination, all encapsulated in a structured format that can be converted into SQL. It provides core data types for representing query components\u2014such as filters with logical operations, sort criteria for ordering results, and pagination parameters\u2014and operations to compose and modify these components programmatically. Submodules handle serialization to and from formats like JSON and S-expressions, facilitate structured query transmission and storage, and ensure safe SQL generation by validating fields against a whitelist. Example uses include implementing domain-specific query interfaces, dynamically composing filters based on user input, and handling paginated and sorted result sets in web services.",
      "description_length": 825,
      "index": 16,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Sihl_type.Session.Map",
      "library": "sihl-type",
      "description": "This module implements a string-keyed map with polymorphic values, supporting dictionary operations like insertion, deletion, and merging, along with functional transformations such as mapping, filtering, and folding over key-value pairs. It facilitates efficient session state management by enabling dynamic value updates, list aggregations, and conversions between maps, lists, and sequences. Specific use cases include handling ephemeral session data in web applications, processing key-value streams from external sources, and maintaining contextual metadata with arbitrary value types.",
      "description_length": 590,
      "index": 17,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Sihl_type.Token.Fields",
      "library": "sihl-type",
      "description": "This module organizes and operates on structured token fields, combining direct manipulation of individual properties with typed accessors and transformations. It supports key operations like mapping, folding, filtering, and validation across fields such as `id`, `value`, `status`, and timestamps, enabling tasks like token validation, data transformation, and structured extraction. The child module extends this by providing fine-grained iteration and manipulation of specific token attributes within `Sihl_type.Token.t`. Together, they allow precise, type-safe processing of token data, such as validating expiration times or serializing token contents.",
      "description_length": 657,
      "index": 18,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sihl_type.User.Fields",
      "library": "sihl-type",
      "description": "This module organizes user data fields with typed accessors and transformations, enabling precise manipulation of user records through operations like map, fold, and query. It supports core data types such as strings, booleans, Ptime.t, and optional fields, all tied to the `Sihl_type.User.t` structure. You can validate user input, transform specific fields like email or status, and extract data for auditing or authentication. Submodules extend this functionality with targeted operations on individual fields, allowing fine-grained updates and conditional logic based on user state.",
      "description_length": 586,
      "index": 19,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sihl_type.User.Error",
      "library": "sihl-type",
      "description": "This module defines error types for user-related operations such as registration, authentication, and validation. It includes specific errors for cases like duplicate registration, incorrect passwords, invalid password formats, and non-existent users. These types are used to handle and propagate user management failures in authentication and user service logic.",
      "description_length": 363,
      "index": 20,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Sihl_type.Token_data.Fields",
      "library": "sihl-type",
      "description": "This module provides direct access and manipulation of the `user_id` field within `Sihl_type.Token_data.t` values, supporting operations like creation, mapping, iteration, and folding. It enables conditional transformations and existence checks on the field, working with types such as `Fieldslib.Field.t_with_perm` to enforce read or set permissions. The module also includes utilities for processing lists of token data fields, allowing bulk validation, extraction, and modification of user identifiers. Specific use cases include extracting user IDs from tokens, transforming token data based on user associations, and validating user-field integrity during authentication.",
      "description_length": 676,
      "index": 21,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sihl_type.Storage_stored.Fields",
      "library": "sihl-type",
      "description": "This module organizes and processes fields of stored data types, focusing on `blob` and `file` fields with defined read and write permissions. It supports creating, transforming, and validating fields through operations like `map`, `fold`, `iter`, and `to_list`, enabling tasks such as data migration, content validation, and metadata collection. The module's submodules extend these capabilities with structured traversal and querying, allowing conditional checks and field-wise data extraction. Examples include constructing storage records, converting blobs to files, and validating field contents during persistence.",
      "description_length": 620,
      "index": 22,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sihl_type.Storage_file.Fields",
      "library": "sihl-type",
      "description": "This module organizes access to storage file fields, offering typed operations to construct, transform, and query `Sihl_type.Storage_file.t` records. It supports mapping, folding, and validating individual fields such as `id`, `filename`, `filesize`, and `mime`, with explicit handling of read and create permissions. Submodules enable direct manipulation of these fields, allowing tasks like metadata validation, path transformation, and property aggregation. Specific uses include building storage files from field values, extracting metadata into lists, and applying validation rules during field updates.",
      "description_length": 608,
      "index": 23,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sihl_type.Queue_job_instance.Status",
      "library": "sihl-type",
      "description": "This module defines an enumerated type with three states\u2014`Pending`, `Succeeded`, and `Failed`\u2014representing the lifecycle status of a queue job instance. It includes functions for converting statuses to and from JSON, displaying them as strings, and comparing equality. These operations directly support persisting job states in a durable queue system and inspecting their outcomes programmatically.",
      "description_length": 398,
      "index": 24,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "Sihl_type.Email_template.Data",
      "library": "sihl-type",
      "description": "This module provides functions to construct and manipulate lists of key-value pairs used for email template data. It includes operations to add entries, check equality, format for debugging, and convert to strings. Concrete use cases include assembling dynamic content for email templates, such as substituting placeholders with user-specific values.",
      "description_length": 350,
      "index": 25,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sihl_type.Email.Fields",
      "library": "sihl-type",
      "description": "This module provides operations to read, set, and transform individual fields of an email type, such as sender, recipient, subject, and content, working directly with the `Sihl_type.Email.t` type. It supports iteration, mapping, folding, and querying over email fields, enabling tasks like content transformation, validation, or data extraction. Child modules extend these capabilities with specialized functions for handling template data and structured email components. Examples include updating a recipient list, extracting attachments, or modifying subject lines dynamically.",
      "description_length": 580,
      "index": 26,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sihl_type.Email_template.Fields",
      "library": "sihl-type",
      "description": "This module organizes email template fields, handling identifiers, names, HTML and text content, and timestamps, with operations to create, map, fold, and validate these fields. It supports workflows like constructing templates from raw data, checking required fields, and converting templates into structured formats such as lists or custom types. The child module enhances these capabilities by enabling fine-grained iteration, transformation, and querying of individual fields, including string and time-based values. Specific examples include validating email content, updating template fields, and serializing templates for storage or transmission.",
      "description_length": 653,
      "index": 27,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Sihl_type.Queue_workable_job.Fields",
      "library": "sihl-type",
      "description": "This module organizes and manipulates job fields within a workable queue system, offering direct access to attributes like name, retry delay, max tries, failure handler, and work function. It supports creation, mapping, iteration, and polymorphic field access over `Sihl_type.Queue_workable_job.t`, allowing precise transformations and inspections of job properties. The child module extends this by enabling functional operations\u2014such as fold, map, and query\u2014on individual job fields, facilitating tasks like validation, conditional updates, and job serialization. Together, they provide a structured way to define job behavior, apply logic per field, and derive new job configurations from existing ones.",
      "description_length": 706,
      "index": 28,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Sihl_type.Queue_job.Fields",
      "library": "sihl-type",
      "description": "This module organizes job queue fields with typed accessors that support reading, setting, and transforming job properties such as name, retry delay, max tries, and handler functions. It enables field-level permission checks using `Field.t_with_perm` and works directly with `Sihl_type.Queue_job.t` for tasks like constructing job definitions, validating properties, and mapping or folding over fields. Submodule operations allow iteration, mapping, and querying of individual job fields, enabling precise manipulation of job payloads and execution logic. Examples include applying validation rules across job configurations, transforming retry policies, and extracting or modifying handler functions with type safety.",
      "description_length": 718,
      "index": 29,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sihl_type.Cleaner",
      "library": "sihl-type",
      "description": "This module defines a type `t` representing a function that returns an Lwt promise resolving to `unit`, typically used for resource cleanup tasks. It provides operations to compose and sequence asynchronous cleanup actions, ensuring resources are released in a specific order. Concrete use cases include closing database connections, removing temporary files, or unregistering event handlers.",
      "description_length": 392,
      "index": 30,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sihl_type.Queue_job_instance",
      "library": "sihl-type",
      "description": "This module manages the lifecycle of job instances derived from job descriptions and input data, providing persistence through serialization. It tracks execution status, retry limits, and scheduling parameters, allowing operations like checking eligibility for execution with `should_run` and rescheduling failed jobs with updated retry counts. The module\u2019s structured data model includes fields such as `id`, `tries`, `next_run_at`, and `status`, which can be manipulated using typed accessors and transformations. The status type, represented as `Pending`, `Succeeded`, or `Failed`, supports JSON serialization and state comparison, enabling durable job queue implementations with precise state transitions.",
      "description_length": 709,
      "index": 31,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sihl_type.Http_response",
      "library": "sihl-type",
      "description": "This module enables constructing and modifying HTTP responses with support for status codes, headers, cookies, and body content in formats like JSON, HTML, or XML. It operates on the `Sihl_type.Http_response.t` type\u2014a wrapper around `Rock.Response.t` that includes metadata like version, headers, and environment context\u2014to facilitate tasks such as redirecting requests, parsing response payloads, or asynchronously serving static files. Specific use cases include building dynamic web responses, managing session cookies, and handling file-based content delivery in asynchronous I/O workflows.",
      "description_length": 594,
      "index": 32,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sihl_type.Http_middleware",
      "library": "sihl-type",
      "description": "This module creates HTTP middleware by wrapping a filter function that processes incoming requests and outgoing responses. It works with `Rock.Request.t` and `Rock.Response.t` types to modify or inspect HTTP traffic within a web application. A concrete use case is implementing authentication checks or logging that run before or after route handlers.",
      "description_length": 351,
      "index": 33,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Sihl_type.Email",
      "library": "sihl-type",
      "description": "This module enables the construction, manipulation, and management of structured email messages with support for text and HTML content, CC/BCC recipients, and template-based generation. It provides core operations to create, update, and serialize emails, along with an in-memory inbox for batch processing and storage. Child modules allow fine-grained access to individual email fields, supporting transformations, queries, and template rendering on the `Sihl_type.Email.t` type. Examples include dynamically rewriting email headers, extracting content for logging or analysis, and assembling multi-format messages from templates with runtime data.",
      "description_length": 648,
      "index": 34,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sihl_type.Queue_job",
      "library": "sihl-type",
      "description": "This module manages queue job configurations with a focus on retry policies, serialization, and failure handling. It provides a polymorphic job type that carries input data, retry settings, and handler functions, supporting operations like setting retry delays, serializing job inputs, and defining error callbacks. The Fields submodule enables typed access and transformation of job properties such as name, retry count, and handler, allowing field-level validation and safe manipulation of job definitions. Examples include defining background jobs that retry on failure with custom delays, serializing job payloads for storage or transmission, and applying validation rules across job configurations using typed field accessors.",
      "description_length": 731,
      "index": 35,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sihl_type.Database",
      "library": "sihl-type",
      "description": "This module provides a structured way to build and manipulate database queries with support for filtering, sorting, and pagination, all translatable into SQL. It includes data types for query components such as logical filters, sort criteria, and pagination parameters, along with operations to compose and modify them programmatically. It also includes submodules for serializing queries to JSON and S-expressions, enabling safe query transmission and storage. You can use it to build dynamic query interfaces, generate SQL safely from validated inputs, or manage paginated results in web services.",
      "description_length": 599,
      "index": 36,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sihl_type.User",
      "library": "sihl-type",
      "description": "This module manages user records with robust operations for authentication, validation, and role-based access control. It centers around a structured user data type with fields like `id`, `email`, `password`, and timestamps, supporting actions such as password setting with policy enforcement, status confirmation, and permission checks. Submodules provide typed accessors and transformations for precise record manipulation, along with specific error types to handle failures in registration, login, and validation. Example uses include implementing secure login flows, enforcing access restrictions, and managing user state changes with typed, auditable updates.",
      "description_length": 664,
      "index": 37,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sihl_type.Session",
      "library": "sihl-type",
      "description": "This module represents a session with a key and expiration time, offering operations to check expiration, retrieve the key, and serialize session data. It integrates a string-keyed map for managing session state, supporting dictionary operations, functional transformations, and conversions with lists and sequences. Built with Ptime, it enables concrete workflows like managing user session lifecycles, processing session data streams, and maintaining contextual metadata with arbitrary value types. Use cases include validating sessions in web applications and aggregating ephemeral session state from external sources.",
      "description_length": 621,
      "index": 38,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "Sihl_type.Migration",
      "library": "sihl-type",
      "description": "This module defines data structures and operations for managing database migration steps. It provides functions to create and manipulate migration steps, each consisting of a label, SQL statement, and foreign key check flag, as well as utilities to format, compare, and display these steps. It is used to construct and manage sequences of database schema updates, particularly in the context of versioned database migrations.",
      "description_length": 425,
      "index": 39,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sihl_type.Token",
      "library": "sihl-type",
      "description": "This module defines a token type with fields such as identifier, value, optional data, kind, status, and timestamps, supporting creation, field access, invalidation, and validity checks based on expiration. The `Status` submodule provides a polymorphic variant type with `Active` and `Inactive` values, along with JSON conversion, string representation, and comparison functions for managing token states. Another submodule enables structured manipulation of token fields through mapping, folding, filtering, and validation, allowing precise operations like checking expiration or transforming token data. Together, these components support use cases such as authentication token management with typed, state-aware processing.",
      "description_length": 726,
      "index": 40,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Sihl_type.Queue_workable_job",
      "library": "sihl-type",
      "description": "This module structures executable jobs with configurable retry policies and failure handling, organizing tasks as named entities equipped with work functions, retry limits, and delay intervals. It supports creating, transforming, and querying job properties through direct access and functional operations like map and fold, enabling tasks such as validating retry configurations or modifying work functions. Submodules enhance this by providing fine-grained manipulation of individual job fields, allowing serialization, conditional updates, and derived job creation. Example uses include processing email deliveries or API requests with automatic retries and custom failure recovery.",
      "description_length": 685,
      "index": 41,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Sihl_type.Storage_file",
      "library": "sihl-type",
      "description": "This module represents a stored file with metadata like identifier, filename, size, and MIME type, offering direct access and updates to individual fields along with JSON serialization. It enables managing file uploads, persisting metadata, and transmitting file information across services, while supporting typed construction, transformation, and validation of file records. Submodules provide operations for mapping, folding, and validating specific fields such as `id`, `filename`, `filesize`, and `mime`, allowing tasks like metadata extraction, path transformation, and rule enforcement during updates. Examples include building storage files from raw values, aggregating properties, and validating field constraints during creation or modification.",
      "description_length": 755,
      "index": 42,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sihl_type.Http_request",
      "library": "sihl-type",
      "description": "This module enables creating and manipulating HTTP requests through method-specific constructors, body format conversions (JSON, URL-encoded, etc.), and precise header/cookie management. It operates on structured representations of HTTP requests, encapsulating metadata like methods, headers, and environments, and is particularly useful for handling form submissions, authentication flows, or cookie-based sessions. Serialization utilities allow debugging or logging requests via human-readable HTTP/1.1 or s-expression formats.",
      "description_length": 529,
      "index": 43,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sihl_type.Storage_stored",
      "library": "sihl-type",
      "description": "This module represents stored files with structured metadata and binary content, supporting construction, attribute manipulation, and JSON serialization. It organizes data processing through blob and file fields with permission-aware access, enabling transformations, validation, and traversal across structured storage records. Operations like `map`, `fold`, and `to_list` allow data migration, conditional checks, and metadata extraction, such as converting blobs to files or validating content before persistence. Specific use cases include handling file uploads, persisting typed storage records, and querying field data with structured access patterns.",
      "description_length": 657,
      "index": 44,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sihl_type.Email_template",
      "library": "sihl-type",
      "description": "This module manages email templates with a structured data type that includes fields like `id`, `name`, `content_text`, and `content_html`, supporting operations for access, update, serialization, and equality checks. It enables rendering personalized email content through variable substitution, using key-value pairs assembled and manipulated by its child modules. The child modules provide utilities to construct and validate template fields, transform and query individual components, and format data for debugging or display. Specific uses include generating concrete email messages from templates, validating content structure, and serializing templates for storage or transmission.",
      "description_length": 688,
      "index": 45,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sihl_type.Migration_state",
      "library": "sihl-type",
      "description": "This module manages migration state by tracking a namespace, version number, and dirty flag. It provides operations to increment version, mark state as clean or dirty, and determine steps to apply based on current state. Use it to handle database or configuration migrations where versioning and state tracking are required.",
      "description_length": 324,
      "index": 46,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sihl_type.Token_data",
      "library": "sihl-type",
      "description": "This module structures user authentication tokens with a focus on the `user_id` field, offering construction, access, and JSON conversion through Yojson. It supports direct manipulation of token fields with operations for mapping, folding, and conditional updates, using permission-aware types to control access. Submodules enhance this functionality with list-level processing, enabling bulk validation and transformation of user identifiers. Example uses include extracting and validating user IDs from tokens, and applying set-only or read-only constraints during authentication workflows.",
      "description_length": 592,
      "index": 47,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sihl_type.Http_cookie",
      "library": "sihl-type",
      "description": "This module handles HTTP cookie creation, parsing, and serialization with support for expiration, security flags, and SameSite attributes. It operates on cookie values represented as key-value pairs, along with associated metadata like domain scope and secure flags. Concrete use cases include constructing cookies for HTTP responses, extracting cookie values from request headers, and managing signed cookies for secure session handling.",
      "description_length": 438,
      "index": 48,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sihl_type.Http_route",
      "library": "sihl-type",
      "description": "This module defines HTTP route handling with methods like GET, POST, and middleware integration. It works with route definitions composed of HTTP methods, paths, and async handlers operating on Rock requests and responses. Concrete use cases include building scoped HTTP routers that map endpoints to handler logic and prefixing routes for modular service composition.",
      "description_length": 368,
      "index": 49,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Sihl_type",
      "library": "sihl-type",
      "description": "This module provides structured data types and operations for managing asynchronous workflows, HTTP interactions, persistent jobs, and user/session state in web applications. Core types include functions for resource cleanup, HTTP requests/responses with middleware support, job configurations with retry policies, user records with authentication, and tokens for session management. Examples include composing database connection closures, building dynamic email messages from templates, defining versioned database migrations, and implementing secure login flows with typed user records. It supports precise manipulation of structured data through typed accessors, JSON serialization, and functional transformations across domains like HTTP handling, job queues, and storage management.",
      "description_length": 788,
      "index": 50,
      "embedding_norm": 0.9999999403953552
    }
  ],
  "filtering": {
    "total_modules_in_package": 51,
    "meaningful_modules": 51,
    "filtered_empty_modules": 0,
    "retention_rate": 1.0
  },
  "statistics": {
    "max_description_length": 825,
    "min_description_length": 324,
    "avg_description_length": 556.9803921568628,
    "embedding_file_size_mb": 0.1857461929321289
  }
}