{
  "package": "sihl-type",
  "embedding_model": "Qwen/Qwen3-Embedding-8B",
  "embedding_dimension": 4096,
  "total_modules": 50,
  "creation_timestamp": "2025-08-15T14:32:30.640250",
  "modules": [
    {
      "module_path": "Sihl_type.Database.Ql.Sql",
      "library": "sihl-type",
      "description": "This module provides functions for constructing and validating SQL query fragments from structured query descriptions. It operates on SQL criteria like filters, sorting, and pagination, using data types such as string lists for whitelisted fields and custom criterion types for filters and sorting. It is used to safely generate parameterized SQL queries from high-level query descriptions, ensuring field and filter validity against a whitelist.",
      "description_length": 446,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sihl_type.Token.Fields.Direct",
      "library": "sihl-type",
      "description": "This module provides direct access to token fields for iteration, transformation, and validation over a `Sihl_type.Token.t` structure. It supports operations like mapping values, checking conditions with `exists` or `for_all`, and converting token fields to a list. Concrete use cases include validating token properties, transforming token data, and extracting specific field values for logging or serialization.",
      "description_length": 413,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sihl_type.Database.Ql.Filter",
      "library": "sihl-type",
      "description": "This module enables constructing and combining database query filters using comparison operators like `Eq` and `Like`, as well as logical compositions (AND/OR) through a recursive type structure. It operates on hierarchical data representations of criteria and filters, supporting operations to serialize and deserialize these structures into formats like S-expressions and Yojson. Typical use cases include dynamically building query conditions for database interactions, persisting filter configurations, or transmitting structured filters across systems.",
      "description_length": 557,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sihl_type.Storage_stored.Fields.Direct",
      "library": "sihl-type",
      "description": "This module provides operations to traverse, transform, and query fields of a stored data structure, specifically handling file and blob types with read and write permissions. Functions like `iter`, `fold`, and `map` allow applying actions to each field, while `for_all` and `exists` support conditional checks across fields. It is used to manipulate storage entities by directly accessing or modifying their individual components, such as updating stored files or validating blob contents.",
      "description_length": 490,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sihl_type.User.Fields.Direct",
      "library": "sihl-type",
      "description": "This module provides operations to iterate over, fold, map, and query individual fields of a user record with typed accessors. It works directly with `Sihl_type.User.t` records, exposing functions that handle specific fields like email, password, username, and timestamps with appropriate type handling. Concrete use cases include validating user data, transforming field values, or extracting information for serialization and business logic evaluation.",
      "description_length": 454,
      "index": 4,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Sihl_type.Storage_file.Fields.Direct",
      "library": "sihl-type",
      "description": "This module provides operations to iterate over, fold, filter, and transform individual fields of a `Sihl_type.Storage_file.t` record, specifically handling `id`, `filename`, `filesize`, and `mime` fields with read and write permissions. It supports concrete use cases like validating field values, converting file metadata, or extracting specific attributes into a list. Functions like `map` and `iter` allow direct manipulation or inspection of each field while preserving structure and access control.",
      "description_length": 504,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sihl_type.Queue_job_instance.Fields.Direct",
      "library": "sihl-type",
      "description": "This module provides direct access to individual fields of a queue job instance, enabling operations like iteration, folding, mapping, and validation over specific properties such as `id`, `name`, `input`, `tries`, `next_run_at`, `max_tries`, and `status`. It supports data types including strings, integers, optional strings, and Ptime timestamps, all tied to the `Queue_job_instance.t` structure. Concrete use cases include transforming job instance data, validating field values, or extracting specific field information for serialization and persistence tasks.",
      "description_length": 564,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sihl_type.Queue_workable_job.Fields.Direct",
      "library": "sihl-type",
      "description": "This module provides operations to iterate over, fold, map, and query individual fields of a `Queue_workable_job` record, including `name`, `work`, `failed`, `max_tries`, and `retry_delay`. It supports functional transformations and inspections of job fields with precise control over each attribute, enabling tasks like validation, serialization, or conditional updates. Concrete use cases include modifying job retry behavior, inspecting work functions, or extracting job metadata for logging and monitoring.",
      "description_length": 510,
      "index": 7,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Sihl_type.Queue_job.Fields.Direct",
      "library": "sihl-type",
      "description": "This module provides operations to iterate, fold, map, and query individual fields of queue job records, including name, input/output transformations, handling logic, failure callbacks, retry parameters, and maximum retry counts. It works directly with `Sihl_type.Queue_job.t` typed records, allowing field access and modification with specific permissions like read or set-and-create. Concrete use cases include inspecting or modifying queue job properties during processing, configuring retry behavior, and converting job inputs and outputs for serialization or execution.",
      "description_length": 574,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sihl_type.Email_template.Fields.Direct",
      "library": "sihl-type",
      "description": "This module provides operations to iterate over, fold, map, and query individual fields of an email template, including string and timestamp fields like `id`, `name`, `content_text`, `content_html`, and `created_at`. It supports concrete actions such as validation, transformation, and conditional checks on these fields. Use cases include processing and manipulating email templates during creation or updates, ensuring field-level consistency, or extracting specific values for logging or serialization.",
      "description_length": 505,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sihl_type.Database.Ql.Page",
      "library": "sihl-type",
      "description": "This module defines a data structure for pagination parameters with optional `limit` and `offset` fields. It provides functions to construct, modify, and access these values, along with serialization and deserialization to JSON, S-expressions, and string representations. Use this module when handling paginated database queries, such as implementing REST API pagination or batch data retrieval.",
      "description_length": 395,
      "index": 10,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sihl_type.Email.Fields.Direct",
      "library": "sihl-type",
      "description": "This module provides operations to iterate, fold, map, and query individual fields of an email type, including sender, recipient, subject, content, and template data. It supports data types like strings, boolean flags, string lists, and optional values, enabling precise manipulation of email attributes. Concrete use cases include validating email fields, transforming content, or extracting metadata for processing or serialization.",
      "description_length": 434,
      "index": 11,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sihl_type.Database.Ql.Sort",
      "library": "sihl-type",
      "description": "This module defines and manipulates sorting criteria for database queries, supporting ascending and descending order specifications on string fields. It provides functions to convert criteria to and from JSON, S-expressions, and string representations, along with comparison and formatting operations. It is used to construct and serialize sort expressions in query-building contexts.",
      "description_length": 384,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sihl_type.Token_data.Fields.Direct",
      "library": "sihl-type",
      "description": "This module provides operations to iterate, fold, map, and query specific fields within a token data structure, focusing on user identifiers. It supports processing fields with read or create permissions, enabling transformations and inspections directly on user ID values. Use cases include validating, converting, or aggregating user-related token data in authentication and authorization workflows.",
      "description_length": 401,
      "index": 13,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sihl_type.Storage_file.Fields",
      "library": "sihl-type",
      "description": "This module directly manipulates fields of a `Sihl_type.Storage_file.t` record, offering typed access to `id`, `filename`, `filesize`, and `mime` with read and write permissions. It supports concrete operations such as creating and mapping file records, folding over field values, and checking conditions across fields. Use cases include constructing storage file instances, transforming metadata, and validating or extracting field data with precise control over each attribute.",
      "description_length": 479,
      "index": 14,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sihl_type.Token.Status",
      "library": "sihl-type",
      "description": "This module defines a polymorphic variant type representing the status of a token, with two possible values: `Active` and `Inactive`. It provides functions for converting the type to and from JSON, displaying it as a string, comparing values for equality, and parsing from a string. Concrete use cases include serializing token statuses for storage or transmission, and validating string inputs into typed status values.",
      "description_length": 420,
      "index": 15,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sihl_type.Storage_stored.Fields",
      "library": "sihl-type",
      "description": "This module defines and manipulates fields of a stored data structure, focusing on `blob` and `file` types with read and create permissions. It provides direct access to field values, enables creation of storage instances via `create`, and supports transformations and queries using functions like `map`, `iter`, `fold`, and `exists`. Concrete use cases include validating file metadata, transforming stored blobs, and building storage records from field components.",
      "description_length": 466,
      "index": 16,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sihl_type.Queue_job_instance.Status",
      "library": "sihl-type",
      "description": "This module defines an enumeration type with three states\u2014`Pending`, `Succeeded`, and `Failed`\u2014representing the lifecycle status of a queue job instance. It includes functions for converting status values to and from JSON, strings, and formatted output, along with equality checks and serialization helpers. These operations support persisting and restoring job state in a durable queue system.",
      "description_length": 394,
      "index": 17,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sihl_type.Email_template.Fields",
      "library": "sihl-type",
      "description": "This module provides operations to access, transform, and validate individual fields of an email template, such as `id`, `name`, `content_text`, `content_html`, and `created_at`. It supports concrete actions like mapping over fields, performing conditional checks, and folding values into aggregate structures. Use cases include enforcing field-level constraints during template creation, extracting data for serialization, or applying transformations to template content and metadata.",
      "description_length": 485,
      "index": 18,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sihl_type.User.Error",
      "library": "sihl-type",
      "description": "This module defines error types for user-related operations such as registration, authentication, and validation. It includes specific errors like `AlreadyRegistered`, `IncorrectPassword`, and `InvalidPasswordProvided` with associated data. These types are used to handle and propagate failure cases in user management workflows.",
      "description_length": 329,
      "index": 19,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sihl_type.Token_data.Fields",
      "library": "sihl-type",
      "description": "This module provides operations to access, transform, and query the `user_id` field of a `Sihl_type.Token_data.t` structure, supporting read and set-on-create permissions. It includes functions to create, map, fold, iterate, and filter over the user ID field, enabling direct manipulation and inspection of user identifiers within token data. Concrete use cases include extracting user IDs for authentication checks, transforming token data during creation, and validating user associations in authorization contexts.",
      "description_length": 517,
      "index": 20,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sihl_type.Queue_job_instance.Fields",
      "library": "sihl-type",
      "description": "This module provides direct access to individual fields of a queue job instance, enabling operations like iteration, folding, mapping, and validation over specific properties such as `id`, `name`, `input`, `tries`, `next_run_at`, `max_tries`, and `status`. It supports data types including strings, integers, optional strings, and Ptime timestamps, all tied to the `Queue_job_instance.t` structure. Concrete use cases include transforming job instance data, validating field values, or extracting specific field information for serialization and persistence tasks.",
      "description_length": 564,
      "index": 21,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sihl_type.Email_template.Data",
      "library": "sihl-type",
      "description": "This module handles key-value pair lists for email template data, providing operations to add entries, check equality, and format or display the data. It works with lists of string pairs, supporting empty initialization and single-entry creation. Concrete use cases include constructing and manipulating dynamic data for email templates, such as substituting placeholders with user-specific values.",
      "description_length": 398,
      "index": 22,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Sihl_type.Queue_workable_job.Fields",
      "library": "sihl-type",
      "description": "This module defines and manipulates fields of a queueable job, such as `name`, `work`, `failed`, `max_tries`, and `retry_delay`, providing accessors and transformation functions. It supports creating, mapping, folding, and querying job attributes with precise control over each field. Concrete use cases include defining job behavior with retry logic, extracting job metadata, and applying transformations to job fields for configuration or inspection.",
      "description_length": 452,
      "index": 23,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sihl_type.Session.Map",
      "library": "sihl-type",
      "description": "This module implements a string-keyed map with polymorphic values, offering dictionary operations like insertion, deletion, and lookup, alongside functional transformations such as folding, filtering, and mapping. It supports advanced manipulations including merging, splitting, and comparison of maps, as well as conversions between maps and sequences or lists. Designed for handling session state, it facilitates use cases like tracking user session data, aggregating session variables, and processing key-value pairs in functional workflows.",
      "description_length": 544,
      "index": 24,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sihl_type.Token.Fields",
      "library": "sihl-type",
      "description": "This module provides direct access to individual fields of a `Sihl_type.Token.t` structure, enabling precise manipulation and inspection. It supports operations like mapping over fields, folding, checking conditions with `exists` or `for_all`, and converting fields to a list. Concrete use cases include validating token expiration or status, transforming token data for storage or transmission, and extracting field values for logging or debugging.",
      "description_length": 449,
      "index": 25,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sihl_type.Database.Ql",
      "library": "sihl-type",
      "description": "This module enables constructing and modifying structured database queries with logical combinations of filters, sort orders, and pagination parameters, operating on dedicated types for query conditions, sorting directives, and page constraints. It supports programmatic query assembly for dynamic filtering, ordered result sets, and paginated data retrieval, with serialization to SQL, JSON, and other formats for safe execution and interoperability. Use cases include building flexible database interfaces, API endpoints with sorting/pagination controls, and type-safe query generation for relational databases.",
      "description_length": 613,
      "index": 26,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sihl_type.User.Fields",
      "library": "sihl-type",
      "description": "This module defines a collection of typed fields for a user record, including standard attributes like email, password, username, and timestamps, each with read and set permissions. It provides operations to create, map, fold, iterate, and query user data with precise type handling for each field. Concrete use cases include user data validation, transformation, and extraction for storage, authentication, or API serialization.",
      "description_length": 429,
      "index": 27,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Sihl_type.Queue_job.Fields",
      "library": "sihl-type",
      "description": "This module provides direct access and manipulation of individual fields in `Sihl_type.Queue_job.t` records, such as name, retry delay, max tries, input/output conversion functions, and job handling logic. It supports operations like reading, setting, mapping, folding, and checking conditions over these fields with precise permissions. Concrete use cases include configuring queue jobs with specific retry policies, transforming job payloads for execution or storage, and inspecting job metadata during processing.",
      "description_length": 516,
      "index": 28,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sihl_type.Storage_stored",
      "library": "sihl-type",
      "description": "This module handles structured storage data combining a file reference and a blob string. It provides direct access to components like blob, file, and metadata fields (mime, filesize, filename), with operations to transform or validate stored data. Use cases include constructing storage records, extracting metadata for processing, and modifying stored file attributes.",
      "description_length": 370,
      "index": 29,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sihl_type.Migration_state",
      "library": "sihl-type",
      "description": "This module manages migration state tracking with operations to create, update, and query migration records. It works with a record type containing namespace, version, and dirty status, and supports tuple conversions and state transitions. Concrete use cases include tracking database schema migrations, determining pending migration steps, and ensuring idempotent migration application.",
      "description_length": 387,
      "index": 30,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sihl_type.Database",
      "library": "sihl-type",
      "description": "This module provides functions to construct and manipulate structured database queries using dedicated types for filters, sorting, and pagination. It enables dynamic query assembly with logical combinations of conditions and supports serialization to SQL, JSON, and other formats. Use it to build type-safe, flexible database interfaces, API endpoints with sorting and pagination, and safe query generation for relational databases.",
      "description_length": 432,
      "index": 31,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sihl_type.Http_route",
      "library": "sihl-type",
      "description": "This module defines HTTP route handling with methods like GET, POST, and DELETE, each associated with a path and an asynchronous handler function. It supports structuring routes using a router that groups routes under a scope and applies middlewares. Use this module to declare and organize HTTP endpoints in a web application, enabling routing based on method and path patterns.",
      "description_length": 379,
      "index": 32,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sihl_type.Session",
      "library": "sihl-type",
      "description": "This module defines session data as a map of string keys to polymorphic values and includes session metadata like expiration timestamps. It provides operations to check session expiration, extract session keys, and serialize session data. Concrete use cases include managing user authentication sessions, storing temporary session variables, and handling time-limited session tokens.",
      "description_length": 383,
      "index": 33,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sihl_type.Token_data",
      "library": "sihl-type",
      "description": "This module defines a token data structure with a `user_id` field and provides functions for creating and accessing token data. It includes JSON serialization and deserialization capabilities for data interchange, along with a `Fields` submodule that offers fine-grained operations on the `user_id` field. Use cases include managing user identifiers in authentication tokens, validating user ownership during token creation, and serializing token data for storage or transmission.",
      "description_length": 480,
      "index": 34,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sihl_type.Email",
      "library": "sihl-type",
      "description": "This module provides tools to construct and manipulate email messages with sender, recipient, subject, and content fields, supporting JSON serialization, equality checks, and structured data access. It also includes operations for managing an in-memory inbox, enabling addition, retrieval, and clearing of messages, along with setting text and HTML content. These features are suited for applications handling email composition, storage, or programmatic transmission workflows.",
      "description_length": 477,
      "index": 35,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sihl_type.Http_request",
      "library": "sihl-type",
      "description": "This module supports constructing, parsing, and modifying HTTP requests with operations for setting methods (GET, POST, etc.), headers, cookies, and bodies in formats like JSON, URL-encoded, or multipart. It works with structured representations of HTTP requests, including methods, headers, cookies, query parameters, and form data, encapsulated in a type wrapping `Rock.Request.t`. These tools are useful for building HTTP clients, handling server-side request parsing, or implementing middleware that requires inspecting or transforming HTTP interactions, with pretty-printing aids for debugging or logging.",
      "description_length": 610,
      "index": 36,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sihl_type.Queue_job_instance",
      "library": "sihl-type",
      "description": "The queue job instance type represents executable jobs derived from job descriptions and input data, with fields for identity, state, and scheduling. Operations include creation, state updates (status, retries, next run time), serialization, and execution timing checks, supporting durable job queues and scheduled task processing with persistence guarantees.",
      "description_length": 359,
      "index": 37,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sihl_type.Queue_workable_job",
      "library": "sihl-type",
      "description": "This module defines a workable job structure with explicit fields for job name, work and failure handlers, retry limits, and delay durations. It provides direct accessors for retrieving job properties and functions to format or display job data. Concrete use cases include configuring queueable jobs with custom retry behavior, handling job execution failures, and inspecting job metadata during processing or logging.",
      "description_length": 418,
      "index": 38,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sihl_type.Http_middleware",
      "library": "sihl-type",
      "description": "This module creates HTTP middleware by wrapping a filter function that processes incoming requests and outgoing responses. It works with `Rock__.Request.t` and `Rock__.Response.t` types to modify or inspect HTTP traffic within a web application. A concrete use case is implementing authentication checks or logging request details before passing control to the next middleware or handler.",
      "description_length": 388,
      "index": 39,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Sihl_type.Http_response",
      "library": "sihl-type",
      "description": "This module provides operations to construct and manipulate HTTP responses, including creating responses from text, JSON, HTML, or files, modifying headers (e.g., `Content-Type`, `Cache-Control`) with conditional logic, and parsing structured data from response bodies. It works with response headers, cookies, and asynchronous file-based response generation using Lwt. Use cases include building dynamic HTTP responses, managing session or signed cookies, and serving static files with custom headers.",
      "description_length": 502,
      "index": 40,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sihl_type.User",
      "library": "sihl-type",
      "description": "This module manages user data through operations like password validation against policies, role and state checks, JSON serialization, and field accessors. It centers on a structured user type with email, password, status, and timestamp fields, supporting authentication workflows and secure session management. Key use cases include enforcing password complexity rules, verifying user states during login, and persisting user data in storage systems.",
      "description_length": 451,
      "index": 41,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sihl_type.Http_cookie",
      "library": "sihl-type",
      "description": "This module handles HTTP cookie creation, parsing, and serialization with support for security attributes like signing, expiration, and SameSite policies. It works with cookies represented as key-value pairs, along with metadata such as expiration time, domain scope, and security flags. Concrete use cases include constructing cookies for HTTP responses, extracting cookies from request headers, and securely managing session tokens or user preferences across HTTP transactions.",
      "description_length": 479,
      "index": 42,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sihl_type.Email_template",
      "library": "sihl-type",
      "description": "This module defines an email template data structure with text and HTML content, metadata, and operations to access, modify, and render templates. It supports concrete use cases like dynamically replacing placeholders in email content using key-value data and serializing templates to and from JSON. Functions include setting content fields, creating templates with optional HTML or text bodies, and rendering personalized email content from substitution data.",
      "description_length": 460,
      "index": 43,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Sihl_type.Cleaner",
      "library": "sihl-type",
      "description": "This module defines a type `t` representing a function that returns an Lwt promise resolving to `unit`, typically used for asynchronous cleanup tasks. It is designed to encapsulate side-effecting operations that need to be executed once, such as resource deallocation or state reset. Concrete use cases include cleaning up temporary files, closing network connections, or finalizing database transactions.",
      "description_length": 405,
      "index": 44,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Sihl_type.Queue_job",
      "library": "sihl-type",
      "description": "This module defines and manipulates queue job configurations with specific retry policies, input/output serialization, and execution handlers. It works with a polymorphic record type representing jobs, including fields for name, retry delay, max tries, and functions for handling and transforming job data. Concrete use cases include creating jobs that process serialized inputs, configuring retry behavior for failed jobs, and formatting job metadata for logging or inspection.",
      "description_length": 478,
      "index": 45,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Sihl_type.Token",
      "library": "sihl-type",
      "description": "This module defines a token data structure with fields for identifier, value, optional data, kind, status, and timestamps. It provides operations to create, invalidate, and validate tokens, as well as accessors for each field. Concrete use cases include managing authentication tokens with expiration and status checks, and transforming or inspecting token data for storage or transmission.",
      "description_length": 390,
      "index": 46,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sihl_type.Storage_file",
      "library": "sihl-type",
      "description": "This module defines a record type for representing stored files with metadata including identifier, filename, size, and MIME type. It provides constructors, accessors, and modifiers for manipulating file records, along with serialization to and from JSON, pretty-printing, equality checks, and string representations. Concrete use cases include handling file uploads, persisting file metadata, and transforming or validating file attributes in storage systems.",
      "description_length": 460,
      "index": 47,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Sihl_type.Migration",
      "library": "sihl-type",
      "description": "This module defines data structures and operations for managing database migration steps. It provides functions to create and manipulate migration steps, each consisting of a label, SQL statement, and foreign key check flag, as well as utilities to build and inspect migration sequences. It is used to construct and serialize versioned schema migrations with individual steps that can be applied in a controlled order.",
      "description_length": 418,
      "index": 48,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sihl_type",
      "library": "sihl-type",
      "description": "This module provides structured types and operations for handling asynchronous cleanup tasks, database queries, email construction, HTTP cookies, middleware, requests, responses, and routing. It works with data types like Lwt promises, database filters, email messages, HTTP requests/responses, and cookie structures. Concrete use cases include managing resource deallocation, building type-safe database queries, sending templated emails, handling HTTP session cookies, implementing authentication middleware, and routing HTTP requests to handlers.",
      "description_length": 549,
      "index": 49,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 51,
    "meaningful_modules": 50,
    "filtered_empty_modules": 1,
    "retention_rate": 0.9803921568627451
  },
  "statistics": {
    "max_description_length": 613,
    "min_description_length": 329,
    "avg_description_length": 459.22,
    "embedding_file_size_mb": 0.7248868942260742
  }
}