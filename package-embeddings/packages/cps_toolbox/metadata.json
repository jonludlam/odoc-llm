{
  "package": "cps_toolbox",
  "embedding_model": "Qwen/Qwen3-Embedding-0.6B",
  "embedding_dimension": 1024,
  "total_modules": 9,
  "creation_timestamp": "2025-07-15T23:05:47.177882",
  "modules": [
    {
      "module_path": "Cps_toolbox.Nat",
      "library": "cps_toolbox",
      "description": "This module implements basic natural number operations using Church numerals in continuation-passing style. It provides `zero` as the base value, `succ` to increment integers, and `fold` to iterate a function a given number of times. Concrete use cases include encoding recursion with continuations and modeling iterative processes without direct mutation.",
      "description_length": 356,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cps_toolbox.Option",
      "library": "cps_toolbox",
      "description": "This module provides operations for working with `option` values, including creating `some` and `none` values, extracting values with `value` and `value_unsafe`, and applying functions with `map` and `map2`. It supports safe and concise handling of optional data, such as processing user input, handling missing fields in records, or chaining computations that may fail.",
      "description_length": 370,
      "index": 1,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Cps_toolbox.Result",
      "library": "cps_toolbox",
      "description": "This module implements a result type for handling computations that may fail, providing constructors for success and error states. It supports mapping over successful values while preserving error propagation. Concrete use cases include parsing, I/O operations, and validation pipelines where explicit error handling is required.",
      "description_length": 329,
      "index": 2,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Cps_toolbox.Functional",
      "library": "cps_toolbox",
      "description": "This module provides core function manipulation tools including identity, composition, and argument swapping. It operates on first-class functions with polymorphic type parameters, enabling precise control over function application order and structure. Concrete use cases include pipeline construction, callback reordering, and higher-order function customization without runtime overhead.",
      "description_length": 389,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cps_toolbox.Order",
      "library": "cps_toolbox",
      "description": "This module defines a total ordering type with three possible values: `EQ`, `LT`, and `GT`. It provides total ordering functions for integers and strings, enabling direct comparison of values of these types. Concrete use cases include sorting integer or string lists and implementing comparison logic in data structures like binary trees or priority queues.",
      "description_length": 357,
      "index": 4,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Cps_toolbox.List",
      "library": "cps_toolbox",
      "description": "This module implements core list operations including construction, transformation, and iteration. It supports standard list manipulations such as mapping, folding, zipping, and sorting, along with utilities for flattening nested lists and selecting elements by index. Concrete use cases include processing sequences of values in a functional style, combining multiple lists, and sorting or filtering data collections.",
      "description_length": 418,
      "index": 5,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Cps_toolbox.Map",
      "library": "cps_toolbox",
      "description": "This module implements a purely functional map with ordered keys, supporting operations like insertion, deletion, and lookup with continuation-passing style handlers for presence or absence. It provides transformations through mapping and folding operations, and conversions to and from key-value lists. Concrete use cases include managing symbol tables with ordered keys, implementing environment structures for interpreters, and handling configuration settings with deterministic ordering.",
      "description_length": 491,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cps_toolbox.AVL",
      "library": "cps_toolbox",
      "description": "This module implements a balanced AVL tree with operations for insertion, deletion, membership checks, and tree traversal. It works with key-value pairs where keys are integers and values are arbitrary data, maintaining balance to ensure efficient access. Use cases include storing and retrieving data with ordered integer keys, such as managing event timelines or indexed records.",
      "description_length": 381,
      "index": 7,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Cps_toolbox",
      "library": "cps_toolbox",
      "description": "This module provides foundational abstractions for numerical computation, optional and result values, function manipulation, ordering, lists, maps, and balanced trees. Key data types include Church-encoded natural numbers, `option`, `result`, ordering comparisons, and AVL trees, with operations like `fold`, `map`, `insert`, and `compare`. You can model recursive processes with continuations, safely handle missing data, compose functions, sort lists, and manage ordered key-value stores with balanced tree efficiency. Examples include parsing with error handling, building interpreter environments, and implementing event timelines with indexed records.",
      "description_length": 656,
      "index": 8,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 10,
    "meaningful_modules": 9,
    "filtered_empty_modules": 1,
    "retention_rate": 0.9
  },
  "statistics": {
    "max_description_length": 656,
    "min_description_length": 329,
    "avg_description_length": 416.3333333333333,
    "embedding_file_size_mb": 0.033145904541015625
  }
}