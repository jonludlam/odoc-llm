{
  "package": "frenetic",
  "embedding_model": "Qwen/Qwen3-Embedding-8B",
  "embedding_dimension": 4096,
  "total_modules": 505,
  "creation_timestamp": "2025-08-18T19:57:19.974285",
  "modules": [
    {
      "module_path": "Frenetic_kernel.Net.Net.Topology.Vertex",
      "library": "frenetic.kernel",
      "description": "This module defines and manipulates vertex representations in network topologies. It provides functions for converting vertices to and from various formats (S-expressions, DOT, GML), comparing vertices, and generating string representations for visualization and Mininet integration. It works directly with network nodes, enabling use cases such as topology serialization, graph rendering, and network simulation setup.",
      "description_length": 419,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.Net.Net.Topology.UnitWeight",
      "library": "frenetic.kernel",
      "description": "This module defines a unit weight type for edges in a network topology, where weights are represented as integers. It provides functions to serialize and deserialize weights and edges, compare weights, and perform addition with a zero element. Concrete use cases include modeling uniform edge costs in network routing or graph algorithms where weights are simple integers.",
      "description_length": 372,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x04.Hello.Element.VersionBitMap",
      "library": "frenetic.kernel",
      "description": "This module handles the Supported Version Bitmap structure in OpenFlow 1.3.4 hello messages. It provides functions to calculate the size of a version bitmap, convert it to a string for debugging, and marshal or parse it to and from a Cstruct buffer. It operates on the `supportedList` type, representing the list of supported OpenFlow versions.",
      "description_length": 344,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.Network.Net.Topology.Edge",
      "library": "frenetic.kernel",
      "description": "This module represents and manipulates network edges using the underlying link type. It provides functions for serializing edges to and from S-expressions, comparing edges, converting to string and DOT format, and parsing from DOT and GML attribute lists. It is used to model network topology edges in data center simulations and graph visualizations.",
      "description_length": 351,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x01.PortDescription.PortState.StpState",
      "library": "frenetic.kernel",
      "description": "This module defines operations for converting STP (Spanning Tree Protocol) state values to and from integers and strings. It works with the `stpState` type, which represents the state of a port in the context of STP. Use cases include serializing and deserializing STP state information when handling OpenFlow 1.0 port description messages.",
      "description_length": 340,
      "index": 4,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_kernel.Network.Net.Topology.UnitWeight",
      "library": "frenetic.kernel",
      "description": "This module defines a unit weight type and operations for working with weighted edges in a network topology. It provides functions to convert weights to and from S-expressions, compare weights, add weights, and retrieve the weight of an edge. The module is used to assign and manipulate integer weights on edges in a network graph, enabling path cost calculations and other graph algorithms.",
      "description_length": 391,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.Topology.Net.Topology.Vertex",
      "library": "frenetic.kernel",
      "description": "This module defines a vertex type based on network nodes and provides functions for converting vertices to and from S-expressions, comparing them, and serializing them to formats like DOT and Mininet. It includes parsers for constructing vertices from DOT and GML representations. Use cases include representing and manipulating network topology nodes in different serialization formats for analysis or simulation.",
      "description_length": 414,
      "index": 6,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_kernel.Network.Make.Topology.UnitWeight",
      "library": "frenetic.kernel",
      "description": "This module implements a unit-weighted graph topology where edges have uniform weight. It provides functions to serialize and deserialize edge weights, compare and sum weights, and retrieve the zero weight value. The module works with edges represented as `Edge.t` and integer weights, typically used to model unweighted networks where each edge contributes equally to path calculations.",
      "description_length": 387,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.Topology.Net.Topology.Edge",
      "library": "frenetic.kernel",
      "description": "This module represents network edges as links between nodes, providing functions to serialize and deserialize edges to and from S-expressions, compare edges, convert edges to string or DOT format, and parse edges from DOT or GML attributes. It works with edge data structures used in network topology modeling, particularly in software-defined networking contexts. Concrete use cases include reading and writing network topologies in different formats for simulation, visualization, or configuration purposes.",
      "description_length": 509,
      "index": 8,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_kernel.Topology.Net.Topology.UnitWeight",
      "library": "frenetic.kernel",
      "description": "This module defines a weight type for edges in a network topology, where each edge has an integer weight. It provides functions to convert weights to and from S-expressions, compare weights, add them, and retrieve the zero value. It is used to represent and manipulate edge weights in routing or graph algorithms that require numerical metrics.",
      "description_length": 344,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.Net.Net.Topology.Edge",
      "library": "frenetic.kernel",
      "description": "This module represents network edges as links between nodes, providing functions to serialize and deserialize edges to and from S-expressions, compare edges, convert them to string or DOT format, and parse them from DOT or GML attribute lists. It works directly with edge data structures defined as `t`, which are built from `Frenetic_kernel.Net.Link.t`. It is used to model and manipulate network topologies in formats compatible with graph visualization and description tools like Graphviz and GML.",
      "description_length": 500,
      "index": 10,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.Network.Net.Topology.Vertex",
      "library": "frenetic.kernel",
      "description": "This module represents vertices in a network topology, providing functions to convert vertices to and from various formats like S-expressions, DOT, and GML. It includes operations for comparing vertices, converting them to strings, and parsing vertex data from graph description formats. Use cases include constructing and serializing network topologies for analysis, visualization, and integration with network simulation tools like Mininet.",
      "description_length": 442,
      "index": 11,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x01.Error.BadAction",
      "library": "frenetic.kernel",
      "description": "This module defines error codes for invalid actions in OpenFlow 1.0 messages, such as `BadType`, `BadLen`, and `BadOutPort`. It provides functions to convert these error values to and from S-expressions and to generate human-readable string representations. These errors are used to signal specific parsing or validation failures when processing OpenFlow action fields.",
      "description_length": 369,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.Topology.Net.Traverse",
      "library": "frenetic.kernel",
      "description": "Implements breadth-first and depth-first traversal algorithms over network topologies. Operates on graph structures defined by vertices, applying a given function to each vertex during traversal. Useful for analyzing connectivity, pathfinding, or network exploration tasks in software-defined networking applications.",
      "description_length": 317,
      "index": 13,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.Network.Make.Parse",
      "library": "frenetic.kernel",
      "description": "Converts network topologies from DOT or GML file formats into an internal representation. It operates on strings representing file paths and returns structured topology data. Useful for loading network designs from external configuration files into applications that process or simulate network behavior.",
      "description_length": 304,
      "index": 14,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_kernel.Packet.Dns.Rr",
      "library": "frenetic.kernel",
      "description": "This module defines DNS resource record operations for parsing and constructing DNS packet payloads. It works with the `t` type, which represents DNS records containing name, type, class, TTL, and raw data. Use this module to handle DNS response and query serialization in network applications or packet manipulation tools.",
      "description_length": 323,
      "index": 15,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.Net.Net.Traverse",
      "library": "frenetic.kernel",
      "description": "Implements breadth-first and depth-first traversal algorithms over network topologies. Operates on graph structures defined by vertices, applying a given function to each vertex during traversal. Useful for analyzing connectivity, pathfinding, or network exploration tasks in software-defined networking applications.",
      "description_length": 317,
      "index": 16,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.Net.Net.Pretty",
      "library": "frenetic.kernel",
      "description": "This module converts network topologies into string representations. It provides functions to generate human-readable text, Graphviz DOT format, and Mininet scripts from a topology. These outputs are used for visualization, debugging, and network simulation setup.",
      "description_length": 264,
      "index": 17,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x01.SwitchFeatures.Capabilities",
      "library": "frenetic.kernel",
      "description": "This module represents the capabilities advertised by an OpenFlow 1.0 switch, encoding each capability as a boolean field in a record. It provides functions to convert capability values to and from S-expressions and to generate human-readable string representations. These capabilities are used to determine switch support for features like flow statistics, port statistics, and STP.",
      "description_length": 383,
      "index": 18,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.Network.Make.Topology",
      "library": "frenetic.kernel",
      "description": "This module provides graph construction and manipulation capabilities for network topologies with typed vertices, edges, and ports. It supports operations like path analysis using unit-weighted graphs, directional edge queries, neighbor discovery, and functional transformations that produce new topology instances when modifying components. The implementation relies on set and hash structures for efficient element tracking, with serialization utilities enabling persistent storage or transmission of topology states.",
      "description_length": 519,
      "index": 19,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_kernel.Net.Net.Parse",
      "library": "frenetic.kernel",
      "description": "This module parses network topologies from file formats. It supports reading graphs in DOT and GML formats and converts them into topology structures. Use this module to load network configurations directly from disk for simulation or analysis tasks.",
      "description_length": 250,
      "index": 20,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x01.Error.HelloFailed",
      "library": "frenetic.kernel",
      "description": "This module defines error codes for failed Hello message exchanges in the OpenFlow 1.0 protocol. It includes two specific error variants: `Incompatible` for version mismatches and `Eperm` for unauthorized access attempts. These errors are used to signal issues during the initial handshake between OpenFlow switches and controllers.",
      "description_length": 332,
      "index": 21,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_kernel.Network.Net.Path",
      "library": "frenetic.kernel",
      "description": "This module computes shortest paths in a network topology using a specified weight type. It provides functions to find single or multiple shortest paths between vertices, returning paths as edge lists. Use cases include network routing analysis and optimizing packet forwarding in software-defined networks.",
      "description_length": 307,
      "index": 22,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.Network.Net.UnitPath",
      "library": "frenetic.kernel",
      "description": "This module computes shortest paths in a network topology using edge-weighted paths. It operates on network topologies represented as graphs with vertices and edges, where edge weights are integers. Functions include finding a single shortest path, all shortest paths between two vertices, and all pairs of shortest paths under a given condition.",
      "description_length": 346,
      "index": 23,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x01.Error.QueueOpFailed",
      "library": "frenetic.kernel",
      "description": "This module defines error codes for queue operation failures in OpenFlow 1.0, specifically `BadPort`, `BadQueue`, and `Eperm`. It provides functions to convert these errors to and from S-expressions and to produce human-readable string representations. Use this module when handling or reporting errors related to queue operations, such as invalid queue identifiers or permission issues.",
      "description_length": 387,
      "index": 24,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.Packet.Dns.Qd",
      "library": "frenetic.kernel",
      "description": "This module defines the DNS query section (Qd) of a DNS packet, containing fields for the domain name, query type, and class. It provides serialization and deserialization functions for converting Qd records to and from S-expressions. This module is used to manipulate DNS query data within packet processing workflows, such as parsing incoming DNS requests or constructing DNS response payloads.",
      "description_length": 396,
      "index": 25,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.Network.Make.UnitPath",
      "library": "frenetic.kernel",
      "description": "This module computes shortest paths in a network topology using edge-weighted graphs. It provides functions to find a single shortest path, all shortest paths from a source, and all pairs of shortest paths that satisfy a given predicate. The core data structures are lists of edges representing paths, with vertices and weights from the `Topology` module. Use cases include network routing analysis and optimizing paths in software-defined networks.",
      "description_length": 449,
      "index": 26,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_kernel.Packet.Igmp3.GroupRec",
      "library": "frenetic.kernel",
      "description": "This module defines operations for parsing and constructing IGMP v3 group records, specifically handling the record type, multicast group address, and source address list. It works with network addresses and integer types to represent and manipulate multicast group membership information. Concrete use cases include processing IGMPv3 reports for multicast routing and managing source-specific multicast subscriptions.",
      "description_length": 418,
      "index": 27,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.Network.Make.Traverse",
      "library": "frenetic.kernel",
      "description": "Implements breadth-first and depth-first traversal algorithms over network topologies. Operates on graph structures defined by the Topology module, visiting each vertex in a specified order. Useful for network analysis tasks such as path discovery, node classification, or fault detection in mesh networks.",
      "description_length": 306,
      "index": 28,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x01.SwitchConfig.FragFlags",
      "library": "frenetic.kernel",
      "description": "This module defines a type `t` representing fragmentation handling modes in OpenFlow 1.0 switch configuration. It includes functions to convert values to and from S-expressions and to obtain string representations. It is used to specify how a switch should handle fragmented packets, such as dropping them or reassembling them.",
      "description_length": 327,
      "index": 29,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x01.FlowRemoved.Reason",
      "library": "frenetic.kernel",
      "description": "This module defines the reason codes for flow removal notifications in OpenFlow 1.0. It provides conversions between reason codes, integers, and string representations. Use this module to interpret or generate flow removal events, such as when a flow expires due to inactivity or is explicitly deleted.",
      "description_length": 302,
      "index": 30,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x04.QueueDesc.QueueProp",
      "library": "frenetic.kernel",
      "description": "This module defines operations for handling queue property descriptions in OpenFlow 1.3.4. It supports parsing and marshaling queue property values to and from binary data, and provides a string representation for debugging. The module works directly with `queueProp` values and `Cstruct.t` buffers for serialization.",
      "description_length": 317,
      "index": 31,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.Topology.Net.Path",
      "library": "frenetic.kernel",
      "description": "This module computes shortest paths in a network topology, providing operations to find individual shortest paths, all shortest paths from a source, and all pairs shortest paths under customizable weight functions. It operates on network topologies composed of vertices and edges, using a user-defined weight type to determine path costs. Concrete use cases include routing optimization and network analysis where minimal cost paths between nodes are required.",
      "description_length": 460,
      "index": 32,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.Net.Net.Path",
      "library": "frenetic.kernel",
      "description": "This module computes shortest paths in network topologies using a specified weight type. It provides functions to find single or multiple shortest paths between vertices, returning paths as edge lists. Concrete use cases include routing optimization and network analysis where minimal cost paths are critical.",
      "description_length": 309,
      "index": 33,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x04.Hello.Element",
      "library": "frenetic.kernel",
      "description": "This module implements the Hello message element structure for OpenFlow 1.3.4, including operations to calculate the size of a Hello element, convert it to a string, and serialize or deserialize it using a Cstruct buffer. It works with the `element` type representing Hello elements, including the `VersionBitMap` substructure for handling supported version bitmaps. Concrete use cases include constructing and parsing Hello messages during OpenFlow handshake negotiation to determine protocol version compatibility.",
      "description_length": 516,
      "index": 34,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.Network.Net.Traverse",
      "library": "frenetic.kernel",
      "description": "Performs breadth-first and depth-first traversals over network topologies. Operates on graph structures defined by vertices, applying a function to each vertex during traversal. Useful for analyzing connectivity or propagating state across network nodes.",
      "description_length": 254,
      "index": 35,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow.Pattern.Ip",
      "library": "frenetic.kernel",
      "description": "This module represents and manipulates IP address patterns with associated subnet masks, supporting operations such as matching, comparison, union, and intersection. It works with IP addresses as `nwAddr` and 32-bit integers for subnet masks, enabling precise network packet filtering logic. Concrete use cases include defining flow table entries that match specific IP ranges, merging overlapping patterns, and checking compatibility between IP-based packet filters in OpenFlow switches.",
      "description_length": 488,
      "index": 36,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x01.PortDescription.PortConfig",
      "library": "frenetic.kernel",
      "description": "This module defines operations for converting port configuration values to and from string and 32-bit integer representations. It works with the `portConfig` type, which represents OpenFlow 1.0 port configuration flags. Use this module when encoding or decoding port configuration fields in OpenFlow messages, such as when configuring switch port behavior or interpreting port status updates.",
      "description_length": 392,
      "index": 37,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x01.PortStatus.ChangeReason",
      "library": "frenetic.kernel",
      "description": "This module defines the `t` type with values `Add`, `Delete`, and `Modify` to represent port status change reasons in OpenFlow 1.0 messages. It includes functions to convert between these values and S-expressions, and to obtain string representations of the values. This module is used to interpret or serialize the reason for a port status update received from a switch.",
      "description_length": 371,
      "index": 38,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.Network.Net.Pretty",
      "library": "frenetic.kernel",
      "description": "This module converts network topologies into string representations for visualization and simulation. It provides functions to generate human-readable strings, Graphviz DOT format, and Mininet scripts from a topology. Use cases include debugging network layouts, generating visual graphs, and creating Mininet test environments from defined topologies.",
      "description_length": 352,
      "index": 39,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x01.PortDescription.PortFeatures",
      "library": "frenetic.kernel",
      "description": "This module encodes and decodes OpenFlow 1.0 port feature flags to and from integer representations. It provides `of_int` and `to_int` for converting between 32-bit integers and structured port feature values, and `to_string` for human-readable string representations. It is used to interpret and manipulate port capabilities such as link speed and duplex mode in network switch configurations.",
      "description_length": 394,
      "index": 40,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.Network.Make.Pretty",
      "library": "frenetic.kernel",
      "description": "This module provides functions to generate string representations of network topologies. It works with the `Topology.t` data type to produce human-readable output in plain text, DOT format, and Mininet scripts. Use it to visualize or export network structures for debugging, documentation, or integration with network simulation tools.",
      "description_length": 335,
      "index": 41,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.Packet.Tcp.Flags",
      "library": "frenetic.kernel",
      "description": "This module defines a record type representing the 9 TCP header flags, such as `syn`, `ack`, and `fin`, each as a boolean. It provides functions to convert between this type and S-expressions for serialization and parsing. These values are used to construct or inspect TCP packet headers when handling network protocols or crafting custom packet data.",
      "description_length": 351,
      "index": 42,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x01.Error.BadRequest",
      "library": "frenetic.kernel",
      "description": "This module defines error codes for malformed OpenFlow 1.0 messages, including invalid versions, types, lengths, and unrecognized messages. It provides serialization and pretty-printing functions for these errors. Use cases include handling protocol mismatches, debugging message parsing failures, and logging invalid controller requests.",
      "description_length": 338,
      "index": 43,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_kernel.Packet.Ip.Flags",
      "library": "frenetic.kernel",
      "description": "This module represents the flags field in an IPv4 packet header, specifically the \"Don't Fragment\" (df) and \"More Fragments\" (mf) bits. It provides functions to convert the flags to and from S-expressions for serialization and parsing. Use this module when manipulating or inspecting IPv4 packet fragments in network applications.",
      "description_length": 330,
      "index": 44,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x01.PortDescription.PortState",
      "library": "frenetic.kernel",
      "description": "This module provides functions to convert port state values to and from strings and integers. It works with the `portState` type, which represents the operational state of a network port in OpenFlow 1.0. Use cases include serializing and deserializing port state information when processing OpenFlow port description messages.",
      "description_length": 326,
      "index": 45,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.Topology.Net.Pretty",
      "library": "frenetic.kernel",
      "description": "This module provides functions to convert network topologies into string representations. It supports generating human-readable strings, DOT format for visualization, and Mininet scripts for network simulation. The module works directly with `Frenetic_kernel.Topology.Net.Topology.t` values, enabling debugging, visualization, and integration with Mininet-based testing workflows.",
      "description_length": 380,
      "index": 46,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.Net.Net.UnitPath",
      "library": "frenetic.kernel",
      "description": "This module computes shortest paths in a network topology, providing functions to find individual shortest paths, all shortest paths from a source, and all pairs shortest paths with customizable filtering. It operates on graph structures represented by vertices and edges from the Topology module, with paths expressed as edge lists and weights as integers. Concrete use cases include network routing analysis, path optimization, and connectivity verification in software-defined networking scenarios.",
      "description_length": 501,
      "index": 47,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_kernel.Topology.Net.Topology",
      "library": "frenetic.kernel",
      "description": "This module provides graph-based operations for modeling network topologies, centered on vertices (nodes), edges (links), and ports (32-bit integers), with support for S-expression serialization, DOT/GML format conversion, and efficient collection management via sets and hashes. It enables tasks like adding or querying graph elements (e.g., ports, edges), retrieving neighbor nodes, counting edges, and iterating over components to support network analysis, visualization, and dynamic topology modification.",
      "description_length": 509,
      "index": 48,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x01.FlowMod.Command",
      "library": "frenetic.kernel",
      "description": "This module defines operations for converting flow modification commands to and from string and integer representations. It works with the `flowModCommand` type and 16-bit integers. Use cases include serializing commands for network transmission and parsing incoming integer codes into actionable command types.",
      "description_length": 311,
      "index": 49,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x01.Error.FlowModFailed",
      "library": "frenetic.kernel",
      "description": "This module defines error codes related to flow modification failures in OpenFlow 1.0, specifically handling cases like table overflow, overlapping entries, and invalid timeouts. It provides functions to convert error values to and from S-expressions and to produce human-readable string representations. These errors are used to signal specific failure conditions during flow table updates or modifications.",
      "description_length": 408,
      "index": 50,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x04.GroupStats.BucketStats",
      "library": "frenetic.kernel",
      "description": "This module provides functions to handle bucket statistics in OpenFlow 1.3.4, including parsing, marshaling, string representation, and size calculation. It operates on the `bucketStats` type, representing statistics for individual buckets within a group. Concrete use cases include processing and serializing bucket statistics received from switches for monitoring and network management.",
      "description_length": 389,
      "index": 51,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x01.Error.PortModFailed",
      "library": "frenetic.kernel",
      "description": "This module defines error codes for port modification failures in OpenFlow 1.0, specifically `BadPort` and `BadHwAddr`. It provides functions to convert these errors to and from S-expressions and to generate human-readable string representations. Use this module when handling or reporting errors related to invalid port configurations or hardware addresses in OpenFlow control plane logic.",
      "description_length": 390,
      "index": 52,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.Net.Net.Topology",
      "library": "frenetic.kernel",
      "description": "This module enables the manipulation of network topologies through graph structures where vertices represent nodes and edges model port-connected links. It provides functionality for constructing, transforming, and querying these graphs using sets of vertices, edges, and ports, along with weighted connections and hashable identifiers. Applications include network simulation, visualization, and algorithm development, with support for traversal, edge inversion, and serialization to formats such as DOT and GML.",
      "description_length": 513,
      "index": 53,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.Topology.Net.UnitPath",
      "library": "frenetic.kernel",
      "description": "This module computes shortest paths in a network topology, providing functions to find individual paths, collections of paths from a source, and all pairs of shortest paths. It operates on edge lists representing paths, with vertices and edges defined in the associated topology module. Concrete use cases include determining optimal routes between network nodes and analyzing connectivity in graph structures.",
      "description_length": 410,
      "index": 54,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.Topology.Net.Parse",
      "library": "frenetic.kernel",
      "description": "This module provides functions to parse network topologies from DOT and GML file formats. It directly works with string file paths and constructs a `Topology.t` data structure representing the network. Concrete use cases include loading predefined network layouts for simulation or analysis from external configuration files.",
      "description_length": 325,
      "index": 55,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.Network.Make.Path",
      "library": "frenetic.kernel",
      "description": "This module computes shortest paths in a network topology using a specified weight type. It provides functions to find the shortest path between two vertices, all shortest paths from a source vertex, and all pairs of shortest paths in the topology. The module works directly with edge lists, vertices, and a weight structure to support concrete routing and network analysis tasks.",
      "description_length": 380,
      "index": 56,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.Network.Net.Parse",
      "library": "frenetic.kernel",
      "description": "This module provides functions to parse network topologies from DOT and GML file formats. It converts string representations of network graphs into structured topology data used for network modeling. These functions are used when loading predefined network layouts for simulation or analysis tasks.",
      "description_length": 298,
      "index": 57,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x01.SwitchFeatures.SupportedActions",
      "library": "frenetic.kernel",
      "description": "This module represents the set of actions supported by an OpenFlow 1.0 switch, with each field indicating support for a specific action such as packet output, VLAN modification, or transport port changes. It provides functions to convert between the type and S-expressions for serialization, along with a pretty-printing function for debugging and logging. Use this module to query or configure switch capabilities in control plane logic, such as determining whether a switch can modify source or destination addresses.",
      "description_length": 519,
      "index": 58,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x04.QueueConfReply",
      "library": "frenetic.kernel",
      "description": "This module defines the structure and operations for handling OpenFlow 1.3.4 Queue Configuration Reply messages. It provides functions to compute the size of a message, convert it to a string, and serialize or parse it using a Cstruct buffer. Use this module when implementing or interacting with OpenFlow control plane logic that queries or configures port queue settings.",
      "description_length": 373,
      "index": 59,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.Packet.Igmp3",
      "library": "frenetic.kernel",
      "description": "This module represents IGMP v3 messages, containing a checksum and a list of group records. It provides functions for converting between a structured representation and S-expressions. Use it to parse and construct IGMPv3 reports for handling multicast group membership and source-specific subscriptions.",
      "description_length": 303,
      "index": 60,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x01.PacketOut",
      "library": "frenetic.kernel",
      "description": "Handles the construction and serialization of OpenFlow 1.0 packet-out messages. Works with `packetOut` structures that specify switch actions and buffer identifiers. Used to format and send precise packet forwarding instructions from a controller to an OpenFlow switch.",
      "description_length": 269,
      "index": 61,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x04.Instructions",
      "library": "frenetic.kernel",
      "description": "This module handles OpenFlow 1.3 instructions, providing operations to serialize, deserialize, and convert instruction lists. It works with lists of OpenFlow instructions and supports parsing from and marshaling to Cstruct buffers. Concrete use cases include processing flow modification messages and converting group references into instruction sequences for switch configuration.",
      "description_length": 381,
      "index": 62,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x01.SwitchFeatures",
      "library": "frenetic.kernel",
      "description": "This module defines data structures and serialization functions for OpenFlow 1.0 switch features, including supported wildcards, capabilities, and actions. It works with records representing switch identifiers, buffer counts, table counts, port descriptions, and boolean flags for feature support. Use this module to parse, serialize, and inspect switch capabilities and supported actions during control plane setup or logging.",
      "description_length": 427,
      "index": 63,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x04.MeterBand",
      "library": "frenetic.kernel",
      "description": "This module defines operations for working with OpenFlow 1.3.4 meter bands, including parsing from and marshaling to Cstruct buffers. It provides the size of a meter band structure, pretty-printing to strings, and direct serialization for network transmission. Concrete use cases include configuring rate limiting and traffic metering in software-defined networking applications.",
      "description_length": 379,
      "index": 64,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x04.Hello",
      "library": "frenetic.kernel",
      "description": "This module handles Hello messages in the OpenFlow 1.3.4 protocol, providing functions to calculate the size of a Hello message, convert it to a string, and serialize or deserialize it using a Cstruct buffer. It operates on the `t` type representing Hello messages, which include Hello elements such as version bitmaps. Concrete use cases include parsing and constructing Hello messages during the initial handshake between an OpenFlow switch and controller to negotiate protocol versions.",
      "description_length": 489,
      "index": 65,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x04.MeterFeatures",
      "library": "frenetic.kernel",
      "description": "This module handles parsing, marshaling, and string representation of OpenFlow 1.3.4 meter features structures. It operates on the `meterFeatures` type, which describes capabilities and limits of metering in OpenFlow switches. Use this module to serialize meter features for transmission, deserialize them from raw data, or inspect their contents in a human-readable format.",
      "description_length": 374,
      "index": 66,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x01.FlowRemoved",
      "library": "frenetic.kernel",
      "description": "This module handles flow removal messages in OpenFlow 1.0, providing functions to parse, marshal, and convert flow removal data to strings. It works with the `flowRemoved` type, which includes details like reason codes (via the `Reason` submodule), cookie values, and packet counts. Use it to process or generate notifications when flows are removed from a switch, such as tracking expired flows or auditing flow deletions.",
      "description_length": 423,
      "index": 67,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.Topology.Net",
      "library": "frenetic.kernel",
      "description": "This module models network topologies using graph structures with vertices, edges, and 32-bit integer ports, supporting operations such as adding and querying graph elements, computing spanning trees, and finding shortest paths with customizable weights. It includes traversal algorithms for connectivity analysis, pathfinding, and network exploration, along with serialization, parsing, and visualization tools for DOT, GML, and Mininet formats. Concrete use cases include routing optimization, network simulation, and dynamic topology analysis in software-defined networking environments.",
      "description_length": 590,
      "index": 68,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.Network.NetPath",
      "library": "frenetic.kernel",
      "description": "This module computes shortest paths and collections of shortest paths in a network topology. It operates on weighted edges and vertices, using lists of edges to represent paths. Functions support finding a single shortest path, all shortest paths between two vertices, and all pairs of shortest paths in a topology, with optional filtering on vertex pairs.",
      "description_length": 356,
      "index": 69,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x04.PortStatus",
      "library": "frenetic.kernel",
      "description": "This module handles the serialization, deserialization, and string representation of OpenFlow 1.3.4 port status messages. It operates on the `portStatus` type, which captures events like port additions, removals, and state changes. Use this module to process port status updates from switches, convert them to and from binary format for transmission, or log them as human-readable strings.",
      "description_length": 389,
      "index": 70,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x01.FlowMod",
      "library": "frenetic.kernel",
      "description": "This module handles flow modification messages in the OpenFlow 1.0 protocol. It provides functions to serialize, deserialize, and manipulate flow entries, including operations for adding, removing, and modifying flows on a switch. The module works with the `flowMod` type, which represents flow modification messages, and integrates with buffer handling via `Cstruct.t`.",
      "description_length": 370,
      "index": 71,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x04.SwitchFeatures",
      "library": "frenetic.kernel",
      "description": "This module handles the Switch Features structure as defined in the OpenFlow 1.3.4 specification. It provides operations to serialize, deserialize, and convert switch feature data to a string representation. The module works directly with the `switchFeatures` type and uses `Cstruct.t` for low-level memory manipulation, enabling interaction with network data buffers.",
      "description_length": 368,
      "index": 72,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x04.MeterConfig",
      "library": "frenetic.kernel",
      "description": "This module defines operations for handling OpenFlow 1.3.4 meter configurations. It provides parsing, marshaling, size calculation, and string representation for meter configuration structures. It works directly with `Cstruct.t` and the `meterConfig` type, enabling efficient serialization and deserialization for network transmission and debugging.",
      "description_length": 349,
      "index": 73,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x01.Wildcards",
      "library": "frenetic.kernel",
      "description": "This module handles bitmask operations for OpenFlow 1.0 wildcard fields. It converts wildcard values to and from 32-bit integers and provides string representations. It is used to encode and decode flow entry match conditions during communication with OpenFlow switches.",
      "description_length": 270,
      "index": 74,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x01.Match",
      "library": "frenetic.kernel",
      "description": "This module handles pattern matching for OpenFlow 1.0 messages, providing functions to convert patterns to strings, marshal and parse patterns from binary structures, and calculate their size. It operates on the `pattern` type representing OpenFlow match fields. Concrete use cases include processing and filtering network traffic based on specific header fields or packet attributes in software-defined networking applications.",
      "description_length": 428,
      "index": 75,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.Net.Node",
      "library": "frenetic.kernel",
      "description": "This module defines a concrete type `t` representing network nodes and provides bidirectional conversion between this type and S-expressions via `t_of_sexp` and `sexp_of_t`. It is used to serialize and deserialize node data for storage or communication, particularly in network configuration and packet processing contexts.",
      "description_length": 323,
      "index": 76,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x04.Error",
      "library": "frenetic.kernel",
      "description": "This module defines operations for handling OpenFlow error messages, including parsing, marshaling, and pretty-printing. It works with the `error` type, which represents structured OpenFlow error data. Concrete use cases include decoding error responses from switches, encoding error messages for controller communication, and generating human-readable error summaries for debugging network events.",
      "description_length": 398,
      "index": 77,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x04.FlowModCommand",
      "library": "frenetic.kernel",
      "description": "This module defines the structure and operations for modifying flow entries in OpenFlow 1.3.4. It provides functions to calculate the size of a flow modification command, serialize it to a buffer, parse it from a buffer, and convert it to a human-readable string. It works directly with the `flowModCommand` type, representing OpenFlow flow modification messages, and is used for managing flow table entries in software-defined networking.",
      "description_length": 439,
      "index": 78,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x04.TableFeatureProp",
      "library": "frenetic.kernel",
      "description": "This module handles the serialization, parsing, and string representation of OpenFlow 1.3.4 Table Feature Property structures. It operates directly on `Cstruct.t` and `Frenetic_kernel.OpenFlow0x04.TableFeatureProp.t` types. Use it when working with OpenFlow table feature negotiations, such as when configuring switch capabilities or processing feature replies.",
      "description_length": 361,
      "index": 79,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x01.PseudoPort",
      "library": "frenetic.kernel",
      "description": "This module represents pseudo-ports in OpenFlow 1.0, which are special identifiers for switch ports that do not correspond to physical interfaces. It provides `to_string` to convert pseudo-port identifiers to human-readable strings, `marshal` to serialize them into integer codes, and `make` to construct pseudo-port values from integers. These operations support handling virtual port logic in switch management and packet processing tasks.",
      "description_length": 441,
      "index": 80,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x01.Vendor",
      "library": "frenetic.kernel",
      "description": "This module represents OpenFlow VENDOR messages as a 32-bit vendor identifier paired with raw payload data. It provides parsing and serialization functions to convert between Cstruct buffers and the vendor message structure. Use this module to handle vendor-specific extensions in OpenFlow 1.0 switches, such as interpreting or constructing messages for custom hardware features.",
      "description_length": 379,
      "index": 81,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_kernel.Packet.Ip",
      "library": "frenetic.kernel",
      "description": "This module represents IPv4 packet headers, including fields like source and destination IP addresses, time-to-live (TTL), and transport layer payloads such as TCP, UDP, or ICMP. It provides functions to serialize and deserialize IPv4 headers to and from S-expressions, enabling easy parsing and reconstruction of network packets. Use this module when handling raw IPv4 packets in network monitoring, packet modification, or custom routing applications.",
      "description_length": 453,
      "index": 82,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x04.FlowMod",
      "library": "frenetic.kernel",
      "description": "This module defines operations for working with OpenFlow 1.3.4 flow modification messages. It provides functions to calculate the size of a flow modification message, serialize it to a buffer, parse it from a buffer, and convert it to a human-readable string. These operations are used when constructing, transmitting, and inspecting flow table updates in software-defined networking applications.",
      "description_length": 397,
      "index": 83,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_kernel.Packet.Igmp1and2",
      "library": "frenetic.kernel",
      "description": "This module defines the structure and operations for handling IGMP v1 and v2 messages. It provides functions to serialize and deserialize the `t` type, which includes fields for maximum response time, checksum, and group address. It is used to process and manipulate IGMP message payloads in network packet handling scenarios.",
      "description_length": 326,
      "index": 84,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x04.RoleRequest",
      "library": "frenetic.kernel",
      "description": "This module defines the structure and operations for handling OpenFlow Role Request messages. It provides functions to calculate the size of a message, convert it to a string, and serialize or deserialize it using Cstruct buffers. These operations are used when implementing or interacting with OpenFlow 1.3.4 role management features, such as negotiating controller roles during switch connection setup.",
      "description_length": 404,
      "index": 85,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x04.OfpMatch",
      "library": "frenetic.kernel",
      "description": "This module defines operations for handling OpenFlow 1.3.4 match structures, which represent packet header fields used for flow classification. It provides functions to calculate the size of a match structure, serialize it to a buffer, parse it from a buffer, and convert it to a human-readable string. These operations are used when constructing or interpreting flow entries in an OpenFlow switch.",
      "description_length": 398,
      "index": 86,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.Hashcons.Make",
      "library": "frenetic.kernel",
      "description": "This module implements hash-consing for a given value type, ensuring that equal values share the same physical representation. It provides operations to retrieve a unique integer key for a value (`get`), recover the value from its key (`unget`), and clear entries associated with a set of keys (`clear`). It is useful in scenarios like symbolic computation or AST manipulation where value deduplication improves performance and memory efficiency.",
      "description_length": 446,
      "index": 87,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x04.MultipartReq",
      "library": "frenetic.kernel",
      "description": "This module defines the structure and operations for handling OpenFlow 1.3.4 multipart request messages. It provides functions to calculate the size of a request, convert it to a string, and serialize or deserialize it using Cstruct buffers. Concrete use cases include constructing and parsing multipart requests like flow stats or port stats queries in an OpenFlow controller.",
      "description_length": 377,
      "index": 88,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x01.PortDescription",
      "library": "frenetic.kernel",
      "description": "This module serializes and deserializes OpenFlow 1.0 port description messages using `parse`, `marshal`, and `to_string`. It works with the `portDescription` type, which contains port configuration, state, and feature data. Use it to process and generate port description payloads in OpenFlow switch communication.",
      "description_length": 314,
      "index": 89,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_kernel.Packet.Dns",
      "library": "frenetic.kernel",
      "description": "This module defines DNS packet structures and operations for parsing, serializing, and constructing DNS messages. It works with DNS packet components including query sections (Qd), resource records (Rr), and packet headers with fields like ID, flags, and question/answer lists. Use this module to build or analyze DNS payloads for network monitoring tools, custom DNS servers, or packet injection utilities.",
      "description_length": 407,
      "index": 90,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x04.PortMod",
      "library": "frenetic.kernel",
      "description": "This module defines operations for working with OpenFlow PortMod messages, including parsing from and marshaling to Cstruct buffers. It handles the `t` type representing PortMod structures, providing serialization, deserialization, and string formatting. Use this module when modifying port configurations in OpenFlow 1.3.4 switches, such as updating port properties or status.",
      "description_length": 377,
      "index": 91,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x04.GroupDesc",
      "library": "frenetic.kernel",
      "description": "This module handles parsing, marshaling, and string representation of OpenFlow 1.3.4 group description structures. It operates on the `t` type representing group descriptions and supports serialization to and from memory buffers via `Cstruct.t`. Use this module when implementing OpenFlow control plane logic that requires inspecting or transmitting group table entries.",
      "description_length": 370,
      "index": 92,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.Topology.Mininet",
      "library": "frenetic.kernel",
      "description": "This module defines functions to construct network topologies from symbolic representations, converting them into concrete network structures used for simulation or testing. It supports topology types like trees, linear chains, single switches, and minimal configurations, each parameterized by size or complexity. Direct use cases include generating test networks for SDN controllers or evaluating network algorithms under controlled topological conditions.",
      "description_length": 458,
      "index": 93,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.Packet.Icmp",
      "library": "frenetic.kernel",
      "description": "This module defines the structure and operations for handling ICMP packets, including fields for type, code, checksum, and payload. It provides functions to serialize and deserialize ICMP packet data using S-expressions. Concrete use cases include parsing and constructing ICMP messages for network communication and diagnostics, such as echo requests and error reporting.",
      "description_length": 372,
      "index": 94,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x04.GroupMod",
      "library": "frenetic.kernel",
      "description": "This module defines operations for encoding, decoding, and manipulating OpenFlow 1.3.4 Group Modify messages. It works with the `groupMod` type, which represents group table modification commands, and uses `Cstruct.t` for low-level byte buffer handling. Concrete use cases include serializing group modification requests to send over the network and parsing incoming group modification messages from switches.",
      "description_length": 409,
      "index": 95,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x04.SwitchConfig",
      "library": "frenetic.kernel",
      "description": "This module defines the structure and operations for handling OpenFlow 1.3.4 switch configuration data. It provides functions to serialize (`marshal`), deserialize (`parse`), compute the size (`sizeof`), and convert to a string representation (`to_string`) of switch configuration values. It directly works with the `switchConfig` type and is used in network control applications to manage switch behavior according to the OpenFlow protocol.",
      "description_length": 441,
      "index": 96,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x04.GroupFeatures",
      "library": "frenetic.kernel",
      "description": "This module handles parsing and serializing the OpenFlow 1.3.4 Group Features structure, which includes capabilities and maximum values for group types. It works directly with the `groupFeatures` type and `Cstruct.t` for binary representation. Use this module to convert between in-memory structures and their wire format for OpenFlow group feature negotiation.",
      "description_length": 361,
      "index": 97,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_kernel.Net.Net",
      "library": "frenetic.kernel",
      "description": "This module provides operations for building, analyzing, and visualizing network topologies using graph structures where vertices represent network nodes and edges model port-connected links. It supports concrete tasks such as computing spanning trees, finding shortest paths with customizable weights, and performing breadth-first or depth-first traversals for connectivity analysis. Additional functionality includes parsing topologies from DOT and GML files, generating visualizations in Graphviz format, and exporting Mininet scripts for network simulation.",
      "description_length": 561,
      "index": 98,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x04.FlowRemoved",
      "library": "frenetic.kernel",
      "description": "This module defines operations for handling OpenFlow 1.3.4 Flow Removed messages, specifically supporting serialization, deserialization, and string representation. It works with the `flowRemoved` type, which captures metadata about flows that have been removed from a switch. Use cases include processing flow expiration notifications and generating human-readable or network-ready representations of these events for logging or control plane updates.",
      "description_length": 452,
      "index": 99,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x01.Action",
      "library": "frenetic.kernel",
      "description": "This module defines operations for manipulating OpenFlow 1.0 action sequences, including moving controller-bound actions to the end of a sequence to ensure compatibility with OpenFlow switches. It provides functions for serializing, parsing, and converting actions to strings, working directly with `action` and `sequence` types. Use cases include preparing action lists for packet processing and debugging through string representation.",
      "description_length": 437,
      "index": 100,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x04.MeterMod",
      "library": "frenetic.kernel",
      "description": "This module defines the structure and operations for modifying meter entries in OpenFlow 1.3.4. It provides functions to calculate the size of a meter modification message, convert it to a string for debugging, and serialize or deserialize it for network transmission. It works directly with the `meterMod` type representing OpenFlow meter configurations.",
      "description_length": 355,
      "index": 101,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x04.MeterStats",
      "library": "frenetic.kernel",
      "description": "This module handles Meter Statistics structures as defined in the OpenFlow 1.3.4 specification. It provides operations to calculate the size of a Meter Statistics instance, convert it to a string for debugging, and serialize or deserialize it using Cstruct buffers. These functions are used when managing OpenFlow meter statistics in network control applications.",
      "description_length": 363,
      "index": 102,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x04.AggregateStats",
      "library": "frenetic.kernel",
      "description": "This module handles aggregate flow statistics in OpenFlow 1.3.4, providing operations to serialize, deserialize, and display statistics data. It works with the `aggregStats` type, which captures flow count, packet, and byte totals. Use this module to process and format aggregate statistics responses from switches.",
      "description_length": 315,
      "index": 103,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x01.StatsRequest",
      "library": "frenetic.kernel",
      "description": "This module handles OpenFlow 1.0 statistics requests, including parsing and serializing messages for switch statistics like flow tables, ports, and queues. It defines operations to convert request messages to and from S-expressions and string representations. Concrete use cases include querying flow statistics to monitor network traffic or retrieving port counters for performance analysis.",
      "description_length": 392,
      "index": 104,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow.To0x01",
      "library": "frenetic.kernel",
      "description": "This module translates high-level OpenFlow actions, flows, and events into their OpenFlow 1.0 equivalents. It handles conversions for data types such as patterns, actions, flow modifications, switch features, and packet operations. Concrete use cases include compiling Frenetic-defined flows into OpenFlow 1.0 messages for switches that do not support OpenFlow 1.3, ensuring compatibility while preserving intended network behavior.",
      "description_length": 432,
      "index": 105,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.Network.Link",
      "library": "frenetic.kernel",
      "description": "This module represents network links with operations to construct, serialize, and manipulate link attributes such as cost, capacity, and weight. It works with a concrete type `t` representing a network link, supporting parsing from formats like DOT and GML, and conversion to string and S-expression representations. Concrete use cases include modeling network topologies, configuring link metrics for routing simulations, and persisting link data in graph formats.",
      "description_length": 465,
      "index": 106,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x04.SwitchDescriptionReply",
      "library": "frenetic.kernel",
      "description": "This module handles parsing and serializing OpenFlow switch description replies, specifically working with the `switchDesc` type to represent switch metadata. It provides functions to calculate the size of a message, convert it to a string, and marshal or parse it from a buffer. Use this when implementing control plane logic that needs to process switch capabilities and features during OpenFlow handshake or monitoring.",
      "description_length": 422,
      "index": 107,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.Network.Net",
      "library": "frenetic.kernel",
      "description": "This module implements network topology manipulation and analysis through graph operations. It provides functions for parsing and serializing network graphs, computing spanning trees and shortest paths, and traversing vertices using breadth-first and depth-first strategies. Concrete use cases include modeling software-defined networks, optimizing routing paths, and generating Mininet testbeds from graph specifications.",
      "description_length": 422,
      "index": 108,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x04.AsyncConfig",
      "library": "frenetic.kernel",
      "description": "This module defines the structure and operations for handling asynchronous configuration messages in the OpenFlow 1.3.4 protocol. It provides functions to serialize (`marshal`), deserialize (`parse`), compute the size (`sizeof`), and convert to a string representation (`to_string`) of asynchronous configuration data. These operations are used when configuring how OpenFlow switches notify controllers of events like packet arrivals or flow changes.",
      "description_length": 450,
      "index": 109,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x04.PacketIn",
      "library": "frenetic.kernel",
      "description": "This module defines the structure and operations for handling OpenFlow 1.3.4 PacketIn messages, which represent packets received by a switch and forwarded to the controller. It provides functions to parse and serialize PacketIn values to and from binary buffers, compute their size, and convert them to human-readable strings. It works directly with the `Cstruct.t` type for binary data manipulation and the `t` type representing a parsed PacketIn message.",
      "description_length": 456,
      "index": 110,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x04.FlowRequest",
      "library": "frenetic.kernel",
      "description": "This module defines operations for handling OpenFlow 1.3.4 flow statistics requests. It provides functions to calculate the size of a request, convert it to a string, and serialize or deserialize it using Cstruct buffers. These operations are used when querying flow statistics in network monitoring and SDN controller implementations.",
      "description_length": 335,
      "index": 111,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x01.SwitchConfig",
      "library": "frenetic.kernel",
      "description": "This module represents OpenFlow 1.0 switch configuration data, containing a fragmentation handling mode and a packet truncation length. It supports parsing and serialization via S-expressions and generates string representations of configuration values. Used to define how switches process fragmented packets and how much packet data to send to controllers.",
      "description_length": 357,
      "index": 112,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x04.QueueRequest",
      "library": "frenetic.kernel",
      "description": "This module handles the serialization, parsing, and string representation of OpenFlow 1.3.4 Queue Statistics requests. It operates on the `t` type, which represents a queue request structure as defined in the specification. Use this module to encode queue statistics requests into a byte buffer, decode them from a buffer, or generate human-readable output for debugging.",
      "description_length": 371,
      "index": 113,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x04.Action",
      "library": "frenetic.kernel",
      "description": "This module handles OpenFlow 1.3.4 action structures, providing serialization, deserialization, and conversion from generic OpenFlow actions. It works with the `action` and `actionSequence` types, representing individual actions and sequences of actions. Use cases include constructing and manipulating packet-forwarding instructions in software-defined networking applications.",
      "description_length": 378,
      "index": 114,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow.Pattern",
      "library": "frenetic.kernel",
      "description": "This module represents and manipulates OpenFlow packet match patterns, supporting operations such as matching, comparison, and joining of patterns based on their field constraints. It works with structured packet fields including Ethernet addresses, VLAN tags, IP addresses (via the `Ip` submodule), transport ports, and input ports, enabling precise packet classification logic. Concrete use cases include defining flow table entries that match specific traffic, merging overlapping match conditions, and determining pattern inclusion for efficient rule compilation targeting OpenFlow 1.0 or 1.3.",
      "description_length": 597,
      "index": 115,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x04.Message",
      "library": "frenetic.kernel",
      "description": "This module defines a variant type representing OpenFlow 1.3 messages, including control, configuration, and data plane operations. It provides functions for serializing and deserializing messages, computing their size, converting to human-readable strings, and extracting or constructing message headers. Concrete use cases include handling switch communication, flow table updates, packet processing, and error reporting in software-defined networking.",
      "description_length": 454,
      "index": 116,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x04.PortStats",
      "library": "frenetic.kernel",
      "description": "This module handles port statistics in the OpenFlow 1.3.4 protocol. It provides functions to calculate the size of a port statistics structure, convert it to a string for debugging, and serialize or deserialize it using Cstruct buffers. These operations are used when retrieving and processing port-level traffic metrics from OpenFlow switches.",
      "description_length": 344,
      "index": 117,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x04.QueueDesc",
      "library": "frenetic.kernel",
      "description": "This module handles queue description structures defined in OpenFlow 1.3.4, providing operations to parse and marshal queue descriptions to and from binary data. It works with `queueDesc` values and `Cstruct.t` buffers for efficient serialization. Concrete use cases include processing queue configuration messages in OpenFlow switches and controllers.",
      "description_length": 352,
      "index": 118,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x01.Timeout",
      "library": "frenetic.kernel",
      "description": "This module defines operations for working with OpenFlow 1.0 timeout values, including converting timeouts to and from integers and strings. It handles the `timeout` type, which represents duration values used in OpenFlow protocol messages. Use cases include encoding and decoding timeout fields in OpenFlow packets, such as those used in flow entry expiration notifications.",
      "description_length": 375,
      "index": 119,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x04.FlowStats",
      "library": "frenetic.kernel",
      "description": "This module handles flow statistics in OpenFlow 1.3.4, providing operations to parse, marshal, and convert flow statistics data to a string. It works with the `t` type representing individual flow statistics, including fields like match, priority, and counters. Use this module to process and serialize flow statistics messages in network monitoring and control applications.",
      "description_length": 375,
      "index": 120,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x04.TableMod",
      "library": "frenetic.kernel",
      "description": "This module defines operations for working with OpenFlow 1.3.4 Table Modify messages, including parsing from and marshaling to Cstruct buffers. It provides the size of a Table Modify message, converts it to a human-readable string, and serializes or deserializes the message for network transmission. Concrete use cases include constructing and interpreting OpenFlow control messages to configure switch table behavior, such as setting table IDs and configuration flags.",
      "description_length": 470,
      "index": 121,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x04.TableFeature",
      "library": "frenetic.kernel",
      "description": "This module handles the serialization, deserialization, and representation of OpenFlow 1.3.4 table feature structures. It provides functions to calculate the size of a table feature, convert it to and from a Cstruct buffer, and generate a human-readable string representation. These operations are essential when configuring switch table capabilities during OpenFlow handshake or feature negotiation.",
      "description_length": 400,
      "index": 122,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x04.TableStats",
      "library": "frenetic.kernel",
      "description": "This module handles table statistics in OpenFlow 1.3.4, providing operations to serialize, deserialize, and display table statistics data. It works with the `t` type representing OpenFlow table statistics, and uses `Cstruct.t` for binary parsing and marshaling. Concrete use cases include processing and generating table statistics messages in network switches or controllers.",
      "description_length": 376,
      "index": 123,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x01.Message",
      "library": "frenetic.kernel",
      "description": "This module defines and manipulates OpenFlow 1.0 message types such as Hello, ErrorMsg, FlowModMsg, and PacketInMsg, along with serialization, parsing, and size calculation operations. It works with data types including Cstruct.t for raw data buffers and various OpenFlow-specific types like Error.t, SwitchFeatures.t, and packetIn. Concrete use cases include constructing FlowMod messages to install switch rules, parsing incoming PacketIn events for packet processing, and serializing EchoRequests for liveness checks.",
      "description_length": 520,
      "index": 124,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow.From0x01",
      "library": "frenetic.kernel",
      "description": "Translates OpenFlow 1.0 actions, switch features, messages, port stats, and flow stats into the unified OpenFlow interface. Converts low-level 1.0 structures to their generalized counterparts for use in higher-level flow processing. Enables handling of OpenFlow 1.0 switches within a system that also supports OpenFlow 1.3 features.",
      "description_length": 332,
      "index": 125,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.Network.Node",
      "library": "frenetic.kernel",
      "description": "This module defines a type `t` representing network nodes with attributes such as name, ID, device type (switch, host, middlebox), MAC address, and IP address. It provides functions to create and access node properties, along with serialization to and from S-expressions, DOT format, and GML. Use cases include modeling network topologies for simulation, generating Mininet configurations, and parsing graph descriptions from external formats.",
      "description_length": 443,
      "index": 126,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x04.Instruction",
      "library": "frenetic.kernel",
      "description": "This module defines operations for handling OpenFlow 1.3.4 flow instructions, including parsing, marshaling, and string representation. It works directly with the `instruction` type and Cstruct buffers for binary encoding and decoding. Use this module when implementing or manipulating flow entries in an OpenFlow switch, such as applying actions or modifying packet processing behavior.",
      "description_length": 387,
      "index": 127,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x04.GroupType",
      "library": "frenetic.kernel",
      "description": "This module defines the group types used in OpenFlow 1.3.4, corresponding to the `ofp_group_type` enumeration. It provides functions to convert group types to human-readable strings, marshal them to integers, and parse integers back into group types. These operations are essential for handling group table entries in software-defined networking applications that implement the OpenFlow protocol.",
      "description_length": 396,
      "index": 128,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x04.Bucket",
      "library": "frenetic.kernel",
      "description": "This module defines operations for working with OpenFlow bucket structures used in group tables. It provides functions to calculate the size of a bucket, convert it to a string, and serialize or deserialize it using Cstruct. These operations are essential for implementing and managing group-based flow rules in OpenFlow 1.3.4 switches.",
      "description_length": 336,
      "index": 129,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_kernel.Packet.Igmp",
      "library": "frenetic.kernel",
      "description": "This module represents and manipulates IGMP (Internet Group Management Protocol) frames within network packets. It defines types for IGMP messages (version 1, 2, and 3) and provides serialization and deserialization functions for working with these messages in memory or during packet inspection. It is used when handling multicast group membership queries and reports in network monitoring or SDN applications.",
      "description_length": 411,
      "index": 130,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.Network.Make",
      "library": "frenetic.kernel",
      "description": "This module implements network topology construction, traversal, and analysis with typed vertices and edges. It provides path computation with customizable weights, spanning tree generation, and serialization for network graphs. Use it to model software-defined networks, optimize routing paths, or analyze connectivity in mesh topologies.",
      "description_length": 339,
      "index": 131,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x04.PortConfig",
      "library": "frenetic.kernel",
      "description": "This module defines bit flags for port configuration in OpenFlow 1.3.4, corresponding directly to the `ofp_port_config` enumeration. It provides functions to marshal and parse these flags to and from 32-bit integers, and to convert them into human-readable strings. These operations are used when configuring or inspecting switch port settings, such as disabling a port or enabling promiscuous mode.",
      "description_length": 399,
      "index": 132,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x04.PortState",
      "library": "frenetic.kernel",
      "description": "This module defines the `t` type representing OpenFlow 1.3.4 port state values, such as `OFPPS_LINK_DOWN` or `OFPPS_BLOCKED`. It provides functions to convert port states to and from 32-bit integers (`marshal` and `parse`) and to generate human-readable string representations (`to_string`). These operations are used when handling port status messages or configuring switch port behavior in OpenFlow-based applications.",
      "description_length": 420,
      "index": 133,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x04.PortDesc",
      "library": "frenetic.kernel",
      "description": "This module defines operations for handling OpenFlow 1.3.4 port description structures. It provides functions to calculate the size of a port description, serialize it to a buffer, parse it from a buffer, and convert it to a human-readable string. These operations are used when managing switch port information in OpenFlow control plane implementations.",
      "description_length": 354,
      "index": 134,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x04.PseudoPort",
      "library": "frenetic.kernel",
      "description": "This module defines operations for working with OpenFlow 1.3 pseudo-port values, including creating pseudo-port instances from raw integer values, converting them to human-readable strings, and serializing them to 32-bit integers. It directly manipulates the `pseudoPort` type, which represents virtual ports in OpenFlow switch configurations. Concrete use cases include handling packet-in events and constructing flow entries that reference special ports like the controller or local switch ports.",
      "description_length": 498,
      "index": 135,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x04.QueueConfReq",
      "library": "frenetic.kernel",
      "description": "This module defines the structure and operations for handling OpenFlow 1.3.4 Queue Configuration request messages. It provides functions to calculate the size of a request, convert it to a string for debugging, and serialize or parse the message from a buffer. These operations directly work with the `queueConfReq` type and network buffers represented as `Cstruct.t`.",
      "description_length": 368,
      "index": 136,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.Packet.Arp",
      "library": "frenetic.kernel",
      "description": "This module defines the structure and serialization of ARP packets, supporting construction and parsing of ARP queries and replies. It works with Ethernet (dlAddr) and IPv4 (nwAddr) addresses, representing ARP payloads for network communication. Concrete use cases include handling address resolution in network switches and routers by encoding/decoding ARP messages for link-layer and network-layer address mapping.",
      "description_length": 416,
      "index": 137,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x01.StatsReply",
      "library": "frenetic.kernel",
      "description": "Handles parsing and marshaling of OpenFlow 1.0 statistics reply messages, converting between raw byte buffers and structured representations. Works with `Cstruct.t` buffers and `Frenetic_kernel.OpenFlow0x01.reply` values, supporting message serialization, deserialization, and string conversion. Used to process and generate OpenFlow statistics responses in network control applications.",
      "description_length": 387,
      "index": 138,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x04.QueueStats",
      "library": "frenetic.kernel",
      "description": "This module handles parsing and serializing queue statistics data structures as defined in the OpenFlow 1.3.4 specification. It operates on the `t` type representing queue statistics, providing exact size calculation, string representation, and binary encoding/decoding using `Cstruct.t`. Useful for processing OpenFlow messages related to queue statistics in network monitoring and control applications.",
      "description_length": 404,
      "index": 139,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x04.GroupStats",
      "library": "frenetic.kernel",
      "description": "This module handles group statistics in OpenFlow 1.3.4, providing operations to parse, marshal, convert to string, and calculate the size of group statistics data. It works with the `groupStats` type, which represents statistics for OpenFlow groups, including bucket-level details via the `BucketStats` submodule. Concrete use cases include processing and serializing group statistics from switches for network monitoring and management tasks.",
      "description_length": 443,
      "index": 140,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x04.Capabilities",
      "library": "frenetic.kernel",
      "description": "This module represents OpenFlow 1.3.4 switch capabilities, mapping each capability to a distinct bit in a 32-bit integer. It provides functions to convert capabilities to and from integer values, along with string representations for debugging. Use this module when negotiating switch features during control plane setup or inspecting supported switch functionality.",
      "description_length": 366,
      "index": 141,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x04.PortFeatures",
      "library": "frenetic.kernel",
      "description": "This module represents port features in the OpenFlow 1.3.4 protocol, corresponding directly to the `ofp_port_features` enumeration. It provides functions to marshal and parse port feature values to and from 32-bit integers, and to convert them into human-readable strings. It is used to describe the capabilities of switch ports, such as supported speeds and link modes, during network device configuration and discovery.",
      "description_length": 421,
      "index": 142,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x04.MultipartReply",
      "library": "frenetic.kernel",
      "description": "This module defines the structure and operations for handling OpenFlow 1.3.4 multipart reply messages. It provides functions to compute the size of a reply, convert it to a string, and serialize or deserialize it using Cstruct buffers. Use cases include processing switch responses during flow table queries or port statistics retrieval in network monitoring applications.",
      "description_length": 372,
      "index": 143,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x04.PacketOut",
      "library": "frenetic.kernel",
      "description": "This module defines operations for constructing and serializing OpenFlow 1.3.4 packet-out messages. It provides functions to calculate the size of a packet-out message, convert it to a string, and marshal or parse it from a Cstruct buffer. These operations are used when sending packets from a controller to a switch, such as injecting packets into the network or responding to packet-in events.",
      "description_length": 395,
      "index": 144,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.Packet.Tcp",
      "library": "frenetic.kernel",
      "description": "This module represents TCP packet headers with precise fields including source and destination ports, sequence and acknowledgment numbers, flags, window size, checksum, and payload. It provides functions to serialize and deserialize TCP packets to and from S-expressions, enabling structured parsing and construction of TCP frames. Concrete use cases include crafting custom TCP packets for network testing, analyzing packet captures, and implementing TCP-based protocol logic in network applications.",
      "description_length": 501,
      "index": 145,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.Net.Link",
      "library": "frenetic.kernel",
      "description": "This module defines a data type `t` representing network links and provides functions to serialize and deserialize link data in various formats, including S-expressions, DOT, and GML. It includes operations for comparing links, converting them to human-readable strings, and parsing link attributes from graph description languages. Concrete use cases include representing and manipulating network topologies in software-defined networking applications.",
      "description_length": 453,
      "index": 146,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x04.Oxm",
      "library": "frenetic.kernel",
      "description": "This module defines operations for handling OpenFlow 1.3.4 OXM (OpenFlow Extensible Match) fields, including parsing, marshaling, and string representation. It works with the `t` type representing OXM fields and `oxmMatch` for match structures, using `Cstruct.t` for binary serialization. Concrete use cases include constructing and deconstructing flow match fields for network packet processing and switch communication.",
      "description_length": 421,
      "index": 147,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x01.Error",
      "library": "frenetic.kernel",
      "description": "This module defines error message types and serialization utilities for handling specific failure scenarios in OpenFlow 1.0 protocol communication. It works with structured error types like `HelloFailed`, `BadRequest`, and `BadAction`, each representing distinct protocol error conditions, along with functions to convert these errors to and from S-expressions and to generate human-readable output. Concrete use cases include reporting handshake failures, malformed messages, invalid actions, and flow or port configuration errors during switch-controller interactions.",
      "description_length": 570,
      "index": 148,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_kernel.Packet.Udp",
      "library": "frenetic.kernel",
      "description": "This module defines the structure of a UDP packet, including source and destination ports, a checksum, and a payload represented as a Cstruct. It provides serialization and deserialization functions to and from S-expressions for UDP packet data. This module is used to handle UDP payloads within network packet processing tasks, such as parsing incoming packets or constructing outgoing UDP frames.",
      "description_length": 398,
      "index": 149,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x01.PortStatus",
      "library": "frenetic.kernel",
      "description": "This module processes OpenFlow 1.0 port status messages, providing functions to parse raw data into structured port status updates and serialize them back into binary format. It works with the `t` type, which includes a change reason from the `ChangeReason` submodule and a `portDescription`. Use this module to handle port status notifications from switches, such as when a port is added, removed, or modified, and to construct or decode these messages for network monitoring or control applications.",
      "description_length": 501,
      "index": 150,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_kernel.Topology",
      "library": "frenetic.kernel",
      "description": "This module provides operations to model, analyze, and generate network topologies using graph structures with switches, ports, and edges. It supports concrete tasks such as extracting switch identifiers, querying port configurations, validating edge connections, and generating network layouts from symbolic definitions. Use cases include routing optimization, network simulation, and testing SDN controllers with synthetic topologies.",
      "description_length": 436,
      "index": 151,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.Net",
      "library": "frenetic.kernel",
      "description": "This module defines network nodes and links as algebraic data types, supporting bidirectional conversion to and from S-expressions. It provides graph-based network topology operations including shortest path computation, spanning tree generation, and traversal algorithms. Concrete use cases include modeling software-defined networks, parsing topology descriptions in DOT/GML formats, and generating Mininet simulations for network testing.",
      "description_length": 441,
      "index": 152,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.Packet",
      "library": "frenetic.kernel",
      "description": "This module supports structured parsing, serialization, and manipulation of network packets through types like Ethernet frames, VLAN tags, IP headers, and transport-layer protocols (TCP, UDP, ICMP). It provides precise access to packet fields (e.g., MAC addresses, IP addresses, port numbers) and conversion utilities between string, byte, and internal representations, enabling tasks like protocol implementation and network testing. Key operations include constructing/modifying packet headers, extracting metadata for analysis, and handling low-level payloads in control applications such as software-defined networking switches.",
      "description_length": 632,
      "index": 153,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_kernel.Util",
      "library": "frenetic.kernel",
      "description": "This module includes functions for string formatting with custom formatters, mapping over tuple lists, and generating or displaying DOT graphs. It operates on data types such as formatter functions, lists of tuples, and strings representing graph descriptions. Concrete uses include converting structured data to strings, transforming tuple-based collections, and visualizing graphs using external tools.",
      "description_length": 404,
      "index": 154,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow",
      "library": "frenetic.kernel",
      "description": "This module provides operations for translating high-level network actions (like parallel compositions, failover groups, and packet modifications) into OpenFlow 1.0 and 1.3 wire formats, while abstracting differences between protocol versions. It works with flow tables, group tables, and action sequences represented as structured types (`action`, `flow`, `group`, `flowTable`), alongside identifiers (switch/port IDs) and packet-level constructs. Specific use cases include compiling Frenetic programs into efficient OpenFlow 1.3 group tables for parallel actions or failover, while falling back to controller round-trips and action sequences in OpenFlow 1.0 environments.",
      "description_length": 674,
      "index": 155,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_kernel.Network",
      "library": "frenetic.kernel",
      "description": "This module implements network topology construction, traversal, and analysis with typed vertices and edges. It provides path computation with customizable weights, spanning tree generation, and serialization for network graphs. Use it to model software-defined networks, optimize routing paths, or analyze connectivity in mesh topologies.",
      "description_length": 339,
      "index": 156,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_kernel.GroupTable0x04",
      "library": "frenetic.kernel",
      "description": "This module manages a mutable group table for defining OpenFlow 1.3-style action groups, supporting operations to create, clear, and commit groups with specific behaviors. It works with group types, action buckets, and port identifiers to model packet processing logic such as fast failover or round-robin distribution. Concrete use cases include setting up fast failover groups that forward packets through the first live port in a list or distributing traffic across multiple buckets.",
      "description_length": 486,
      "index": 157,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow_Header",
      "library": "frenetic.kernel",
      "description": "This module defines the fixed OpenFlow message header structure, including version, type code, length, and transaction ID (xid). It provides functions to parse and marshal this header from and to raw packet buffers, along with conversions to and from S-expressions and human-readable strings. Concrete use cases include extracting header metadata from incoming OpenFlow packets and preparing headers for outgoing messages.",
      "description_length": 422,
      "index": 158,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x04",
      "library": "frenetic.kernel",
      "description": "This module implements serialization, deserialization, and structured manipulation of OpenFlow 1.3 protocol messages for software-defined networking. It operates on data structures representing network switches, ports, flow tables, group tables, meters, and packet match/action rules, with support for handling configuration, statistics, errors, and control plane operations. Key use cases include switch state management, packet routing, flow modification, and network telemetry through precise binary and S-expression format conversions.",
      "description_length": 539,
      "index": 159,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.Hashcons",
      "library": "frenetic.kernel",
      "description": "This module implements hash-consing for a custom value type, ensuring physically identical representations for structurally equal values. It provides `get` to obtain a unique integer key for a value, `unget` to retrieve the value from its key, and `clear` to remove entries for a set of keys. It is particularly useful in symbolic computation and AST manipulation to improve performance and reduce memory usage through deduplication.",
      "description_length": 433,
      "index": 160,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_kernel.Bits",
      "library": "frenetic.kernel",
      "description": "This module provides low-level bit and byte manipulation operations for 32-bit and 64-bit integers. It includes functions to set, clear, test, and conditionally update individual bits, as well as extract specific bytes from integer values. These operations are useful in network protocol parsing, hardware interfacing, and performance-sensitive systems code where direct bit-level control is required.",
      "description_length": 401,
      "index": 161,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x01",
      "library": "frenetic.kernel",
      "description": "This module provides serialization and deserialization functions for converting between S-expressions and OpenFlow 1.0 protocol entities, such as flow modifications, packet-in messages, and port state data. It operates on structured types representing network control primitives, including switch identifiers, flow rules, match patterns, and actions. These utilities support software-defined networking applications by enabling message parsing, flow rule management, and data conversion for monitoring and configuration tasks.",
      "description_length": 526,
      "index": 162,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel",
      "library": "frenetic.kernel",
      "description": "This module includes low-level bit manipulation, network topology modeling, OpenFlow protocol handling, and hash-consing for efficient data representation. It works with 32/64-bit integers, network graphs, OpenFlow messages, and custom value types for deduplication. Use it for network protocol parsing, SDN switch management, symbolic computation, and performance-sensitive systems programming.",
      "description_length": 395,
      "index": 163,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_async.Ox.DefaultHandlers",
      "library": "frenetic.async",
      "description": "This module provides default implementations for event handlers that manage switch connections, barrier replies, and statistics replies in an OpenFlow 0x01 application. It works with switch identifiers, transaction IDs, and OpenFlow message types to handle events such as switch connection, disconnection, and message responses. These handlers are useful for simplifying controller logic when no custom behavior is needed for these events.",
      "description_length": 439,
      "index": 164,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_async.NetKAT_Controller.Make",
      "library": "frenetic.async",
      "description": "This module implements a controller for managing OpenFlow switches, providing operations to initialize the controller on a TCP port, retrieve network events, and query switch state such as connected switches and port statistics. It supports dynamic policy updates, including setting local or global policies, compiling policies from FDDs, and injecting packets into the network. Use cases include building software-defined networking applications that react to network events, enforce traffic policies, and gather real-time statistics from OpenFlow-enabled switches.",
      "description_length": 566,
      "index": 165,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_async.Ox.Make",
      "library": "frenetic.async",
      "description": "This module builds an Ox controller that listens on port 6633 for OpenFlow messages from network switches and routes them to the provided `OxModule` callbacks. It operates on OpenFlow-enabled switch data and network event streams, enabling direct interaction with SDN hardware. Concrete use cases include implementing custom network control logic, such as traffic monitoring, routing policies, or dynamic firewall rules.",
      "description_length": 420,
      "index": 166,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_async.OpenFlow0x01_Plugin.LowLevel",
      "library": "frenetic.async",
      "description": "This module manages low-level interactions with OpenFlow 1.0 switches, handling connection initialization, message sending, and event reception. It works with switch identifiers, transaction IDs, and OpenFlow messages, providing direct access to switch communication. Concrete use cases include establishing control plane connectivity, transmitting packet-out commands, and processing asynchronous switch events like port status changes or received packets.",
      "description_length": 457,
      "index": 167,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_async.Ox.Platform",
      "library": "frenetic.async",
      "description": "This module provides functions to send OpenFlow messages such as packet-out, flow-mod, stats request, and barrier request to switches, using switch identifiers, transaction IDs, and message-specific data. It also includes a function to execute a thunk after a specified timeout delay. These operations are used to interact directly with OpenFlow switches and manage asynchronous control plane tasks in network applications.",
      "description_length": 423,
      "index": 168,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_async.OpenFlow0x01_Plugin",
      "library": "frenetic.async",
      "description": "This module implements an asynchronous OpenFlow 1.0 controller plugin for managing software-defined switches. It provides operations to start a controller instance, send packet-out commands, retrieve flow and port statistics, update forwarding policies, and access switch features or event streams. Concrete use cases include building network control applications that react to switch events, enforce network policies, or gather real-time traffic metrics from OpenFlow-enabled switches.",
      "description_length": 486,
      "index": 169,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_async.Logging",
      "library": "frenetic.async",
      "description": "This module offers functions to configure log levels, format structured messages with timestamps and tags, and manage asynchronous output rotation and flushing. It works with S-expressions, strings, and message objects, enabling severity-based logging and contextual tagging. Ideal for applications requiring robust structured logging with dynamic configuration and asynchronous processing of diverse data formats.",
      "description_length": 414,
      "index": 170,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_async.Shell",
      "library": "frenetic.async",
      "description": "This module provides a single entry point `main` that initializes and runs an asynchronous shell environment. It handles command-line arguments and sets up event loops for interactive shell operations. Concrete use cases include building custom REPLs or command-line tools with asynchronous I/O.",
      "description_length": 295,
      "index": 171,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_async.Compile_Server",
      "library": "frenetic.async",
      "description": "This module implements a server that compiles Frenetic programs asynchronously. It listens for incoming compilation requests on a specified port and processes them concurrently. The `main` function starts the server with a given port number and handles each client connection by compiling the received Frenetic code and returning the result.",
      "description_length": 341,
      "index": 172,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_async.Http_Controller",
      "library": "frenetic.async",
      "description": "Implements an asynchronous HTTP controller for handling network requests and responses. Works with socket descriptors and HTTP message structures to manage client-server communication. Use this module to build lightweight web servers or network clients that require non-blocking I/O operations.",
      "description_length": 294,
      "index": 173,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_async.Ox",
      "library": "frenetic.async",
      "description": "This module implements an OpenFlow 0x01 controller for handling switch connections and message routing. It provides event handlers for managing switch lifecycle events and sending control messages like flow-mod, packet-out, and stats requests. Concrete use cases include building SDN applications for traffic management, network monitoring, and dynamic policy enforcement.",
      "description_length": 372,
      "index": 174,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_async.Common",
      "library": "frenetic.async",
      "description": "This module provides functions for profiling code execution, logging with severity levels, extracting request paths from HTTP requests, and handling parsing errors in asynchronous HTTP handlers. It works with Cohttp_async request and body types, Frenetic_netkat policies, and compiler options. Concrete use cases include measuring performance of policy updates, safely parsing JSON-formatted network policies and compiler configurations from HTTP requests, and generating appropriate HTTP responses when parsing fails.",
      "description_length": 518,
      "index": 175,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_async.DynGraph",
      "library": "frenetic.async",
      "description": "This module implements a dynamic dataflow graph where nodes hold values and propagate updates to connected nodes. It supports creating nodes with update functions, attaching nodes to form directed edges, and interfacing with async pipes for external input and output. Use cases include building reactive systems that respond to changing data sources, such as live data feeds or interactive UI components.",
      "description_length": 404,
      "index": 176,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_async.NetKAT_Controller",
      "library": "frenetic.async",
      "description": "Implements a controller for managing OpenFlow switches, offering operations to initialize on a TCP port, retrieve network events, and query switch state like connected switches and port statistics. Supports dynamic policy updates, including local/global policies, FDD-based compilation, and packet injection. Enables building SDN applications that react to network events, enforce traffic policies, and collect real-time switch statistics.",
      "description_length": 439,
      "index": 177,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_async.OpenFlow0x04_Plugin",
      "library": "frenetic.async",
      "description": "This module implements OpenFlow 1.3 messaging and switch management for asynchronous network control applications. It provides functions to send and process OpenFlow messages, manage flow tables, and handle group tables on switches, using Async for non-blocking I/O. Key operations include installing flows, handling switch connections, and maintaining fault-tolerant control loops.",
      "description_length": 382,
      "index": 178,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_async",
      "library": "frenetic.async",
      "description": "This module provides asynchronous networking and control functionality for software-defined networking applications. It includes modules for handling HTTP requests, compiling network policies, managing OpenFlow switches, and implementing dynamic dataflow graphs. Use it to build reactive network controllers, compile and enforce network policies in real time, and process asynchronous data streams from network devices.",
      "description_length": 419,
      "index": 179,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.Fdd.Action.Seq.Tree.Provide_of_sexp",
      "library": "frenetic.netkat",
      "description": "Converts S-expressions into FDD action sequence trees, using a provided function to parse leaf actions. Works with NetKAT predicates and OpenFlow actions structured as decision diagrams. Useful for deserializing flow tables or policy configurations from S-expressions into executable FDDs.",
      "description_length": 289,
      "index": 180,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.Fdd.Action.Par.Tree.Provide_of_sexp",
      "library": "frenetic.netkat",
      "description": "Converts S-expressions into FDD action trees, specifically handling the structured representation of OpenFlow actions and header matches. Works with `Frenetic_netkat.Fdd.Action.Par.Tree.t`, a type representing parallel action trees over a customizable element type. Useful for parsing serialized NetKAT policies into executable flow tables.",
      "description_length": 340,
      "index": 181,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.Fdd.Action.Par.Tree.Named",
      "library": "frenetic.netkat",
      "description": "This module implements parallel composition and comparison operations for named action trees in Forwarding Decision Diagrams (FDDs). It works with OpenFlow actions and header match fields, enabling precise manipulation of network forwarding policies. Concrete use cases include checking equality and subset relationships between FDDs to validate policy transformations and compiling NetKAT programs into efficient flow tables for SDN switches.",
      "description_length": 443,
      "index": 182,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_netkat.Fdd.FDD.Tbl.Provide_bin_io",
      "library": "frenetic.netkat",
      "description": "This module provides binary serialization and deserialization operations for FDD-based flow tables indexed by a key type. It works with FDDs that map keys to flow table entries, using OpenFlow actions and header matches. Concrete use cases include persisting compiled flow tables to disk or transmitting them over a network in a compact binary format.",
      "description_length": 351,
      "index": 183,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.Local_compiler.FDD.BinTbl.Provide_bin_io",
      "library": "frenetic.netkat",
      "description": "This module implements binary serialization and deserialization for FDD-based tables parameterized by a key type. It provides functions to compute binary shapes, sizes, and to read and write FDD tables in binary format. These operations support efficient storage and transmission of FDD structures used in network policy compilation.",
      "description_length": 333,
      "index": 184,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.Global_compiler.FDD.Tbl.Provide_of_sexp",
      "library": "frenetic.netkat",
      "description": "This module implements a function `t_of_sexp` that parses S-expressions into a table structure indexed by a key type, where values are FDDs (Variable-Lattice-Result structures). It specifically works with `Ppx_sexp_conv_lib.Sexp.t` input and constructs a table mapping keys to FDDs using a provided conversion function. A concrete use case is deserializing network policy configurations represented as S-expressions into an in-memory table of FDD-based decision diagrams for efficient packet classification and analysis.",
      "description_length": 520,
      "index": 185,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_netkat.Fdd.Action.Par.Elt",
      "library": "frenetic.netkat",
      "description": "This module represents elements of a parallel action sequence in a Forwarding Decision Diagram (FDD), where each element corresponds to a sequence of OpenFlow actions applied to network packets. It provides functions for serializing and deserializing these action sequences and supports comparison operations through a comparator. It is used during the compilation of NetKAT policies into efficient flow tables by manipulating action outcomes at FDD leaves.",
      "description_length": 457,
      "index": 186,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.Local_compiler.FDD.BinTbl.Provide_of_sexp",
      "library": "frenetic.netkat",
      "description": "This module implements a function `t_of_sexp` that parses S-expressions into a binary table structure, using a provided key conversion function. It operates on S-expressions and constructs values of type `Frenetic_netkat.Local_compiler.FDD.BinTbl.t`, which represents a table mapping keys to FDD-based results. It is used to deserialize network policy rules stored in S-expression format into an optimized binary decision diagram table for efficient lookup and evaluation.",
      "description_length": 472,
      "index": 187,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.Fdd.Action.Seq.Key",
      "library": "frenetic.netkat",
      "description": "This module defines a key type for sequences of actions in a Forwarding Decision Diagram (FDD), where keys represent either a field or a continuation. It provides comparison and serialization functions for these keys, enabling efficient manipulation and persistence of FDD structures. Concrete use cases include compiling NetKAT policies into optimized flow tables by managing action sequences during FDD construction and transformation.",
      "description_length": 437,
      "index": 188,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.Fdd.Action.Par.Provide_bin_io",
      "library": "frenetic.netkat",
      "description": "This module provides binary serialization and deserialization operations for parallel action values in Forwarding Decision Diagrams. It works with the `t` type representing structured network actions, enabling efficient storage and transmission of FDD-based flow tables. Concrete use cases include persisting compiled NetKAT policies to disk or sending them over a network for switch configuration.",
      "description_length": 398,
      "index": 189,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.Fdd.Action.Par.Provide_of_sexp",
      "library": "frenetic.netkat",
      "description": "Converts S-expressions into parallel action values, specifically handling the deserialization of structured network actions. Works with `Frenetic_netkat.Fdd.Action.Par.t`, a type representing sets of OpenFlow actions applied in parallel. Useful for parsing policy configurations or flow tables from external sources like configuration files or network management systems.",
      "description_length": 371,
      "index": 190,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_netkat.Fdd.Action.Seq.Provide_hash",
      "library": "frenetic.netkat",
      "description": "This module implements hash folding for sequences of actions in Forwarding Decision Diagrams (FDDs), enabling efficient hashing of action sequences structured according to a key module. It operates directly on FDD action sequences, using a provided hash state to generate hash values that reflect the structure and content of the actions. This is particularly useful when compiling NetKAT policies into flow tables, where consistent and efficient hashing of action sequences is required for optimization and deduplication.",
      "description_length": 522,
      "index": 191,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.Local_compiler.FDD.Tbl.Provide_bin_io",
      "library": "frenetic.netkat",
      "description": "This module implements binary serialization and deserialization for FDD-based tables indexed by a key type. It provides functions to convert FDD tables to and from binary format, supporting efficient storage and transmission. Use cases include persisting FDD table states to disk or sending them over a network.",
      "description_length": 311,
      "index": 192,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.Global_compiler.FDD.BinTbl.Provide_bin_io",
      "library": "frenetic.netkat",
      "description": "This module implements binary serialization and deserialization for FDD-based tables parameterized by a key type. It provides functions to compute binary shapes, size, write, and read FDD tables, along with reader and writer instances compatible with Bin_prot. It is used to efficiently persist or transmit FDD tables in binary format, such as during network communication or disk storage.",
      "description_length": 389,
      "index": 193,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.Fdd.Action.Par.Tree",
      "library": "frenetic.netkat",
      "description": "This module offers ordered tree-based operations for managing NetKAT FDD actions and header matches, emphasizing set-like manipulations (union, intersection, difference) and ordered traversal/folding. It operates on immutable, comparator-driven trees containing OpenFlow action elements, enabling precise policy transformations and validations in SDN workflows. Key applications include compiling NetKAT programs into optimized flow tables and performing efficient policy analysis through structured action tree manipulations.",
      "description_length": 526,
      "index": 194,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.Fdd.Action.Seq.Provide_bin_io",
      "library": "frenetic.netkat",
      "description": "This module implements binary serialization and deserialization for sequence actions within a decision diagram structure. It operates on types involving `Frenetic_netkat.Fdd.Action.Seq.t`, enabling efficient storage and transmission of action sequences tied to decision paths. Concrete use cases include persisting compiled NetKAT policies to disk or sending them over a network in a compact binary format.",
      "description_length": 406,
      "index": 195,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.Fdd.Action.Par.Named",
      "library": "frenetic.netkat",
      "description": "This module implements parallel actions for FDDs using named OpenFlow actions, enabling precise manipulation and comparison of forwarding policies. It provides operations to check subset and equality relationships between action sets, ensuring correctness during FDD compilation and optimization. Concrete use cases include validating policy transformations and ensuring consistency when merging or simplifying flow tables derived from NetKAT programs.",
      "description_length": 452,
      "index": 196,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.Fdd.FDD.Tbl.Provide_of_sexp",
      "library": "frenetic.netkat",
      "description": "This module implements a parser for converting S-expressions into FDD-based flow tables, enabling the direct instantiation of flow tables from structured external representations. It operates on FDDs (Forwarding Decision Diagrams) extended with OpenFlow actions and header matches, using a key module to define field orderings. It is used to load precomputed flow tables from disk or network configurations, supporting concrete applications like network policy compilation and switch rule provisioning.",
      "description_length": 502,
      "index": 197,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.Local_compiler.FDD.Tbl.Provide_of_sexp",
      "library": "frenetic.netkat",
      "description": "This module provides a function `t_of_sexp` that constructs an FDD table from an S-expression representation, using a provided conversion function for values. It operates on S-expressions and FDD tables, where keys are of the type specified by the `Key` module. A concrete use case is parsing serialized FDD tables from configuration files or network messages into in-memory structures for further processing.",
      "description_length": 409,
      "index": 198,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.Fdd.FDD.BinTbl.Provide_of_sexp",
      "library": "frenetic.netkat",
      "description": "This module implements a function `t_of_sexp` that parses S-expressions into FDD binary decision tables, using a provided conversion function for key values. It operates on the `Frenetic_netkat.Fdd.FDD.BinTbl.t` type, which represents flow tables derived from FDDs. A concrete use case is deserializing NetKAT policy specifications from S-expressions into executable flow tables for network forwarding.",
      "description_length": 402,
      "index": 199,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.Fdd.Action.Par.Provide_hash",
      "library": "frenetic.netkat",
      "description": "This module implements hash folding and hashing operations for parallel action values in a decision diagram structure. It works with FDD action parallel types to enable structural hashing of OpenFlow action combinations. This supports efficient comparison and caching of action sets during flow table generation.",
      "description_length": 312,
      "index": 200,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.Semantics.HeadersValues.Fields.Direct",
      "library": "frenetic.netkat",
      "description": "This module directly manipulates header-value maps for network packet processing, providing field-specific operations to iterate, fold, filter, and transform values associated with packet headers such as Ethernet source/destination, VLAN tags, IP addresses, and TCP ports. It supports concrete data types like `Frenetic_kernel.Packet.dlAddr`, `Frenetic_kernel.Packet.nwAddr`, and `int64`, tied to network semantics. Use cases include modifying packet metadata during forwarding decisions or applying transformations in software-defined networking pipelines.",
      "description_length": 557,
      "index": 201,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_netkat.Fdd.Action.Seq.Provide_of_sexp",
      "library": "frenetic.netkat",
      "description": "This module defines a function `t_of_sexp` that parses S-expressions into FDD action sequences parameterized by a `Key` module. It works with FDDs whose leaves are OpenFlow actions and whose nodes represent packet header fields. Use this module to construct FDD-based packet processing pipelines from S-expression representations, such as when loading configurations or policies from files or network management tools.",
      "description_length": 418,
      "index": 202,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.Fdd.Action.Seq.Tree",
      "library": "frenetic.netkat",
      "description": "This module implements ordered trees that map structured keys to arbitrary values, designed to represent and manipulate packet-forwarding policies using finite decision diagrams (FDDs). It provides operations for constructing, transforming, and querying hierarchical data through key-based insertion, deletion, folding, and range-based traversal, alongside utilities for validation and error handling. These trees underpin NetKAT's compilation process, enabling efficient policy analysis and translation into OpenFlow-compatible flow tables by leveraging ordered key hierarchies and BDD-inspired optimizations.",
      "description_length": 610,
      "index": 203,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.Global_compiler.FDD.BinTbl.Provide_of_sexp",
      "library": "frenetic.netkat",
      "description": "This module implements a function `t_of_sexp` that parses S-expressions into a binary decision diagram (FDD) structure parameterized by a key type. It works with FDDs built from a variable lattice and result type, using a key-based representation for nodes. A typical use case involves deserializing FDDs from S-expression formats during configuration or testing.",
      "description_length": 363,
      "index": 204,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.Fdd.FDD.BinTbl.Provide_bin_io",
      "library": "frenetic.netkat",
      "description": "This module provides binary serialization and deserialization operations for FDDs (Forwarding Decision Diagrams) represented as binary tables. It works with FDDs parameterized over a key type, supporting efficient conversion to and from binary formats using the Bin_prot library. Concrete use cases include persisting compiled flow tables to disk or transmitting them over a network in a compact, typed binary format.",
      "description_length": 417,
      "index": 205,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.Global_compiler.FDD.Tbl.Provide_bin_io",
      "library": "frenetic.netkat",
      "description": "This module implements binary serialization and deserialization for FDD-based tables indexed by a `Key` type. It provides functions to convert FDD tables to and from binary representations, enabling efficient storage and transmission. Use cases include persisting FDD tables to disk or sending them over a network.",
      "description_length": 314,
      "index": 206,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.Semantics.HeadersValues.Fields",
      "library": "frenetic.netkat",
      "description": "This module provides structured access to packet header fields through creation, traversal, and transformation operations on a map of header values, supporting network headers like Ethernet, IP, TCP ports, VLAN, and switch metadata. It enables functional transformations and traversals over these fields using typed accessors and polymorphic functions like `iter`, `map`, and `to_list`. These capabilities are used in network policy evaluation to process and manipulate packet headers with precise, field-level control.",
      "description_length": 519,
      "index": 207,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.Local_compiler.FDD.Tbl",
      "library": "frenetic.netkat",
      "description": "This module implements hash tables keyed by Variable-Lattice-Result (FDD) structures, supporting efficient operations for mapping, merging, filtering, and serializing key-value pairs where keys represent hierarchical decision diagrams. It provides imperative and functional transformations like conditional updates, multi-value handling, and lattice-aware traversals, alongside binary/S-expression encoding for persistence. These tables are particularly suited for network policy compilation tasks requiring structured manipulation of packet-processing rules and their associated metadata.",
      "description_length": 589,
      "index": 208,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.Fdd.FDD.BinTbl",
      "library": "frenetic.netkat",
      "description": "This component implements hash tables with keys composed of Forwarding Decision Diagram (FDD) pairs, supporting operations like associative construction, duplicate handling via customizable strategies, and transformations using imperative or functional patterns. It works with FDDs\u2014BDD extensions embedding OpenFlow actions and header matches\u2014to model network forwarding policies, enabling efficient compilation of NetKAT rules into flow tables. Key use cases include merging policy fragments with conflict resolution, validating packet-processing logic, and serializing network state for runtime execution.",
      "description_length": 607,
      "index": 209,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.Local_compiler.FDD.BinTbl",
      "library": "frenetic.netkat",
      "description": "This module implements hash tables keyed by pairs of FDDs (Variable-Lattice-Result structures) with arbitrary value types, supporting both functional and imperative operations for table manipulation, transformation, and serialization. It provides specialized operations for merging, filtering, and folding over key-value pairs, with network policy decision tables as a core use case where efficient representation and structured manipulation of forwarding logic are critical. The module emphasizes direct mutation, custom combination logic for key collisions, and binary/S-expression serialization to enable persistent storage and transmission of policy state in SDN environments.",
      "description_length": 680,
      "index": 210,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.Fdd.Field.Env",
      "library": "frenetic.netkat",
      "description": "Maps packet header field names to their static FDD representations, tracking initialization and mutability. Provides operations to create an empty environment, add or update field mappings, and retrieve field information by name. Used during FDD construction to manage header field metadata and ensure consistency in packet processing rules.",
      "description_length": 341,
      "index": 211,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.Fdd.Action.Par",
      "library": "frenetic.netkat",
      "description": "This module manages ordered collections of parallel OpenFlow actions using set-theoretic operations and ordered tree structures. It supports union, intersection, difference, and subset checks, along with transformations like filtering, mapping, and merging, while ensuring structural invariants for efficient policy compilation. These operations target network policy optimization and SDN flow table generation by manipulating action sequences within FDDs, leveraging ordered sets (`Par.t`) and their elements (`Elt.t`) to enforce deterministic behavior during packet processing.",
      "description_length": 579,
      "index": 212,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.Global_compiler.FDD.Tbl",
      "library": "frenetic.netkat",
      "description": "This module supports efficient imperative and functional manipulation of key-value tables where keys are specialized FDD structures (representing network policy decisions) and values can be arbitrary types, including integers and lists. It enables operations like merging, filtering, and counter updates with fine-grained control, along with bidirectional conversion between tables and S-expressions or binary formats for persisting or transmitting network policy configurations. The design emphasizes performance-critical use cases such as dynamic policy enforcement and traffic management in software-defined networks.",
      "description_length": 620,
      "index": 213,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_netkat.Fdd.Action.Seq",
      "library": "frenetic.netkat",
      "description": "This module manages sequences of OpenFlow actions associated with structured keys representing packet headers or continuations, using finite decision diagrams (FDDs) to enable efficient policy compilation and flow table generation. It provides operations for constructing, merging, and transforming key-indexed action sequences with conflict resolution strategies, while supporting validation, ordered traversal, and serialization to formats like HVS lists or S-expressions. Key applications include optimizing NetKAT-to-OpenFlow translations, handling overlapping header matches with precise key ordering, and enabling property-based testing or error-resilient policy composition in network control planes.",
      "description_length": 707,
      "index": 214,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.Fdd.FDD.Tbl",
      "library": "frenetic.netkat",
      "description": "This module provides hash table implementations optimized for managing flow tables in network policy compilation, where keys are structured as Forwarding Decision Diagrams (FDDs) encoding OpenFlow match conditions and actions. It supports imperative operations like merging, filtering, and in-place transformations, alongside functional manipulations for immutable data, enabling efficient handling of network forwarding rules. Designed for use cases such as compiling NetKAT programs into OpenFlow-compatible flow tables, it leverages FDDs' hierarchical structure to ensure scalability in data plane programming tasks.",
      "description_length": 619,
      "index": 215,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.Packet.T",
      "library": "frenetic.netkat",
      "description": "This module represents network packets as maps from fields to 64-bit integer values. It provides operations for comparing, hashing, and serializing packets, along with a comparator for use in ordered collections. Use cases include packet processing in software-defined networking applications, where precise field-level manipulation and efficient equality checks are required.",
      "description_length": 376,
      "index": 216,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.Global_compiler.FDD",
      "library": "frenetic.netkat",
      "description": "This module provides operations for constructing and manipulating decision diagrams that represent network policies in software-defined networking. Core functionalities include building decision nodes (`cond`, `atom`), combining diagrams via union or sequential composition, simplifying them through transformations (`map`, `restrict`), and analyzing size or equivalence. The diagrams are built from field-value pairs and actions, leveraging table-based structures for efficient policy configuration management. These tools enable use cases like modeling packet processing pipelines, optimizing policy execution, and visualizing network behavior through serialization and diagram rendering.",
      "description_length": 690,
      "index": 217,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.Fdd.Action",
      "library": "frenetic.netkat",
      "description": "This module provides operations for constructing and analyzing OpenFlow actions within forwarding decision diagrams, focusing on structured sequences and parallel compositions. It works with packet header matches, continuations, and ordered key-based representations to enable efficient policy compilation, while supporting introspection through query extraction, pipe tracking, and serialization. These capabilities are specifically used to translate NetKAT programs into optimized SDN flow tables by leveraging BDD-based decision diagram theory.",
      "description_length": 547,
      "index": 218,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.Fdd.FDD",
      "library": "frenetic.netkat",
      "description": "This module provides operations for constructing, transforming, and serializing decision diagrams that model network forwarding behavior using field-value tests and OpenFlow actions. It works with hierarchical data structures representing packet headers, action policies, and optimized hash tables for merging conflict resolution, leveraging BDD-like optimizations. Specific use cases include compiling high-level network policies into efficient flow tables for software-defined networking, with support for structural analysis, caching, and visualization through domain-specific combinators.",
      "description_length": 592,
      "index": 219,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.Parser.Portless",
      "library": "frenetic.netkat",
      "description": "This module parses NetKAT policies and predicates from strings or files, producing corresponding syntax trees without port information. It provides functions to convert string representations into policy and predicate values, handling lexical analysis and syntactic structure. Use it to load NetKAT configurations from external sources, such as configuration files or network inputs, directly into executable policy logic.",
      "description_length": 422,
      "index": 220,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.Fdd.Value",
      "library": "frenetic.netkat",
      "description": "This module represents values used in Forwarding Decision Diagrams (FDDs) for NetKAT, supporting operations like equality, comparison, hashing, and lattice-based subsetting. It works with packet fields and actions, encoding them as constants, bitmasks, abstract locations, pipes, queries, and failure codes. Concrete use cases include representing Ethernet source addresses, port masks, and control actions during FDD construction and flow table generation.",
      "description_length": 457,
      "index": 221,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.Semantics.HeadersValues",
      "library": "frenetic.netkat",
      "description": "This module provides structured access and functional transformations for network packet headers, including Ethernet, IP, TCP, VLAN, and switch metadata fields. It supports operations like field-level serialization, comparison, and conversion to string representations or key-value lists, enabling use cases such as packet classification, header manipulation (e.g., VLAN tagging), and network protocol parsing. The design facilitates traversals and modifications over header fields while maintaining type-safe access to low-level packet data.",
      "description_length": 542,
      "index": 222,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.Global_compiler.Automaton",
      "library": "frenetic.netkat",
      "description": "This module represents NetKAT automata as an intermediate structure used during global compilation. It supports operations like adding transitions between states, folding over reachable states, converting policies to automata, and rendering automata to graphical formats. The automaton works with states represented as integers, transitions involving FDDs (Flow Decision Diagrams), and maintains mappings to track state relationships. Concrete use cases include compiling network policies into efficient automata representations and visualizing the structure of those automata for debugging or analysis.",
      "description_length": 603,
      "index": 223,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.Fdd.Field",
      "library": "frenetic.netkat",
      "description": "This module defines a set of named packet header fields used in Forwarding Decision Diagrams (FDDs), such as Ethernet source, IP destination, TCP port, and VLAN. It provides operations to convert between string representations and field values, compare and hash fields, and manage global field ordering, which impacts FDD efficiency. Concrete use cases include constructing and normalizing network policies from NetKAT into FDDs, optimizing packet classification via field reordering, and mapping header values to FDD structures during compilation.",
      "description_length": 548,
      "index": 224,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.Local_compiler.FDD",
      "library": "frenetic.netkat",
      "description": "This module provides operations for constructing and manipulating hierarchical decision structures over packet fields, enabling precise modeling of network policies. It works with branching data structures composed of `Leaf` and `Branch` nodes, which represent decisions based on packet values, and leverages hash tables for efficient policy merging, filtering, and serialization. Key use cases include compiling network predicates into structured packet-processing rules, performing set-theoretic operations (union, sequential composition), and optimizing policy representations for software-defined networking (SDN) applications.",
      "description_length": 631,
      "index": 225,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.Virtual_Compiler.Make",
      "library": "frenetic.netkat",
      "description": "This module generates and compiles virtual network policies using a fabric-based approach. It constructs a fabric from virtual and physical topologies, then compiles policies by leveraging the generated fabric to enforce virtual routing logic. Key operations include fabric generation, policy compilation with precomputed fabrics, and end-to-end policy translation for software-defined networking environments.",
      "description_length": 410,
      "index": 226,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.Packet.Field",
      "library": "frenetic.netkat",
      "description": "This module represents individual fields within a network packet, such as source or destination IP addresses, port numbers, or protocol types. It provides operations to compare fields and define custom comparators, enabling precise packet classification and forwarding decisions. Concrete use cases include matching packets against flow rules in software-defined networking applications.",
      "description_length": 387,
      "index": 227,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.Fdd.Pattern",
      "library": "frenetic.netkat",
      "description": "This module represents patterns in Forwarding Decision Diagrams (FDDs) as pairs of fields and values, enabling precise header matching. It supports pattern comparison, equality checks, and conversions to NetKAT headers, predicates, and OpenFlow patterns. These operations facilitate compiling NetKAT policies into efficient flow tables for network switches.",
      "description_length": 357,
      "index": 228,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.Vlr.Make",
      "library": "frenetic.netkat",
      "description": "This module provides operations for constructing and manipulating lattice-valued decision diagrams with semi-ring-valued functions, using branching nodes and leaves to encode structured state spaces. It supports structural transformations like mapping and folding, logical combinations via semi-ring operations, and efficient equality checks, working with lattice-ordered variables and memoized computation. Designed for network applications, it enables compact representation and analysis of policies or network state transitions where partial orders and algebraic computations are critical.",
      "description_length": 592,
      "index": 229,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.FabricGen.FabricGen",
      "library": "frenetic.netkat",
      "description": "This module implements a two-player adversarial strategy for generating network fabrics by combining virtual and physical topologies. It operates on policies and predicates from the `Syntax` module, constructing fabrics as pairs of policy lists that represent ingress and egress rules. Concrete use cases include synthesizing network configurations that enforce security policies while modeling adversarial behavior in virtualized environments.",
      "description_length": 444,
      "index": 230,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_netkat.Domain.Field",
      "library": "frenetic.netkat",
      "description": "This module defines operations for comparing and ordering field values within a domain, specifically using the `compare` function and a comparator witness. It works with the `Frenetic_netkat.Domain.Field.t` type, which represents individual field values in a domain. Concrete use cases include determining equivalence or ordering of packet fields in network policies or automata transitions.",
      "description_length": 391,
      "index": 231,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.Domain",
      "library": "frenetic.netkat",
      "description": "This module tracks the domain of packet fields by collecting all values that appear in tests or modifications within an FDD or automaton. It provides operations to merge domains, compute representatives for equivalence classes, and extract packet samples. It works with field values mapped to sets of 64-bit integers, structured as a map over packet fields. Use cases include domain analysis for network policy compilation and generating test packets from automata.",
      "description_length": 465,
      "index": 232,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.Local_compiler",
      "library": "frenetic.netkat",
      "description": "This module provides operations for compiling and optimizing network policies into flow tables, using hierarchical decision diagrams (`FDD.t`) to represent packet-processing logic with branching nodes. It supports policy transformations via sequential and parallel composition, restriction, and extraction of forwarding rules, alongside serializing configurations and evaluating packet behavior against compiled policies. Key use cases include translating NetKAT policies into switch-executable flow tables, generating multi-table configurations with group tables, and exporting policy representations for debugging or storage.",
      "description_length": 627,
      "index": 233,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.Optimize",
      "library": "frenetic.netkat",
      "description": "This module provides functions to construct and manipulate network policies and predicates, including logical operations (AND, OR, NOT), policy composition (sequence, union, Kleene star), and normalization. It works with predicates and policies in the NetKAT language, representing network packet tests and packet forwarding rules. Concrete use cases include building optimized firewall rules, routing policies, and packet classification systems.",
      "description_length": 446,
      "index": 234,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.Lexer",
      "library": "frenetic.netkat",
      "description": "This module defines a set of lexical tokens and parsing functions for processing NetKAT-like input. It includes token types for keywords, identifiers, literals, and operators, along with functions to parse input from buffers, strings, or files into these tokens. It is used to implement the initial stage of a parser for network policies or packet processing rules written in a domain-specific language.",
      "description_length": 403,
      "index": 235,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.Virtual_Compiler",
      "library": "frenetic.netkat",
      "description": "This module generates and compiles virtual network policies by constructing a fabric from virtual and physical topologies. It provides operations for fabric generation, policy compilation using precomputed fabrics, and translating high-level policies into low-level forwarding rules. Use cases include enforcing virtual routing logic in software-defined networking environments and managing network isolation and traffic control across distributed systems.",
      "description_length": 456,
      "index": 236,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.Fdd",
      "library": "frenetic.netkat",
      "description": "This module implements Forwarding Decision Diagrams (FDDs) for modeling and transforming network forwarding policies using field-value tests and OpenFlow actions. It operates on structured packet headers, policy expressions, and action sequences to enable efficient compilation of NetKAT programs into optimized SDN flow tables. Concrete use cases include policy normalization, packet classification, and flow table generation with support for structural analysis and caching.",
      "description_length": 476,
      "index": 237,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.Tokens",
      "library": "frenetic.netkat",
      "description": "This module defines a comprehensive set of lexical tokens used for parsing and representing the syntax of the Frenetic network programming language. It includes tokens for control structures (e.g., `IF`, `THEN`, `ELSE`, `WHILE`), network-specific primitives (e.g., `VSWITCH`, `VPORT`, `VLAN`, `IP4SRC`, `ETHDST`), arithmetic and logical operators (e.g., `PLUS`, `STAR`, `AND`, `OR`), and literals (e.g., `INT`, `STRING`, `MAC`). These tokens are used directly by the parser to construct abstract syntax trees for network policies and packet-processing programs.",
      "description_length": 561,
      "index": 238,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_netkat.Vlr",
      "library": "frenetic.netkat",
      "description": "This module implements a hash table for storing and retrieving integer pairs with efficient lookup and insertion. It provides operations to create, query, and manipulate mappings from integer pairs to arbitrary values. Useful for managing flow entries in network applications where fast access to bidirectional flow information is required.",
      "description_length": 340,
      "index": 239,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_netkat.Semantics",
      "library": "frenetic.netkat",
      "description": "This module implements packet evaluation and analysis for network policies, operating on packets that include switch identifiers, structured headers, and payloads. It provides functions to apply policies to packets, extract query and switch identifiers from policies, and compute policy size. Concrete use cases include processing PACKET_IN messages in a runtime system, applying VLAN transformations, and generating packet traces for network monitoring or debugging.",
      "description_length": 467,
      "index": 240,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.LexBuffer",
      "library": "frenetic.netkat",
      "description": "This module provides a lexbuffer implementation that tracks source positions and characters during lexical analysis. It supports operations to mark and backtrack positions, retrieve the next character or its location, and initialize buffers from strings or files with optional position tracking. It works directly with UTF-8 character streams and is used for precise error reporting and source mapping in parsers.",
      "description_length": 413,
      "index": 241,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.Bisim",
      "library": "frenetic.netkat",
      "description": "Implements bisimilarity checking between two automata using the Hopcroft-Karp algorithm. Operates directly on automaton structures defined in the Global_compiler module. Useful for verifying equivalence of network packet processing pipelines represented as finite automata.",
      "description_length": 273,
      "index": 242,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.FabricGen",
      "library": "frenetic.netkat",
      "description": "This module implements a two-player adversarial strategy for generating network fabrics by combining virtual and physical topologies. It operates on policies and predicates, constructing fabrics as pairs of policy lists representing ingress and egress rules. It is used to synthesize network configurations that enforce security policies while modeling adversarial behavior in virtualized environments.",
      "description_length": 402,
      "index": 243,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.Packet",
      "library": "frenetic.netkat",
      "description": "This module represents network packets as maps from fields to 64-bit integer values, supporting operations such as applying flow decision diagrams (FDDs), evaluating actions, and serializing packets. It works with fields like source and destination IP addresses, ports, and protocols, enabling precise packet classification and forwarding. Concrete use cases include processing and filtering packets in software-defined networking applications based on specific field values and flow rules.",
      "description_length": 490,
      "index": 244,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.Syntax",
      "library": "frenetic.netkat",
      "description": "This module provides operations for constructing and manipulating NetKAT's core syntax elements, including network locations, header values, predicates, policy expressions, and metadata. It works with structured data types like identifiers for switches, ports, virtual switches, and hosts, along with serialization/deserialization routines for S-expressions and JSON. These capabilities enable use cases such as compiling policies into flow tables, parsing network rules from strings, and modeling virtual or physical network topologies with precise metadata handling.",
      "description_length": 568,
      "index": 245,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.Pretty",
      "library": "frenetic.netkat",
      "description": "This module provides functions to format and convert network policies and predicates into human-readable strings. It works with the `policy` and `pred` types defined in the `Frenetic_netkat.Syntax` module. Use cases include debugging policy transformations, logging rule sets, and displaying network logic in a structured format.",
      "description_length": 329,
      "index": 246,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_netkat.Parser",
      "library": "frenetic.netkat",
      "description": "Parses NetKAT policies and predicates from strings or files into syntax trees, omitting port information. It converts string or file input into policy and predicate values, supporting direct loading of NetKAT configurations for network control applications. Useful for translating external NetKAT specifications into executable logic for network management tasks.",
      "description_length": 363,
      "index": 247,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.Generated_Parser",
      "library": "frenetic.netkat",
      "description": "This module provides functions for parsing network policies and predicates from input streams using a generated parser. It processes tokens produced by the `Frenetic_netkat.Lexer` to construct abstract syntax trees representing policies and logical conditions. Concrete use cases include parsing NetKAT policy expressions and predicate logic from configuration files or network management interfaces.",
      "description_length": 400,
      "index": 248,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_netkat.Portless_Compiler",
      "library": "frenetic.netkat",
      "description": "Compiles a network policy that does not specify port information into one that does, using a given network topology. It transforms high-level, port-agnostic policies into concrete, port-specific policies based on the structure of the network. This enables the execution of policies on real network devices that require explicit port identifiers.",
      "description_length": 345,
      "index": 249,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.Json",
      "library": "frenetic.netkat",
      "description": "This module serializes and deserializes NetKAT policies and OpenFlow messages to and from JSON. It supports conversion of policy types, header values, pseudoports, flow tables, and packet events between their in-memory representations and JSON structures. Concrete use cases include transmitting NetKAT policies over networks, persisting switch state, and parsing controller events in JSON format.",
      "description_length": 397,
      "index": 250,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.Global_compiler",
      "library": "frenetic.netkat",
      "description": "This module compiles NetKAT policies into FDDs (Flow Decision Diagrams) that represent network policies as decision diagrams over field-value pairs and actions. It uses an automaton-based intermediate representation to manage transitions between states and optimize policy execution. The `compile` function takes a policy and optional parameters to produce a compiled FDD, enabling concrete use cases such as modeling packet processing pipelines, optimizing policy evaluation, and generating visual representations of network policies.",
      "description_length": 535,
      "index": 251,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.Portless_Generated_Parser",
      "library": "frenetic.netkat",
      "description": "This module provides functions for parsing network policies and predicates from lexing buffers, producing values of type `Frenetic_netkat.Syntax.policy` and `Frenetic_netkat.Syntax.pred`. It operates on `token` values via a lexer function and is used to parse policy and predicate expressions until end-of-file. Concrete use cases include loading and interpreting NetKAT policy files or string inputs in a portless context.",
      "description_length": 423,
      "index": 252,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Netkat.Fdd.Action.Seq.Tree.Provide_of_sexp",
      "library": "frenetic",
      "description": "Converts S-expressions into FDD action sequence trees, using a provided function to parse leaf actions. Works with Frenetic.Netkat.Fdd.Action.Seq.Tree.t structures, which represent sequences of OpenFlow actions in decision diagrams. Useful for deserializing NetKAT policy configurations from S-expressions into executable flow tables.",
      "description_length": 334,
      "index": 253,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.Netkat.Fdd.Action.Par.Tree.Named",
      "library": "frenetic",
      "description": "This module implements parallel composition and comparison operations for named action FDDs, specifically supporting equivalence checking and subset verification between flow decision diagrams. It operates on structured flow tables represented as decision trees with named actions at the leaves, derived from NetKAT policies. Concrete use cases include verifying network policy containment and ensuring consistent forwarding behavior across different network configurations.",
      "description_length": 474,
      "index": 254,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Netkat.Fdd.Action.Par.Tree.Provide_of_sexp",
      "library": "frenetic",
      "description": "Converts S-expressions into FDD action trees, enabling the construction of complex forwarding decision diagrams from serialized representations. Works with OpenFlow actions and header match data structures. Useful for parsing pre-defined network policies or configurations stored in S-expression format into executable FDDs.",
      "description_length": 324,
      "index": 255,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Netkat.Global_compiler.FDD.Tbl.Provide_of_sexp",
      "library": "frenetic",
      "description": "This module implements a function `t_of_sexp` that parses S-expressions into FDD tables, using a provided conversion function for values. It works with FDD structures parameterized over a key type, where keys are derived from the `Key` module. It is used to construct FDD-based mappings from S-expression input, such as when loading configurations or policies serialized in S-expresssion format.",
      "description_length": 395,
      "index": 256,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.Netkat.Fdd.Action.Seq.Key",
      "library": "frenetic",
      "description": "This module defines a key type for sequences of OpenFlow actions within a Forwarding Decision Diagram (FDD). It supports efficient comparison and serialization operations for use in map and set data structures. The key type represents either a field or a continuation in the FDD structure, enabling precise control over flow table generation and manipulation.",
      "description_length": 359,
      "index": 257,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Netkat.Fdd.FDD.Tbl.Provide_of_sexp",
      "library": "frenetic",
      "description": "This module implements a table structure for mapping keys to FDD-based values, where each key corresponds to a specific field in the packet header. It provides functionality to construct and manipulate these tables using S-expressions, enabling serialization and deserialization of FDD tables for storage or transmission. Concrete use cases include compiling NetKAT policies into efficient forwarding decision diagrams and generating flow tables for software-defined networking switches.",
      "description_length": 487,
      "index": 258,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Netkat.Local_compiler.FDD.Tbl.Provide_bin_io",
      "library": "frenetic",
      "description": "This module implements binary serialization and deserialization for FDD-based tables indexed by a `Key` type. It provides functions to convert FDD tables to and from binary representations using the Bin_prot library, supporting efficient storage and transmission. Use cases include persisting FDD tables to disk or sending them over a network.",
      "description_length": 343,
      "index": 259,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Netkat.Global_compiler.FDD.BinTbl.Provide_of_sexp",
      "library": "frenetic",
      "description": "This module implements a function `t_of_sexp` that parses S-expressions into FDD-based binary tables using a provided key conversion function. It operates on data types involving S-expressions and FDD structures parameterized by a key type. A concrete use case is deserializing network policy rules represented as S-expressions into an optimized FDD-based decision diagram for efficient packet classification.",
      "description_length": 409,
      "index": 260,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Netkat.Fdd.FDD.BinTbl.Provide_of_sexp",
      "library": "frenetic",
      "description": "This module provides functions to convert S-expressions into binary decision tables with OpenFlow actions, using a specified key module for field ordering. It operates on data structures representing flow decision diagrams, where each node corresponds to a packet header field match and leaves represent forwarding actions. It is used to parse serialized NetKAT policies into executable flow tables for network switches.",
      "description_length": 420,
      "index": 261,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Netkat.Fdd.Action.Par.Provide_hash",
      "library": "frenetic",
      "description": "This module implements hash functions for FDD action parallel structures, enabling efficient comparison and caching of flow table entries. It operates on `Frenetic.Netkat.Fdd.Action.Par.t` values, which represent sets of OpenFlow actions in NetKAT's FDD-based compilation pipeline. Concrete use cases include optimizing flow table generation by detecting and eliminating duplicate action sets during switch rule installation.",
      "description_length": 425,
      "index": 262,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Netkat.Fdd.Action.Par.Tree",
      "library": "frenetic",
      "description": "This module provides set operations and ordered tree manipulations for managing collections of NetKAT action elements (`Frenetic.Netkat.Fdd.Action.Par.Elt.t`) and flow decision diagrams (FDDs) structured as binary trees. It supports policy analysis tasks like network equivalence checking and flow table transformation by enabling efficient union, intersection, and ordering operations on FDDs with named actions, while also handling conversions between tree representations and linear data structures (lists, arrays, S-expressions). Key use cases include optimizing OpenFlow policy configurations, deduplicating action sets, and serializing/deserializing structured flow tables for network verification workflows.",
      "description_length": 714,
      "index": 263,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Netkat.Global_compiler.FDD.Tbl.Provide_bin_io",
      "library": "frenetic",
      "description": "This module implements binary serialization and deserialization for FDD-based tables parameterized by a key type. It provides functions to compute binary shapes, sizes, and to read/write FDD tables to binary streams. These operations support efficient storage and transmission of FDD structures used in network policy compilation.",
      "description_length": 330,
      "index": 264,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Netkat.Fdd.Action.Seq.Provide_of_sexp",
      "library": "frenetic",
      "description": "This module defines a function `t_of_sexp` that parses S-expressions into values of type `Frenetic.Netkat.Fdd.Action.Seq.t`, which represents sequences of OpenFlow actions within Forwarding Decision Diagrams. It works with S-expressions and action sequences, enabling the deserialization of structured action representations used in FDD construction. A concrete use case is loading pre-defined OpenFlow action sequences from configuration files or external inputs into an FDD-based compiler pipeline.",
      "description_length": 500,
      "index": 265,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.Netkat.Local_compiler.FDD.Tbl.Provide_of_sexp",
      "library": "frenetic",
      "description": "This module implements a function `t_of_sexp` that parses S-expressions into FDD tables, using a provided conversion function for values. It works with FDD structures parameterized over a key type, where keys are derived from the `Key` module. A concrete use case is deserializing network policy rules represented as S-expressions into an FDD-based decision diagram for packet processing.",
      "description_length": 388,
      "index": 266,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Netkat.Fdd.Action.Par.Provide_bin_io",
      "library": "frenetic",
      "description": "This module implements binary serialization and deserialization for FDD action parallel structures, handling conversion to and from binary formats with precise size calculation, reading, and writing operations. It works directly with `Frenetic.Netkat.Fdd.Action.Par.t`, a type representing sets of OpenFlow actions in parallel within a decision diagram context. Concrete use cases include persisting compiled FDDs to disk or transmitting them over a network in a compact binary form for efficient storage or communication.",
      "description_length": 522,
      "index": 267,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.Netkat.Local_compiler.FDD.BinTbl.Provide_bin_io",
      "library": "frenetic",
      "description": "This module implements binary serialization and deserialization for FDD-based tables parameterized by a key type. It provides functions to compute binary shapes, size, write, and read FDD tables, along with bin reader and writer type class instances. Concrete use cases include persisting FDD tables to disk or transmitting them over a network in a binary format.",
      "description_length": 363,
      "index": 268,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Netkat.Fdd.Action.Par.Elt",
      "library": "frenetic",
      "description": "This module represents actions in a parallel context within a Forwarding Decision Diagram (FDD), where each action corresponds to OpenFlow operations applied to network packets. It provides functions for serializing and deserializing action sequences, as well as a comparator for ordering elements during FDD manipulation. It is used when compiling NetKAT policies into efficient flow tables that can be deployed on SDN switches.",
      "description_length": 429,
      "index": 269,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Netkat.Fdd.Action.Seq.Tree",
      "library": "frenetic",
      "description": "This module provides operations for constructing, transforming, and querying immutable tree-based maps that associate keys of type `Frenetic.Netkat.Fdd.Action.Seq.Key.t` with arbitrary values, optimized for representing OpenFlow action sequences in Forwarding Decision Diagrams (FDDs). The data structure supports efficient functional manipulation through folding, mapping, filtering, and structural comparison, alongside validation, error propagation, and bulk processing, ensuring strict key uniqueness and correctness. It is used to compile NetKAT policies into flow tables by enabling precise management of action sequences and maintaining efficient FDD representations under field-ordering constraints.",
      "description_length": 707,
      "index": 270,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Netkat.Fdd.Action.Seq.Provide_bin_io",
      "library": "frenetic",
      "description": "This module implements binary serialization and deserialization for sequence actions within a decision diagram structure. It operates on types involving `Frenetic.Netkat.Fdd.Action.Seq.t`, enabling efficient storage and transmission of flow table configurations derived from NetKAT programs. Concrete use cases include persisting compiled forwarding rules to disk or sending them over a network to a switch.",
      "description_length": 407,
      "index": 271,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Netkat.Fdd.FDD.Tbl.Provide_bin_io",
      "library": "frenetic",
      "description": "This module implements binary serialization and deserialization for FDD-based flow tables indexed by a key type. It operates on FDD structures extended with table mappings, enabling efficient storage and transmission of compiled NetKAT policies. Concrete use cases include persisting flow tables to disk or sending them over a network in a compact binary format.",
      "description_length": 362,
      "index": 272,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Netkat.Fdd.Action.Par.Named",
      "library": "frenetic",
      "description": "This module provides operations to compare and validate relationships between named OpenFlow actions within a Forwarding Decision Diagram (FDD). It works directly with `Frenetic.Netkat.Fdd.Action.Par.named` values, which represent structured sequences of OpenFlow actions annotated with names. Concrete use cases include verifying that one action sequence is a subset of another, or ensuring two named action sequences are semantically equivalent, which is critical when compiling NetKAT policies into efficient OpenFlow tables.",
      "description_length": 528,
      "index": 273,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Netkat.Global_compiler.FDD.BinTbl.Provide_bin_io",
      "library": "frenetic",
      "description": "This module implements binary serialization and deserialization for FDD-based tables parameterized by a key type. It provides functions to compute binary shapes, sizes, and to read and write FDD tables in binary format, specifically handling values of type `'a Frenetic.Netkat.Global_compiler.FDD.BinTbl.t`. These operations are used to efficiently store, transmit, or reconstruct FDD tables in network applications such as packet classification and policy compilation.",
      "description_length": 469,
      "index": 274,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Netkat.Semantics.HeadersValues.Fields.Direct",
      "library": "frenetic",
      "description": "This module directly manipulates packet header fields such as Ethernet source/destination, VLAN tags, IP addresses, and TCP ports. It provides operations to iterate, fold, map, and query specific header values within a `HeadersValues.t` map. Use cases include packet classification, header modification, and network policy enforcement based on specific field values.",
      "description_length": 366,
      "index": 275,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Netkat.Fdd.Action.Par.Provide_of_sexp",
      "library": "frenetic",
      "description": "Converts S-expressions into parallel action values, specifically handling the deserialization of OpenFlow action lists. Works with NetKAT FDD action structures represented as S-expressions. Useful for parsing stored or transmitted FDD configurations back into executable flow tables.",
      "description_length": 283,
      "index": 276,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Netkat.Fdd.Action.Seq.Provide_hash",
      "library": "frenetic",
      "description": "This module implements hash folding for sequences of OpenFlow actions in Forwarding Decision Diagrams (FDDs), enabling efficient hashing of action sequences during FDD compilation. It works directly with FDD action sequences and leverages a key module to define hashable action types. Concrete use cases include optimizing flow table generation by identifying and deduplicating equivalent action sequences, improving performance in NetKAT-to-OpenFlow translation.",
      "description_length": 463,
      "index": 277,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.Netkat.Fdd.FDD.BinTbl.Provide_bin_io",
      "library": "frenetic",
      "description": "This module implements binary serialization and deserialization for FDD (Forwarding Decision Diagram) tables indexed by a key type. It provides functions to compute the binary shape, size, and perform read/write operations for FDD tables, enabling efficient storage and transmission of compiled flow tables. Concrete use cases include persisting NetKAT policy transformations to disk or sending them over a network in a compact binary format.",
      "description_length": 442,
      "index": 278,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Netkat.Local_compiler.FDD.BinTbl.Provide_of_sexp",
      "library": "frenetic",
      "description": "This module implements a function `t_of_sexp` that parses S-expressions into FDD-based binary tables, using a provided key conversion function. It operates on S-expressions and constructs values of type `'a Frenetic.Netkat.Local_compiler.FDD.BinTbl.t`, leveraging the structure defined by the parent FDD module. A typical use case involves deserializing network policy rules represented in S-expression format into efficient FDD-based decision tables for packet processing.",
      "description_length": 473,
      "index": 279,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Net.Net.Topology.Vertex",
      "library": "frenetic",
      "description": "This module defines operations for representing and manipulating vertices in a network topology. It provides functions to convert vertices to and from various formats (like S-expressions, DOT, and GML), compare vertices, and generate string representations for visualization and simulation. It works directly with network nodes, enabling use cases such as parsing topology descriptions from DOT or GML files and exporting them for tools like Mininet or graph visualizers.",
      "description_length": 471,
      "index": 280,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Net.Net.Topology.Edge",
      "library": "frenetic",
      "description": "This module represents edges in a network topology, providing functions to convert edges to and from S-expressions, compare edges, and serialize them to string and DOT formats. It supports parsing edges from DOT and GML attribute lists and includes a default edge value. It is used for modeling and manipulating network links in graph-based network analysis tools.",
      "description_length": 364,
      "index": 281,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Network.Net.Topology.Edge",
      "library": "frenetic",
      "description": "This module represents and manipulates edges in a network topology, providing functions to convert edges to and from S-expressions, compare edges, generate string and DOT format representations, and parse edges from DOT and GML attribute lists. It works with the `Frenetic.Network.Link.t` type, which models network links as edges in a graph structure. Concrete use cases include serializing and deserializing network topologies, generating visualizations in DOT format, and maintaining consistent edge representations across network analysis and visualization tools.",
      "description_length": 567,
      "index": 282,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.Netkat.Fdd.FDD.BinTbl",
      "library": "frenetic",
      "description": "This module enables efficient management and transformation of hash tables where keys are composed of pairs of binary decision diagrams (FDDs) extended with OpenFlow actions, supporting operations like merging, filtering, and in-place modification. It provides utilities for constructing tables from association lists, resolving key collisions through customizable strategies, and serializing or deserializing FDD-based policies for network flow compilation. Designed for network policy processing, it facilitates tasks such as translating NetKAT programs into optimized flow tables while leveraging functional patterns for safe, deterministic transformations.",
      "description_length": 660,
      "index": 283,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Topology.Net.Topology.Edge",
      "library": "frenetic",
      "description": "This module defines operations for representing and manipulating network edges, including parsing from and converting to formats like DOT and GML. It works directly with edge data structures that model network links, supporting tasks like comparison, serialization, and string representation. Concrete use cases include converting edge data to DOT format for visualization or parsing edge attributes from configuration files.",
      "description_length": 425,
      "index": 284,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Topology.Net.Topology.Vertex",
      "library": "frenetic",
      "description": "This module defines a vertex type used in network topology representations, based on node identifiers. It provides functions for converting vertices to and from S-expressions, comparing vertices, and serializing them to formats like DOT and Mininet. It also includes parsers for constructing vertices from DOT and GML AST structures, enabling integration with graph description languages.",
      "description_length": 388,
      "index": 285,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Network.Net.Topology.UnitWeight",
      "library": "frenetic",
      "description": "This module defines a unit weight type and operations for weighted edges in a network topology. It provides functions to convert weights to and from S-expressions, compare weights, add weights, and retrieve the weight of an edge. The module works with integer weights and edges that incorporate these weights, enabling precise control over path calculations in routing algorithms.",
      "description_length": 380,
      "index": 286,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Network.Net.Topology.Vertex",
      "library": "frenetic",
      "description": "This module defines operations for representing and manipulating vertices in a network topology. It provides functions to convert vertices to and from various formats (like S-expressions, DOT, and GML), compare vertices, and generate string representations for visualization and Mininet configuration. It works directly with network nodes, enabling use cases such as topology serialization, graph visualization, and integration with network simulation tools.",
      "description_length": 458,
      "index": 287,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.OpenFlow0x04.Hello.Element.VersionBitMap",
      "library": "frenetic",
      "description": "This module handles the Supported Version Bitmap structure, which encodes the OpenFlow protocol versions supported by a switch during the Hello handshake. It provides functions to parse and serialize version bitmaps, as well as compute their size and generate string representations. It operates on `supportedList` values, which are lists of OpenFlow version numbers.",
      "description_length": 367,
      "index": 288,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.Netkat.Fdd.Action.Par",
      "library": "frenetic",
      "description": "This module provides set operations (union, intersection, difference) and ordered tree manipulations for structured analysis of parallel OpenFlow actions in FDDs, focusing on transformations like filtering, element selection, and conversion between data structures. It operates on sets of individual actions (`Elt.t`) and ordered collections (`Par.t`), supporting use cases such as optimizing SDN flow tables, compiling NetKAT policies, and enabling efficient serialization, hashing, and comparison for FDD-based network decision diagrams.",
      "description_length": 539,
      "index": 289,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x01.PortDescription.PortState.StpState",
      "library": "frenetic",
      "description": "This module defines operations to convert Spanning Tree Protocol (STP) state values between integer representations and human-readable strings. It provides `of_int`, `to_int`, and `to_string` functions to work with the `stpState` type, which represents the STP state of a switch port. These functions enable parsing and serializing STP state values when handling OpenFlow 1.0 port description messages.",
      "description_length": 402,
      "index": 290,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Topology.Net.Topology.UnitWeight",
      "library": "frenetic",
      "description": "This module defines a unit weight type as an integer and provides functions to manipulate weighted edges in a network topology. It includes operations for adding weights, comparing them, and serializing or deserializing edge data to and from S-expressions. Concrete use cases include representing and processing link weights in network routing or graph analysis tasks.",
      "description_length": 368,
      "index": 291,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Netkat.Fdd.Field.Env",
      "library": "frenetic",
      "description": "Maps NetKAT meta field identifiers to FDD fields, tracking initializer values and mutability flags. Provides operations to add and look up field bindings in the environment. Used during FDD construction to manage header field metadata and initialization constraints.",
      "description_length": 266,
      "index": 292,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Netkat.Semantics.HeadersValues.Fields",
      "library": "frenetic",
      "description": "This module enables structured, type-safe access and transformation of network packet headers through field-specific operations on a `HeadersValues.t` map, which stores typed values like `dlAddr`, `nwAddr`, and `tpPort`. It supports use cases such as packet filtering, policy evaluation, and header rewriting by providing precise accessors, bulk transformations via `map`, and iterative processing with `fold` or quantification functions. The design emphasizes correctness through strong typing while enabling efficient introspection and manipulation of packet metadata in network applications.",
      "description_length": 594,
      "index": 293,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.Netkat.Global_compiler.FDD.Tbl",
      "library": "frenetic",
      "description": "This module implements imperative and functional hash table operations for key-value stores where keys are derived from FDD (Variable-Lattice-Result) structures, a specialized representation for network policy decision diagrams. It supports polymorphic key-value pairs with advanced transformations like conflict-resolution merging, multi-value aggregation, and predicate-based filtering, alongside serialization for network configuration persistence. The design enables efficient manipulation of dynamic policy data through in-place mutations and pure functional updates, tailored for high-performance network control plane applications.",
      "description_length": 638,
      "index": 294,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Netkat.Fdd.Action.Seq",
      "library": "frenetic",
      "description": "This module provides operations for constructing, transforming, and serializing sequences of key-value pairs where keys represent FDD action fields or continuations (`Key.t`) and values are arbitrary data. It supports efficient manipulation of ordered OpenFlow action sequences through functions like splitting, merging, filtering, and ranked access, while ensuring compatibility with FDD compilation workflows that require structured queries and persistence via S-expressions or binary formats. Typical use cases include optimizing network policy representations in NetKAT-to-Flow-Table compilation pipelines and managing hierarchical action data in decision diagrams.",
      "description_length": 669,
      "index": 295,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Netkat.Fdd.FDD.Tbl",
      "library": "frenetic",
      "description": "This module provides hash table operations for managing key-value pairs where keys are Forwarding Decision Diagrams (FDDs) representing NetKAT predicates with OpenFlow actions. It supports functional and imperative manipulation, including in-place transformations, merging, filtering, and counter operations, alongside serialization via S-expressions and binary I/O. The structure is optimized for compiling NetKAT policies into efficient flow tables for SDN switch configuration, leveraging FDDs' BDD-based efficiency for scalable packet-processing logic.",
      "description_length": 556,
      "index": 296,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Net.Net.Topology.UnitWeight",
      "library": "frenetic",
      "description": "This module defines a weight type for edges in a network topology, where weights are represented as integers. It provides functions to serialize and deserialize weights and edges, retrieve the weight of an edge, and perform comparisons and addition on weights. Concrete use cases include managing link costs in routing algorithms and tracking edge metrics in network graphs.",
      "description_length": 374,
      "index": 297,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Netkat.Local_compiler.FDD.BinTbl",
      "library": "frenetic",
      "description": "This module implements associative containers for binary decision diagrams (FDDs) where keys are FDD pairs and values are arbitrary data, supporting imperative and functional transformations like merging, filtering, and key-aware mapping. It provides specialized operations for network policy compilation, including multi-value lookups, serialization to S-expressions/binary formats, and integer counter manipulations with zero-crossing removal semantics. The structure enables efficient rule processing through FDD-based grouping and invariant-preserving transformations while maintaining compatibility with network policy transmission workflows.",
      "description_length": 647,
      "index": 298,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.Network.Make.Topology.UnitWeight",
      "library": "frenetic",
      "description": "This module implements a unit-weighted graph topology with edges represented as integers. It provides functions to serialize and deserialize edge weights, compare and sum weights, and retrieve the zero weight value. The module is used to model network topologies where each edge has a uniform cost, enabling shortest-path calculations and other graph algorithms that rely on consistent edge weights.",
      "description_length": 399,
      "index": 299,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x01.FlowMod.Command",
      "library": "frenetic",
      "description": "This module defines operations for converting flow modification commands to and from string and integer representations. It works with the `flowModCommand` type and 16-bit integers. Concrete use cases include serializing commands for network transmission and parsing incoming integer codes into actionable command types.",
      "description_length": 320,
      "index": 300,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.Async.NetKAT_Controller.Make",
      "library": "frenetic",
      "description": "This module implements a controller for managing OpenFlow switches, providing operations to initialize the controller on a TCP port, retrieve network events, and inspect or modify switch behavior. It works with OpenFlow switches, ports, and policies, allowing updates to local or global forwarding rules using either high-level policies or FDD representations. Concrete use cases include monitoring port statistics, dynamically updating packet forwarding logic, and injecting packets into the network with specified policies.",
      "description_length": 525,
      "index": 301,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Topology.Net.Parse",
      "library": "frenetic",
      "description": "This module parses network topologies from DOT and GML file formats. It converts string representations of graphs into structured topology objects. Use this when loading predefined network layouts from external configuration files for simulation or analysis.",
      "description_length": 258,
      "index": 302,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.Packet.Tcp.Flags",
      "library": "frenetic",
      "description": "This module defines a record type representing the 9 TCP header flags, such as `syn`, `ack`, and `fin`, each as a boolean. It provides functions to convert between this type and S-expressions for serialization and parsing. Use this module when inspecting or constructing TCP packets to check or set control flags, such as determining if a packet initiates a connection (`syn`) or terminates it (`fin`).",
      "description_length": 402,
      "index": 303,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.Netkat.Semantics.HeadersValues",
      "library": "frenetic",
      "description": "This module provides structured access to packet headers with typed fields, enabling operations like field-specific access, serialization to S-expressions, and conversion to string or tuple-based representations. It works with a record type that models network packet metadata as key-value pairs, offering type-safe manipulation through a field-oriented interface. These capabilities are particularly useful for network applications such as packet classification, software-defined networking (SDN), and protocol-aware traffic processing.",
      "description_length": 537,
      "index": 304,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow.Pattern.Ip",
      "library": "frenetic",
      "description": "This module represents and manipulates IP address patterns with CIDR-style masks for use in OpenFlow packet processing. It supports operations like matching, comparison, joining, and intersection of IP patterns to enable precise packet classification and flow control. Concrete use cases include defining flow table entries that match specific IP ranges, merging overlapping patterns, and checking compatibility between rules.",
      "description_length": 426,
      "index": 305,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.Netkat.Global_compiler.Automaton",
      "library": "frenetic",
      "description": "This module represents and manipulates NetKAT automata as an intermediate form during global compilation. It supports operations like adding transitions between states, folding over reachable states, converting policies to automata, and rendering automata into visual formats. The automaton structure uses FDDs (Flow Decision Diagrams) to encode packet and cache state transitions, enabling precise control plane modeling and optimization.",
      "description_length": 439,
      "index": 306,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Async.Ox.Make",
      "library": "frenetic",
      "description": "This module builds an Ox controller that listens on port 6633 for OpenFlow messages from network switches and routes them to the provided `OxModule` callbacks. It operates with the `OxModule` module, which defines the handler logic for switch events and messages. Use this to implement custom OpenFlow control logic, such as custom routing or network monitoring, by defining the message handling behavior in the `OxModule`.",
      "description_length": 423,
      "index": 307,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Topology.Net.Topology",
      "library": "frenetic",
      "description": "This module enables constructing, modifying, and querying graph-based network topologies with vertices representing nodes, edges modeling connections, and ports capturing interface-level details. It provides set and hash table utilities for managing collections of vertices, edges, and ports, along with traversal operations to explore neighbor relationships or map elements to labels. Typical applications include network modeling, port-aware graph traversal, and transformation tasks requiring precise control over node and connection relationships.",
      "description_length": 551,
      "index": 308,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x01.SwitchFeatures.SupportedActions",
      "library": "frenetic",
      "description": "This module represents the set of actions supported by an OpenFlow switch, with each field indicating whether a specific action like output, VLAN modification, or enqueue is supported. It works with the `Action.t` type and provides serialization and pretty-printing functions for inspecting or transmitting switch capabilities. Use this module to query or configure switch behavior in response to flow table matches, such as determining if a packet can be redirected or modified.",
      "description_length": 479,
      "index": 309,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.Netkat.Domain.Field",
      "library": "frenetic",
      "description": "This module defines operations for comparing and ordering field values within a domain, specifically using the `compare` function and a comparator witness. It works with the `t` type, representing fields in an FDD or Automaton domain. Concrete use cases include determining field value equivalence and ordering in decision diagrams or automaton transitions.",
      "description_length": 357,
      "index": 310,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Packet.Dns.Rr",
      "library": "frenetic",
      "description": "This module defines DNS resource record operations for parsing and constructing DNS packet payloads. It works with DNS resource records (`t`) containing name, type, class, TTL, and raw data fields. Concrete use cases include extracting domain information and handling DNS response data in network monitoring or packet manipulation tasks.",
      "description_length": 337,
      "index": 311,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Net.Net.UnitPath",
      "library": "frenetic",
      "description": "This module computes shortest paths in a network topology, providing functions to find individual shortest paths, all shortest paths from a source, and all pairs of shortest paths with optional filtering. It operates on graph structures represented by vertices and edges, with paths returned as lists of edges and associated integer weights. Concrete use cases include network routing analysis and path selection in software-defined networking scenarios.",
      "description_length": 454,
      "index": 312,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Topology.Net.UnitPath",
      "library": "frenetic",
      "description": "This module computes shortest paths in a network topology, providing functions to find individual paths, all shortest paths from a source, and all-pairs shortest paths with edge lists. It operates on graph structures defined by vertices and edges from the Topology module, using integer weights to represent path costs. Concrete use cases include network routing analysis and path optimization in software-defined networking.",
      "description_length": 425,
      "index": 313,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x01.PortDescription.PortState",
      "library": "frenetic",
      "description": "This module defines conversions for the OpenFlow 1.0 port state values, enabling parsing and serialization of port state flags. It provides `of_int`, `to_int`, and `to_string` functions to work with the `portState` type, which encodes the operational status of a switch port, including link status and STP state. These functions are used when processing port description messages to interpret or generate port state fields.",
      "description_length": 423,
      "index": 314,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Net.Net.Topology",
      "library": "frenetic",
      "description": "This module provides operations for constructing, querying, and modifying graph-based network topologies through vertices, edges, ports, and their relationships. It supports adjacency checks, connectivity analysis, label-to-element mapping, and traversal/transformation of graph structures, while also enabling set operations and hashing for efficient element management. These capabilities are designed for applications like network simulation, performance analysis, and visualization tools where dynamic topology manipulation and inspection are critical.",
      "description_length": 556,
      "index": 315,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.OpenFlow0x01.Error.QueueOpFailed",
      "library": "frenetic",
      "description": "This module defines error codes for queue operation failures in OpenFlow 1.0, specifically `BadPort`, `BadQueue`, and `Eperm`. It provides functions to convert these errors to and from S-expressions and to convert them to human-readable strings. These values are used to signal specific error conditions during queue management operations, such as invalid port or queue identifiers.",
      "description_length": 382,
      "index": 316,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Network.Net.Parse",
      "library": "frenetic",
      "description": "Converts network topologies from external file formats into an internal representation. It parses DOT and GML files to construct a Topology.t data structure modeling network graphs. Useful for loading predefined network layouts into network simulation or analysis tools.",
      "description_length": 270,
      "index": 317,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Network.Make.Path",
      "library": "frenetic",
      "description": "This module computes shortest paths in a network topology using a specified weight type. It provides functions to find the shortest path between two vertices, all shortest paths from a source vertex, and all pairs of shortest paths in the topology. The module works directly with edge lists, vertices, and a weight abstraction to support concrete use cases like routing optimization and network analysis.",
      "description_length": 404,
      "index": 318,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Packet.Ip.Flags",
      "library": "frenetic",
      "description": "This module represents the flags field in an IPv4 packet header, specifically handling the \"Don't Fragment\" (df) and \"More Fragments\" (mf) bits. It provides functions to convert this flag structure to and from S-expressions for serialization and parsing. Use this module when constructing or analyzing IPv4 packets to set or read fragmentation control flags directly.",
      "description_length": 367,
      "index": 319,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Topology.Net.Pretty",
      "library": "frenetic",
      "description": "This module provides functions to convert network topologies into string representations. It supports generating human-readable strings, DOT format for visualization, and Mininet scripts for network simulation. The module works directly with `Frenetic.Topology.Net.Topology.t` values, enabling debugging, visualization, and integration with Mininet-based testing workflows.",
      "description_length": 373,
      "index": 320,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Netkat.Fdd.Field",
      "library": "frenetic",
      "description": "This module defines a set of named header fields used in Forwarding Decision Diagrams (FDDs), such as Ethernet source, IP destination, TCP port, and VLAN fields. It provides operations to convert between string representations and field values, compare and hash fields, and manage a global field ordering that affects FDD structure and performance. The module also includes functions to automatically determine or manually set the field order based on policy or user input.",
      "description_length": 473,
      "index": 321,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Network.Make.Traverse",
      "library": "frenetic",
      "description": "Implements breadth-first and depth-first traversal algorithms over network topologies. Operates on graph structures defined by the Topology module, visiting each vertex in a specified order. Useful for network discovery, pathfinding, and topology analysis tasks.",
      "description_length": 262,
      "index": 322,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.Network.Net.Pretty",
      "library": "frenetic",
      "description": "This module converts network topologies into string representations for visualization and simulation. It provides functions to generate human-readable strings, Graphviz DOT format output, and Mininet scripts from a topology. Use cases include debugging network layouts, generating visual graphs, and creating executable Mininet test environments from defined topologies.",
      "description_length": 370,
      "index": 323,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x01.PortDescription.PortFeatures",
      "library": "frenetic",
      "description": "This module defines operations for converting port feature flags to and from integer representations and provides a string representation for debugging. It works with the `portFeatures` type, which encodes the capabilities of a network port in OpenFlow 1.0. Use cases include interpreting switch port capabilities from raw integers during message parsing and logging port feature sets in a human-readable format.",
      "description_length": 412,
      "index": 324,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x01.Error.HelloFailed",
      "library": "frenetic",
      "description": "This module defines error codes for failed Hello message exchanges in OpenFlow 1.0, specifically `Incompatible` and `Eperm`. It provides functions to convert these errors to and from S-expressions and to generate human-readable string representations. Use this module when handling or reporting errors during OpenFlow handshake initialization.",
      "description_length": 343,
      "index": 325,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.Packet.Dns.Qd",
      "library": "frenetic",
      "description": "This module defines DNS query data structures and conversion functions for parsing and serializing DNS query sections. It operates on DNS query records containing name, type, and class fields, enabling direct manipulation of DNS packet components. Concrete use cases include constructing and deconstructing DNS request payloads for network monitoring or custom DNS server implementations.",
      "description_length": 388,
      "index": 326,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Network.Make.Pretty",
      "library": "frenetic",
      "description": "This module converts network topologies into human-readable string representations, DOT format for visualization, and Mininet scripts for network simulation. It works directly with the `Topology.t` data type to facilitate debugging, diagram generation, and test environment setup. Use cases include exporting topologies for documentation, visualizing network structures, and generating Mininet testbeds with optional setup and teardown scripts.",
      "description_length": 444,
      "index": 327,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x01.PortStatus.ChangeReason",
      "library": "frenetic",
      "description": "This module defines the `t` type representing reasons for port status changes in OpenFlow 0x01, with variants `Add`, `Delete`, and `Modify`. It provides functions to convert values of type `t` to and from S-expressions and strings. This module is used to interpret and serialize port status change events received from OpenFlow switches.",
      "description_length": 337,
      "index": 328,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Topology.Net.Path",
      "library": "frenetic",
      "description": "This module computes shortest paths in a network topology using a specified weight type. It provides functions to find single or multiple shortest paths between vertices, returning paths as edge lists. Concrete use cases include routing optimization and network analysis where minimal traversal cost is required.",
      "description_length": 312,
      "index": 329,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Netkat.FabricGen.FabricGen",
      "library": "frenetic",
      "description": "This module implements a two-player adversarial strategy for generating network fabrics in a virtual compilation context. It constructs fabrics as pairs of policy lists that enforce connectivity and isolation constraints between virtual and physical network components. The `generate_fabric` function takes predicates and policies defining virtual and physical topologies and ingress/egress conditions, producing a fabric that mediates their interaction under adversarial assumptions.",
      "description_length": 484,
      "index": 330,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Network.Net.UnitPath",
      "library": "frenetic",
      "description": "This module computes shortest paths in a network topology using edge-weighted paths. It operates on graph structures composed of vertices and edges, with weights represented as integers. Functions support finding single shortest paths, enumerating shortest paths from a source, and computing all-pairs shortest paths with customizable filtering.",
      "description_length": 345,
      "index": 331,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Netkat.Fdd.Action",
      "library": "frenetic",
      "description": "This module provides operations for constructing and analyzing structured sequences and parallel compositions of OpenFlow actions within Forwarding Decision Diagrams (FDDs). It supports transformations, serialization, and conversion to SDN policies through algebraic operations like action composition, negation, and decomposition, while enabling introspection of action components such as query lists and pipe sets. These capabilities are used to compile NetKAT programs into optimized OpenFlow rule sets, analyze network behavior, and manipulate policy components programmatically.",
      "description_length": 583,
      "index": 332,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.Net.Net.Parse",
      "library": "frenetic",
      "description": "This module provides functions to parse network topologies from DOT and GML file formats. It converts string representations of network graphs into structured topology data used for network modeling. Concrete use cases include loading predefined network layouts for simulation or analysis tasks.",
      "description_length": 295,
      "index": 333,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.OpenFlow0x04.Hello.Element",
      "library": "frenetic",
      "description": "This module implements the Hello Element structure from the OpenFlow 1.3.4 specification, handling parsing, serialization, and size calculation for Hello elements. It works with `t` values representing Hello elements, and supports operations like converting to human-readable strings, marshaling to and from binary buffers, and determining the size of the element. Concrete use cases include processing Hello messages during OpenFlow switch handshake to negotiate protocol versions.",
      "description_length": 482,
      "index": 334,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Netkat.Packet.Field",
      "library": "frenetic",
      "description": "This module defines a field as a key in a packet map, supporting comparison operations to order and distinguish fields. It works with packet fields such as headers and metadata, enabling precise packet classification and manipulation. Concrete use cases include defining match conditions in network policies and extracting or modifying specific packet attributes during forwarding decisions.",
      "description_length": 391,
      "index": 335,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x01.PortDescription.PortConfig",
      "library": "frenetic",
      "description": "This module defines bit-level operations for parsing and manipulating OpenFlow 1.0 port configuration flags. It provides conversions between integer representations and typed configurations, enabling precise control over network port behavior. Use this module to decode or modify port settings like administratively down or STP blocking from raw OpenFlow messages.",
      "description_length": 364,
      "index": 336,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Netkat.Packet.T",
      "library": "frenetic",
      "description": "This module represents network packets as maps from fields to 64-bit integer values. It provides operations for comparing packets, serializing and deserializing them to S-expressions, and computing hash values. Use this module when processing or analyzing network traffic in a software-defined networking context, such as matching packets against policies or tracking flow statistics.",
      "description_length": 384,
      "index": 337,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Net.Net.Pretty",
      "library": "frenetic",
      "description": "This module converts network topologies into string representations for visualization and simulation. It provides functions to generate human-readable strings, DOT format output, and Mininet scripts from a topology. Use cases include debugging network designs, generating input for network simulators, and visualizing topologies using graph tools.",
      "description_length": 347,
      "index": 338,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Netkat.Fdd.Value",
      "library": "frenetic",
      "description": "This module represents values used in Forwarding Decision Diagrams (FDDs) for NetKAT, supporting operations such as constant assignment, bitmasking, and abstract location references. It defines a lattice structure for packet field values, enabling compression of field tests and ensuring correct partial ordering via `subset_eq`. Concrete use cases include representing Ethernet source addresses with `Const` or `Mask`, modeling pipeline actions with `Pipe`, and handling special ports like `Controller` through `AbstractLocation`.",
      "description_length": 531,
      "index": 339,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Network.Make.Topology",
      "library": "frenetic",
      "description": "This module provides graph-based network topology management with operations to create, modify, and analyze directed graphs composed of typed vertices, edges, and ports, each supporting associated metadata. It enables structural manipulation (vertex/edge addition/removal), uniform-cost path calculations via unit-weighted modeling, and serialization of network elements, while offering traversal capabilities to enumerate neighbors, count graph components, or map elements to string representations. These features are particularly useful in software-defined networking scenarios requiring dynamic topology updates, path computation, or network state serialization.",
      "description_length": 666,
      "index": 340,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Network.Net.Path",
      "library": "frenetic",
      "description": "This module computes shortest paths in a network topology using a specified weight type. It provides functions to find a single shortest path, all shortest paths from a source vertex, and all pairs of shortest paths that satisfy a given predicate. These operations work with vertices and edges from the Topology module, returning paths as lists of edges.",
      "description_length": 354,
      "index": 341,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x01.Error.FlowModFailed",
      "library": "frenetic",
      "description": "This module defines error codes related to flow modification failures in OpenFlow 1.0, including conditions like table overflow or unsupported operations. It provides serialization and pretty-printing functions for these error values. Use this module to handle or report specific flow modification errors during switch communication.",
      "description_length": 333,
      "index": 342,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x04.GroupStats.BucketStats",
      "library": "frenetic",
      "description": "This module provides operations to parse, marshal, and convert bucket statistics to strings. It works with the `bucketStats` type, representing statistics for individual buckets within OpenFlow groups. Use it to process and serialize bucket statistics received from switches, such as packet and byte counts per bucket.",
      "description_length": 318,
      "index": 343,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Network.Net.Traverse",
      "library": "frenetic",
      "description": "Performs breadth-first and depth-first traversals over network topologies. Operates on graph structures defined by the Topology module, visiting each vertex. Useful for analyzing connectivity, pathfinding, and network exploration tasks.",
      "description_length": 236,
      "index": 344,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.OpenFlow0x01.Error.BadRequest",
      "library": "frenetic",
      "description": "This module defines error codes for malformed OpenFlow 1.0 messages, such as incorrect versions, invalid message types, or bad lengths. It includes functions to convert errors to and from S-expressions and to generate human-readable string representations. Use cases include reporting parsing failures and debugging malformed network messages.",
      "description_length": 343,
      "index": 345,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x01.Error.PortModFailed",
      "library": "frenetic",
      "description": "This module defines error codes for port modification failures in OpenFlow 1.0, specifically `BadPort` and `BadHwAddr`. It provides functions to convert these errors to and from S-expressions and to produce human-readable string representations. Use this module when handling or reporting errors related to invalid port configurations or hardware addresses in OpenFlow messages.",
      "description_length": 378,
      "index": 346,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Async.Ox.Platform",
      "library": "frenetic",
      "description": "This module provides functions to send OpenFlow messages such as packet-out, flow-mod, stats request, and barrier request to switches, using switch identifiers, transaction IDs, and message-specific data. It also includes a function to execute a thunk with a specified timeout. These operations are used to interact directly with OpenFlow switches and manage asynchronous control operations in network applications.",
      "description_length": 415,
      "index": 347,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Netkat.Virtual_Compiler.Make",
      "library": "frenetic",
      "description": "This module generates network fabrics and compiles Virtual NetKAT policies using a customizable fabric generation strategy. It operates on network predicates and policies to model and transform network topologies and traffic rules. It is used to implement virtual network compilation where physical and virtual topologies are combined and optimized.",
      "description_length": 349,
      "index": 348,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Packet.Igmp3.GroupRec",
      "library": "frenetic",
      "description": "This module defines a record type representing IGMPv3 group records, including the group record type, multicast group address, and a list of source addresses. It provides functions to serialize and deserialize these records to and from S-expressions. This module is used to handle multicast group membership information in IGMPv3 messages.",
      "description_length": 339,
      "index": 349,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Netkat.Global_compiler.FDD",
      "library": "frenetic",
      "description": "This module provides operations for constructing, transforming, and combining Flow Decision Diagrams (FDDs), which encode network policies through hierarchical packet classification and forwarding decisions. It operates on FDDs structured as Variable-Lattice-Result (VLR) instances, manipulating variables representing network fields, actions like packet modifications, and integer/int64 sets for rule prioritization. These capabilities are used to compile and optimize network policy languages like Frenetic into efficient decision diagrams for software-defined networking pipelines.",
      "description_length": 584,
      "index": 350,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Netkat.Vlr.Make",
      "library": "frenetic",
      "description": "This module provides operations for constructing and manipulating semi-ring-valued decision diagrams with lattice-ordered variables, including node creation (`Leaf`, `Branch`), logical combinations (`sum`, `prod`), structural transformations (`map`, `fold`), and cache management. It works with a decision diagram type `t` that encodes functions mapping lattice variables to semi-ring results, alongside supporting types for variables (`V`), lattice elements (`L`), and result values (`R`). Key use cases include symbolic computation, formal verification, and optimization tasks where hierarchical decision logic with algebraic structures must be analyzed or visualized via serialization and rendering tools.",
      "description_length": 708,
      "index": 351,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x01.FlowRemoved.Reason",
      "library": "frenetic",
      "description": "This module defines the reason codes for flow removal notifications in OpenFlow 1.0. It provides conversions between reason codes, integers, and string representations. Use this module to interpret or generate flow removal events, such as when a flow expires due to inactivity or is explicitly deleted.",
      "description_length": 302,
      "index": 352,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Network.Make.UnitPath",
      "library": "frenetic",
      "description": "This module computes shortest paths in a network topology with integer-weighted edges. It provides functions to find the shortest path between two vertices, all shortest paths from a source vertex, and all pairs of shortest paths in the graph. These operations are useful for network routing analysis and traffic optimization scenarios.",
      "description_length": 336,
      "index": 353,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.Net.Net.Path",
      "library": "frenetic",
      "description": "This module computes shortest paths in a network topology using a specified weight type. It provides functions to find the shortest path between two vertices, all shortest paths from a source vertex, and all pairs of shortest paths in the topology. These operations are used to determine optimal routing paths in network analysis and traffic engineering scenarios.",
      "description_length": 364,
      "index": 354,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x01.Error.BadAction",
      "library": "frenetic",
      "description": "This module defines error codes for invalid actions in OpenFlow 1.0 messages, including malformed types, lengths, ports, and queue configurations. It provides serialization to and from S-expressions and converts error values to human-readable strings. Use this module to handle and report specific action-related errors during OpenFlow message processing.",
      "description_length": 355,
      "index": 355,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x04.QueueDesc.QueueProp",
      "library": "frenetic",
      "description": "This module defines operations for handling queue property descriptions in OpenFlow 1.3.4. It supports parsing and serializing queue property data structures, which include properties like minimum and maximum rates, using `Cstruct.t` for efficient binary representation. Use cases include managing Quality of Service (QoS) settings in software-defined networking by encoding and decoding queue configurations for transmission or storage.",
      "description_length": 437,
      "index": 356,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.Netkat.Parser.Portless",
      "library": "frenetic",
      "description": "Parses NetKAT policies and predicates from strings or files without requiring port information. Works directly with string inputs and file paths, producing policy and predicate structures defined in `Frenetic_netkat.Syntax`. Useful for processing NetKAT programs where port details are omitted or irrelevant, such as in abstract network specifications or symbolic analysis.",
      "description_length": 373,
      "index": 357,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Topology.Net.Traverse",
      "library": "frenetic",
      "description": "Implements breadth-first and depth-first traversal algorithms over network topologies. Operates on graph structures defined by vertices, applying a function to each vertex during traversal. Useful for analyzing connectivity or propagating state across network nodes.",
      "description_length": 266,
      "index": 358,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Network.Make.Parse",
      "library": "frenetic",
      "description": "Converts network topologies from DOT or GML file formats into an in-memory graph structure. It processes string paths to files containing network descriptions and returns a `Topology.t` value representing the network. Useful for loading predefined network layouts for simulation or analysis tasks.",
      "description_length": 297,
      "index": 359,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Async.OpenFlow0x01_Plugin.LowLevel",
      "library": "frenetic",
      "description": "This module manages low-level communication with OpenFlow 1.0 switches, handling connection setup, message sending, and event reception. It works with switch identifiers, transaction IDs, and OpenFlow messages, providing direct access to switch control operations. Concrete use cases include sending flow modification requests to switches and processing asynchronous switch events like packet arrivals.",
      "description_length": 402,
      "index": 360,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Net.Net.Traverse",
      "library": "frenetic",
      "description": "Implements breadth-first and depth-first traversal algorithms over network topologies. Operates on graph structures defined by vertices, applying a given function to each vertex during traversal. Useful for analyzing network connectivity, path discovery, or propagating state across network nodes.",
      "description_length": 297,
      "index": 361,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x01.SwitchFeatures.Capabilities",
      "library": "frenetic",
      "description": "This module defines a record type representing the capabilities of an OpenFlow 1.0 switch, with boolean fields corresponding to individual capability flags such as flow statistics, port statistics, and STP support. It provides functions to convert between the record and S-expressions, and a function to produce a human-readable string representation of the capabilities. This module is used to interpret and serialize the capabilities field in OpenFlow switch feature responses.",
      "description_length": 479,
      "index": 362,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Netkat.Fdd.FDD",
      "library": "frenetic",
      "description": "This module provides operations for constructing and manipulating Flow Decision Diagrams (FDDs), which model network policies using header field tests and OpenFlow actions at decision nodes. It supports functional transformations (`map`, `fold`), arithmetic operations (`sum`, `prod`), structural analysis (equality checks, size computation), and serialization, working with decision diagrams represented as variable-lattice-result (VLR) structures. These capabilities enable compiling NetKAT policies into optimized SDN flow tables, facilitating efficient packet classification and network policy enforcement in software-defined networking scenarios.",
      "description_length": 651,
      "index": 363,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x01.SwitchConfig.FragFlags",
      "library": "frenetic",
      "description": "This module defines a type `t` representing fragment handling flags in OpenFlow 1.0 switch configuration messages. It includes functions to convert values to and from S-expressions and to obtain string representations. It is used to specify how fragmented packets should be handled in switch configuration settings.",
      "description_length": 315,
      "index": 364,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Netkat.Fdd.Pattern",
      "library": "frenetic",
      "description": "This module represents patterns in Forwarding Decision Diagrams (FDDs), which consist of field-value pairs corresponding to network headers. It provides operations to compare and convert patterns to NetKAT predicates or OpenFlow header values, enabling direct use in flow table generation. These patterns are used during FDD construction and manipulation to represent packet header matches and to interface with OpenFlow switches.",
      "description_length": 430,
      "index": 365,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.Async.Ox.DefaultHandlers",
      "library": "frenetic",
      "description": "This module provides default implementations for handling OpenFlow switch events, including connection, disconnection, barrier replies, and stats replies. It works with OpenFlow 0x01 switch identifiers, transaction IDs, and message reply structures. These handlers are useful for ignoring or stubbing out advanced event handling in simple controller implementations.",
      "description_length": 366,
      "index": 366,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Async.Common",
      "library": "frenetic",
      "description": "This module provides functions for profiling asynchronous computations, logging messages with severity levels, extracting request paths from HTTP requests, and handling parsing errors in HTTP body content. It works with Cohttp_async request and body types, Frenetic_netkat policy and compiler options, and Async deferred values. Concrete use cases include measuring execution time of functions, parsing JSON or NetKAT policy updates from HTTP requests, and safely handling malformed input in network applications.",
      "description_length": 513,
      "index": 367,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x04.Action",
      "library": "frenetic",
      "description": "This module defines and manipulates OpenFlow 1.3.4 action structures, including individual actions and action sequences. It provides functions for serializing, parsing, and converting actions to and from internal representations, along with computing their size and string representation. It is used to construct and process OpenFlow messages that specify packet forwarding and modification instructions.",
      "description_length": 404,
      "index": 368,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x01.StatsRequest",
      "library": "frenetic",
      "description": "This module handles the parsing and representation of OpenFlow 1.0 statistics requests, converting between raw message formats and structured data. It supports operations to serialize and deserialize statistical query messages, enabling interaction with network devices that use the OpenFlow protocol. Use cases include retrieving flow statistics, port information, and table metrics from switches for monitoring and control purposes.",
      "description_length": 434,
      "index": 369,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.OpenFlow0x01.Error",
      "library": "frenetic",
      "description": "This module defines error message types and serialization functions for handling specific error conditions in OpenFlow 1.0 message processing. It works with Cstruct.t for binary message representation and supports conversion to and from S-expressions and human-readable strings. Use this module to construct, serialize, and report detailed OpenFlow protocol errors such as malformed messages, unsupported actions, or failed flow modifications.",
      "description_length": 443,
      "index": 370,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.OpenFlow0x04.SwitchDescriptionReply",
      "library": "frenetic",
      "description": "This module handles parsing and serializing OpenFlow switch description replies, specifically working with the `switchDesc` type to represent switch metadata. It provides direct operations for converting between in-memory structures and network byte streams, including calculating size, pretty-printing, and binary marshaling. Concrete use cases include processing switch connection events and extracting switch capabilities during network discovery.",
      "description_length": 450,
      "index": 371,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x04.PortDesc",
      "library": "frenetic",
      "description": "This module defines operations for handling OpenFlow 1.3.4 port descriptions, including parsing from and marshaling to Cstruct buffers. It provides the size of a port description structure, converts it to and from binary representations, and generates string representations for debugging. These functions are used when interacting with network switches to retrieve, modify, or display port configuration data.",
      "description_length": 410,
      "index": 372,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.Netkat.Bisim",
      "library": "frenetic",
      "description": "Implements bisimilarity checking between two automata using the Hopcroft-Karp algorithm. Operates directly on automaton structures defined in the Global_compiler module. Useful for verifying equivalence of network packet processing pipelines represented as finite automata.",
      "description_length": 273,
      "index": 373,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Packet.Igmp",
      "library": "frenetic",
      "description": "This module represents and manipulates IGMP (Internet Group Management Protocol) packets, supporting parsing and serialization of IGMP messages into structured types. It handles two main message variants\u2014IGMPv1/v2 and IGMPv3\u2014along with unparsable message types, enabling precise packet inspection and construction. Concrete use cases include processing multicast group membership queries and reports in network monitoring or SDN applications.",
      "description_length": 442,
      "index": 374,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x04.MeterConfig",
      "library": "frenetic",
      "description": "This module handles Meter Configuration structures as defined in OpenFlow 1.3.4. It provides operations to serialize (`marshal`), deserialize (`parse`), determine size (`sizeof`), and convert to a human-readable string (`to_string`) for meter configuration data. These functions operate directly on `meterConfig` values and are used when configuring or inspecting flow meters in OpenFlow switches.",
      "description_length": 397,
      "index": 375,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Net.Node",
      "library": "frenetic",
      "description": "This module defines a type `t` representing network nodes and provides functions to convert values of this type to and from S-expressions. It works directly with the `Frenetic.Net.node` type and the `Sexplib0__.Sexp.t` type for serialization and deserialization. Concrete use cases include persisting network node configurations to disk or transmitting them over a network in a structured format.",
      "description_length": 396,
      "index": 376,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x01.FlowMod",
      "library": "frenetic",
      "description": "This module handles flow modification messages in the OpenFlow 1.0 protocol, providing functions to serialize, parse, and manipulate flow entries. It operates on the `flowMod` type, which represents flow table modifications, and supports concrete use cases such as constructing flow updates for network devices and decoding incoming flow mod messages from switches. Key operations include converting flow mods to and from binary format, generating string representations, and determining message size for transmission.",
      "description_length": 518,
      "index": 377,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x04.SwitchConfig",
      "library": "frenetic",
      "description": "This module handles the serialization, parsing, and string representation of OpenFlow switch configuration data. It operates on the `switchConfig` type, which represents the configuration parameters of an OpenFlow switch. Concrete use cases include converting switch configurations to and from binary format for transmission over the network, and generating human-readable output for debugging or logging.",
      "description_length": 405,
      "index": 378,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.OpenFlow0x04.QueueDesc",
      "library": "frenetic",
      "description": "This module handles queue description structures defined in OpenFlow 1.3.4, providing functions to parse and serialize queue descriptors to and from `Cstruct.t` buffers. It supports operations like determining the size of a queue descriptor, converting it to a human-readable string, and encoding or decoding it for network transmission or storage. Concrete use cases include configuring and transmitting Quality of Service (QoS) policies in software-defined networks, where queue settings such as min and max rates must be accurately encoded into OpenFlow messages.",
      "description_length": 566,
      "index": 379,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x04.PortStats",
      "library": "frenetic",
      "description": "This module handles parsing, marshaling, and pretty-printing of OpenFlow 1.3.4 port statistics structures. It operates on the `t` type representing port statistics, including fields like port number, receive and transmit byte/packet counts, and port state. Use this module to serialize port stats for network transmission or convert them to human-readable strings for logging and debugging.",
      "description_length": 390,
      "index": 380,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Netkat.Tokens",
      "library": "frenetic",
      "description": "This module defines a token type representing lexical elements of the NetKAT language, including keywords, operators, literals, and identifiers. It provides constructors for creating tokens with associated values, such as strings, integers, and locations, used during parsing and evaluation. Concrete use cases include lexical analysis of NetKAT programs and constructing abstract syntax trees for network policies.",
      "description_length": 415,
      "index": 381,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x01.FlowRemoved",
      "library": "frenetic",
      "description": "This module handles flow removal events in OpenFlow 1.0 by providing functions to parse, marshal, and convert flow removal data. It works with the `flowRemoved` type, which includes details like reason codes (via the `Reason` submodule), cookie values, and packet counts. Use this module to process or construct flow removal messages, such as when a switch notifies a controller that a flow has expired or been deleted.",
      "description_length": 419,
      "index": 382,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x04.FlowStats",
      "library": "frenetic",
      "description": "This module handles individual flow statistics in OpenFlow 1.3.4, providing operations to calculate size, convert to string, marshal, and parse flow statistics. It works with the `t` type representing flow statistics and `Cstruct.t` for binary data manipulation. Concrete use cases include serializing flow stats for network transmission and deserializing received binary data into flow stat structures.",
      "description_length": 403,
      "index": 383,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Network.Link",
      "library": "frenetic",
      "description": "This module represents network links with attributes like cost, capacity, and weight. It provides functions to create links, modify their weight, and serialize or parse them from formats like S-expressions, DOT, and GML. Use cases include modeling network topologies and managing link metrics for routing or graph analysis.",
      "description_length": 323,
      "index": 384,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x04.Oxm",
      "library": "frenetic",
      "description": "This module defines operations for handling OpenFlow 1.3.4 OXM (OpenFlow Extensible Match) fields, including parsing, marshaling, and string representation. It works with `oxm` and `oxmMatch` types, which represent match fields and their values in flow tables. Concrete use cases include serializing match conditions for packet flows, extracting field names and sizes, and converting pattern structures into OXM representations for switch communication.",
      "description_length": 453,
      "index": 385,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.Netkat.Generated_Parser",
      "library": "frenetic",
      "description": "Parses network policies and predicates from input streams using a generated lexer. It converts sequences of tokens into structured policy and predicate representations defined in the Syntax module. This module is used to interpret NetKAT programs from textual input, enabling policy analysis and transformation tasks.",
      "description_length": 317,
      "index": 386,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x04.FlowMod",
      "library": "frenetic",
      "description": "This module defines operations for working with OpenFlow 1.3.4 flow modification messages. It provides functions to calculate the size of a flow modification message, serialize it to a buffer, parse it from a buffer, and convert it to a human-readable string. These operations are used when constructing, transmitting, and inspecting flow table updates in software-defined networking applications.",
      "description_length": 397,
      "index": 387,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.OpenFlow0x04.MultipartReq",
      "library": "frenetic",
      "description": "This module defines the structure and operations for handling multipart request messages in the OpenFlow 1.3.4 protocol. It supports parsing and serializing multipart request data using `Cstruct.t` buffers, along with computing message size and generating string representations. Concrete use cases include processing switch statistics requests and handling controller-to-switch communication for flow table monitoring.",
      "description_length": 419,
      "index": 388,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x04.RoleRequest",
      "library": "frenetic",
      "description": "This module defines the structure and operations for handling Role Request messages in the OpenFlow 1.3.4 protocol. It provides functions to calculate the size of a role request, convert it to a string, and serialize or deserialize it using Cstruct buffers. These operations are used when negotiating controller roles in a software-defined network.",
      "description_length": 348,
      "index": 389,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x04.GroupType",
      "library": "frenetic",
      "description": "This module defines the group types supported in OpenFlow 1.3.4, corresponding directly to the `ofp_group_type` enumeration. It provides operations to convert group type values to human-readable strings, to integers, and to parse integers back into group type values. These functions are used when handling group table operations in OpenFlow switches, such as specifying group behavior in flow entries.",
      "description_length": 402,
      "index": 390,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.OpenFlow0x04.MeterStats",
      "library": "frenetic",
      "description": "This module handles parsing, marshaling, and pretty-printing of OpenFlow 1.3.4 meter statistics structures. It operates directly on `meterStats` values and `Cstruct.t` buffers for wire-level encoding and decoding. Use it to process meter statistics messages received from switches or to construct and serialize meter stats for testing and simulation.",
      "description_length": 350,
      "index": 391,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x04.PortState",
      "library": "frenetic",
      "description": "This module defines the port state values used in OpenFlow 1.3.4, corresponding directly to the `ofp_port_state` enumeration. It provides functions to convert port state values to and from 32-bit integers, and to generate string representations of each state. These operations are used when encoding or decoding OpenFlow messages that describe switch port status and capabilities.",
      "description_length": 380,
      "index": 392,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x04.PacketIn",
      "library": "frenetic",
      "description": "This module defines the structure and operations for handling OpenFlow 1.3.4 PacketIn messages, which represent packets received by a switch and sent to the controller. It provides functions to parse and serialize PacketIn values to and from Cstruct buffers, along with utilities to compute their size and convert them to human-readable strings. It is used in OpenFlow controller implementations to process incoming packets and extract metadata such as buffer ID, in-port, and packet data.",
      "description_length": 489,
      "index": 393,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x04.TableFeatureProp",
      "library": "frenetic",
      "description": "This module handles the serialization, parsing, and string representation of OpenFlow table feature properties. It operates on the `t` type, which represents table feature property structures as defined in the OpenFlow 1.3.4 specification. Use this module when working with OpenFlow control messages that require inspecting or constructing table feature properties, such as negotiating table capabilities during switch configuration.",
      "description_length": 433,
      "index": 394,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Async.DynGraph",
      "library": "frenetic",
      "description": "This module implements a dynamic dataflow graph where nodes hold values and propagate updates to connected nodes. It supports creating nodes with custom update functions, source nodes that can be pushed to, and connecting nodes to form directed edges while avoiding cycles. Use cases include building reactive systems that respond to asynchronous value changes, such as streaming data pipelines or event-driven state propagation.",
      "description_length": 429,
      "index": 395,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.Netkat.Optimize",
      "library": "frenetic",
      "description": "This module constructs and transforms network policies and predicates using logical and control-flow operations. It provides functions to build boolean combinations of predicates, sequence and union of policies, and iterative policy application, along with normalization and flattening utilities. These operations directly manipulate policy and predicate structures to model packet processing pipelines and optimize their representation.",
      "description_length": 437,
      "index": 396,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Netkat.Portless_Compiler",
      "library": "frenetic",
      "description": "Compiles a portless network policy into a portful policy by leveraging a given network topology. Operates on network policies and topologies, transforming policies to include port-specific behavior. Useful for implementing OpenFlow-like forwarding rules in environments where port information is required.",
      "description_length": 305,
      "index": 397,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Topology.Net",
      "library": "frenetic",
      "description": "This module provides graph construction and manipulation capabilities with vertices, edges, and ports, supporting operations like traversal, shortest path computation, and topology transformation. It includes specialized modules for spanning tree generation, breadth-first and depth-first traversal, path finding with weighted edges, and parsing or pretty-printing topologies in formats like DOT and GML. Concrete use cases include modeling network infrastructures, optimizing routing paths, and integrating with network simulation tools like Mininet.",
      "description_length": 551,
      "index": 398,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.Netkat.FabricGen",
      "library": "frenetic",
      "description": "This module implements a two-player adversarial strategy to generate network fabrics as pairs of policy lists that enforce connectivity and isolation constraints. It operates on predicates and policies representing virtual and physical network topologies, ingress, and egress conditions. The main function, `generate_fabric`, constructs fabrics that mediate interactions between virtual and physical components under adversarial assumptions, ensuring correct compilation in virtualized network environments.",
      "description_length": 507,
      "index": 399,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Async.NetKAT_Controller",
      "library": "frenetic",
      "description": "This module implements a controller for managing OpenFlow switches, providing operations to initialize the controller on a TCP port, retrieve network events, and inspect or modify switch behavior. It works with OpenFlow switches, ports, and policies, allowing updates to local or global forwarding rules using either high-level policies or FDD representations. Concrete use cases include monitoring port statistics, dynamically updating packet forwarding logic, and injecting packets into the network with specified policies.",
      "description_length": 525,
      "index": 400,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x04.Bucket",
      "library": "frenetic",
      "description": "This module defines operations for working with OpenFlow bucket structures used in group tables. It provides functions to calculate the size of a bucket, convert it to a string, and serialize or deserialize it using Cstruct. These operations support handling packet forwarding actions within OpenFlow 1.3.4 group entries.",
      "description_length": 321,
      "index": 401,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Async.OpenFlow0x01_Plugin",
      "library": "frenetic",
      "description": "This module manages asynchronous communication with OpenFlow 1.0 switches, enabling control operations such as sending flow updates, retrieving switch features, and handling packet events. It works with switch identifiers, port identifiers, flow patterns, and network policies, supporting interactions like forwarding packets, querying flow statistics, and updating switch configurations. Concrete use cases include implementing software-defined networking controllers that react to switch events and enforce network policies.",
      "description_length": 526,
      "index": 402,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Netkat.Json",
      "library": "frenetic",
      "description": "This module converts NetKAT policies and OpenFlow messages to and from JSON format using Yojson. It supports serialization and deserialization of policies, header values, events, statistics, pseudoports, and flow tables. Use cases include transmitting NetKAT policies over networks, persisting switch state, and integrating with external systems expecting JSON input.",
      "description_length": 367,
      "index": 403,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.OpenFlow0x04.MultipartReply",
      "library": "frenetic",
      "description": "This module defines the structure and operations for handling multipart reply messages in the OpenFlow 1.3.4 protocol. It provides functions to calculate the size of a reply, convert it to a string, and serialize or deserialize it using Cstruct buffers. Concrete use cases include processing switch statistics and status information sent in response to controller queries.",
      "description_length": 372,
      "index": 404,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x04.PortMod",
      "library": "frenetic",
      "description": "This module defines operations for working with OpenFlow PortMod messages, including parsing, marshaling, and string representation. It handles the `t` type representing port configuration changes, and provides the size of each message instance. It is used to modify port settings such as MAC address, configuration flags, and state in OpenFlow 1.3.4 switches.",
      "description_length": 360,
      "index": 405,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Network.Net",
      "library": "frenetic",
      "description": "This module implements network topology analysis and transformation operations. It provides graph traversal algorithms, shortest path computation with customizable weights, and file format parsing for network layouts. Use cases include network simulation, pathfinding for routing protocols, and generating Mininet test environments from defined topologies.",
      "description_length": 356,
      "index": 406,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Packet.Igmp3",
      "library": "frenetic",
      "description": "This module represents IGMPv3 messages with a structured type that includes a checksum and a list of group records. It supports serialization and deserialization of these messages to and from S-expressions. It is used to manage multicast group membership data within network applications that process or generate IGMPv3 packets.",
      "description_length": 328,
      "index": 407,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow.Pattern",
      "library": "frenetic",
      "description": "This module defines packet-matching patterns for OpenFlow flow tables, supporting operations like exact match, subset checking, and merging of patterns. It works with structured packet fields including Ethernet addresses, VLAN tags, IP addresses, and transport ports, enabling precise flow classification. Concrete use cases include constructing and comparing flow entries to ensure correct packet matching, merging overlapping rules, and generating efficient OpenFlow 1.3 group tables.",
      "description_length": 486,
      "index": 408,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Netkat.Domain",
      "library": "frenetic",
      "description": "This module tracks the domain of fields in network programs by collecting sets of values that appear in packet tests or modifications. It provides operations to merge domains, construct them from FDDs or automata, and generate representative packets. The core type maps fields to sets of 64-bit integers, enabling precise analysis of packet-processing behavior.",
      "description_length": 361,
      "index": 409,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x04.PortStatus",
      "library": "frenetic",
      "description": "This module handles the serialization, deserialization, and display of OpenFlow 1.3.4 port status messages. It operates on the `portStatus` type, representing events such as port additions, removals, or state changes. Use this module to interpret or construct raw port status messages in network monitoring or switch management applications.",
      "description_length": 341,
      "index": 410,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Netkat.Vlr",
      "library": "frenetic",
      "description": "This module implements a lattice structure for network packet processing, providing operations to combine and compare packet classification rules. It works with integer pairs as keys and supports efficient lookups and insertions. A concrete use case is optimizing the compilation of Software-Defined Networking (SDN) policies into efficient decision trees.",
      "description_length": 356,
      "index": 411,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.Async.Logging",
      "library": "frenetic",
      "description": "This module offers structured logging operations with support for severity levels (info, error, debug), timestamped and tagged message formatting, and asynchronous output management including rotation and flushing. It works with S-expressions, strings, and formatted messages, enabling use cases like error tracking in distributed systems, debugging async workflows with deferred computations, and generating analyzable logs through structured data representations. Key utilities include `surround_s` and `surroundf` for timing-sensitive logging and transformations that enrich messages with contextual metadata.",
      "description_length": 612,
      "index": 412,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Async.Ox",
      "library": "frenetic",
      "description": "This module launches an Ox controller that listens for OpenFlow messages on port 6633 and routes them to handler callbacks defined in an `OxModule`. It supports interaction with OpenFlow 0x01 switches using message types like packet-out, flow-mod, and stats request, along with switch identifiers and transaction IDs. It is used to implement custom network control logic, such as routing or monitoring, by defining event and message handling behavior in the provided module.",
      "description_length": 474,
      "index": 413,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.OpenFlow.From0x01",
      "library": "frenetic",
      "description": "This module translates OpenFlow 1.0 messages, actions, and statistics into the unified Frenetic.OpenFlow interface. It handles conversion of switch features, port and flow statistics, and event generation from switch messages. These functions enable Frenetic to compile high-level actions into OpenFlow 1.0-compatible operations while supporting feature detection and runtime monitoring.",
      "description_length": 387,
      "index": 414,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Netkat.Fdd",
      "library": "frenetic",
      "description": "This module implements Flow Decision Diagrams (FDDs) for representing and manipulating network policies in NetKAT, using OpenFlow actions at decision leaves and structured header matches. It supports operations such as policy composition, transformation, and serialization, working with data types like field-value patterns, structured actions, and decision nodes organized via field ordering. Concrete use cases include compiling NetKAT programs into optimized OpenFlow rule sets, performing packet classification, and enabling efficient network policy enforcement in SDN environments.",
      "description_length": 586,
      "index": 415,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x04.PacketOut",
      "library": "frenetic",
      "description": "This module defines operations for constructing and serializing OpenFlow 1.3.4 packet-out messages. It provides functions to calculate the size of a packet-out structure, convert it to a string, and marshal or parse it from a Cstruct buffer. These operations are used when sending packets from the controller to a switch, such as injecting crafted packets or forwarding received packets.",
      "description_length": 387,
      "index": 416,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Netkat.Local_compiler",
      "library": "frenetic",
      "description": "This module compiles, optimizes, and transforms NetKAT policies into FDD-based intermediate representations and OpenFlow flow tables, supporting policy composition (`seq`, `union`, `star`), restriction, deduplication, and multi-table compilation. It operates on NetKAT policies, flow layouts, and structured flow entries with instructions, producing OpenFlow 1.3+ multi-table configurations, group tables, and metadata for analysis. Use cases include policy evaluation on packets, serialization to JSON/DOT/S-expressions, and generating optimized flow tables with customizable field ordering and caching strategies.",
      "description_length": 615,
      "index": 417,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x01.PseudoPort",
      "library": "frenetic",
      "description": "This module defines operations for working with pseudo ports in OpenFlow 1.0. It provides `to_string` to convert a pseudo port to a string, `marshal` to serialize it into an integer, and `make` to construct a pseudo port from two integers. These functions are used to handle special port identifiers that represent logical or virtual ports in OpenFlow switch processing.",
      "description_length": 370,
      "index": 418,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Async.Compile_Server",
      "library": "frenetic",
      "description": "This module defines a single entry point `main` that starts an asynchronous compilation server, listening on a specified port. It handles incoming compilation requests and processes them concurrently using asynchronous I/O. Concrete use cases include running a background service for compiling Frenetic code over the network.",
      "description_length": 325,
      "index": 419,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x04.TableMod",
      "library": "frenetic",
      "description": "This module defines operations for working with OpenFlow 1.3.4 Table Modify messages. It provides functions to calculate the size of a message, convert it to a string, and serialize or deserialize it using a Cstruct buffer. These operations are used when configuring switch table settings in software-defined networking applications.",
      "description_length": 333,
      "index": 420,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Netkat.Global_compiler",
      "library": "frenetic",
      "description": "This module compiles NetKAT policies into optimized Flow Decision Diagrams (FDDs) using an automaton-based intermediate representation. It processes policies by translating them into automata with FDD-encoded transitions, then reduces and transforms these automata into hierarchical decision diagrams that represent network forwarding behavior. The resulting FDDs capture packet classification and forwarding decisions for efficient execution in software-defined networks.",
      "description_length": 472,
      "index": 421,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Hashcons.Make",
      "library": "frenetic",
      "description": "This module implements hash-consing for a given value type, ensuring that equal values share the same physical representation. It provides operations to retrieve a unique integer key for a value, recover the value from its key, and remove entries associated with specific keys. It is useful in scenarios like symbolic manipulation or term rewriting where managing canonical forms of data is critical.",
      "description_length": 400,
      "index": 422,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Packet.Dns",
      "library": "frenetic",
      "description": "This module defines DNS packet structures and serialization for handling DNS queries and responses. It works with DNS packet types containing identifiers, flags, and lists of query and resource records, using submodules to manage question and answer sections. Concrete use cases include crafting and parsing DNS messages for network analysis or custom DNS proxy implementations.",
      "description_length": 378,
      "index": 423,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x04.FlowRemoved",
      "library": "frenetic",
      "description": "This module handles the serialization, deserialization, and string representation of OpenFlow 1.3.4 Flow Removed messages. It operates on the `flowRemoved` type, which captures metadata about a flow entry being removed from a switch. Concrete use cases include parsing incoming Flow Removed messages from network switches and converting them to human-readable strings for logging or debugging.",
      "description_length": 393,
      "index": 424,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x04.Instructions",
      "library": "frenetic",
      "description": "This module handles OpenFlow 1.3 instruction lists, providing operations to serialize, deserialize, and convert group references into instruction sequences. It works with `instruction list` types and Cstruct buffers for network transmission. Use this module when constructing or interpreting OpenFlow messages that involve packet processing instructions, such as modifying headers or directing packet flow.",
      "description_length": 406,
      "index": 425,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x01.SwitchFeatures",
      "library": "frenetic",
      "description": "This module defines data structures and serialization functions for interpreting OpenFlow 1.0 switch feature responses. It includes records for switch identifiers, buffer and table counts, supported capabilities, actions, and port descriptions, along with functions to convert these structures to and from S-expressions and to produce readable string representations. Use this module to parse and inspect switch capabilities and configuration during control plane interactions, such as determining supported actions or port properties for flow rule installation.",
      "description_length": 562,
      "index": 426,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.OpenFlow0x04.PortConfig",
      "library": "frenetic",
      "description": "This module defines bit flags for port configuration in OpenFlow 1.3.4, corresponding directly to the `ofp_port_config` enumeration. It provides functions to convert these flags to and from 32-bit integers, enabling low-level packet manipulation and configuration. Use cases include setting or interpreting port behavior such as administratively disabling a port or suppressing packet reception.",
      "description_length": 395,
      "index": 427,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x01.PacketOut",
      "library": "frenetic",
      "description": "This module handles the construction and manipulation of OpenFlow 1.0 packet-out messages. It provides functions to serialize packet-out actions and payloads into the correct binary format for transmission. Use cases include sending raw Ethernet frames from the controller to a switch port or implementing custom packet forwarding logic.",
      "description_length": 337,
      "index": 428,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.Net.Net",
      "library": "frenetic",
      "description": "This module implements core network topology operations, including graph construction, traversal, shortest path computation, and file format parsing. It works with vertex-, edge-, and port-based data structures to support concrete use cases such as network simulation, routing analysis, and visualization. Functions include spanning tree generation, connectivity analysis, topology serialization, and Mininet script generation.",
      "description_length": 427,
      "index": 429,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x04.FlowRequest",
      "library": "frenetic",
      "description": "This module defines the structure and operations for handling Flow Statistics requests in OpenFlow 1.3.4. It provides functions to serialize (`marshal`), deserialize (`parse`), compute the size (`sizeof`), and pretty-print (`to_string`) flow request messages. These operations directly work with the `flowRequest` type and Cstruct buffers, enabling efficient network transmission and debugging of individual or aggregate flow statistics requests.",
      "description_length": 446,
      "index": 430,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x01.PortDescription",
      "library": "frenetic",
      "description": "This module parses, serializes, and represents OpenFlow 1.0 port description messages. It works with the `portDescription` type, which includes port number, hardware address, name, configuration, state, current features, advertised features, and supported features. Use it to decode raw port descriptions from switches, encode port settings for configuration, or inspect port capabilities and status in SDN applications.",
      "description_length": 420,
      "index": 431,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x04.QueueConfReply",
      "library": "frenetic",
      "description": "This module defines the structure and operations for handling OpenFlow Queue Configuration Reply messages. It provides functions to parse and serialize these messages, as well as compute their size and convert them to human-readable strings. It works directly with `Cstruct.t` and the internal `queueConfReply` type representing OpenFlow 1.3.4 queue configurations.",
      "description_length": 365,
      "index": 432,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.OpenFlow0x01.StatsReply",
      "library": "frenetic",
      "description": "This module handles parsing and marshaling of OpenFlow 1.0 statistics reply messages, converting between raw byte sequences and structured representations. It works with `Cstruct.t` buffers for binary data and `t` type values representing parsed replies. Use this module to decode incoming stats replies from switches or encode responses to send over the network.",
      "description_length": 363,
      "index": 433,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x04.OfpMatch",
      "library": "frenetic",
      "description": "This module defines operations for handling OpenFlow 1.3.4 flow match structures, including parsing, marshaling, and string representation. It works with the `oxmMatch` type, representing match fields for flow entries, and uses `Cstruct.t` for low-level buffer manipulation. Concrete use cases include serializing match structures for network transmission and deserializing received packets into usable flow match data.",
      "description_length": 419,
      "index": 434,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Packet.Icmp",
      "library": "frenetic",
      "description": "This module defines the structure and operations for handling ICMP packets, including fields for type, code, checksum, and payload. It provides serialization and deserialization functions for converting ICMP packet data to and from S-expressions. Concrete use cases include parsing and constructing ICMP messages for network communication and diagnostics, such as echo requests and error reporting.",
      "description_length": 398,
      "index": 435,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.OpenFlow0x04.MeterBand",
      "library": "frenetic",
      "description": "This module defines operations for working with OpenFlow 1.3.4 meter band structures. It provides functions to calculate the size of a meter band, convert it to a string, and serialize or deserialize it using Cstruct. These operations are used when configuring or interpreting rate-limiting behavior in OpenFlow switches.",
      "description_length": 321,
      "index": 436,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x04.QueueStats",
      "library": "frenetic",
      "description": "This module handles queue statistics in OpenFlow 1.3.4, providing operations to parse, marshal, and convert queue stats to human-readable strings. It works with the `t` type representing queue statistics and `Cstruct.t` for binary data manipulation. Use it to extract and format queue performance metrics from network devices.",
      "description_length": 326,
      "index": 437,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.OpenFlow0x04.PseudoPort",
      "library": "frenetic",
      "description": "This module defines operations for working with pseudo ports in OpenFlow 1.3. It provides functions to create pseudo port values from raw integers, convert them to human-readable strings, calculate their size, and serialize them to 32-bit integers. These operations are used when handling special OpenFlow port identifiers that represent logical or virtual ports, such as in packet forwarding decisions or switch configuration.",
      "description_length": 427,
      "index": 438,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x04.AsyncConfig",
      "library": "frenetic",
      "description": "This module defines the structure and operations for handling asynchronous configuration messages in the OpenFlow 1.3.4 protocol. It provides functions to serialize (`marshal`), deserialize (`parse`), compute the size (`sizeof`), and convert to a string representation (`to_string`) of asynchronous configuration data. It works directly with `Cstruct.t` and the internal `asyncConfig` type to support network communication and packet processing in software-defined networking applications.",
      "description_length": 489,
      "index": 439,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.OpenFlow0x04.SwitchFeatures",
      "library": "frenetic",
      "description": "This module handles parsing and serializing the OpenFlow 1.3.4 switch features structure. It provides the size of the structure, converts it to a human-readable string, and marshals or parses the structure from binary data. Use this module when interacting with OpenFlow switch handshakes to interpret or construct switch feature responses.",
      "description_length": 340,
      "index": 440,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow.To0x01",
      "library": "frenetic",
      "description": "This module translates OpenFlow 1.3 data structures to their OpenFlow 1.0 equivalents, enabling compatibility between the two versions. It handles conversion of patterns, actions, flow modifications, switch features, and packet events. Use cases include compiling Frenetic programs to OpenFlow 1.0 switches and bridging semantic differences between OpenFlow versions for consistent network control.",
      "description_length": 398,
      "index": 441,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x04.GroupStats",
      "library": "frenetic",
      "description": "This module handles parsing, marshaling, and pretty-printing of OpenFlow group statistics, specifically for version 1.3.4. It operates on the `groupStats` type, which captures statistics such as group ID, bucket statistics, and packet and byte counts. Use it to process and serialize group statistics data retrieved from OpenFlow switches for monitoring and network management tasks.",
      "description_length": 383,
      "index": 442,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.Topology.Mininet",
      "library": "frenetic",
      "description": "This module defines functions to construct network topologies such as tree, linear, single-switch, and minimal configurations. It maps symbolic topology names to concrete network structures used for simulation and testing. Direct use cases include setting up predefined network layouts for SDN experiments and performance testing.",
      "description_length": 330,
      "index": 443,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.OpenFlow0x04.Message",
      "library": "frenetic",
      "description": "This module defines the message types and operations for handling OpenFlow 1.3 protocol messages. It supports serialization, deserialization, and manipulation of messages such as Hello, FlowMod, PacketIn, and Error, using data types like `t`, `Cstruct.t`, and `xid`. Use cases include constructing and parsing OpenFlow control messages for switch communication, measuring message sizes, and converting messages to and from wire format.",
      "description_length": 435,
      "index": 444,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Network.Make",
      "library": "frenetic",
      "description": "This module implements a graph-based network topology framework with typed vertices and edges, supporting structural manipulation, path computation, and serialization. It provides concrete operations for building and analyzing directed graphs with metadata-rich elements, enabling use cases such as dynamic routing, network simulation, and topology visualization. Key capabilities include shortest path calculation, traversal algorithms, file format parsing, and Mininet script generation for network testing.",
      "description_length": 509,
      "index": 445,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x04.GroupFeatures",
      "library": "frenetic",
      "description": "This module handles parsing, marshaling, and string representation of OpenFlow 1.3.4 group features structures, which describe the capabilities of a switch's group table. It operates directly on the `groupFeatures` type, providing precise serialization and deserialization for use in network device communication and protocol implementation.",
      "description_length": 341,
      "index": 446,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Netkat.Portless_Generated_Parser",
      "library": "frenetic",
      "description": "This module provides functions for parsing network policies and predicates from lexical buffers, producing values of type `Frenetic_netkat.Syntax.policy` and `Frenetic_netkat.Syntax.pred`. It operates on `token` values via a lexer function, specifically handling end-of-file conditions during parsing. It is used to convert raw input streams into structured policy and predicate representations for network configuration and analysis tasks.",
      "description_length": 440,
      "index": 447,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.OpenFlow0x01.Wildcards",
      "library": "frenetic",
      "description": "This module encodes and decodes wildcard bitmasks for OpenFlow 1.0 flow entries. It converts wildcard values to and from 32-bit integers and provides string representations. It is used to handle fields like `in_port` or `eth_src` in flow tables where partial matches are allowed.",
      "description_length": 279,
      "index": 448,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x04.FlowModCommand",
      "library": "frenetic",
      "description": "This module defines operations for working with OpenFlow 1.3.4 flow modification commands. It provides functions to calculate the size of a command, serialize it to an integer representation, parse it from an integer, and convert it to a human-readable string. These operations are used when constructing or interpreting OpenFlow messages that modify switch flow tables.",
      "description_length": 370,
      "index": 449,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x04.PortFeatures",
      "library": "frenetic",
      "description": "This module defines bit flags representing port features in OpenFlow 1.3.4, such as 10 Mbps, 100 Mbps, and full-duplex support. It provides functions to convert these features to and from a 32-bit integer representation, enabling efficient serialization and parsing. Use cases include configuring switch port capabilities and interpreting port status messages in network control applications.",
      "description_length": 392,
      "index": 450,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x01.Timeout",
      "library": "frenetic",
      "description": "This module defines operations for working with OpenFlow 1.0 timeout values, including converting timeouts to strings, integers, and constructing them from integers. It handles the `timeout` type, which represents duration values used in flow table entries and packet processing rules. Concrete use cases include setting flow entry idle or hard timeouts and logging timeout values during network policy enforcement.",
      "description_length": 415,
      "index": 451,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.OpenFlow0x04.GroupMod",
      "library": "frenetic",
      "description": "This module defines operations for encoding, decoding, and manipulating OpenFlow 1.3.4 Group Modify messages. It works with the `groupMod` type, which represents group table modifications, and uses `Cstruct.t` for low-level byte buffer handling. Concrete use cases include serializing group modification commands to send over the network and parsing incoming group modification messages from switches.",
      "description_length": 401,
      "index": 452,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x04.Capabilities",
      "library": "frenetic",
      "description": "This module defines bit flags representing OpenFlow switch capabilities, such as flow statistics, table statistics, and port statistics. It provides conversions to and from 32-bit integers and string representations for debugging or logging. Use this module when interpreting or constructing OpenFlow handshake messages to determine supported features.",
      "description_length": 352,
      "index": 453,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x01.Message",
      "library": "frenetic",
      "description": "This module defines and manipulates OpenFlow 1.0 message types such as Hello, ErrorMsg, FlowModMsg, and PacketInMsg, along with serialization, parsing, and size calculation operations. It works directly with data types like `Cstruct.t`, `OpenFlow_Header.t`, and transaction IDs (`xid`) to handle message encoding and decoding. Concrete use cases include constructing FlowMod messages to update switch flow tables, parsing incoming PacketIn messages for packet processing, and serializing EchoRequests for liveness checks.",
      "description_length": 521,
      "index": 454,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Netkat.Semantics",
      "library": "frenetic",
      "description": "This module implements packet evaluation and policy analysis for network traffic processing. It defines `eval` to apply policies to packets, producing modified packet sets, and `eval_pipes` to trace packet transformations through policy components. It operates on packet records containing switch identifiers, structured headers, and payloads, supporting concrete use cases such as policy-based packet filtering, traffic steering, and runtime monitoring in software-defined networks.",
      "description_length": 483,
      "index": 455,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Netkat.Lexer",
      "library": "frenetic",
      "description": "This module defines a lexer for parsing network policy languages, recognizing tokens like keywords, identifiers, integers, and special symbols. It provides functions to convert input strings or files into token streams, supporting concrete syntax elements such as `IF`, `THEN`, `PORT`, and `MAC`. Use this module to implement custom parsers for network configuration and policy languages.",
      "description_length": 388,
      "index": 456,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x04.QueueConfReq",
      "library": "frenetic",
      "description": "This module defines operations for handling Queue Configuration request messages in the OpenFlow 1.3.4 protocol. It provides functions to parse and serialize these messages to and from binary data structures, as well as to calculate their size and convert them to human-readable strings. It works directly with the `t` type representing Queue Configuration requests and `Cstruct.t` for binary manipulation, enabling use cases like switch-to-controller communication for queue configuration retrieval.",
      "description_length": 500,
      "index": 457,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Async.OpenFlow0x04_Plugin",
      "library": "frenetic",
      "description": "This module implements OpenFlow 1.3 messaging and switch management for SDN applications. It provides functions to send and process OpenFlow messages, manage flow tables, and handle switch connections asynchronously. Key operations include flow installation, group table configuration, and fault-tolerant switch communication.",
      "description_length": 326,
      "index": 458,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Async.Shell",
      "library": "frenetic",
      "description": "This module provides a function to run a network application with a specified number of worker threads, handling asynchronous I/O operations and shell command execution. It works with basic system types like integers and unit values, integrating low-level system interactions with high-level async workflows. A concrete use case is launching a concurrent network server that executes shell commands in response to client requests.",
      "description_length": 430,
      "index": 459,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x01.PortStatus",
      "library": "frenetic",
      "description": "This module represents port status messages in OpenFlow 0x01, capturing both the reason for a port status change and the associated port description. It provides functions to parse and marshal these messages to and from binary data, convert them to S-expressions and strings, and determine their size in bytes. It is used to process notifications from OpenFlow switches about port additions, deletions, or modifications.",
      "description_length": 420,
      "index": 460,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Packet.Ip",
      "library": "frenetic",
      "description": "This module represents IPv4 packet headers, including fields like source and destination addresses, TTL, and protocol type. It supports parsing and serializing headers to and from S-expressions, and handles transport layer payloads through the `tp` type. Use it when constructing or inspecting IPv4 packets, especially for network monitoring or custom routing applications.",
      "description_length": 373,
      "index": 461,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x01.Vendor",
      "library": "frenetic",
      "description": "This module represents OpenFlow VENDOR messages as a 32-bit vendor identifier paired with raw payload data. It provides parsing and serialization functions to convert between Cstruct buffers and the internal tuple representation. Use this module to handle vendor-specific extensions in OpenFlow 1.0 switches, such as interpreting or constructing messages for custom hardware actions or proprietary features.",
      "description_length": 407,
      "index": 462,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x04.Instruction",
      "library": "frenetic",
      "description": "This module handles flow instruction structures as defined in the OpenFlow 1.3.4 specification. It provides operations to calculate the size of an instruction, serialize it to a buffer, parse it from a buffer, and convert it to a human-readable string. These functions are used when constructing or interpreting OpenFlow messages that modify flow tables, such as adding or modifying flow entries with specific actions or metadata.",
      "description_length": 430,
      "index": 463,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Netkat.LexBuffer",
      "library": "frenetic",
      "description": "This module provides a lexbuffer implementation that tracks source positions and Unicode characters during lexical analysis. It supports operations to read and advance through input, mark and backtrack positions, and retrieve source locations for error reporting. It is used to implement parsers that require precise source location tracking, such as compilers or interpreters for domain-specific languages.",
      "description_length": 407,
      "index": 464,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x04.MeterMod",
      "library": "frenetic",
      "description": "This module defines operations for constructing, serializing, and parsing OpenFlow meter modification messages. It works with the `meterMod` type, which represents meter configurations including rate limits and burst sizes. Use this module to install, update, or remove meters in OpenFlow switches, directly encoding or decoding these actions into network byte streams.",
      "description_length": 369,
      "index": 465,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Packet.Tcp",
      "library": "frenetic",
      "description": "This module represents TCP frames with fields including source and destination ports, sequence and acknowledgment numbers, data offset, flags, window size, checksum, urgent pointer, and payload. It provides functions to serialize and parse TCP packets to and from S-expressions, enabling inspection and construction of TCP headers for network analysis or packet manipulation tasks. Use this module when handling TCP payloads in OpenFlow PacketIn or PacketOut messages, such as inspecting connection states or crafting custom TCP responses.",
      "description_length": 539,
      "index": 466,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Netkat.Virtual_Compiler",
      "library": "frenetic",
      "description": "This module compiles Virtual NetKAT policies into efficient network fabrics using customizable strategies. It transforms network predicates and policies to model and optimize traffic rules across combined physical and virtual topologies. Concrete use cases include generating forwarding tables and optimizing network paths for software-defined networks.",
      "description_length": 353,
      "index": 467,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Netkat.Packet",
      "library": "frenetic",
      "description": "This module processes network packets represented as maps from fields to 64-bit integers, supporting operations like comparison, serialization, and hash computation. It includes functions to apply decision diagrams and actions to packets, enabling policy enforcement and flow transformation in software-defined networking. Concrete use cases include packet classification, traffic filtering, and modifying packet fields during forwarding.",
      "description_length": 438,
      "index": 468,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Net.Link",
      "library": "frenetic",
      "description": "This module defines a data type `t` representing network links and provides functions to serialize and deserialize link data using S-expressions, compare links, and convert them to string or DOT format. It includes parsers for creating link objects from DOT and GML attribute lists, along with a default link value. It is used to model and manipulate network topologies by converting between different representation formats.",
      "description_length": 425,
      "index": 469,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Netkat.Syntax",
      "library": "frenetic",
      "description": "This module provides S-expression serialization, comparison, and equality operations for network identifiers and policy structures, alongside combinators for constructing and manipulating packet-forwarding policies. It operates on types representing network elements (switches, ports, hosts, buffer IDs), header values, predicates, and metadata, as well as core NetKAT syntax like sequential composition, union, and star operations. These capabilities enable parsing NetKAT strings, compiling policies into flow tables, and runtime enforcement of network behavior in SDN environments.",
      "description_length": 584,
      "index": 470,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x04.Error",
      "library": "frenetic",
      "description": "This module handles the serialization, deserialization, and string representation of OpenFlow error messages as defined in version 1.3.4 of the specification. It operates on the `error` type, which represents different OpenFlow error codes and their associated data. Concrete use cases include parsing error responses from switches, constructing error messages for control plane debugging, and logging detailed error information during network management operations.",
      "description_length": 466,
      "index": 471,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x01.Match",
      "library": "frenetic",
      "description": "This module handles pattern matching for OpenFlow 1.0 messages, providing functions to parse, marshal, and convert patterns to strings. It operates on `pattern` data structures representing packet match conditions. Use cases include processing and serializing flow table entries in software-defined networking applications.",
      "description_length": 323,
      "index": 472,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Async.Http_Controller",
      "library": "frenetic",
      "description": "This module implements an asynchronous HTTP controller for handling network requests. It provides a `main` function that starts a server on specified IPv4 and IPv6 ports, managing concurrent connections and routing HTTP traffic. Concrete use cases include building lightweight web servers or RESTful APIs that handle dynamic request processing and response generation.",
      "description_length": 368,
      "index": 473,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.OpenFlow0x04.GroupDesc",
      "library": "frenetic",
      "description": "This module defines operations for handling OpenFlow 1.3.4 group description structures. It provides functions to calculate the size of a group description, convert it to a string, and serialize or parse it from a memory buffer. These operations are used when managing switch group tables, such as during group addition, modification, or querying.",
      "description_length": 347,
      "index": 474,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Packet.Udp",
      "library": "frenetic",
      "description": "This module defines the structure of UDP packets, including source and destination ports, checksum, and payload. It provides functions to serialize and deserialize UDP packet data for use in network communication tasks like packet inspection or crafting. Concrete use cases include handling UDP-based protocols such as DNS or DHCP within packet processing applications.",
      "description_length": 369,
      "index": 475,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x04.TableFeature",
      "library": "frenetic",
      "description": "This module handles the serialization, parsing, and representation of OpenFlow 1.3.4 table feature structures. It provides operations to calculate the size of a table feature, convert it to and from a Cstruct buffer, and generate a human-readable string representation. These functions are used when configuring or querying switch table capabilities in an OpenFlow controller.",
      "description_length": 376,
      "index": 476,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x01.Action",
      "library": "frenetic",
      "description": "This module handles OpenFlow 1.0 action manipulation, including parsing, marshaling, and string representation. It works with `action` values and action sequences, which are lists of actions. Specific operations include reordering actions to ensure controller outputs occur last, converting actions to strings, and serializing actions to and from binary formats.",
      "description_length": 362,
      "index": 477,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.Packet.Arp",
      "library": "frenetic",
      "description": "This module defines the structure and serialization of ARP packets, supporting Query and Reply operations with Ethernet and IP address fields. It works with `t` values representing ARP payloads, using `dlAddr` and `nwAddr` types from the parent packet module. Concrete use cases include constructing and parsing ARP messages for network discovery and address resolution in packet processing applications.",
      "description_length": 404,
      "index": 478,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x04.MeterFeatures",
      "library": "frenetic",
      "description": "This module handles parsing, marshaling, and string representation of OpenFlow 1.3.4 meter features structures. It operates on the `meterFeatures` type, which encodes capabilities and constraints of metering in a switch. Use this module to serialize meter features to and from network format, or to inspect their contents programmatically.",
      "description_length": 339,
      "index": 479,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Netkat.Pretty",
      "library": "frenetic",
      "description": "This module provides functions to format and convert network policies and predicates into human-readable strings. It works with the `policy` and `pred` types defined in the `Frenetic_netkat.Syntax` module. Use it to print or log policies and predicates in a readable form, or to generate string representations for debugging and configuration output.",
      "description_length": 350,
      "index": 480,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Netkat.Parser",
      "library": "frenetic",
      "description": "Parses NetKAT policies and predicates from strings or files, handling both complete and portless input. Converts string representations into structured policy and predicate types defined in `Frenetic_netkat.Syntax`. Useful for loading and interpreting NetKAT programs from text sources, especially when port information is omitted or symbolic analysis is required.",
      "description_length": 364,
      "index": 481,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x04.QueueRequest",
      "library": "frenetic",
      "description": "This module defines the structure and operations for handling OpenFlow Queue Statistics requests. It provides functions to serialize (`marshal`), deserialize (`parse`), and compute the size (`sizeof`) of queue request messages, along with pretty-printing (`to_string`). It works directly with `Cstruct.t` and the `Frenetic.OpenFlow0x04.queueRequest` type to support efficient network communication and debugging.",
      "description_length": 412,
      "index": 482,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x01.SwitchConfig",
      "library": "frenetic",
      "description": "This module represents OpenFlow 1.0 switch configuration settings, including fragment handling flags and the maximum number of bytes to send when a packet misses the flow table. It provides functions to serialize and deserialize configurations to and from S-expressions and to convert configurations to string representations. It is used to manage how switches handle fragmented packets and control packet buffering during flow setup.",
      "description_length": 434,
      "index": 483,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x04.TableStats",
      "library": "frenetic",
      "description": "This module handles parsing, marshaling, and string representation of OpenFlow 1.3.4 table statistics. It operates on the `t` type representing table statistics, including fields like table ID, active count, and lookup/matched counts. Use it to serialize table stats into network buffers, deserialize them from packets, or generate human-readable output for debugging.",
      "description_length": 368,
      "index": 484,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Network.Node",
      "library": "frenetic",
      "description": "This module represents network nodes with structured attributes including name, unique identifier, device type (switch, host, or middlebox), MAC and IP addresses. It provides functions to serialize and deserialize nodes, convert them to formats like DOT and Mininet, and parse node data from graph representations. Concrete use cases include modeling network topologies, configuring virtual networks, and exporting node information for visualization or simulation.",
      "description_length": 464,
      "index": 485,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x04.AggregateStats",
      "library": "frenetic",
      "description": "This module defines operations for handling aggregate flow statistics in OpenFlow 1.3.4. It provides functions to parse and marshal the `aggregStats` structure, as well as compute its size and convert it to a string. These operations are used when retrieving or processing aggregated flow data from a switch, such as counting matching flows or summarizing packet statistics.",
      "description_length": 374,
      "index": 486,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.Network.NetPath",
      "library": "frenetic",
      "description": "This module computes shortest paths in network topologies, providing functions to find single or multiple shortest paths between vertices. It works with weighted edges and vertex identifiers from a network topology. Concrete use cases include determining optimal routing paths in software-defined networks based on latency or bandwidth metrics.",
      "description_length": 344,
      "index": 487,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x04.Hello",
      "library": "frenetic",
      "description": "This module handles the parsing, serialization, and size calculation of OpenFlow Hello elements as defined in version 1.3.4. It operates on `t` values representing Hello elements, providing functions to convert them to strings, marshal them to binary buffers, and parse them from binary data. It is used during the initial handshake with an OpenFlow switch to negotiate protocol versions.",
      "description_length": 388,
      "index": 488,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Packet.Igmp1and2",
      "library": "frenetic",
      "description": "This module defines the structure and serialization for IGMP v1 and v2 messages, specifically handling the maximum response time, checksum, and group address fields. It works with the `t` record type containing 8-bit and 16-bit integers and a network address. Concrete use cases include parsing and generating IGMP message payloads for network monitoring or multicast management in packet processing applications.",
      "description_length": 413,
      "index": 489,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Network",
      "library": "frenetic",
      "description": "This module provides graph-based network modeling with typed vertices and edges, supporting shortest path computation, topology analysis, and serialization. It works with structured node and link data types that include metadata like device type, MAC/IP addresses, cost, and capacity. Concrete use cases include dynamic routing in software-defined networks, network simulation, and generating Mininet test environments from abstract topologies.",
      "description_length": 444,
      "index": 490,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow_Header",
      "library": "frenetic",
      "description": "This module defines the fixed header structure shared by all OpenFlow messages, providing functions to parse and marshal the header fields from and to raw packet buffers. It works with the `t` record type representing the header and the `xid` type for transaction identifiers. Use this module when handling OpenFlow protocol messages to extract or construct their standard header information.",
      "description_length": 392,
      "index": 491,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Topology",
      "library": "frenetic",
      "description": "This module provides operations for constructing and analyzing network topologies, including retrieving switch identifiers, querying port connections, and validating edge relationships. It works with graph structures representing network devices and their interconnections, using data types like switch IDs, port IDs, and topology representations. Concrete use cases include configuring software-defined networks, validating network reachability, and simulating network layouts for testing routing algorithms.",
      "description_length": 509,
      "index": 492,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Packet",
      "library": "frenetic",
      "description": "This module provides structured manipulation of network packet data through serialization, deserialization, and field-level access across Ethernet, IP, and transport-layer protocols. It operates on packet payloads using types like `Cstruct.t` for binary representations, along with typed wrappers for MAC addresses, VLAN tags, IP addresses, and protocol fields, enabling precise packet construction and inspection. Key applications include SDN packet processing, network analysis tools, and low-level packet crafting for testing or protocol implementation.",
      "description_length": 556,
      "index": 493,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Util",
      "library": "frenetic",
      "description": "This module includes functions for string formatting with custom formatters, mapping over tuple lists, and generating or displaying DOT graphs. It works with lists, tuples, and string-based representations of structured data. These functions support tasks like debugging with formatted output, transforming tuple lists, and visualizing graph structures directly from string inputs.",
      "description_length": 381,
      "index": 494,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Net",
      "library": "frenetic",
      "description": "This module provides data types and operations for modeling network topologies, including nodes (switches and hosts), links, and graph structures. It supports concrete tasks like network simulation, routing analysis, and topology visualization through functions for graph construction, traversal, shortest path computation, and format conversion. Key data types include `node`, `link`, and graph representations that incorporate port-based connectivity.",
      "description_length": 453,
      "index": 495,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.Bits",
      "library": "frenetic",
      "description": "This module provides direct bit and byte manipulation operations for 32-bit and 64-bit integers. It includes functions to set, clear, test, and conditionally update individual bits, as well as extract specific bytes from integer values. These operations are useful for low-level programming tasks such as protocol implementation, hardware control, and binary data parsing.",
      "description_length": 372,
      "index": 496,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Async",
      "library": "frenetic",
      "description": "This module collection implements asynchronous networking and control components for software-defined networks. It provides HTTP and OpenFlow controllers for managing network devices, dynamic dataflow graphs for reactive systems, and profiling and logging tools for monitoring asynchronous computations. Concrete applications include building network policy compilers, real-time traffic analyzers, and distributed SDN controllers that handle switch communication and flow management.",
      "description_length": 483,
      "index": 497,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x04",
      "library": "frenetic",
      "description": "This module handles structured data interchange for OpenFlow 1.3 protocol messages, focusing on serialization and deserialization of types like match fields (OXM), actions, flow entries, port configurations, and error codes via S-expressions. It operates on network-centric data structures including packet metadata, switch identifiers, group tables, meters, and control plane configurations to enable precise management of switch state and packet processing pipelines. Key use cases include controller-switch communication for dynamic flow rule updates, port and queue configuration, error handling during protocol negotiations, and gathering switch statistics for SDN applications.",
      "description_length": 683,
      "index": 498,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.GroupTable0x04",
      "library": "frenetic",
      "description": "This module manages a mutable group table for defining OpenFlow 1.3-style action groups. It supports creating groups with multiple action buckets, including fast failover groups that select the first live port, and generates corresponding OpenFlow messages for switch configuration. Operations include adding or clearing groups, and committing changes to produce a sequence of control messages.",
      "description_length": 394,
      "index": 499,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x01",
      "library": "frenetic",
      "description": "This module provides serialization, deserialization, and parsing operations for OpenFlow 1.0 control messages and their components, including flow modifications, packet-in events, port statistics, and match patterns. It works with structured types like `flowMod`, `packetIn`, `portStats`, and `match`, along with identifiers such as `switchId` and `portId`, using S-expressions and binary formats for data exchange. These capabilities support use cases in software-defined networking, such as switch communication, flow rule management, network telemetry, and error handling for corrupted or unsupported messages.",
      "description_length": 613,
      "index": 500,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Hashcons",
      "library": "frenetic",
      "description": "This module implements hash-consing for a parameterized value type, ensuring physically identical representations for equal values. It provides operations to generate a unique integer key for a value, retrieve the value from its key, and remove entries by key. It is particularly useful in symbolic computation and term rewriting systems where maintaining canonical forms of data is essential.",
      "description_length": 393,
      "index": 501,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Netkat",
      "library": "frenetic",
      "description": "This module provides operations for parsing, compiling, optimizing, and executing network policies using finite automata, Flow Decision Diagrams (FDDs), and OpenFlow-compatible representations. It manipulates packet classification rules via lattice operations on integer-pair keys, enabling efficient decision tree construction, while supporting tasks like bisimilarity verification, adversarial fabric generation, and domain-specific SDN optimizations. Key applications include policy transformation pipelines, packet evaluation, and structured data serialization for network topologies and predicates.",
      "description_length": 603,
      "index": 502,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.OpenFlow",
      "library": "frenetic",
      "description": "This module translates high-level network actions into OpenFlow 1.0 and 1.3 protocols, managing flow tables, packet modifications, and group table configurations. It operates on structured types like flow entries with match patterns, action sequences, and switch features, while handling version-specific semantics such as failover groups in 1.3 versus controller round-trips in 1.0. Use cases include compiling parallel actions into efficient group table operations for OpenFlow 1.3 or emulating them in 1.0, alongside serializing complex structures for switch communication and debugging.",
      "description_length": 590,
      "index": 503,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic",
      "library": "frenetic",
      "description": "This module collection provides low-level bit manipulation, OpenFlow protocol handling, network modeling, and asynchronous control components. It includes structured operations for managing switch state, compiling network policies, and modeling topologies with typed graph data. Concrete use cases involve SDN controller development, network simulation, packet processing, and protocol implementation.",
      "description_length": 401,
      "index": 504,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 512,
    "meaningful_modules": 505,
    "filtered_empty_modules": 7,
    "retention_rate": 0.986328125
  },
  "statistics": {
    "max_description_length": 714,
    "min_description_length": 236,
    "avg_description_length": 419.4930693069307,
    "embedding_file_size_mb": 7.317615509033203
  }
}