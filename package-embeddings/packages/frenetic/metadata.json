{
  "package": "frenetic",
  "embedding_model": "Qwen/Qwen3-Embedding-0.6B",
  "embedding_dimension": 1024,
  "total_modules": 581,
  "creation_timestamp": "2025-07-16T00:34:08.142083",
  "modules": [
    {
      "module_path": "Frenetic.Netkat.Fdd.Action.Par.Tree.Named",
      "library": "frenetic",
      "description": "This module implements parallel tree structures for representing and manipulating OpenFlow actions within Forwarding Decision Diagrams (FDDs). It provides operations to check subset and equality relationships between named action trees, ensuring correctness during FDD compilation and optimization. These capabilities are essential for translating NetKAT policies into efficient switch-level flow tables.",
      "description_length": 404,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Netkat.Fdd.Action.Par.Tree.Provide_of_sexp",
      "library": "frenetic",
      "description": "Converts S-expressions into FDD structures with OpenFlow actions at leaves. Works with NetKAT predicates and header match fields for network policy compilation. Used to parse serialized FDDs into executable flow tables for software-defined networking.",
      "description_length": 251,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Netkat.Fdd.Action.Seq.Tree.Provide_of_sexp",
      "library": "frenetic",
      "description": "This module defines a function `t_of_sexp` that parses S-expressions into FDD action sequence trees, using a provided conversion function for the key type. It works with NetKAT FDD structures that have OpenFlow actions at their leaves and use complete header matches for decision nodes. A concrete use case is deserializing NetKAT policy configurations from S-expression representations into executable FDD-based flow tables.",
      "description_length": 425,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Netkat.Local_compiler.FDD.BinTbl.Provide_bin_io",
      "library": "frenetic",
      "description": "This module implements binary serialization and deserialization for FDD-based tables parameterized by a key type. It provides functions to compute the binary shape, size, and perform reading and writing operations for FDD tables. Concrete use cases include persisting FDD tables to disk or transmitting them over a network in a binary format.",
      "description_length": 342,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Netkat.Global_compiler.FDD.BinTbl.Provide_of_sexp",
      "library": "frenetic",
      "description": "This module implements a function `t_of_sexp` that parses S-expressions into a binary table structure keyed by a specific type. It works with FDDs (Variable-Lattice-Result structures) and uses a key module to define the indexing logic. A concrete use case is deserializing network policy rules stored in S-expression format into an optimized binary decision diagram representation for efficient evaluation and manipulation.",
      "description_length": 423,
      "index": 4,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.Netkat.Global_compiler.FDD.Tbl.Provide_of_sexp",
      "library": "frenetic",
      "description": "This module implements a function `t_of_sexp` that parses S-expressions into a table structure indexed by a key type, where values are FDDs (Variable-Lattice-Result structures). It specifically handles deserialization of nested S-expressions using a provided conversion function for the value type. A typical use case involves reconstructing FDD-based decision diagrams from serialized configurations or specifications.",
      "description_length": 419,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Netkat.Local_compiler.FDD.Tbl.Provide_bin_io",
      "library": "frenetic",
      "description": "This module implements binary serialization and deserialization for FDD-based tables indexed by a key type. It provides functions to convert FDD tables to and from binary format, supporting efficient storage and transmission. Use cases include persisting FDD tables to disk or sending them over a network.",
      "description_length": 305,
      "index": 6,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.Netkat.Fdd.Action.Par.Named",
      "library": "frenetic",
      "description": "This module implements operations for comparing and checking subset relationships between named OpenFlow actions in Forwarding Decision Diagrams (FDDs). It provides concrete functions `is_subset` and `equal` to determine whether one set of named actions is a subset of or exactly matches another, respectively. These operations are used during FDD compilation to optimize and validate flow tables derived from NetKAT policies.",
      "description_length": 426,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Netkat.Fdd.Action.Par.Provide_of_sexp",
      "library": "frenetic",
      "description": "Converts S-expressions into parallel action values, specifically handling the deserialization of OpenFlow action lists within Forwarding Decision Diagrams. Works with `Frenetic.Netkat.Fdd.Action.Par.t`, a type representing unordered sets of OpenFlow actions. Useful when loading precomputed FDDs from storage or configuration files to reconstruct action logic for network forwarding decisions.",
      "description_length": 393,
      "index": 8,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.Netkat.Fdd.FDD.Tbl.Provide_bin_io",
      "library": "frenetic",
      "description": "This module implements binary serialization and deserialization for FDD tables keyed by a specific type. It provides functions to convert FDD tables to and from binary format, supporting efficient storage and transmission. Use cases include persisting compiled NetKAT policies to disk or sending them over a network.",
      "description_length": 316,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Netkat.Fdd.Action.Seq.Key",
      "library": "frenetic",
      "description": "This module defines a key type for sequences of actions in a Forwarding Decision Diagram (FDD), where each key represents either a field or a continuation. It provides comparison and serialization functions for these keys, enabling efficient manipulation and storage within FDD structures. The module is used to manage action sequencing during the compilation of NetKAT policies into flow tables.",
      "description_length": 396,
      "index": 10,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Netkat.Fdd.FDD.BinTbl.Provide_of_sexp",
      "library": "frenetic",
      "description": "This module provides functions to convert S-expressions into FDD-based flow tables, specifically using the `t_of_sexp` function. It operates on FDDs structured as Variable-Lattice-Result (VLR) types, with a focus on handling OpenFlow actions and header matches. A concrete use case is parsing serialized NetKAT policies into executable flow tables for network forwarding.",
      "description_length": 371,
      "index": 11,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Netkat.Global_compiler.FDD.BinTbl.Provide_bin_io",
      "library": "frenetic",
      "description": "This module implements binary serialization and deserialization for FDD-based tables parameterized by a key type. It provides functions to convert FDD tables to and from binary format, supporting efficient storage and transmission. Use cases include persisting FDD tables to disk or sending them over a network.",
      "description_length": 311,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Netkat.Fdd.Action.Seq.Provide_of_sexp",
      "library": "frenetic",
      "description": "This module defines functions for converting S-expressions into FDD action sequences, which represent ordered collections of OpenFlow actions. It operates on S-expressions and FDD structures with actions at the leaves. A concrete use case is parsing NetKAT policy configurations from S-expression format into executable flow tables.",
      "description_length": 332,
      "index": 13,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Netkat.Fdd.Action.Seq.Provide_bin_io",
      "library": "frenetic",
      "description": "This module implements binary serialization and deserialization for FDD action sequences, specifically handling values of type `'a Frenetic.Netkat.Fdd.Action.Seq.t`. It provides functions to compute the size, shape, and binary representation of these sequences, along with readers and writers for efficient I/O operations. Concrete use cases include persisting compiled flow tables to disk or transmitting them over a network in a compact binary format.",
      "description_length": 453,
      "index": 14,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Netkat.Local_compiler.FDD.Tbl.Provide_of_sexp",
      "library": "frenetic",
      "description": "This module implements a function `t_of_sexp` that parses S-expressions into a table structure indexed by a key type, specifically used for constructing FDDs (Variable-Lattice-Result structures) from serialized data. It operates on S-expressions and maps them to FDD tables using a provided conversion function for values. A concrete use case is deserializing network policy rules represented in S-expression format into an FDD-based decision diagram for efficient packet classification.",
      "description_length": 487,
      "index": 15,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.Netkat.Fdd.Action.Par.Provide_bin_io",
      "library": "frenetic",
      "description": "This module implements binary serialization and deserialization for parallel action FDDs, enabling efficient storage and transmission of flow decision structures. It operates directly on `Frenetic.Netkat.Fdd.Action.Par.t` values, which represent sets of OpenFlow actions in NetKAT's FDD-based forwarding model. Concrete use cases include persisting compiled flow tables to disk or sending them over the network in a compact binary format.",
      "description_length": 438,
      "index": 16,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Netkat.Fdd.Action.Seq.Tree",
      "library": "frenetic",
      "description": "This module represents hierarchical key-value structures with NetKAT-specific OpenFlow match fields as keys and action sequences or polymorphic data as values. It supports tree construction, transformation, and querying with deduplication, merging, and error handling, enabling efficient compilation of network policies into compact flow tables. The child module provides `t_of_sexp` to parse S-expressions into FDD action sequence trees, facilitating the deserialization of NetKAT policies into executable flow tables with structured header matches. Together, they enable precise manipulation and optimization of network rulesets through ordered traversal, range queries, and customizable field ordering strategies.",
      "description_length": 716,
      "index": 17,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Netkat.Fdd.Action.Par.Provide_hash",
      "library": "frenetic",
      "description": "This module implements hash functions for FDD action parallel structures, enabling efficient comparison and caching of flow table entries. It operates directly on `Frenetic.Netkat.Fdd.Action.Par.t` values, which represent sets of OpenFlow actions applied to network headers. Concrete use cases include optimizing FDD compilation by detecting equivalent action nodes and reducing memory usage during flow table generation.",
      "description_length": 421,
      "index": 18,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Netkat.Fdd.Action.Seq.Provide_hash",
      "library": "frenetic",
      "description": "This module provides a function `hash_fold_t` that computes a hash for sequences of actions in a Forwarding Decision Diagram (FDD). It operates on FDD action sequences, which represent OpenFlow actions applied to network packets. A concrete use case is enabling efficient comparison and caching of FDD nodes during compilation to flow tables, as described in the NetKAT compiler paper.",
      "description_length": 385,
      "index": 19,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Netkat.Fdd.FDD.Tbl.Provide_of_sexp",
      "library": "frenetic",
      "description": "This module implements a table structure for FDDs (Forwarding Decision Diagrams) that maps keys to FDD values, enabling efficient serialization and deserialization of FDD-based forwarding tables from S-expressions. It supports operations to convert S-exxp representations into typed FDD tables, where each entry corresponds to a decision path in the FDD leading to an OpenFlow action. It is used to construct and manipulate flow tables from NetKAT policies by translating symbolic S-expressions into executable FDD-based tables.",
      "description_length": 528,
      "index": 20,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.Netkat.Fdd.Action.Par.Elt",
      "library": "frenetic",
      "description": "This module represents elements of a parallel action table in the FDD structure, where each element maps a header match to a sequence of OpenFlow actions. It provides serialization and deserialization functions for converting action elements to and from S-expressions, along with a comparator for ordering. It is used during FDD compilation to manage action application in flow tables derived from NetKAT policies.",
      "description_length": 414,
      "index": 21,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Netkat.Local_compiler.FDD.BinTbl.Provide_of_sexp",
      "library": "frenetic",
      "description": "This module implements a function `t_of_sexp` that parses S-expressions into a binary decision diagram (FDD) structure parameterized by a key type. It works with FDDs that map keys to arbitrary values using a lattice structure. A concrete use case is deserializing network policy rules represented as S-expressions into an FDD for efficient analysis and composition.",
      "description_length": 366,
      "index": 22,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Netkat.Fdd.FDD.BinTbl.Provide_bin_io",
      "library": "frenetic",
      "description": "This module provides binary serialization and deserialization operations for FDDs (Forwarding Decision Diagrams) represented as binary tables. It works with FDDs parameterized over a key type, enabling efficient marshaling to and from binary formats. Concrete use cases include persisting compiled flow tables to disk or transmitting them over a network in a compact, efficient format for switch updates.",
      "description_length": 404,
      "index": 23,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Netkat.Fdd.Action.Par.Tree",
      "library": "frenetic",
      "description": "This module manages ordered tree-based sets of NetKAT actions, enabling efficient functional transformations, set operations, and ordered traversals over immutable tree structures (`t`) with elements of type `Elt.t`. It supports key operations like union, intersection, and binary search, facilitating the compilation and optimization of network policies through hierarchical flow rule decompositions. The first child module extends this functionality with parallel tree structures for representing OpenFlow actions within FDDs, offering subset and equality checks to ensure correctness during FDD compilation. The second child module parses S-expressions into FDDs with OpenFlow actions at leaves, integrating NetKAT predicates and header matches to generate executable flow tables for software-defined networking.",
      "description_length": 815,
      "index": 24,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Netkat.Semantics.HeadersValues.Fields.Direct",
      "library": "frenetic",
      "description": "This module directly manipulates header-value maps for network packet processing, providing field-specific operations to iterate, fold, map, and query individual header fields such as Ethernet source/destination, VLAN tags, IP addresses, and TCP ports. It supports concrete data types like `Frenetic_kernel.Packet.dlAddr`, `Frenetic_kernel.Packet.nwAddr`, and `Frenetic_netkat.Syntax.location`, enabling precise control over packet header transformations. Use cases include packet classification, header rewriting, and policy enforcement in software-defined networking applications.",
      "description_length": 582,
      "index": 25,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.Netkat.Global_compiler.FDD.Tbl.Provide_bin_io",
      "library": "frenetic",
      "description": "This module implements binary serialization and deserialization for FDD tables parameterized by a key type. It provides functions to convert FDD tables to and from binary format, supporting efficient storage or transmission. Use cases include persisting FDD-based state to disk or sending it across network connections.",
      "description_length": 319,
      "index": 26,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.Netkat.Fdd.Field.Env",
      "library": "frenetic",
      "description": "This module maps string identifiers to FDD fields, along with their initialization and mutability status, using operations like `add` and `lookup`. It works with environments (`t`), string keys, and FDD field representations. Concrete use cases include managing header field metadata during FDD construction and tracking which fields are mutable or initialized in a flow table compilation pass.",
      "description_length": 394,
      "index": 27,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Net.Net.Topology.UnitWeight",
      "library": "frenetic",
      "description": "This module defines a unit weight type and operations for working with weighted edges in a network topology. It provides functions to convert weights to and from S-expressions, compare weights, add weights, and retrieve the weight of an edge. The module is used to assign and manipulate integer weights on edges in a network graph, such as modeling uniform link costs in a software-defined network.",
      "description_length": 398,
      "index": 28,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Net.Net.Topology.Edge",
      "library": "frenetic",
      "description": "This module represents edges in a network topology, providing functions to convert edges to and from S-expressions, compare edges, generate string and DOT format representations, and parse edges from DOT and GML attribute lists. It works with edge data structures that encapsulate link information in a network graph. Concrete use cases include serializing and deserializing network links for storage, visualization using DOT format, and integrating with graph processing tools that consume GML input.",
      "description_length": 501,
      "index": 29,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.Net.Net.Topology.Vertex",
      "library": "frenetic",
      "description": "This module defines a vertex type used in network topology representations, based on `Frenetic.Net.Node.t`. It provides functions for converting vertices to and from S-expressions, comparing vertices, and serializing them to formats like DOT and Mininet. It also includes parsers for constructing vertices from DOT and GML AST structures.",
      "description_length": 338,
      "index": 30,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Netkat.Fdd.Action.Seq",
      "library": "frenetic",
      "description": "This module manages ordered sequences of key-value pairs with unique keys, optimized for NetKAT FDD actions and structured header matches. It supports transformations like folding, filtering, and merging while preserving key order and uniqueness, enabling the compilation of network policies into efficient flow tables. The key module handles structured match keys with comparison and serialization, while the parser and serializer modules convert S-expressions to action sequences and handle binary I/O. Additional utilities compute hashes for action sequences and represent hierarchical key-value trees, supporting policy deserialization, deduplication, and structured traversal for network rule optimization.",
      "description_length": 711,
      "index": 31,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Netkat.Semantics.HeadersValues.Fields",
      "library": "frenetic",
      "description": "This module provides structured access to packet header fields through a type-safe map-like structure, enabling operations like traversal, filtering, and transformation of network data such as MAC addresses, IP addresses, and TCP ports. It supports existential checks and bulk conversions across headers including Ethernet, VLAN, and IP, facilitating tasks like packet validation and policy enforcement. Child modules enhance this functionality with field-specific iteration, mapping, and querying operations, using concrete types like `dlAddr`, `nwAddr`, and `location` for precise packet manipulation in SDN pipelines. Examples include rewriting source addresses, filtering by port ranges, and enforcing location-based forwarding rules.",
      "description_length": 738,
      "index": 32,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.Topology.Net.Topology.Edge",
      "library": "frenetic",
      "description": "This module defines operations for representing and manipulating network edges, including parsing from and converting to formats like DOT and GML. It works directly with edge data structures that model network links, supporting tasks like comparison, serialization, and string representation. Concrete use cases include network topology analysis, graph visualization, and configuration parsing from structured formats.",
      "description_length": 418,
      "index": 33,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Network.Net.Topology.Vertex",
      "library": "frenetic",
      "description": "This module defines a vertex type based on network nodes and provides serialization to and from S-expressions, comparison, string conversion, and formatting for DOT and Mininet. It supports parsing vertices from DOT and GML graph representations. Concrete use cases include representing and manipulating network topology nodes in graph processing and network simulation workflows.",
      "description_length": 380,
      "index": 34,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.Netkat.Fdd.Action.Par",
      "library": "frenetic",
      "description": "This module manages immutable, ordered sets of OpenFlow actions, supporting set operations like union, intersection, and difference, along with normalization via `mod_k`. It provides efficient transformations to trees, maps, and sequences, and supports queries for membership, maxima, and ordered traversal, all working on immutable sets of action elements (`Elt.t`). The module enables key NetKAT policy compilation tasks such as merging divergent paths in FDDs, optimizing flow tables through deduplication, and checking action equivalence modulo field values. Submodules extend this with subset and equality checks, S-expression and binary serialization, hashing for caching, and tree-based representations that integrate with FDD construction and parsing workflows.",
      "description_length": 769,
      "index": 35,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Netkat.Local_compiler.FDD.BinTbl",
      "library": "frenetic",
      "description": "This module provides binary serialization and deserialization for FDD-based tables, including functions to compute binary shape and size, and to read and write FDD tables in binary format. It also includes a submodule that parses S-expressions into FDDs parameterized by a key type, supporting the construction of binary decision diagrams from structured representations. The main data types involve FDDs mapping keys to values with a lattice structure, and operations include serializing to binary, computing size, and parsing from S-expressions. You can use it to persist FDD tables to disk, transmit them over a network, or load network policy rules into an FDD for analysis.",
      "description_length": 678,
      "index": 36,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Netkat.Local_compiler.FDD.Tbl",
      "library": "frenetic",
      "description": "This module manages key-value associations with keys of type `FDD.t`, supporting imperative updates and functional transformations like merging, filtering, and multi-value mapping. It includes utilities for serialization, equality checks, and safe key handling, working with values such as lists and integer counters. The binary submodule enables efficient storage and transmission by converting tables to and from binary format, while the S-expression submodule constructs tables from serialized data using a conversion function. Example uses include persisting tables to disk, transmitting them over a network, or building decision diagrams for packet classification from policy rules.",
      "description_length": 687,
      "index": 37,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Topology.Net.Topology.UnitWeight",
      "library": "frenetic",
      "description": "This module defines a unit weight type as an integer and provides functions to manipulate weighted edges in a network topology. It includes operations for comparing weights, adding them, and serializing or deserializing both weights and edge structures. Concrete use cases include modeling network links with uniform cost and performing path calculations in routing algorithms.",
      "description_length": 377,
      "index": 38,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x04.Hello.Element.VersionBitMap",
      "library": "frenetic",
      "description": "This module handles the Supported Version Bitmap structure, which encodes the OpenFlow protocol versions supported by a switch during the initial handshake. It provides functions to parse and marshal a list of supported versions to and from binary format, as well as compute the size and generate string representations of the structure. It operates on `supportedList` values, which are lists of integers representing protocol versions.",
      "description_length": 436,
      "index": 39,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Netkat.Global_compiler.FDD.BinTbl",
      "library": "frenetic",
      "description": "This module manages binary decision diagram (BDD)-based tables with keys as pairs of FDDs or BDD nodes and values of arbitrary data, supporting imperative and functional operations like conditional filtering, partitioning, mapping, merging, and counter manipulation. It enables transformations with key exposure, structural equality checks, and multi-value lookups, tailored for network policy compilation and intermediate representation manipulation. Serialization is handled through S-expressions and binary I/O, allowing persistence and transmission, with child modules providing `t_of_sexp` for parsing and functions for binary conversion of FDD tables. Specific uses include deserializing network policy rules into optimized BDDs and transmitting FDD tables over a network.",
      "description_length": 778,
      "index": 40,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.OpenFlow0x01.PortDescription.PortState.StpState",
      "library": "frenetic",
      "description": "This module defines conversions between the `stpState` type and integer and string representations. It supports operations for encoding and decoding spanning tree protocol (STP) state values used in OpenFlow 1.0 port descriptions. Use this module when working with network switch port configurations that require STP state manipulation or serialization.",
      "description_length": 353,
      "index": 41,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Network.Make.Topology.UnitWeight",
      "library": "frenetic",
      "description": "This module implements a unit-weight topology where edges have integer weights. It provides functions to serialize and deserialize edge and weight values, compare weights, and perform addition with a zero value. It is used to model network topologies where each edge has a uniform cost, such as unweighted graph routing or basic pathfinding.",
      "description_length": 341,
      "index": 42,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Netkat.Global_compiler.FDD.Tbl",
      "library": "frenetic",
      "description": "This module manages hash tables keyed by functional decision diagrams (FDDs) with imperative updates, transformations, and queries over polymorphic values, particularly optimized for list-valued entries and integer counters. It supports serialization through S-expressions and binary I/O, enabling reconstruction of FDD-based structures from configuration files or efficient transmission over networks. Direct operations allow inserting, mapping, filtering, and aggregating FDD-backed entries, while child modules provide deserialization from S-expressions and round-trip binary encoding/decoding. Example uses include compiling network policies from structured specifications and maintaining dynamic state with symbolic decision diagrams.",
      "description_length": 739,
      "index": 43,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Netkat.Fdd.FDD.Tbl",
      "library": "frenetic",
      "description": "This module manages imperative hash tables optimized for network control planes, where keys are structured as Forwarding Decision Diagrams (FDDs) representing OpenFlow-like match-action rules. It supports operations for grouping equivalent FDDs, merging overlapping entries, and maintaining reference counts, with direct support for list-valued entries, in-place updates, and serialization. The binary serialization submodule enables efficient storage and transmission of FDD tables, while the S-expression submodule allows constructing and manipulating FDD-based tables from symbolic NetKAT policies. Together, they enable compiling, minimizing, and distributing OpenFlow rule sets for network control applications.",
      "description_length": 716,
      "index": 44,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Network.Net.Topology.Edge",
      "library": "frenetic",
      "description": "This module represents and manipulates edges in a network topology, providing functions to convert edges to and from S-expressions, compare edges, and serialize them to string and DOT formats. It supports parsing edges from DOT and GML attribute lists and includes a default edge value. It is used to model network links in graph representations for network analysis and visualization tools.",
      "description_length": 391,
      "index": 45,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Network.Net.Topology.UnitWeight",
      "library": "frenetic",
      "description": "This module defines a unit weight type and operations for working with weighted edges in a network topology. It provides functions to convert weights to and from S-expressions, compare weights, add weights, and retrieve the weight of an edge. The module is used to assign and manipulate integer weights on edges in a network graph, typically for routing or pathfinding computations.",
      "description_length": 382,
      "index": 46,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Topology.Net.Topology.Vertex",
      "library": "frenetic",
      "description": "This module defines a vertex type used in network topology representations, providing functions for converting vertices to and from various formats like S-expressions, DOT, and GML. It includes operations for comparing vertices, converting them to strings, and parsing them from DOT and GML input formats. Concrete use cases include loading network topologies from DOT or GML files, serializing vertices for storage or transmission, and generating string identifiers for visualization or Mininet configuration.",
      "description_length": 510,
      "index": 47,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Netkat.Fdd.FDD.BinTbl",
      "library": "frenetic",
      "description": "This module enables efficient manipulation of hash tables with FDD-based keys and arbitrary values, supporting operations like merging, filtering, mapping, and in-place updates, with customizable handling of duplicate keys. It provides direct access to functional and imperative transformations, including conditional lookups and partitioning, essential for compiling and optimizing NetKAT policies into OpenFlow rule sets. The module supports serialization and deserialization through S-expressions and binary formats, allowing for the structured parsing and persistence of flow tables. Submodules handle FDD-specific conversions from S-expressions and efficient binary marshaling, enabling applications such as policy transmission and switch updates.",
      "description_length": 752,
      "index": 48,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Net.Net.Traverse",
      "library": "frenetic",
      "description": "Performs breadth-first and depth-first traversals over network topologies. Operates on graph structures defined by the Topology module, applying a function to each vertex visited. Useful for analyzing network reachability or propagating state across connected nodes.",
      "description_length": 266,
      "index": 49,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x01.Error.HelloFailed",
      "library": "frenetic",
      "description": "This module defines error codes for failed Hello messages in the OpenFlow 1.0 protocol. It includes the `Incompatible` and `Eperm` error types, which indicate version mismatches or permission issues during handshake. The module provides serialization to and from S-expressions and converts error values to human-readable strings.",
      "description_length": 329,
      "index": 50,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Topology.Net.Path",
      "library": "frenetic",
      "description": "This module computes shortest paths in a network topology using a specified weight type. It provides functions to find a single shortest path, all shortest paths from a source, and all pairs of shortest paths with a filtering function. The operations work directly with vertices and edges from a topology module, returning path lists or options when paths exist.",
      "description_length": 362,
      "index": 51,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x01.PortDescription.PortState",
      "library": "frenetic",
      "description": "This module handles the conversion of OpenFlow 1.0 port state values to and from strings and integers, centered around the `portState` type. It includes operations for serializing port state data for logging or network transmission, and integrates the `stpState` submodule for handling spanning tree protocol state conversions. The `portState` type can be used to represent and manipulate switch port states, while the submodule provides encoding and decoding functions for STP-specific values. Example uses include converting a `portState` to an integer for transmission, or parsing an STP state string into its corresponding integer representation for switch configuration.",
      "description_length": 675,
      "index": 52,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.Net.Net.Pretty",
      "library": "frenetic",
      "description": "This module converts network topologies into string representations. It provides functions to generate human-readable text, DOT format for visualization, and Mininet scripts for network simulation. These operations take a topology structure as input and produce formatted output strings, optionally incorporating external prologue and epilogue files in the Mininet case.",
      "description_length": 370,
      "index": 53,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Network.Make.Parse",
      "library": "frenetic",
      "description": "Converts network topologies from DOT or GML file formats into an in-memory representation. Works with strings as file paths and returns structured topology data. Useful for loading predefined network graphs from external configuration files.",
      "description_length": 241,
      "index": 54,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.Network.Make.Traverse",
      "library": "frenetic",
      "description": "Implements breadth-first and depth-first traversal algorithms over network topologies. Operates on graph structures defined by the Topology module, visiting each vertex in a specified order. Useful for network analysis tasks like path discovery, node classification, or fault detection in software-defined networks.",
      "description_length": 315,
      "index": 55,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Netkat.Semantics.HeadersValues",
      "library": "frenetic",
      "description": "This module organizes network packet headers into a structured map, supporting operations like serialization, string conversion, and comparison. It centers on a record type that captures header-value pairs for entities such as Ethernet, IP, TCP, and VLAN, enabling tasks like packet processing and protocol implementation. Child modules provide type-safe access to specific header fields using concrete types like `dlAddr` and `nwAddr`, allowing operations such as filtering by port ranges, rewriting addresses, and enforcing forwarding rules. Together, they support precise packet manipulation in SDN pipelines through iteration, transformation, and bulk queries.",
      "description_length": 664,
      "index": 56,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Net.Net.Path",
      "library": "frenetic",
      "description": "This module computes shortest paths in a network topology using Dijkstra's algorithm. It operates on edge-weighted graphs represented by the Topology module, working with vertices and edges to find optimal routes between nodes. Concrete use cases include determining the most efficient data packet routes in a network or analyzing connectivity in graph structures.",
      "description_length": 364,
      "index": 57,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Async.Ox.Platform",
      "library": "frenetic",
      "description": "This module provides functions to send OpenFlow messages such as packet-out, flow-mod, stats request, and barrier request to switches, using switch identifiers, transaction IDs, and message-specific data. It also includes a timeout function that wraps a thunk to execute after a specified delay. These operations are used to manage communication with network switches and handle time-sensitive actions in SDN applications.",
      "description_length": 422,
      "index": 58,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x01.PortDescription.PortConfig",
      "library": "frenetic",
      "description": "This module converts port configuration values to and from string and 32-bit integer representations. It operates on the `portConfig` type defined in the `Frenetic.OpenFlow0x01` module. Use this module when serializing port configurations for transmission or parsing them from raw integer values in OpenFlow 1.0 messages.",
      "description_length": 321,
      "index": 59,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.Network.Net.PATH",
      "library": "frenetic",
      "description": "This module computes shortest paths in a network topology using edge-weighted graphs. It provides functions to find a single shortest path, all shortest paths from a source vertex, and all pairs of shortest paths based on a filtering function. These operations are used to determine optimal routing paths between network nodes and analyze connectivity in software-defined networking scenarios.",
      "description_length": 393,
      "index": 60,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Packet.Dns.Qd",
      "library": "frenetic",
      "description": "This module defines the DNS query section (`Qd`) with fields for domain name, record type, and class. It provides serialization and deserialization functions for converting DNS query data to and from S-expressions. Use this module when handling DNS request packets that require structured parsing or construction of query fields.",
      "description_length": 329,
      "index": 61,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x01.SwitchFeatures.SupportedActions",
      "library": "frenetic",
      "description": "This module represents the set of actions supported by an OpenFlow 1.0 switch, with each field indicating support for a specific action such as packet output, VLAN manipulation, or transport port modification. It provides functions to convert the structure to and from S-expressions and to generate a human-readable string representation. It is used to query and configure switch capabilities in network control applications.",
      "description_length": 425,
      "index": 62,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Topology.Net.Topology",
      "library": "frenetic",
      "description": "This module organizes network topology manipulation around vertex-labeled graphs with port-annotated edges, supporting dynamic updates, neighbor discovery, and path computation. It integrates edge operations for format conversion, comparison, and serialization, vertex utilities for format parsing and string representation, and weight handling for uniform-cost routing. You can load a topology from DOT or GML, compute next-hop routes, and serialize the structure for distributed state synchronization. Direct APIs for traversal and mutation work alongside submodules that refine edge, vertex, and weight behavior for specific tasks like visualization or Mininet configuration.",
      "description_length": 678,
      "index": 63,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Network.Make.UnitPath",
      "library": "frenetic",
      "description": "This module computes shortest paths in a network topology using integer weights. It provides functions to find a single shortest path, all shortest paths from a source vertex, and all pairs of shortest paths that satisfy a given predicate. The module works directly with lists of edges as paths and leverages a vertex hash table in intermediate computations.",
      "description_length": 358,
      "index": 64,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.OpenFlow0x01.PortStatus.ChangeReason",
      "library": "frenetic",
      "description": "This module defines an enumeration of port status change reasons, including `Add`, `Delete`, and `Modify`. It provides functions to convert these values to and from S-expressions and to obtain string representations. This is used to handle and interpret port status updates in OpenFlow 1.0 messages.",
      "description_length": 299,
      "index": 65,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Net.Net.Topology",
      "library": "frenetic",
      "description": "This module models network topologies with vertices, edges, and ports, supporting traversal, modification, and serialization. It integrates weighted edges for link cost modeling, edge utilities for DOT/GML conversion and comparison, and vertices based on `Frenetic.Net.Node.t` for compatibility with SDN frameworks. You can build dynamic network graphs, assign and sum link weights, and serialize the topology to S-expressions or DOT for visualization and analysis. Submodules enhance core operations with format-specific parsing, comparison, and transformation capabilities.",
      "description_length": 575,
      "index": 66,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.Async.NetKAT_Controller.CONTROLLER",
      "library": "frenetic",
      "description": "This module manages an asynchronous network controller that handles OpenFlow events, switch connections, and policy updates. It provides operations to retrieve network events, query port statistics, send packets, and update policies using either NetKAT or FDD representations. Key data types include switch IDs, port IDs, policies, and compiler options, with concrete use cases like monitoring traffic statistics, dynamically updating forwarding rules, and injecting packets at specific switches.",
      "description_length": 496,
      "index": 67,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Netkat.Domain.Field",
      "library": "frenetic",
      "description": "This module defines operations for comparing and ordering field values within a domain, specifically using the `compare` function and a associated comparator witness. It works directly with the `Frenetic.Netkat.Domain.Field.t` type, which represents individual field values in a domain. Concrete use cases include determining the ordering of fields during FDD (Functional Decision Diagram) manipulations and ensuring consistent field comparisons in automaton transitions.",
      "description_length": 471,
      "index": 68,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.Netkat.Fdd.Field",
      "library": "frenetic",
      "description": "This module defines named header fields for packet headers in NetKAT policies, supporting conversion between string and typed representations, comparison, hashing, and global field ordering management. Its child module maps string identifiers to FDD fields, tracking initialization and mutability status via operations like `add` and `lookup`, enabling structured handling of header metadata during FDD construction. Together, they facilitate tasks like compiling flow tables with accurate field tracking and optimizing FDD performance through dynamic field ordering. Specific operations include setting field order based on policy structure, resolving string keys into typed fields, and maintaining mutable field states across compilation passes.",
      "description_length": 747,
      "index": 69,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow.Pattern.Ip",
      "library": "frenetic",
      "description": "This module represents and manipulates IP address patterns with associated subnet masks, supporting operations such as matching, comparison, joining, and intersection. It works with IP addresses as `Frenetic_kernel.Packet.nwAddr` and includes a mask as an `int32`. Concrete use cases include defining packet flow rules that match specific IP ranges, checking whether two IP patterns overlap, and computing the most general pattern that includes multiple subnets.",
      "description_length": 462,
      "index": 70,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Topology.Net.UnitPath",
      "library": "frenetic",
      "description": "This module computes shortest paths in a network topology, providing functions to retrieve individual paths, all shortest paths from a source, and all pairs of shortest paths with edge details. It operates on graph structures defined by vertices and edges, using integer weights to represent path costs. Concrete use cases include network routing analysis and optimizing packet forwarding in software-defined networks.",
      "description_length": 418,
      "index": 71,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.Netkat.Global_compiler.Automaton",
      "library": "frenetic",
      "description": "This module represents NetKAT automata as an intermediate structure for the global compiler, using states mapped to field decision diagrams (FDDs) and managing transitions between states. It supports operations like adding transitions, folding over reachable states, converting policies to automata, and rendering automata to visual formats. Concrete use cases include compiling network policies into efficient automata representations and analyzing or transforming those representations for optimization or verification.",
      "description_length": 521,
      "index": 72,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Net.Net.UnitPath",
      "library": "frenetic",
      "description": "This module computes shortest paths in a network topology, providing functions to find individual shortest paths, all shortest paths from a source, and all pairs of shortest paths with optional filtering. It operates on graph structures defined by vertices and edges from the Topology module, returning paths as edge lists with associated weights. Concrete use cases include network routing analysis and path optimization in software-defined networking scenarios.",
      "description_length": 463,
      "index": 73,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.Packet.Igmp3.GroupRec",
      "library": "frenetic",
      "description": "This module defines a `GroupRec` type representing IGMP v3 group records, including the record type, multicast group address, and list of source addresses. It provides functions to serialize and deserialize these records to and from S-expressions. It is used for handling multicast group membership information in network packet processing.",
      "description_length": 340,
      "index": 74,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.Network.Net.UnitPath",
      "library": "frenetic",
      "description": "This module computes shortest paths in a network topology using edge lists to represent paths. It provides functions to find the shortest path between two vertices, all shortest paths from a source vertex, and all pairs of shortest paths with optional filtering. These operations are used to determine optimal routes in network topologies, such as selecting the most efficient data transmission paths between switches or hosts.",
      "description_length": 427,
      "index": 75,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.Topology.Net.PATH",
      "library": "frenetic",
      "description": "This module computes shortest paths in a network topology, providing functions to find individual shortest paths, all shortest paths from a source, and all pairs shortest paths with customizable filtering. It operates on graph structures represented by vertices and edges, with weighted path calculations. Concrete use cases include network routing optimization and failure path analysis in software-defined networks.",
      "description_length": 417,
      "index": 76,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Netkat.FabricGen.FABRIC_GEN",
      "library": "frenetic",
      "description": "This module generates a network fabric structure as a pair of policy lists, modeling both virtual and physical network components. It takes predicates and policies as inputs to define network behavior, including virtual and physical topologies, ingress and egress points, and visibility relations. Use this module to synthesize network configurations for virtual compilation, enabling path recording and logging for analysis or debugging.",
      "description_length": 438,
      "index": 77,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.Net.Net.Parse",
      "library": "frenetic",
      "description": "This module parses network topologies from file formats. It supports reading topologies from DOT and GML files, converting them into structured representations. Use this module to load predefined network graphs for simulation or analysis tasks.",
      "description_length": 244,
      "index": 78,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Packet.Ip.Flags",
      "library": "frenetic",
      "description": "This module defines and manipulates the flag fields (`df` and `mf`) of an IPv4 packet header. It provides direct access to the \"Don't Fragment\" and \"More Fragments\" flags, enabling inspection and modification of packet fragmentation behavior. Useful for implementing custom IP packet handling logic, such as fragmentation control or packet analysis in network applications.",
      "description_length": 373,
      "index": 79,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Netkat.Parser.Portless",
      "library": "frenetic",
      "description": "Parses NetKAT policies and predicates from strings or files, producing corresponding syntax trees. Works with string inputs and file paths, returning structured policy and predicate representations. Useful for directly converting NetKAT source code into executable forms without port-specific handling.",
      "description_length": 302,
      "index": 80,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.OpenFlow0x01.FlowRemoved.Reason",
      "library": "frenetic",
      "description": "This module defines conversions for flow removal reasons in OpenFlow 1.0. It provides functions to convert between the `flowRemovedReason` type and their string or 16-bit integer representations. Use this module when handling flow expiration events to interpret or serialize removal causes, such as idle timeout or hard timeout.",
      "description_length": 328,
      "index": 81,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x01.PortDescription.PortFeatures",
      "library": "frenetic",
      "description": "This module converts port feature flags to and from string and integer representations. It operates on the `portFeatures` type, which encodes OpenFlow 1.0 port capabilities like link speed and duplex mode. Use it to serialize port features for logging or network transmission, or to parse integer values from OpenFlow messages into structured flags.",
      "description_length": 349,
      "index": 82,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Netkat.Fdd.Pattern",
      "library": "frenetic",
      "description": "This module represents patterns in Forwarding Decision Diagrams (FDDs) as field-value pairs, enabling precise header matching for network policies. It supports operations to convert patterns to NetKAT predicates and OpenFlow structures, facilitating the translation of high-level policies into executable flow tables. Concrete use cases include compiling NetKAT programs into efficient OpenFlow rules for software-defined networks.",
      "description_length": 431,
      "index": 83,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Netkat.Fdd.Value",
      "library": "frenetic",
      "description": "This module represents values used in field tests and modifications within a decision diagram framework. It supports operations like equality checks, comparison, hashing, and lattice-based subsetting across variants such as constant integers, bitmasks, and abstract locations. Concrete use cases include representing Ethernet source addresses with masks, encoding packet modifications like port assignments, and supporting flow table generation by enabling precise field-value associations and transformations.",
      "description_length": 510,
      "index": 84,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Netkat.Global_compiler.FDD",
      "library": "frenetic",
      "description": "This module models network flow policies using functional decision diagrams (FDDs) with field-value pairs, actions, and hierarchical decision nodes, supporting operations like conditional branching, union, sequential composition, and Kleene star. It includes submodules for managing BDD-based tables and FDD-keyed hash tables, enabling efficient filtering, merging, serialization, and imperative transformations over structured and numeric data. Together, they facilitate policy compilation, equivalence checking, dynamic state tracking, and visualization through graph generation and optimized serialization formats. Example uses include translating network rules into symbolic representations, optimizing policy size, and transmitting structured FDD tables across networks.",
      "description_length": 775,
      "index": 85,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Async.Ox.Make",
      "library": "frenetic",
      "description": "This module builds an Ox controller that listens on port 6633 for OpenFlow messages from network switches and routes them to the provided `OxModule` callbacks. It operates on OpenFlow protocol data types and network event structures defined by the `OxModule`. Concrete use cases include implementing custom SDN controllers that react to switch connections, packet arrivals, or flow modifications in real-time.",
      "description_length": 409,
      "index": 86,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Async.NetKAT_Controller.PLUGIN",
      "library": "frenetic",
      "description": "This module manages interactions with OpenFlow switches in an SDN environment. It provides operations to start a controller, handle switch events, retrieve switch features, update flow tables, send packets, and query flow and port statistics. Concrete use cases include dynamically reconfiguring network policies, monitoring traffic patterns, and responding to switch connection/disconnection events.",
      "description_length": 400,
      "index": 87,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.Netkat.Vlr.Lattice",
      "library": "frenetic",
      "description": "This module defines a lattice structure with operations to compare, hash, and serialize elements. It supports data types that form a partial order, providing concrete functionality for checking subset relationships, equality, and ordering. Use cases include representing hierarchical or ordered domains like security levels, network policies, or abstract interpretation domains.",
      "description_length": 378,
      "index": 88,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Topology.Net.Traverse",
      "library": "frenetic",
      "description": "Implements breadth-first and depth-first traversal over network topologies represented as graphs. Operates on vertex data structures, applying a given function to each vertex during traversal. Useful for network discovery, path analysis, or monitoring tasks in software-defined networking applications.",
      "description_length": 302,
      "index": 89,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Network.Net.Parse",
      "library": "frenetic",
      "description": "Converts network topologies from DOT or GML file formats into internal graph representations. Works with strings as file paths and constructs Topology.t values. Useful for loading predefined network structures from external configuration files into the system for simulation or analysis.",
      "description_length": 287,
      "index": 90,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.Netkat.Local_compiler.FDD",
      "library": "frenetic",
      "description": "This module implements a Variable-Lattice-Result structure for efficient key-value storage and transformation, supporting imperative and functional operations over FDD keys. It provides direct access to serialization, equality checks, and lattice-based value manipulation, while submodules handle binary encoding and S-expression parsing for structured data conversion. You can build and analyze network policy rules by mapping them into FDDs, persist resulting tables to disk, or transmit them over a network in binary form. Key types include FDDs parameterized by keys and lattice-structured values, with operations for merging, filtering, and computing binary representations.",
      "description_length": 679,
      "index": 91,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.OpenFlow0x01.Error.FlowModFailed",
      "library": "frenetic",
      "description": "This module defines error codes for flow modification failures in OpenFlow 1.0, including specific cases like `AllTablesFull`, `Overlap`, and `Unsupported`. It provides conversions to and from S-expressions and a string representation for debugging or logging. These values are used to signal specific failure conditions when modifying flow tables in network switches.",
      "description_length": 368,
      "index": 92,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.OpenFlow0x01.SwitchFeatures.Capabilities",
      "library": "frenetic",
      "description": "This module defines a record type representing the capabilities of a switch in the OpenFlow 1.0 protocol, with boolean fields indicating support for features like flow statistics, table statistics, port statistics, STP, IP reassembly, queue statistics, and ARP matching. It includes functions to convert between the record and S-expressions, and a function to generate a human-readable string representation. It is used to query and represent the optional features supported by an OpenFlow switch during handshake and feature negotiation.",
      "description_length": 538,
      "index": 93,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.Network.Net.Traverse",
      "library": "frenetic",
      "description": "Implements breadth-first and depth-first traversal algorithms over network topologies. Operates on graph structures defined by vertices, applying a function to each vertex during traversal. Useful for analyzing connectivity, pathfinding, or network exploration tasks in software-defined networking.",
      "description_length": 298,
      "index": 94,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.Net.Net.PATH",
      "library": "frenetic",
      "description": "This module computes shortest paths in a network topology, providing functions to find a single shortest path, all shortest paths from a source, and all pairs of shortest paths with optional filtering. It operates on graph structures defined by vertices and edges, using weights to determine path costs. Concrete use cases include network routing optimization and traffic engineering in software-defined networks.",
      "description_length": 413,
      "index": 95,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.Netkat.Vlr.HashCmp",
      "library": "frenetic",
      "description": "This module defines a type `t` with operations for comparison, hashing, and S-expression conversion. It includes functions for equality checking, string representation, and serialization to and from S-expressions. Concrete use cases include enabling `t` values to be stored in hash tables, compared for ordering, or persisted as strings and S-expressions.",
      "description_length": 355,
      "index": 96,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x01.Error.BadAction",
      "library": "frenetic",
      "description": "This module defines error codes for invalid actions in OpenFlow 1.0, including malformed types, lengths, ports, and queue configurations. It provides serialization to and from S-expressions and converts error values to human-readable strings. Use this module to handle and report errors related to action validation in OpenFlow switch implementations.",
      "description_length": 351,
      "index": 97,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Packet.Dns.Rr",
      "library": "frenetic",
      "description": "This module defines DNS resource record operations for parsing and constructing DNS packet payloads. It provides functions to convert resource records to and from S-expressions, enabling serialization and deserialization for network transmission or debugging. The module works with DNS resource records containing fields like name, type, class, TTL, and raw data.",
      "description_length": 363,
      "index": 98,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Netkat.Fdd.FDD",
      "library": "frenetic",
      "description": "This module implements tree-structured decision diagrams that encode OpenFlow actions at leaves and header field tests in branch nodes, organized within a variable-lattice-result (VLR) framework to model hierarchical field orderings and action mappings. It provides operations for constructing, transforming, and analyzing these structures, enabling tasks such as policy compilation into flow tables, equivalence verification, and header space analysis in software-defined networking contexts. Child modules extend this functionality with imperative and functional hash tables optimized for FDD-based keys, supporting operations like merging, filtering, and in-place updates, along with serialization and symbolic construction from NetKAT policies. These capabilities allow concrete use cases such as compiling high-level policies into minimized OpenFlow rule sets, optimizing forwarding decisions, and synchronizing distributed network state.",
      "description_length": 943,
      "index": 99,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Async.NetKAT_Controller.Make",
      "library": "frenetic",
      "description": "This module implements a controller for handling OpenFlow events and managing switch policies in a software-defined network. It provides operations to start a listening server, retrieve network events, update policies locally or globally, query packet statistics, and send packets to switches. It works with OpenFlow switches, ports, and policies, using Frenetic's NetKAT policy language and compiler.",
      "description_length": 401,
      "index": 100,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.Network.Make.Path",
      "library": "frenetic",
      "description": "This module computes shortest paths in a network topology using a specified weight type. It provides functions to find the shortest path between two vertices, all shortest paths from a source, and all pairs of shortest paths matching a predicate. The module works directly with graph structures represented by `Topology.edge` and `Topology.vertex` types.",
      "description_length": 354,
      "index": 101,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.Netkat.Vlr.Make",
      "library": "frenetic",
      "description": "This module provides operations to construct and manipulate binary decision diagrams representing functions from lattice-ordered variables to semi-ring values, supporting node",
      "description_length": 175,
      "index": 102,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Network.Make.Pretty",
      "library": "frenetic",
      "description": "This module converts network topologies into human-readable string formats, including DOT and Mininet scripts. It supports custom prologue and epilogue content when generating Mininet output. Use cases include visualizing network structures via graph tools or generating executable network simulations.",
      "description_length": 302,
      "index": 103,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.OpenFlow0x01.SwitchConfig.FragFlags",
      "library": "frenetic",
      "description": "This module defines a type `t` representing fragment handling modes in switch configuration, with variants for normal processing, dropping fragments, and reassembling them. It provides functions to convert values to and from S-expressions and to obtain string representations. This is used to configure how network switches handle fragmented packets in OpenFlow 0x01.",
      "description_length": 367,
      "index": 104,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.Netkat.FabricGen.FabricGen",
      "library": "frenetic",
      "description": "This module implements a two-player adversarial strategy for generating network fabrics in a virtual compilation context. It constructs fabrics as pairs of policies representing virtual and physical network behaviors, using predicates and policies to model traffic constraints and topologies. The main function `generate_fabric` synthesizes these policies under specified virtual and physical constraints, while `default_ving_pol` provides a fallback policy for virtual ingress based on given predicates.",
      "description_length": 504,
      "index": 105,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "Frenetic.Netkat.Packet.Field",
      "library": "frenetic",
      "description": "This module defines a field as a key in a packet's field-to-value mapping, supporting comparison operations to order fields. It works with packet fields represented as a concrete type `t` and comparator witnesses for efficient ordering. Use this module to uniquely identify and compare packet fields such as source and destination IP addresses, port numbers, or protocol types.",
      "description_length": 377,
      "index": 106,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Network.Net.Pretty",
      "library": "frenetic",
      "description": "This module converts network topologies into string representations for visualization and simulation. It provides functions to generate human-readable strings, Graphviz DOT format output, and Mininet scripts from a network topology. Use cases include debugging network configurations, generating visual diagrams, and creating executable Mininet test environments.",
      "description_length": 363,
      "index": 107,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Async.Ox.DefaultHandlers",
      "library": "frenetic",
      "description": "This module provides default implementations for event handlers in an Ox application, specifically for managing switch connections, barrier replies, stats replies, and cleanup. It works with OpenFlow switch identifiers, transaction IDs, and protocol-specific message types. These handlers are useful for ignoring or stubbing out events in simple controllers where advanced handling is unnecessary.",
      "description_length": 397,
      "index": 108,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Async.Ox.OXMODULE",
      "library": "frenetic",
      "description": "This module defines the interface for handling OpenFlow controller events, including switch connections, packet arrivals, and responses to asynchronous requests. It works with OpenFlow switch identifiers, transaction IDs, and protocol-specific data structures like packet-in messages and statistics replies. Concrete use cases include implementing custom logic for managing switch state, processing incoming packets, and handling control plane exceptions in network applications.",
      "description_length": 479,
      "index": 109,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Netkat.Fdd.Action",
      "library": "frenetic",
      "description": "This module orchestrates the manipulation and optimization of NetKAT actions within FDDs, combining algebraic operations on `Action.t` values\u2014such as union, intersection, and normalization\u2014with structured key-value sequences and immutable action sets. It enables query extraction, deduplication, and policy translation while leveraging child modules for ordered key management, set operations, and serialization. Examples include compiling network policies into optimized flow tables, merging FDD paths using set operations, and extracting structured matches for header field analysis. The integration of direct action transformations with key sequencing and set-based optimizations supports both high-level policy analysis and low-level switch rule generation.",
      "description_length": 761,
      "index": 110,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x04.QueueDesc.QueueProp",
      "library": "frenetic",
      "description": "This module defines operations for handling queue property descriptions in OpenFlow 1.3.4. It provides functions to calculate size, convert to string, marshal, and parse queue property structures. These operations are used when configuring or inspecting queue behavior in software-defined networking.",
      "description_length": 300,
      "index": 111,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.Async.OpenFlow0x01_Plugin.LowLevel",
      "library": "frenetic",
      "description": "This module manages low-level communication with OpenFlow 1.0 switches. It starts a connection to a switch on a given port, sends OpenFlow messages asynchronously, and provides a stream of incoming OpenFlow events. Use it to implement custom control logic for software-defined networks by handling switch connections, packet-ins, and flow modifications directly.",
      "description_length": 362,
      "index": 112,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x01.Error.PortModFailed",
      "library": "frenetic",
      "description": "This module defines error codes for port modification failures in OpenFlow 1.0, specifically `BadPort` and `BadHwAddr`. It provides functions to convert these errors to and from S-expressions and to convert them to human-readable strings. This module is used to handle and report errors when modifying switch port configurations, such as invalid port numbers or hardware addresses.",
      "description_length": 381,
      "index": 113,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.OpenFlow0x01.Error.BadRequest",
      "library": "frenetic",
      "description": "This module defines error codes for malformed OpenFlow requests, including invalid versions, types, stats, vendors, subtypes, permissions, lengths, and buffer states. It provides serialization to and from S-expressions and converts error values to human-readable strings. Use this module to handle and report errors in OpenFlow 1.0 request parsing or validation.",
      "description_length": 362,
      "index": 114,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x01.Error.QueueOpFailed",
      "library": "frenetic",
      "description": "This module defines error codes for queue operation failures in OpenFlow 1.0, specifically covering invalid ports, queues, and permission issues. It provides serialization and deserialization functions for converting between error values and S-expressions, along with a function to convert error values to human-readable strings. This module is used to handle and report errors related to queue operations in network switch management.",
      "description_length": 435,
      "index": 115,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Frenetic.OpenFlow0x04.GroupStats.BucketStats",
      "library": "frenetic",
      "description": "This module provides functions to serialize, deserialize, and display bucket statistics from OpenFlow 1.3.4 group stats. It operates on the `bucketStats` type, representing statistics for individual buckets within a group. Use cases include parsing incoming OpenFlow messages containing bucket statistics and generating human-readable logs for network monitoring.",
      "description_length": 363,
      "index": 116,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.Network.Make.Topology",
      "library": "frenetic",
      "description": "This module provides a unit-weight topology for modeling networks with uniform edge costs, offering core operations like edge serialization, weight comparison, and arithmetic with a zero value. Its main data types include edges and integer weights, supporting functions to build, manipulate, and analyze unweighted graphs. Submodule 1 extends this functionality by enabling efficient routing and pathfinding in scenarios such as network design or grid-based navigation. Together, the module and its child modules allow tasks like constructing adjacency lists, computing shortest paths, and exporting topology data for external use.",
      "description_length": 631,
      "index": 117,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.Network.Net.Topology",
      "library": "frenetic",
      "description": "This module models graph-based network topologies with vertices representing devices and directed edges encoding port-specific connections. It supports graph construction, pathfinding (e.g., next_hop), connectivity queries, and iterative traversal/mutation over structures like EdgeSet and VertexHash for efficient collection management. The vertex module enables representation, serialization, and parsing of network nodes in formats like DOT and GML, while the edge module handles link modeling, comparison, and serialization with support for attribute-based parsing. A weight module provides integer-weighted edge operations, including addition and comparison, enabling routing and pathfinding computations over the topology.",
      "description_length": 728,
      "index": 118,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Network.Net.Path",
      "library": "frenetic",
      "description": "Computes shortest paths in network topologies using edge-weighted graphs. It operates on vertices and edges from a network topology module, returning paths as lists of edges. Functions support finding single shortest paths, all shortest paths from a source, and all pairs shortest paths filtered by a predicate.",
      "description_length": 311,
      "index": 119,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Netkat.Vlr.Result",
      "library": "frenetic",
      "description": "This module defines a semi-ring structure over a type `t`, providing operations for addition (`sum`), multiplication (`prod`), and their respective identity elements (`zero` and `one`). It includes standard functions for equality, comparison, hashing, and serialization. This structure is useful for representing and manipulating algebraic values in network policy analysis and symbolic computation.",
      "description_length": 399,
      "index": 120,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.Netkat.Packet.T",
      "library": "frenetic",
      "description": "This module represents network packets as maps from fields to 64-bit integer values. It provides operations for comparing, hashing, and serializing packets, along with a comparator for use in ordered collections. Use this module when processing or analyzing network traffic where packets need to be inspected, modified, or matched against rules.",
      "description_length": 345,
      "index": 121,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Network.Make.PATH",
      "library": "frenetic",
      "description": "This module computes shortest paths in a network topology using edge-weighted graphs. It provides functions to find a single shortest path, all shortest paths from a source, and all pairs of shortest paths that satisfy a given predicate. These operations are used to determine optimal routing paths between network nodes based on edge weights.",
      "description_length": 343,
      "index": 122,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.Netkat.Virtual_Compiler.Make",
      "library": "frenetic",
      "description": "This module generates and compiles network fabrics for virtual NetKAT policies using a customizable fabric generation strategy. It operates on network predicates and policies to model virtual and physical topologies, ingress and egress conditions, and forwarding rules. Concrete use cases include synthesizing network virtualization overlays and compiling high-level policies into efficient switch-level configurations.",
      "description_length": 419,
      "index": 123,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x04.Hello.Element",
      "library": "frenetic",
      "description": "This module structures and manipulates Hello elements in OpenFlow 1.3.4, focusing on version negotiation during the handshake between switch and controller. It defines the `element` type and supports marshaling, parsing, and version handling, including the Supported Version Bitmap structure through its child module. The child module processes `supportedList` values\u2014lists of integers representing protocol versions\u2014enabling binary conversion, size calculation, and string representation. Together, they allow constructing, serializing, and decoding Hello messages with precise version support information.",
      "description_length": 607,
      "index": 124,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Topology.Net.Parse",
      "library": "frenetic",
      "description": "Converts network topologies from DOT or GML file formats into internal topology representations. Works with graph data encoded in string-based file paths. Used to load predefined network structures from disk for simulation or analysis tasks.",
      "description_length": 241,
      "index": 125,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x01.FlowMod.Command",
      "library": "frenetic",
      "description": "This module converts flow modification commands to and from string and 16-bit integer representations. It operates on the `flowModCommand` type, enabling serialization and deserialization for network transmission or logging. Use cases include encoding commands like add, delete, or modify into OpenFlow messages and decoding them from received packets.",
      "description_length": 352,
      "index": 126,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Topology.Net.Pretty",
      "library": "frenetic",
      "description": "This module provides functions to generate string representations of network topologies. It includes operations to convert a topology to a human-readable string, to the DOT graph format, and to a Mininet script. These functions are used to visualize or export network structures for analysis and simulation.",
      "description_length": 307,
      "index": 127,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Packet.Tcp.Flags",
      "library": "frenetic",
      "description": "This module defines a record type representing the 9 individual boolean flags in a TCP header, such as `syn`, `ack`, and `fin`. It provides functions to convert between this type and S-expressions for serialization and parsing. These flags are used to control TCP connection states and data transmission behavior, such as initiating connections (`syn`), acknowledging received data (`ack`), or closing a connection (`fin`).",
      "description_length": 423,
      "index": 128,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.OpenFlow0x04.MeterConfig",
      "library": "frenetic",
      "description": "This module defines operations for handling OpenFlow 1.3.4 meter configurations, including parsing from and marshaling to Cstruct buffers. It works directly with the `meterConfig` type, representing OpenFlow meter configuration data structures. Concrete use cases include serializing meter configurations for network transmission and deserializing received packets into usable meter state.",
      "description_length": 389,
      "index": 129,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Packet.Igmp1and2",
      "library": "frenetic",
      "description": "This module defines the structure and serialization of IGMPv1 and IGMPv2 messages, specifically handling fields like maximum response time, checksum, and group address. It operates on the `t` record type, which encapsulates IGMP message data. Concrete use cases include parsing and constructing IGMP packets for network monitoring or multicast management tasks.",
      "description_length": 361,
      "index": 130,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x01.PortStatus",
      "library": "frenetic",
      "description": "This module represents port status events in an OpenFlow 1.0 switch, including the reason for the change and the port description. It provides functions to serialize, deserialize, parse, and marshal port status data, along with converting it to a string. The child module defines an enumeration of change reasons such as `Add`, `Delete`, and `Modify`, with conversions to and from S-expressions and string representations. Use this module to process port status updates from switches, for example, detecting when a port is added or its configuration changes.",
      "description_length": 558,
      "index": 131,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.Netkat.Virtual_Compiler",
      "library": "frenetic",
      "description": "This module synthesizes network fabrics for virtual NetKAT policies using customizable strategies, translating high-level policies into concrete network configurations. It operates on network predicates, policies, and topologies to model ingress, egress, and forwarding behavior, supporting both virtual and physical network representations. It enables tasks like generating network virtualization overlays and compiling policies into switch-level configurations. For example, it can transform a policy specifying allowed traffic flows into an optimized OpenFlow configuration for a physical switch fabric.",
      "description_length": 606,
      "index": 132,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Network.Make",
      "library": "frenetic",
      "description": "This module builds and manipulates network topologies using custom vertex and edge types, supporting operations like spanning tree construction and path-tracking traversal. It enables network routing analysis, pathfinding, and human-readable path representation, with core data types including vertices, edges, and graph structures. Child modules extend functionality by loading topologies from DOT/GML files, performing BFS/DFS traversals, computing shortest paths with integer or custom weights, and exporting topologies to formats like DOT and Mininet. Specific use cases include generating adjacency lists, analyzing network faults, and simulating network paths for routing optimization.",
      "description_length": 691,
      "index": 133,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x04.FlowStats",
      "library": "frenetic",
      "description": "This module handles flow statistics in OpenFlow 1.3.4, providing operations to parse, marshal, and convert flow statistic entries to strings. It works with the `flowStats` type, which represents individual flow statistics entries as defined in the specification. Use this module to extract, serialize, and inspect flow statistics from OpenFlow messages.",
      "description_length": 353,
      "index": 134,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x04.OfpMatch",
      "library": "frenetic",
      "description": "This module defines operations for handling OpenFlow 1.3.4 match structures, which represent packet header fields used for flow classification. It provides functions to calculate the size of a match structure, serialize it to a buffer, parse it from a buffer, and convert it to a human-readable string. These operations are used when constructing or interpreting flow entries in OpenFlow switches.",
      "description_length": 397,
      "index": 135,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x04.GroupType",
      "library": "frenetic",
      "description": "This module defines the group types used in OpenFlow 1.3.4, corresponding to the `ofp_group_type` enumeration. It provides operations to convert group type values to human-readable strings, marshal them to integers, and parse integers back into group type values. These functions are used when handling group table operations in OpenFlow switches, such as specifying group behavior in flow entries.",
      "description_length": 398,
      "index": 136,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.OpenFlow0x04.FlowModCommand",
      "library": "frenetic",
      "description": "This module defines operations for working with OpenFlow 1.3.4 flow modification commands. It provides functions to calculate the size of a command, serialize it to an integer representation, parse it from an integer, and convert it to a human-readable string. These operations are used when constructing or interpreting OpenFlow messages that modify switch flow tables, such as adding, updating, or removing flow entries.",
      "description_length": 422,
      "index": 137,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.Packet.Dns",
      "library": "frenetic",
      "description": "This module provides DNS packet structures and serialization for parsing and constructing DNS messages, supporting direct manipulation of query and response fields. It defines core types like `Qd` for DNS questions and `Rr` for resource records, along with operations to serialize these into binary format for use in UDP or TCP payloads. The `Qd` module handles query sections with domain names, record types, and classes, while the `Rr` module manages resource records with TTLs and raw data. Examples include building custom DNS servers, analyzing packets, or converting DNS data to and from S-expressions for debugging or transmission.",
      "description_length": 638,
      "index": 138,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Async.Http_Controller",
      "library": "frenetic",
      "description": "This module implements an asynchronous HTTP controller for handling network requests. It provides a `main` function that starts a server on specified port and interface, managing incoming HTTP connections with non-blocking I/O. Use it to build lightweight, high-performance web services that require direct control over request handling and response generation.",
      "description_length": 361,
      "index": 139,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.Netkat.Portless_Generated_Parser",
      "library": "frenetic",
      "description": "This module provides functions for parsing network policies and predicates from input streams using a lexer. It processes `token` values generated by the `Frenetic_netkat.Lexer` module, producing abstract syntax trees representing network policies and boolean predicates. Concrete use cases include parsing policy expressions and packet filter conditions from configuration files or interactive input.",
      "description_length": 401,
      "index": 140,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Netkat.Json",
      "library": "frenetic",
      "description": "This module serializes and deserializes NetKAT policies and OpenFlow messages to and from JSON. It supports conversion of types such as `Syntax.policy`, `OpenFlow.event`, `OpenFlow.portStats`, and `OpenFlow.pseudoport` between their native OCaml representations and Yojson. Concrete use cases include transmitting NetKAT policies over networks, persisting switch state, and handling controller-to-switch communication in network applications.",
      "description_length": 442,
      "index": 141,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.OpenFlow0x01.PseudoPort",
      "library": "frenetic",
      "description": "This module defines operations for working with pseudo ports in OpenFlow 1.0. It provides functions to convert pseudo ports to strings, marshal them to integers, and construct them from integers. These operations are used to represent and manipulate virtual port identifiers in network switch configurations.",
      "description_length": 308,
      "index": 142,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x04.FlowRemoved",
      "library": "frenetic",
      "description": "This module handles the serialization, deserialization, and string representation of OpenFlow 1.3.4 flow removed messages. It operates on the `flowRemoved` type, which captures metadata about flows that have been removed from a switch. Use this module to convert flow removed data to and from binary format for network transmission or logging.",
      "description_length": 343,
      "index": 143,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x04.Message",
      "library": "frenetic",
      "description": "This module defines the message types used to communicate with OpenFlow 1.3 switches, including control messages like `FeaturesRequest`, `FlowModMsg`, and `PacketInMsg`. It provides functions to serialize and deserialize messages to and from byte buffers, compute their size, and convert them to human-readable strings. Use cases include constructing and parsing OpenFlow control packets for switch configuration, flow management, and packet processing.",
      "description_length": 453,
      "index": 144,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.Network.MAKE-Pretty",
      "library": "frenetic",
      "description": "This module converts network topologies into string representations, DOT format for visualization, and Mininet scripts for network simulation. It operates on `Topology.t` structures, which model network graphs. Use cases include generating input for visualization tools or automating Mininet network setups from abstract topology descriptions.",
      "description_length": 343,
      "index": 145,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.OpenFlow0x04.PacketIn",
      "library": "frenetic",
      "description": "This module defines the structure and operations for handling OpenFlow 1.3.4 PacketIn messages, which represent packets received by a switch and sent to the controller. It provides functions to parse and serialize PacketIn values to and from Cstruct buffers, along with utilities to compute their size and generate string representations. It is used to process and inspect incoming network packets in OpenFlow-compliant software-defined networking applications.",
      "description_length": 461,
      "index": 146,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x04.SwitchDescriptionReply",
      "library": "frenetic",
      "description": "This module handles the serialization, deserialization, and string representation of OpenFlow switch description replies. It operates on the `switchDesc` type, which captures metadata about an OpenFlow switch, such as its hardware and software versions. Use this module when processing or constructing switch description replies in an OpenFlow 1.3.4 controller or switch implementation.",
      "description_length": 386,
      "index": 147,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x04.TableStats",
      "library": "frenetic",
      "description": "This module handles parsing and serializing table statistics data structures as defined in the OpenFlow 1.3.4 specification. It operates on the `t` type representing table statistics, providing functions to calculate size, convert to string, marshal to a buffer, and parse from a buffer. Use this module when working with OpenFlow table statistics messages for network monitoring and control.",
      "description_length": 392,
      "index": 148,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.Network.NETWORK-UnitPath",
      "library": "frenetic",
      "description": "This module computes shortest paths and related information over a network topology. It works with vertices and edges from a `Topology` module, using integer weights to determine path costs. Concrete use cases include finding the shortest path between two vertices, enumerating all shortest paths from a source, or generating all-pairs shortest paths filtered by a vertex pair condition.",
      "description_length": 387,
      "index": 149,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.OpenFlow0x01.PortDescription",
      "library": "frenetic",
      "description": "This module processes OpenFlow 1.0 port descriptions, enabling serialization, parsing, and string conversion for `portDescription` records that capture port identifiers, state, configuration, and capabilities. It integrates submodules that handle specific type conversions: one for `portState`, supporting STP state encoding and decoding; another for `portConfig`, translating configuration flags to integers; and a third for `portFeatures`, mapping link capabilities to and from integer representations. You can use it to prepare port data for network transmission, extract structured information from raw OpenFlow messages, or inspect and modify port attributes like speed, duplex mode, or STP status. For example, you might serialize a `portDescription` for logging, parse an incoming integer port state into its structured form, or convert a `portFeatures` value to a human-readable string.",
      "description_length": 894,
      "index": 150,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Netkat.Bisim",
      "library": "frenetic",
      "description": "Implements bisimilarity checking between two automata using the Hopcroft-Karp algorithm. Operates directly on automaton structures defined in the Global_compiler module. Useful for verifying equivalence of network programs represented as finite automata.",
      "description_length": 254,
      "index": 151,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Async.OpenFlow0x04_Plugin",
      "library": "frenetic",
      "description": "This module implements OpenFlow 1.3 communication and control logic for SDN switches. It provides functions to send and process OpenFlow messages, manage flow tables and group tables, and run fault-tolerant control loops. Key operations include flow installation, group table synchronization, and asynchronous message handling, specifically for network control applications like software-defined networking controllers.",
      "description_length": 419,
      "index": 152,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.OpenFlow0x01.SwitchConfig",
      "library": "frenetic",
      "description": "This module represents configuration settings for an OpenFlow 1.0 switch, focusing on fragment handling modes and the maximum byte limit for packet-in messages. It includes serialization and deserialization functions for converting configuration values to and from S-expressions, along with string representations for logging or debugging. The main data type encodes fragment handling behavior, supporting variants for normal processing, dropping fragments, and reassembling them. Example uses include configuring switch behavior to control fragmented packet handling and persisting or transmitting switch settings across systems.",
      "description_length": 630,
      "index": 153,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.Netkat.Semantics",
      "library": "frenetic",
      "description": "This module evaluates network policies against packets, transforming packet sets and tracking modifications through policy pipelines. It operates on packets with switch identifiers, headers, and payloads, enabling precise simulation of forwarding, policy analysis, and dependency extraction. The structured header map supports serialization, comparison, and type-safe access to fields like Ethernet and IP addresses, facilitating operations such as address rewriting and port-based filtering. Submodules enable fine-grained manipulation and querying of packet headers, enhancing SDN pipeline capabilities through transformation and bulk processing.",
      "description_length": 648,
      "index": 154,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.Network.WEIGHT",
      "library": "frenetic",
      "description": "This module defines a weighted graph edge structure with a numeric weight type that supports comparison and addition. It provides functions to access edge weights, compare and combine weights, and serialize or deserialize both weights and edges. Concrete use cases include modeling network graphs with weighted edges, such as representing link costs in routing algorithms or traffic flow optimization.",
      "description_length": 401,
      "index": 155,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.OpenFlow0x01.Action",
      "library": "frenetic",
      "description": "This module manipulates sequences of OpenFlow 1.0 actions, providing utilities to reorder, serialize, and format them. It handles operations like moving controller-bound actions to the end of a sequence to work around switch limitations, converting actions to strings, and marshaling actions to and from binary representations. Use cases include preparing action lists for packet processing in software-defined networking applications and debugging by inspecting action sequences.",
      "description_length": 480,
      "index": 156,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.Network.NETWORK-module-type-PATH",
      "library": "frenetic",
      "description": "This module computes shortest paths in a network topology using edge-weighted graphs. It provides functions to find the shortest path between two vertices, all shortest paths from a source vertex, and all pairs of shortest paths that satisfy a given predicate. The module works directly with network topologies represented as edges and vertices, using weights to determine path costs.",
      "description_length": 384,
      "index": 157,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Async.Ox",
      "library": "frenetic",
      "description": "This module initializes and runs network event loops to manage SDN applications, coordinating switch connections and packet event handling using OpenFlow data types and event handlers. It supports sending OpenFlow messages like flow-mod and packet-out, listening for incoming switch connections, and defining custom or default event callbacks to manage network behavior in real time. For example, it can launch a controller that listens on port 6633, sends flow rules to switches, and handles packet-in events with custom logic. Timeout-based operations and default handler stubs allow for flexible control over event-driven network interactions.",
      "description_length": 646,
      "index": 158,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Network.NETWORK-Topology-Vertex",
      "library": "frenetic",
      "description": "This module defines a vertex type used in network topology representations, supporting serialization to and from S-expressions, DOT, and GML formats. It includes operations for comparing vertices, converting them to strings, and parsing them from DOT and GML syntax trees. Concrete use cases include building and manipulating network graphs for simulation, visualization, and configuration in tools like Mininet and Graphviz.",
      "description_length": 425,
      "index": 159,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x04.MeterBand",
      "library": "frenetic",
      "description": "This module defines operations for working with OpenFlow 1.3.4 meter band structures. It provides functions to calculate the size of a meter band, convert it to a string, and serialize or deserialize it using Cstruct. These operations support configuring and interpreting rate-limiting behavior in OpenFlow switches.",
      "description_length": 316,
      "index": 160,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.Network.Link",
      "library": "frenetic",
      "description": "This module represents network links with attributes like cost, capacity, and weight. It provides functions to create links, modify their weight, and serialize or deserialize them using formats like S-expressions, DOT, and GML. Use cases include modeling network topologies and managing link properties in routing or network analysis applications.",
      "description_length": 347,
      "index": 161,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.Netkat.Packet",
      "library": "frenetic",
      "description": "This module represents network packets as maps from fields to 64-bit integer values, enabling packet transformation and analysis through operations like `apply_fdd`, `apply_action`, and `eval_e_fdd`. Fields act as ordered keys for accessing and comparing packet data, while packets support comparison, hashing, and serialization for use in rule matching and traffic processing. It allows evaluating forwarding decision diagrams to route or modify packets based on values like Ethernet addresses or IP headers. Use this module to implement software-defined networking logic that inspects, transforms, or routes packets using structured field-based operations.",
      "description_length": 658,
      "index": 162,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Async.Compile_Server",
      "library": "frenetic",
      "description": "This module implements a server that compiles and executes Frenetic programs asynchronously. It listens for incoming program submissions, processes them concurrently, and returns results without blocking the main execution thread. The `main` function starts the server with a specified concurrency limit, handling each request by spawning a separate asynchronous task.",
      "description_length": 368,
      "index": 163,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Network.NETWORK-Parse",
      "library": "frenetic",
      "description": "Converts network topologies from file formats like DOT and GML into structured data. Processes input files to build graph representations suitable for network analysis. Useful for loading predefined network layouts into applications that simulate or manage network behavior.",
      "description_length": 274,
      "index": 164,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Netkat.Lexer",
      "library": "frenetic",
      "description": "This module defines a lexer for parsing network policy specifications, recognizing tokens like keywords, identifiers, and literals. It provides functions to tokenize input from strings or files, supporting concrete syntax elements such as `IP4SRC`, `VLAN`, and `MAC`. Use it to convert raw policy text into structured tokens for further processing or analysis.",
      "description_length": 360,
      "index": 165,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x04.Capabilities",
      "library": "frenetic",
      "description": "This module defines bitflag constants representing switch capabilities in the OpenFlow 1.3.4 protocol, such as flow statistics, port statistics, and group support. It provides functions to convert capability values to human-readable strings, 32-bit integers, and parse them back from integers. These operations are used when negotiating switch features during handshake or interpreting device capabilities in network control logic.",
      "description_length": 431,
      "index": 166,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.OpenFlow0x04.GroupMod",
      "library": "frenetic",
      "description": "This module defines operations for encoding, decoding, and manipulating OpenFlow 1.3.4 Group Modify messages. It works with the `groupMod` type, which represents group table modification commands, and uses `Cstruct.t` for low-level byte buffer handling. Concrete use cases include constructing and parsing GroupMod messages to configure switch group tables, such as adding, modifying, or deleting group entries with specific actions and buckets.",
      "description_length": 445,
      "index": 167,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.OpenFlow0x04.PacketOut",
      "library": "frenetic",
      "description": "This module defines operations for constructing and serializing OpenFlow 1.3.4 packet-out messages. It supports parsing from and marshaling to Cstruct buffers, along with computing message size and generating string representations. It works directly with OpenFlow packet-out structures, enabling precise control over packet egress in software-defined networking applications.",
      "description_length": 376,
      "index": 168,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Network.MAKE-Topology",
      "library": "frenetic",
      "description": "This module enables the construction and manipulation of graph-based network topologies with typed vertices, edges, and ports, supporting metadata association, serialization, and dynamic updates through operations like vertex/edge addition or removal. It provides traversal, querying, and analysis tools to inspect connectivity, edge directionality, and adjacency relationships, working directly with graph components such as switches (vertices), links (edges), and switch ports. Designed for modeling network infrastructures, it facilitates tasks like topology analysis, dynamic reconfiguration, and protocol testing in software-defined networking scenarios.",
      "description_length": 659,
      "index": 169,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x04.SwitchConfig",
      "library": "frenetic",
      "description": "This module handles switch configuration data structures defined in the OpenFlow 1.3.4 specification. It provides operations to serialize, deserialize, and convert switch configuration values to strings, with a focus on direct manipulation of `switchConfig` type instances. Use cases include parsing incoming OpenFlow messages and constructing configuration payloads for network switch management.",
      "description_length": 397,
      "index": 170,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x01.StatsReply",
      "library": "frenetic",
      "description": "This module handles parsing and serializing OpenFlow 1.0 statistics replies, converting between wire format and OCaml values. It operates on `Cstruct.t` buffers for network transmission and supports conversion to and from S-expressions and string representations. Use it to process OpenFlow switch statistics in network control applications.",
      "description_length": 341,
      "index": 171,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Netkat.Domain",
      "library": "frenetic",
      "description": "This module tracks the set of 64-bit integer values that each packet field can take, derived from tests or modifications in network programs, and supports constructing domains from FDDs or automatons, merging domains, and generating representative packets. It provides a map from fields to value sets, along with operations for domain combination and packet synthesis, enabling analysis of field value constraints. The child module enhances field value reasoning by defining comparison operations and ordering constraints over `Frenetic.Netkat.Domain.Field.t`, ensuring consistency during FDD and automaton manipulations. Together, they support tasks like verifying packet behavior under different field constraints and generating test packets that conform to specified domain rules.",
      "description_length": 783,
      "index": 172,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x04.PortFeatures",
      "library": "frenetic",
      "description": "This module defines bitflag representations for OpenFlow 1.3.4 port features, including operations to marshal to and parse from 32-bit integers, and to convert to human-readable strings. It works directly with the `portFeatures` type, encoding and decoding combinations of link modes, auto-negotiation, and port capabilities. Concrete use cases include interpreting switch port capabilities during handshake and constructing port configuration messages.",
      "description_length": 453,
      "index": 173,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Network.NETWORK",
      "library": "frenetic",
      "description": "This module implements network topology analysis and path computation for software-defined networking. It provides a spanning tree construction function from a given root vertex, using a custom combination function for merging values during traversal. The module works with graph structures represented through the Topology and Path submodules, enabling concrete use cases like network routing optimization and packet forwarding path determination.",
      "description_length": 448,
      "index": 174,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.Hashcons.Make",
      "library": "frenetic",
      "description": "This module implements hash-consing for a given value type, ensuring that structurally identical values share the same memory representation. It provides operations to retrieve a unique integer identifier for a value (`get`), recover the original value from its identifier (`unget`), and clear internal state for a set of identifiers (`clear`). It is useful in scenarios requiring efficient equality checks and memory deduplication, such as symbolic computation or compiler intermediate representations.",
      "description_length": 503,
      "index": 175,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Netkat.LexBuffer",
      "library": "frenetic",
      "description": "This module provides a custom lexbuffer that tracks source locations during lexical analysis, wrapping Sedlexing's buffer. It supports operations like `next` to retrieve the next Unicode character, `mark` and `backtrack` for position management, and `of_ascii_string` to initialize buffers from strings. It works with ASCII strings and files, maintaining character positions for precise error reporting and source mapping in parsers.",
      "description_length": 433,
      "index": 176,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x04.Instructions",
      "library": "frenetic",
      "description": "This module handles OpenFlow 1.3 instruction lists, providing operations to serialize, deserialize, and convert instructions. It works with `instruction list` types and Cstruct buffers for network transmission. Concrete use cases include parsing raw packet data into instruction lists, converting group objects to instructions, and generating string representations for debugging.",
      "description_length": 380,
      "index": 177,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.Net.Node",
      "library": "frenetic",
      "description": "This module defines a concrete type `t` representing network nodes and provides bidirectional conversion functions between this type and S-expressions. It supports serialization and deserialization of node data, enabling persistent storage or transmission over a network. Use cases include saving node configurations to disk or reconstructing node objects from received S-expressions in distributed systems.",
      "description_length": 407,
      "index": 178,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.OpenFlow0x01.FlowMod",
      "library": "frenetic",
      "description": "This module handles OpenFlow 1.0 flow modification messages, supporting serialization and deserialization of flow entries to Cstruct buffers and S-expressions. It includes operations to convert flow modifications to strings, compute their size, and marshal or parse them for network use. The `flowModCommand` type represents commands like add, delete, or modify, which can be encoded to or decoded from 16-bit integers and strings. Examples include constructing flow table updates in a controller or interpreting incoming flow modification requests from switches.",
      "description_length": 563,
      "index": 179,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x04.SwitchFeatures",
      "library": "frenetic",
      "description": "This module handles parsing and serializing the OpenFlow 1.3.4 switch features structure. It provides the size of the structure, converts it to a string for debugging, and marshals or parses it from a Cstruct buffer. Use this module when interacting with OpenFlow switch handshakes to read or construct switch capabilities.",
      "description_length": 323,
      "index": 180,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x04.TableMod",
      "library": "frenetic",
      "description": "This module defines operations for modifying OpenFlow table configurations, specifically supporting serialization, deserialization, and string representation of table modification messages. It works with the `t` type representing OpenFlow 1.3.4 table modification structures, as defined in section 7.3.3 of the specification. Concrete use cases include constructing and parsing `OFPT_TABLE_MOD` messages for controlling table behavior in OpenFlow switches.",
      "description_length": 456,
      "index": 181,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Topology.Mininet",
      "library": "frenetic",
      "description": "This module defines functions to construct network topologies from symbolic representations, converting them into concrete network structures used for simulation or testing. It supports topology types like trees, linear chains, single switches, and minimal configurations. Each topology is parameterized by integers that define its size or complexity, enabling precise control over network shape and scale.",
      "description_length": 406,
      "index": 182,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Network.NETWORK-Topology",
      "library": "frenetic",
      "description": "This module supports constructing, modifying, and analyzing graph structures representing network topologies through operations like adding or removing ports and edges, querying vertex/edge counts, mapping elements to labels, and graph traversal. It works with vertices, edges, ports, and their associated sets (e.g., `VertexSet`, `EdgeSet`) and hashes, enabling efficient manipulation and serialization via S-expressions. Typical use cases include network modeling, topology analysis, and persistence/transmission of network state in systems requiring dynamic graph management.",
      "description_length": 578,
      "index": 183,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x04.MeterMod",
      "library": "frenetic",
      "description": "This module defines operations for working with OpenFlow 1.3.4 MeterMod messages, including parsing, marshaling, and string representation. It handles the `meterMod` type, which represents meter configurations in the OpenFlow protocol. Concrete use cases include constructing and deconstructing meter modification messages for network traffic control in software-defined networking.",
      "description_length": 382,
      "index": 184,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Network.MAKE-Path",
      "library": "frenetic",
      "description": "This module computes shortest paths in a network topology using a specified weight type. It provides functions to find the shortest path between two vertices, all shortest paths from a source vertex, and all pairs of shortest paths in the topology. These operations are useful for network routing and traffic optimization scenarios.",
      "description_length": 332,
      "index": 185,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.OpenFlow0x01.PacketOut",
      "library": "frenetic",
      "description": "Converts a PacketOut message into its string representation. Works with the `packetOut` type defined in the OpenFlow 1.0 protocol. Useful for logging or debugging network control messages in software-defined networking applications.",
      "description_length": 232,
      "index": 186,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.OpenFlow0x04.GroupStats",
      "library": "frenetic",
      "description": "This module processes OpenFlow 1.3.4 group statistics, handling encoding, decoding, and formatting of both top-level group statistics and nested bucket statistics. It defines the `groupStats` type for representing group-level data and works with `Cstruct.t` buffers for efficient wire-level operations. The child module extends this functionality to individual bucket statistics via the `bucketStats` type, enabling detailed inspection of group bucket behavior. Together, they support tasks like parsing switch-generated statistics, logging structured data, and analyzing traffic distribution across group buckets.",
      "description_length": 614,
      "index": 187,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x04.PseudoPort",
      "library": "frenetic",
      "description": "This module defines operations for working with pseudo ports in OpenFlow 1.3. It provides functions to create pseudo port values from raw integers, convert them to human-readable strings, compute their size, and serialize them to 32-bit integers. These operations are used when handling OpenFlow messages that reference special switch ports like `OFPP_CONTROLLER` or `OFPP_FLOOD`.",
      "description_length": 380,
      "index": 188,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x04.QueueDesc",
      "library": "frenetic",
      "description": "This module handles OpenFlow queue descriptions, providing functions to parse and marshal queue configurations to and from binary formats. It centers around the `queueDesc` type, enabling serialization for network transmission and deserialization for processing. Submodule operations support property manipulation, allowing precise control and inspection of queue behavior in SDN environments. Example uses include encoding queue settings before sending them to a switch or decoding received queue data for local processing.",
      "description_length": 524,
      "index": 189,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.OpenFlow0x04.TableFeatureProp",
      "library": "frenetic",
      "description": "This module handles the serialization, parsing, and string representation of OpenFlow 1.3.4 Table Feature Property structures. It operates directly on `Cstruct.t` and `Frenetic.OpenFlow0x04.tableFeatureProp` types. Use this module when working with OpenFlow table configuration messages to read, write, or inspect table feature properties on the wire or in logs.",
      "description_length": 362,
      "index": 190,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x04.FlowRequest",
      "library": "frenetic",
      "description": "This module defines the structure and operations for handling OpenFlow 1.3.4 flow statistics requests. It provides functions to serialize (`marshal`), deserialize (`parse`), compute the size (`sizeof`), and pretty-print (`to_string`) flow request data. These operations directly work with the `flowRequest` type and `Cstruct.t` buffers, enabling efficient network transmission and debugging of individual or aggregate flow statistics requests.",
      "description_length": 443,
      "index": 191,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.Network.MAKE",
      "library": "frenetic",
      "description": "This module implements network topology manipulation and traversal algorithms. It provides functions for constructing spanning trees, parsing and pretty-printing network paths, and traversing graph structures using customizable strategies. It works with user-defined vertex and edge types to model network devices and connections, enabling concrete use cases like SDN controller path computation and network reachability analysis.",
      "description_length": 430,
      "index": 192,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x01.Message",
      "library": "frenetic",
      "description": "This module defines a comprehensive set of message types used in OpenFlow 1.0 for communication between switches and controllers, including handshake, configuration, flow management, packet handling, and statistics operations. It supports serialization, deserialization, parsing, and size calculation for these messages, enabling efficient network transmission and processing. Concrete use cases include handling switch feature negotiation, flow table modifications, packet-in events, and barrier synchronization in SDN environments.",
      "description_length": 533,
      "index": 193,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.OpenFlow0x01.Vendor",
      "library": "frenetic",
      "description": "This module handles OpenFlow 1.0 VENDOR messages by parsing and marshaling raw binary data into structured values. It operates on a tuple type consisting of a 32-bit integer (vendor ID) and a `Cstruct.t` (vendor-specific payload). Concrete use cases include decoding vendor extensions in OpenFlow control messages and serializing custom vendor data for transmission.",
      "description_length": 366,
      "index": 194,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x04.Hello",
      "library": "frenetic",
      "description": "This module handles OpenFlow Hello messages, defining the `t` type and operations for serialization, deserialization, and string representation. It works with `Cstruct.t` for low-level buffer manipulation, enabling parsing of incoming messages and marshaling of responses. The `element` type and its submodules manage version negotiation, supporting operations on `supportedList` values for encoding and decoding protocol version bitmaps. Specific uses include constructing Hello messages with version bitmaps and extracting version information from received messages during switch-controller handshakes.",
      "description_length": 604,
      "index": 195,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Netkat.Fdd",
      "library": "frenetic",
      "description": "This module provides a structured representation of network policies using Forwarding Decision Diagrams (FDDs), where header fields, patterns, and actions are encoded into a hierarchical decision structure. It supports precise header matching through field-value patterns, manipulates packet transformations using lattice-based values, and compiles policies into optimized OpenFlow rules by organizing field tests in a variable-lattice-result tree. Key operations include dynamic field ordering, pattern-to-predicate conversion, action set normalization, and FDD-to-flow-table translation, enabling concrete tasks such as policy compilation, equivalence checking, and distributed state synchronization in software-defined networks.",
      "description_length": 731,
      "index": 196,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x04.Instruction",
      "library": "frenetic",
      "description": "This module defines operations for handling OpenFlow 1.3.4 flow instructions, including parsing, marshaling, and string representation. It works directly with the `instruction` type and Cstruct buffers for binary data manipulation. Use this module when implementing or manipulating flow entries that require instruction encoding or decoding, such as modifying packet processing behavior in an OpenFlow switch.",
      "description_length": 409,
      "index": 197,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Async.Common",
      "library": "frenetic",
      "description": "This module provides functions for profiling asynchronous operations, logging messages with severity levels, extracting request paths from HTTP requests, and handling parsing errors in HTTP handlers. It works with Cohttp asynchronous request and body types, Frenetic_netkat policy and compiler types, and deferred values. Concrete use cases include measuring execution time of functions, parsing JSON request bodies into policies or compiler options, and safely handling malformed input in HTTP servers.",
      "description_length": 503,
      "index": 198,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Async.NetKAT_Controller",
      "library": "frenetic",
      "description": "This module implements asynchronous network control logic using NetKAT semantics, enabling real-time packet-processing policies across switches through event streams, flow tables, and policy compilation. It supports dynamic policy updates, traffic monitoring, and packet injection, with core types like switch IDs, port IDs, and policies expressed in NetKAT or FDD. Submodules handle OpenFlow switch interactions, including controller setup, event handling, flow table updates, and statistics collection. Use cases include load balancing, traffic analysis, and adaptive network reconfiguration in response to network events or performance metrics.",
      "description_length": 647,
      "index": 199,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x04.Bucket",
      "library": "frenetic",
      "description": "This module defines operations for working with OpenFlow 1.3.4 bucket structures used in group tables. It provides functions to calculate the size of a bucket, convert it to a string representation, and serialize/deserialize buckets to and from binary data. These operations support handling group-based flow actions in software-defined networking.",
      "description_length": 348,
      "index": 200,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Network.Node",
      "library": "frenetic",
      "description": "This module defines a type `t` representing network nodes with attributes such as name, ID, device type (switch, host, middlebox), MAC address, and IP address. It provides functions to serialize and deserialize nodes and device types, compare nodes, and convert nodes to string formats like DOT and Mininet. It also includes utilities to parse nodes from DOT and GML formats, and to construct and access node fields.",
      "description_length": 416,
      "index": 201,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Network.NETWORK-Topology-Edge",
      "library": "frenetic",
      "description": "This module defines and manipulates edge representations in a network topology. It provides functions for serializing edges to and from S-expressions, comparing edges, converting edges to string and DOT formats, and parsing edges from DOT and GML attribute lists. It is used to represent and process network graph edges in formats suitable for visualization and configuration.",
      "description_length": 376,
      "index": 202,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Network.NetPath",
      "library": "frenetic",
      "description": "This module computes shortest paths in network topologies using edge-weighted graphs. It provides functions to find single or multiple shortest paths between vertices, returning paths as lists of edges. Concrete use cases include routing optimization and network analysis tasks where minimal cost paths are critical.",
      "description_length": 316,
      "index": 203,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x04.AsyncConfig",
      "library": "frenetic",
      "description": "This module defines the structure and operations for handling asynchronous configuration messages in the OpenFlow 1.3.4 protocol. It supports parsing and serializing `asyncConfig` values to and from binary data using `Cstruct.t`, along with computing their size and generating human-readable string representations. It is used to configure which asynchronous events a switch should report to the controller.",
      "description_length": 407,
      "index": 204,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.Network.MAKE-Traverse",
      "library": "frenetic",
      "description": "Implements breadth-first and depth-first traversal algorithms over network topologies. Operates on graph structures defined by the Topology module, visiting each vertex in a specified order. Useful for network discovery, pathfinding, and topology analysis tasks.",
      "description_length": 262,
      "index": 205,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.OpenFlow0x04.PortConfig",
      "library": "frenetic",
      "description": "This module defines bit flags representing port configuration options in OpenFlow 1.3.4, such as port down, no STP, and no receive. It provides functions to convert these flags to and from 32-bit integers, enabling direct interaction with OpenFlow messages. Use this module when setting or interpreting port configuration fields in OpenFlow switch communication.",
      "description_length": 362,
      "index": 206,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.Network.Net",
      "library": "frenetic",
      "description": "This module analyzes network topologies and computes paths through customizable traversal strategies, building spanning trees and working with vertices and edges to support routing and reachability analysis. It includes shortest path computation via edge-weighted graphs and edge lists, file format conversion for topology import/export, and traversal algorithms like BFS and DFS for network exploration. Submodules enable loading topologies from DOT/GML files, generating visualizations or Mininet scripts, and modeling network devices with directed edges and port-specific connections. Specific use cases include finding optimal data transmission routes, analyzing network connectivity, and simulating network behavior with customizable pathfinding and mutation operations.",
      "description_length": 775,
      "index": 207,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.Netkat.Generated_Parser",
      "library": "frenetic",
      "description": "This module provides functions to parse network policies and predicates from input streams using a generated lexer. It processes `token` values from a `lexbuf` buffer, producing abstract syntax trees for policies and predicates. Concrete use cases include parsing policy expressions or logical conditions from strings or files in network configuration tools.",
      "description_length": 358,
      "index": 208,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Network.NETWORK-Traverse",
      "library": "frenetic",
      "description": "Performs breadth-first and depth-first traversals over a network topology. Processes each vertex using a provided function during traversal. Useful for analyzing connectivity or propagating state across network nodes.",
      "description_length": 217,
      "index": 209,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Packet.Igmp",
      "library": "frenetic",
      "description": "This module handles IGMP (Internet Group Management Protocol) packets, providing types and functions for parsing and constructing IGMP messages. It supports version-specific message types through a variant type that distinguishes between IGMPv1/v2 and IGMPv3, along with unparsable message handling. Concrete use cases include processing multicast group membership queries and reports in network monitoring or SDN applications.",
      "description_length": 427,
      "index": 210,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.Async.Logging",
      "library": "frenetic",
      "description": "This module enables structured logging with support for severity levels, timestamps, and tagged metadata, outputting messages as S-expressions or strings. It integrates asynchronous control flow via `Deferred.t`, offering scoped logging to track function boundaries with `surround_s`/`surroundf` and lifecycle management through flush and rotation triggers. Designed for applications requiring precise log structuring, contextual tracing, and non-blocking log handling in concurrent or distributed systems.",
      "description_length": 506,
      "index": 211,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Netkat.Pretty",
      "library": "frenetic",
      "description": "This module provides functions to format and convert network policies and predicates into human-readable strings. It supports pretty-printing of policy and predicate structures, including associative representations of policies. Use cases include debugging network programs, logging policy transformations, and generating readable output for network rule sets.",
      "description_length": 360,
      "index": 212,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Net.Link",
      "library": "frenetic",
      "description": "This module defines a data type `t` representing network links and provides functions to serialize and deserialize link data using S-expressions, compare links, and convert them to string or DOT format. It includes parsers for creating link objects from DOT and GML attribute lists, along with a default link value. It is used to model and manipulate network topologies by converting between different representation formats and enabling structured link comparisons.",
      "description_length": 466,
      "index": 213,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Network.NETWORK-Path",
      "library": "frenetic",
      "description": "This module computes shortest paths in a network topology using edge weights. It provides functions to find the shortest path between two vertices, all shortest paths from a source vertex, and all pairs of shortest paths that satisfy a given predicate. The module works with topologies composed of vertices and edges, where edge weights determine path costs.",
      "description_length": 358,
      "index": 214,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x04.PortStatus",
      "library": "frenetic",
      "description": "This module handles the serialization, deserialization, and string representation of OpenFlow 1.3.4 port status messages. It operates on the `portStatus` type, which captures events like port additions, removals, and state changes. Use this module to process port status updates from switches, convert them to and from binary format for transmission, or log them as human-readable strings.",
      "description_length": 389,
      "index": 215,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.OpenFlow0x04.Oxm",
      "library": "frenetic",
      "description": "This module defines operations for handling OpenFlow 1.3.4 OXM (OpenFlow Extensible Match) fields, including parsing, marshaling, and string representation. It works with the `t` type representing OXM fields and `oxmMatch` for match structures, using `Cstruct.t` for binary manipulation. Concrete use cases include serializing and deserializing flow match fields for network packet processing and switch communication.",
      "description_length": 418,
      "index": 216,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.OpenFlow0x04.PortMod",
      "library": "frenetic",
      "description": "This module defines operations for working with OpenFlow PortMod messages, including parsing, marshaling, and string representation. It handles the `t` type representing a PortMod message, which modifies port configurations in an OpenFlow switch. Use this module to construct or interpret PortMod messages for tasks like changing port properties or administrative states in network control applications.",
      "description_length": 403,
      "index": 217,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Packet.Igmp3",
      "library": "frenetic",
      "description": "This module handles IGMP v3 messages with a focus on group record management, enabling serialization and deserialization of packets containing checksums and group records. It supports operations for processing multicast group membership reports and leave messages, commonly used in network monitoring and SDN applications. The `GroupRec` submodule defines the structure of group records, including record type, multicast group address, and source address lists, and provides S-expression-based serialization. Together, the module and its submodule allow precise manipulation of IGMP v3 packets for tasks like parsing network traffic or constructing membership updates.",
      "description_length": 668,
      "index": 218,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.Packet.Tcp",
      "library": "frenetic",
      "description": "This module represents TCP packets with a `t` type that includes header fields like source and destination ports, sequence and acknowledgment numbers, flags, window size, and checksum, along with a `Cstruct.t` payload. The main operations support serialization and deserialization via S-expressions, enabling inspection and construction of TCP frames for network monitoring or packet manipulation. The child module provides a structured representation of TCP flags, allowing conversion between boolean fields like `syn`, `ack`, and `fin` and S-expressions. Together, they enable precise control and analysis of TCP communication states, such as initiating, acknowledging, or terminating connections.",
      "description_length": 699,
      "index": 219,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.OpenFlow.From0x01",
      "library": "frenetic",
      "description": "This module translates OpenFlow 1.0 messages, actions, and statistics into the unified Frenetic.OpenFlow interface. It handles conversion of switch features, port and flow statistics, and event generation from switch messages. It enables Frenetic to operate over OpenFlow 1.0 by mapping low-level 1.0 constructs to the higher-level action and event types used by the core Frenetic system.",
      "description_length": 388,
      "index": 220,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Network.MAKE-Parse",
      "library": "frenetic",
      "description": "Converts network topologies from DOT or GML file formats into an internal representation. Works with strings as file paths and constructs Topology.t values. Useful for loading predefined network structures from external configuration files into the system for simulation or analysis.",
      "description_length": 283,
      "index": 221,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x04.AggregateStats",
      "library": "frenetic",
      "description": "This module defines the structure and operations for handling aggregate flow statistics in OpenFlow 1.3.4. It provides functions to serialize, deserialize, and convert aggregate statistics to human-readable strings. It works directly with the `aggregStats` type and network buffers (`Cstruct.t`), commonly used for processing OpenFlow messages in network control applications.",
      "description_length": 376,
      "index": 222,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.Network.MAKE-Topology-UnitWeight",
      "library": "frenetic",
      "description": "This module implements a unit-weight topology where edges have integer weights. It provides functions to serialize and deserialize edge and weight values, compare weights, add weights together, and retrieve the zero weight value. It is used to model network topologies with uniform edge costs, enabling calculations like shortest paths or total network weight.",
      "description_length": 360,
      "index": 223,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.OpenFlow0x04.PortDesc",
      "library": "frenetic",
      "description": "This module defines operations for working with OpenFlow port description structures. It provides functions to calculate the size of a port description, serialize it to a buffer, parse it from a buffer, and convert it to a human-readable string. These operations are used when handling network device port information in OpenFlow 1.3.4 implementations.",
      "description_length": 352,
      "index": 224,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x01.FlowRemoved",
      "library": "frenetic",
      "description": "This module provides tools for working with OpenFlow 1.0 flow removal messages, including serialization, deserialization, and string representation. It centers around the `flowRemoved` type, which captures key fields like cookie, priority, and reason, and supports operations for converting between in-memory and wire formats. The child module handles conversion of flow removal reasons, enabling interpretation and serialization of causes like idle or hard timeouts. Together, these components allow developers to process and manipulate flow expiration notifications effectively.",
      "description_length": 580,
      "index": 225,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.OpenFlow0x01.Wildcards",
      "library": "frenetic",
      "description": "This module handles bitmask representations of wildcard fields in OpenFlow 1.0 flow entries. It provides functions to convert wildcard values to human-readable strings, marshal them to 32-bit integers, and parse them from integer bitmasks. It directly works with the `wildcards` type, which represents match fields that can be ignored in packet processing rules. Use this module when managing flow table entries that require flexible packet matching, such as ignoring source or destination IP addresses in a switch.",
      "description_length": 515,
      "index": 226,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.Netkat.Tokens",
      "library": "frenetic",
      "description": "This module defines a token type representing lexical elements used in parsing and processing network policies and queries. It includes tokens for logical operations, packet fields, control flow, and identifiers, along with associated values like strings, integers, and locations. It is used to represent the concrete syntax of policy languages during parsing and evaluation.",
      "description_length": 375,
      "index": 227,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Topology.Net",
      "library": "frenetic",
      "description": "This module orchestrates network topology construction and analysis by folding over graph-like structures to generate spanning trees from a given vertex. It collaborates with the `Topology` module to model vertices and edges, and leverages the `Traverse` module for traversal strategies, enabling tasks like building minimum spanning trees for routing or assessing graph connectivity. Shortest path computation is supported through multiple submodules, each offering functions to find single or all-pairs shortest paths with customizable filtering and integer-weighted path costs, useful for optimizing packet forwarding or analyzing network failures. Additional capabilities include loading topologies from DOT or GML files, exporting to visualization formats or Mininet scripts, and performing dynamic updates, neighbor discovery, and serialization for distributed synchronization.",
      "description_length": 883,
      "index": 228,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Netkat.Local_compiler",
      "library": "frenetic",
      "description": "This module organizes FDD-based computation with lattice-structured values, enabling efficient key-value transformations and policy analysis. It provides core operations for building, merging, and filtering FDDs, along with serialization and binary encoding capabilities through its submodules. You can map network policies into FDD representations, compute their lattice-aggregated results, and persist or transmit the structured data in binary or S-expression format. Key types include FDDs parameterized by keys and lattice values, with direct support for equality checks, imperative updates, and functional transformations.",
      "description_length": 627,
      "index": 229,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Network.MAKE-UnitPath",
      "library": "frenetic",
      "description": "This module computes shortest paths in a network topology using edge-weighted graphs. It provides functions to find the shortest path between two vertices, all shortest paths from a source vertex, and all pairs of shortest paths in the topology. The module works directly with Topology.t, vertex identifiers, and lists of edges weighted by integer values. It is used in network routing and traffic optimization scenarios where path selection depends on minimal cumulative edge weights.",
      "description_length": 485,
      "index": 230,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.Network.NETWORK-Topology-UnitWeight",
      "library": "frenetic",
      "description": "This module represents a unit-weighted network topology where edges have uniform weight. It provides functions to serialize and deserialize edge and weight values, compare weights, and perform addition with a zero identity. The module is used to model network graphs where all edges are treated equally, such as in unweighted shortest path calculations or uniform cost routing.",
      "description_length": 377,
      "index": 231,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Async.Shell",
      "library": "frenetic",
      "description": "Executes a function asynchronously in a separate thread, allowing concurrent evaluation of tasks. Works with functions that take an integer argument and return a unit value. Useful for running background computations or handling multiple tasks in parallel without blocking the main thread.",
      "description_length": 289,
      "index": 232,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x04.PortState",
      "library": "frenetic",
      "description": "This module defines the port state values used in OpenFlow 1.3.4, corresponding directly to the `ofp_port_state` enumeration. It provides functions to convert port state values to and from 32-bit integers, and to convert them into human-readable strings. These operations are essential when interpreting or constructing OpenFlow messages that describe the status of switch ports, such as in packet-in events or port status updates.",
      "description_length": 431,
      "index": 233,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x04.Action",
      "library": "frenetic",
      "description": "This module defines and manipulates OpenFlow 1.3.4 action structures, including individual actions and sequences of actions. It provides functions for serializing, deserializing, and converting actions between different representations, along with computing their size and string representation. It is used to construct and process OpenFlow messages that specify packet forwarding or modification instructions.",
      "description_length": 410,
      "index": 234,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Network.MAKE-module-type-PATH",
      "library": "frenetic",
      "description": "This module computes shortest paths in a network topology using edge-weighted graphs. It provides functions to find a single shortest path, all shortest paths from a source, and all pairs of shortest paths that satisfy a given predicate. These operations are useful for network routing and traffic optimization scenarios where paths must be determined based on specific edge weights.",
      "description_length": 383,
      "index": 235,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Packet.Icmp",
      "library": "frenetic",
      "description": "This module defines the structure and operations for handling ICMP packets, including fields for type, code, checksum, and payload. It provides serialization and deserialization functions for converting ICMP packet data to and from S-expressions. Use cases include processing ICMP echo requests and error messages in network monitoring or software-defined networking applications.",
      "description_length": 380,
      "index": 236,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.Packet.Arp",
      "library": "frenetic",
      "description": "This module defines the structure and serialization of ARP packets, supporting construction and parsing of ARP queries and replies. It operates on data link and network addresses, representing ARP payloads for Ethernet and IPv4. Use it to generate or interpret ARP packet contents in network monitoring or SDN applications.",
      "description_length": 323,
      "index": 237,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Network.EDGE",
      "library": "frenetic",
      "description": "This module defines a data type `t` representing edges in a network graph, along with functions to convert edges to and from S-expressions, compare them, and render them as strings or DOT format attributes. It provides specific parsers for converting DOT and GML attribute lists into edge values, and a default edge value for use in graph construction or testing. Concrete use cases include reading and writing network graphs in DOT or GML formats and manipulating edge attributes during graph transformations.",
      "description_length": 510,
      "index": 238,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.Network.VERTEX",
      "library": "frenetic",
      "description": "This module defines a polymorphic type `t` for representing vertices in a network graph, along with serialization and comparison functions. It supports conversion to and from S-expressions, DOT format, and GML format, enabling use in configuration parsing and network visualization tools. Concrete use cases include vertex manipulation in software-defined networking applications and integration with graph layout engines like Graphviz.",
      "description_length": 436,
      "index": 239,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Async.OpenFlow0x01_Plugin",
      "library": "frenetic",
      "description": "This module enables asynchronous management of OpenFlow 1.0 switches, handling events, flow and port statistics, packet forwarding, and policy updates using switch IDs, port IDs, flow patterns, and NetKAT policies. It coordinates with its child module, which manages low-level communication by establishing switch connections, sending OpenFlow messages, and exposing a stream of incoming events such as packet-ins and flow modifications. Together, they support concrete operations like querying switch features, sending packet-out commands, and dynamically updating forwarding rules in response to network events. Use them in tandem to implement custom control logic for software-defined networking applications.",
      "description_length": 712,
      "index": 240,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Netkat.FabricGen",
      "library": "frenetic",
      "description": "This module implements strategies for generating network fabric configurations tailored to virtual compilers, combining direct operations for constructing and manipulating topologies with advanced policy-based synthesis through its child modules. The core functionality includes creating switches, links, and flow rules, while the child modules generate fabric structures as policy pairs\u2014supporting both standard network synthesis and adversarial two-player strategies for modeling complex traffic constraints. Main data types include policies, predicates, and fabric structures that encode virtual and physical components, ingress/egress points, and visibility relations. Example uses include automating virtualized network setup, optimizing SDN routing, and simulating adversarial network conditions using synthesized policies.",
      "description_length": 829,
      "index": 241,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x04.RoleRequest",
      "library": "frenetic",
      "description": "This module defines the structure and operations for handling OpenFlow Role Request messages. It provides functions to calculate the size, convert to a string, serialize, and parse Role Request packets according to the OpenFlow 1.3.4 specification. These operations directly work with the `t` type representing Role Request messages and `Cstruct.t` buffers for binary data handling.",
      "description_length": 382,
      "index": 242,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x04.TableFeature",
      "library": "frenetic",
      "description": "This module defines operations for working with OpenFlow table feature structures, including parsing, marshaling, and calculating their size. It handles the `tableFeatures` data type, which represents the capabilities and configuration of a switch's flow table. Use cases include serializing table features for network transmission, deserializing received data, and inspecting table properties like maximum entries or supported match fields.",
      "description_length": 441,
      "index": 243,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x04.GroupDesc",
      "library": "frenetic",
      "description": "This module defines operations for handling OpenFlow 1.3.4 group description structures. It provides functions to calculate the size of a group description, convert it to a string, and serialize or deserialize it using Cstruct buffers. These operations are used when managing switch group tables, such as retrieving and modifying group configurations in network devices.",
      "description_length": 370,
      "index": 244,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x04.MeterFeatures",
      "library": "frenetic",
      "description": "This module handles parsing, marshaling, and string representation of OpenFlow 1.3.4 meter features structures. It operates on the `meterFeatures` type, which describes capabilities and constraints of metering in a switch. Use it to serialize meter configurations for transmission or inspect received meter feature replies from switches.",
      "description_length": 337,
      "index": 245,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.OpenFlow.To0x01",
      "library": "frenetic",
      "description": "This module translates high-level OpenFlow 1.3 constructs into their OpenFlow 1.0 equivalents, enabling compatibility with switches that only support the older version. It handles conversions for patterns, actions, flow modifications, switch features, and packet events between the two OpenFlow versions. Concrete use cases include compiling Frenetic programs that use group tables or parallel actions into OpenFlow 1.0 messages that emulate the same behavior using controller round-trips or equivalent 1.0 primitives.",
      "description_length": 518,
      "index": 246,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Packet.Ip",
      "library": "frenetic",
      "description": "This module handles IPv4 packet headers, offering operations to construct, parse, and manipulate packets, including fields such as source and destination addresses, TTL, and protocol-specific payloads like TCP, UDP, and ICMP. It supports serialization and deserialization of packet data to and from S-expressions for easy inspection and storage, enabling tasks like network packet analysis and custom packet generation. A child module provides direct access to fragmentation flags (`df` and `mf`), allowing precise control over packet fragmentation behavior. Together, these components support advanced networking tasks such as custom routing, packet filtering, and low-level network diagnostics.",
      "description_length": 696,
      "index": 247,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x04.QueueRequest",
      "library": "frenetic",
      "description": "This module handles the serialization, parsing, and size calculation of OpenFlow 1.3.4 Queue Statistics requests. It operates on the `t` type, which represents a queue request structure as defined in the specification. Use this module when constructing or interpreting OpenFlow messages for queue statistics in network monitoring or SDN controller applications.",
      "description_length": 361,
      "index": 248,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.OpenFlow0x04.MeterStats",
      "library": "frenetic",
      "description": "This module handles Meter Statistics structures as defined in the OpenFlow 1.3.4 specification. It provides operations to calculate the size of a meter statistics structure, convert it to a string for debugging, and serialize/deserialize it to and from memory buffers. These functions are used when managing network traffic policies and monitoring bandwidth usage in software-defined networking environments.",
      "description_length": 408,
      "index": 249,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Netkat.Optimize",
      "library": "frenetic",
      "description": "This module constructs and transforms network policies and predicates using logical and control-flow operations. It combines packet filters with boolean logic (mk_and, mk_or, mk_not), builds policy pipelines (mk_seq), applies repetition (mk_star), and merges alternatives (mk_union). It specializes policies to specific switches (specialize_policy) and normalizes policy expressions (norm_policy), handling lists of policies or predicates for bulk composition (mk_big_and, mk_big_union).",
      "description_length": 487,
      "index": 250,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow.Pattern",
      "library": "frenetic",
      "description": "This module defines packet-matching patterns for OpenFlow rules, enabling exact matches or wildcarding on fields such as MAC addresses, VLAN tags, IP addresses, ports, and input ports. It supports operations to compare and combine patterns, including equivalence checks, subset determination, and superset computation, facilitating precise flow table construction and analysis. The IP submodule extends this functionality by handling IP address patterns with subnet masks, allowing operations like intersection, joining, and overlap checking on `Frenetic_kernel.Packet.nwAddr` values. Together, these capabilities allow defining rules that match specific IP ranges, combining multiple subnets into broader patterns, and analyzing rule overlaps for network control applications.",
      "description_length": 777,
      "index": 251,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x04.Error",
      "library": "frenetic",
      "description": "This module defines operations for handling OpenFlow error messages, including parsing, marshaling, and pretty-printing. It works with the `error` type, which represents structured OpenFlow error data. Concrete use cases include decoding error responses from switches and encoding error messages for controller communication.",
      "description_length": 325,
      "index": 252,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x01.Match",
      "library": "frenetic",
      "description": "This module handles pattern matching in network flows by providing functions to convert patterns to human-readable strings, serialize them into binary format, parse them from binary data, and calculate their size. It operates directly on the `pattern` type representing packet match criteria. Use this module when implementing or managing flow tables in software-defined networking applications.",
      "description_length": 395,
      "index": 253,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.OpenFlow0x04.MultipartReq",
      "library": "frenetic",
      "description": "This module defines the structure and operations for handling multipart request messages in the OpenFlow 1.3.4 protocol. It supports serialization, deserialization, and string representation of multipart request data, which includes querying flow statistics, table statistics, and port statistics from a switch. The module works directly with `multipartRequest` type values and uses `Cstruct.t` for low-level memory manipulation during message encoding and decoding.",
      "description_length": 466,
      "index": 254,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Netkat.Vlr",
      "library": "frenetic",
      "description": "This module organizes a lattice-based framework for processing and combining network packet rules, using integer-pair keys to map to lattice elements for efficient lookup and modification. It integrates support for structured serialization, comparison, and hashing through its child modules, enabling use cases like flow table management and policy evaluation in SDN. The lattice operations interact with semi-ring values via decision diagrams, allowing complex rule combinations and symbolic analysis. Together, these components support concrete operations such as evaluating network policies, tracking hierarchical rule relationships, and persisting rule states as S-expressions or strings.",
      "description_length": 692,
      "index": 255,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x04.PortStats",
      "library": "frenetic",
      "description": "This module handles port statistics in OpenFlow 1.3.4, providing operations to serialize, deserialize, and display port statistics data. It works with the `t` type representing port statistics, including fields like port number, receive and transmit byte counts, and error rates. Use this module to process and manipulate port statistics messages exchanged between an OpenFlow controller and switch.",
      "description_length": 399,
      "index": 256,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Netkat.Syntax",
      "library": "frenetic",
      "description": "This module enables structured manipulation and comparison of NetKAT elements through serialization, equality checks, and ordering operations. It operates on identifiers (switch, port, virtual ports), network entities (hosts, buffer IDs), and policy components (predicates, expressions) with support for converting to S-expressions and JSON. These features facilitate tasks like compiling policies into flow tables, parsing NetKAT strings, and implementing dynamic network behaviors in SDN environments.",
      "description_length": 503,
      "index": 257,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.OpenFlow0x04.FlowMod",
      "library": "frenetic",
      "description": "This module defines operations for working with OpenFlow 1.3.4 flow modification messages. It provides functions to compute the size of a flow modification message, serialize it to a buffer, parse it from a buffer, and convert it to a human-readable string. These operations are used when constructing, transmitting, and inspecting flow table updates in an OpenFlow controller implementation.",
      "description_length": 392,
      "index": 258,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.OpenFlow0x01.StatsRequest",
      "library": "frenetic",
      "description": "This module defines the structure and serialization for OpenFlow 1.0 statistics requests. It supports converting request data to and from S-expressions and string representations. Use it to parse or generate OpenFlow 1.0 stats request messages in network monitoring or SDN controller applications.",
      "description_length": 297,
      "index": 259,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x04.GroupFeatures",
      "library": "frenetic",
      "description": "This module handles parsing and serializing the Group Features structure defined in the OpenFlow 1.3.4 specification. It works with the `groupFeatures` type, which represents capabilities and limits of a switch's group table. Use this module to read or write group feature data when interacting with OpenFlow switches, such as determining supported group types or statistics counters.",
      "description_length": 384,
      "index": 260,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Async.DynGraph",
      "library": "frenetic",
      "description": "This module implements a dynamic dataflow graph where nodes hold values and propagate updates to connected nodes. It supports creating nodes with custom update functions, attaching nodes to form directed edges, and interfacing with async pipes for external input and output. Use cases include building reactive systems that respond to changing data sources, such as live UI updates or stream processing pipelines.",
      "description_length": 413,
      "index": 261,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x04.QueueConfReply",
      "library": "frenetic",
      "description": "This module defines the structure and operations for handling OpenFlow Queue Configuration Reply messages. It provides functions to parse and serialize these messages, along with computing their size and converting them to a human-readable string format. It works directly with `Cstruct.t` and the `queueConfReply` type to support network-level message handling in OpenFlow 1.3.4 implementations.",
      "description_length": 396,
      "index": 262,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.Netkat.Parser",
      "library": "frenetic",
      "description": "Parses NetKAT policies and predicates from strings or files into structured syntax trees, enabling direct conversion of raw NetKAT code into executable policies or logical conditions. The module consumes string-based input and outputs policy and predicate types defined in the syntax module, supporting both inline parsing and file-based loading. It serves as the entry point for transforming human-readable NetKAT into structured representations used in network control applications. Submodules extend this capability with additional parsing utilities while maintaining compatibility with the core syntax model.",
      "description_length": 612,
      "index": 263,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Packet.Udp",
      "library": "frenetic",
      "description": "This module defines the structure and operations for handling UDP packets, including source and destination ports, checksum, and payload. It provides functions to serialize and deserialize UDP packet data using S-expressions. Use this module when working with UDP frame parsing, construction, or transformation in network applications.",
      "description_length": 335,
      "index": 264,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.OpenFlow0x01.Error",
      "library": "frenetic",
      "description": "This module handles error message types and serialization for OpenFlow 1.0, organizing errors into distinct categories such as HelloFailed, BadRequest, and BadAction, each with associated data representing specific protocol violations. It provides operations to convert error values to and from S-expressions and generate human-readable strings, enabling structured error handling and logging during protocol communication. Submodules define specific error codes for handshake failures, flow modification issues, invalid actions, port configuration problems, malformed requests, and queue operation failures, each supporting the same serialization and string conversion capabilities. Examples include detecting version mismatches in Hello messages, reporting invalid actions in switch configurations, and handling malformed OpenFlow request data.",
      "description_length": 846,
      "index": 265,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.OpenFlow0x04.QueueConfReq",
      "library": "frenetic",
      "description": "This module defines the structure and operations for handling OpenFlow Queue Configuration request messages. It provides functions to calculate the size of a request, convert it to a string for debugging, and serialize or parse the message from binary data. This is used when configuring queue settings on a switch port in an OpenFlow 1.3.4 network.",
      "description_length": 349,
      "index": 266,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x04.MultipartReply",
      "library": "frenetic",
      "description": "This module defines the structure and operations for handling multipart reply messages in the OpenFlow 1.3.4 protocol. It provides functions to calculate the size of a reply, convert it to a string, and serialize or deserialize it using a Cstruct buffer. It works directly with the `multipartReply` type and is used for processing switch responses such as flow statistics or port information.",
      "description_length": 392,
      "index": 267,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.OpenFlow0x04.QueueStats",
      "library": "frenetic",
      "description": "This module handles queue statistics in OpenFlow 1.3.4, providing operations to serialize, deserialize, and display queue statistic data. It works with the `t` type representing queue statistics, using `Cstruct.t` for binary data manipulation. Use this module to extract or construct queue statistics from network data or for logging and debugging queue behavior in OpenFlow switches.",
      "description_length": 384,
      "index": 268,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Net.Net",
      "library": "frenetic",
      "description": "This module enables network topology analysis and path computation for software-defined networking, offering direct support for constructing spanning trees, graph traversal, and path manipulation. It works with vertices, edges, and ports to model network structures, compute shortest paths using Dijkstra's algorithm, and serialize or parse topologies to and from formats like DOT, GML, and Mininet. Submodules enhance these capabilities with traversal strategies, shortest path variants, human-readable output generation, and file-based topology loading. You can build dynamic network graphs, validate packet forwarding paths, generate visualizations, and optimize routing based on link weights.",
      "description_length": 696,
      "index": 269,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x01.SwitchFeatures",
      "library": "frenetic",
      "description": "This module handles the data structures and serialization for OpenFlow 1.0 switch features, capturing supported wildcards, capabilities, and actions. It provides types like `supported_wildcards`, `t`, and port lists, along with operations to parse, serialize, and display switch properties. The first submodule represents switch-supported actions such as packet output and VLAN manipulation, with conversion to S-expressions and string formatting. The second submodule defines switch capabilities like flow statistics and STP support, offering similar conversion and display functions for feature negotiation during control plane setup.",
      "description_length": 636,
      "index": 270,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Netkat.Global_compiler",
      "library": "frenetic",
      "description": "This module compiles network policies into compact decision diagrams by leveraging internal bookkeeping and predicate constraints, translating high-level policies into structured representations for runtime enforcement and analysis. It uses field decision diagrams (FDDs) to model network flows with operations like conditional branching, union, and sequential composition, while its child modules represent NetKAT automata and manage FDD-based tables for optimization and transformation. You can convert policies into automata, analyze reachable states, perform imperative updates on FDDs, and serialize structured policy data for transmission. Example workflows include compiling and optimizing network-wide policies, verifying policy equivalence, and generating visual representations for debugging or documentation.",
      "description_length": 819,
      "index": 271,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Network.NETWORK-Pretty",
      "library": "frenetic",
      "description": "This module converts network topologies into string representations. It provides functions to generate human-readable text, DOT format for visualization, and Mininet scripts for network simulation. Use cases include debugging network layouts, generating input for graph visualization tools, and automating Mininet test environments.",
      "description_length": 332,
      "index": 272,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Hashcons.HASHTYPE",
      "library": "frenetic",
      "description": "This module represents hash-consed values with a unique integer identifier. It provides operations to retrieve the integer key for a value (`get`), reconstruct the value from its key (`unget`), and remove entries associated with a set of keys (`clear`). It is used to manage canonical forms of values, such as optimizing comparisons or reducing memory usage in symbolic computation or network configuration tasks.",
      "description_length": 413,
      "index": 273,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow0x01.Timeout",
      "library": "frenetic",
      "description": "This module provides functions to convert timeout values to and from string and integer representations. It operates on the `timeout` type, which represents OpenFlow 1.0 timeout values. Use cases include serializing timeouts for logging or network transmission and parsing integer values into typed timeouts for protocol handling.",
      "description_length": 330,
      "index": 274,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Netkat.Portless_Compiler",
      "library": "frenetic",
      "description": "Compiles portless network policies into portful policies by resolving switch port information using a provided network topology. Works with network policy and topology data structures to enable policy deployment in environments where port details are required. Useful for translating high-level policies into executable forms compatible with physical network devices.",
      "description_length": 367,
      "index": 275,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Hashcons",
      "library": "frenetic",
      "description": "This module enables hash-consing for arbitrary data structures using customizable hash and equality functions, ensuring structurally identical values share memory and can be compared efficiently by reference. It provides core operations to obtain a unique integer identifier for a value (`get`), recover the original value from its identifier (`unget`), and clear internal state for a set of identifiers (`clear`). These capabilities support tasks like optimizing memory usage in symbolic computation, managing compiler intermediate representations, and ensuring fast equality checks over large datasets. Submodules refine this functionality to specific value types and canonical form management, extending the core approach to practical use cases.",
      "description_length": 748,
      "index": 276,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.Async",
      "library": "frenetic",
      "description": "This module orchestrates asynchronous network control, HTTP services, and dataflow processing through a suite of specialized components. It centers around handling OpenFlow protocols for SDN, executing Frenetic programs, and managing HTTP and NetKAT-based policies with non-blocking I/O. Key data types include deferred values, event streams, flow tables, and policy representations, with operations for dynamic updates, structured logging, and concurrent task execution. Examples include launching an OpenFlow controller that reacts to packet-in events, deploying flow rules across switches, profiling async tasks, or running a web service that compiles policies on demand.",
      "description_length": 674,
      "index": 277,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.Network",
      "library": "frenetic",
      "description": "This module models network topologies with vertices, edges, and weighted connections, enabling path computation, traversal, and link management. It supports constructing and analyzing graphs with customizable vertex and edge types, including attributes like cost, capacity, and device metadata, and provides operations for shortest path calculation, spanning tree generation, and BFS/DFS traversal. Concrete functionality includes loading and exporting topologies in DOT, GML, and Mininet formats, computing optimal routes based on integer or custom weights, and manipulating network structures with dynamic updates to vertices, edges, and ports. Use cases span network simulation, routing optimization, fault analysis, and SDN controller development, integrating serialization, querying, and visualization tools across its submodules.",
      "description_length": 835,
      "index": 278,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.GroupTable0x04",
      "library": "frenetic",
      "description": "This module manages a mutable group table for defining packet processing behavior in software-defined networking. It supports creating groups of action buckets that determine packet forwarding, including fast failover and round-robin strategies, using OpenFlow 1.3 semantics. Concrete use cases include setting up redundant forwarding paths and load balancing across multiple ports.",
      "description_length": 382,
      "index": 279,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Util",
      "library": "frenetic",
      "description": "This module provides functions for string formatting with custom formatters, list transformation by mapping over tuple fields, and generating or displaying DOT graphs. It works with lists, formatter functions, and string-based DOT graph specifications. Concrete uses include converting structured data to strings, adjusting pairs in lists, and visualizing network topologies or control flow graphs using DOT.",
      "description_length": 408,
      "index": 280,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.Topology",
      "library": "frenetic",
      "description": "This module represents and manipulates network topologies, enabling queries on switch IDs, internal ports, and edge connections using types like `SDN.switchId`, `SDN.portId`, and `Net.Topology.PortSet`. It supports constructing topologies from symbolic definitions\u2014such as trees, chains, or single switches\u2014with parameterized size, and analyzes graph structures through spanning tree generation, shortest path computation, and connectivity assessment. It integrates with traversal strategies and file formats like DOT and GML for visualization, Mininet export, and dynamic updates. Examples include modeling forwarding paths in SDNs, validating switch connectivity in simulations, and optimizing routing with weighted path calculations.",
      "description_length": 736,
      "index": 281,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Netkat",
      "library": "frenetic",
      "description": "This module suite models and manipulates network policies using formal algebraic structures, translating high-level specifications into executable configurations. Core data types include policies, predicates, forwarding decision diagrams (FDDs), and network packets represented as structured field maps. Operations enable policy composition, parsing, evaluation, serialization, and equivalence checking, supporting tasks like compiling NetKAT programs into OpenFlow rules, simulating packet forwarding, and synthesizing network fabrics. Example workflows include transforming a virtual policy into a physical switch configuration, verifying automaton equivalence, or parsing and applying packet filters from configuration files.",
      "description_length": 728,
      "index": 282,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.Bits",
      "library": "frenetic",
      "description": "This module provides low-level bit and byte manipulation operations for 32-bit and 64-bit integers. It includes functions to set, clear, test, and modify individual bits, as well as extract specific bytes from integer values. These operations are useful for tasks like network protocol parsing, hardware control, and binary file format manipulation.",
      "description_length": 349,
      "index": 283,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.Packet",
      "library": "frenetic",
      "description": "This module enables the construction, parsing, and manipulation of network packets at multiple protocol layers, offering precise control over Ethernet frames, IP headers, and transport-layer protocols such as TCP, UDP, and ICMP. It provides core data types like `t` records for packet representations, along with operations for serialization, deserialization, and field access, supporting tasks like packet inspection, custom message crafting, and network monitoring. Child modules extend this functionality with protocol-specific handling: for example, IGMP modules manage multicast group membership messages, DNS structures support query and resource record manipulation, and TCP and UDP modules provide structured access to transport-layer fields. Together, they enable detailed packet manipulation across the network stack, from ARP resolution and IP fragmentation to TCP state tracking and ICMP message handling.",
      "description_length": 917,
      "index": 284,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.Net",
      "library": "frenetic",
      "description": "This module models network elements like nodes, links, and topologies, providing core data structures and operations for building and manipulating network state. It supports serialization to formats like S-expressions, DOT, and GML, enabling data persistence and inter-process communication. You can construct network graphs, compute shortest paths with Dijkstra's algorithm, and generate visualizations or Mininet-compatible configurations. Submodules handle node and link serialization, topology analysis, and traversal strategies, allowing tasks like path validation, spanning tree construction, and dynamic network modeling.",
      "description_length": 628,
      "index": 285,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.OpenFlow0x01",
      "library": "frenetic",
      "description": "This module enables structured data interchange for OpenFlow 0x01 protocol elements, focusing on serialization and deserialization via S-expressions for control plane logic in switch communication. It handles network-centric types such as flow modification commands, packet-in events, port state updates, and statistics messages, with support for converting values to and from wire formats, strings, and S-expressions. Child modules refine this functionality by processing port status changes, pseudo ports, port descriptions, switch configuration, action sequences, and flow removal messages, while deeper submodules handle bitmask wildcards, error types, timeout values, and switch capabilities. Examples include constructing flow table updates, interpreting port state transitions, configuring fragment handling, and decoding vendor extensions for custom SDN control logic.",
      "description_length": 876,
      "index": 286,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow",
      "library": "frenetic",
      "description": "This module translates high-level networking actions into OpenFlow 1.0 and 1.3 protocols, managing flow tables and serializing low-level constructs like packet headers, switch ports, and action groups. It supports type-safe identifiers, flow entries with match patterns and timeouts, action sequences for modification, enqueueing, and failover, and abstracts version-specific differences to enable seamless compilation across OpenFlow versions. For example, it compiles parallel actions into OpenFlow 1.3 group tables or emulates them in 1.0 using controller round-trips, and handles failover using fast-failover groups or fallback mechanisms. Child modules handle version-specific translations, pattern matching with support for MAC, VLAN, IP, and port fields, and utilities for comparing and combining match rules, enabling precise flow table construction and analysis across different OpenFlow versions.",
      "description_length": 906,
      "index": 287,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic.OpenFlow_Header",
      "library": "frenetic",
      "description": "This module defines the fixed OpenFlow message header structure, including version, type code, length, and transaction ID (xid). It provides functions to parse and marshal this header from or to a buffer, and to convert it to a human-readable string. The module is used to handle the common header format across all OpenFlow versions, enabling consistent message interpretation and construction.",
      "description_length": 395,
      "index": 288,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic.OpenFlow0x04",
      "library": "frenetic",
      "description": "This module provides S-expression serialization and deserialization for OpenFlow 1.3 protocol components, enabling precise manipulation of network control messages. It directly supports types representing switch configuration, flow management, error handling, and statistics, with operations for message construction, parsing, and inspection. Child modules handle specific structures such as meter configurations, flow statistics, match fields, group types, and flow modification commands, each offering serialization, deserialization, and string conversion. Use cases include building and parsing OpenFlow messages for switch communication, extracting and inspecting flow and port statistics, configuring meters and groups, and managing switch features and packet handling in software-defined networking environments.",
      "description_length": 818,
      "index": 289,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic",
      "library": "frenetic",
      "description": "This module provides a comprehensive toolkit for software-defined networking, network policy modeling, and low-level data manipulation. It centers on managing OpenFlow protocols, network topologies, and packet processing with data types like flow tables, graph structures, policy expressions, and bit-level representations. Operations include compiling high-level policies to switch rules, computing shortest paths in dynamic networks, serializing control messages, and crafting or inspecting network packets at multiple protocol layers. Specific tasks include deploying load-balanced forwarding groups, optimizing routing with weighted graph analysis, translating NetKAT programs into executable flow tables, and parsing OpenFlow messages for switch state management.",
      "description_length": 768,
      "index": 290,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.Net.Net.Topology.UnitWeight",
      "library": "frenetic.kernel",
      "description": "This module represents edge weights in a network topology as integers, providing functions to convert weights to and from S-expressions, compare weights, and perform addition. It works with the `edge` type from the `Frenetic_kernel.Net.Net.Topology` module, allowing retrieval of weight values from edges. Concrete use cases include managing link costs in routing algorithms and serializing topology data for storage or transmission.",
      "description_length": 433,
      "index": 291,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.Network.Net.Topology.Vertex",
      "library": "frenetic.kernel",
      "description": "This module represents vertices in a network topology, providing functions to convert vertices to and from various formats like S-expressions, DOT, and GML. It includes operations for comparing vertices, converting them to strings, and parsing vertex data from DOT and GML input formats. It is used when building or analyzing network topologies, particularly when interfacing with external tools like Mininet or graph visualization systems.",
      "description_length": 440,
      "index": 292,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.Topology.Net.Topology.Vertex",
      "library": "frenetic.kernel",
      "description": "This module defines a vertex type based on network nodes and provides functions for converting vertices to and from S-expressions, comparing them, and rendering them as strings in different formats such as DOT and Mininet. It includes parsers for constructing vertices from DOT and GML representations. Use cases include representing and manipulating network topology nodes in various serialization and visualization formats.",
      "description_length": 425,
      "index": 293,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.Network.Net.Topology.Edge",
      "library": "frenetic.kernel",
      "description": "This module represents edges in a network topology, providing functions to convert edges to and from S-expressions, compare edges, and serialize them to string and DOT formats. It supports parsing edges from DOT and GML attribute lists and includes a default edge value. It is used to model network links in graph representations for network analysis and visualization tools.",
      "description_length": 375,
      "index": 294,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_kernel.Topology.Net.Topology.UnitWeight",
      "library": "frenetic.kernel",
      "description": "This module defines a unit weight type as an integer and provides serialization functions for converting weights and edges to and from S-expressions. It includes operations for comparing weights, adding them, and retrieving the zero value. The module is used to assign and manipulate uniform weights on edges in a network topology, enabling weighted graph algorithms.",
      "description_length": 367,
      "index": 295,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x04.Hello.Element.VersionBitMap",
      "library": "frenetic.kernel",
      "description": "This module handles the Supported Version Bitmap structure in OpenFlow 1.3.4 hello messages. It provides functions to calculate the size of a version bitmap, convert it to a string for debugging, and marshal or parse it to and from binary format using Cstruct. The module works directly with the `supportedList` type representing sets of OpenFlow protocol versions.",
      "description_length": 365,
      "index": 296,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_kernel.Topology.Net.Topology.Edge",
      "library": "frenetic.kernel",
      "description": "This module represents network edges as links between nodes, providing functions to serialize and deserialize edges to and from S-expressions, compare edges, convert edges to string or DOT format, and parse edges from DOT or GML attributes. It works with graph data structures by handling edge-specific operations in network topology processing. Concrete use cases include reading and writing network topologies in different formats and manipulating individual edge attributes in a graph.",
      "description_length": 488,
      "index": 297,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "Frenetic_kernel.Network.Net.Topology.UnitWeight",
      "library": "frenetic.kernel",
      "description": "This module represents edge weights in a network topology as integers, providing functions to serialize and deserialize weight values and edges. It includes operations for comparing weights, adding them, and defining a zero value, all working directly with integer-based edge weights. Concrete use cases include modeling network paths where each edge has a uniform weight, such as in shortest path algorithms or bandwidth calculations.",
      "description_length": 435,
      "index": 298,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "Frenetic_kernel.Net.Net.Topology.Vertex",
      "library": "frenetic.kernel",
      "description": "This module defines a vertex type based on network nodes and provides functions for converting vertices to and from S-expressions, comparing them, and serializing them to formats like DOT and Mininet. It includes parsers for constructing vertices from DOT and GML representations. The module is used to represent and manipulate individual nodes within network topologies, such as switches or hosts, in a format compatible with graph-processing tools.",
      "description_length": 450,
      "index": 299,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x01.PortDescription.PortState.StpState",
      "library": "frenetic.kernel",
      "description": "This module defines conversions between the `stpState` type and integer and string representations. It provides functions to parse integers into `stpState` values, convert `stpState` values back to integers, and obtain string descriptions of `stpState`. These operations are used to interpret and serialize Spanning Tree Protocol (STP) port states in OpenFlow 1.0 messages.",
      "description_length": 373,
      "index": 300,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.Network.Make.Topology.UnitWeight",
      "library": "frenetic.kernel",
      "description": "This module implements a unit-weighted graph topology with edges represented as integers. It provides functions to serialize and deserialize edge weights, compare and sum weights, and retrieve the zero weight value. The module is used to model network topologies where each edge has a uniform cost, enabling shortest-path calculations and other graph algorithms that rely on consistent edge weights.",
      "description_length": 399,
      "index": 301,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.Net.Net.Topology.Edge",
      "library": "frenetic.kernel",
      "description": "This module represents network edges as links between nodes, providing functions to serialize and deserialize edges to and from S-expressions, compare edges, convert edges to string or DOT format, and parse edges from DOT or GML attributes. It works with network topologies by handling edge data in formats compatible with graph visualization and analysis tools. Concrete use cases include converting edge data for display in Graphviz, reading edge information from GML files, and managing edge identifiers in network simulations.",
      "description_length": 530,
      "index": 302,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.Network.Net.Pretty",
      "library": "frenetic.kernel",
      "description": "This module converts network topologies into string representations for visualization and simulation. It provides functions to generate human-readable strings, Graphviz DOT format output, and Mininet scripts from a network topology structure. Use cases include debugging network configurations, generating visualizations, and creating Mininet test environments from abstract network models.",
      "description_length": 390,
      "index": 303,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_kernel.Net.Net.Parse",
      "library": "frenetic.kernel",
      "description": "This module parses network topologies from file formats commonly used in graph representation. It supports reading topologies from DOT files and GML files, converting them into structured topology objects. Concrete use cases include loading predefined network layouts for simulation or analysis tasks.",
      "description_length": 301,
      "index": 304,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x01.Error.HelloFailed",
      "library": "frenetic.kernel",
      "description": "This module defines error codes for failed Hello messages in the OpenFlow 1.0 protocol. It includes the `Incompatible` and `Eperm` error types and provides functions to convert these errors to and from S-expressions and strings. It is used to handle and report errors during the initial handshake between OpenFlow switches and controllers.",
      "description_length": 339,
      "index": 305,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.Packet.Tcp.Flags",
      "library": "frenetic.kernel",
      "description": "This module defines a record type representing the 9 individual boolean flags in a TCP header, such as `syn`, `ack`, and `fin`, used to control connection state and data transmission. It provides functions to convert between this type and S-expressions for serialization and parsing. Concrete use cases include inspecting or modifying TCP control flags during packet processing in network applications or monitoring tools.",
      "description_length": 422,
      "index": 306,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_kernel.Network.Net.Parse",
      "library": "frenetic.kernel",
      "description": "This module parses network topologies from file formats. It supports reading graphs in DOT and GML formats and converts them into topology structures. Use it to load predefined network layouts for simulation or analysis tasks.",
      "description_length": 226,
      "index": 307,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.Network.Make.UnitPath",
      "library": "frenetic.kernel",
      "description": "This module computes shortest paths in a network topology using integer-weighted edges. It provides functions to find a single shortest path, all shortest paths from a source vertex, and all pairs of shortest paths that satisfy a given predicate. The results include the path length, start and end vertices, and the sequence of edges in the path.",
      "description_length": 346,
      "index": 308,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.Topology.Net.Path",
      "library": "frenetic.kernel",
      "description": "This module computes shortest paths in a network topology, providing functions to find individual shortest paths, all shortest paths from a source, and all pairs of shortest paths. It operates on edge-weighted topologies composed of vertices and edges, using a customizable weight type. Concrete use cases include network routing analysis and optimizing packet forwarding in software-defined networks.",
      "description_length": 401,
      "index": 309,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x01.PortDescription.PortFeatures",
      "library": "frenetic.kernel",
      "description": "This module provides functions to convert port feature flags to and from string and 32-bit integer representations. It operates on the `portFeatures` type, which represents OpenFlow 1.0 port capabilities such as link modes and connector types. Use this module when parsing or serializing port feature data in network management applications.",
      "description_length": 341,
      "index": 310,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.Topology.Net.Pretty",
      "library": "frenetic.kernel",
      "description": "This module provides functions to generate string representations of network topologies. It supports converting topologies to human-readable strings, DOT format for visualization, and Mininet scripts for network simulation. The primary data type it works with is the network topology structure defined in the Topology module.",
      "description_length": 325,
      "index": 311,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.Topology.Net.PATH",
      "library": "frenetic.kernel",
      "description": "This module computes shortest paths in a network topology, providing functions to find individual shortest paths, collections of shortest paths from a source, and all-pairs shortest paths. It operates on graph structures represented by vertices and edges from the `Topology` module, with paths returned as lists of edges. Concrete use cases include network routing analysis and path optimization in software-defined networking scenarios.",
      "description_length": 437,
      "index": 312,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.Network.Make.Topology",
      "library": "frenetic.kernel",
      "description": "This module manages graph-based network topologies with typed vertices, directed edges, and 32-bit integer ports, each supporting metadata. It allows creation, modification, and serialization of graphs through operations like adding or removing elements, querying vertex and edge counts, traversing neighbors, and inspecting edge endpoints, using standard collections for efficiency. A key submodule provides unit-weighted graph functionality, representing edges as integers with operations for weight serialization, comparison, summation, and retrieval of zero values. This supports uniform-cost network modeling and enables shortest-path algorithms and other graph analyses requiring consistent edge weights.",
      "description_length": 710,
      "index": 313,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_kernel.Net.Net.Path",
      "library": "frenetic.kernel",
      "description": "This module computes shortest paths in network topologies using a specified weight type. It provides functions to find single or multiple shortest paths between vertices, returning edge lists that represent the path. Concrete use cases include routing optimization and network analysis where minimal cost paths are critical.",
      "description_length": 324,
      "index": 314,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x01.PortDescription.PortConfig",
      "library": "frenetic.kernel",
      "description": "This module provides functions to convert port configuration values to and from string and 32-bit integer representations. It operates on the `portConfig` type, which represents OpenFlow 1.0 port configuration flags. Use this module when serializing port configurations for network transmission or parsing them from raw integer values.",
      "description_length": 335,
      "index": 315,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.Network.Make.Pretty",
      "library": "frenetic.kernel",
      "description": "This module provides functions to generate string representations of network topologies. It includes `to_string` for basic string output, `to_dot` for DOT format visualization, and `to_mininet` to produce Mininet simulation scripts. These functions operate on `Topology.t` values, enabling direct use in network modeling, visualization tools, and network emulation workflows.",
      "description_length": 375,
      "index": 316,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_kernel.Network.Net.UnitPath",
      "library": "frenetic.kernel",
      "description": "This module computes shortest paths in a network topology, providing functions to find a single shortest path, all shortest paths between two vertices, or all pairs of shortest paths with optional filtering. It operates on weighted edges and vertices within a topology, returning paths as lists of edges along with their weights. Concrete use cases include network routing analysis and path optimization in graph-based systems.",
      "description_length": 427,
      "index": 317,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x01.FlowRemoved.Reason",
      "library": "frenetic.kernel",
      "description": "This module defines conversions for flow removal reason codes in OpenFlow 1.0. It provides functions to convert these reasons to and from strings and 16-bit integers. Use this module when handling flow removal events to interpret or set the reason for a flow's removal.",
      "description_length": 269,
      "index": 318,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.Network.Net.PATH",
      "library": "frenetic.kernel",
      "description": "This module computes shortest paths in a network topology, providing functions to find a single shortest path, all shortest paths from a source, and all pairs of shortest paths with optional filtering. It operates on graph structures represented by vertices and edges from the Topology module, using edge weights to determine path costs. Concrete use cases include network routing analysis and optimizing packet forwarding paths in software-defined networks.",
      "description_length": 458,
      "index": 319,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.Network.Make.Traverse",
      "library": "frenetic.kernel",
      "description": "Implements breadth-first and depth-first traversal algorithms over network topologies. Operates on graph structures defined by the Topology module, visiting each vertex in a specified order. Useful for network analysis tasks such as path discovery, node classification, or topology visualization.",
      "description_length": 296,
      "index": 320,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x04.QueueDesc.QueueProp",
      "library": "frenetic.kernel",
      "description": "This module defines operations for handling queue property descriptions in OpenFlow 1.3.4. It supports parsing and serializing queue property data structures to and from memory buffers, along with computing their size and generating string representations. It works directly with `queueProp` values and memory regions represented by `Cstruct.t`.",
      "description_length": 345,
      "index": 321,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_kernel.Topology.Net.Traverse",
      "library": "frenetic.kernel",
      "description": "Implements breadth-first and depth-first traversal algorithms over network topologies. Operates on graph structures defined by vertices, applying a function to each vertex during traversal. Useful for analyzing connectivity, pathfinding, or network exploration tasks in software-defined networking applications.",
      "description_length": 311,
      "index": 322,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.Net.Net.PATH",
      "library": "frenetic.kernel",
      "description": "This module computes shortest paths and collections of shortest paths in a network topology. It operates on graph structures composed of vertices and edges, with functions to find individual shortest paths, all shortest paths from a source, and all pairs shortest paths under a given condition. Concrete use cases include network routing analysis and optimizing packet forwarding paths in software-defined networks.",
      "description_length": 415,
      "index": 323,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.Net.Net.Topology",
      "library": "frenetic.kernel",
      "description": "This module provides graph construction and traversal capabilities for network topologies, centered around functional manipulation of vertices, edges, and ports. It supports adding and removing nodes and connections, inspecting adjacency, and serializing topology components, with concrete applications in modeling network infrastructure and analyzing distributed systems. The module's core types interoperate with submodules that handle edge weights, vertex representations, and edge serialization, enabling tasks like managing link costs in routing, converting topologies to DOT for visualization, and parsing GML files into network edges. Functions for comparing, converting, and serializing vertices and edges facilitate integration with storage, simulation, and graph-processing tools.",
      "description_length": 790,
      "index": 324,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x04.GroupStats.BucketStats",
      "library": "frenetic.kernel",
      "description": "This module provides operations to parse, marshal, and convert bucket statistics to strings. It works with the `bucketStats` type, representing OpenFlow 1.3.4 bucket statistics. Use it to serialize bucket stats for transmission or display their contents in a human-readable format.",
      "description_length": 281,
      "index": 325,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x01.Error.PortModFailed",
      "library": "frenetic.kernel",
      "description": "This module defines error codes for port modification failures in OpenFlow 1.0, specifically `BadPort` and `BadHwAddr`. It provides functions to convert these errors to and from S-expressions and to generate human-readable string representations. Use this module when handling or reporting errors related to invalid port configurations or hardware addresses in OpenFlow control applications.",
      "description_length": 391,
      "index": 326,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x01.Error.QueueOpFailed",
      "library": "frenetic.kernel",
      "description": "This module defines error codes for queue operation failures in OpenFlow 1.0, specifically covering invalid ports, queues, and permission issues. It includes functions to convert between error values and S-expressions, along with a pretty-printing function for error messages. This module is used to handle and report errors related to queue operations in network switch management.",
      "description_length": 382,
      "index": 327,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_kernel.Topology.Net.UnitPath",
      "library": "frenetic.kernel",
      "description": "This module computes shortest paths in a network topology, providing functions to find individual paths, collections of paths from a source, and all-pairs shortest paths. It operates on graph structures represented by vertices and edges, with paths weighted by integer values. Concrete use cases include network routing analysis and path optimization in software-defined networking scenarios.",
      "description_length": 392,
      "index": 328,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x01.SwitchFeatures.Capabilities",
      "library": "frenetic.kernel",
      "description": "This module defines a record type representing the capabilities of an OpenFlow 1.0 switch, including support for flow statistics, table statistics, port statistics, STP, IP reassembly, queue statistics, and ARP matching. It provides functions to convert between the record and S-expressions, and to generate a human-readable string representation. It is used to query and represent the feature set available on a switch during control plane interactions.",
      "description_length": 454,
      "index": 329,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_kernel.Network.Net.Path",
      "library": "frenetic.kernel",
      "description": "This module computes shortest paths in a network topology using a specified weight type. It provides functions to find single or multiple shortest paths between vertices, returning edge lists that represent the path. Use it when determining optimal routes between nodes in a network, such as in routing protocols or network analysis tools.",
      "description_length": 339,
      "index": 330,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x04.Hello.Element",
      "library": "frenetic.kernel",
      "description": "This module structures OpenFlow Hello elements with support for serialization, deserialization, and string representation using the `element` type. It integrates the handling of Supported Version Bitmaps through its child module, enabling operations like size calculation, binary conversion with Cstruct, and debug output for protocol version sets represented as `supportedList`. Use cases include parsing and constructing Hello messages during switch communication, extracting version information, and logging element contents for debugging. Direct API functions manipulate full Hello elements while submodules handle internal structures like version bitmaps.",
      "description_length": 660,
      "index": 331,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.Packet.Dns.Qd",
      "library": "frenetic.kernel",
      "description": "This module defines DNS query data structures and serialization functions. It provides `t_of_sexp` and `sexp_of_t` for converting between DNS query records and S-expressions. It operates on the `t` type, which represents DNS query sections with name, type, and class fields. Use this module when parsing or generating DNS packet payloads in network applications.",
      "description_length": 362,
      "index": 332,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_kernel.Packet.Ip.Flags",
      "library": "frenetic.kernel",
      "description": "This module defines and manipulates the flag fields (`df` and `mf`) of an IPv4 packet header. It provides functions to convert these flags to and from S-expressions for serialization and parsing. Use cases include inspecting or modifying fragmentation behavior in network packet processing tasks.",
      "description_length": 296,
      "index": 333,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x01.PortDescription.PortState",
      "library": "frenetic.kernel",
      "description": "This module handles the conversion of network port state values to and from strings and integers, centered around the `portState` type used in OpenFlow 1.0. It includes operations to parse, serialize, and describe port states, enabling tasks like logging or preparing data for network transmission. A child module extends this functionality to the `stpState` type, providing equivalent conversions for Spanning Tree Protocol states. Together, they support precise manipulation and interpretation of port state information in both general and STP-specific contexts.",
      "description_length": 564,
      "index": 334,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.Network.Net.Traverse",
      "library": "frenetic.kernel",
      "description": "Implements breadth-first and depth-first traversal over network topologies. Operates on graph structures defined by vertices and edges in the Topology module. Useful for analyzing connectivity, pathfinding, and network exploration tasks.",
      "description_length": 237,
      "index": 335,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.Network.Make.Path",
      "library": "frenetic.kernel",
      "description": "This module computes shortest paths in a network topology using a specified weight type. It provides functions to find the shortest path between two vertices, all shortest paths from a source vertex, and all pairs of shortest paths in the topology. It operates on a graph structure represented by vertices and edges, with weights determined by the provided `Weight` module.",
      "description_length": 373,
      "index": 336,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x01.Error.BadAction",
      "library": "frenetic.kernel",
      "description": "This module defines error codes specific to invalid actions in OpenFlow 1.0 messages, such as incorrect action types, lengths, or unsupported vendor actions. It includes functions to convert error values to and from S-expressions and to generate human-readable string representations. Use this module when handling or reporting errors related to malformed or unsupported action descriptions in OpenFlow control messages.",
      "description_length": 420,
      "index": 337,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.Network.Make.Parse",
      "library": "frenetic.kernel",
      "description": "Converts network topologies from DOT or GML file formats into an internal representation. Works with strings as file paths and constructs Topology.t values. Useful for loading predefined network structures from external configuration files for simulation or analysis.",
      "description_length": 267,
      "index": 338,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x01.PortStatus.ChangeReason",
      "library": "frenetic.kernel",
      "description": "This module defines a type `t` representing the possible reasons for a port status change in an OpenFlow 1.0 switch, specifically `Add`, `Delete`, and `Modify`. It provides functions to convert values of type `t` to and from S-expressions and to convert them to human-readable strings. This module is used to interpret port status events received from an OpenFlow switch, enabling applications to react appropriately to changes in switch port configuration.",
      "description_length": 457,
      "index": 339,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.Topology.Net.Parse",
      "library": "frenetic.kernel",
      "description": "This module provides functions to parse network topologies from DOT and GML file formats. It converts string representations of graphs into structured topology objects. Use this module when loading network layouts from external configuration files for simulation or analysis tasks.",
      "description_length": 281,
      "index": 340,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.Net.Net.Traverse",
      "library": "frenetic.kernel",
      "description": "Implements breadth-first and depth-first traversal algorithms over network topologies. Operates on graph structures defined by vertices, applying a given function to each vertex during traversal. Useful for analyzing network connectivity, path discovery, and topology exploration in software-defined networking applications.",
      "description_length": 324,
      "index": 341,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_kernel.Topology.Net.Topology",
      "library": "frenetic.kernel",
      "description": "This module organizes network topologies as graphs with vertices, edges, and ports, supporting efficient element tracking, graph traversal, and bulk transformations. It coordinates with submodules that define core data types: one for network nodes with serialization and formatting, another for integer-based edge weights with arithmetic operations, and a third for edge representations with format parsing and conversion. Together, they enable tasks like building and modifying network graphs, applying weighted algorithms, and serializing topologies to formats like DOT and GML. Direct APIs allow topology construction and traversal, while submodules handle data representation, comparison, and format-specific operations.",
      "description_length": 724,
      "index": 342,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x01.SwitchConfig.FragFlags",
      "library": "frenetic.kernel",
      "description": "This module defines a type `t` representing fragmentation handling modes in an OpenFlow switch configuration, including options to handle fragments normally, drop them, or reassemble them. It provides functions to convert values of type `t` to and from S-expressions and to obtain string representations of the flags. These operations support serialization and debugging in network control applications.",
      "description_length": 403,
      "index": 343,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow.Pattern.Ip",
      "library": "frenetic.kernel",
      "description": "This module represents and manipulates IP address patterns with associated subnet masks, supporting operations like matching, comparison, union, and intersection. It works with IP addresses as `Frenetic_kernel.Packet.nwAddr` and subnet masks as `int32`, structured as tuples. Concrete use cases include defining packet filter rules, merging routing policies, and checking compatibility between IP address ranges in software-defined networking.",
      "description_length": 443,
      "index": 344,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x01.FlowMod.Command",
      "library": "frenetic.kernel",
      "description": "This module defines conversions for flow modification commands in the OpenFlow 1.0 protocol. It supports operations to translate command values to and from string and 16-bit integer representations. Use this module when encoding or decoding flow modification messages for communication with OpenFlow switches.",
      "description_length": 309,
      "index": 345,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x01.Error.BadRequest",
      "library": "frenetic.kernel",
      "description": "This module defines error codes for malformed OpenFlow 1.0 requests, including invalid version, type, statistics, vendor, or length. It provides serialization to and from S-expressions and converts errors to human-readable strings. Use this module to handle and report request-specific errors in OpenFlow message parsing or validation.",
      "description_length": 335,
      "index": 346,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x01.SwitchFeatures.SupportedActions",
      "library": "frenetic.kernel",
      "description": "This module represents the set of actions supported by an OpenFlow 1.0 switch, with boolean flags indicating support for specific actions such as packet output, VLAN modification, MAC address changes, and queueing. It provides functions to serialize and deserialize these capabilities to and from S-expressions, along with a function to generate a human-readable string representation. This module is used to communicate and query switch capabilities during control plane setup and policy enforcement.",
      "description_length": 501,
      "index": 347,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_kernel.Packet.Igmp3.GroupRec",
      "library": "frenetic.kernel",
      "description": "This module defines a type `t` representing IGMPv3 group records, including their type, multicast group address, and list of source addresses. It provides functions to serialize and deserialize these records using S-expressions. This module is used to handle multicast group membership information in network packet processing.",
      "description_length": 327,
      "index": 348,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.Network.Make.PATH",
      "library": "frenetic.kernel",
      "description": "This module computes shortest paths in a network topology using edge weights. It provides functions to find a single shortest path, all shortest paths from a source, and all pairs of shortest paths that satisfy a given condition. These operations work with vertices and edges of a topology, returning paths as lists of edges.",
      "description_length": 325,
      "index": 349,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.Network.Net.Topology",
      "library": "frenetic.kernel",
      "description": "This module manages network topology graphs through vertex and edge manipulation, port configuration, and serialization, supporting dynamic graph updates and traversal algorithms. It includes data types for vertices, edges, ports, and associated sets, with operations for comparison, conversion, and attribute parsing from formats like DOT and GML. Child modules handle vertex and edge representation, enabling integration with visualization tools and network analysis, while the edge weight submodule provides integer-based weighting for path calculations and bandwidth modeling. Examples include building network models from external input, computing shortest paths, and serializing topologies for debugging or storage.",
      "description_length": 721,
      "index": 350,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.Net.Net.UnitPath",
      "library": "frenetic.kernel",
      "description": "This module computes shortest paths in a network topology, providing functions to find individual paths, all shortest paths from a source, and all pairs of shortest paths. It operates on graph structures defined by vertices and edges from the Topology module, with paths represented as lists of edges. Concrete use cases include network routing analysis and path optimization in software-defined networking scenarios.",
      "description_length": 417,
      "index": 351,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_kernel.Packet.Dns.Rr",
      "library": "frenetic.kernel",
      "description": "This module defines DNS resource record operations for parsing and constructing DNS packet payloads. It works with DNS resource records (`t`) containing name, type, class, TTL, and raw data fields. Concrete use cases include handling DNS response data in network monitoring or packet manipulation tasks.",
      "description_length": 303,
      "index": 352,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x01.Error.FlowModFailed",
      "library": "frenetic.kernel",
      "description": "This module defines error codes specific to flow modification failures in the OpenFlow 1.0 protocol. It includes operations for converting error values to and from S-expressions and to strings. Concrete use cases include handling and reporting errors when installing or modifying flows in a software-defined networking context.",
      "description_length": 327,
      "index": 353,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.Net.Net.Pretty",
      "library": "frenetic.kernel",
      "description": "This module converts network topologies into string representations. It provides functions to generate human-readable text, Graphviz DOT format, and Mininet simulation scripts from a topology. Use cases include visualizing network structures, generating input for network simulations, and debugging topology configurations.",
      "description_length": 323,
      "index": 354,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_kernel.Network.VERTEX",
      "library": "frenetic.kernel",
      "description": "This module defines a polymorphic type `t` for representing vertices in a network graph, along with functions to convert vertices to and from S-expressions, compare them, and render them as strings or DOT/GML format nodes. It includes parsers for constructing vertex values from DOT and GML node representations and utilities for outputting vertex data in Mininet-compatible formats. Concrete use cases include serializing network topologies to configuration files or visualizing them using graph tools.",
      "description_length": 503,
      "index": 355,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x04.Hello",
      "library": "frenetic.kernel",
      "description": "This module implements the OpenFlow 1.3.4 Hello message structure, providing operations to serialize, deserialize, and inspect Hello messages using the `t` type and `Cstruct.t` for binary manipulation. It structures Hello elements through the `element` type, supporting operations like size calculation, binary conversion, and debug output, with internal handling of Supported Version Bitmaps via submodules. Concrete use cases include parsing incoming Hello messages from switches, constructing Hello replies during handshakes, and extracting or logging version information for protocol negotiation.",
      "description_length": 600,
      "index": 356,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x04.PortStats",
      "library": "frenetic.kernel",
      "description": "This module handles port statistics in the OpenFlow 1.3.4 protocol, providing operations to serialize, deserialize, and display port statistics data. It works with the `t` type representing port statistics and `Cstruct.t` for memory-efficient byte-level manipulation. Use this module to process and construct port statistics messages in network monitoring and switch management applications.",
      "description_length": 391,
      "index": 357,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x04.PortStatus",
      "library": "frenetic.kernel",
      "description": "This module handles the serialization, deserialization, and string representation of OpenFlow 1.3.4 port status messages. It operates on the `portStatus` type, which represents events such as port additions, removals, or state changes. Use this module to process port status updates received from switches, or to construct and send port status messages over the network.",
      "description_length": 370,
      "index": 358,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.Network.MAKE-Traverse",
      "library": "frenetic.kernel",
      "description": "Implements breadth-first and depth-first traversal algorithms over network topologies. Operates on graph structures defined by the Topology module, visiting each vertex in a specified order. Useful for network analysis tasks such as path discovery, node classification, or topology visualization.",
      "description_length": 296,
      "index": 359,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x04.TableStats",
      "library": "frenetic.kernel",
      "description": "This module handles table statistics in OpenFlow 1.3.4, providing operations to parse, marshal, and convert table statistics data to strings. It works with the `t` type representing OpenFlow table statistics and uses `Cstruct.t` for binary data manipulation. Concrete use cases include processing and serializing table statistics messages in network monitoring and SDN controller applications.",
      "description_length": 393,
      "index": 360,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x04.SwitchConfig",
      "library": "frenetic.kernel",
      "description": "This module defines the structure and operations for handling OpenFlow 1.3.4 switch configuration data. It provides functions to calculate the size of a configuration, convert it to a string, and serialize or deserialize it using Cstruct buffers. Use this module when working with OpenFlow control messages that require reading or constructing switch configuration payloads, such as when implementing or parsing OFPT_SET_CONFIG or OFPT_GET_CONFIG_REPLY messages.",
      "description_length": 462,
      "index": 361,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x01.Error",
      "library": "frenetic.kernel",
      "description": "This module represents and serializes OpenFlow 1.0 error messages, organizing them into distinct categories such as handshake failures, request malformations, and flow modification issues. It defines core data types like `HelloFailed`, `BadRequest`, and `FlowModFailed`, each capturing specific error contexts, and provides serialization functions for transmission or logging. Submodules handle specialized error types, such as `Incompatible` and `Eperm` for handshake failures, `BadPort` and `BadHwAddr` for port configuration issues, and `BadAction` variants for malformed message actions. These types can be converted to human-readable strings or S-expressions, enabling structured error reporting and debugging in OpenFlow control applications.",
      "description_length": 748,
      "index": 362,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.Net.Node",
      "library": "frenetic.kernel",
      "description": "This module defines a concrete type `t` representing network nodes and provides bidirectional conversion between this type and S-expressions via `t_of_sexp` and `sexp_of_t`. It works directly with `Frenetic_kernel.Net.node` and `Sexplib0__.Sexp.t` types. It is used to serialize and deserialize network node data for storage or communication purposes.",
      "description_length": 351,
      "index": 363,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.Network.NETWORK-module-type-PATH",
      "library": "frenetic.kernel",
      "description": "This module computes shortest paths in a network topology using edge-weighted graphs. It provides functions to find a single shortest path, all shortest paths from a source, and all pairs of shortest paths that satisfy a given predicate. The core data structures are lists of edges representing paths, with vertices and weights from the `Topology` module. Use cases include network routing analysis and optimizing packet forwarding in software-defined networks.",
      "description_length": 461,
      "index": 364,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x04.QueueConfReply",
      "library": "frenetic.kernel",
      "description": "This module defines the structure and operations for handling OpenFlow 1.3.4 Queue Configuration reply messages. It provides functions to calculate the size, convert to a string, serialize, and parse these messages. Use this module when implementing or interacting with OpenFlow control plane logic that requires queue configuration responses.",
      "description_length": 343,
      "index": 365,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x04.PortMod",
      "library": "frenetic.kernel",
      "description": "This module defines the structure and operations for modifying port configurations in OpenFlow 1.3.4. It provides functions to serialize, deserialize, and display port modification messages. Use this module when handling port state updates or configuration changes in an OpenFlow switch.",
      "description_length": 287,
      "index": 366,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x04.GroupStats",
      "library": "frenetic.kernel",
      "description": "This module manages OpenFlow 1.3.4 group statistics, handling parsing, marshaling, and pretty-printing of both overall group statistics and their per-bucket components. The core `groupStats` type captures group-level data such as reference counts and bucket statistics arrays, while the `bucketStats` type in the child module represents per-bucket packet and byte counts. Operations include converting structured statistics to binary for transmission or extracting human-readable summaries from received data. Use it to serialize group state for network communication or analyze received statistics for monitoring and debugging.",
      "description_length": 628,
      "index": 367,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x04.Error",
      "library": "frenetic.kernel",
      "description": "This module defines the structure and operations for handling OpenFlow 1.3.4 error messages. It provides functions to serialize (`marshal`), deserialize (`parse`), compute the size (`sizeof`), and convert to a human-readable string (`to_string`) error messages. It works directly with the `error` type and `Cstruct.t` buffers, enabling efficient parsing and construction of error payloads in network applications.",
      "description_length": 413,
      "index": 368,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x04.PortState",
      "library": "frenetic.kernel",
      "description": "This module defines the OpenFlow 1.3.4 port state enumeration, representing the possible states of a switch port such as link down, blocked, or live. It provides functions to convert port state values to and from 32-bit integers, and to generate human-readable string representations. These operations are used when interpreting or constructing OpenFlow messages that include port state information, such as port status updates or configuration requests.",
      "description_length": 454,
      "index": 369,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.Network.MAKE-Parse",
      "library": "frenetic.kernel",
      "description": "Converts network topologies from DOT or GML file formats into an internal representation. Works with strings as file paths and constructs Topology.t values. Useful for loading predefined network structures from external configuration files for simulation or analysis.",
      "description_length": 267,
      "index": 370,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x04.FlowStats",
      "library": "frenetic.kernel",
      "description": "This module handles individual flow statistics in OpenFlow 1.3.4, providing operations to serialize, deserialize, and display flow statistics data. It works directly with the `flowStats` type and network buffers via `Cstruct.t`. Use this module to extract or format flow statistics from switches, such as packet and byte counts per flow.",
      "description_length": 337,
      "index": 371,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x04.AsyncConfig",
      "library": "frenetic.kernel",
      "description": "This module defines the structure and operations for handling asynchronous configuration messages in the OpenFlow 1.3.4 protocol. It supports parsing and serializing `asyncConfig` values to and from binary data using `Cstruct.t`, along with determining their size and converting them to human-readable strings. Concrete use cases include managing packet-in, port-status, and flow-removed message configurations in software-defined networking applications.",
      "description_length": 455,
      "index": 372,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x01.PortStatus",
      "library": "frenetic.kernel",
      "description": "This module handles OpenFlow 1.0 port status messages, encoding and decoding events that signal changes in switch port state. It centers on a core type `t` representing port status reasons\u2014`Add`, `Delete`, and `Modify`\u2014with support for S-expression conversion and string representation. Functions allow parsing raw message data into structured values and reconstructing messages for transmission, enabling network controllers to monitor and respond to port configuration changes. Submodule `Reason` provides auxiliary operations for inspecting and formatting the cause of each port status event.",
      "description_length": 595,
      "index": 373,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x04.FlowRemoved",
      "library": "frenetic.kernel",
      "description": "This module handles the serialization, deserialization, and string representation of OpenFlow 1.3.4 flow removed messages. It operates on the `flowRemoved` type, which captures metadata about flows that have been removed from a switch. Use this module to convert flow removal data to and from binary format for network transmission or logging.",
      "description_length": 343,
      "index": 374,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x04.MultipartReq",
      "library": "frenetic.kernel",
      "description": "This module defines the structure and operations for handling OpenFlow 1.3.4 multipart request messages. It provides functions to calculate the size of a request, convert it to a string for debugging, and serialize or deserialize it to and from binary format using Cstruct. These operations are essential for constructing and interpreting OpenFlow control messages in network monitoring and management applications.",
      "description_length": 415,
      "index": 375,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x01.PortDescription",
      "library": "frenetic.kernel",
      "description": "This module manages the full lifecycle of OpenFlow 1.0 port descriptions, handling serialization, parsing, and human-readable formatting. It centers on the `portDescription` type, which captures port configuration, state, and capabilities, and supports conversion to and from network byte order. The module's submodules provide fine-grained control over port features (`portFeatures`), configuration flags (`portConfig`), and state values (`portState`), including STP-specific extensions via `stpState`. Use it to decode raw port data from switches, construct port updates for network management, or log detailed port status in human-readable form.",
      "description_length": 648,
      "index": 376,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x04.MeterMod",
      "library": "frenetic.kernel",
      "description": "This module defines the structure and operations for modifying meter entries in OpenFlow 1.3.4. It provides functions to serialize, deserialize, and convert meter modification messages to strings, working directly with the `meterMod` type and Cstruct buffers. It is used to configure per-flow rate limiting or traffic marking policies in software-defined networking switches.",
      "description_length": 375,
      "index": 377,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x01.Message",
      "library": "frenetic.kernel",
      "description": "This module defines a comprehensive set of message types used in OpenFlow 1.0 for communication between switches and controllers, including handshake, configuration, flow management, packet handling, and statistics operations. It supports serialization, deserialization, parsing, and size calculation for these messages, enabling efficient network transmission and processing. Concrete use cases include switch feature negotiation, flow table updates, packet-in events, and barrier synchronization in SDN environments.",
      "description_length": 518,
      "index": 378,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x04.TableFeature",
      "library": "frenetic.kernel",
      "description": "This module handles the serialization, deserialization, and representation of OpenFlow 1.3.4 table feature structures. It provides operations to calculate the size of a table feature, convert it to and from a Cstruct buffer, and generate a human-readable string representation. These functions are used when configuring or querying switch table capabilities in an OpenFlow controller.",
      "description_length": 384,
      "index": 379,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.Hashcons.HASHTYPE",
      "library": "frenetic.kernel",
      "description": "This module represents hash-consed values with a unique integer identifier. It provides operations to retrieve the integer key for a value (`get`), recover the value from its key (`unget`), and remove entries associated with a set of keys (`clear`). It is used to manage interned values efficiently, such as symbols or expressions, where equality can be checked via integer comparison.",
      "description_length": 385,
      "index": 380,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x04.Capabilities",
      "library": "frenetic.kernel",
      "description": "This module defines bitflag representations of OpenFlow switch capabilities, such as flow statistics, port statistics, and group support. It provides conversions between capability values, integers, and string representations. Use this module when negotiating or interpreting switch features during OpenFlow handshake or device management.",
      "description_length": 339,
      "index": 381,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x04.MeterFeatures",
      "library": "frenetic.kernel",
      "description": "This module handles parsing, marshaling, and string representation of OpenFlow 1.3.4 meter features structures. It works directly with `Cstruct.t` and the `meterFeatures` type to serialize and deserialize meter configuration data. Use this module when implementing or managing switch metering capabilities in OpenFlow control plane logic.",
      "description_length": 338,
      "index": 382,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.Network.MAKE-Path",
      "library": "frenetic.kernel",
      "description": "Implements shortest path algorithms on network topologies using a customizable weight type. It computes single or multiple shortest paths between vertices, returning paths as edge lists. Useful for routing optimization or network analysis tasks where paths need explicit representation.",
      "description_length": 286,
      "index": 383,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x04.PacketOut",
      "library": "frenetic.kernel",
      "description": "This module defines operations for constructing and serializing OpenFlow 1.3.4 packet-out messages. It provides functions to calculate the size of a packet-out message, convert it to a string for debugging, and marshal or parse it to or from a Cstruct buffer. These operations are used when sending packets from a controller to a switch, such as injecting packets into the network or responding to packet-in events.",
      "description_length": 415,
      "index": 384,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x04.FlowModCommand",
      "library": "frenetic.kernel",
      "description": "This module defines operations for working with OpenFlow 1.3.4 flow modification commands. It provides functions to calculate the size of a command, serialize it to a byte representation, parse it from bytes, and convert it to a human-readable string. These operations are used when constructing or interpreting flow modification messages sent between a controller and a switch.",
      "description_length": 378,
      "index": 385,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x04.RoleRequest",
      "library": "frenetic.kernel",
      "description": "This module defines the structure and operations for handling OpenFlow Role Request messages. It provides functions to calculate the size, convert to a string, serialize, and parse Role Request messages, which are used to negotiate controller roles in an OpenFlow switch. Concrete use cases include encoding and decoding role negotiation packets during controller-switch communication.",
      "description_length": 385,
      "index": 386,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x04.PseudoPort",
      "library": "frenetic.kernel",
      "description": "This module defines operations for working with OpenFlow 1.3 pseudo ports. It provides functions to create pseudo port values from raw integers, determine their size in bytes, convert them to human-readable strings, and serialize them to 32-bit integers. Use this module when handling virtual switch ports in OpenFlow control plane logic, such as representing ingress or egress ports in flow entries.",
      "description_length": 400,
      "index": 387,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x04.FlowRequest",
      "library": "frenetic.kernel",
      "description": "This module defines the structure and operations for handling OpenFlow 1.3.4 flow statistics requests. It provides functions to calculate the size of a request, convert it to a string for debugging, and serialize/deserialize it for network transmission. Concrete use cases include constructing and parsing flow request messages sent between a controller and a switch to query flow statistics.",
      "description_length": 392,
      "index": 388,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x04.Instruction",
      "library": "frenetic.kernel",
      "description": "This module defines operations for handling OpenFlow 1.3.4 flow instructions, including parsing, marshaling, and string representation. It works with the `instruction` type and `Cstruct.t` for binary data manipulation. Use this module when implementing or processing flow modification commands in an OpenFlow controller or switch.",
      "description_length": 330,
      "index": 389,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.Topology.Mininet",
      "library": "frenetic.kernel",
      "description": "This module defines functions to construct network topologies from symbolic representations like trees, linear chains, single switches, or minimal configurations. It translates `topo_name` values into concrete `Topology.t` structures used for network simulation and testing. Concrete use cases include generating test networks for SDN controllers or evaluating routing algorithms under controlled topological conditions.",
      "description_length": 420,
      "index": 390,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_kernel.Network.NETWORK-Topology",
      "library": "frenetic.kernel",
      "description": "This module supports operations for constructing, modifying, and querying graph-based network structures, including vertex and edge management, port configuration, and serialization to persistent formats. It operates on a graph representation composed of vertices, edges, ports, and associated sets and hash tables, enabling applications such as network topology analysis, configuration management, and protocol simulation. Key capabilities include traversal, element removal, neighbor discovery, and label conversion for dynamic network modeling tasks.",
      "description_length": 553,
      "index": 391,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.Network.NETWORK",
      "library": "frenetic.kernel",
      "description": "This module implements network topology analysis and path computation for software-defined networking. It provides a spanning tree construction function that aggregates values across connected vertices, along with traversal utilities for path discovery. The module works with vertex-based network topologies and structured path representations, enabling use cases like network reachability analysis and SDN controller logic.",
      "description_length": 424,
      "index": 392,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x04.QueueStats",
      "library": "frenetic.kernel",
      "description": "This module handles parsing, marshaling, and pretty-printing of OpenFlow 1.3.4 queue statistics structures. It operates on the `t` type representing queue statistics, including fields like queue ID, port number, and transmitted byte/packet counts. Use this module when implementing or interacting with OpenFlow switch queue monitoring and reporting functionality.",
      "description_length": 363,
      "index": 393,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.Network.MAKE",
      "library": "frenetic.kernel",
      "description": "This module builds and manipulates network topologies using user-defined vertex and edge types. It provides functions for constructing spanning trees from a given vertex and traversing network structures, along with parsing and pretty-printing capabilities for network data. Concrete use cases include modeling and analyzing software-defined network layouts, path computation, and network transformation tasks.",
      "description_length": 410,
      "index": 394,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x01.Action",
      "library": "frenetic.kernel",
      "description": "This module provides functions to manipulate sequences of OpenFlow 1.0 actions, including reordering actions that send packets to the controller to the end of the list to work around a switch bug. It supports serialization, parsing, and string representation of individual actions and action lists. These operations are used when constructing or modifying OpenFlow messages to ensure correct switch behavior and facilitate debugging or logging.",
      "description_length": 444,
      "index": 395,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.Network.NETWORK-Topology-Vertex",
      "library": "frenetic.kernel",
      "description": "This module defines a type `t` representing vertices in a network topology. It provides functions to serialize and deserialize vertex values to and from S-expressions, compare vertices, convert them to string formats suitable for DOT and Mininet representations, and parse vertex data from DOT and GML AST structures. It is used to model and manipulate individual nodes in network topologies, particularly when interfacing with graph visualization or network simulation tools.",
      "description_length": 476,
      "index": 396,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.Network.Node",
      "library": "frenetic.kernel",
      "description": "This module defines a type `t` representing network nodes with attributes such as name, ID, device type (switch, host, middlebox), MAC address, and IP address. It provides functions to create and access node properties, along with serialization to and from S-expressions, DOT, and GML formats. Use cases include modeling network topologies, configuring virtual networks in Mininet, and parsing graph descriptions from external formats.",
      "description_length": 435,
      "index": 397,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x04.MultipartReply",
      "library": "frenetic.kernel",
      "description": "This module defines the structure and operations for handling OpenFlow 1.3.4 multipart reply messages. It provides functions to calculate the size of a reply, convert it to a string, and serialize or deserialize it using Cstruct buffers. It directly works with the `multipartReply` type and is used for processing switch responses in network control plane implementations.",
      "description_length": 372,
      "index": 398,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x04.Bucket",
      "library": "frenetic.kernel",
      "description": "This module defines operations for working with OpenFlow bucket structures used in group tables. It provides functions to calculate the size of a bucket, convert it to a string representation, and serialize or deserialize buckets to and from network buffers. These operations are essential for implementing and managing group-based flow processing in software-defined networking.",
      "description_length": 379,
      "index": 399,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.Network.Link",
      "library": "frenetic.kernel",
      "description": "This module represents network links with attributes like cost, capacity, and weight. It provides functions to create links, modify their weight, and serialize or parse them using formats like S-expressions, DOT, and GML. Use cases include modeling network topologies and managing link properties in routing algorithms.",
      "description_length": 319,
      "index": 400,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x01.Wildcards",
      "library": "frenetic.kernel",
      "description": "This module handles bitmask representations of OpenFlow 1.0 wildcard fields. It provides functions to convert wildcard values to strings, marshal them to 32-bit integers, and parse them from integers. Use this module when encoding or decoding OpenFlow 1.0 flow entries to manage which packet fields are masked in matching.",
      "description_length": 322,
      "index": 401,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x04.FlowMod",
      "library": "frenetic.kernel",
      "description": "This module defines operations for working with OpenFlow 1.3.4 flow modification messages. It provides functions to calculate the size of a flow modification message, serialize it to a buffer, parse it from a buffer, and convert it to a human-readable string. These operations are used when constructing, transmitting, and inspecting flow table updates in software-defined networking applications.",
      "description_length": 397,
      "index": 402,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow.Pattern",
      "library": "frenetic.kernel",
      "description": "This module represents packet match patterns in OpenFlow, defining how to specify and compare packet fields such as source and destination MAC addresses, IP ranges, port numbers, and VLAN tags. It supports operations to check pattern inclusion (`less_eq`), equivalence (`eq`), and combining patterns (`join`), along with utilities for parsing and formatting. The IP pattern submodule extends this functionality by handling IP address patterns with subnet masks as tuples of `Frenetic_kernel.Packet.nwAddr` and `int32`, supporting match, union, and intersection operations. Together, they enable precise packet filtering, merging of routing policies, and compatibility checks between flow entries in software-defined networking.",
      "description_length": 727,
      "index": 403,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_kernel.Packet.Igmp",
      "library": "frenetic.kernel",
      "description": "This module represents and manipulates IGMP (Internet Group Management Protocol) frames within network packets. It defines types for IGMP versions 1, 2, and 3, along with unparsable data, and provides serialization and deserialization functions for these structures. It is used to inspect or construct IGMP messages carried in packet payloads, such as those handled during multicast group management in network switches or routers.",
      "description_length": 431,
      "index": 404,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.Network.NETWORK-Topology-Edge",
      "library": "frenetic.kernel",
      "description": "This module defines and manipulates edge representations in a network topology. It supports parsing edges from DOT and GML formats, converting edges to string and DOT representations, and comparing edge values. It is used for handling network edge data in configurations and visualizations.",
      "description_length": 290,
      "index": 405,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_kernel.Network.NETWORK-Topology-UnitWeight",
      "library": "frenetic.kernel",
      "description": "This module represents a network topology with unit-weighted edges. It provides functions to convert edge weights to and from S-expressions, compare weights, add weights, and retrieve the weight value from an edge. The primary data types are `t` for weights (integers) and `edge` for network edges, supporting concrete operations like parsing, serialization, and arithmetic on edge weights.",
      "description_length": 390,
      "index": 406,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x01.SwitchConfig",
      "library": "frenetic.kernel",
      "description": "This module represents the configuration of an OpenFlow 1.0 switch, specifically handling packet fragmentation behavior and the maximum number of bytes sent per packet miss. It includes the `FragFlags` submodule, which defines modes for handling fragments\u2014such as normal processing, dropping, or reassembling\u2014and supports conversion to and from S-expressions and strings. The module provides direct operations to set fragmentation policies and max bytes, enabling precise control over packet handling and facilitating serialization for communication or logging. For example, you can configure a switch to drop all fragments and limit packet miss transmissions to 128 bytes, then serialize the configuration for transmission to a switch.",
      "description_length": 736,
      "index": 407,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_kernel.Packet.Arp",
      "library": "frenetic.kernel",
      "description": "This module defines the structure and serialization of ARP packets, supporting construction of ARP queries and replies with source and target MAC and IP addresses. It works with `dlAddr` (MAC) and `nwAddr` (IP) types to represent network endpoints in ARP payloads. Use this module to encode and decode ARP messages for network discovery or simulation tasks.",
      "description_length": 357,
      "index": 408,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x01.Timeout",
      "library": "frenetic.kernel",
      "description": "This module provides conversions between timeout values and integers or strings. It supports the `timeout` data type, which represents OpenFlow 1.0 timeout values. Use this module to serialize timeouts for logging or network transmission, or to parse integer representations into typed timeout values.",
      "description_length": 301,
      "index": 409,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x04.Oxm",
      "library": "frenetic.kernel",
      "description": "This module encodes and decodes OpenFlow 1.3.4 match fields (OXM) for flow table entries. It supports parsing, marshaling, and string representation of OXM structures, including operations to extract field names, compute sizes, and convert from OpenFlow patterns. Concrete use cases include constructing and inspecting flow match conditions for network switches using the OpenFlow protocol.",
      "description_length": 390,
      "index": 410,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.Packet.Tcp",
      "library": "frenetic.kernel",
      "description": "This module represents TCP frames and provides access to header fields including source and destination ports, sequence and acknowledgment numbers, flags, window size, and checksum. It operates on `t` records with a `Cstruct.t` payload, enabling inspection and manipulation of TCP packet data. The included flags module handles the 9 boolean control flags, supporting operations like flag inspection and modification during packet processing. Use cases include parsing TCP packets for network monitoring, constructing custom responses in software-defined networking, and extracting flow data for traffic analysis.",
      "description_length": 613,
      "index": 411,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x04.AggregateStats",
      "library": "frenetic.kernel",
      "description": "This module handles aggregate flow statistics in OpenFlow 1.3.4, providing operations to calculate the size of a statistics structure, convert it to a human-readable string, and serialize or deserialize it using Cstruct. It works directly with the `aggregStats` type, which represents aggregated flow statistics data. Concrete use cases include processing and transmitting flow statistics in network monitoring and SDN controller applications.",
      "description_length": 443,
      "index": 412,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow.From0x01",
      "library": "frenetic.kernel",
      "description": "This module translates OpenFlow 1.0 messages, actions, and statistics into a unified OpenFlow interface. It converts low-level 1.0 structures such as actions, switch features, port stats, and flow stats into their generalized counterparts for internal use. These translations enable higher-level constructs like group tables and efficient parallel actions to be built on top, supporting features such as fast failover and logical packet duplication without requiring direct 1.0 support.",
      "description_length": 486,
      "index": 413,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x01.FlowRemoved",
      "library": "frenetic.kernel",
      "description": "This module processes OpenFlow 1.0 flow removed messages, handling serialization, parsing, and string representation of flow removal events. It centers on the `flowRemoved` type, which captures metadata like reason, cookie, priority, and duration, enabling applications to track flow expiration and state changes. The flow removal reason submodule supports conversions between reason codes, strings, and 16-bit integers, facilitating precise handling of removal causes such as idle timeout or port deletion. Example uses include decoding a network byte stream into a `flowRemoved` value, setting a removal reason from a string, or logging flow expiration details using string representations.",
      "description_length": 692,
      "index": 414,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x04.GroupMod",
      "library": "frenetic.kernel",
      "description": "This module defines operations for handling OpenFlow 1.3.4 Group Modify messages, including parsing, marshaling, and string representation. It works with the `groupMod` type, which represents group table modification commands. Concrete use cases include constructing and deconstructing OpenFlow messages to manage switch group tables, such as adding, modifying, or deleting groups.",
      "description_length": 381,
      "index": 415,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x04.Message",
      "library": "frenetic.kernel",
      "description": "This module defines the message types used to communicate with OpenFlow 1.3 switches, including control messages like `FeaturesRequest`, `FlowModMsg`, and `PacketInMsg`. It provides functions to serialize and deserialize messages to and from byte strings, compute their size, and pretty-print them. Use cases include constructing and parsing OpenFlow control messages for switch configuration, flow management, and packet processing.",
      "description_length": 433,
      "index": 416,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.Net.Link",
      "library": "frenetic.kernel",
      "description": "This module defines a data type `t` representing network links and provides functions to serialize and deserialize link data in various formats, including S-expressions, DOT, and GML. It includes operations for comparing links, converting them to string representations, and parsing link attributes from graph description formats. Concrete use cases include reading and writing network topologies in different graph formats and managing link attributes in network configuration tools.",
      "description_length": 484,
      "index": 417,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_kernel.Packet.Dns",
      "library": "frenetic.kernel",
      "description": "This module provides DNS packet structures and serialization routines for working with DNS queries and resource records in network applications. It defines core types like `Qd` for DNS questions and `Rr` for resource records, along with operations to convert DNS packets to binary format for transmission over UDP or TCP. The `Qd` submodule handles DNS query sections with name, type, and class fields, supporting S-expression conversion for parsing and generation. The `Rr` submodule manages resource records with TTL and raw data fields, enabling manipulation of DNS response payloads in custom network tools.",
      "description_length": 611,
      "index": 418,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.Network.NETWORK-Traverse",
      "library": "frenetic.kernel",
      "description": "Performs breadth-first and depth-first traversals of a network topology. Applies a visitor function to each vertex during traversal. Useful for analyzing connectivity or propagating state across a network graph.",
      "description_length": 211,
      "index": 419,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.Network.MAKE-UnitPath",
      "library": "frenetic.kernel",
      "description": "This module computes shortest paths in a network topology using edge-weighted graphs. It provides functions to find the shortest path between two vertices, all shortest paths from a source vertex, and all pairs of shortest paths that satisfy a given predicate. The primary data structures are lists of edges representing paths, with weights calculated as integers.",
      "description_length": 364,
      "index": 420,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x01.FlowMod",
      "library": "frenetic.kernel",
      "description": "This module provides core operations for working with OpenFlow 1.0 flow modification messages, including construction, serialization, and size calculation. It supports conversions to and from strings, sexps, and binary formats using Cstruct, enabling efficient network transmission and parsing of flow table updates. The command submodule handles encoding and decoding of flow modification commands to 16-bit integers and strings, facilitating precise control over flow entry actions. Use this module to assemble flow updates for switches or parse incoming modification requests.",
      "description_length": 579,
      "index": 421,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.Packet.Igmp3",
      "library": "frenetic.kernel",
      "description": "This module handles IGMP v3 messages, focusing on group record management and checksum handling. It provides serialization and deserialization of IGMP v3 message types to and from S-expressions, enabling parsing and construction of IGMP v3 packets for network communication. The core type `t` represents group records with their type, multicast group address, and source address list. These records are used to manage multicast group membership during network packet processing.",
      "description_length": 478,
      "index": 422,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_kernel.Network.Make",
      "library": "frenetic.kernel",
      "description": "This module enables network graph construction and analysis with customizable vertex and edge types, supporting operations such as spanning tree generation, traversal, and data parsing/pretty-printing. It provides core functionality for network protocol modeling, SDN path computation, and reachability analysis, with concrete data types like `Topology.t` for representing networks and functions to manipulate and query graph structures. Submodules extend this foundation with shortest-path algorithms over integer or generic weights, traversal strategies like BFS and DFS, and input/output capabilities including DOT and Mininet export. Examples include computing all shortest paths from a source vertex, visualizing network topologies via `to_dot`, and loading predefined graphs from GML or DOT files for simulation.",
      "description_length": 818,
      "index": 423,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow.To0x01",
      "library": "frenetic.kernel",
      "description": "This module translates OpenFlow 1.3 actions, patterns, flows, and events into their OpenFlow 1.0 equivalents. It handles conversions for data types such as `pattern`, `action`, `flow`, `switchFeatures`, `payload`, `packetInReason`, `pktOut`, and `event`. These translations enable Frenetic programs written using OpenFlow 1.3 semantics to operate on switches that only support OpenFlow 1.0.",
      "description_length": 390,
      "index": 424,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x04.GroupDesc",
      "library": "frenetic.kernel",
      "description": "This module defines the structure and operations for handling OpenFlow 1.3.4 group descriptions. It provides functions to calculate the size of a group description, convert it to a string, and serialize or deserialize it using Cstruct buffers. It is used when managing switch group tables, such as encoding or decoding group entries during control plane communication.",
      "description_length": 368,
      "index": 425,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x04.SwitchFeatures",
      "library": "frenetic.kernel",
      "description": "This module handles the parsing, marshaling, and string representation of OpenFlow 1.3.4 switch feature data structures. It operates on the `switchFeatures` type, which captures capabilities and configuration of an OpenFlow switch, such as supported actions and buffer sizes. Use this module when implementing control plane logic that needs to interpret or construct switch feature responses, such as initializing switch connections or validating feature negotiation.",
      "description_length": 467,
      "index": 426,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x04.MeterConfig",
      "library": "frenetic.kernel",
      "description": "This module defines operations for handling OpenFlow 1.3.4 meter configurations, including parsing from and marshaling to Cstruct buffers. It provides the size of a meter configuration, pretty-prints configurations as strings, and serializes or deserializes them for network transmission or storage. Use cases include managing per-flow traffic metering settings in software-defined networking applications.",
      "description_length": 406,
      "index": 427,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x01.Match",
      "library": "frenetic.kernel",
      "description": "This module handles pattern matching in OpenFlow 1.0 by providing functions to convert patterns to strings, serialize and deserialize them, and calculate their size. It operates on `Frenetic_kernel.OpenFlow0x01.pattern` values, which represent packet match conditions. Use cases include processing and transmitting flow table entries in software-defined networking applications.",
      "description_length": 378,
      "index": 428,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.Packet.Icmp",
      "library": "frenetic.kernel",
      "description": "This module defines the structure and serialization of ICMP packets, including fields for type, code, checksum, and payload. It operates on `Cstruct.t` buffers for efficient packet manipulation and parsing. Concrete use cases include handling ICMP echo requests/responses (ping) and error messages like destination unreachable.",
      "description_length": 327,
      "index": 429,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.Network.MAKE-Pretty",
      "library": "frenetic.kernel",
      "description": "This module provides functions to convert network topologies into string representations. It supports generating human-readable output, DOT format for visualization, and Mininet scripts for network simulation. It operates on `Topology.t` structures, enabling concrete use cases like debugging network layouts, generating documentation, or automating test environments.",
      "description_length": 368,
      "index": 430,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x04.Action",
      "library": "frenetic.kernel",
      "description": "This module defines and manipulates OpenFlow 1.3.4 action structures, including serialization, deserialization, and conversion from generic OpenFlow actions. It operates on `action` and `actionSequence` types, providing precise parsing and string representation. Concrete use cases include constructing and interpreting packet-forwarding instructions in software-defined networking applications.",
      "description_length": 395,
      "index": 431,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x04.MeterStats",
      "library": "frenetic.kernel",
      "description": "This module handles Meter Statistics structures as defined in the OpenFlow 1.3.4 specification. It provides operations to calculate the size of a MeterStats value, convert it to a string for debugging, and serialize/deserialize it to and from a Cstruct buffer. These functions are used when managing OpenFlow meter statistics in network control applications.",
      "description_length": 358,
      "index": 432,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.Net.Net",
      "library": "frenetic.kernel",
      "description": "This module orchestrates network topology construction, analysis, and transformation through a suite of interwoven submodules. It supports core operations like spanning tree computation, shortest path determination, and traversal strategies over graph-like structures composed of vertices and edges, enabling tasks such as routing optimization and connectivity analysis. Submodules handle topology parsing from DOT and GML files, shortest path calculation under various weight models, and serialization to formats like DOT and Mininet scripts. Direct APIs allow functional manipulation of graph components, while integrated traversal and pathfinding algorithms facilitate network exploration and transformation in software-defined networking contexts.",
      "description_length": 751,
      "index": 433,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.Network.NETWORK-Pretty",
      "library": "frenetic.kernel",
      "description": "This module provides functions to convert network topologies into string representations. It supports generating human-readable text, Graphviz DOT format, and Mininet scripts for network simulation. The module works directly with `Topology.t` data structures to facilitate visualization and testing of network configurations.",
      "description_length": 325,
      "index": 434,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_kernel.Network.MAKE-Topology-UnitWeight",
      "library": "frenetic.kernel",
      "description": "This module represents a unit-weighted network topology where edges have uniform weight. It provides functions to serialize and deserialize edge and weight values, compare weights, and perform weight addition. The module is used to model network graphs where all edges are treated with equal weight, simplifying path calculations and topological analysis.",
      "description_length": 355,
      "index": 435,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x01.PseudoPort",
      "library": "frenetic.kernel",
      "description": "This module handles pseudo-port values in OpenFlow 1.0, providing conversion to strings and integers, and constructing pseudo-ports from integers. It operates on the `pseudoPort` type representing OpenFlow pseudo-port identifiers. Use this module when encoding or decoding OpenFlow messages that reference pseudo-ports, such as packet-in or flow-mod commands.",
      "description_length": 359,
      "index": 436,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x04.MeterBand",
      "library": "frenetic.kernel",
      "description": "This module defines operations for working with OpenFlow 1.3.4 meter bands, including serialization, deserialization, and string representation. It handles the `meterBand` type, which represents bandwidth or rate-limiting configurations in software-defined networking. Use this module to configure, transmit, or inspect metering rules applied to network traffic flows.",
      "description_length": 368,
      "index": 437,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x04.Instructions",
      "library": "frenetic.kernel",
      "description": "This module handles OpenFlow 1.3 instructions, providing operations to serialize, deserialize, and convert instruction lists. It works with `instruction list` types and supports parsing from and marshaling to Cstruct buffers. Concrete use cases include processing flow modification messages and converting group actions into instruction sequences for switch configuration.",
      "description_length": 372,
      "index": 438,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.Network.EDGE",
      "library": "frenetic.kernel",
      "description": "This module defines a data type `t` representing edges in a network graph, along with functions to convert edges to and from string, S-expression, DOT, and GML formats. It provides comparison, serialization, and parsing operations tailored for network modeling tasks such as reading and writing graph files or generating visualizations. Concrete use cases include constructing and manipulating network topologies from configuration files or external representations.",
      "description_length": 466,
      "index": 439,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x04.QueueRequest",
      "library": "frenetic.kernel",
      "description": "This module defines operations for handling OpenFlow 1.3.4 queue statistics requests. It provides functions to serialize (`marshal`), deserialize (`parse`), compute the size (`sizeof`), and convert to a string representation (`to_string`) of queue request structures. These operations directly work with the `queueRequest` type and `Cstruct.t` buffers, enabling efficient processing of OpenFlow queue statistics messages in network monitoring and control applications.",
      "description_length": 468,
      "index": 440,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_kernel.Packet.Ip",
      "library": "frenetic.kernel",
      "description": "This module represents IPv4 packet headers, enabling the construction and manipulation of packets for transport protocols such as TCP, UDP, and ICMP. It provides data types like `t` for full IPv4 headers and `tp` for transport protocol variants, along with operations to set or retrieve fields such as source and destination addresses, TTL, and checksum. The flag submodule handles fragmentation flags (`df`, `mf`) with utilities for serialization and parsing, supporting tasks like modifying packet fragmentation behavior. Use cases include crafting custom IP packets, analyzing network traffic, and implementing tunneling or routing logic in software-defined networks.",
      "description_length": 670,
      "index": 441,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x01.StatsReply",
      "library": "frenetic.kernel",
      "description": "This module handles OpenFlow 1.0 statistics replies, providing functions to parse and serialize these messages from and to Cstruct buffers. It defines the type `t` for representing statistics replies and includes converters to and from S-expressions for debugging or logging. Use this module when processing switch statistics responses in network control applications.",
      "description_length": 368,
      "index": 442,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x04.OfpMatch",
      "library": "frenetic.kernel",
      "description": "This module defines operations for handling OpenFlow 1.3.4 flow match structures. It provides functions to calculate the size of a match structure, serialize it to a buffer, parse it from a buffer, and convert it to a human-readable string. These operations are used when constructing or interpreting flow entries in an OpenFlow switch.",
      "description_length": 336,
      "index": 443,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x04.SwitchDescriptionReply",
      "library": "frenetic.kernel",
      "description": "This module handles the serialization, parsing, and string representation of OpenFlow switch description replies. It works with the `switchDesc` type, which captures metadata about an OpenFlow switch, such as its manufacturer, hardware, and software versions. Use this module when interacting with OpenFlow 1.3.4 control messages to retrieve or construct switch identity information.",
      "description_length": 383,
      "index": 444,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_kernel.Packet.Udp",
      "library": "frenetic.kernel",
      "description": "This module defines the structure of a UDP packet, including source and destination ports, a checksum, and a payload. It provides functions to serialize and deserialize UDP packet data using S-expressions. Concrete use cases include parsing incoming UDP packets and constructing UDP payloads for transmission in network applications.",
      "description_length": 333,
      "index": 445,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x04.TableMod",
      "library": "frenetic.kernel",
      "description": "This module defines operations for constructing, serializing, and parsing OpenFlow 1.3.4 Table Modify messages. It works with the `t` type representing a table modification, alongside buffer manipulation using `Cstruct.t`. It is used to configure switch table properties such as maximum entries, eviction policies, and table identifiers during control plane communication.",
      "description_length": 372,
      "index": 446,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.Packet.Igmp1and2",
      "library": "frenetic.kernel",
      "description": "This module defines the structure and serialization functions for IGMP v1 and v2 messages. It works with the `t` record containing maximum response time, checksum, and network address data types. It supports parsing and generating IGMP message representations for network packet processing tasks.",
      "description_length": 296,
      "index": 447,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x01.SwitchFeatures",
      "library": "frenetic.kernel",
      "description": "This module provides data structures and serialization functions for representing OpenFlow 1.0 switch features, including wildcards, capabilities, and actions. It supports parsing and serializing switch feature responses using types like `supported_wildcards`, `t`, and lists of `portDescription`, enabling precise control plane interactions. The capabilities submodule handles switch feature queries with support for statistics and protocol features, while the actions submodule tracks supported operations like packet output and VLAN modification. Together, they allow applications to inspect and configure switch behavior during network setup and policy enforcement.",
      "description_length": 669,
      "index": 448,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.Topology.Net",
      "library": "frenetic.kernel",
      "description": "This module models network topologies as graph structures, enabling operations like path computation, traversal, and topology transformation using vertices, edges, and ports. It supports building spanning trees with custom fold functions, parsing network descriptions from DOT and GML files, and generating string representations for visualization or simulation. Submodules handle shortest path computation with customizable or integer weights, breadth-first and depth-first traversal, and serialization to formats like DOT and Mininet. Examples include validating network configurations, optimizing routing paths, and simulating network layouts using external tools.",
      "description_length": 667,
      "index": 449,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.Hashcons.Make",
      "library": "frenetic.kernel",
      "description": "This module implements hash-consing for a given value type, ensuring that equal values share the same physical representation. It provides operations to retrieve a unique integer identifier for a value, recover the original value from its identifier, and clear identifiers corresponding to a set of integers. It is useful in scenarios like optimizing memory usage in symbolic computation or ensuring efficient equality checks in compilers.",
      "description_length": 439,
      "index": 450,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.Network.MAKE-module-type-PATH",
      "library": "frenetic.kernel",
      "description": "This module computes shortest paths in a network topology using edge-weighted graphs. It provides functions to find the shortest path between two vertices, all shortest paths from a source vertex, and all pairs of shortest paths in the graph. These operations are useful for network routing and traffic optimization scenarios where paths must be dynamically calculated based on vertex and edge relationships.",
      "description_length": 408,
      "index": 451,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x01.PacketOut",
      "library": "frenetic.kernel",
      "description": "Converts an OpenFlow 1.0 packet-out message into a string representation. Works with the `packetOut` type defined in the OpenFlow 1.0 module. Useful for logging or debugging packet-out messages in network applications.",
      "description_length": 218,
      "index": 452,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x04.PortConfig",
      "library": "frenetic.kernel",
      "description": "This module defines bit flags for port configuration in OpenFlow 1.3.4, corresponding directly to the `ofp_port_config` enumeration. It provides functions to convert these flags to and from 32-bit integers, enabling low-level manipulation and interpretation of port settings. Use this module when configuring or inspecting switch port behavior, such as disabling a port or enabling packet reception.",
      "description_length": 399,
      "index": 453,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.Network.WEIGHT",
      "library": "frenetic.kernel",
      "description": "This module defines a weighted graph edge structure with a numeric weight type that supports comparison and addition. It provides functions to access edge weights, combine weights using addition, and serialize or deserialize both weights and edges. Concrete use cases include modeling network graphs with weighted edges and implementing shortest path algorithms like Dijkstra's.",
      "description_length": 378,
      "index": 454,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x04.QueueConfReq",
      "library": "frenetic.kernel",
      "description": "This module defines operations for handling OpenFlow 1.3.4 Queue Configuration request messages. It provides functions to parse and serialize these messages to and from Cstruct buffers, along with computing their size and converting them to human-readable strings. It directly works with the `t` type representing Queue Configuration requests, used when interacting with network switches via the OpenFlow protocol.",
      "description_length": 414,
      "index": 455,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.Network.NETWORK-Parse",
      "library": "frenetic.kernel",
      "description": "Converts network topologies from file formats into a structured representation. It parses DOT and GML files into a `Topology.t` value, which models network graphs with nodes and edges. This is useful for loading network configurations from disk for analysis or simulation.",
      "description_length": 272,
      "index": 456,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x04.GroupFeatures",
      "library": "frenetic.kernel",
      "description": "This module handles parsing, marshaling, and string representation of OpenFlow 1.3.4 group features structures, which describe the capabilities of a switch's group table. It operates directly on the `groupFeatures` type, which encapsulates properties like supported group types and maximum group counts. Concrete use cases include serializing group features for network transmission, deserializing received data, and logging or debugging group table capabilities.",
      "description_length": 463,
      "index": 457,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x01.StatsRequest",
      "library": "frenetic.kernel",
      "description": "This module defines operations for handling OpenFlow 1.0 statistics requests, including serialization and conversion to strings. It works with the `request` type representing OpenFlow messages. Concrete use cases include parsing incoming OpenFlow statistics requests from switches and generating string representations for logging or debugging.",
      "description_length": 344,
      "index": 458,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x04.GroupType",
      "library": "frenetic.kernel",
      "description": "This module defines the group types supported in OpenFlow 1.3.4, corresponding directly to the `ofp_group_type` enumeration. It provides operations to convert group type values to human-readable strings, marshal them to integers, and parse integers back into group type values. These functions are used when handling group table operations in OpenFlow switches, such as specifying whether a group is a select, indirect, or fast-failover type.",
      "description_length": 442,
      "index": 459,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.Network.Net",
      "library": "frenetic.kernel",
      "description": "This module provides network topology analysis and path computation, enabling the construction of spanning trees, graph traversal, and path manipulation using graph structures defined in the Topology module. It supports shortest path computation with weighted edges, customizable path filtering, and traversal algorithms like breadth-first and depth-first search, operating on vertices and edges to enable network routing analysis and connectivity exploration. Submodules handle input parsing from formats like DOT and GML, topology serialization, string-based visualization, and script generation for Mininet environments. Examples include loading network layouts from files, computing optimal routes between nodes, transforming topologies into Graphviz diagrams, and dynamically updating network graphs with vertex and edge operations.",
      "description_length": 837,
      "index": 460,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x04.PacketIn",
      "library": "frenetic.kernel",
      "description": "This module defines operations for handling OpenFlow 1.3.4 PacketIn messages, including parsing from and marshaling to Cstruct buffers. It provides the size of a PacketIn message, converts it to a human-readable string, and supports direct manipulation of packet data structures. Concrete use cases include processing incoming packets in a software-defined networking controller and constructing PacketIn responses for switch interaction.",
      "description_length": 438,
      "index": 461,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x04.QueueDesc",
      "library": "frenetic.kernel",
      "description": "This module handles OpenFlow queue descriptions and their associated properties, providing a complete interface for parsing, serializing, and manipulating queue configurations in network switches. It defines the `queueDesc` type for representing queue structures, along with operations to compute their size, convert to strings, and serialize to or from binary data using `Cstruct.t`. The child module extends this functionality to individual queue properties through the `queueProp` type, enabling fine-grained control over queue behavior settings. Together, they support tasks such as transmitting queue state between switches and controllers or persisting queue configurations in storage.",
      "description_length": 691,
      "index": 462,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_kernel.Network.NetPath",
      "library": "frenetic.kernel",
      "description": "This module computes shortest paths and collections of shortest paths in a network topology. It operates on edge-weighted graphs represented as lists of edges, vertices, and a hash table mapping vertices to values. Concrete use cases include finding the most efficient route between two nodes, enumerating all shortest paths from a source to a destination, and calculating all-pairs shortest paths for network analysis tasks like traffic optimization or fault tolerance planning.",
      "description_length": 479,
      "index": 463,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.Network.NETWORK-Path",
      "library": "frenetic.kernel",
      "description": "This module computes shortest paths in a network topology using edge-weighted graphs. It provides functions to find the shortest path between two vertices, all shortest paths from a source vertex, and all pairs of shortest paths that satisfy a given predicate. The module works with topologies composed of vertices and edges, where edge weights are defined by the `Weight` parameter module. Concrete use cases include network routing analysis and optimizing paths in graph-based simulations.",
      "description_length": 491,
      "index": 464,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.Network.NETWORK-UnitPath",
      "library": "frenetic.kernel",
      "description": "This module computes shortest paths and related information over a network topology. It works with vertices and edges defined in the `Topology` module, returning paths as lists of edges. It supports finding a single shortest path, all shortest paths from a source, and all pairs of shortest paths with a filtering function.",
      "description_length": 323,
      "index": 465,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x04.PortDesc",
      "library": "frenetic.kernel",
      "description": "This module defines operations for handling OpenFlow 1.3.4 port description structures, including parsing, marshaling, and string representation. It works directly with the `portDesc` type and Cstruct buffers for binary encoding and decoding. Use cases include processing switch port information during control plane communication and serializing port state for transmission or logging.",
      "description_length": 386,
      "index": 466,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x04.TableFeatureProp",
      "library": "frenetic.kernel",
      "description": "This module handles the serialization, parsing, and string representation of OpenFlow 1.3.4 table feature properties. It operates on the `TableFeatureProp.t` type, which represents the structure of table feature properties as defined in the specification. Use this module when working with OpenFlow control messages that require encoding or decoding table capabilities, such as when configuring switch table behavior or retrieving feature support information.",
      "description_length": 459,
      "index": 467,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x01.Vendor",
      "library": "frenetic.kernel",
      "description": "This module handles OpenFlow VENDOR messages by parsing and marshaling raw binary data into structured values. It operates on a tuple type consisting of an `int32` vendor ID and a `Cstruct.t` payload, supporting direct interaction with custom or extended OpenFlow commands. It is used to implement vendor-specific extensions in network control applications.",
      "description_length": 357,
      "index": 468,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x04.PortFeatures",
      "library": "frenetic.kernel",
      "description": "This module defines bitflag representations for OpenFlow 1.3.4 port features, such as 10 Mb/s, 100 Mb/s, and full-duplex capabilities. It provides functions to marshal these features to a 32-bit integer, parse them from an integer, and convert them to a human-readable string. These operations directly correspond to the `ofp_port_features` enumeration in the OpenFlow 1.3.4 specification, enabling precise handling of switch port capabilities in network control logic.",
      "description_length": 469,
      "index": 469,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_kernel.Hashcons",
      "library": "frenetic.kernel",
      "description": "This module enables hash-consing to optimize memory and equality checks for immutable data by assigning unique integer identifiers to values. It supports creating interned representations where equivalent values share the same physical identity, with operations to map values to keys (`get`), retrieve values from keys (`unget`), and remove entries by key set (`clear`). It is ideal for managing symbols, expressions, or abstract syntax trees in symbolic computation or compiler intermediate representations. Submodules handle the internal management of hash-consed values and provide utilities for identifier-based access and cleanup.",
      "description_length": 635,
      "index": 470,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow",
      "library": "frenetic.kernel",
      "description": "This module bridges OpenFlow 1.0 and 1.3 by translating high-level network actions into version-specific wire formats, managing flow and group tables, and optimizing packet processing logic. It supports identifiers like switches and ports, actions such as output, modification, and failover, and flow entries with match patterns and statistics, using S-expressions for serialization. The match patterns module enables precise packet filtering through field comparisons and set operations, while the translation modules convert between OpenFlow versions, allowing Frenetic programs to use 1.3 features on 1.0 switches or vice versa. Examples include optimizing parallel actions via group tables in 1.3 or controller round-trips in 1.0, and implementing failover using fast-failover groups or switch-to-controller handoffs.",
      "description_length": 821,
      "index": 471,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.Topology",
      "library": "frenetic.kernel",
      "description": "This module models and manipulates network topologies for software-defined networking, offering operations to retrieve switch identifiers, check switch connectivity, and list network edges. It supports direct construction of topologies from symbolic forms such as chains or trees and represents networks as graphs for path computation, traversal, and transformation. Submodules enable importing topologies from DOT and GML files, generating visualizations, and computing shortest paths with customizable metrics. Example uses include simulating SDN test networks, validating connectivity, and optimizing routing with custom weight functions.",
      "description_length": 641,
      "index": 472,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.Util",
      "library": "frenetic.kernel",
      "description": "This module includes functions for string formatting with custom formatters, mapping over tuple lists, and generating or displaying DOT graphs. It works with strings, lists of tuples, and DOT graph representations. These functions are used to format values into strings, transform tuple lists, and visualize graphs using external tools.",
      "description_length": 336,
      "index": 473,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.Bits",
      "library": "frenetic.kernel",
      "description": "This module provides precise bit and byte manipulation operations for 32-bit and 64-bit integers, including setting, clearing, testing individual bits, and extracting specific bytes. It works directly with `int32` and `int64` types, allowing efficient bit-level operations without conversion to abstract types. Concrete use cases include low-level network protocol parsing, bitmask handling, and hardware register manipulation.",
      "description_length": 427,
      "index": 474,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_kernel.Packet",
      "library": "frenetic.kernel",
      "description": "This module enables low-level packet construction, parsing, and manipulation with a focus on type-safe binary data handling. It provides structured representations of Ethernet, VLAN, IP, TCP, UDP, ICMP, and IGMP headers, along with serialization and field-accessor functions for tasks like crafting custom payloads, modifying packet metadata, and converting between wire and high-level formats. Submodules support specific protocols: IGMP handles group membership messages, ARP encodes network discovery packets, TCP exposes header fields and flags for flow control, DNS manages queries and resource records, and IPv4 provides header manipulation with fragmentation control. Examples include building IGMPv3 group records, parsing ICMP echo requests, serializing UDP packets for transmission, and constructing ARP replies with specified MAC/IP pairs.",
      "description_length": 850,
      "index": 475,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow_Header",
      "library": "frenetic.kernel",
      "description": "This module defines the fixed OpenFlow message header structure shared across all versions, consisting of version, type code, length, and transaction ID (xid). It provides functions to parse and marshal this header from and to raw packet buffers, along with serialization to human-readable strings. Concrete use cases include extracting header metadata from incoming OpenFlow packets and constructing valid OpenFlow message headers for transmission.",
      "description_length": 449,
      "index": 476,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_kernel.Net",
      "library": "frenetic.kernel",
      "description": "This module models network elements such as switches and hosts, providing core data types and serialization functions for representing and manipulating network topologies. It includes submodules for handling node identities through S-expression conversion, managing network links with support for multiple serialization formats, and constructing and analyzing network topologies using graph algorithms. You can use it to read and write network structures from DOT or GML files, compute spanning trees or shortest paths, and serialize network data for communication or storage. Direct APIs allow manipulation of nodes and links, while submodules enable advanced operations like topology analysis and routing optimization.",
      "description_length": 720,
      "index": 477,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x04",
      "library": "frenetic.kernel",
      "description": "This module provides S-expression serialization and deserialization for OpenFlow 1.3 types, enabling structured handling of protocol messages such as Hello, PacketIn, FlowMod, and multipart replies. It supports key data types like flow entries, match fields (OXM), actions, meters, groups, ports, and statistics, with operations to convert between structured values and binary representations using `Cstruct.t`. Submodules handle specific message types and structures, such as Hello message negotiation, port and flow statistics, switch features, and error messages, allowing precise control over switch configuration, packet processing, and network monitoring. Examples include parsing incoming Hello messages, constructing flow modification commands, extracting port status updates, and serializing meter configurations for transmission.",
      "description_length": 839,
      "index": 478,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.GroupTable0x04",
      "library": "frenetic.kernel",
      "description": "This module manages a mutable group table for defining OpenFlow 1.3-style action groups, supporting operations to create, clear, and commit groups. It works with group types, action buckets, and port identifiers to define forwarding behavior such as fast failover or round-robin distribution. Concrete use cases include setting up redundant packet paths with `add_fastfail_group` and generating corresponding OpenFlow messages via `commit`.",
      "description_length": 440,
      "index": 479,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_kernel.Network",
      "library": "frenetic.kernel",
      "description": "This module models network topologies with vertices, edges, and weighted connections, supporting construction, traversal, and analysis of graph structures. It provides core types for nodes, links, paths, and graphs, along with operations to serialize, parse, and transform network data using formats like DOT, GML, and Mininet. Concrete capabilities include shortest path computation with customizable weights, spanning tree generation, and traversal algorithms like BFS and DFS, enabling tasks such as SDN routing analysis, network visualization, and simulation of virtualized topologies. Submodules extend this foundation with format-specific parsers, path enumeration, and structured graph manipulation for dynamic network modeling.",
      "description_length": 735,
      "index": 480,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel.OpenFlow0x01",
      "library": "frenetic.kernel",
      "description": "This module enables bidirectional conversion between OCaml types and S-expressions for OpenFlow 1.0 protocol components, supporting structured handling of flow entries, actions, port state, control messages, and switch features. Core operations include serialization, parsing, and size calculation for messages like flow modifications, packet outputs, and statistics requests, while submodules manage specialized types such as error codes, port descriptions, and timeout values. It can be used to construct and decode control plane messages, configure switch behavior with precise bitmask and fragmentation settings, or log and inspect flow expiration and port status events. Specific capabilities include reordering packet actions to work around switch bugs, encoding match patterns for flow entries, and handling vendor-specific extensions with raw payload parsing.",
      "description_length": 867,
      "index": 481,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_kernel",
      "library": "frenetic.kernel",
      "description": "This collection optimizes symbolic and network data handling in software-defined networking contexts. Core data types include hash-consed values for efficient equality, OpenFlow messages and actions for switch control, network topologies for SDN modeling, and low-level packet structures for protocol manipulation. Operations span bit-level integer manipulation, S-expression serialization, group table management, and graph traversal with customizable metrics. Examples include translating OpenFlow 1.3 features for 1.0 switches, computing shortest paths with dynamic weights, crafting type-safe Ethernet frames, and managing fast-failover groups with unique identifier assignment.",
      "description_length": 682,
      "index": 482,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.Fdd.Action.Seq.Tree.Provide_of_sexp",
      "library": "frenetic.netkat",
      "description": "This module provides a function `t_of_sexp` that deserializes S-expressions into FDD trees with sequence actions, using a provided conversion function for the key type. It operates on OpenFlow actions and header matches structured as FDDs, enabling direct translation of symbolic S-expression representations into executable flow tables. A concrete use case is parsing NetKAT policy specifications from external sources like configuration files or network management APIs into internal FDD representations for further compilation.",
      "description_length": 530,
      "index": 483,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.Fdd.Action.Par.Tree.Provide_of_sexp",
      "library": "frenetic.netkat",
      "description": "Converts S-expressions into FDD structures with OpenFlow actions at leaves. Works with binary decision diagrams extended to handle network packet headers and actions. Useful for parsing NetKAT policy specifications into executable flow tables.",
      "description_length": 243,
      "index": 484,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.Fdd.Action.Par.Tree.Named",
      "library": "frenetic.netkat",
      "description": "This module represents FDDs (Forwarding Decision Diagrams) with named OpenFlow actions at the leaves, used for modeling network forwarding behavior. It provides operations to check if one FDD is a subset of another and to test equality between two FDDs, both returning results wrapped in `Base.Or_error.t`. These operations are used during FDD compilation and optimization to verify correctness and equivalence of flow tables derived from NetKAT policies.",
      "description_length": 455,
      "index": 485,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.Fdd.Action.Par.Provide_bin_io",
      "library": "frenetic.netkat",
      "description": "This module implements binary serialization and deserialization for parallel action values in forwarding decision diagrams. It works with the `Frenetic_netkat.Fdd.Action.Par.t` type, representing sets of OpenFlow actions applied to network packets. Concrete use cases include persisting FDD-based flow tables to disk or transmitting them over a network.",
      "description_length": 353,
      "index": 486,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.Semantics.HeadersValues.Fields.Direct",
      "library": "frenetic.netkat",
      "description": "This module provides direct access to individual header fields within a packet's semantics, enabling precise manipulation and inspection of network packet attributes. It supports operations on concrete data types such as MAC addresses, IP addresses, VLAN tags, and switch ports, tied to specific header keys. Use cases include packet classification, header rewriting, and policy enforcement in software-defined networking applications.",
      "description_length": 435,
      "index": 487,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_netkat.Local_compiler.FDD.Tbl.Provide_of_sexp",
      "library": "frenetic.netkat",
      "description": "This module provides a function `t_of_sexp` that constructs an FDD table from an S-expression representation, using a provided conversion function for values. It operates on S-expressions and FDD tables parameterized by a key type. A concrete use case is deserializing FDD-based network policies stored in S-expression format into an in-memory FDD table for further processing or evaluation.",
      "description_length": 391,
      "index": 488,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.Fdd.Action.Seq.Tree",
      "library": "frenetic.netkat",
      "description": "This module implements ordered key-value trees for mapping OpenFlow header matches to sequences of actions, supporting insertion, deletion, lookup, and advanced transformations like folding, filtering, and merging. It maintains strict field ordering to optimize decision diagram compilation, modeling network forwarding policies for translating NetKAT programs into minimized OpenFlow tables. The `t_of_sexp` function in its child module enables parsing symbolic S-expression representations\u2014such as NetKAT policies from configuration files\u2014into executable FDD trees by applying a user-specified key conversion function. Together, the module and its submodules support both direct manipulation of structured packet header mappings and the deserialization of external policy specifications into internal representations for compilation.",
      "description_length": 835,
      "index": 489,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.Local_compiler.FDD.Tbl.Provide_bin_io",
      "library": "frenetic.netkat",
      "description": "This module implements binary serialization and deserialization for FDD-based tables indexed by a `Key` type. It provides functions to compute binary shapes, sizes, and to read/write table values, supporting efficient storage or transmission of FDD table instances. Concrete use cases include persisting FDD tables to disk or sending them over a network.",
      "description_length": 354,
      "index": 490,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_netkat.Fdd.Action.Par.Named",
      "library": "frenetic.netkat",
      "description": "This module implements operations for comparing and checking subset relationships between named OpenFlow actions in Forwarding Decision Diagrams (FDDs). It works directly with the `named` type representing structured OpenFlow actions, enabling precise validation and equivalence checking. Concrete use cases include verifying that one set of packet forwarding rules is a subset of another, or confirming that two rule sets are semantically identical.",
      "description_length": 450,
      "index": 491,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.Fdd.Action.Par.Tree",
      "library": "frenetic.netkat",
      "description": "This module manipulates ordered collections of NetKAT actions using balanced trees, supporting set operations like union and intersection, along with filtering and ordered traversal. It enables functional transformations of tree structures that model sets of parallel actions, facilitating network policy analysis and flow table optimization. The first child module parses S-expressions into FDDs with OpenFlow actions at leaves, translating NetKAT policies into executable flow tables using binary decision diagrams. The second child module represents and compares FDDs with named OpenFlow actions, providing error-aware subset and equality checks critical for verifying flow table correctness and equivalence during compilation.",
      "description_length": 730,
      "index": 492,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.Fdd.FDD.Tbl.Provide_bin_io",
      "library": "frenetic.netkat",
      "description": "This module implements binary serialization and deserialization for FDD-based flow tables keyed by a specific type. It provides functions to convert flow tables to and from binary representations, ensuring efficient storage and transmission. Use cases include persisting compiled NetKAT policies to disk or sending them over a network.",
      "description_length": 335,
      "index": 493,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.Global_compiler.FDD.BinTbl.Provide_of_sexp",
      "library": "frenetic.netkat",
      "description": "This module implements a function `t_of_sexp` that constructs an FDD binary table from S-expression data, using a provided key conversion function. It operates on S-expressions and produces values of type `Frenetic_netkat.Global_compiler.FDD.BinTbl.t`, which represents a binary decision diagram table tied to a specific key type. A concrete use case is parsing serialized FDD configurations from files or network streams into executable decision tables for packet processing pipelines.",
      "description_length": 486,
      "index": 494,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.Fdd.FDD.BinTbl.Provide_bin_io",
      "library": "frenetic.netkat",
      "description": "This module provides binary serialization and deserialization operations for FDDs with OpenFlow actions at the leaves. It works with FDD data structures parameterized over a key type, supporting efficient conversion to and from binary representations. Concrete use cases include persisting compiled flow tables to disk or transmitting them over a network.",
      "description_length": 355,
      "index": 495,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.Fdd.Action.Seq.Key",
      "library": "frenetic.netkat",
      "description": "This module defines a key type for sequences of actions in a Forwarding Decision Diagram (FDD), where keys represent either a field or a continuation. It provides functions for converting values to and from S-expressions and a comparator for ordering keys, which is essential for maintaining consistent field ordering during FDD compilation. The module is used to structure and manipulate action sequences in the transformation of NetKAT policies into efficient flow tables.",
      "description_length": 474,
      "index": 496,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_netkat.Local_compiler.FDD.BinTbl.Provide_of_sexp",
      "library": "frenetic.netkat",
      "description": "This module implements a function `t_of_sexp` that parses S-expressions into a binary table structure, using a provided key conversion function. It operates on S-expressions and constructs values of type `Frenetic_netkat.Local_compiler.FDD.BinTbl.t`, which represents a table mapping keys to FDD-based results. It is used to deserialize network policy rules stored in S-expression format into an executable decision diagram structure for packet processing.",
      "description_length": 456,
      "index": 497,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.Global_compiler.FDD.BinTbl.Provide_bin_io",
      "library": "frenetic.netkat",
      "description": "This module implements binary serialization and deserialization for FDD-based tables parameterized by a key type. It provides functions to compute the binary shape, size, and perform reading and writing operations for FDD tables. These operations enable efficient storage and transmission of FDD table instances in binary format, particularly useful in network applications and persistent storage scenarios.",
      "description_length": 407,
      "index": 498,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.Fdd.Action.Seq.Provide_hash",
      "library": "frenetic.netkat",
      "description": "This module provides a hashing function for sequences of actions in a decision diagram, specifically working with the `Frenetic_netkat.Fdd.Action.Seq.t` type. It allows folding a hash state over these sequences, enabling efficient and deterministic hashing of action sequences for use in compilation or optimization passes. A concrete use case is ensuring structural equivalence detection when generating flow tables from NetKAT programs.",
      "description_length": 438,
      "index": 499,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_netkat.Fdd.FDD.BinTbl.Provide_of_sexp",
      "library": "frenetic.netkat",
      "description": "This module defines a function `t_of_sexp` that parses S-expressions into FDD binary decision tables, using a provided function to convert S-expressions into the key type. It works with FDD structures that map OpenFlow header matches to actions, leveraging S-expression representations for serialization and deserialization. A concrete use case is loading precomputed FDD-based flow tables from configuration files or external inputs in a NetKAT compiler pipeline.",
      "description_length": 464,
      "index": 500,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.Fdd.Action.Seq.Provide_of_sexp",
      "library": "frenetic.netkat",
      "description": "This module defines a function `t_of_sexp` that parses S-expressions into a sequence of actions within a decision diagram structure, using a provided key conversion function. It operates specifically on `Ppx_sexp_conv_lib.Sexp.t` inputs and produces values of type `Frenetic_netkat.Fdd.Action.Seq.t`. A concrete use case is deserializing NetKAT policy configurations from S-expression format into executable flow tables for network forwarding.",
      "description_length": 443,
      "index": 501,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_netkat.Global_compiler.FDD.Tbl.Provide_of_sexp",
      "library": "frenetic.netkat",
      "description": "This module provides a function `t_of_sexp` that constructs an FDD table from an S-expression representation, using a provided conversion function for the table's values. It operates on data types involving FDDs parameterized by a key type, where the values are derived from parsing S-expressions. A concrete use case is deserializing FDD-based network policies stored in S-expression format into executable FDD structures for processing.",
      "description_length": 438,
      "index": 502,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.Fdd.Action.Par.Provide_hash",
      "library": "frenetic.netkat",
      "description": "This module implements hash functions for parallel action values in a decision diagram structure, specifically working with `Frenetic_netkat.Fdd.Action.Par.t` types that represent sets of OpenFlow actions. It enables efficient hashing and folding of action values into hash states, supporting operations like flow table compilation where consistent hashing of action combinations is required. Concrete use cases include optimizing NetKAT-to-OpenFlow translation by identifying equivalent action sets during FDD processing.",
      "description_length": 522,
      "index": 503,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.Fdd.Action.Par.Provide_of_sexp",
      "library": "frenetic.netkat",
      "description": "Converts S-expressions into parallel action values, specifically handling the deserialization of structured network actions. Works with `Frenetic_netkat.Fdd.Action.Par.t`, a type representing sets of OpenFlow actions applied in parallel. Useful for parsing serialized policy configurations or restoring action states from storage.",
      "description_length": 330,
      "index": 504,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.Global_compiler.FDD.Tbl.Provide_bin_io",
      "library": "frenetic.netkat",
      "description": "This module implements binary serialization and deserialization for FDD-based tables indexed by a `Key` type. It provides functions to convert FDD tables to and from binary format, supporting efficient storage and transmission. Use cases include persisting FDD table state to disk or sending them over a network.",
      "description_length": 312,
      "index": 505,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_netkat.Fdd.FDD.Tbl.Provide_of_sexp",
      "library": "frenetic.netkat",
      "description": "This module implements a parser for converting S-expressions into FDD-based flow tables, specifically handling key-value mappings where keys are derived from OpenFlow headers. It processes S-expressions into structured FDDs that represent forwarding decisions with actions at the leaves. Use this when deserializing NetKAT policies or flow tables from external configurations or test inputs.",
      "description_length": 391,
      "index": 506,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_netkat.Fdd.Action.Par.Elt",
      "library": "frenetic.netkat",
      "description": "This module represents elements of a parallel action structure in Forwarding Decision Diagrams (FDDs), where each element combines a value with a sequence of OpenFlow actions. It provides functions for serializing and deserializing these elements using S-expressions and defines a comparator for ordering instances. It is used during FDD construction and manipulation to represent distinct action outcomes under different header match conditions.",
      "description_length": 446,
      "index": 507,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_netkat.Fdd.Action.Seq.Provide_bin_io",
      "library": "frenetic.netkat",
      "description": "This module provides binary serialization and deserialization operations for sequences of FDD actions parameterized by a key type. It works with the `Frenetic_netkat.Fdd.Action.Seq.t` type, which represents sequences of actions associated with decision diagram nodes. Concrete use cases include persisting compiled flow tables to disk or transmitting them over a network in a compact binary format.",
      "description_length": 398,
      "index": 508,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.Local_compiler.FDD.BinTbl.Provide_bin_io",
      "library": "frenetic.netkat",
      "description": "This module implements binary serialization and deserialization for FDD-based tables parameterized by a key type. It provides functions to compute the binary shape, size, and perform reading and writing operations for FDD table values. Concrete use cases include persisting FDD tables to disk or transmitting them over a network in a binary format.",
      "description_length": 348,
      "index": 509,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.Global_compiler.FDD.BinTbl",
      "library": "frenetic.netkat",
      "description": "This module manages key-value tables where keys are binary decision diagrams (FDDs), supporting imperative updates and functional transformations like map, filter, and merge. It enables efficient rule evaluation and flow table optimization in network policy compilation by associating arbitrary data with FDDs. Submodule 1 constructs tables from S-expressions, allowing configuration-driven packet processing pipelines, while Submodule 2 provides binary serialization for efficient storage and transmission of FDD-based tables. Together, they support both dynamic construction and persistence of structured packet processing state.",
      "description_length": 631,
      "index": 510,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_netkat.Semantics.HeadersValues.Fields",
      "library": "frenetic.netkat",
      "description": "This module enables type-safe manipulation and inspection of packet header fields across network layers, combining direct access to concrete data types like MAC addresses, IP addresses, and VLAN tags with polymorphic operations over packet properties. It provides a structured interface for mapping, filtering, and transforming header fields within a policy evaluation or packet processing pipeline. Submodules extend this functionality to protocol-specific operations, allowing precise control over Ethernet, IP, TCP, and VLAN semantics. Examples include rewriting source IP addresses, enforcing firewall rules based on port numbers, or extracting VLAN tags for network virtualization.",
      "description_length": 686,
      "index": 511,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_netkat.Fdd.Action.Par",
      "library": "frenetic.netkat",
      "description": "This module manages sets of parallel OpenFlow actions using the structured collection type `Par.t`, composed of individual action elements `Elt.t`, and supports set operations, element selection, normalization, and hierarchical conversion. It enables precise manipulation of network policies for compiling NetKAT programs into optimized flow tables, verifying action equivalence, and serializing configurations. Submodules provide binary serialization, subset checking, ordered tree-based transformations, hashing, S-expression parsing, and element-level serialization, covering operations from policy translation to equivalence verification and storage. Specific uses include persisting flow tables, validating forwarding rules, optimizing network policies, and translating NetKAT into executable OpenFlow configurations.",
      "description_length": 822,
      "index": 512,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_netkat.Fdd.FDD.BinTbl",
      "library": "frenetic.netkat",
      "description": "This module manages associative tables keyed by Forwarding Decision Diagrams (FDDs), enabling operations like merge, filter, and transform while preserving network policy semantics through OpenFlow actions and header matches. It supports binary and S-expression serialization via submodules, allowing FDD-based flow tables to be persisted, transmitted, or loaded from external sources. The core API handles decision logic consistency and BDD-inspired optimizations, while the child modules provide concrete `t_of_sexp` and binary (de)serialization for structured keys. Example uses include compiling and optimizing NetKAT programs into efficient flow tables, then saving or sharing them across systems.",
      "description_length": 702,
      "index": 513,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.Local_compiler.FDD.BinTbl",
      "library": "frenetic.netkat",
      "description": "This module provides imperative hash table operations for binary decision diagrams, managing key-value pairs with support for insertion, lookup, iteration, and higher-order transformations such as `mapi` and `filter_map`. It handles polymorphic tables with typed keys and values, including multi-value lists, and includes mechanisms for efficient manipulation, serialization via S-expressions, and error handling for key collisions. The module enables applications like network policy compilation by supporting the construction and transformation of FDD-based tables, with submodules offering S-expression parsing via `t_of_sexp` and binary serialization routines for persistence and transmission. Example uses include deserializing network rules into executable decision diagrams and exporting FDD tables to disk or over a network.",
      "description_length": 832,
      "index": 514,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.Fdd.Action.Seq",
      "library": "frenetic.netkat",
      "description": "This module orchestrates the construction and manipulation of ordered sequences of OpenFlow actions tied to header fields, combining direct operations like folding, filtering, and validation with submodules that model key-value mappings, serialization, and hashing. It centers around the `t` type representing action sequences, with keys either as header fields or continuations, and supports transformations that preserve ordering constraints required for FDD compilation. Submodules enable parsing from S-expressions, binary serialization, and hashing, allowing use cases such as translating NetKAT policies into minimized OpenFlow tables or detecting equivalent action sequences during optimization. Specific operations include `t_of_sexp` for policy deserialization, `hash_fold_t` for deterministic hashing, and `merge` for conflict-free action sequence assembly.",
      "description_length": 867,
      "index": 515,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_netkat.Global_compiler.FDD.Tbl",
      "library": "frenetic.netkat",
      "description": "This module manages polymorphic hash tables with FDD-derived keys, supporting imperative and functional operations for efficient lookups, conditional updates, and policy-driven duplicate handling. It enables advanced table manipulations such as merging, filtering, and partitioning with customizable logic, and supports list-valued entries for multi-mapping use cases like tracking network flow states. The module includes submodules for serializing and deserializing FDD tables using S-expressions and binary formats, facilitating persistence and transmission across systems. For example, it can compile network policies into executable FDD structures, then serialize them for storage or network transfer.",
      "description_length": 706,
      "index": 516,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.Fdd.FDD.Tbl",
      "library": "frenetic.netkat",
      "description": "This module provides specialized hash tables for efficient manipulation of FDDs as keys, supporting arbitrary value types and operations like merging, filtering, and reference counting. It enables imperative updates and functional transformations over finite-domain key structures derived from NetKAT's OpenFlow-based predicates, with optimized lookups for list-valued entries and structural comparisons used in flow table generation. The binary serialization submodule converts flow tables to compact binary formats for storage or transmission, while the S-expression parser submodule ingests structured key-value mappings from external configurations into FDD-based tables. Together, these components support compiling, transforming, and persisting network policies in software-defined networking workflows.",
      "description_length": 809,
      "index": 517,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_netkat.Local_compiler.FDD.Tbl",
      "library": "frenetic.netkat",
      "description": "This module manages hash tables keyed by FDDs (Variable-Lattice-Result structures), supporting efficient construction from lists with customizable duplicate handling, functional transformations via map and fold, imperative updates, and predicate-based queries for selection and validation. It includes operations for serializing tables to and from S-expressions and binary formats, enabling persistence and transmission of structured FDD-based data such as network policies. The S-expression submodule provides `t_of_sexp` to deserialize FDD tables using a custom value parser, while the binary submodule offers shape computation, size calculation, and read/write functions for compact and efficient storage or network transfer. Example uses include compiling and evaluating network policies in memory, then saving or transmitting them for deployment across distributed systems.",
      "description_length": 878,
      "index": 518,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.Fdd.Field.Env",
      "library": "frenetic.netkat",
      "description": "This module maps string identifiers to FDD fields, tracking each field's initializer and mutability. It supports adding new field mappings, looking up existing ones, and maintaining a global field ordering to optimize FDD structure. It is used during FDD construction to manage header field metadata and ensure consistent, efficient decision diagram compilation from NetKAT policies.",
      "description_length": 383,
      "index": 519,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.Vlr.HashCmp",
      "library": "frenetic.netkat",
      "description": "This module defines a type `t` with operations for equality checking, comparison, hashing, and S-expression conversion. It supports data structures that require consistent hashing and comparison, such as keys in hash tables or elements in sets. Concrete use cases include representing network packet fields or rule identifiers that must be efficiently compared and stored.",
      "description_length": 372,
      "index": 520,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.Vlr.Lattice",
      "library": "frenetic.netkat",
      "description": "This module defines a lattice structure with operations to compare, hash, and serialize elements. It supports data types that can be ordered within a lattice, enabling efficient set-like operations and policy analysis. Concrete use cases include representing network packet classifiers and symbolic sets in software-defined networking.",
      "description_length": 335,
      "index": 521,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_netkat.Vlr.Result",
      "library": "frenetic.netkat",
      "description": "This module defines a semi-ring structure with operations for sum and product, along with standard comparison, hashing, and serialization functions. It works with an abstract type `t` that supports semi-ring laws, including identity elements `zero` and `one`. Concrete use cases include representing and combining network packet processing policies where algebraic composition is required.",
      "description_length": 389,
      "index": 522,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.Parser.Portless",
      "library": "frenetic.netkat",
      "description": "This module parses NetKAT policies and predicates from strings or files, converting them into corresponding syntax trees. It supports parsing operations for both policy and predicate expressions, handling input with or without specified lexical positions. Use it to directly construct NetKAT programs from textual representations, such as reading configurations from files or user input.",
      "description_length": 387,
      "index": 523,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.Global_compiler.FDD",
      "library": "frenetic.netkat",
      "description": "This module implements Variable-Lattice-Result (VLR) structures to represent and manipulate Binary Decision Diagrams (FDDs) for network policy modeling, supporting operations such as union, sequential composition, Kleene star, and recursive traversal. It includes submodules for managing FDD-keyed tables with imperative and functional transformations, enabling rule evaluation, flow table optimization, and multi-mapping of network flow states. The module supports policy compilation, equivalence checking, and reachability analysis, with additional facilities for S-expression and binary serialization of FDD-based state. Example uses include compiling packet processing pipelines from structured configurations and serializing optimized policies for distributed deployment.",
      "description_length": 776,
      "index": 524,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.Local_compiler.FDD",
      "library": "frenetic.netkat",
      "description": "This module implements a Variable-Lattice-Result structure for modeling network packet processing policies using binary decision diagrams. It supports set-theoretic operations like union and sequential composition, structural manipulations such as map and restrict, and analysis tasks including equivalence checking and size measurement. The core functionality enables optimizing network policy pipelines and verifying transformations between packet header rules, with direct support for DOT serialization to visualize decision logic. Submodules provide imperative hash table operations for FDD-based data, enabling efficient construction, transformation, and serialization of network policies to S-expressions and binary formats, with use cases including rule compilation, in-memory evaluation, and distributed deployment.",
      "description_length": 823,
      "index": 525,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.Semantics.HeadersValues",
      "library": "frenetic.netkat",
      "description": "This module represents network packet headers as a structured record with fields for Ethernet, IP, TCP, and virtual switch data, offering direct access to values such as MAC and IP addresses, port numbers, and VLAN tags. It supports type-safe inspection, modification, and comparison of header fields, along with serialization to strings or lists for logging or transmission. Submodules enable protocol-specific operations, such as rewriting IP addresses, filtering packets by TCP port, or extracting VLAN tags for virtualized network management. Examples include implementing firewall rules, transforming packet metadata during routing, or analyzing traffic for monitoring tools.",
      "description_length": 680,
      "index": 526,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.Fdd.FDD",
      "library": "frenetic.netkat",
      "description": "This module represents hierarchical decision structures as binary trees with internal nodes testing packet header fields and leaves encoding forwarding actions, organized using a variable lattice to optimize field ordering. It supports operations like conditional branching, functional mapping, and path analysis, enabling the compilation of network policies into compressed OpenFlow tables using BDD-based algorithms. Child modules provide associative tables and hash tables keyed by FDDs, allowing efficient merging, filtering, and serialization to binary or S-expression formats. These capabilities facilitate tasks such as optimizing NetKAT programs, persisting flow tables, and exchanging structured network policies across systems.",
      "description_length": 737,
      "index": 527,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_netkat.FabricGen.FABRIC_GEN",
      "library": "frenetic.netkat",
      "description": "This module generates a network fabric configuration as a pair of policy lists, representing ingress and egress rules. It constructs the fabric based on input predicates and policies that define virtual and physical topologies, along with ingress and egress conditions. Use this module to synthesize forwarding rules for software-defined networks where traffic must be steered through middleboxes or across distributed switches.",
      "description_length": 428,
      "index": 528,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.Vlr.Make",
      "library": "frenetic.netkat",
      "description": "This module provides operations to construct and manipulate semi-ring\u2013valued decision diagrams over lattice-ordered variables, supporting structural transformations like `map`, `fold`, and `restrict`, memoized computation via `dp_map`, and algebraic combinations (`sum`, `prod`). It works with lattice-based decision diagrams represented as a recursive data structure of nodes, which encode conditional logic, constants, and atomic tests, alongside utility functions for equality checking, size analysis, and serialization. These capabilities are particularly useful in network policy modeling, where lattice variables can represent packet header fields and semi-ring values track quantitative properties like flow counts or aggregated metadata.",
      "description_length": 745,
      "index": 529,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_netkat.Packet.T",
      "library": "frenetic.netkat",
      "description": "This module represents network packets as maps from fields to 64-bit integer values. It provides operations for comparing packets, serializing and deserializing them to S-expressions, and computing hash values. Use this module when processing or manipulating packet data in network applications, such as matching packets against rules or storing packets in hash tables.",
      "description_length": 369,
      "index": 530,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.FabricGen.FabricGen",
      "library": "frenetic.netkat",
      "description": "Implements a two-player adversarial strategy to generate network fabrics by combining virtual and physical topologies. It constructs policies that enforce reachability constraints between ingress and egress points under a given relation. Uses `policy` and `pred` types from the Syntax module to represent network behaviors and packet filters.",
      "description_length": 342,
      "index": 531,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.Domain.Field",
      "library": "frenetic.netkat",
      "description": "This module defines operations for comparing and ordering field values within a domain, specifically using the `compare` function and a comparator witness. It works with the `t` type, representing fields in an FDD or Automaton domain. Concrete use cases include determining field value equivalence and sorting or indexing field data during automaton construction or analysis.",
      "description_length": 375,
      "index": 532,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.Fdd.Action",
      "library": "frenetic.netkat",
      "description": "This module defines algebraic operations on network actions represented as Forwarding Decision Diagrams (FDDs), enabling associative and commutative composition, identity handling, and transformation into low-level SDN instructions. It works with OpenFlow-style header modification actions embedded in FDDs, along with derived data structures like query lists, pipe sets, and serialized action representations, supporting tasks such as compiling NetKAT policies into optimized flow tables and translating high-level actions into switch-level configurations. The first child module manages sets of parallel actions using `Par.t`, supporting set operations, normalization, and serialization, with uses in policy translation, equivalence verification, and flow table optimization. The second child module handles ordered sequences of actions tied to header fields, offering operations like folding, filtering, and merging, with support for parsing, hashing, and deterministic serialization to enable policy translation and action sequence optimization.",
      "description_length": 1049,
      "index": 533,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_netkat.Fdd.Value",
      "library": "frenetic.netkat",
      "description": "This module represents values used in field tests and modifications within a decision diagram structure, supporting operations like equality checks, comparison, hashing, and lattice-based subsetting. It works with packet fields by encoding constants, bitmasks, abstract locations, and special actions like Pipe or Query as possible values. Concrete use cases include representing exact matches (e.g., EthSrc = \"FE:89:00:12:34:12\"), wildcarded matches using masks, and encoding actions such as port modifications in flow tables.",
      "description_length": 527,
      "index": 534,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.Packet.Field",
      "library": "frenetic.netkat",
      "description": "This module defines a field as a key in a packet, used to access or modify specific values within packet maps. It provides comparison operations to order fields and a comparator witness for use in ordered data structures. Concrete use cases include constructing packet classifiers or manipulating packet headers in network applications.",
      "description_length": 336,
      "index": 535,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.Fdd.Field",
      "library": "frenetic.netkat",
      "description": "This module defines a fixed set of packet header fields used in Forwarding Decision Diagrams, such as Ethernet source, IP destination, TCP port, and VLAN. It provides operations to convert fields to and from strings and sexps, compare and hash them, and manage a global field ordering that can be set manually or derived from a policy. The child module maps string identifiers to fields, tracking initializers and mutability, supporting dynamic field registration and consistent FDD compilation from NetKAT policies. Together, they enable efficient header field manipulation and metadata management during FDD construction.",
      "description_length": 623,
      "index": 536,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_netkat.Virtual_Compiler.Make",
      "library": "frenetic.netkat",
      "description": "This module generates and compiles network fabrics for virtual NetKAT policies using a customizable fabric generation strategy. It operates on NetKAT predicates and policies to model network topologies, ingress, and egress conditions. It is used to translate high-level virtual network policies into concrete forwarding rules based on a physical network substrate.",
      "description_length": 364,
      "index": 537,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_netkat.Fdd.Pattern",
      "library": "frenetic.netkat",
      "description": "This module represents patterns in Forwarding Decision Diagrams, pairing fields with values to model OpenFlow header matches. It supports conversions to NetKAT predicates and OpenFlow patterns, enabling direct use in flow table generation. Operations include comparison, equality checks, and transformations between header representations.",
      "description_length": 339,
      "index": 538,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_netkat.Global_compiler.Automaton",
      "library": "frenetic.netkat",
      "description": "This module represents and manipulates NetKAT automata as an intermediate structure in the global compiler. It supports operations like adding states, folding over reachable states, converting policies to automata, and rendering automata to graphical formats. It works directly with field decision diagrams (FDDs) and integer identifiers to represent automaton states and transitions, enabling concrete tasks such as policy compilation, visualization, and analysis of network behaviors.",
      "description_length": 486,
      "index": 539,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.Virtual_Compiler",
      "library": "frenetic.netkat",
      "description": "This module translates high-level virtual network policies into concrete forwarding rules by generating and compiling network fabrics based on NetKAT predicates and policies. It models network topologies, ingress, and egress conditions using customizable fabric generation strategies. Key data types include NetKAT predicates, policies, and physical substrates, with operations for policy compilation and fabric instantiation. For example, it can generate a forwarding table from a virtual policy that restricts traffic between specific IP ranges.",
      "description_length": 547,
      "index": 540,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.Semantics",
      "library": "frenetic.netkat",
      "description": "This module evaluates network policies against packets containing structured headers, switch identifiers, and payloads, producing transformed output packets or pipeline results. It processes PACKET_IN messages through network functions, extracts identifiers from policies, and supports type-safe header manipulation via submodules that handle Ethernet, IP, TCP, and VLAN operations. Examples include applying firewall rules based on TCP ports, rewriting IP addresses during routing, or extracting VLAN tags for virtualized network management. The core API works with packets and policies defined in a domain-specific language, enabling precise traffic analysis and transformation.",
      "description_length": 680,
      "index": 541,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_netkat.LexBuffer",
      "library": "frenetic.netkat",
      "description": "This module provides a lexbuffer implementation that tracks source positions and Unicode characters during lexical analysis. It supports operations to create buffers from strings or files, mark and backtrack positions, and retrieve the next character or its location. It is used to implement precise error reporting and source mapping in parsers that process ASCII-based input.",
      "description_length": 377,
      "index": 542,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_netkat.Global_compiler",
      "library": "frenetic.netkat",
      "description": "This module compiles network policies into efficient decision diagrams using internal bookkeeping and predicate constraints, working with policy, predicate, and field data types to enforce packet processing rules. It leverages Variable-Lattice-Result (VLR) structures to represent Binary Decision Diagrams (FDDs), supporting operations like union, sequential composition, and Kleene star, along with imperative and functional transformations for flow table optimization and policy serialization. The module also processes NetKAT automata, enabling policy compilation, visualization, and analysis through state transitions and FDD-based representations. Example uses include compiling structured network configurations into executable policies and serializing optimized FDDs for distributed deployment.",
      "description_length": 801,
      "index": 543,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.Fdd",
      "library": "frenetic.netkat",
      "description": "This module implements Forwarding Decision Diagrams (FDDs) for representing and manipulating network policies as hierarchical decision structures. It centers around FDDs as binary trees with header field tests at internal nodes and OpenFlow actions at leaves, supporting operations like conditional branching, composition, and path analysis. Key data types include FDDs themselves, packet fields with configurable ordering, field-value patterns for header matches, and action algebras for policy transformations. Example uses include compiling NetKAT programs into optimized OpenFlow tables, optimizing and serializing flow rules, and verifying policy equivalence through structured FDD manipulations.",
      "description_length": 701,
      "index": 544,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.Json",
      "library": "frenetic.netkat",
      "description": "This module converts NetKAT policies and OpenFlow messages to and from JSON format using Yojson. It supports serialization and deserialization of policies, header values, pseudoports, flow tables, and packet events, handling input and output as JSON strings or channels. Concrete use cases include transmitting NetKAT policies over a network, logging OpenFlow events, and reconstructing switch state from JSON data.",
      "description_length": 415,
      "index": 545,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.Portless_Generated_Parser",
      "library": "frenetic.netkat",
      "description": "This module provides functions for parsing network policies and predicates from input streams without port information. It processes tokens generated by the lexer to produce policy and predicate values, working directly with lex buffers and token streams. Concrete use cases include reading and interpreting NetKAT policies and predicates from files or strings in a port-agnostic context.",
      "description_length": 388,
      "index": 546,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.Syntax",
      "library": "frenetic.netkat",
      "description": "This module provides serialization, comparison, and equality operations for network identifiers and NetKAT syntax structures, supporting data representation and conversion. It defines types for network elements like switches, ports, virtual identifiers, and policies, enabling use cases such as compiling NetKAT into flow tables, parsing policy strings, and converting JSON-formatted configurations.",
      "description_length": 399,
      "index": 547,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.Lexer",
      "library": "frenetic.netkat",
      "description": "This module defines a set of lexical tokens and parsing functions for processing NetKAT-like network policies. It handles input strings, files, or buffers, converting them into structured tokens such as keywords, identifiers, and literals like MAC addresses or integers. Use this module to implement custom parsers for network policy languages, or to tokenize and analyze NetKAT expressions in OCaml programs.",
      "description_length": 409,
      "index": 548,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.Pretty",
      "library": "frenetic.netkat",
      "description": "This module provides functions to format and convert network policies and predicates into human-readable strings. It supports pretty-printing of policy and predicate structures, including handling of associative operators for improved readability. Use cases include debugging network programs and generating readable output for policy configurations.",
      "description_length": 350,
      "index": 549,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_netkat.Vlr",
      "library": "frenetic.netkat",
      "description": "This module organizes integer pairs into a versioned lattice structure that supports cache management with least recently used eviction. It uses a specialized hash table for efficient key-value storage and provides operations to insert, query, and evict entries based on versioned timestamps. The lattice submodule enables ordering and set-like operations, while the semi-ring submodule supports algebraic policy composition with identity elements. Decision diagrams over lattice variables allow structural transformations and memoized computation, useful for modeling network policies with conditional logic and quantitative tracking.",
      "description_length": 635,
      "index": 550,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.Portless_Compiler",
      "library": "frenetic.netkat",
      "description": "Compiles a portless network policy into a portful policy by leveraging a given network topology. Works with network policies and topologies represented as structured data types. Useful for translating high-level policies into executable, port-specific configurations in software-defined networking.",
      "description_length": 298,
      "index": 551,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.FabricGen",
      "library": "frenetic.netkat",
      "description": "This module orchestrates the generation of network fabric configurations for virtualized environments, integrating topology construction with policy synthesis to automate test network creation and optimize physical layouts. It provides core operations for defining switches, links, host placements, and reachability constraints, while leveraging child modules to produce policy-based forwarding rules and adversarial strategies that enforce traffic conditions across distributed elements. The first child module synthesizes ingress and egress rule pairs from input predicates and topologies, enabling precise traffic steering through middleboxes, while the second employs game-theoretic methods to construct fabrics satisfying reachability relations between endpoints. Together, they enable both deterministic and strategic fabric generation, using packet filters and policies to model network behavior.",
      "description_length": 903,
      "index": 552,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.Tokens",
      "library": "frenetic.netkat",
      "description": "This module defines a comprehensive set of lexical tokens used for parsing and representing the syntax of the Frenetic language. It includes tokens for control structures (e.g., WHILE, IF, THEN), network-specific identifiers (e.g., SWITCH, PORT, VLAN), literals (e.g., INT, STRING), and operators (e.g., AND, OR, ASSIGN). These tokens are used directly in the construction and manipulation of abstract syntax trees during the compilation and evaluation of network policies.",
      "description_length": 473,
      "index": 553,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.Bisim",
      "library": "frenetic.netkat",
      "description": "Implements bisimilarity checking between two automata using the Hopcroft-Karp algorithm. Operates directly on automaton structures defined in the Global_compiler module. Useful for verifying equivalence of network packet processing pipelines represented as finite automata.",
      "description_length": 273,
      "index": 554,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.Packet",
      "library": "frenetic.netkat",
      "description": "A packet is a map from fields to 64-bit integer values, supporting transformations and evaluations through field decision diagrams and actions. It enables concrete operations like applying FDDs to compute actions based on packet fields or modifying packets via actions, with support for comparison, serialization, and hashing. Fields act as keys into the packet, providing ordering and comparison capabilities for constructing classifiers or manipulating packet headers. This module is used for precise packet processing in network applications, such as rule matching, policy enforcement, and header manipulation.",
      "description_length": 613,
      "index": 555,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.Generated_Parser",
      "library": "frenetic.netkat",
      "description": "This module provides functions to parse network policies and predicates from input streams using a generated parser. It processes tokens from a lexing buffer to produce abstract syntax trees representing policies and boolean expressions. Concrete use cases include parsing NetKAT policy specifications and predicate logic from files or strings for network verification tasks.",
      "description_length": 375,
      "index": 556,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_netkat.Domain",
      "library": "frenetic.netkat",
      "description": "The module tracks the domain of packet fields by collecting sets of values from FDD or automaton tests and modifications, supporting operations to create, merge, and extract domains for generating representative packets. It defines core types like `t` to represent field domains and includes functions to compare and order field values, enabling sorting and equivalence checks during automaton analysis. Submodule functionality extends this by providing comparator-based operations for indexing and structuring field data. Example uses include extracting all observed IP addresses from a firewall decision diagram and merging domains across multiple rules to ensure comprehensive packet coverage.",
      "description_length": 696,
      "index": 557,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.Optimize",
      "library": "frenetic.netkat",
      "description": "This module provides functions to construct and manipulate network policies and predicates, including logical operations (AND, OR, NOT), policy composition (sequence, union, Kleene star), and normalization. It works with predicates and policies defined over network switches, enabling the creation of complex filtering and forwarding rules. Concrete use cases include building optimized packet-processing pipelines, simplifying policy expressions, and specializing policies to specific switches.",
      "description_length": 495,
      "index": 558,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat.Parser",
      "library": "frenetic.netkat",
      "description": "Parses NetKAT policies and predicates from strings or files into structured syntax trees, supporting both policy and predicate expressions with or without positional information. The main operations take string or file inputs and produce corresponding NetKAT values, enabling direct construction of programs from textual configurations or user input. For example, it can read a firewall rule written in NetKAT from a file and convert it into an executable policy structure. The module and its submodules together provide a complete interface for loading and interpreting NetKAT code in various contexts.",
      "description_length": 603,
      "index": 559,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_netkat.Local_compiler",
      "library": "frenetic.netkat",
      "description": "This module provides a framework for compiling and analyzing network policies using an FDD-based intermediate representation, supporting operations such as sequential and parallel composition, policy restriction, and deduplication. It models policies through a variable-lattice-result structure that enables set-theoretic operations, structural transformations, and analysis tasks like equivalence checking, with support for DOT serialization to visualize decision logic. The module handles core data types including policies, packets, flow instructions, and multi-table flows, and includes submodules for efficient FDD-based hash table operations, S-expression and binary serialization, and imperative construction of network rules. Use cases include optimizing policy compilation into OpenFlow rules, tracing packet behavior, and deploying structured network policies in software-defined networking environments.",
      "description_length": 914,
      "index": 560,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_netkat",
      "library": "frenetic.netkat",
      "description": "This module suite implements a comprehensive network policy language and compiler for software-defined networking, centered around NetKAT semantics. It provides core data types for packets, predicates, policies, and Forwarding Decision Diagrams (FDDs), with operations for policy composition, packet transformation, and FDD-based optimization. Users can define high-level network policies\u2014such as firewalls, traffic filters, and routing rules\u2014and compile them into executable OpenFlow configurations, verify policy equivalence, or simulate packet behavior. Example workflows include translating a NetKAT firewall policy into optimized switch rules, analyzing reachability across a virtual network, or serializing policy changes to JSON for distributed deployment.",
      "description_length": 763,
      "index": 561,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_async.Ox.Platform",
      "library": "frenetic.async",
      "description": "This module provides functions to send OpenFlow protocol messages such as packet-out, flow modification, statistics requests, and barrier requests to network switches. It also includes a function to execute a thunk with a specified timeout. These operations are used to interact directly with OpenFlow switches and manage asynchronous control operations in network applications.",
      "description_length": 378,
      "index": 562,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_async.NetKAT_Controller.Make",
      "library": "frenetic.async",
      "description": "This module implements a controller for handling OpenFlow events and managing network policies in an SDN environment. It provides operations to start a TCP listener, retrieve switch and port statistics, update policies locally or globally, inject packets, and query traffic metrics, working with OpenFlow switches, ports, and FDD-compiled policies. Concrete use cases include dynamically reconfiguring network traffic rules, monitoring port activity, and responding to switch events in real time.",
      "description_length": 496,
      "index": 563,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_async.Ox.OXMODULE",
      "library": "frenetic.async",
      "description": "This module defines the interface for handling OpenFlow switch events, including switch connections, disconnections, packet arrivals, barrier replies, and statistics responses. It works with OpenFlow switch identifiers, transaction IDs, packet data, and control messages. Concrete use cases include implementing custom logic for network monitoring, dynamic flow rule updates, and switch management in SDN controllers.",
      "description_length": 417,
      "index": 564,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_async.Ox.DefaultHandlers",
      "library": "frenetic.async",
      "description": "This module provides default implementations for handling OpenFlow switch events such as connection, disconnection, barrier replies, and stats replies, all of which ignore the received messages. It works with OpenFlow switch identifiers, transaction IDs, and message reply structures from the OpenFlow 0x01 protocol. These handlers are useful in simple controllers where advanced event processing is not required.",
      "description_length": 413,
      "index": 565,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_async.OpenFlow0x01_Plugin.LowLevel",
      "library": "frenetic.async",
      "description": "This module manages low-level OpenFlow 1.0 communication for switches, handling message transmission and event reception. It provides operations to start a connection, send typed messages to specific switches with transaction IDs, and receive a stream of OpenFlow events. Concrete use cases include implementing custom switch control logic, packet processing pipelines, and network monitoring tools.",
      "description_length": 399,
      "index": 566,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_async.NetKAT_Controller.PLUGIN",
      "library": "frenetic.async",
      "description": "This module manages interactions with OpenFlow switches in an SDN environment. It provides functions to start a controller instance, handle switch events, retrieve switch features, update flow tables, send packets, and query flow and port statistics. Concrete use cases include dynamically reconfiguring network policies, monitoring traffic on specific ports, and implementing custom control logic for packet forwarding.",
      "description_length": 420,
      "index": 567,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_async.Ox.Make",
      "library": "frenetic.async",
      "description": "This module builds an Ox controller that listens on port 6633 for OpenFlow messages from network switches and routes them to the provided OXMODULE callbacks. It operates on OpenFlow-enabled switch connections and handles message dispatching for network event processing. Concrete use cases include implementing custom SDN controllers that react to switch events like packet arrivals or flow modifications.",
      "description_length": 405,
      "index": 568,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_async.NetKAT_Controller.CONTROLLER",
      "library": "frenetic.async",
      "description": "This module manages a network controller that handles OpenFlow events, monitors switches and port statistics, and applies NetKAT policies to control network behavior. It provides operations to update policies locally or globally, send packet instructions, and query network metrics. Use cases include real-time network monitoring, dynamic traffic control, and policy-based packet forwarding.",
      "description_length": 391,
      "index": 569,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_async.NetKAT_Controller",
      "library": "frenetic.async",
      "description": "This module implements asynchronous network control logic using NetKAT semantics, enabling the compilation and execution of packet-processing policies on switches. It manages packet arrivals, switch connections, and policy updates, with core data types including policies, packet headers, and switch state. The module supports use cases like dynamic traffic reconfiguration, real-time monitoring of port statistics, and policy-based forwarding. Submodules provide controller setup, OpenFlow event handling, flow table management, and operations for injecting packets or querying metrics across switches.",
      "description_length": 603,
      "index": 570,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_async.Ox",
      "library": "frenetic.async",
      "description": "This module launches and manages Ox applications by defining handlers, platform-specific behavior, and module composition. It supports building network services with asynchronous event handling, including setting up HTTP servers and custom application logic through the `OXMODULE` signature. Child modules enable direct interaction with OpenFlow switches via message sending, define event handling interfaces for switch events, and provide default handlers for common OpenFlow operations. Together, they allow implementing SDN controllers that listen on port 6633, process switch events, and execute custom or default logic for network monitoring, flow control, and message dispatching.",
      "description_length": 686,
      "index": 571,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_async.DynGraph",
      "library": "frenetic.async",
      "description": "This module implements a dynamic dataflow graph where nodes hold values and propagate updates to connected nodes. It supports creating nodes with custom update functions, attaching nodes to form directed edges, and interfacing with async pipes for external input and output. Nodes can be sources that reject incoming edges or sinks that produce values to a pipe, enabling reactive programming patterns with precise control over data dependencies and propagation.",
      "description_length": 462,
      "index": 572,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_async.Logging",
      "library": "frenetic.async",
      "description": "This module supports structured logging and diagnostics with configurable severity levels, asynchronous output, and metadata handling. It processes structured data like S-expressions, strings, and log messages, incorporating timestamps, key-value tags, and error contexts. Designed for applications requiring distributed system monitoring, error tracking, and performance auditing, it enables log rotation, deferred computation wrapping, and fine-grained control over message formatting and delivery.",
      "description_length": 500,
      "index": 573,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Frenetic_async.OpenFlow0x01_Plugin",
      "library": "frenetic.async",
      "description": "This module enables asynchronous handling of OpenFlow 1.0 switch interactions, managing connections, packet forwarding, and flow/port statistics. It supports operations like sending packet-out commands, querying flow statistics, and applying NetKAT policies to update switch rules, while working with switch and port identifiers, flow patterns, and OpenFlow events. The child module handles low-level communication, allowing custom control logic, packet processing, and monitoring through message transmission and event streaming. Together, they support use cases like network analysis, dynamic rule updates, and real-time switch monitoring.",
      "description_length": 641,
      "index": 574,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_async.Common",
      "library": "frenetic.async",
      "description": "This module provides functions for profiling code execution, logging with severity levels, extracting request paths from HTTP requests, and handling parsing errors in asynchronous HTTP handlers. It works with Cohttp_async request and body types, along with Frenetic_netkat policy and compiler types. Concrete use cases include parsing JSON policy updates, extracting routing paths from requests, and wrapping HTTP handlers to manage parsing failures gracefully.",
      "description_length": 461,
      "index": 575,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_async.OpenFlow0x04_Plugin",
      "library": "frenetic.async",
      "description": "This module implements OpenFlow 1.3 communication and control logic for network switches, handling message serialization, flow table updates, and group table management. It works with OpenFlow messages, flow layouts, switch identifiers, and network topologies to manage SDN switch behavior. Concrete operations include sending asynchronous OpenFlow messages, installing flow rules with or without fault tolerance, processing incoming messages, and running event loops for switch communication.",
      "description_length": 493,
      "index": 576,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_async.Http_Controller",
      "library": "frenetic.async",
      "description": "This module implements an asynchronous HTTP controller for handling network requests. It provides a `main` function that starts a server on specified ports and manages incoming connections. Concrete use cases include building lightweight web services or APIs that process HTTP methods like GET, POST, and PUT asynchronously.",
      "description_length": 324,
      "index": 577,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frenetic_async.Shell",
      "library": "frenetic.async",
      "description": "Executes a command-line interface loop, handling user input and invoking corresponding actions. Works with string-based commands and asynchronous event handlers. Useful for building interactive shell applications with async workflows.",
      "description_length": 234,
      "index": 578,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_async.Compile_Server",
      "library": "frenetic.async",
      "description": "This module implements a server that compiles and executes Frenetic programs asynchronously. It listens for incoming connections on a specified port, processes compilation requests, and returns the results to the client. The `main` function starts the server with a given port number and handles the asynchronous event loop for request processing.",
      "description_length": 347,
      "index": 579,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frenetic_async",
      "library": "frenetic.async",
      "description": "This module enables asynchronous network control and management with reactive dataflow and structured diagnostics. Core data types include network policies, packet headers, switch state, dynamic dataflow nodes, and structured log entries, supporting operations like policy compilation, flow rule updates, event-driven switch handling, and HTTP server management. Users can implement SDN controllers that process OpenFlow events, build reactive graphs for value propagation, log diagnostics with metadata, or run HTTP services that handle network requests asynchronously. Examples include dynamic traffic steering, real-time port monitoring, interactive CLI tools, and distributed system auditing.",
      "description_length": 696,
      "index": 580,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 582,
    "meaningful_modules": 581,
    "filtered_empty_modules": 1,
    "retention_rate": 0.9982817869415808
  },
  "statistics": {
    "max_description_length": 1049,
    "min_description_length": 175,
    "avg_description_length": 462.8072289156627,
    "embedding_file_size_mb": 2.110873222351074
  }
}