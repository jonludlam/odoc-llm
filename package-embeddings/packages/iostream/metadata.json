{
  "package": "iostream",
  "embedding_model": "BAAI/bge-base-en-v1.5",
  "embedding_dimension": 1024,
  "total_modules": 8,
  "creation_timestamp": "2025-06-18T16:31:23.737583",
  "modules": [
    {
      "module_path": "Iostream_unix.In",
      "description": "Creates an input stream from a Unix file descriptor, allowing reading with optional error handling on close. Operates on Unix.file_descr and Iostream.In.t_seekable types. Useful for integrating low-level I/O handles into higher-level stream-based processing.",
      "description_length": 258,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Iostream_unix.Out",
      "description": "Provides functions for writing data to Unix file descriptors and managing seekable output streams. Works with Unix.file_descr and Iostream.Out.t_seekable types. Enables low-level I/O operations such as writing binary data directly to file descriptors without intermediate buffering.",
      "description_length": 282,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Iostream.Slice",
      "description": "Provides functions to create, manipulate, and inspect byte slices, including consuming bytes and finding character indices. Works with a custom slice type that wraps a byte buffer and tracks offset and length. Used to process network data streams by efficiently extracting and advancing through portions of a byte buffer.",
      "description_length": 321,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Iostream_types.Slice",
      "description": "type t = { offset : int; len : int } Provides functions to create, manipulate, and query slices based on byte offset and length. Works with raw byte sequences and ensures bounds checking during slice operations. Used to extract subranges from binary data structures or network packets.",
      "description_length": 285,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "iostream",
      "description": "Provides functions for reading, writing, and composing byte streams, including transformations and combinators for stream manipulation. Works with byte buffers, input and output channels, and effect-based I/O backends. Enables building efficient, modular I/O pipelines for network protocols, file processing, and data serialization.",
      "description_length": 332,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Iostream_unix",
      "description": "Reads from and writes to Unix file descriptors using stream interfaces, supporting both input and output operations with seekable behavior. Handles low-level I/O by converting file descriptors into stream types, enabling direct data manipulation. Allows reading binary data from file descriptors and writing to them with control over error handling and positioning. Supports integration of Unix I/O into stream-based workflows, such as processing network or file data incrementally.",
      "description_length": 482,
      "index": 5,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Iostream",
      "description": "Provides a framework for handling I/O streams through customizable and composable components. It includes a slice type for managing byte buffers with offset and length, enabling efficient processing of network data by extracting and advancing through specific portions. Functions allow byte consumption, index searching, and buffer inspection. This supports low-level data manipulation and stream composition in network and file I/O scenarios.",
      "description_length": 443,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Iostream_types",
      "description": "Provides a structured way to represent and manage byte-level slices using a record type with offset and length fields. It supports creating and validating slices, ensuring safe access to raw binary data by enforcing bounds checks. This enables precise extraction and manipulation of subranges from binary streams or network packets. For example, it can isolate a specific field from a protocol header or segment a large buffer into smaller, manageable parts.",
      "description_length": 458,
      "index": 7,
      "embedding_norm": 0.9999999403953552
    }
  ],
  "filtering": {
    "total_modules_in_package": 18,
    "meaningful_modules": 8,
    "filtered_empty_modules": 10,
    "retention_rate": 0.4444444444444444
  },
  "statistics": {
    "max_description_length": 482,
    "min_description_length": 258,
    "avg_description_length": 357.625,
    "embedding_file_size_mb": 0.02946949005126953
  }
}