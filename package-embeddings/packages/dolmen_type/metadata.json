{
  "package": "dolmen_type",
  "embedding_model": "Qwen/Qwen3-Embedding-0.6B",
  "embedding_dimension": 1024,
  "total_modules": 82,
  "creation_timestamp": "2025-07-15T23:18:48.669912",
  "modules": [
    {
      "module_path": "Dolmen_type.Arith.Smtlib2.Real.Tff",
      "library": "dolmen_type",
      "description": "This module implements type-checking and parsing for real arithmetic expressions in SMT-LIBv2, specifically handling warnings and errors related to specification compliance. It works with terms represented as `Dolmen.Std.Term.t`, and integrates configuration settings and versioning to enforce strict or relaxed interpretations of the standard. Concrete use cases include validating real-number expressions during parsing and raising appropriate diagnostics for non-compliant constructs.",
      "description_length": 487,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dolmen_type.Arith.Smtlib2.Real_Int.Tff",
      "library": "dolmen_type",
      "description": "Handles parsing and type-checking of arithmetic expressions involving integers and real numbers according to SMT-LIB 2 specifications. It defines errors and warnings for invalid or non-conforming arithmetic expressions and ensures correct typing during parsing. Useful for validating mixed integer-real arithmetic in SMT solvers or formal verification tools.",
      "description_length": 358,
      "index": 1,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Dolmen_type.Arith.Smtlib2.Int.Tff",
      "library": "dolmen_type",
      "description": "This module implements type-checking and parsing for SMT-LIBv2 integer arithmetic expressions, enforcing strict or relaxed conformance based on provided configuration. It works with terms represented as `Dolmen.Std.Term.t`, leveraging type information from the `Type`, `Ty`, and `T` submodules to validate expressions against the SMT-LIBv2 specification. It is used to detect and report specification violations through dedicated warning and error types during the parsing of integer arithmetic constructs.",
      "description_length": 506,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dolmen_type.Arith.Zf.Thf",
      "library": "dolmen_type",
      "description": "Implements arithmetic operations over integers with support for parsing built-in symbols. Works with integer types and expressions defined through the `Type`, `Ty`, and `T` modules. Useful for formal verification tasks involving integer arithmetic, such as constraint solving or theorem proving.",
      "description_length": 295,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dolmen_type.Float.Smtlib2.Tff",
      "library": "dolmen_type",
      "description": "This module defines error types for invalid character parsing in binary, hexadecimal, and decimal formats, along with a `parse` function that processes SMT-LIB 2 floating-point literals based on the specified version. It operates on character input and integrates with term construction in the Type module. Concrete use cases include validating and parsing floating-point constants in SMT solvers or formal verification tools.",
      "description_length": 426,
      "index": 4,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Dolmen_type.Arith.Smtlib2.Real",
      "library": "dolmen_type",
      "description": "This module provides type-checking and parsing for real arithmetic expressions in SMT-LIBv2, ensuring compliance with the standard by handling warnings and errors. It operates on terms represented as `Dolmen.Std.Term.t`, integrating configuration settings to enforce strict or relaxed interpretations. It supports validating real-number expressions during parsing and diagnosing non-compliant constructs with concrete error reporting. Example use cases include checking the correctness of real-valued term syntax and ensuring proper handling of version-specific features.",
      "description_length": 571,
      "index": 5,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Dolmen_type.Core.Tptp.Tff",
      "library": "dolmen_type",
      "description": "Implements parsing of TPTP TFF (Typed First-Order Form) expressions, handling built-in types like \\$i (individuals) and \\$o (propositions). Provides the `parse` function to convert TPTP versioned input into typed expressions using the Type, Ty, and T modules for type representation and term construction. Useful for integrating TFF logic into theorem proving tools or formal verification systems.",
      "description_length": 397,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dolmen_type.Core.Zf.Tff",
      "library": "dolmen_type",
      "description": "Implements parsing and handling of SMT-LIB core theory builtins, including types, tags, and terms. Works with type representations, term structures, and symbol tables specific to SMT solving. Supports concrete operations like type inference, term normalization, and symbol resolution in SMT contexts.",
      "description_length": 300,
      "index": 7,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Dolmen_type.Core.Smtlib2.Tff",
      "library": "dolmen_type",
      "description": "This module defines built-in symbols and type-checking rules for SMT-LIB's core theory, handling terms, types, and attributes. It provides functions for parsing SMT-LIB expressions, managing type errors, and tracking inferred model constants. Concrete use cases include validating SMT-LIB input during parsing and enforcing correct term usage in logical expressions.",
      "description_length": 366,
      "index": 8,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Dolmen_type.Core.Tptp.Thf",
      "library": "dolmen_type",
      "description": "Implements parsing of TPTP THF (Typed Higher-Order Form) expressions, handling built-in types like \\$i, \\$o, and higher-order constructs. Works with type definitions, terms, and formulas in THF syntax. Useful for integrating THF-based logic inputs into theorem proving workflows.",
      "description_length": 279,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dolmen_type.Arith.Tptp.Tff",
      "library": "dolmen_type",
      "description": "Implements TPTP arithmetic type checking and parsing for first-order logic terms. Handles integer and real type validation, tracks arithmetic symbol applications, and raises precise errors for invalid operations like applying $quotient to integers. Used to enforce arithmetic constraints during logic term processing in TPTP TFF format.",
      "description_length": 336,
      "index": 10,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Dolmen_type.Bitv.Smtlib2.Bvconv",
      "library": "dolmen_type",
      "description": "Implements parsing of SMT-LIB 2 bitvector conversion operations for built-in types. Handles conversions between bitvectors and other domains like integers and booleans. Useful for interpreting bitvector literals and casts in SMT-LIB 2 input files.",
      "description_length": 247,
      "index": 11,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Dolmen_type.Strings.Smtlib2.Tff",
      "library": "dolmen_type",
      "description": "This module defines error types for invalid string literals and escape sequences, and provides a `parse` function to validate and process SMT-LIB 2 TFF (Typed First-Order Form) string terms. It operates on string and character data, integrating with term and type systems defined in the `Type`, `Ty`, and `T` submodules. It is used to handle string parsing and type checking in SMT-LIB 2 implementations.",
      "description_length": 404,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dolmen_type.Arrays.Smtlib2.Tff",
      "library": "dolmen_type",
      "description": "Implements parsing and validation of SMT-LIB 2.0 array expressions in TFF (Typed First-Formulas) logic, enforcing array sort restrictions and flagging use of extended array operations like `const`. Works with SMT-LIB terms, types, and identifiers, integrating array-specific error and warning handling during type checking. Useful for verifying array-based logical formulas in automated theorem proving tools.",
      "description_length": 409,
      "index": 13,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dolmen_type.Bitv.Ae.Tff",
      "library": "dolmen_type",
      "description": "Handles parsing and type-checking of bitvector literals and operations in Alt-Ergo's TFF (Typed First-Order Form) syntax. Works with bitvectors represented as strings of '0' and '1', and natural number literals. Used when processing input files containing bitvector constants or expressions expecting numeric arguments.",
      "description_length": 319,
      "index": 14,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Dolmen_type.Arith.Ae.Tff",
      "library": "dolmen_type",
      "description": "This module implements parsing and type-checking for arithmetic expressions in the TFF (Typed First-Form) logic. It ensures terms conform to expected arithmetic types (int or real) and reports errors when types mismatch. It works directly with term and type structures from the enclosing arithmetic module.",
      "description_length": 306,
      "index": 15,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Dolmen_type.Core.Dimacs.Tff",
      "library": "dolmen_type",
      "description": "This module defines built-in symbols for parsing TPTP's TFF (Typed First-Order Form) logic within the DIMACS framework. It works with type and term representations defined by the `Type` and `T` modules to support concrete syntax and semantic interpretations specific to TFF. It is used to implement parsers and type checkers for TFF formulas in formal verification tools.",
      "description_length": 371,
      "index": 16,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Dolmen_type.Core.Ae.Tff",
      "library": "dolmen_type",
      "description": "This module defines built-in symbols for TPTP's TFF logic, including operations for parsing and representing TFF expressions. It works with data types related to logical terms, types, and tags, specifically tailored for first-order logic with polymorphic extensions. Concrete use cases include parsing TFF formulas from input streams and constructing typed logical expressions for formal verification tasks.",
      "description_length": 407,
      "index": 17,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dolmen_type.Bitv.Smtlib2.Tff",
      "library": "dolmen_type",
      "description": "Implements SMT-LIB 2.0 bitvector operations for the TFF (Typed First-Order Form) logic, handling parsing and type checking of bitvector literals and operations. Defines error types for invalid bitvector sizes, extraction ranges, and malformed binary, hexadecimal, and decimal characters. Provides the `parse` function to integrate bitvector builtins into a SMT-LIB version-specific symbol table.",
      "description_length": 395,
      "index": 18,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Dolmen_type.Arith.Smtlib2.Real_Int",
      "library": "dolmen_type",
      "description": "This module provides facilities for parsing and validating arithmetic expressions that mix integers and real numbers, adhering to the SMT-LIB 2 standard. It defines core data types representing arithmetic expressions, integers, and real numbers, along with operations for type checking and error reporting during parsing. The module ensures correct typing and conformance to the expected semantics of mixed integer-real arithmetic. For example, it can validate expressions like `(+ 3.5 x)` where `x` must be a real number, or flag type mismatches in expressions like `(* 2 i)` where `i` is incorrectly declared as a real.",
      "description_length": 621,
      "index": 19,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dolmen_type.Arrays.Ae.Tff",
      "library": "dolmen_type",
      "description": "Implements array operations for the TFF logic, handling array construction and access with fixed arities. Works with array types parameterized by one or two arguments, enforcing correct usage through error reporting. Useful for formal verification tasks involving array manipulation in TFF formulas.",
      "description_length": 299,
      "index": 20,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dolmen_type.Arith.Smtlib2.Int",
      "library": "dolmen_type",
      "description": "This module provides type-checking and parsing for SMT-LIBv2 integer arithmetic expressions, validating terms against the specification using type information from associated submodules. It supports strict or relaxed conformance modes and reports violations through dedicated error and warning types. It operates on terms represented as `Dolmen.Std.Term.t`, enabling detection of specification deviations during parsing. Example usage includes validating integer expressions like `(+ x 1)` or detecting type mismatches in arithmetic operations.",
      "description_length": 544,
      "index": 21,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dolmen_type.Core.Zf",
      "library": "dolmen_type",
      "description": "This module provides infrastructure for working with SMT-LIB core theory constructs, enabling parsing, type inference, and term manipulation in SMT contexts. It defines data types for SMT terms, types, and symbol tables, along with operations for normalization, symbol resolution, and term construction. You can use it to process SMT-LIB input, analyze term structures, or build custom SMT-based tools. For example, it supports parsing an SMT term, inferring its type, and normalizing it for further processing.",
      "description_length": 511,
      "index": 22,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Dolmen_type.Bitv.Ae",
      "library": "dolmen_type",
      "description": "This module processes bitvector literals and operations in Alt-Ergo's TFF syntax, converting string representations of binary numbers and natural number literals into typed expressions. It supports parsing and type-checking for bitvector constants and numeric expressions, ensuring correct usage in logical formulas. For example, it interprets `\"0110\"` as a bitvector or `42` as a numeric argument in bitvector operations. Key operations include parsing, type validation, and literal conversion for use in theorem proving tasks.",
      "description_length": 528,
      "index": 23,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Dolmen_type.Tff_intf.S-T-Cstr",
      "library": "dolmen_type",
      "description": "This module handles algebraic datatype constructors, providing operations to retrieve their types, compare them, and determine argument types during pattern matching. It works with type representations and constructor symbols. It is used to validate and type-check constructor applications in functional patterns.",
      "description_length": 313,
      "index": 24,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dolmen_type.Tff_intf.S",
      "library": "dolmen_type",
      "description": "This module provides a typechecking framework for formal logic systems, enabling first- and higher-order type inference, polymorphism handling, and context-sensitive symbol resolution. It operates on environments, logical terms, and types from the Dolmen library, with operations for error reporting (e.g., arity mismatches, shadowing), binding management, and monomorphization. Designed for theorem proving and formal verification, it supports type-safe declaration of symbols, implicit definitions, and location-aware term analysis in logical contexts.",
      "description_length": 554,
      "index": 25,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Dolmen_type.Tff.Make",
      "library": "dolmen_type",
      "description": "This module provides typechecking and term processing capabilities for TFF syntax, supporting first-order and higher-order inference with explicit, implicit, and flexible polymorphism. It operates on environments, typed terms, and symbolic bindings to enable structured resolution of variables, constants, and builtins while producing rich diagnostic context for errors, warnings, and semantic checks in formal logic systems. Key use cases include theorem proving, formal verification, and handling polymorphic declarations with arity constraints or pattern-matching constructs.",
      "description_length": 578,
      "index": 26,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dolmen_type.Tff_intf.S-Ty-Const",
      "library": "dolmen_type",
      "description": "This module manages constant symbols used in type definitions, providing operations to create, compare, and annotate these constants. It supports data types such as `t` for representing type constants, along with tags for attaching metadata. Concrete use cases include building and manipulating type-level constants during type checking, such as associating arities or custom data with type symbols.",
      "description_length": 399,
      "index": 27,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dolmen_type.Thf_intf.S-T",
      "library": "dolmen_type",
      "description": "This module enables the construction and manipulation of typechecked higher-order logic terms, including variables, constants, algebraic datatypes, and records, with support for polymorphic application, logical primitives, and type annotations. It facilitates quantification over variables, binding expressions, let-bindings (sequential and parallel), pattern matching, and formula tagging, operating on logical formulas and polymorphic terms. These capabilities are applied in formal verification, automated reasoning, and defining complex data structures with rigorous type guarantees.",
      "description_length": 587,
      "index": 28,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Dolmen_type.Logic.Smtlib2",
      "library": "dolmen_type",
      "description": "This module defines data structures and operations for representing and manipulating SMT-LIB 2 logics, including theory combinations and feature sets with arithmetic, arrays, and quantifiers. It provides parsing of logic strings into structured representations and comprehensive printing functions for output formatting. Use cases include logic specification in SMT solvers and validation of supported features in SMT-LIB scripts.",
      "description_length": 430,
      "index": 29,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dolmen_type.Thf_intf.S-Tag",
      "library": "dolmen_type",
      "description": "This module provides a function to create a new tag with an optional pretty-printing configuration. It operates on generic type `'a` and is used to generate tagged values within the typechecking process. Concrete use cases include attaching metadata or identifiers to expressions during type inference and error reporting.",
      "description_length": 322,
      "index": 30,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dolmen_type.Tff_intf.S-T",
      "library": "dolmen_type",
      "description": "This module enables the creation and manipulation of typed first-order polymorphic terms, supporting algebraic datatypes with destructors, record definitions, logical conjunctions, and lambda abstractions. It operates on terms, type variables, constants, constructors, and fields to facilitate type checking, quantified logical expressions, and structured bindings like let-expressions or pattern matching. It is particularly suited for formal verification tasks requiring precise type handling and logical reasoning over polymorphic term structures.",
      "description_length": 550,
      "index": 31,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Dolmen_type.Misc.Lists",
      "library": "dolmen_type",
      "description": "This module provides list manipulation functions such as creating lists with computed values, replicating elements, splitting lists at a given index, and iterating or mapping over three lists in parallel. It supports standard list types and tuples, enabling precise list transformations and combinations not covered by older OCaml standard libraries. Specific use cases include generating indexed lists, handling triplets, and performing parallel folds and splits for data processing tasks.",
      "description_length": 490,
      "index": 32,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dolmen_type.Arrays.Ae",
      "library": "dolmen_type",
      "description": "This module provides array operations for the TFF logic, supporting construction, access, and arity validation for parameterized array types. It includes data types for arrays with one or two arguments and operations to manipulate and verify array expressions. You can create arrays, access elements, and enforce correct arity usage in TFF formulas. For example, it ensures proper indexing and reports errors for mismatched array arities during manipulation.",
      "description_length": 458,
      "index": 33,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dolmen_type.Core.Ae",
      "library": "dolmen_type",
      "description": "This module provides built-in symbols and operations for working with TPTP's TFF logic, focusing on parsing and representing logical expressions with support for polymorphic types. It operates on data structures representing logical terms, types, and tags, enabling the construction and manipulation of typed first-order formulas. You can use it to parse TFF expressions from input streams, build logical terms programmatically, or prepare expressions for formal verification workflows.",
      "description_length": 486,
      "index": 34,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dolmen_type.Tff_intf.S-T-Field",
      "library": "dolmen_type",
      "description": "This module defines operations for comparing constant symbols within a typechecked TFF (Typed First-Formulas) context. It works with the abstract type `t` representing constant symbols and provides a total ordering function `compare` that determines equivalence or precedence between two symbols. Concrete use cases include sorting or deduplicating collections of constant symbols during typechecking or formula normalization.",
      "description_length": 426,
      "index": 35,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Dolmen_type.Tff_intf.S-T-Var",
      "library": "dolmen_type",
      "description": "This module manages typed variables in terms, providing operations to create variables with associated types, retrieve and compare variables, and manipulate metadata via tags. It supports concrete use cases like tracking variable bindings during typechecking and attaching auxiliary information for term transformations. The primary data type is `t`, representing term variables, along with operations for tag-based metadata management.",
      "description_length": 436,
      "index": 36,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Dolmen_type.Misc.Bitv",
      "library": "dolmen_type",
      "description": "This module provides functions to parse and validate bitvector literals in binary, hexadecimal, and decimal formats. It operates on strings representing bitvectors and converts them into their corresponding binary form. Concrete use cases include parsing SMT-LIB-style bitvector constants like `#b1010`, `#x1a`, or `bv123` into raw binary strings for further processing.",
      "description_length": 370,
      "index": 37,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dolmen_type.Thf_intf.S-Ty-Var",
      "library": "dolmen_type",
      "description": "This module manages type variables, including named variables and wildcards, with operations to create, compare, and print them. It supports attaching and retrieving tagged values to variables, enabling contextual metadata storage. Concrete use cases include tracking type variables during typechecking and associating constraints or annotations with specific variables.",
      "description_length": 370,
      "index": 38,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dolmen_type.Core.Dimacs",
      "library": "dolmen_type",
      "description": "This module integrates TFF logic parsing into the DIMACS framework by defining built-in symbols that align with TFF's type and term structures. It leverages the `Type` and `T` modules to represent and manipulate TFF expressions, enabling the construction of parsers and type checkers for formal verification. For example, it allows parsing TFF formulas into typed terms and validating their semantic consistency within a verification pipeline.",
      "description_length": 443,
      "index": 39,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dolmen_type.Thf_intf.S-T-Const",
      "library": "dolmen_type",
      "description": "This module manages constant symbols in terms, providing operations to create constants with associated types and paths, retrieve their types, and tag them with arbitrary values. It supports comparison and printing of constants, enabling precise manipulation and inspection of term-level constants during typechecking. Concrete use cases include symbol registration in a typechecker, tracking constant metadata, and facilitating term pretty-printing and equality checks.",
      "description_length": 470,
      "index": 40,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dolmen_type.Tff_intf.S-Tag",
      "library": "dolmen_type",
      "description": "This module provides a single operation, `create`, which generates a new tag value of type `'a Tag.t`, optionally taking a pretty-printing function. It works with the `Tag.t` type, which is used to uniquely identify and manage typechecker state within the TFF interface. A concrete use case is initializing fresh type variables or constraints during type inference or checking processes.",
      "description_length": 387,
      "index": 41,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dolmen_type.Tff_intf.S-T-Const",
      "library": "dolmen_type",
      "description": "This module implements operations for creating, tagging, and comparing constant symbols in terms, including functions to retrieve their type and print them. It works with constant symbols represented as type `t`, along with associated types like `Ty.t` for types and `Dolmen.Std.Path.t` for paths. Concrete use cases include constructing typed constants during term processing and attaching metadata via tags for analysis or debugging.",
      "description_length": 435,
      "index": 42,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dolmen_type.Strings.Smtlib2",
      "library": "dolmen_type",
      "description": "This module handles parsing and validation of SMT-LIB 2 string literals, including error handling for invalid escape sequences. It defines core data types for representing string terms and integrates with the type system to ensure correctness during parsing. The `parse` function processes string and character input into typed terms, supporting operations like escape sequence resolution and type assignment. It enables robust construction and validation of string expressions within SMT-LIB 2 implementations.",
      "description_length": 511,
      "index": 43,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Dolmen_type.Thf_intf.S-T-Var",
      "library": "dolmen_type",
      "description": "This module handles typed term variables with operations to create, compare, and manage tags. It works with variables represented by the type `t`, each associated with a type from `Ty.t` and optional tag values. Concrete use cases include constructing typed variables with `mk`, retrieving type information with `ty`, and attaching or querying metadata using `set_tag`, `get_tag`, and `unset_tag`.",
      "description_length": 397,
      "index": 44,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Dolmen_type.Def.Subst_arg",
      "library": "dolmen_type",
      "description": "Implements substitution operations over types and terms using variable-value mappings. It provides functions to replace type variables with types and term variables with terms within a given type or term structure. This is useful for tasks like type inference, term rewriting, or implementing substitution-based logic operations.",
      "description_length": 329,
      "index": 45,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dolmen_type.Core.Tptp",
      "library": "dolmen_type",
      "description": "This module provides parsers for TPTP's TFF and THF logical forms, handling built-in types like \\$i (individuals) and \\$o (propositions), along with typed term and formula construction. It supports both first-order and higher-order logic inputs, enabling integration into theorem provers or formal verification tools. The `parse` function converts versioned TPTP input into typed expressions using internal type and term modules. Example uses include processing TFF/THF files for automated reasoning or logic-based analysis tasks.",
      "description_length": 530,
      "index": 46,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dolmen_type.Core.Smtlib2",
      "library": "dolmen_type",
      "description": "This module translates S-expressions into terms and sorts following the SMT-LIB standard, integrating directly with Dolmen's internal representations for logical expressions. It supports parsing, type-checking, and validation of SMT-LIB input, including built-in symbols and core theory rules. Key operations include converting S-expressions to typed terms, handling attributes, and resolving model constants during parsing. Example uses include building custom SMT solvers, validating input files, and manipulating SMT-LIB expressions programmatically.",
      "description_length": 553,
      "index": 47,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dolmen_type.Bitv.Smtlib2",
      "library": "dolmen_type",
      "description": "This module provides parsing and type-checking functionality for SMT-LIB 2 bitvector operations, supporting conversions between bitvectors and other types such as integers and booleans. It defines core data types like bitvectors with fixed sizes and operations for parsing literals in binary, hexadecimal, and decimal formats, along with error handling for invalid sizes and ranges. The module includes a `parse` function that integrates bitvector builtins into a version-specific symbol table, enabling interpretation of bitvector expressions in TFF logic. Example uses include processing SMT-LIB input with bitvector casts and detecting malformed literals during parsing.",
      "description_length": 673,
      "index": 48,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Dolmen_type.Intf.Formulas",
      "library": "dolmen_type",
      "description": "This module supports typechecking logic-based systems through operations like polymorphic type inference, symbol resolution, and semantic tagging, handling complex constructs such as wildcards and higher-order terms. It works with environments tracking declarations, definitions, and bindings, alongside structured types (`ty`, `term`, `binding`) and error diagnostics for arity mismatches or shadowing. Designed for formal verification contexts, it enables robust type manipulation, parsing of logical formulas, and error recovery in theorem proving or constraint-solving systems.",
      "description_length": 581,
      "index": 49,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dolmen_type.Thf_intf.S-T-Cstr",
      "library": "dolmen_type",
      "description": "This module defines algebraic datatype constructors with operations to retrieve their type, compare symbols, and determine argument types during pattern matching. It works with type-checked constants and their associated types. Concrete use cases include constructing and validating typed expressions in a typechecker for a logic or programming language.",
      "description_length": 354,
      "index": 50,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dolmen_type.Arith.Tptp",
      "library": "dolmen_type",
      "description": "This module provides arithmetic type checking and parsing for first-order logic terms in the TPTP format. It validates integer and real types, tracks arithmetic symbol applications, and raises precise errors for invalid operations, such as using $quotient with integers. It enforces arithmetic constraints during term processing in TPTP TFF. Example uses include validating $sum on integers and detecting type mismatches in $less comparisons.",
      "description_length": 442,
      "index": 51,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dolmen_type.Arrays.Smtlib2",
      "library": "dolmen_type",
      "description": "This module defines configurations for SMT-LIB array builtins and provides a function to print these configurations. It works with the `config` type, which represents different sets of array theories supported by SMT solvers, allowing users to specify and output array theory configurations when interfacing with SMT solvers using the SMT-LIB standard. The child module handles parsing and validation of SMT-LIB 2.0 array expressions in TFF logic, enforcing array sort restrictions and flagging extended operations like `const`. Together, they enable precise control and verification of array-based logical formulas in automated theorem proving tools.",
      "description_length": 651,
      "index": 52,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dolmen_type.Arith.Zf",
      "library": "dolmen_type",
      "description": "This module provides arithmetic operations over integers, including parsing of built-in symbols, and integrates with type definitions from the `Type`, `Ty`, and `T` modules. It supports formal verification tasks such as constraint solving and theorem proving by enabling manipulation of integer expressions and typed arithmetic. Operations include addition, multiplication, and symbolic evaluation, with examples like evaluating `2 + 3` or verifying properties of expressions such as `x + 0 = x`.",
      "description_length": 496,
      "index": 53,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dolmen_type.Misc.Strings",
      "library": "dolmen_type",
      "description": "This module provides two operations: `to_list`, which converts a string into a list of characters, and `is_suffix`, which checks if one string is a suffix of another. It works directly with string and list data types. These functions are useful for string manipulation tasks such as parsing or validating string formats.",
      "description_length": 320,
      "index": 54,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dolmen_type.Arith.Smtlib2",
      "library": "dolmen_type",
      "description": "This module configures arithmetic solving for integers and real numbers in SMT-LIBv2, coordinating type-checking, parsing, and validation across its submodules. It defines core data types for arithmetic expressions and operations that support strict or relaxed conformance to the standard, handling terms represented as `Dolmen.Std.Term.t`. The module enables tasks like validating mixed integer-real expressions, checking syntax correctness, and enforcing semantic rules during parsing. Specific examples include verifying expressions like `(+ x 1)` for integers or flagging type mismatches in `(* 2 i)` where `i` is incorrectly typed as a real.",
      "description_length": 646,
      "index": 55,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Dolmen_type.Def.Declare",
      "library": "dolmen_type",
      "description": "This module handles the declaration and definition of type and term constants within a type environment. It provides operations to add declarations, define type constants with their parameters, and define term constants with type and term variables. These functions are used to extend the environment with new symbols during type checking or parsing of formal languages.",
      "description_length": 370,
      "index": 56,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dolmen_type.Float.Smtlib2",
      "library": "dolmen_type",
      "description": "This module handles parsing and validation of SMT-LIB 2 floating-point literals, supporting binary, hexadecimal, and decimal formats. It defines error types for invalid character sequences and provides a `parse` function that processes character input and constructs typed terms. Users can validate and convert floating-point constants for use in SMT solvers or formal verification systems. For example, it can parse `\"#x1p+0\"` into a normalized floating-point value or reject malformed inputs like `\"#b2\"` with a descriptive error.",
      "description_length": 532,
      "index": 57,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Dolmen_type.Arith.Ae",
      "library": "dolmen_type",
      "description": "This module provides arithmetic expression parsing and type-checking for the TFF logic, ensuring terms match expected types like int or real. It operates on term and type structures, validating expressions and reporting type mismatches. For example, it can verify that addition applies to compatible numeric types or flag errors in ill-typed expressions. Key operations include parsing input strings into typed terms and checking type consistency during arithmetic operations.",
      "description_length": 476,
      "index": 58,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dolmen_type.Thf_intf.S",
      "library": "dolmen_type",
      "description": "This module provides type inference, term validation, binding resolution, and error handling for higher-order logic systems, with support for polymorphism control, wildcard management, and environment customization. It operates on environments, terms, types, declarations, and bindings, enabling tasks like symbol resolution, monomorphization, and fragment parsing in logical contexts. Use cases include implementing THF typecheckers, validating logical formulas, managing declarations with precise diagnostics, and resolving type inconsistencies in polymorphic or higher-order settings.",
      "description_length": 587,
      "index": 59,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dolmen_type.Tff_intf.S-Ty",
      "library": "dolmen_type",
      "description": "This module implements a typechecker for TFF (Typed First-Formulas) logic, providing operations to construct, manipulate, and analyze types. It supports type construction via application, arrow, and polymorphic (pi) types, along with variable and constant handling through submodules. Concrete use cases include type checking logical expressions, managing type variables with wildcards, and annotating types with metadata tags during theorem proving or type inference tasks.",
      "description_length": 474,
      "index": 60,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dolmen_type.Misc.Options",
      "library": "dolmen_type",
      "description": "This module provides functions for mapping over option values, allowing transformations of optional data. It supports operations that apply functions to values wrapped in `option` types, handling the presence or absence of values seamlessly. Useful in scenarios where computations depend on optional inputs, such as parsing or configuration processing.",
      "description_length": 352,
      "index": 61,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dolmen_type.Thf_intf.S-Ty",
      "library": "dolmen_type",
      "description": "This module represents a type system for higher-order logic, providing operations to construct and manipulate types, including function types, polymorphic types, and type applications. It supports type equality checks, wildcard handling, and tagging for annotations, working with types built from variables, constants, arrows, and pi types. Concrete use cases include type inference, type checking, and representation of logical propositions and polymorphic functions.",
      "description_length": 468,
      "index": 62,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dolmen_type.Def.Subst",
      "library": "dolmen_type",
      "description": "This module substitutes type and term definitions during type-checking by expanding them into their bodies. It operates on type and term variables, identifiers, and environments, using definitions stored in the environment to resolve symbols. Concrete use cases include expanding type synonyms and inlining term constants during type inference.",
      "description_length": 344,
      "index": 63,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dolmen_type.Thf_intf.S-T-Field",
      "library": "dolmen_type",
      "description": "This module defines operations for comparing constant symbols within a typechecked THF (Typed Higher-Order Form) context. It works with the `T.Field.t` type, representing fields or constant symbols in the logic. Concrete use cases include ordering constants during proof search or term normalization in automated theorem proving.",
      "description_length": 329,
      "index": 64,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dolmen_type.Thf_intf.S-Ty-Const",
      "library": "dolmen_type",
      "description": "This module manages constant symbols used in type definitions, providing operations to create, compare, and print these constants. It supports tagged data through functions to set or add values to tags, working with type constants that have a defined arity. Concrete use cases include representing and manipulating type-level constants in a typechecker, such as built-in types or user-defined type symbols with associated metadata.",
      "description_length": 431,
      "index": 65,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Dolmen_type.Tff_intf.S-Ty-Var",
      "library": "dolmen_type",
      "description": "This module manages type variables with operations to create, compare, and manipulate variables, including support for wildcards and tagged data. It provides functions to set, get, and unset values associated with tags on variables, enabling contextual metadata storage. Concrete use cases include tracking type variable bindings during typechecking and managing variable-specific annotations in type inference algorithms.",
      "description_length": 422,
      "index": 66,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dolmen_type.Arrays",
      "library": "dolmen_type",
      "description": "This module combines array logic for TFF with SMT-LIB array configurations, enabling construction, validation, and manipulation of array expressions with strict arity and sort enforcement. It supports array types with one or two arguments, operations for element access and const expressions, and configurable array theories for SMT solvers. Users can create and validate array expressions, ensure correct indexing, and output SMT-LIB compliant array configurations. Example uses include building parameterized arrays, checking arity during access, and configuring SMT solvers to support specific array theories.",
      "description_length": 612,
      "index": 67,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dolmen_type.Misc",
      "library": "dolmen_type",
      "description": "This module combines utilities for list manipulation, bitvector parsing, string operations, and option mapping. It offers data transformations on lists, strings, and optional values, along with bitvector literal decoding. Examples include generating indexed lists, converting SMT-LIB bitvectors to binary, checking string suffixes, and safely applying functions to optional values. Key data types are lists, strings, and options, with operations like parallel mapping, suffix checking, and bitvector parsing.",
      "description_length": 508,
      "index": 68,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dolmen_type.Thf_intf",
      "library": "dolmen_type",
      "description": "This module defines the interface for an external typechecker in a THF logic context, enabling type checking and inference over logical expressions with support for polymorphism, binding, and type annotations. It provides core operations to construct and manipulate typechecked terms, manage type variables and constants, and perform type inference with precise error handling, all while allowing integration of custom typechecking logic into formal verification workflows. The interface supports building and validating higher-order terms with let-bindings, pattern matching, and tagged metadata, while submodules handle specific tasks like symbol comparison, type construction, and environment management. Examples include validating THF formula types, resolving polymorphic symbols, and attaching annotations to variables or constants during proof system development.",
      "description_length": 870,
      "index": 69,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dolmen_type.Arith",
      "library": "dolmen_type",
      "description": "This module handles arithmetic type-checking, parsing, and evaluation across multiple formats including TPTP TFF and SMT-LIBv2. It defines core data types for arithmetic expressions and operations such as addition, multiplication, and comparison, enforcing correct usage of types like integers and reals. It supports symbolic manipulation, constraint solving, and formal verification tasks by validating expressions like `x + 0 = x` or detecting type mismatches in invalid operations. Examples include evaluating integer expressions, verifying arithmetic properties, and parsing and checking well-formed terms like `(+ x 1)` or `$sum(2, 3)`.",
      "description_length": 641,
      "index": 70,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Dolmen_type.Strings",
      "library": "dolmen_type",
      "description": "This module provides functionality for parsing and validating SMT-LIB 2 string literals, ensuring correct handling of escape sequences and type assignment. It defines core data types representing string terms and supports operations such as parsing character and string input into typed terms. The module integrates with the type system to enforce correctness during parsing and includes error handling for invalid input. For example, it can resolve escape sequences in string literals and construct validated string expressions for use in SMT solvers.",
      "description_length": 552,
      "index": 71,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Dolmen_type.Intf",
      "library": "dolmen_type",
      "description": "This module provides the interface for an instantiated typechecker, centered around the `symbol` type and the `Formulas` module type, which together enable the representation and manipulation of logical formulas and symbols in typechecking processes. It supports operations such as polymorphic type inference, symbol resolution, and semantic tagging, working with structured types like `ty`, `term`, and `binding` to manage environments and declarations. The module facilitates concrete tasks such as implementing typechecking logic for terms, parsing logical formulas, and handling errors like arity mismatches in theorem proving or constraint-solving systems. Its submodules extend these capabilities to support complex constructs such as wildcards and higher-order terms while ensuring robust type manipulation and error recovery.",
      "description_length": 833,
      "index": 72,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dolmen_type.Tff",
      "library": "dolmen_type",
      "description": "This module enables typechecking and term processing for TFF syntax, supporting first-order and higher-order inference with various polymorphism styles. It works with environments, typed terms, and symbolic bindings to resolve variables, constants, and builtins, while generating detailed diagnostics for errors and semantic checks. It facilitates tasks like theorem proving, formal verification, and handling polymorphic declarations with arity constraints. Example uses include validating logical expressions, checking polymorphic function applications, and resolving symbolic references in formal proofs.",
      "description_length": 607,
      "index": 73,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Dolmen_type.Def",
      "library": "dolmen_type",
      "description": "This module manages the declaration, substitution, and expansion of symbols within a type-checking or formal verification context. It provides core data types for representing type and term variables, constants, and environments, along with operations to define, substitute, and resolve these symbols. The substitution submodule replaces variables with values in types and terms, the declaration submodule extends environments with new constants, and the expansion submodule inlines definitions during type checking. Examples include resolving bound variables in logical expressions, rewriting terms during inference, and expanding type synonyms using stored environment data.",
      "description_length": 676,
      "index": 74,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dolmen_type.Thf",
      "library": "dolmen_type",
      "description": "This module enables typechecking of untyped terms from a standard syntax tree, ensuring correctness by verifying type consistency during evaluation. It introduces key data types such as `term`, `type_env`, and `typ` to represent expressions, typing environments, and type annotations, respectively. Core operations include `typecheck`, which infers and validates the type of a given term within a context, and `typeof`, which returns the explicit type of a well-formed term. For example, applying `typecheck` to a lambda expression confirms its function type, while using `typeof` on a numeral yields its inferred integer type.",
      "description_length": 627,
      "index": 75,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dolmen_type.Core",
      "library": "dolmen_type",
      "description": "This module enables processing and manipulation of logical expressions across SMT-LIB and TPTP formats, supporting both first-order and higher-order logic. It defines core data types for terms, types, and symbols, along with operations for parsing, type inference, normalization, and validation. Built-in parsers handle SMT-LIB S-expressions and TPTP TFF/THF logic, enabling tasks like input validation, custom solver development, and formal verification pipelines. Example uses include parsing and normalizing SMT terms, constructing typed logical expressions, and integrating TFF logic into DIMACS-based workflows.",
      "description_length": 616,
      "index": 76,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Dolmen_type.Logic",
      "library": "dolmen_type",
      "description": "This module provides a polymorphic type `t` to represent either default or specific Smtlib2 logic variants, enabling tools to handle logic specifications for type-checking and solving in SMT languages. It supports parsing and printing of logic strings, along with reasoning about logical fragments in problem files. The child module extends this functionality by structuring SMT-LIB 2 logics with support for theory combinations, arithmetic, arrays, and quantifiers. Together, they allow precise validation and manipulation of logic features in SMT solvers and script processing.",
      "description_length": 579,
      "index": 77,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Dolmen_type.Tff_intf",
      "library": "dolmen_type",
      "description": "This module provides the interface for an instantiated typechecker operating in a TFF logic context, enabling type checking and inference over logical expressions and environments. It coordinates with submodules to handle algebraic datatypes, polymorphic terms, and type constants, supporting operations like type validation, symbol resolution, and term analysis. Key data types include typed variables, constants, constructors, and polymorphic type structures, with operations for comparison, creation, tagging, and type inference. Specific capabilities include checking constructor applications, managing type variables with metadata, building typed terms with destructors or lambda abstractions, and integrating type checking into theorem proving workflows with context-sensitive error reporting and monomorphization.",
      "description_length": 820,
      "index": 78,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dolmen_type.Float",
      "library": "dolmen_type",
      "description": "This module processes SMT-LIB 2 floating-point literals in binary, hexadecimal, and decimal formats, converting them into normalized values or reporting errors for invalid sequences. It provides a `parse` function that takes string input and returns either a typed floating-point term or an error indicating malformed syntax. Key data types include the parsed floating-point representation and error variants for invalid characters or formats. For example, it converts `\"#x1p+0\"` into a valid float or rejects `\"#b2\"` with a specific error.",
      "description_length": 540,
      "index": 79,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dolmen_type.Bitv",
      "library": "dolmen_type",
      "description": "This module processes bitvector literals and operations across TFF and SMT-LIB 2 syntaxes, converting string and numeric representations into typed expressions for formal verification. It defines fixed-size bitvectors and supports parsing in binary, hexadecimal, and decimal formats, along with conversions to and from integers and booleans. Key operations include parsing, type validation, and error handling for invalid sizes or ranges, enabling tasks like interpreting `\"0110\"` as a bitvector or processing SMT-LIB input with bitvector casts. Example uses include converting `42` into a typed bitvector argument and detecting malformed literals during theorem proving.",
      "description_length": 671,
      "index": 80,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dolmen_type",
      "library": "dolmen_type",
      "description": "This collection implements a comprehensive type-checking and expression manipulation framework for formal verification and SMT solver integration. It centers on data types like `term`, `type_env`, `ty`, and `symbol`, supporting operations for arithmetic, arrays, bitvectors, strings, and higher-order logic across SMT-LIB, TPTP TFF, and THF formats. Users can validate polymorphic expressions, parse and evaluate literals, resolve symbols, and configure logic theories for solvers. Specific tasks include typechecking lambda expressions, normalizing SMT terms, expanding type synonyms, and converting bitvector or floating-point literals into typed terms with error handling.",
      "description_length": 675,
      "index": 81,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 84,
    "meaningful_modules": 82,
    "filtered_empty_modules": 2,
    "retention_rate": 0.9761904761904762
  },
  "statistics": {
    "max_description_length": 870,
    "min_description_length": 247,
    "avg_description_length": 479.0365853658537,
    "embedding_file_size_mb": 0.298309326171875
  }
}