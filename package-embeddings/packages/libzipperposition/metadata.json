{
  "package": "libzipperposition",
  "embedding_model": "Qwen/Qwen3-Embedding-8B",
  "embedding_dimension": 4096,
  "total_modules": 269,
  "creation_timestamp": "2025-08-18T20:43:15.861699",
  "modules": [
    {
      "module_path": "Libzipperposition_avatar.UnionFind.Make",
      "library": "libzipperposition.avatar",
      "description": "Implements a union-find data structure with monoidal value aggregation for managing equivalence classes of keys. It supports operations like creating a new structure from a list of keys, finding class representatives, merging classes, and adding values to classes. Useful for tasks like unification in term rewriting or merging constraints in type inference.",
      "description_length": 358,
      "index": 0,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_avatar.UnionFind",
      "library": "libzipperposition.avatar",
      "description": "Implements a union-find data structure with monoidal value aggregation for managing equivalence classes of hashable keys. It supports creating a structure from keys, finding class representatives, merging classes, and combining values across merges. Useful for unification in term rewriting or constraint merging in type inference.",
      "description_length": 331,
      "index": 1,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_avatar.Make",
      "library": "libzipperposition.avatar",
      "description": "This module supports splitting clauses into logical components, validating satisfiability constraints, and managing lemma lifecycles through addition, implication definitions, and inference rule integration. It operates on clauses, trails, SAT solvers, and lemma sets, with mechanisms to trigger actions when new lemmas are introduced. These capabilities enable theorem proving workflows that combine clause transformation, proof generation, and logical reasoning through lemma-driven inferences.",
      "description_length": 496,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_avatar",
      "library": "libzipperposition.avatar",
      "description": "Implements splitting and SAT integration for clause management using trails to track clause activity. Uses union-find with monoidal aggregation to handle equivalence classes of hashable keys, enabling efficient merging and value combination during term rewriting or constraint solving. Enables Avatar-style splitting in theorem proving by associating clauses with trails and managing their activation based on SAT solver feedback.",
      "description_length": 430,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Env.Make.ProofState.SubsumptionIndex.C",
      "library": "libzipperposition",
      "description": "This module defines operations for comparing clauses, iterating over their literals, and retrieving associated integer labels. It works directly with clause data structures, providing concrete access to their components for indexing and subsumption checks. Use cases include efficient clause subsumption testing and literal-based indexing in automated theorem proving.",
      "description_length": 368,
      "index": 4,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.Env.Make.FormRename.Ctx.Lit",
      "library": "libzipperposition",
      "description": "This module manages bidirectional conversions between literals and formulas using customizable hooks. It provides functions to register and retrieve conversion hooks, ensuring atomic formulas can be safely transformed into literals and vice versa. Concrete use cases include integrating custom term representations with theorem proving engines or transforming logical expressions during proof search.",
      "description_length": 400,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Env.Make.Stm.Ctx.Lit",
      "library": "libzipperposition",
      "description": "This module manages bidirectional conversions between literals and their formula representations using customizable hooks. It provides functions to register and retrieve conversion hooks for transforming literals to and from terms, supporting dynamic extensions to the conversion process. The primary data types involved are `Logtk.Literal.t` and `Logtk.Term.t Logtk.SLiteral.t`, with concrete use cases in parsing and pretty-printing logical formulas during theorem proving tasks.",
      "description_length": 481,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Env.Make.ProofState.UnitIndex.E",
      "library": "libzipperposition",
      "description": "This module represents and compares indexed equations with their associated terms, signs, and clauses. It provides operations to extract components of equations, compare them for ordering, and determine their priority in a proof state. It is used to manage and manipulate equations during automated theorem proving processes.",
      "description_length": 325,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Env.Make.ProofState.TermIndex.Leaf",
      "library": "libzipperposition",
      "description": "This module implements a term index structure that supports efficient insertion, removal, and querying of logical terms paired with associated elements. It provides operations for exact matching, unification, and substitution-based matching against indexed terms, enabling use cases such as automated theorem proving and term rewriting. The structure works directly with logical terms from `Logtk.Index_intf` and scoped terms from `Logtk.Scoped`, handling unification with `Logtk.Unif_subst` and substitution tracking.",
      "description_length": 518,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Env.Make.ProofState.CQueue.PriorityFun",
      "library": "libzipperposition",
      "description": "Implements priority functions for clause selection in proof search. It maps clauses to integer priorities, guiding the order of processing in automated theorem proving. Useful for defining custom clause weighting schemes based on syntactic features.",
      "description_length": 249,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Env.Make.ProofState.CQueue.WeightFun",
      "library": "libzipperposition",
      "description": "This module defines weight functions for prioritizing clauses in a proof state's priority queue. It operates on clause data structures, computing integer weights based on clause properties like penalty, goal proximity, and syntactic characteristics (e.g., presence of negative literals or Horn clauses). Use cases include guiding clause selection during automated theorem proving by favoring specific clause types or combining multiple heuristics for tailored prioritization.",
      "description_length": 475,
      "index": 10,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Env.Make.ProofState.CQueue.C",
      "library": "libzipperposition",
      "description": "This module provides operations for managing and analyzing logical clauses in automated reasoning systems, focusing on flag manipulation, redundancy checks, structural comparisons, and metadata management like penalties or weights. It operates on clause data structures with support for trails, proofs, and substitutions, enabling tasks such as literal eligibility analysis for resolution/paramodulation, groundness checks, and clause normalization. Specific use cases include prioritizing clauses in theorem proving loops, validating proof steps, and transforming clauses for TSTP output or debugging.",
      "description_length": 602,
      "index": 11,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Env.Make.StmQ.WeightFun",
      "library": "libzipperposition",
      "description": "This module defines weight functions that assign integer weights to streams of statements. It includes operations to retrieve a penalty value for a stream and to combine multiple weighted functions into a single function using a weighted sum. These functions are used to prioritize or evaluate streams based on customizable numeric criteria.",
      "description_length": 341,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Env.Make.ProofState.SimplSet",
      "library": "libzipperposition",
      "description": "This module manages a dynamic set of clauses with support for adding and removing clauses, while providing event signals for tracking changes. It works with clause data structures and uses iterators for batch operations. It is used in theorem proving contexts to maintain and update clause sets during proof search.",
      "description_length": 315,
      "index": 13,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.Env.Make.C.Pos",
      "library": "libzipperposition",
      "description": "Accesses a subterm at a specified position within a clause. Works with clauses and terms, using positions to navigate term structure. Useful for precise term manipulation during proof search or term rewriting.",
      "description_length": 209,
      "index": 14,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Env.Make.ProofState.PassiveSet",
      "library": "libzipperposition",
      "description": "This module manages a collection of passive clauses with operations to add, remove, and retrieve clauses based on a queue. It provides signals for tracking clause additions and removals, and includes checks for clause status and total clause count. It is used during proof search to handle clauses that are not actively processed but may be revisited.",
      "description_length": 351,
      "index": 15,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.Env.Make.Stm.Ctx",
      "library": "libzipperposition",
      "description": "This module provides context management for theorem proving tasks, handling term orderings, selection functions, and symbol signatures with support for term comparison, skolemization, and dynamic tracking of symbol properties via signals. It operates on logical terms, literals (`Logtk.Literal.t`, `Logtk.SLiteral.t`), and function symbols (`Logtk.ID.t`), enabling bidirectional conversions between literals and terms through customizable hooks. Key use cases include parsing and pretty-printing logical formulas, reasoning about injective functions via `is_injective_for_arg`, and maintaining consistent symbol declarations during proof search.",
      "description_length": 645,
      "index": 16,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.AC.Make.C.Seq",
      "library": "libzipperposition",
      "description": "This module provides functions to extract literals, terms, and variables from a clause structure. It works with clause (`C.t`), literal (`Logtk.Literal.t`), term (`Logtk.Term.t`), and variable (`Logtk.HVar.t`) types. Use it to analyze or transform logical clauses by iterating over their constituent elements in a sequent calculus context.",
      "description_length": 339,
      "index": 17,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Lift_lambdas.Make.C.Seq",
      "library": "libzipperposition",
      "description": "Extracts literals, terms, and variables from a clause structure for analysis or transformation tasks. Works directly with clauses (`C.t`), producing iterators over literals, terms, and typed variables. Useful in proof search or clause preprocessing where inspecting or manipulating clause components is required.",
      "description_length": 312,
      "index": 18,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.Env.Make.C.WithPos",
      "library": "libzipperposition",
      "description": "This module represents clauses with a specific subterm and its position, enabling precise term manipulation and analysis. It provides comparison and pretty-printing operations for these structured clauses. Useful for tasks like term rewriting, proof tracing, or focused clause transformations where positional context is critical.",
      "description_length": 330,
      "index": 19,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Lift_lambdas.Make.C.ClauseSet",
      "library": "libzipperposition",
      "description": "This module provides functional set operations for managing ordered collections of clauses, including membership checks, union and intersection, and ordered traversal via filtering and mapping. It operates on immutable sets structured with a comparator, supporting transformations like folding and iteration, as well as conversions to and from lists, sequences, and string representations. These capabilities are particularly valuable in automated reasoning systems, where precise clause manipulation, predicate-based queries, and ordered element access are essential.",
      "description_length": 568,
      "index": 20,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.Combinators.Make.C.Seq",
      "library": "libzipperposition",
      "description": "This module provides functions to extract literals, terms, and variables from a clause structure. It works with clause (`C.t`), literal (`Logtk.Literal.t`), term (`Logtk.Term.t`), and variable (`Logtk.HVar.t`) types. Use it to analyze or transform logical clauses by iterating over their constituent elements in a structured way.",
      "description_length": 329,
      "index": 21,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Lift_lambdas.Make.C.WithPos",
      "library": "libzipperposition",
      "description": "This module represents clauses with a specific subterm and its position, enabling precise manipulation and analysis of terms within clauses. It provides comparison and pretty-printing operations for these annotated clauses. Useful for debugging and term traversal tasks where positional context is critical.",
      "description_length": 307,
      "index": 22,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.Env.Make.ProofState.SubsumptionIndex",
      "library": "libzipperposition",
      "description": "This module implements a subsumption index for efficient clause retrieval in automated theorem proving. It supports operations to add, remove, and query clauses based on subsumption and alpha-equivalence, using literal and label sequences as keys. The index works directly with clause data structures, enabling concrete use cases such as subsumption checking and clause indexing during proof search.",
      "description_length": 399,
      "index": 23,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Env.Make.ProofState.UnitIndex",
      "library": "libzipperposition",
      "description": "This module implements an index for managing and querying equations during automated theorem proving. It supports operations to add, remove, and retrieve equations based on term matching and substitution, with facilities to iterate over indexed equations or visualize the index structure. The index is used to efficiently find matching or generalizing equations when processing proof states in automated reasoning tasks.",
      "description_length": 420,
      "index": 24,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Combinators.Make.C.Tbl",
      "library": "libzipperposition",
      "description": "This module provides imperative hash table operations for key-value pairs where keys are of type `C.t` and values can be arbitrary. It supports safe lookups, bulk updates from sequences or iterators, value transformations, and customizable merging strategies for handling duplicate keys, along with utilities for counting elements, converting between data structures, and in-place filtering. Typical use cases include efficiently maintaining counters, aggregating values into lists, and processing key-value data with custom combination logic while leveraging hash tables for fast access and updates.",
      "description_length": 600,
      "index": 25,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Lift_lambdas.Make.C.Tbl",
      "library": "libzipperposition",
      "description": "This module implements a mutable key-value store with efficient imperative operations over keys of type `C.t` and arbitrary values, supporting in-place updates, bulk modifications from sequences/iterators, and transformations with customizable combination logic. It works with hash tables (`C.Tbl.t`) and interoperates with sequences, lists, and iterators, offering utilities for aggregation, counter manipulation, and list-valued entries. Typical applications include tracking dynamic mappings with frequent updates, aggregating statistics with merge strategies, and transforming heterogeneous data while preserving key uniqueness constraints.",
      "description_length": 644,
      "index": 26,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Combinators.Make.C.ClauseSet",
      "library": "libzipperposition",
      "description": "This module implements a specialized ordered set structure for clauses, offering operations like membership checks, set algebra, ordered traversal, and transformations while preserving physical equality. It works with `C.ClauseSet.t` sets governed by a total ordering (`Ord.compare`), supporting both safe (option-returning) and unsafe (exception-raising) variants for extremal element access and bulk conversions to/from lists or sequences. Designed for applications requiring ordered clause manipulation\u2014such as theorem proving or constraint solving\u2014it enables efficient filtering, predicate-based searches, and structured data interchange with iterators or string representations.",
      "description_length": 683,
      "index": 27,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Lift_lambdas.Make.C.Eligible",
      "library": "libzipperposition",
      "description": "This module defines eligibility criteria for selecting literals within clauses during theorem proving operations. It provides functions to filter literals based on properties such as positivity, negativity, equation status, and maximality, as well as logical combinations of these conditions. These criteria are used to guide resolution and paramodulation steps in automated reasoning algorithms.",
      "description_length": 396,
      "index": 28,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.AC.Make.C.Tbl",
      "library": "libzipperposition",
      "description": "This module implements a hash table for keys of type `C.t` and arbitrary values, supporting imperative operations like insertion, deletion, and in-place transformations. It provides utilities for merging duplicate keys with custom combination functions, converting between sequences/iterators and hashtables, and aggregating statistics or counts from collections. Typical use cases include tracking frequency distributions in sequences, managing dynamic key-value mappings with atomic updates, and transforming heterogeneous data structures with controlled merging strategies.",
      "description_length": 576,
      "index": 29,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Combinators.Make.C.WithPos",
      "library": "libzipperposition",
      "description": "This module represents clauses with a specific subterm and its position, enabling precise term manipulation and analysis. It provides comparison and pretty-printing operations for these structured clauses. Useful for tasks like term rewriting, proof search, and subterm tracking in logical expressions.",
      "description_length": 302,
      "index": 30,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.ProofState.Make.CQueue.PriorityFun",
      "library": "libzipperposition",
      "description": "Implements priority functions for clause queues based on clause properties. Accepts string descriptions to generate weighting functions that map clauses to integer priorities. Used to dynamically configure prioritization strategies in proof search.",
      "description_length": 248,
      "index": 31,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Combinators.Make.C.Eligible",
      "library": "libzipperposition",
      "description": "This module defines eligibility criteria for selecting literals in clausal reasoning, using functions that determine inclusion based on properties like position, type, or logical context. It supports operations for filtering literals by resolution, paramodulation, positivity, negativity, and maximality, with combinators for logical composition using and, or, and not. Concrete use cases include guiding inference rules in automated theorem proving by restricting clause processing to relevant literals.",
      "description_length": 504,
      "index": 32,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Env.Make.C.ClauseSet",
      "library": "libzipperposition",
      "description": "This module implements a functional set structure for clause elements (`C.t`), supporting standard operations like union, intersection, and difference while preserving immutability. It maintains ordered sets using a comparator from the `Make` functor, enabling ordered traversal, range queries via `split`, and element access through functions like `min`, `max`, and `to_seq_from`. The structure is particularly useful for managing logical clauses in theorem proving or symbolic reasoning tasks, where ordered processing, transformations via `map` or `fold`, and conversions to lists or sequences are required for analysis or output formatting.",
      "description_length": 644,
      "index": 33,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.ProofState.Make.TermIndex.Leaf",
      "library": "libzipperposition",
      "description": "This module implements a term index structure for efficient storage and retrieval of terms with associated values, supporting operations like insertion, removal, and conditional updates. It enables advanced term matching and unification queries, returning results with substitutions when terms match or unify with indexed entries. Useful for applications requiring fast term-based lookups in theorem proving or logic programming contexts.",
      "description_length": 438,
      "index": 34,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Env.Make.FormRename.Ctx",
      "library": "libzipperposition",
      "description": "This module manages logical contexts for theorem proving by handling term orderings, skolemization, and symbol signature operations, supporting dynamic updates and comparisons. It enables injectivity checks for term transformations and bridges literals and formulas through customizable hooks, facilitating integration of domain-specific term representations. Key use cases include proof search optimization, logical expression transformation, and maintaining consistency during symbol/signature modifications.",
      "description_length": 510,
      "index": 35,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.Env.Make.ProofState.ActiveSet",
      "library": "libzipperposition",
      "description": "Maintains a dynamic set of clauses with signals for tracking additions and removals. Provides operations to add or remove multiple clauses, retrieve the current set, and get the number of clauses. Useful for managing active clauses during theorem proving where clause set changes must trigger specific actions.",
      "description_length": 310,
      "index": 36,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Env.Make.C.Tbl",
      "library": "libzipperposition",
      "description": "This module implements a polymorphic hash table for key-value associations with keys of type `C.t`, offering imperative operations like insertion, lookup, in-place modification, and bulk updates from sequences. It supports advanced transformations with custom merge functions, in-place filtering, and conversion to/from lists and iterators, while providing utilities for counting elements, tracking statistics, and pretty-printing. Typical applications include managing dynamic environments, aggregating data streams, and implementing counters or caches where efficient key-based access and mutation are critical.",
      "description_length": 613,
      "index": 37,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Env.Make.C.Eligible",
      "library": "libzipperposition",
      "description": "This module defines eligibility criteria for selecting literals in a clause based on specific logical properties. It provides functions to filter literals by resolution, paramodulation, positivity, negativity, maximality, and equation status, as well as logical combinations of these conditions. Use cases include guiding inference rules in automated theorem proving by restricting which literals can participate in resolution or paramodulation steps.",
      "description_length": 451,
      "index": 38,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Lift_lambdas.Make.C.Pos",
      "library": "libzipperposition",
      "description": "This module provides a function `at` that retrieves a subterm at a specified position within a term. It operates on terms and positions, enabling precise navigation and manipulation of term structures. A concrete use case is extracting specific components from complex logical expressions during proof search or term rewriting.",
      "description_length": 327,
      "index": 39,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.AC.Make.C.Eligible",
      "library": "libzipperposition",
      "description": "This module defines eligibility criteria for selecting literals in a clause based on specific logical properties. It provides functions to filter literals by type (positive, negative, equations), role (resolution, paramodulation), or position (maximal), and allows combining criteria using logical operations. These functions are used to control inference rules in automated theorem proving, such as restricting resolution or paramodulation steps to certain literals.",
      "description_length": 467,
      "index": 40,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Combinators.Make.C.Pos",
      "library": "libzipperposition",
      "description": "Accesses a subterm at a specified position within a clause. Works with clauses and terms, using positions to navigate term structure. Useful for precise term manipulation during proof search or term rewriting.",
      "description_length": 209,
      "index": 41,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Env.Make.ProofState.TermIndex",
      "library": "libzipperposition",
      "description": "This module provides term indexing operations for efficient insertion, removal, and queries on logical terms paired with positional data, supporting exact matches, unification, and hierarchical generalization/specialization. It leverages scoped terms and unification mechanisms from Logtk libraries, organizing data into index structures optimized for automated reasoning tasks. The indexed data can be visualized via DOT format output, aiding analysis of term relationships in theorem proving or rewriting systems.",
      "description_length": 515,
      "index": 42,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.ProofState.Make.SubsumptionIndex.C",
      "library": "libzipperposition",
      "description": "This module defines operations for comparing clauses, extracting literals, and retrieving label subsets, ensuring compatibility with subsumption logic. It works with clauses represented by the type `C.t`, providing direct access to their structural components. Use cases include clause indexing, subsumption checking, and label-based filtering in automated theorem proving.",
      "description_length": 373,
      "index": 43,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.AC.Make.C.WithPos",
      "library": "libzipperposition",
      "description": "This module represents clauses with a specific subterm and its position, enabling precise term manipulation and analysis. It provides comparison and pretty-printing operations for these structured clauses. Useful for tasks like term rewriting, proof tracing, or focused clause transformations where positional context is critical.",
      "description_length": 330,
      "index": 44,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Env.Make.C.Seq",
      "library": "libzipperposition",
      "description": "This module provides functions to extract literals, terms, and variables from a clause. It works with clauses (`C.t`), iterating over their components using specific data structures like `Logtk.Literal.t`, `Logtk.Term.t`, and `Logtk.HVar.t`. Use it to analyze or transform logical clauses by inspecting their constituent parts during proof search or term rewriting.",
      "description_length": 365,
      "index": 45,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.ProofState.Make.CQueue.C",
      "library": "libzipperposition",
      "description": "This module manages clause properties and transformations in automated reasoning systems, focusing on operations like redundancy checks, trail-based reasoning, and proof step manipulation. It works with clauses, trails, and proof structures to support tasks such as clause analysis (e.g., literal eligibility, symbol counting), substitution application, and \u03b7-reduction, while also enabling TSTP-format output and goal-directed simplification. Key use cases include theorem proving, proof state maintenance, and logical term transformation.",
      "description_length": 540,
      "index": 46,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.AC.Make.C.Pos",
      "library": "libzipperposition",
      "description": "Accesses a subterm at a specified position within a term. Works with terms and positions, enabling precise navigation and manipulation of term structures. Useful for tasks like term rewriting or proof search where specific subterms need to be inspected or modified.",
      "description_length": 265,
      "index": 47,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.ProofState.Make.CQueue.WeightFun",
      "library": "libzipperposition",
      "description": "This module defines weight functions for prioritizing clauses in a proof search context. It provides operations to create and combine weight functions that influence clause selection based on properties like goal proximity, clause structure, and literal characteristics. Use cases include guiding automated theorem proving by assigning priorities based on heuristics such as favoring ground or Horn clauses, penalizing complexity, or combining multiple criteria into a single weighted score.",
      "description_length": 491,
      "index": 48,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.Env.Make.ProofState.CQueue",
      "library": "libzipperposition",
      "description": "This module implements priority queues of logical clauses designed for automated theorem proving, offering operations to insert clauses, select them based on customizable weight and priority functions, and manage set-like membership with efficient retrieval and removal. It operates on clause priority queues (`ProofState.CQueue.t`) using properties like syntactic features, penalties, or conjecture proximity to guide prioritization. These queues optimize proof search in scenarios requiring strategies such as favoring ground clauses, goal-oriented selection, or hybrid approaches combining FIFO and heuristic-based ordering.",
      "description_length": 627,
      "index": 49,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.ProofState.Make.UnitIndex.E",
      "library": "libzipperposition",
      "description": "This module represents and manipulates indexed equations, consisting of pairs of terms along with a boolean flag indicating equality or inequality. It provides operations to compare equations, extract their components, and determine their priority for use in theorem proving. These equations are used to store and process logical equalities and inequalities during proof search.",
      "description_length": 378,
      "index": 50,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Clause.Make.Seq",
      "library": "libzipperposition",
      "description": "This module provides functions to iterate over literals, terms, and variables within a clause structure. It allows direct access to the logical components of clauses for analysis or transformation. Useful for implementing clause-based reasoning tools like theorem provers or formula simplifiers.",
      "description_length": 295,
      "index": 51,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Clause.Make.Eligible",
      "library": "libzipperposition",
      "description": "This module defines predicates to select subsets of literals in a clause based on specific logical properties, such as positivity, negativity, maximality, or eligibility for resolution and paramodulation. It supports operations to combine and transform these predicates using logical operators like and, or, and not. Use cases include filtering literals during theorem proving steps, such as selecting candidates for inference rules or restricting clause simplifications.",
      "description_length": 471,
      "index": 52,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.ProofState.Make.CQueue",
      "library": "libzipperposition",
      "description": "This module offers operations to manage a priority queue of clauses, including insertion, retrieval, iteration, membership checks, and removal, along with pretty-printing. Priorities are determined by weight functions that evaluate clause properties like goal proximity, structural complexity, and logical features, enabling efficient clause selection and processing in automated theorem proving workflows.",
      "description_length": 406,
      "index": 53,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.ProofState.Make.UnitIndex",
      "library": "libzipperposition",
      "description": "This module implements an index for managing logical equations and inequalities, supporting operations to add, remove, and retrieve terms based on pattern matching and substitution. It works with indexed terms and substitutions, enabling efficient lookups during theorem proving by generalizing query terms against stored (in)equations. Use cases include indexing logical constraints for resolution and matching during proof search.",
      "description_length": 432,
      "index": 54,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.ProofState.Make.SubsumptionIndex",
      "library": "libzipperposition",
      "description": "This module implements a subsumption index for efficient clause retrieval in automated theorem proving. It supports operations to add, remove, and query clauses based on subsumption and alpha-equivalence, working directly with clauses of type `C.t`. Use cases include indexing clauses during proof search, identifying subsuming or subsumed clauses, and filtering candidates for redundancy or equivalence checks.",
      "description_length": 411,
      "index": 55,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Ctx.Make.Lit",
      "library": "libzipperposition",
      "description": "This module provides functions to convert between logical literals and their term-based representations, using customizable hooks for transformation. It works with `Logtk.Literal.t` and `Logtk.Term.t Logtk.SLiteral.t` types, enabling bidirectional conversion. Concrete use cases include integrating literal processing with theorem proving components that require term-level manipulation or normalization.",
      "description_length": 404,
      "index": 56,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Clause.Make.WithPos",
      "library": "libzipperposition",
      "description": "This module represents clauses with a specific subterm and its position, enabling precise manipulation and analysis of terms within clauses. It provides comparison and pretty-printing operations for these structured clauses. Useful for tasks like term indexing, rewriting, or focused proof search where subterm positions matter.",
      "description_length": 328,
      "index": 57,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Env.Make.Stm",
      "library": "libzipperposition",
      "description": "This module manages streams of clauses with unique identifiers, tracking parent clauses, penalties, and retrieval attempts. It supports operations like `drip` to extract elements, `make` to construct streams, and provides equality, comparison, and hashing for stream values. Use cases include prioritizing clause processing in theorem proving, managing proof derivation history, and controlling search heuristics via penalty adjustments.",
      "description_length": 437,
      "index": 58,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.ProofState.Make.SimplSet",
      "library": "libzipperposition",
      "description": "This module manages a dynamic set of clauses with operations to add or remove clauses and notify listeners of changes. It uses iterators over clauses for batch modifications and provides signals to react to clause additions or removals. It is useful for maintaining and updating a collection of logical clauses during proof search or simplification processes.",
      "description_length": 359,
      "index": 59,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Clause.Make.Tbl",
      "library": "libzipperposition",
      "description": "Provides hash table operations for key-value pair management, including insertion, lookup, iteration, and folding, with support for sequence conversion and duplicate key handling via custom combination functions. Works",
      "description_length": 218,
      "index": 60,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.Env.Make.FormRename",
      "library": "libzipperposition",
      "description": "This module implements formula renaming and skolemization mechanisms for logical terms during proof search. It provides operations to detect renaming clauses, introduce predicate skolems, and rename formulas with configurable strategies, supporting polarity-aware transformations and skolem symbol generation. It works directly with logical clauses and formulas, enabling use cases like formula definition extraction, consistent skolem symbol introduction, and logical expression normalization during theorem proving.",
      "description_length": 517,
      "index": 61,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Env.Make.ProofState",
      "library": "libzipperposition",
      "description": "This module manages the dynamic state of automated theorem proving by organizing clauses into priority queues, indexed structures, and active/passive sets. It provides operations to prioritize clauses based on syntactic and semantic properties, index terms and equations for fast retrieval, and maintain evolving clause sets with change tracking. Concrete use cases include guiding proof search through heuristic clause selection, accelerating term matching during resolution, and managing clause lifecycle stages in saturation-based provers.",
      "description_length": 542,
      "index": 62,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.ProofState.Make.TermIndex",
      "library": "libzipperposition",
      "description": "This module provides term indexing structures for efficient storage and retrieval of logical terms paired with `C.WithPos.t` elements, supporting operations like insertion, removal, iteration, and advanced queries such as unification, generalization, and specialization under substitutions. It is designed for theorem proving applications, enabling efficient term matching and substitution tracking during proof search. A utility function also allows visualizing the index's graph-like structure in DOT format using a custom element printer.",
      "description_length": 541,
      "index": 63,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Env.Make.StmQ",
      "library": "libzipperposition",
      "description": "This module implements a priority queue for managing streams of statements with customizable weighting. It provides operations to add streams or lists of streams, retrieve clauses with optional fairness guarantees, and inspect queue state. Concrete use cases include prioritizing proof search branches in automated theorem proving and managing clause selection strategies based on dynamic metrics like size or complexity.",
      "description_length": 421,
      "index": 64,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.AC.Make.C",
      "library": "libzipperposition",
      "description": "This module provides operations for managing logical clauses, including metadata manipulation (redundancy flags, proof tracking), structural analysis (literal maximality, eligibility for inference rules), and transformations (substitution application, term reduction). It works with clauses (`C.t`), trails, substitutions, and scoped terms, using specialized data structures like clause hash tables (`Tbl`) and positional term accessors. These capabilities support automated theorem proving tasks such as backward simplification, proof construction, and inference control in formal verification systems.",
      "description_length": 603,
      "index": 65,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.Combinators.Make.C",
      "library": "libzipperposition",
      "description": "The module offers operations for clause manipulation, trail-based logic, and proof management, focusing on tasks like flagging clauses as redundant, modifying trails for subsumption checks, and extracting proofs. It works with clauses (`C.t`), trails (`Trail.t`), substitutions, and term structures, while leveraging hash tables (`Tbl`) and ordered clause sets (`ClauseSet`) for efficient data handling. These tools support automated theorem proving workflows such as resolution rule application, clause analysis for emptiness/unit status, and proof-guided transformations during inference or search processes.",
      "description_length": 610,
      "index": 66,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Clause.Make.ClauseSet",
      "library": "libzipperposition",
      "description": "This module implements a sorted set structure for managing collections of clauses with efficient membership checks, ordered traversal, and set algebra operations like union, intersection, and difference. It relies on a total ordering for element comparison and supports transformations through mapping, filtering, and folding, as well as conversions to and from lists, sequences, and strings. Typical applications include symbolic reasoning systems requiring precise set manipulation, ordered clause processing, or predicate-based element retrieval in formal verification contexts.",
      "description_length": 581,
      "index": 67,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Env.Make.C",
      "library": "libzipperposition",
      "description": "This module provides operations for clause manipulation in automated theorem proving, including flag management, redundancy checks, proof extraction, and eligibility analysis for inference rules. It works with clauses (`C.t`), trails (`Trail.t`), substitutions, and polymorphic hash tables (`Tbl`), supporting tasks like logical normalization, term rewriting, and structured clause analysis. Key use cases involve managing trail-based logic, optimizing clause sets for resolution, and transforming formulas into standardized logical forms.",
      "description_length": 539,
      "index": 68,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.ClauseQueue.Make.PriorityFun",
      "library": "libzipperposition",
      "description": "Implements priority functions for clause selection in theorem proving, where each function maps a clause to an integer priority. It parses string descriptions of weight functions to define custom prioritization strategies. Used to control the order of clause processing in saturation-based provers.",
      "description_length": 298,
      "index": 69,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.ProofState.Make.ActiveSet",
      "library": "libzipperposition",
      "description": "This module maintains a dynamic set of clauses with operations to add or remove clauses and track changes via signals. It provides direct access to the current clause set and its size. Useful for managing logical clauses during theorem proving where clauses are selectively added or removed based on proof strategies.",
      "description_length": 317,
      "index": 70,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.StreamQueue.Make.WeightFun",
      "library": "libzipperposition",
      "description": "This module implements weight functions for stream prioritization, where each function maps a stream statement to an integer weight. It provides operations to compute a penalty value for a stream and to combine multiple weighted functions into a single composite weight function using coefficients. These functions are used to guide the selection of streams in a priority queue based on customizable weighting strategies.",
      "description_length": 421,
      "index": 71,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Bool_lit.Make.Tbl",
      "library": "libzipperposition",
      "description": "This module provides hash table operations for managing key-value associations where keys are boolean literals, supporting creation, modification, and traversal with functions like insertion, deletion, folding, and iteration. It works with hash tables, sequences, and lists, enabling bulk updates, conflict resolution during key collisions, and conversions between collections. Specific use cases include tracking boolean flag states, aggregating statistics from logical expressions, and merging heterogeneous data sources with customizable value combination strategies.",
      "description_length": 570,
      "index": 72,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.BBox.Lit.Set",
      "library": "libzipperposition",
      "description": "This module implements an immutable set structure for managing ordered literals, supporting operations like union, intersection, and difference alongside ordered traversal, filtering, and transformation via functions such as `map` and `partition`. It relies on a total ordering from `Ord.compare` to maintain element relationships, enabling efficient membership tests, extremum retrieval (min/max), and ordered iteration. Key use cases include symbolic reasoning tasks requiring precise literal set manipulation, predicate-driven element searches, and serialization workflows for debugging or external representation via `to_string` and sequence conversions.",
      "description_length": 658,
      "index": 73,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.ProofState.Make.PassiveSet",
      "library": "libzipperposition",
      "description": "This module manages a set of passive clauses with operations to add, remove, and retrieve clauses based on a queue. It provides signals for tracking clause additions and removals, and includes functions to check if a clause is passive and to get the current clause count. It is used during theorem proving to manage clauses that are not actively being processed but may be needed later.",
      "description_length": 386,
      "index": 74,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.ClauseQueue.Make.WeightFun",
      "library": "libzipperposition",
      "description": "This module defines weight functions that assign integer weights to clauses for guiding proof search in automated theorem proving. It supports operations to create, combine, and customize weight functions, including penalties, goal proximity, and syntactic preferences like favoring Horn or ground clauses. Use cases include prioritizing clauses in a queue based on heuristics to improve prover efficiency.",
      "description_length": 406,
      "index": 75,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Clause.Make.Pos",
      "library": "libzipperposition",
      "description": "This module provides a function `at` that retrieves a term from a clause at a specified position using a positional index. It operates on clauses and positional data structures to access specific subterms. A concrete use case is extracting or inspecting terms at precise locations within a clause for proof manipulation or term analysis.",
      "description_length": 337,
      "index": 76,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Ctx.Key",
      "library": "libzipperposition",
      "description": "This module defines a single key `lost_completeness` used to track whether completeness has been lost during proof search. It works with the `Logtk.Flex_state` type to store and retrieve boolean values associated with this key. This key is specifically used in theorem proving contexts to signal when a derivation step compromises completeness.",
      "description_length": 344,
      "index": 77,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Env.Make",
      "library": "libzipperposition",
      "description": "This module provides functionalities for clause manipulation, proof state management, rule registration, stream prioritization, and formula transformation in automated reasoning workflows. It operates on clauses, trails, substitutions, priority queues, terms, literals, and dynamic state structures to enable tasks like normalization, skolemization, and heuristic-guided proof search. The components are designed for saturation-based theorem proving, supporting logical inference, simplification, redundancy checks, and dynamic state updates during proof exploration.",
      "description_length": 567,
      "index": 78,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.Combinators.Make",
      "library": "libzipperposition",
      "description": "This module implements combinators for clause manipulation and proof management in automated theorem proving. It provides operations to flag clauses as redundant, modify trails for subsumption checks, and extract proofs, working with clauses, trails, substitutions, and term structures. It supports concrete tasks like resolution rule application, clause analysis, and proof-guided transformations during inference.",
      "description_length": 415,
      "index": 79,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.Saturate.Make",
      "library": "libzipperposition",
      "description": "Implements the given clause algorithm for saturation-based theorem proving, handling inference generation and state reduction. Operates on logical clauses and proof states, managing active and passive clause sets. Used to drive automated reasoning steps, such as in resolution or superposition provers, by iteratively processing clauses and deriving new conclusions.",
      "description_length": 366,
      "index": 80,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.ProofState.Make",
      "library": "libzipperposition",
      "description": "This module implements a proof state management system for automated theorem proving, centered around clause processing and indexing. It provides priority-based clause selection via a weighted queue, multiple specialized indexes for term and clause retrieval (including subsumption and unit propagation), and dynamic clause sets for active, passive, and simplification-focused workflows. Concrete use cases include guiding proof search by prioritizing relevant clauses, efficiently querying term relationships under substitutions, and maintaining indexed clause databases for resolution and simplification steps.",
      "description_length": 612,
      "index": 81,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Cut_form.Seq",
      "library": "libzipperposition",
      "description": "Extracts terms from cut forms, either as a sequence of terms or with their positions. Works with `Cut_form.t` and `Cut_form.term` types. Useful for analyzing or transforming logical formulas by accessing their constituent terms and positions during proof search or term rewriting.",
      "description_length": 280,
      "index": 82,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Bool_lit.Make",
      "library": "libzipperposition",
      "description": "This module implements boolean literals with sign manipulation, comparison, and payload handling. It supports operations like negation, sign extraction, and normalization, working with a customizable payload type. Concrete use cases include symbolic logic processing, clause management in theorem provers, and handling boolean flags with associated data.",
      "description_length": 354,
      "index": 83,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.Ctx.Make",
      "library": "libzipperposition",
      "description": "This module facilitates logical context management for theorem proving by handling term orderings, selection functions, and skolemization contexts, while enabling dynamic manipulation of symbol signatures through declaration, type resolution, and update tracking. It incorporates per-argument injectivity tracking for identifiers and bidirectional conversion between logical literals and term-based representations, operating on structured types like `Logtk.Literal.t` and `Logtk.Term.t`. These capabilities support advanced use cases such as integrating term-level reasoning into proof systems and maintaining precise symbol behavior during complex logical transformations.",
      "description_length": 674,
      "index": 84,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Clause.Make",
      "library": "libzipperposition",
      "description": "This module provides operations for managing clause metadata (e.g., redundancy markers, simplification flags), analyzing clause structure (e.g., literal selection, eligibility checks for inference rules), and transforming clauses through substitution or proof manipulation. It operates on clauses (`t`), substitutions, bitvectors, and hash tables (`Tbl`), with specialized support for automated theorem proving tasks like tracking proof depth, selecting inference candidates, and maintaining term-level analysis. Key use cases include clause state tracking during saturation-based proving, eligibility filtering for resolution or paramodulation, and structured proof extraction.",
      "description_length": 678,
      "index": 85,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Lift_lambdas.Make",
      "library": "libzipperposition",
      "description": "This module transforms lambda terms in clauses into equivalent first-order representations using a given environment. It provides `lift_lambdas` to process clauses and `setup` to register transformation rules globally. Useful for eliminating higher-order constructs during preprocessing in theorem proving.",
      "description_length": 306,
      "index": 86,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.SimplM.Infix",
      "library": "libzipperposition",
      "description": "Implements monadic bind and map operations for the `SimplM` monad, enabling chaining of computations that return `SimplM.t` values. Works directly with the `SimplM.t` type, allowing for sequential composition and transformation of monadic actions. Useful for structuring complex term rewriting or simplification pipelines where intermediate results must be passed between functions in a stateful context.",
      "description_length": 404,
      "index": 87,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.ClauseContext.Set",
      "library": "libzipperposition",
      "description": "This module provides efficient, immutable set operations for managing `ClauseContext` elements, including membership checks, union, intersection, difference, ordered traversal, and transformations via map, fold, and filter. It works with sets of `ClauseContext.t` values, offering safe and unsafe variants for element retrieval, cardinality checks, and conversions to lists, sequences, and string representations. These operations are particularly valuable in theorem proving for tracking and manipulating logical clauses during proof search, where ordered iteration, set algebra, and efficient serialization aid in debugging and algorithmic efficiency.",
      "description_length": 653,
      "index": 88,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.BBox.Lit",
      "library": "libzipperposition",
      "description": "This module implements a typed representation of boolean literals with operations for sign manipulation, comparison, and payload extraction. It works with a private type `t` and a payload type, supporting concrete tasks like negation, normalization, and fresh literal generation. Key use cases include symbolic reasoning, clause manipulation, and logic-based computations where literals must be compared, transformed, and stored efficiently.",
      "description_length": 441,
      "index": 89,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.AC.Make",
      "library": "libzipperposition",
      "description": "This module implements AC (associative-commutative) theory handling for logical clauses, providing operations to declare and track AC symbols, detect AC-trivial literals and clauses, and simplify clauses modulo AC properties. It works directly with clauses, literals, terms, and symbol sets, using specialized structures like clause hash tables and term accessors. Concrete use cases include detecting redundancy in equational reasoning, simplifying clauses during superposition-based theorem proving, and managing AC-specific proof steps in formal verification tasks.",
      "description_length": 568,
      "index": 90,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Sat_solver.Make",
      "library": "libzipperposition",
      "description": "This module implements a SAT solver that supports incremental solving, clause learning, and proof generation. It operates on clauses represented as lists of literals, and provides operations to add clauses, check satisfiability, query the model, and retrieve proofs of unsatisfiability or individual literals. Use cases include formal verification tasks where precise proof traces are required, and solving constraint systems derived from logical formulas in automated reasoning tools.",
      "description_length": 485,
      "index": 91,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.ClauseQueue.Make",
      "library": "libzipperposition",
      "description": "This module provides a clause prioritization system for automated reasoning, enabling operations to insert, remove, and select clauses (`C.t`) based on customizable weight and priority functions. It supports strategies like FIFO, goal-driven, or heuristic-based exploration, with utilities for membership checks, passive set management, and debugging output, primarily used to optimize proof search order and resource efficiency in theorem proving workflows.",
      "description_length": 458,
      "index": 92,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Stream.Make",
      "library": "libzipperposition",
      "description": "This module implements a stream data structure with unique identifiers, penalty tracking, and element retrieval operations. It works with sequences of optional clauses (`C.t option OSeq.t`) and supports efficient access, modification, and comparison of streams. Concrete use cases include managing and prioritizing streams of logical clauses during automated theorem proving.",
      "description_length": 375,
      "index": 93,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.StreamQueue.Make",
      "library": "libzipperposition",
      "description": "This module implements priority queues for managing streams of clauses in a theorem prover, using customizable weight functions to determine stream prioritization. It supports operations to add individual streams or lists of streams, take clauses fairly or with bounded attempts, and inspect queue state, all while applying weighted strategies to guide clause selection. Concrete use cases include controlling the order of clause processing in automated reasoning tasks where prioritization affects proof search efficiency.",
      "description_length": 523,
      "index": 94,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Cut_form.FV_tbl",
      "library": "libzipperposition",
      "description": "This module implements a hash table that maps cut forms (modulo \u03b1-equivalence) to values of type `X.t`. It supports adding, checking membership, and retrieving bindings for cut forms, using \u03b1-equivalence to determine key equality. Useful for managing substitutions or metadata associated with logical formulas in proof search or term rewriting contexts.",
      "description_length": 353,
      "index": 95,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Eprover_interface.Make",
      "library": "libzipperposition",
      "description": "Implements an interface for integrating the E theorem prover within a larger system, enabling direct interaction with E's functionalities through a binary path configuration. It provides operations to set the E binary location, invoke E on given clause sequences, and set up necessary environment rules for execution. Designed for use in automated reasoning pipelines where clause-based logic solving is required.",
      "description_length": 413,
      "index": 96,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.FormulaRename.Make",
      "library": "libzipperposition",
      "description": "This module implements formula renaming and Skolemization during clausification, handling predicate Skolem introduction and definition management. It operates on clauses and terms, supporting controlled Skolem symbol generation with configurable freshness strategies. Use cases include formula normalization and transformation during theorem proving or formula preprocessing.",
      "description_length": 375,
      "index": 97,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.SClause.TPSet",
      "library": "libzipperposition",
      "description": "This module implements a set structure for managing term-position pairs, supporting efficient membership checks, ordered traversal, and set algebra (union, intersection, difference). It operates on elements of type `(Logtk.Term.t * Logtk.Position.t)`, leveraging ordered comparisons for deterministic manipulation and providing transformations like mapping, filtering, and folding. Designed for applications in formal verification or symbolic computation, it enables precise tracking of term occurrences within logical clauses through positional annotations and bulk set operations.",
      "description_length": 582,
      "index": 98,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Cut_form.Pos",
      "library": "libzipperposition",
      "description": "This module provides precise term manipulation within a structured array representation. It supports operations to access and modify subterms, literals, and clauses at specific positions, enabling direct navigation and transformation of logical expressions. Concrete use cases include term rewriting, proof manipulation, and formula transformation in automated reasoning tasks.",
      "description_length": 377,
      "index": 99,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Cover_set.Case",
      "library": "libzipperposition",
      "description": "This module represents inductive cases in a coverset, starting with a constructor of their type. It provides operations to compare, hash, and print cases, as well as check if a case is recursive or base, and extract associated terms, literals, and sub-constants. It is used to analyze and manipulate inductive constants and their case distinctions during proof search or term rewriting.",
      "description_length": 386,
      "index": 100,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.AC_intf",
      "library": "libzipperposition",
      "description": "This module defines a type `spec` that pairs a symbol identifier with a type, used to specify term properties in term indexing. It includes a signature `S` for implementing term indexing structures that support efficient retrieval of terms matching a given pattern. Concrete use cases include building indexed term databases for fast query resolution in theorem proving and term rewriting systems.",
      "description_length": 397,
      "index": 101,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Sat_solver_intf",
      "library": "libzipperposition",
      "description": "This module defines the interface for a SAT solver used in automated theorem proving. It includes types for proof steps and proofs, along with a result type indicating satisfiability or unsatisfiability, including a proof in the unsatisfiable case. It is used to implement and integrate SAT solving capabilities within theorem provers that require formal verification of logical formulas.",
      "description_length": 388,
      "index": 102,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.Stream_intf",
      "library": "libzipperposition",
      "description": "This module defines a stream interface with operations for lazy, sequential data processing. It works with stream types that support element-wise access, filtering, and transformation. Concrete use cases include parsing large files incrementally, processing log entries in real time, or handling network data flows without loading entire datasets into memory.",
      "description_length": 359,
      "index": 103,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.SClause",
      "library": "libzipperposition",
      "description": "This module provides logical clause manipulation capabilities, centered on constructing and managing clauses through literal operations, trail integration, and flag-based state tracking (e.g., redundancy, simplification). It works with clauses (`t`), term-position sets (`TPSet`), and proof trails (`Trail.t`), supporting use cases like symbolic reasoning, proof adaptation, and format-preserving output for debugging or interoperability (TPTP/TSTP). Key operations include ordered traversal of term-position pairs, clause annotation with metadata, and customizable pretty-printing for diagnostic or proof-exchange purposes.",
      "description_length": 624,
      "index": 104,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.FormulaRename",
      "library": "libzipperposition",
      "description": "This module implements formula renaming and Skolemization during clausification, handling predicate Skolem introduction and definition management. It operates on clauses and terms, supporting controlled Skolem symbol generation with configurable freshness strategies. Use cases include formula normalization and transformation during theorem proving or formula preprocessing.",
      "description_length": 375,
      "index": 105,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Combinators_base",
      "library": "libzipperposition",
      "description": "This module implements combinatory logic transformations and optimizations for terms in a formal logic system. It provides functions to construct and manipulate terms using standard combinators (S, B, C, K, I), apply optimization rules like currying and narrowing, and normalize terms. These operations are used during theorem proving to simplify and transform logical expressions systematically.",
      "description_length": 396,
      "index": 106,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.StreamQueue_intf",
      "library": "libzipperposition",
      "description": "A priority queue for managing a collection of streams, where elements are ordered by priority. It supports operations to insert streams, retrieve and remove the highest-priority stream, and check if the queue is empty. This structure is useful for scheduling tasks where each stream represents a sequence of prioritized work items.",
      "description_length": 331,
      "index": 107,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.AC",
      "library": "libzipperposition",
      "description": "This module implements AC (associative-commutative) theory handling for logical clauses, offering operations to declare and track AC symbols, identify AC-trivial literals and clauses, and simplify clauses modulo AC properties. It operates on clauses, literals, terms, and symbol sets, using structures like clause hash tables and term accessors. It is used to detect redundancy in equational reasoning, simplify clauses during superposition-based theorem proving, and manage AC-specific proof steps in formal verification.",
      "description_length": 522,
      "index": 108,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Params",
      "library": "libzipperposition",
      "description": "This module manages configuration parameters for a theorem proving system, handling command-line arguments, default values, and global state keys. It supports operations to define and extend argument parsing, configure proof search behavior, and control output formats. Concrete use cases include setting proof search depth, enabling proof checking, and specifying DOT file generation for visualization.",
      "description_length": 403,
      "index": 109,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.ClauseQueue_intf",
      "library": "libzipperposition",
      "description": "This module defines a priority queue for clauses with customizable selection strategies. It supports operations to add clauses with specified priorities and to retrieve the next clause based on the active strategy. The queue is used to control the order of clause processing in theorem proving, such as prioritizing goal-related or lightweight clauses.",
      "description_length": 352,
      "index": 110,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Bool_selection",
      "library": "libzipperposition",
      "description": "This module defines selection functions for choosing boolean subterms in logical expressions, based on ordering and other constraints. It operates on terms and literals, producing lists of selected subterms with their positions. Concrete use cases include guiding resolution or superposition proofs by selecting specific literals or terms that satisfy eligibility criteria.",
      "description_length": 373,
      "index": 111,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Extensions",
      "library": "libzipperposition",
      "description": "This module manages dynamic extensions for a theorem prover, allowing plugins to define and register custom behaviors at various stages of processing, such as parsing, typing, CNF transformation, and ordering. It supports data types like `state`, `env_action`, and `prec_action`, and provides operations to register extensions, retrieve them by name, and list all active extensions. Concrete use cases include adding custom clause processing logic, modifying term ordering, and integrating new inference rules during proof search.",
      "description_length": 530,
      "index": 112,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Stream",
      "library": "libzipperposition",
      "description": "This module implements a stream data structure with unique identifiers, penalty tracking, and element retrieval operations. It works with sequences of optional clauses (`C.t option OSeq.t`) and supports efficient access, modification, and comparison of streams. Concrete use cases include managing and prioritizing streams of logical clauses during automated theorem proving.",
      "description_length": 375,
      "index": 113,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Lift_lambdas",
      "library": "libzipperposition",
      "description": "This module transforms lambda terms within clauses into first-order equivalents using a provided environment. It offers `lift_lambdas` to process clauses and `setup` to register global transformation rules. Designed for use in preprocessing stages of theorem proving to eliminate higher-order constructs.",
      "description_length": 304,
      "index": 114,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Const",
      "library": "libzipperposition",
      "description": "Contains constants used throughout the library, including version information and logging section identifiers. It provides direct access to predefined values that configure and identify the library's behavior. Useful for retrieving the current version string or referencing shared logging sections in debugging contexts.",
      "description_length": 320,
      "index": 115,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Env",
      "library": "libzipperposition",
      "description": "This module implements a clause-based proof state manager with rule registration, priority-based stream handling, and term transformation capabilities for automated theorem proving. It works directly with clauses, literals, substitutions, priority queues, and dynamic state structures to support operations like normalization, skolemization, and heuristic-driven inference. Concrete use cases include managing logical simplifications, orchestrating proof search strategies, and maintaining trail-based state updates during saturation-based reasoning.",
      "description_length": 550,
      "index": 116,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Bool_lit",
      "library": "libzipperposition",
      "description": "This module implements boolean literals with sign manipulation, comparison, and payload handling. It supports operations like negation, sign extraction, and normalization, working with a customizable payload type. Concrete use cases include symbolic logic processing, clause management in theorem provers, and handling boolean flags with associated data.",
      "description_length": 354,
      "index": 117,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.Sat_solver",
      "library": "libzipperposition",
      "description": "This module implements a SAT solver interface with support for generating and manipulating formal proofs. It provides operations to check satisfiability of logical formulas, returning results as either `Sat` or `Unsat` with an associated proof. The module works with logical terms and proof structures defined in the `Logtk` library, and is used in automated theorem proving to validate logical formulas and produce verifiable unsatisfiability proofs.",
      "description_length": 451,
      "index": 118,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Ind_cst",
      "library": "libzipperposition",
      "description": "This module supports creation, analysis, and manipulation of inductive constants and their skolemized counterparts, with functionality to track sub-constants, depth relationships, and type consistency. It operates on data structures representing inductive constants (`Ind_cst.t`), skolem identifiers (`ind_skolem`), and their collections via a dedicated set module (`Cst_set`). These tools facilitate tasks like term analysis in logic programming, recognition of inductive types, and dependency management during theorem proving where hierarchical constant relationships and type-preserving transformations are critical.",
      "description_length": 620,
      "index": 119,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.ClauseQueue",
      "library": "libzipperposition",
      "description": "This module implements a priority queue for managing clauses in automated theorem proving, where clauses are prioritized based on configurable heuristics such as age or weight. It supports operations to insert, select, and remove clauses, along with profile management to dynamically control prioritization strategies. Concrete use cases include guiding proof search in saturation-based provers and optimizing resource allocation by favoring promising or older clauses.",
      "description_length": 469,
      "index": 120,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.SimplM",
      "library": "libzipperposition",
      "description": "This module implements a monad for combining simplification steps that track whether a transformation resulted in a new value or left it unchanged. It works with values wrapped in a `SimplM.t` type that encodes whether a change occurred. It supports operations like binding, mapping, and applying lists of simplifications, making it suitable for term rewriting systems where tracking modifications is essential.",
      "description_length": 411,
      "index": 121,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Clause",
      "library": "libzipperposition",
      "description": "This module manages clause metadata, analyzes clause structure, and transforms clauses during automated theorem proving. It works with clauses, substitutions, bitvectors, and hash tables, supporting operations like redundancy marking, literal selection, and eligibility checks. Use cases include tracking clause state during saturation, filtering inference candidates, and manipulating proofs.",
      "description_length": 393,
      "index": 122,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Cover_set",
      "library": "libzipperposition",
      "description": "This module manages inductive case analysis by constructing and manipulating cover sets over terms, supporting proof search and term rewriting. It provides operations to build cover sets for types, extract cases (recursive or base), retrieve sub-constants, and generate type declarations needed for introducing new inductive constants. Use cases include automating induction steps and analyzing term structure in theorem proving.",
      "description_length": 429,
      "index": 123,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Selection",
      "library": "libzipperposition",
      "description": "This module provides functions for selecting literals in theorem proving, operating on arrays of logical literals and using bitvectors to track selected positions. It implements strategies like prioritizing maximal, negative, or ground literals, with specialized handling for Horn clauses, range-restricted clauses, and higher-order logic to support completeness in proof systems.",
      "description_length": 380,
      "index": 124,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.BBox",
      "library": "libzipperposition",
      "description": "The module enables symbolic manipulation of boolean literals with rich payloads, supporting operations like clause injection, sign inversion, and payload extraction over types such as `Logtk.Literals.t` and `Cut_form.t`. It also facilitates conversion of `BBox.t` structures into multiple textual representations, including SMT, TSTP, and ZF formats, for interoperability with theorem provers and proof assistants. These capabilities are applied in logic-based computation, clause abstraction, and formal verification workflows.",
      "description_length": 528,
      "index": 125,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Env_intf",
      "library": "libzipperposition",
      "description": "This module defines an interface for managing proof search environments, including operations to create, update, and query state during automated reasoning tasks. It works with abstract data types representing logical terms, clauses, and proof contexts. Concrete use cases include tracking active and passive clauses, maintaining term orderings, and supporting inference rule applications in theorem proving systems.",
      "description_length": 416,
      "index": 126,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.StreamQueue",
      "library": "libzipperposition",
      "description": "This module implements a priority queue for managing streams of clauses in a theorem prover, using customizable weight functions to determine stream prioritization. It supports operations to add individual streams or lists of streams, take clauses fairly or with bounded attempts, and inspect queue state, all while applying weighted strategies to guide clause selection. Concrete use cases include controlling the order of clause processing in automated reasoning tasks where prioritization affects proof search efficiency.",
      "description_length": 524,
      "index": 127,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.ClauseContext",
      "library": "libzipperposition",
      "description": "Manages clause contexts with holes that can be filled with terms, enabling precise manipulation of logical literals during theorem proving. It supports creating, extracting, and applying contexts to terms, ensuring variable scope control and structural equality checks. Useful for proof search algorithms that require tracking and transforming logical clauses through substitution and unification steps.",
      "description_length": 403,
      "index": 128,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Ctx",
      "library": "libzipperposition",
      "description": "Manages logical contexts for theorem proving with support for term orderings, selection functions, and skolemization. It works with literals, terms, and symbol signatures to enable dynamic context updates, including type resolution and injectivity tracking. Used in proof systems to maintain logical consistency and facilitate term-level reasoning during complex derivations.",
      "description_length": 375,
      "index": 129,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.Signals",
      "library": "libzipperposition",
      "description": "This module defines signals triggered at key points during execution, such as before processing a file, when printing statistics, on exit, and when activating dot output. It works with unit and string values paired with integer exit codes, using the Logtk.Signal type. Concrete use cases include hooking into solver workflows for logging, profiling, or custom output handling.",
      "description_length": 376,
      "index": 130,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Combinators",
      "library": "libzipperposition",
      "description": "This module implements combinators for clause manipulation and proof management in automated theorem proving. It provides operations to flag clauses as redundant, modify trails for subsumption checks, and extract proofs, working with clauses, trails, substitutions, and term structures. It supports concrete tasks like resolution rule application, clause analysis, and proof-guided transformations during inference.",
      "description_length": 415,
      "index": 131,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.ProofState_intf",
      "library": "libzipperposition",
      "description": "This module defines an interface for managing proof states in automated theorem proving, supporting operations to manipulate logical formulas, track proof steps, and maintain solver state. It works with data structures representing logical terms, clauses, and proof contexts. Concrete use cases include implementing proof search strategies, managing clause derivations, and maintaining state during saturation-based reasoning.",
      "description_length": 426,
      "index": 132,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Eprover_interface",
      "library": "libzipperposition",
      "description": "Implements an interface for integrating the E theorem prover within a larger system, enabling direct interaction with E's functionalities through a binary path configuration. It provides operations to set the E binary location, invoke E on given clause sequences, and set up necessary environment rules for execution. Designed for use in automated reasoning pipelines where clause-based logic solving is required.",
      "description_length": 413,
      "index": 133,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Bool_clause",
      "library": "libzipperposition",
      "description": "This module represents and manipulates boolean clauses, which are lists of boolean literals. It provides functions to create and extract boolean clauses from proof results, enabling integration with theorem proving processes. Use cases include clause-based reasoning in automated theorem provers and handling propositional logic during proof search.",
      "description_length": 349,
      "index": 134,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Ctx_intf",
      "library": "libzipperposition",
      "description": "This module defines a polymorphic context type `'a t` with operations to manage scoped environments, including binding and lookup of values. It supports data types like variables, terms, and substitutions, commonly used in theorem proving and term rewriting systems. Concrete use cases include tracking variable assignments during proof search and managing local definitions in logical contexts.",
      "description_length": 395,
      "index": 135,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Trail",
      "library": "libzipperposition",
      "description": "This module offers set-like operations for managing collections of boolean literals, including addition, removal, filtering, and merging of trails, which are represented as sets of logical constraints. It supports analysis through subset checks, contradiction detection, and conversion into logical formulas, while also enabling evaluation under specific valuations to determine constraint satisfaction. The functionality is particularly useful in logical reasoning contexts, such as merging constraint sets or validating assumptions during automated theorem proving.",
      "description_length": 567,
      "index": 136,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Saturate",
      "library": "libzipperposition",
      "description": "Implements the given clause algorithm for saturation-based theorem proving, handling inference generation and state reduction. Operates on logical clauses and proof states, managing active and passive clause sets. Used to drive automated reasoning steps, such as in resolution or superposition provers, by iteratively processing clauses and deriving new conclusions.",
      "description_length": 366,
      "index": 137,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Clause_intf",
      "library": "libzipperposition",
      "description": "This module defines core structures and operations for representing and manipulating logical clauses, including types for individual proof steps and full proofs. It works with abstract clause representations and proof objects, enabling precise tracking of logical derivations. Concrete use cases include building and analyzing resolution-based proofs in automated theorem proving systems.",
      "description_length": 388,
      "index": 138,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Bool_lit_intf",
      "library": "libzipperposition",
      "description": "This module defines operations for working with boolean literals, including creation, negation, and comparison. It handles data types representing boolean values and their logical expressions. Use cases include managing propositional logic in theorem proving and simplifying boolean constraints in formal verification tasks.",
      "description_length": 324,
      "index": 139,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.ProofState",
      "library": "libzipperposition",
      "description": "This module implements a proof state management system for automated theorem proving, centered around clause processing and indexing. It provides priority-based clause selection via a weighted queue, multiple specialized indexes for term and clause retrieval (including subsumption and unit propagation), and dynamic clause sets for active, passive, and simplification-focused workflows. Concrete use cases include guiding proof search by prioritizing relevant clauses, efficiently querying term relationships under substitutions, and maintaining indexed clause databases for resolution and simplification steps.",
      "description_length": 612,
      "index": 140,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Classify_cst",
      "library": "libzipperposition",
      "description": "This module classifies constants based on their role in inductive reasoning, distinguishing between types, constructors, projectors, defined constants, parameters, skolems, and others. It provides functions to query these roles, such as checking if an identifier is a constructor or a projector, and supports printing operations for result and signature types. It is used to guide term ordering and weighting strategies in automated reasoning tasks involving inductive types.",
      "description_length": 475,
      "index": 141,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition",
      "library": "libzipperposition",
      "description": "This module provides functionalities for clause processing, boolean logic operations, term classification, and context management, operating on logical terms, clauses, proof states, and boolean literals. It supports automated theorem proving tasks like superposition, induction, SAT solving, and constraint analysis, with optimized structures for memory-efficient stream processing and trail-based reasoning in heuristic-driven logical inference.",
      "description_length": 446,
      "index": 142,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_induction.Make",
      "library": "libzipperposition.induction",
      "description": "This module implements inference rules for inductive reasoning by registering them during initialization. It operates on term structures and clause sets, integrating induction schemes with equality reasoning. It is used to automate inductive proofs in equational theorem proving contexts.",
      "description_length": 288,
      "index": 143,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_induction",
      "library": "libzipperposition.induction",
      "description": "This module implements inductive reasoning through cut-based techniques, enabling proof search with induction hypotheses as constraints. It operates on logical formulas and proof states, integrating induction steps directly into the deduction process. Concrete use cases include automated theorem proving in formal verification and handling inductive data types in logical frameworks.",
      "description_length": 384,
      "index": 144,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_phases.Phases.Key",
      "library": "libzipperposition.phases",
      "description": "This module provides a state key to track the current phase during proof search. It works with phase identifiers and integrates with a flexible state system. Useful for managing and querying the current processing stage in automated reasoning tasks.",
      "description_length": 249,
      "index": 145,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_phases.Phases.Infix",
      "library": "libzipperposition.phases",
      "description": "This module defines infix operators for sequencing and transforming computations within a phased processing context. It supports monadic-style composition using `>>=`, error-aware chaining with `>>?=`, and result mapping via `>|=`. These operations are used to build and manipulate pipelines that process data through successive stages, such as parsing followed by transformation or validation followed by execution.",
      "description_length": 416,
      "index": 146,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_phases.Phases",
      "library": "libzipperposition.phases",
      "description": "This module offers a monadic framework for managing phase transitions and state manipulation in automated reasoning pipelines, providing operations for scoped execution, error handling, and sequencing computations using constructs like `bind`, `map`, and parallel combinators. It works with typed environments, clauses, and key-indexed state, making it particularly suited for orchestrating complex proof search processes where phased execution and dynamic state management are critical.",
      "description_length": 487,
      "index": 147,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_phases.Phases_impl",
      "library": "libzipperposition.phases",
      "description": "This module implements a sequence of phases for processing logic files, including parsing command-line arguments, loading extensions, processing files through type inference and clause saturation, printing results, and checking proofs. It operates on logic formulas, environments, and state transitions, tracking progress through phase tags like `[ `Parse_cli ]` to `[ `Saturate ]`. Concrete use cases include running a theorem prover from the command line or embedding it in a library, processing input files to saturation, and outputting results in standardized formats.",
      "description_length": 572,
      "index": 148,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_phases",
      "library": "libzipperposition.phases",
      "description": "This module orchestrates automated reasoning workflows through a structured sequence of phases, handling tasks like parsing, type checking, clause processing, and proof search. It manages state transitions across phases using typed environments and logic formulas, enabling precise control over theorem proving pipelines. Use cases include executing command-line theorem provers, processing logic files to saturation, and integrating proof search into larger systems.",
      "description_length": 467,
      "index": 149,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Superposition.Make.PS.CQueue.PriorityFun",
      "library": "libzipperposition.calculi",
      "description": "Implements priority functions for clause weighting in superposition-based theorem proving. It assigns integer priorities to clauses based on parsed string descriptions of weight functions. Used to guide clause selection during automated reasoning tasks.",
      "description_length": 253,
      "index": 150,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Superposition.Make.PS.UnitIndex.E",
      "library": "libzipperposition.calculi",
      "description": "This module represents and compares indexed equations with their terms, signs, and associated clauses. It provides operations to extract components of equations, compare them, and assess their priority for use in superposition-based theorem proving. The module works directly with terms, equations, and clauses to support indexing and selection during proof search.",
      "description_length": 365,
      "index": 151,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Heuristics.Make.PS.CQueue.WeightFun",
      "library": "libzipperposition.calculi",
      "description": "This module defines weight functions for prioritizing clauses in a priority queue based on heuristic criteria. It supports operations like parsing weight function descriptions, combining multiple weight functions with coefficients, and applying specific heuristics such as favoring ground or Horn clauses. Use cases include guiding clause selection in automated theorem proving by assigning dynamic weights based on clause properties like penalty, goal proximity, or literal composition.",
      "description_length": 487,
      "index": 152,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Superposition.Make.PS.CQueue.C",
      "library": "libzipperposition.calculi",
      "description": "This module provides operations to manage clause properties (e.g., redundancy, goal status), manipulate trails and proofs, analyze clause structure for inference eligibility, and transform clauses for output. It works with clauses, trails, proof steps, and literals, supporting superposition-based theorem proving, trail-driven reasoning, and TSTP-compliant proof generation.",
      "description_length": 375,
      "index": 153,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Heuristics.Make.PS.CQueue.C",
      "library": "libzipperposition.calculi",
      "description": "This module provides operations to manage and query clause properties such as redundancy, simplification status, and goal-related metrics, alongside utilities for trail manipulation, proof extraction, and resolution/paramodulation eligibility checks. It operates on clauses (`PS.CQueue.C.t`) and integrates with scoped terms (`Logtk.Scoped.t`), substitutions (`Logtk.Subst.t`), and bitvector-based representations for efficient literal and symbol tracking. These capabilities are used in theorem proving to prioritize clauses during search, transform proofs, and optimize reasoning steps like grounding or \u03b7-reduction.",
      "description_length": 618,
      "index": 154,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Heuristics.Make.PS.CQueue.PriorityFun",
      "library": "libzipperposition.calculi",
      "description": "Implements priority functions for clause selection in saturation provers, assigning integer weights to clauses based on configurable heuristics. Accepts string-based configuration to define weight calculation strategies, enabling dynamic control over proof search. Used to prioritize clauses during automated reasoning tasks in theorem proving.",
      "description_length": 344,
      "index": 155,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Superposition.Make.PS.CQueue.WeightFun",
      "library": "libzipperposition.calculi",
      "description": "This module defines weight functions for prioritizing clauses in a superposition prover. It includes functions like `default`, `penalty`, and specialized ones like `favor_all_neg` and `favor_goal` to influence clause selection based on logical properties. These functions assign integer weights to clauses, guiding the prover's search strategy.",
      "description_length": 344,
      "index": 156,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Superposition.Make.PS.SubsumptionIndex.C",
      "library": "libzipperposition.calculi",
      "description": "This module implements a subsumption index for clauses, providing operations to compare clauses, iterate over their literals, and access label subsets. It works with clause data structures that support literal extraction and label tracking. Concrete use cases include efficient subsumption checking during saturation-based theorem proving.",
      "description_length": 339,
      "index": 157,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Heuristics.Make.PS.SubsumptionIndex.C",
      "library": "libzipperposition.calculi",
      "description": "This module defines operations for comparing clauses, extracting literals, and managing labels associated with clauses. It works directly with clause data structures, enabling subsumption checks through label subsets and literal iteration. Concrete use cases include clause indexing and subsumption-based simplification in automated theorem proving.",
      "description_length": 349,
      "index": 158,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Superposition.Make.PS.TermIndex.Leaf",
      "library": "libzipperposition.calculi",
      "description": "This module implements a term index structure for efficient retrieval of terms under a superposition calculus, supporting operations like adding or removing indexed terms, iterating over entries, and performing unification or matching queries. It works with terms from the `Logtk.Index_intf` module and elements of type `elt`, which are associated with indexed terms. Concrete use cases include managing clauses during automated theorem proving, enabling fast lookups when applying inference rules like paramodulation or resolution.",
      "description_length": 532,
      "index": 159,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Heuristics.Make.PS.TermIndex.Leaf",
      "library": "libzipperposition.calculi",
      "description": "This module implements a term index structure for efficient retrieval of terms based on unification and matching operations. It supports adding, removing, and updating indexed terms along with their associated values, and provides iteration and folding over indexed entries. It is used in theorem proving systems to quickly find matching or unifiable terms during proof search.",
      "description_length": 377,
      "index": 160,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Heuristics.Make.PS.UnitIndex.E",
      "library": "libzipperposition.calculi",
      "description": "This module represents and compares indexed equations with their terms, signs, and associated clauses. It provides operations to extract components of equations, compare them for ordering, and determine their priority for use in theorem proving. It is used to manage and select equations efficiently during automated reasoning tasks.",
      "description_length": 333,
      "index": 161,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Heuristics.Make.C.ClauseSet",
      "library": "libzipperposition.calculi",
      "description": "This module supports operations for managing ordered sets of clauses, including membership tests, insertion, deletion, union, intersection, difference, subset checks, iteration, mapping, folding, and predicate checking. It works with ordered sets using `C.t` elements, maintaining a total order via the `Ord.compare` function from its functor instantiation. Designed for theorem proving contexts, it enables efficient clause filtering, partitioning, ordered traversal (e.g., retrieving min/max clauses), conversion between lists/sequences, and customizable string representations for debugging or logging.",
      "description_length": 605,
      "index": 162,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Booleans.Make.C.WithPos",
      "library": "libzipperposition.calculi",
      "description": "This module represents clauses with a specific subterm and its position, enabling precise term manipulation and comparison. It provides a structured way to associate a clause, a term, and its logical position, facilitating targeted transformations and analyses. Useful in theorem proving contexts where positional information within clauses is critical for inference steps.",
      "description_length": 373,
      "index": 163,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.EnumTypes.Make.C.Pos",
      "library": "libzipperposition.calculi",
      "description": "This module provides a function `at` that retrieves a term at a specific position within a clause. It operates on clauses and positions, enabling precise navigation and manipulation of term structures. Useful for tasks like clause indexing or proof reconstruction where positional access to subterms is required.",
      "description_length": 312,
      "index": 164,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Fool.Make.C.Seq",
      "library": "libzipperposition.calculi",
      "description": "This module provides functions to extract literals, terms, and variables from a clause structure. It works with clause (`C.t`), literal (`Logtk.Literal.t`), term (`Logtk.Term.t`), and typed variable (`Logtk.Type.t Logtk.HVar.t`) data types. Concrete use cases include analyzing or transforming logical clauses by inspecting their constituent literals, terms, or variable bindings during proof search or clause processing.",
      "description_length": 421,
      "index": 165,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Superposition.Make.C.Eligible",
      "library": "libzipperposition.calculi",
      "description": "This module defines eligibility criteria for selecting literals in superposition-based theorem proving. It provides functions to filter literals based on properties such as positivity, negativity, equation status, and maximality within a clause. These criteria can be combined using logical operations to control which literals are used in resolution, paramodulation, or other inference steps.",
      "description_length": 393,
      "index": 166,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Heuristics.Make.C.WithPos",
      "library": "libzipperposition.calculi",
      "description": "This module represents clauses with a specific subterm and its position, enabling precise term manipulation and comparison. It provides a data structure that combines a clause, a term, and its logical position, supporting operations like ordering and pretty-printing. It is used in proof search and term rewriting to track and compare subterms within clauses.",
      "description_length": 359,
      "index": 167,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.EnumTypes.Make.C.WithPos",
      "library": "libzipperposition.calculi",
      "description": "This module represents clauses with a specific subterm and its position, enabling precise term manipulation and analysis. It provides comparison and pretty-printing operations for these structured clauses. Useful for tasks like subterm indexing, rewriting, or focused proof search where term positions matter.",
      "description_length": 309,
      "index": 168,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Superposition.Make.C.Tbl",
      "library": "libzipperposition.calculi",
      "description": "This module implements hash tables with keys of a fixed type (`C.t`) and arbitrary value types, enabling efficient key-based operations like insertion, lookup, in-place transformations, and bulk updates from sequences. It supports advanced manipulations such as merging duplicate keys with custom functions, counter-like incrementing, and conversions between tables and lists, making it ideal for scenarios requiring structured associative data management, such as term indexing or frequency tracking in symbolic computations.",
      "description_length": 526,
      "index": 169,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Booleans.Make.C.ClauseSet",
      "library": "libzipperposition.calculi",
      "description": "This module provides ordered, immutable sets of clauses with operations for functional set manipulation, including union, intersection, difference, and ordered traversal via `map`, `fold`, and `iter`. It works with `C.ClauseSet.t` structures, which enforce a specific element ordering (`Ord.compare`), and supports safe querying (e.g., `find_first_map`, `find_last_opt`), bulk conversions to/from lists/sequences, and custom formatting. It is suited for applications requiring precise clause management in ordered contexts, such as formal verification or automated reasoning systems where immutability and deterministic traversal are critical.",
      "description_length": 643,
      "index": 170,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Hlt_elim.Make.C.Seq",
      "library": "libzipperposition.calculi",
      "description": "This module provides functions to extract literals, terms, and variables from a clause structure. It works with data types such as clauses (`C.t`), literals (`Logtk.Literal.t`), terms (`Logtk.Term.t`), and typed variables (`Logtk.Type.t Logtk.HVar.t`). Concrete use cases include analyzing or transforming logical clauses by inspecting their constituent literals, terms, or variable bindings during proof search or term rewriting.",
      "description_length": 430,
      "index": 171,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Higher_order.Make.C.Eligible",
      "library": "libzipperposition.calculi",
      "description": "This module defines predicates to select eligible literals in clauses for specific inference rules in automated theorem proving. It supports operations like filtering by resolution, paramodulation, equation status, sign, and maximality, with combinators for composing conditions using logical operators. These predicates are applied to clauses to determine which literals can participate in further reasoning steps.",
      "description_length": 415,
      "index": 172,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Higher_order.Make.C.WithPos",
      "library": "libzipperposition.calculi",
      "description": "This module represents clauses with a specific subterm and its position, enabling precise manipulation and analysis of terms within clauses. It provides comparison and pretty-printing operations for these structured clauses. Useful for implementing higher-order reasoning rules that require tracking term positions within logical expressions.",
      "description_length": 342,
      "index": 173,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Heuristics.Make.C.Tbl",
      "library": "libzipperposition.calculi",
      "description": "This implementation offers imperative hash table operations (insertion, removal, iteration) and functional transformations (folding, mapping, filtering) over key-value stores with keys of type `C.Tbl.key` and arbitrary value types. It supports advanced use cases like merging tables with custom conflict resolution, tracking integer counters, and bulk data conversion between sequences/lists, while providing utilities for inspecting table statistics and customizing value printing. The design emphasizes efficient in-place modifications and combinator-based value updates for scenarios like frequency counting or aggregating list-valued results.",
      "description_length": 646,
      "index": 174,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Heuristics.Make.C.Eligible",
      "library": "libzipperposition.calculi",
      "description": "This module defines eligibility criteria for selecting literals in a clause based on logical operations and specific properties such as positivity, negativity, maximality, and equation status. It provides functions to filter literals for resolution, paramodulation, or custom conditions, and supports combining criteria using logical conjunction, disjunction, and negation. Use cases include guiding inference rules in automated theorem proving by restricting which literals can participate in resolution or paramodulation steps.",
      "description_length": 529,
      "index": 175,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Hlt_elim.Make.C.Eligible",
      "library": "libzipperposition.calculi",
      "description": "This module defines eligibility criteria for selecting literals in a clause based on specific logical properties. It provides functions to filter literals by type (positive, negative, equations), role (resolution, paramodulation), and position (maximal), as well as to combine and negate these criteria. These operations are used to control inference rules in automated theorem proving, such as restricting resolution to certain literals or prioritizing specific equation orientations.",
      "description_length": 485,
      "index": 176,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Hlt_elim.Make.C.Tbl",
      "library": "libzipperposition.calculi",
      "description": "This module implements imperative hash tables for keys of type `C.t`, offering standard operations like insertion, lookup, deletion, iteration, and table management (creation, clearing, copying), along with in-place filtering and folding. It supports bulk updates from sequences, value transformations, and custom merging strategies for duplicates, with utilities for element frequency counting, list conversions, and customizable value printing, making it suitable for tasks like symbol resolution, dynamic data aggregation, or cache management where efficient key-value tracking and flexible update policies are required.",
      "description_length": 623,
      "index": 177,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Higher_order.Make.C.ClauseSet",
      "library": "libzipperposition.calculi",
      "description": "This module implements an ordered set structure for clauses with efficient membership checks, transformations, and relational operations, using a comparison function to maintain element order. It supports functional manipulation of clause collections through union/intersection/difference operations, predicate-based filtering, extremal element queries, and safe conversions to sequences or lists. Designed for higher-order logic applications, it enables tasks like clause normalization, subsumption checking, and iterative proof search while preserving physical equality during immutable updates.",
      "description_length": 597,
      "index": 178,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Superposition.Make.C.Seq",
      "library": "libzipperposition.calculi",
      "description": "This module provides functions to extract literals, terms, and variables from clauses. It works with clause (`C.t`), literal, term, and variable data types. Use it to analyze or transform logical clauses by inspecting their constituent elements.",
      "description_length": 245,
      "index": 179,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Superposition.Make.PS.SubsumptionIndex",
      "library": "libzipperposition.calculi",
      "description": "This module implements a subsumption index for clauses, providing operations to compare clauses, iterate over their literals, and access label subsets. It works with clause data structures that support literal extraction and label tracking. Concrete use cases include efficient subsumption checking during saturation-based theorem proving.",
      "description_length": 339,
      "index": 180,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Heuristics.Make.C.Seq",
      "library": "libzipperposition.calculi",
      "description": "This module provides functions to extract literals, terms, and variables from clauses. It works with clause (`C.t`), literal (`Logtk.Literal.t`), term (`Logtk.Term.t`), and variable (`Logtk.HVar.t`) data types. Use it to analyze or transform logical clauses by inspecting their components during theorem proving or formula manipulation tasks.",
      "description_length": 342,
      "index": 181,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Superposition.Make.PS.PassiveSet",
      "library": "libzipperposition.calculi",
      "description": "This module manages a passive clause set for a superposition prover, supporting operations to add and remove clauses, query clause status, and retrieve the next clause to process. It works with clause sets and queues, tracking clause state through signals and boolean checks. Concrete use cases include managing passive clauses during theorem proving, enabling dynamic clause processing and prioritization in saturation-based reasoning.",
      "description_length": 436,
      "index": 182,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Booleans.Make.C.Pos",
      "library": "libzipperposition.calculi",
      "description": "This module provides a function `at` that retrieves a term at a specified position within a clause. It operates on clauses and positions, enabling precise navigation and manipulation of logical terms during proof search or term rewriting tasks. A concrete use case is extracting subterms from clauses during the application of inference rules in automated theorem proving.",
      "description_length": 372,
      "index": 183,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Fool.Make.C.ClauseSet",
      "library": "libzipperposition.calculi",
      "description": "This module supports functional manipulation of ordered clause sets with operations like membership testing, union, intersection, and ordered traversal, using an immutable sorted structure optimized for efficient subset checks and transformations. It works with immutable sets of clauses (`C.t`), leveraging a comparator to enable ordered operations such as min/max retrieval, filtering, and safe element selection, while providing conversions to lists, sequences, and formatted strings. It is particularly useful in automated reasoning systems where ordered clause management is critical, such as in superposition-based theorem proving, to ensure efficient set manipulations and predicate-driven traversals.",
      "description_length": 708,
      "index": 184,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Fool.Make.C.WithPos",
      "library": "libzipperposition.calculi",
      "description": "This module represents clauses with a specific subterm and its position, enabling precise manipulation and analysis of terms within clauses. It provides comparison and pretty-printing operations for these structured clauses. Use cases include tracking term occurrences in proof search and analyzing subterm positions during clause processing.",
      "description_length": 342,
      "index": 185,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Hlt_elim.Make.C.ClauseSet",
      "library": "libzipperposition.calculi",
      "description": "This module provides operations for managing ordered sets of clauses, supporting set operations like union, intersection, and difference, as well as ordered traversal, element filtering, and extremal element queries (e.g., min/max). It works with `C.ClauseSet.t` sets containing elements of type `C.ClauseSet.elt`, which are ordered using a total ordering derived from the `Ord` module. These capabilities are used in automated reasoning systems to manipulate clause sets during proof search, enabling efficient transformations, predicate-based searches, and structured output generation via list/sequence conversions.",
      "description_length": 618,
      "index": 186,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Fool.Make.C.Tbl",
      "library": "libzipperposition.calculi",
      "description": "This module implements a hash table structure for key-value pairs where keys conform to type `C.t`, offering imperative operations for insertion, lookup, and in-place modification with customizable handling of duplicate keys. It supports advanced transformations through sequence and iterator conversions, in-place filtering, and value aggregation with user-defined functions, enabling efficient table construction and manipulation. Typical applications include tracking term frequencies from streams, merging symbolic mappings with conflict resolution, and formatting structured data for debugging or logging outputs.",
      "description_length": 618,
      "index": 187,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Lazy_cnf.Make.C.Pos",
      "library": "libzipperposition.calculi",
      "description": "This module provides a function `at` that retrieves a term at a specific position within a clause. It operates on clauses (`C.t`) and positions (`Logtk.Position.t`), enabling precise access to subterms during proof search or term analysis. Use cases include implementing position-based rewriting or analyzing clause structure in automated theorem proving.",
      "description_length": 355,
      "index": 188,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Superposition.Make.PS.UnitIndex",
      "library": "libzipperposition.calculi",
      "description": "This module implements an index for unit equations used in superposition-based theorem proving. It supports efficient insertion, removal, and retrieval of equations based on term structure and substitution matching, working directly with terms, equations, and substitutions. Use cases include selecting candidate equations during proof search and finding generalizations of terms under variable bindings.",
      "description_length": 404,
      "index": 189,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Heuristics.Make.PS.UnitIndex",
      "library": "libzipperposition.calculi",
      "description": "This module implements an indexing structure for managing and retrieving equations based on term patterns. It supports operations to add, remove, and query equations, with efficient retrieval of matching or generalizing terms under substitutions. It is used in automated theorem proving to quickly find applicable rewrite rules or inference candidates.",
      "description_length": 352,
      "index": 190,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Higher_order.Make.C.Pos",
      "library": "libzipperposition.calculi",
      "description": "Extracts a subterm from a given term at a specified position. Works with terms and positions in a term structure. Useful for precise term manipulation and analysis during proof search or term rewriting.",
      "description_length": 202,
      "index": 191,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Heuristics.Make.PS.CQueue",
      "library": "libzipperposition.calculi",
      "description": "This implementation provides priority queues for managing clauses in automated reasoning systems, supporting operations to insert, retrieve, and prioritize elements based on configurable heuristics. It works with clauses annotated with weight and priority functions, enabling dynamic selection strategies during proof search, such as favoring smaller or goal-proximate clauses. The structure also includes utilities for membership checks, removal, and human-readable inspection, making it suitable for iterative refinement of clause sets in theorem proving workflows.",
      "description_length": 567,
      "index": 192,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Booleans.Make.C.Eligible",
      "library": "libzipperposition.calculi",
      "description": "This module defines eligibility criteria for selecting literals in a clause based on logical operations and properties such as positivity, negativity, maximality, and equation status. It provides functions to filter literals for resolution, paramodulation, and custom conditions, supporting precise control over inference rules in automated theorem proving. Operations include logical combinations (and, or, not) of eligibility predicates to build complex selection rules.",
      "description_length": 472,
      "index": 193,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Higher_order.Make.C.Seq",
      "library": "libzipperposition.calculi",
      "description": "This module provides functions to extract literals, terms, and typed variables from a given clause structure. It operates on clauses (`C.t`), producing iterators over literals, terms, and type-annotated variables. Useful for analyzing or transforming logical clauses during theorem proving or term rewriting tasks.",
      "description_length": 314,
      "index": 194,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.EnumTypes.Make.C.Tbl",
      "library": "libzipperposition.calculi",
      "description": "This module implements imperative hash tables with keys of type `C.t`, supporting operations like insertion, lookup, deletion, iteration, and in-place transformations. It provides utilities for bulk updates from sequences or iterators, merging duplicate keys with custom combinators, and converting between hash tables, lists, and iterators, while enabling advanced use cases like lazy initialization or frequency counting. The structure is optimized for managing dynamic key-value associations where precise control over collisions and efficient aggregation of streaming data are required.",
      "description_length": 590,
      "index": 195,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Lazy_cnf.Make.C.Seq",
      "library": "libzipperposition.calculi",
      "description": "This module provides functions to iterate over literals, terms, and variables contained in a clause. It works with clause structures (`C.t`) and returns iterators for literals, terms, and typed variables. Useful for analyzing or transforming logical clauses by accessing their components in a sequential manner.",
      "description_length": 311,
      "index": 196,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Lazy_cnf.Make.C.Eligible",
      "library": "libzipperposition.calculi",
      "description": "This module defines predicates to select eligible literals in clauses for specific inference rules. It supports operations like filtering by resolution, paramodulation, equation, positivity, negativity, and maximality, combining criteria using logical operators. These predicates are used to implement theorem-proving strategies that require precise control over literal selection.",
      "description_length": 381,
      "index": 197,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Heuristics.Make.PS.ActiveSet",
      "library": "libzipperposition.calculi",
      "description": "This module maintains a dynamic set of clauses with operations to add or remove clauses, retrieve the current set, and track clause count. It provides signals triggered on clause additions and removals for reactive updates. Useful in theorem proving contexts where clause sets evolve during search, enabling monitoring and response to changes in the active clause set.",
      "description_length": 368,
      "index": 198,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Heuristics.Make.C.Pos",
      "library": "libzipperposition.calculi",
      "description": "This module provides a function `at` that retrieves a subterm from a given term at a specified position. It operates on terms represented by the `C.t` type and positions defined by `Logtk.Position.t`. A typical use case involves accessing specific parts of logical expressions during proof search or term manipulation tasks.",
      "description_length": 324,
      "index": 199,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.EnumTypes.Make.C.Eligible",
      "library": "libzipperposition.calculi",
      "description": "This module defines eligibility criteria for selecting literals in clausal reasoning, using a function type that determines whether a literal at a given position in a clause qualifies. It provides operations to construct and combine criteria, such as selecting literals eligible for resolution, paramodulation, positivity, negativity, or maximality within a clause. These criteria can be composed using logical operations like conjunction, disjunction, and negation, enabling precise control over literal selection in proof search procedures.",
      "description_length": 542,
      "index": 200,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Booleans.Make.C.Seq",
      "library": "libzipperposition.calculi",
      "description": "This module provides functions to extract literals, terms, and variables from a clause structure. It works with clause (`C.t`), literal (`Logtk.Literal.t`), term (`Logtk.Term.t`), and variable (`Logtk.HVar.t`) types. Useful for analyzing or transforming logical clauses in automated reasoning tasks.",
      "description_length": 299,
      "index": 201,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Hlt_elim.Make.C.WithPos",
      "library": "libzipperposition.calculi",
      "description": "This module represents clauses with a specific subterm and its position, enabling precise term manipulation and analysis. It provides comparison and pretty-printing operations for these structured clauses. Useful for implementing rewriting or inference rules that require tracking subterm positions within logical expressions.",
      "description_length": 326,
      "index": 202,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Fool.Make.C.Eligible",
      "library": "libzipperposition.calculi",
      "description": "This module defines eligibility criteria for selecting literals in a clause based on specific logical properties. It provides functions to filter literals by resolution, paramodulation, positivity, negativity, maximality, and equation status, as well as logical combinations of these conditions. These criteria are used to control inference rules in automated theorem proving, such as restricting resolution or paramodulation steps to certain literals.",
      "description_length": 452,
      "index": 203,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Superposition.Make.PS.ActiveSet",
      "library": "libzipperposition.calculi",
      "description": "This module manages a dynamic set of clauses with support for adding, removing, and querying clauses. It provides signals triggered on clause insertion and removal, and exposes the current clause set as a set data structure. It is used to maintain and monitor the active set of clauses during theorem proving processes.",
      "description_length": 319,
      "index": 204,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Superposition.Make.C.WithPos",
      "library": "libzipperposition.calculi",
      "description": "This module represents clauses with a specific subterm and its position, enabling precise term manipulation and analysis. It provides comparison and pretty-printing operations for these structured clauses. Useful for implementing superposition-based theorem proving rules that require tracking term positions within clauses.",
      "description_length": 324,
      "index": 205,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Superposition.Make.C.Pos",
      "library": "libzipperposition.calculi",
      "description": "This module provides a function `at` that retrieves a term at a specific position within a clause. It operates on clauses (`C.t`) and positions (`Logtk.Position.t`), enabling precise navigation of term structures. Use it to inspect or manipulate subterms in logical expressions during proof search or term rewriting.",
      "description_length": 316,
      "index": 206,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Lazy_cnf.Make.C.WithPos",
      "library": "libzipperposition.calculi",
      "description": "This module represents clauses with a specific subterm and its position, enabling precise manipulation and analysis of terms within clauses. It provides comparison and pretty-printing operations for these annotated clauses. Useful for implementing transformations or analyses that require tracking subterm positions within logical formulas.",
      "description_length": 340,
      "index": 207,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Heuristics.Make.PS.SimplSet",
      "library": "libzipperposition.calculi",
      "description": "This module manages a set of clauses with operations to add or remove clauses and trigger signals on these changes. It uses an underlying set structure to store clauses and provides iteration-based updates for batch modifications. It is used in clause management systems where tracking additions and removals is necessary, such as in theorem proving or logic solvers.",
      "description_length": 367,
      "index": 208,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Booleans.Make.C.Tbl",
      "library": "libzipperposition.calculi",
      "description": "This module offers a comprehensive suite of hash table operations for mappings between keys of type `C.t` and arbitrary values, emphasizing efficient data manipulation and transformation. It supports key-based aggregation (e.g., counting occurrences from sequences), in-place updates with combinators, and bidirectional conversion between tables and iterables, while providing safety-focused retrieval and bulk insertion. Use cases include symbolic data processing, frequency analysis, and structured serialization of heterogeneous data.",
      "description_length": 537,
      "index": 209,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Superposition.Make.PS.CQueue",
      "library": "libzipperposition.calculi",
      "description": "This module manages priority queues of clauses for a superposition prover, offering operations to add, prioritize, retrieve, and remove clauses based on configurable weight and strategy functions. It supports specialized queue implementations like FIFO, goal-oriented, and ground clause-favoring strategies, along with debugging tools for membership checks and string representations, facilitating tasks such as passive set management, redundancy elimination, and proof-state integration.",
      "description_length": 488,
      "index": 210,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Superposition.Make.PS.C",
      "library": "libzipperposition.calculi",
      "description": "This module provides operations for managing clause metadata (e.g., redundancy flags, goal status), constructing and modifying clauses with trails and proofs, analyzing clause properties for inference eligibility (like literal selection and paramodulation), and transforming clauses through grounding or substitution. It works with clauses, trails, substitutions, and bitvectors, supporting use cases in automated theorem proving such",
      "description_length": 434,
      "index": 211,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Heuristics.Make.PS.PassiveSet",
      "library": "libzipperposition.calculi",
      "description": "This module manages a passive clause set with dynamic addition and removal, providing signals for tracking changes. It supports operations to query, add, remove, and process clauses, along with checking passivity and counting clauses. It is used to implement heuristic-driven clause selection strategies in automated theorem proving.",
      "description_length": 333,
      "index": 212,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Hlt_elim.Make.C.Pos",
      "library": "libzipperposition.calculi",
      "description": "This module provides a function `at` that retrieves a subterm from a given term at a specified position. It operates on terms and positions, enabling precise navigation within term structures. Useful for tasks like term rewriting or analysis where specific subterms need to be accessed or modified.",
      "description_length": 298,
      "index": 213,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Heuristics.Make.PS.TermIndex",
      "library": "libzipperposition.calculi",
      "description": "The module implements a term indexing structure optimized for unification and matching operations on logical terms, enabling efficient retrieval of terms that can be unified, generalized, or specialized with substitutions. It manages associations between terms and arbitrary values, supporting dynamic updates and queries for theorem-proving scenarios like clause subsumption or lemma application. A dedicated visualization tool generates DOT-formatted graphs of the index, aiding in debugging and analysis of term relationships.",
      "description_length": 529,
      "index": 214,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Higher_order.Make.C.Tbl",
      "library": "libzipperposition.calculi",
      "description": "This module provides imperative hash table operations for managing key-value pairs with keys of type `C.t`, including insertion, lookup, deletion, and iteration, alongside higher-order functions for folding, filtering, and converting to sequences. It operates on parameterized hash tables (`'a C.Tbl.t`), supporting bulk updates from sequences/iterators, conflict-resolution strategies during merges, and transformations like incrementing counters or appending to stored lists. Common use cases include counting elements",
      "description_length": 520,
      "index": 215,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Superposition.Make.PS.TermIndex",
      "library": "libzipperposition.calculi",
      "description": "This module implements a hierarchical term indexing structure optimized for superposition-based automated reasoning, enabling efficient unification, matching, and subsumption checks by organizing terms alongside clause-position metadata. It supports dynamic term insertion/removal, context-scoped retrieval of unifiable terms, and hierarchical visualization via DOT format output, primarily serving performance-sensitive tasks in logical inference engines.",
      "description_length": 456,
      "index": 216,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Heuristics.Make.PS.SubsumptionIndex",
      "library": "libzipperposition.calculi",
      "description": "This module implements a subsumption index for efficient clause retrieval in automated theorem proving. It supports operations to add, remove, and query clauses based on subsumption and alpha-equivalence, using clause literals and labels. Use cases include clause indexing for resolution provers and subsumption-based redundancy elimination.",
      "description_length": 341,
      "index": 217,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Superposition.Make.PS.SimplSet",
      "library": "libzipperposition.calculi",
      "description": "This module manages a set of clauses with operations to add or remove clauses and trigger signals on these changes. It works with clause data structures and supports iteration over clauses. It is used to track clause modifications in a theorem proving context.",
      "description_length": 260,
      "index": 218,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Lazy_cnf.Make.C.Tbl",
      "library": "libzipperposition.calculi",
      "description": "This module offers imperative and functional hash table operations for keys of type `C.t`, supporting safe lookups, in-place modifications (`replace_seq`, `incr`), bulk construction from sequences/iterators, and collision handling via custom merge functions. It manipulates hash tables (`C.Tbl.t`) with arbitrary value types, emphasizing utilities for counting elements, aggregating key-value pairs, and lazy value insertion. Specific use cases include tracking term frequencies during CNF transformation, managing substitution mappings, or aggregating intermediate results in logical reasoning pipelines where precise key collision semantics are required.",
      "description_length": 656,
      "index": 219,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Fool.Make.C.Pos",
      "library": "libzipperposition.calculi",
      "description": "This module provides a function `at` that retrieves a term at a specified position within a clause. It operates on clauses and term positions to access specific subterms. Useful for proof search and term manipulation in automated theorem proving.",
      "description_length": 246,
      "index": 220,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.EnumTypes.Make.C.Seq",
      "library": "libzipperposition.calculi",
      "description": "This module provides functions to extract literals, terms, and variables from a clause structure. It works with clauses (`C.t`), iterating over their components as sequences. Use it to analyze or transform logical clauses by processing their constituent literals, terms, or typed variables.",
      "description_length": 290,
      "index": 221,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Lazy_cnf.Make.C.ClauseSet",
      "library": "libzipperposition.calculi",
      "description": "This module offers an immutable, ordered set abstraction for managing clauses, supporting standard set operations like union, intersection, and difference, alongside ordered traversal, extremal element retrieval, and predicate-based filtering. It maintains elements in sorted order using a total ordering derived from the clause type, with conversions to lists, sequences, and string representations for interoperability and debugging. Such functionality is particularly useful in logical reasoning systems requiring efficient clause set manipulation and ordered processing, such as automated theorem proving or SAT solving.",
      "description_length": 624,
      "index": 222,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Heuristics.Make.C",
      "library": "libzipperposition.calculi",
      "description": "This module provides operations for managing clause metadata (e.g., redundancy flags, weights, literals), constructing and modifying clauses with trails and proofs, analyzing inference rule eligibility (resolution, paramodulation), and transforming clauses through substitutions or reductions. It works with clauses (`C.t`), specialized hash tables (`Tbl`), trails (`Trail.t`), substitutions, and clause sets, emphasizing efficient equality checks and property tracking. These capabilities support automated reasoning tasks like clause simplification, proof generation, and heuristic-driven inference in theorem provers.",
      "description_length": 620,
      "index": 223,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Booleans.Make.C",
      "library": "libzipperposition.calculi",
      "description": "This module provides operations for managing boolean properties of logical clauses (e.g., redundancy, simplification status, goal derivation), constructing and transforming clauses with trails, proofs, and semantic annotations, and manipulating substitutions, bitvectors, and literal selections for resolution-based inference. It operates on clauses, substitutions, literals, and positional term data, enabling precise control over proof search and inference rule application. These capabilities are applied in automated theorem proving for tasks like redundancy elimination, eligibility tracking, and verifying axioms or subsumption relationships in logical reasoning.",
      "description_length": 669,
      "index": 224,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Higher_order.Make.C",
      "library": "libzipperposition.calculi",
      "description": "This module offers operations for managing clause metadata (boolean flags, redundancy, simplification markers) and constructing clauses with trails, proofs, and associated metadata. It supports clause analysis (eligibility checks, literal/term properties, maximal subterms) and transformations (substitution, eta-reduction, grounding), integrating with data structures like hash tables, clause sets, and positional term accessors. It is used in higher-order theorem proving for resolution, paramodulation, proof extraction, and automated reasoning tasks requiring clause manipulation and simplification.",
      "description_length": 603,
      "index": 225,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Superposition.Make.C",
      "library": "libzipperposition.calculi",
      "description": "This module provides operations for managing clause properties like redundancy, simplification, and goal detection, while enabling trail-based clause manipulation and proof extraction to track logical dependencies. It operates on clauses, trails, substitutions, and structures such as hash tables (Tbl) and bitvectors, incorporating specialized logic for literal selection (Eligible, Pos) and term analysis. These capabilities support superposition-based theorem proving tasks, including clause normalization, grounding, and eligibility checks for resolution or paramodulation inference rules.",
      "description_length": 593,
      "index": 226,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Lazy_cnf.Make.C",
      "library": "libzipperposition.calculi",
      "description": "This module focuses on clause manipulation and analysis for automated reasoning, offering operations to manage flags, track redundancy, compute weights, and determine goal status. It supports transformations like proof extraction, literal eligibility checks, and term position tracking across clauses (`C.t`), trails (`Trail.t`), substitutions, and bitvectors. Designed for theorem proving workflows, it enables tasks such as resolution, paramodulation, and term rewriting through specialized data structures like hash tables (`Tbl`) and clause sets (`ClauseSet`).",
      "description_length": 564,
      "index": 227,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Heuristics.Make.PS",
      "library": "libzipperposition.calculi",
      "description": "This module implements a clause management system for automated theorem proving, combining priority queues, term indexing, and clause set tracking to support dynamic clause selection and inference. It provides data structures for prioritizing clauses during proof search, indexing terms and equations for efficient retrieval, and maintaining active, simplified, and passive clause sets with change notifications. Concrete use cases include guiding resolution provers with heuristic strategies, managing clause evolution during search, and enabling efficient subsumption and rewriting operations.",
      "description_length": 595,
      "index": 228,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Superposition.Make.PS",
      "library": "libzipperposition.calculi",
      "description": "This module implements a superposition prover state with clause management, indexing, and proof search control. It provides functions to process clauses using priority queues, perform term and subsumption indexing, and maintain active, passive, and simplified clause sets with change notifications. It is used for implementing saturation-based theorem proving loops with efficient clause selection, redundancy checking, and inference control.",
      "description_length": 442,
      "index": 229,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.EnumTypes.Make.C",
      "library": "libzipperposition.calculi",
      "description": "This module provides operations for clause property management (flags, redundancy, equality checks), trail-based clause manipulation, proof extraction, and eligibility analysis for inference rules. It works with clauses (`C.t`), trails (`Trail.t`), substitutions (`Logtk.Subst.t`), and specialized structures like imperative hash tables (`Tbl`) and positional term accessors, enabling tasks such as logical clause reduction, symbol extraction, and first-order proof search in automated reasoning systems.",
      "description_length": 504,
      "index": 230,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Fool.Make.C",
      "library": "libzipperposition.calculi",
      "description": "This module provides operations for manipulating logical clauses through boolean flag management, proof and trail handling, and eligibility checks for inference rules, while supporting transformations like substitution application and clause reduction. It works with clauses, trails, substitutions, and ordered clause sets to enable automated theorem proving tasks such as superposition, resolution, and redundancy analysis. Key use cases include proof search optimization, logical property verification, and inference control in formal reasoning systems.",
      "description_length": 555,
      "index": 231,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Hlt_elim.Make.C",
      "library": "libzipperposition.calculi",
      "description": "This module manages clause metadata, logical transformations, and inference control in automated reasoning systems. It operates on clauses (`C.t`), trails (`Trail.t`), substitutions, and ordered clause sets, supporting operations like redundancy checks, eligibility analysis for resolution/paramodulation, proof extraction, and term rewriting. Key use cases include optimizing inference rule application, maintaining logical consistency during proof search, and enabling efficient clause manipulation in theorem proving pipelines.",
      "description_length": 530,
      "index": 232,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.MyHeap.Make",
      "library": "libzipperposition.calculi",
      "description": "Implements a mutable heap structure using a vector, providing operations for inserting elements, removing the minimum element, and maintaining heap properties through percolation. It supports indexed access to elements and allows dynamic adjustments like decreasing or increasing element values. This heap is suitable for priority queue implementations where efficient access to the smallest element is required.",
      "description_length": 412,
      "index": 233,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Bce.Make",
      "library": "libzipperposition.calculi",
      "description": "This module implements a fixpoint computation engine for a custom equality type provided by the `E` module. It supports setup, iteration, and teardown of fixpoint calculations, with control over fixed-point mode. It is used to compute closure under inference rules in theorem proving contexts, particularly for equality reasoning.",
      "description_length": 330,
      "index": 234,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Rewriting.Make",
      "library": "libzipperposition.calculi",
      "description": "Implements rewriting and narrowing operations for equational logic, using a parameterized module E that provides term representations and equality checks. Exposes a setup function to configure rewriting strategies with options like context-sensitive narrowing and enabling/disabling rewriting. Useful for building theorem provers or symbolic computation tools where term rewriting is central.",
      "description_length": 392,
      "index": 235,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Higher_order.Make",
      "library": "libzipperposition.calculi",
      "description": "This module manages clause metadata, including boolean flags, redundancy, and simplification markers, and supports clause construction with trails, proofs, and transformations like substitution and eta-reduction. It works with clauses, literals, terms, and hash-based data structures for efficient access and manipulation. It is used in higher-order theorem proving for resolution, paramodulation, and proof extraction, enabling precise clause analysis and automated reasoning tasks.",
      "description_length": 483,
      "index": 236,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Bce_pe_fixpoint.Make",
      "library": "libzipperposition.calculi",
      "description": "Implements a fixpoint computation engine for clause elimination and predicate elimination (BCE/PE) transformations. It operates on clause sets and propositional formulas, applying simplification rules until a stable state is reached. Useful in automated theorem proving for reducing problem size by removing redundant clauses and predicates.",
      "description_length": 341,
      "index": 237,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Pure_literal_elim.IDMap",
      "library": "libzipperposition.calculi",
      "description": "This module implements a persistent associative map structure specialized for key-value associations where keys are unique identifiers (`id_sgn`) and values are polymorphic. It supports functional transformations like merging, filtering, and folding, along with set-like operations (union, partition) and sequence conversions, enabling efficient traversal and manipulation of identifier-indexed data. The design facilitates use cases in logical simplification processes, such as tracking or eliminating literals by their identifiers while preserving immutability during iterative reasoning steps.",
      "description_length": 596,
      "index": 238,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Booleans.Make",
      "library": "libzipperposition.calculi",
      "description": "This module implements boolean clause operations for automated theorem proving, including clause transformation with trails and proofs, substitution and bitvector manipulation, and literal selection for resolution. It works with clauses, substitutions, literals, and term positions to support inference rule application. Used for redundancy elimination, eligibility tracking, and axiom verification in proof search.",
      "description_length": 415,
      "index": 239,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Lazy_cnf.Make",
      "library": "libzipperposition.calculi",
      "description": "This module implements lazy CNF transformation for automated reasoning, providing clause normalization and simplification functions. It operates on clauses (`C.t`) and integrates with trail-based reasoning via `Trail.t`, supporting operations like literal selection, redundancy detection, and weight computation. It is used in theorem proving to manage clause form conversion during resolution and paramodulation steps.",
      "description_length": 419,
      "index": 240,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Pred_elim.Make",
      "library": "libzipperposition.calculi",
      "description": "This module implements a fixpoint-based predicate elimination algorithm using a parameterized equality module. It provides operations to initialize the elimination process, perform iterative fixpoint steps, and finalize the process, working with logical expressions and equality constraints. It is used to simplify or eliminate predicates during theorem proving by iteratively applying equality reasoning.",
      "description_length": 405,
      "index": 241,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Hlt_elim.Make",
      "library": "libzipperposition.calculi",
      "description": "This module implements the HLT (Hypothesis Learning and Transformation) elimination calculus for first-order logic, providing functions to manage clause learning, transformation, and elimination during saturation-based theorem proving. It works with clauses (`C.t`), substitutions, and trail-based reasoning to support operations like hypothesis generalization, redundancy elimination, and inference control in proof search. It is used to enhance reasoning efficiency by removing redundant clauses and guiding the prover toward minimal, useful clause sets during automated deduction.",
      "description_length": 583,
      "index": 242,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.EnumTypes.Make",
      "library": "libzipperposition.calculi",
      "description": "This module implements enumeration type handling for first-order logic reasoning, providing functions to declare enumerated types through case lists and instantiate variables over those domains. It operates on clauses, substitutions, and enumerated type definitions to enable logical reductions and proof search. Key use cases include restricting type domains for finite models and expanding variables into all possible values during clause processing.",
      "description_length": 452,
      "index": 243,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Heuristics.Make",
      "library": "libzipperposition.calculi",
      "description": "This module implements heuristic-driven clause processing for automated theorem proving, providing operations to prioritize clauses using term indexing, manage dynamic clause sets with change tracking, and guide inference rules like resolution and paramodulation. It works with clauses, substitutions, trails, and specialized hash tables to enable efficient proof search, clause simplification, and heuristic-based selection in provers. Concrete use cases include optimizing clause selection during proof search, applying heuristic reductions, and managing active and passive clause sets with priority-based scheduling.",
      "description_length": 619,
      "index": 244,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Ind_types.Make",
      "library": "libzipperposition.calculi",
      "description": "This module implements inference rule setups for a theorem proving calculus, specifically handling term and clause manipulation. It works with term and clause data structures, applying reduction and simplification rules. Concrete use cases include initializing and configuring inference systems for automated reasoning tasks.",
      "description_length": 325,
      "index": 245,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Qle.Make",
      "library": "libzipperposition.calculi",
      "description": "Implements a selection function for the QLE (Quick Lifting of Equality) calculus used in superposition theorem proving. It works with equality literals and clauses, prioritizing those that can lead to efficient unification or simplification. This module is used during proof search to guide the selection of inference steps involving equality reasoning.",
      "description_length": 353,
      "index": 246,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Fool.Make",
      "library": "libzipperposition.calculi",
      "description": "This module implements boolean literal rewriting and clause manipulation routines tailored for automated theorem proving. It operates on clauses, substitutions, and trails to support inference rule eligibility, proof search optimization, and redundancy elimination. Concrete use cases include simplifying logical expressions during superposition-based reasoning and managing boolean constraints in formal verification tasks.",
      "description_length": 424,
      "index": 247,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Superposition_intf",
      "library": "libzipperposition.calculi",
      "description": "This module defines the core components of a superposition calculus, including term ordering, unification, and clause simplification functions. It operates on terms, literals, and clauses, providing the logical machinery for automated reasoning tasks. Concrete use cases include implementing and testing superposition-based theorem proving strategies.",
      "description_length": 351,
      "index": 248,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Higher_order",
      "library": "libzipperposition.calculi",
      "description": "This module implements higher-order reasoning operations for theorem proving, including term enumeration, clause metadata management, and pruning strategies to control redundancy. It works with terms, clauses, literals, and hash-based sets, supporting operations like substitution, eta-reduction, and proof construction. It is used to enable higher-order resolution, paramodulation, and precise clause analysis in automated reasoning systems.",
      "description_length": 442,
      "index": 249,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Pred_elim",
      "library": "libzipperposition.calculi",
      "description": "This module implements a fixpoint-based predicate elimination algorithm using a parameterized equality module. It provides operations to initialize the elimination process, perform iterative fixpoint steps, and finalize the process, working with logical expressions and equality constraints. It is used to simplify or eliminate predicates during theorem proving by iteratively applying equality reasoning.",
      "description_length": 405,
      "index": 250,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.MyHeap",
      "library": "libzipperposition.calculi",
      "description": "Implements a mutable heap structure using a vector with operations to insert elements, remove the minimum, and adjust element values efficiently. Supports indexed access and dynamic updates such as decreasing or increasing element priorities. Useful for priority queues and algorithms requiring fast access to the smallest element, like Dijkstra's or Prim's.",
      "description_length": 358,
      "index": 251,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Bool_encode",
      "library": "libzipperposition.calculi",
      "description": "This module facilitates the embedding and manipulation of Boolean logic within a formal proof system, focusing on operations like encoding logical connectives (conjunction, disjunction, negation, equality) and quantifiers into typed terms and CNF clauses. It works with structured types and terms from the `T` module, alongside `Logtk`-based declarations and literals, to support automated reasoning in first-order and higher-order logic frameworks. Specific applications include constructing resolution proofs, formal verification tasks, and axiomatizing Boolean expressions for automated theorem proving.",
      "description_length": 606,
      "index": 252,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Pure_literal_elim",
      "library": "libzipperposition.calculi",
      "description": "This module implements pure literal elimination for logical simplification, providing operations to identify and remove clauses containing pure literals. It processes sequences of logical statements, tracking symbol occurrences using identifier maps and sets, and enables iterative refinement of logical formulae by eliminating redundant clauses. Key functions include computing occurrence maps, extracting pure symbols, and filtering clauses, specifically supporting automated reasoning tasks in formal verification and theorem proving.",
      "description_length": 537,
      "index": 253,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Hlt_elim",
      "library": "libzipperposition.calculi",
      "description": "This module enables clause learning, transformation, and redundancy elimination during saturation-based theorem proving, operating on first-order logic clauses (`C.t`), substitutions, and trail-based reasoning structures. It provides configurable parameters to control clause tracking, simplification rules, and proof search efficiency, with a focus on integrating HLT-elimination into larger automated reasoning systems. Designed for applications in formal verification and automated deduction, it optimizes proof search by managing clause complexity and logical dependencies through specialized saturation algorithms.",
      "description_length": 619,
      "index": 254,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Superposition",
      "library": "libzipperposition.calculi",
      "description": "Implements inference and simplification rules for the superposition calculus, including unification algorithms and higher-order basic rules. Operates on terms and scoped terms from the Logtk library, managing substitutions and flexible state configurations. Useful for automated theorem proving tasks involving equational reasoning and clause normalization.",
      "description_length": 357,
      "index": 255,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Bce_pe_fixpoint",
      "library": "libzipperposition.calculi",
      "description": "Implements a fixpoint computation engine for Blocked Clause Elimination (BCE) and Predicate Elimination (PE) transformations. It operates on clause sets and propositional formulas, iteratively applying simplification rules until no further reductions are possible. Useful in automated theorem proving to reduce problem size by removing redundant clauses and predicates.",
      "description_length": 369,
      "index": 256,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Qle",
      "library": "libzipperposition.calculi",
      "description": "Implements a selection function for the QLE calculus in superposition theorem proving, focusing on equality literals and clauses. It prioritizes literals that enable efficient unification or simplification during proof search. Used to guide inference step selection in equality-based reasoning.",
      "description_length": 294,
      "index": 257,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Heuristics",
      "library": "libzipperposition.calculi",
      "description": "This module implements heuristic-driven clause processing for automated theorem proving. It provides operations to prioritize clauses using term indexing, manage dynamic clause sets with change tracking, and guide inference rules like resolution and paramodulation. It works with clauses, substitutions, trails, and specialized hash tables to enable efficient proof search, clause simplification, and heuristic-based selection in provers. Use cases include optimizing clause selection during proof search, applying heuristic reductions, and managing active and passive clause sets with priority-based scheduling.",
      "description_length": 612,
      "index": 258,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Booleans",
      "library": "libzipperposition.calculi",
      "description": "This module implements boolean clause transformations and reasoning techniques for automated theorem proving, including quantifier renaming, boolean simplifications, and clause preprocessing. It operates on typed statements, clauses, substitutions, and literals to support proof search optimizations like redundancy elimination and eligibility tracking. Concrete use cases include boolean term normalization, case analysis, and bitvector-based literal selection during resolution.",
      "description_length": 480,
      "index": 259,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Rewriting",
      "library": "libzipperposition.calculi",
      "description": "Implements term rewriting and narrowing for equational logic using a parameterized term representation. Provides functions like `unfold_def_before_cnf` to expand definitions prior to clausal normalization, and integrates configuration options for strategies such as context-sensitive narrowing. Designed for use in theorem provers and symbolic systems requiring precise term manipulation.",
      "description_length": 388,
      "index": 260,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Fool",
      "library": "libzipperposition.calculi",
      "description": "This module implements boolean literal rewriting and clause manipulation routines tailored for automated theorem proving. It operates on clauses, substitutions, and trails to support inference rule eligibility, proof search optimization, and redundancy elimination. Concrete use cases include simplifying logical expressions during superposition-based reasoning and managing boolean constraints in formal verification tasks.",
      "description_length": 424,
      "index": 261,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.App_encode",
      "library": "libzipperposition.calculi",
      "description": "This module provides applicative encoding functions for higher-order terms and logical statements, along with pretty-printing support for input/output operations. It works with terms, literals, clauses, and statements from the Logtk library, enabling theorem proving tasks that involve type-based resolution and extensionality axiom generation.",
      "description_length": 344,
      "index": 262,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Eq_encode",
      "library": "libzipperposition.calculi",
      "description": "This module enables equality reasoning by providing operations to declare equality symbols, encode literals and clauses, and manage type declarations within logical statements. It operates on logical terms and clauses, facilitating automated theorem proving and formal verification tasks. Its integration into the Libzipperposition framework enhances equality handling through dedicated extension mechanisms for proof systems.",
      "description_length": 426,
      "index": 263,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Lazy_cnf",
      "library": "libzipperposition.calculi",
      "description": "This module implements a lazy CNF (Conjunctive Normal Form) transformation for automated reasoning, providing clause normalization and simplification functions. It operates on clauses (`C.t`) and integrates with trail-based reasoning via `Trail.t`, supporting operations like literal selection, redundancy detection, and weight computation. It is used in theorem proving to manage clause form conversion during resolution and paramodulation steps.",
      "description_length": 447,
      "index": 264,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.EnumTypes",
      "library": "libzipperposition.calculi",
      "description": "This module implements enumeration type handling for first-order logic reasoning, providing functions to declare enumerated types through case lists and instantiate variables over those domains. It operates on clauses, substitutions, and enumerated type definitions to enable logical reductions and proof search. Key use cases include restricting type domains for finite models and expanding variables into all possible values during clause processing.",
      "description_length": 452,
      "index": 265,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Bce",
      "library": "libzipperposition.calculi",
      "description": "This module implements a fixpoint computation engine for a custom equality type, supporting setup, iteration, and teardown of fixpoint calculations. It works with equality reasoning in theorem proving contexts, specifically enabling closure computation under inference rules. Concrete use cases include automating equality-based reasoning steps in theorem provers.",
      "description_length": 364,
      "index": 266,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Ind_types",
      "library": "libzipperposition.calculi",
      "description": "Implements inference rule configurations for theorem proving, focusing on term and clause manipulation. It operates on term and clause data structures, applying reduction and simplification rules. Used to set up and manage inference systems for automated reasoning tasks.",
      "description_length": 271,
      "index": 267,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi",
      "library": "libzipperposition.calculi",
      "description": "This module implements core components for automated theorem proving, focusing on higher-order reasoning, equality handling, clause transformation, and heuristic-driven proof search. It provides operations for term encoding, boolean logic manipulation, predicate and clause elimination, fixpoint computations, and superposition-based inference rules. Designed for use in formal verification and automated deduction systems, it directly supports tasks like resolution proof construction, logical simplification, and saturation-based reasoning over typed terms and clauses.",
      "description_length": 571,
      "index": 268,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 278,
    "meaningful_modules": 269,
    "filtered_empty_modules": 9,
    "retention_rate": 0.9676258992805755
  },
  "statistics": {
    "max_description_length": 708,
    "min_description_length": 202,
    "avg_description_length": 434.90706319702605,
    "embedding_file_size_mb": 3.8991336822509766
  }
}