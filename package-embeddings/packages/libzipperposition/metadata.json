{
  "package": "libzipperposition",
  "embedding_model": "Qwen/Qwen3-Embedding-0.6B",
  "embedding_dimension": 1024,
  "total_modules": 1162,
  "creation_timestamp": "2025-07-16T01:19:22.246822",
  "modules": [
    {
      "module_path": "Libzipperposition_phases.Phases.Key",
      "library": "libzipperposition.phases",
      "description": "This module provides a state key to track the current phase during proof search. It works with phase identifiers and state management structures. A concrete use case is storing and retrieving the active phase in a theorem prover's execution context.",
      "description_length": 249,
      "index": 0,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_phases.Phases.Infix",
      "library": "libzipperposition.phases",
      "description": "This module defines infix operators for composing and transforming phased computations. It provides monadic bind (`>>=`) and error-aware bind (`>>?=`) operations, along with a map operator (`>|=`), enabling chaining of phase-based actions that carry state and error information. These operators are used to sequence proof search phases in automated theorem proving, where each phase may produce intermediate results or fail.",
      "description_length": 424,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_phases.Phases_impl",
      "library": "libzipperposition.phases",
      "description": "This module implements a sequence of phases for processing logic files, including parsing command-line arguments, loading extensions, processing files through type inference and clause saturation, printing results, and checking proofs. It operates on file lists, environment states, and logic parameters, producing SZS status outputs and error codes. Concrete use cases include running a command-line prover, processing multiple logic files in sequence, and embedding the prover in a library.",
      "description_length": 492,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_phases.Phases",
      "library": "libzipperposition.phases",
      "description": "This module orchestrates stateful computations in a theorem-proving pipeline using monadic operations that enforce typed transitions between phases. It manages structured data such as phase descriptors, environments, clauses, and results, while threading a `Flex_state.t` to enable keyed state transformations across phase boundaries. The core API supports pure and effectful operations over hierarchical proof states, with infix operators for sequencing phased computations (`>>=`, `>>?=`, `>|=`) and a state key for tracking the active phase during execution. Example usage includes composing proof search stages that pass typed intermediate results and errors through a shared state context.",
      "description_length": 694,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_phases",
      "library": "libzipperposition.phases",
      "description": "This module coordinates the end-to-end execution of theorem proving tasks, combining file processing, stateful phase transitions, and proof search into a unified pipeline. It defines core data types such as proof states, logic clauses, and solver configurations, with operations for parsing input formats, applying type inference, saturating clause sets, and validating proofs. The API supports both standalone execution via command-line interfaces and programmatic composition of phases using monadic combinators that enforce correct state transitions. Example workflows include running automated reasoning jobs on TPTP benchmarks, integrating custom solving heuristics into the saturation loop, and extracting structured proof output in SZS format.",
      "description_length": 750,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Env.Make.ProofState.CQueue.PriorityFun",
      "library": "libzipperposition",
      "description": "Implements priority functions for clause queues based on clause properties. It assigns integer weights to clauses using customizable parsing logic from strings. This module is used to dynamically select and prioritize clauses during proof search based on user-defined strategies.",
      "description_length": 279,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Env.Make.ProofState.SubsumptionIndex.C",
      "library": "libzipperposition",
      "description": "This module defines operations for comparing clauses, iterating over their literals, and accessing label subsets used in subsumption checks. It works with clause data structures that contain literals and associated integer labels. Concrete use cases include managing clause indices for efficient subsumption testing in automated theorem proving.",
      "description_length": 345,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Env.Make.ProofState.TermIndex.Leaf",
      "library": "libzipperposition",
      "description": "This module implements a term index structure that supports efficient insertion, removal, and querying of logical terms paired with associated elements. It provides operations for exact matching, unification, and substitution-based pattern matching between indexed terms and query terms. Typical use cases include managing sets of logical expressions during automated theorem proving and performing efficient term retrieval based on structural equality or unifiability.",
      "description_length": 469,
      "index": 7,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.Env.Make.ProofState.CQueue.C",
      "library": "libzipperposition",
      "description": "This module manages clause properties and transformations in automated reasoning, offering operations to track redundancy, goal status, and inference eligibility, manipulate trails and proofs for boolean assignments, and compute term properties like bitvectors and penalties. It operates on clauses within priority queues, supporting use cases such as resolution, paramodulation, proof construction, and output formatting in theorem proving workflows.",
      "description_length": 451,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Env.Make.ProofState.CQueue.WeightFun",
      "library": "libzipperposition",
      "description": "This module defines weight functions that assign integer weights to clauses for prioritizing them in a proof state's priority queue. It supports operations like parsing weight function descriptions, combining weighted functions, and applying heuristic-based weighting strategies such as favoring ground or Horn clauses. Specific use cases include guiding clause selection during automated theorem proving by adjusting priorities based on clause structure, goal proximity, or penalty metrics.",
      "description_length": 491,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Env.Make.FormRename.Ctx.Lit",
      "library": "libzipperposition",
      "description": "This module provides functions to convert between literals and formulas, specifically handling atomic formulas. It maintains lists of hooks for customizing conversions, with `from_hooks` and `to_hooks` retrieving the current hook lists, and `add_from_hook` and `add_to_hook` extending them. The `of_form` and `to_form` functions perform direct conversions between `SLiteral.t` and `Literal.t` types, ensuring correct atomic representation or raising errors otherwise.",
      "description_length": 467,
      "index": 10,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Env.Make.Stm.Ctx.Lit",
      "library": "libzipperposition",
      "description": "This module manages bidirectional conversions between literals and formulas using customizable hooks. It provides functions to register and retrieve conversion hooks, as well as to perform the actual conversions. It works with `Logtk.Literal.t` and `Logtk.SLiteral.t` types, enabling integration of custom logic during conversion processes.",
      "description_length": 340,
      "index": 11,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.Env.Make.ProofState.UnitIndex.E",
      "library": "libzipperposition",
      "description": "This module represents and compares indexed equations with their associated terms, signs, and clauses. It provides operations to extract components of equations, compare them for ordering, and assess their utility through a priority function. It is used to manage and retrieve equations efficiently in theorem proving contexts.",
      "description_length": 327,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Env.Make.C.WithPos",
      "library": "libzipperposition",
      "description": "This module represents clauses with a specific subterm and its position, enabling precise manipulation and analysis of terms within clauses. It provides comparison and pretty-printing operations for values containing clauses, terms, and their logical positions. Useful for tasks like term indexing, proof tracing, or focused rewriting where subterm locations matter.",
      "description_length": 366,
      "index": 13,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Combinators.Make.C.WithPos",
      "library": "libzipperposition",
      "description": "This module represents clauses with a specific subterm and its position, enabling precise manipulation and tracking of terms within clauses. It provides comparison and pretty-printing operations for these structured clauses. Useful for tasks like term indexing, rewriting, or focused proof search where subterm positions matter.",
      "description_length": 328,
      "index": 14,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Env.Make.C.ClauseSet",
      "library": "libzipperposition",
      "description": "This module supports operations for managing ordered collections of clauses through standard set manipulations, including membership checks, union/intersection/difference calculations, and predicate-based filtering or partitioning. It works with sets of clauses (`C.t`) while enabling conversions to lists, sequences, and formatted string representations, emphasizing ordered traversal and safe element access. These capabilities are particularly useful in theorem proving scenarios requiring structured clause processing, such as resolution steps or proof search strategies that rely on ordered traversal and dynamic set transformations.",
      "description_length": 638,
      "index": 15,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Env.Make.Stm.Ctx",
      "library": "libzipperposition",
      "description": "This module manages logical contexts for theorem proving, handling term orderings, selection functions, and symbol type declarations while supporting operations like term comparison, skolemization, and tracking signature changes. It works with literals and terms, including checks for argument-specific injectivity to guide simplification and inference, and integrates with the `Lit` module for literal manipulation. A child module enables bidirectional conversions between literals and formulas using customizable hooks, supporting types like `Logtk.Literal.t` and `Logtk.SLiteral.t` for flexible integration of custom logic during proof search. These capabilities allow users to define, transform, and reason over logical expressions within a consistent context.",
      "description_length": 764,
      "index": 16,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Env.Make.ProofState.CLAUSE_SET",
      "library": "libzipperposition",
      "description": "This module manages a set of clauses with operations to add or remove clauses and to register callbacks for when clauses are added or removed. It works with clause sets and uses signals to notify of changes. Concrete use cases include tracking clause modifications during theorem proving or maintaining derived constraints in a logic solver.",
      "description_length": 341,
      "index": 17,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Env.Make.ProofState.CQueue",
      "library": "libzipperposition",
      "description": "This module organizes clauses into priority queues using customizable strategies such as FIFO, goal-oriented, or heuristic-based ordering, enabling dynamic prioritization through weight functions. It supports core operations like insertion, priority-based retrieval, membership checks, and removal, while integrating with submodules that define weight functions, manage clause properties, and apply transformations during proof search. For example, weight functions can be parsed from strings, combined, or applied to favor specific clause types like Horn or ground clauses, while clause properties track redundancy, goal status, and inference eligibility. These capabilities facilitate resolution, paramodulation, proof construction, and efficient clause selection in automated reasoning systems.",
      "description_length": 797,
      "index": 18,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.ProofState.Make.TermIndex.Leaf",
      "library": "libzipperposition",
      "description": "This module implements a term index structure for efficient storage and retrieval of terms with associated values, supporting operations like adding, removing, and updating indexed terms. It works with terms from the Logtk library and custom elements, enabling precise unification and matching queries with substitutions. It is used in automated theorem proving to quickly find relevant clauses or terms during proof search.",
      "description_length": 424,
      "index": 19,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.ProofState.Make.SubsumptionIndex.C",
      "library": "libzipperposition",
      "description": "This module defines operations for comparing and analyzing clauses in a subsumption index. It provides direct access to clause literals and labels, enabling efficient subsumption checks and ordering. Useful in automated theorem proving for managing clause hierarchies and redundancy.",
      "description_length": 283,
      "index": 20,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Env.Make.ProofState.PassiveSet",
      "library": "libzipperposition",
      "description": "This module manages a collection of passive clauses with operations to add, remove, and retrieve clauses based on their passive status. It provides signals for tracking clause additions and removals, a clause queue for processing, and direct access to the current clause set. Concrete use cases include controlling clause processing order in theorem proving and monitoring clause state changes during proof search.",
      "description_length": 414,
      "index": 21,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.ProofState.Make.CQueue.PriorityFun",
      "library": "libzipperposition",
      "description": "Implements priority functions for clause selection in proof search. It assigns integer weights to clauses based on configurable string descriptions, influencing the order of processing in automated theorem proving. Useful for guiding search strategies by prioritizing clauses according to heuristic rules encoded in the weight functions.",
      "description_length": 337,
      "index": 22,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.AC.Make.C.Tbl",
      "library": "libzipperposition",
      "description": "This module provides imperative hash table operations for key-value pairs where keys are of type `C.t` and values can be arbitrary. It supports efficient insertion, removal, and safe retrieval of values, in-place updates with customizable merging strategies for duplicate keys, and conversions between tables and sequences or iterators. Typical use cases include element frequency counting, building tables from iterable collections, and custom serialization through user-defined combination functions during updates.",
      "description_length": 517,
      "index": 23,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.Env.Make.ProofState.UnitIndex",
      "library": "libzipperposition",
      "description": "This module organizes a hierarchy of components for managing logical (in)equations within a proof state, centered around an efficient indexing structure. At its core, it supports adding, removing, and querying indexed terms to facilitate fast substitution and generalization lookups during theorem proving. The main data types include terms, equations, and clauses, with operations for comparison, extraction, and prioritization. For example, it enables retrieving high-priority equations matching a given term or identifying unifying substitutions across indexed entries.",
      "description_length": 572,
      "index": 24,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.Env.Make.FormRename.Ctx",
      "library": "libzipperposition",
      "description": "This module manages logical contexts with operations for term ordering, signature manipulation, skolemization, and term rewriting, including injectivity checks. It supports key data types like contexts, signatures, terms, and literals, enabling tasks such as symbol declaration, type resolution, and equivalence reasoning. Its child module facilitates conversion between literals and formulas via customizable hooks, using functions like `of_form` and `to_form` to handle atomic representations safely. Together, they support theorem proving workflows involving constraint solving, logic manipulation, and signature updates.",
      "description_length": 624,
      "index": 25,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.AC.Make.C.Eligible",
      "library": "libzipperposition",
      "description": "This module defines eligibility criteria for selecting literals in a clause based on specific logical properties. It provides functions to filter literals by type (positive, negative, equations), role (resolution, paramodulation), and logical combinations of these conditions. Use cases include guiding inference rules in automated theorem proving by restricting which literals can be used in resolution or paramodulation steps.",
      "description_length": 428,
      "index": 26,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.AC.Make.C.Pos",
      "library": "libzipperposition",
      "description": "This module provides a function `at` that retrieves a subterm from a given term at a specified position. It operates on terms represented by the `C.t` type and uses positions defined by `Logtk.Position.t`. A concrete use case is extracting specific subterms during proof search or term analysis.",
      "description_length": 295,
      "index": 27,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.ProofState.Make.CQueue.WeightFun",
      "library": "libzipperposition",
      "description": "This module defines weight functions for prioritizing clauses in a proof search context. It provides operations to create and combine weight functions that influence clause selection based on properties like goal proximity, clause structure, and penalties. Use cases include guiding automated theorem proving by assigning priorities to clauses in a queue for efficient processing.",
      "description_length": 380,
      "index": 28,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Combinators.Make.C.Tbl",
      "library": "libzipperposition",
      "description": "This module supports standard imperative hash table operations with keys of type `C.t` and polymorphic values, offering safe access, bulk updates, and in-place transformations. It provides utilities for counting elements, converting between hashtables and lists/sequences, and resolving conflicts during construction, while enabling custom iteration, folding, and statistical tracking. Typical use cases include aggregating data from streams, maintaining counters, and managing key-value associations with dynamic updates and conditional modifications.",
      "description_length": 552,
      "index": 29,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Env.Make.ProofState.TermIndex",
      "library": "libzipperposition",
      "description": "This module organizes logical terms and their positional data in a graph-like index structure, enabling efficient insertion, removal, and querying of terms with associated elements. It supports operations such as exact matching, unification, and substitution-based pattern matching, allowing retrieval of unifiables, generalizations, and specializations. The index facilitates automated reasoning tasks like theorem proving by managing term sets and enabling structural equality checks and pattern-based queries. A built-in visualization tool generates DOT representations for analysis and debugging of the index structure.",
      "description_length": 623,
      "index": 30,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.AC.Make.C.WithPos",
      "library": "libzipperposition",
      "description": "This module represents clauses with a specific subterm and its position, enabling precise term manipulation and analysis. It provides comparison and pretty-printing operations for these structured clauses. Useful for tasks like term rewriting, proof tracing, or focused clause transformations where positional context is critical.",
      "description_length": 330,
      "index": 31,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.Env.Make.ProofState.SubsumptionIndex",
      "library": "libzipperposition",
      "description": "This module organizes clauses into a structured hierarchy, enabling efficient management and retrieval based on subsumption and alpha-equivalence. It supports key operations like adding and removing clauses, as well as querying by literals and labels to identify subsumed or redundant clauses during proof search. The child module enhances these capabilities by providing utilities to compare clauses, iterate over their literals, and access label subsets for precise subsumption checks. Together, they facilitate advanced indexing strategies, such as maintaining clause databases with fast lookup and redundancy elimination in automated reasoning systems.",
      "description_length": 656,
      "index": 32,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Env.Make.C.Pos",
      "library": "libzipperposition",
      "description": "Accesses a subterm at a specified position within a clause. Works with clauses and terms, using positions to navigate term structure. Useful for precise term manipulation during proof search or term rewriting.",
      "description_length": 209,
      "index": 33,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.AC.Make.C.Seq",
      "library": "libzipperposition",
      "description": "This module provides functions to iterate over literals, terms, and variables contained in a clause. It works with clause (`C.t`), literal (`Logtk.Literal.t`), term (`Logtk.Term.t`), and typed variable (`Logtk.Type.t Logtk.HVar.t`) data structures. Concrete use cases include analyzing clause components for simplification, substitution, or proof search in automated theorem proving.",
      "description_length": 383,
      "index": 34,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Env.Make.ProofState.SimplSet",
      "library": "libzipperposition",
      "description": "This module manages a dynamic set of clauses with support for adding and removing clauses using iterators. It provides signals that are triggered on clause insertion and removal, enabling reactive updates. It is used in proof state management to track and respond to changes in clause sets during automated reasoning tasks.",
      "description_length": 323,
      "index": 35,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.Lift_lambdas.Make.C.Pos",
      "library": "libzipperposition",
      "description": "This module provides a function `at` that retrieves a subterm at a specified position within a term. It operates on terms and positions, enabling precise navigation and manipulation of term structures. A concrete use case is extracting specific components from complex logical expressions during proof search or term rewriting.",
      "description_length": 327,
      "index": 36,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Lift_lambdas.Make.C.WithPos",
      "library": "libzipperposition",
      "description": "This module defines a structure for representing a clause with a specific subterm and its position within the clause. It provides operations to compare such structured clauses and to pretty-print them. This is useful when tracking specific subterms during proof search or term rewriting, where precise positional information is required for reasoning or debugging.",
      "description_length": 364,
      "index": 37,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Env.Make.C.Eligible",
      "library": "libzipperposition",
      "description": "This module defines predicates to select subsets of literals in clauses based on specific logical properties. It supports operations like filtering by positivity, negativity, equation status, and eligibility for resolution or paramodulation. These predicates can be combined using logical operators to express complex selection criteria for automated reasoning tasks.",
      "description_length": 367,
      "index": 38,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Env.Make.ProofState.ActiveSet",
      "library": "libzipperposition",
      "description": "This module manages a dynamic set of clauses with signals for additions and removals. It supports adding or removing clauses from an iterator, retrieving the current clause set, and querying the number of clauses. It is used to track and manipulate logical clauses during theorem proving processes.",
      "description_length": 298,
      "index": 39,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Lift_lambdas.Make.C.Tbl",
      "library": "libzipperposition",
      "description": "This module provides imperative hash table operations for key-value storage with keys of type `C.t` and arbitrary value types, emphasizing safe access, bulk updates from sequences/iterators, and customizable transformations. It supports in-place modifications, conflict resolution via combining functions, and conversions between hashtables, lists, and sequences, while offering utilities for counting elements and defining custom pretty-printing. Typical use cases include managing dynamic mappings with efficient lookups, aggregating data from iterative sources, and handling key-based computations requiring atomic updates or deterministic traversal.",
      "description_length": 653,
      "index": 40,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.Combinators.Make.C.Seq",
      "library": "libzipperposition",
      "description": "This module provides functions to extract literals, terms, and variables from a clause structure. It works with clause (`C.t`), literal, term, and variable data types. Use it to analyze or transform logical clauses by iterating over their components.",
      "description_length": 250,
      "index": 41,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.Combinators.Make.C.Pos",
      "library": "libzipperposition",
      "description": "Extracts a subterm at a specific position within a term. Works with terms and positions, enabling precise navigation and manipulation of term structures. Useful for tasks like term rewriting or analysis where access to specific subterms is required.",
      "description_length": 249,
      "index": 42,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.ProofState.Make.UnitIndex.E",
      "library": "libzipperposition",
      "description": "This module represents and manipulates indexed equations, consisting of pairs of terms along with a boolean flag indicating equality or inequality. It provides operations to extract components of equations, compare them for ordering, and assess their priority for use in proof search. These equations are used directly in theorem proving processes to manage logical inferences and simplifications.",
      "description_length": 397,
      "index": 43,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Lift_lambdas.Make.C.Seq",
      "library": "libzipperposition",
      "description": "Extracts literals, terms, and typed variables from a clause structure for analysis or transformation tasks. Works directly with clauses (`C.t`), producing iterators over literals, terms, and type-annotated variables. Useful in proof search and clause manipulation where inspecting or modifying clause components is required.",
      "description_length": 324,
      "index": 44,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Combinators.Make.C.ClauseSet",
      "library": "libzipperposition",
      "description": "This module implements ordered set operations for managing logical clause collections, including union, intersection, difference, membership testing, and element retrieval (min, max, choose). It operates on comparator-ordered clause sets (`C.ClauseSet.t`), supporting use cases like predicate-based filtering, ordered traversal, and conversions between sets, sequences, and lists for logical reasoning tasks. Safe and unsafe variants of operations enable precise control over partial functions, while string formatting aids debugging and analysis.",
      "description_length": 547,
      "index": 45,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Lift_lambdas.Make.C.Eligible",
      "library": "libzipperposition",
      "description": "This module defines predicates to select subsets of literals in clauses based on specific logical properties. It supports operations like filtering by positivity, negativity, equation status, and eligibility for inference rules such as resolution or paramodulation. These predicates can be combined using logical operators to build complex selection criteria for automated reasoning tasks.",
      "description_length": 389,
      "index": 46,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.Env.Make.C.Tbl",
      "library": "libzipperposition",
      "description": "This module enables efficient manipulation of polymorphic hash tables with fixed key types, supporting safe lookups, bulk updates from sequences/iterators, in-place value transformations, and customizable merging of duplicate keys. It works with hash tables (`C.Tbl.t`) mapping keys of type `C.Tbl.key` to arbitrary values, offering operations for iteration, filtering, counting, and converting between tables and lists. It is particularly useful for scenarios requiring functional-style key-value management, such as aggregating statistics, maintaining dynamic mappings with precise control over collisions, or transforming structured data with sequence-based workflows.",
      "description_length": 671,
      "index": 47,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.ProofState.Make.CQueue.C",
      "library": "libzipperposition",
      "description": "This module offers operations to manage clause properties (e.g., redundancy, goal status), manipulate literals and substitutions, and transform clauses via normalization or proof adjustments. It works with clause data structures (`CQueue.C.t`), trails, proofs, substitutions (`Subst.t`), and scoped terms (`Logtk.Scoped.t`), using bitvectors and sets for efficient property tracking. These capabilities support theorem proving tasks such as redundancy elimination, literal eligibility checks for inference rules, and generating TSTP-compliant output for debugging.",
      "description_length": 564,
      "index": 48,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Env.Make.C.Seq",
      "library": "libzipperposition",
      "description": "This module provides functions to extract literals, terms, and variables from a clause structure. It works with clause (`C.t`), literal, term, and typed variable data types. Use it to analyze or transform logical clauses by iterating over their constituent elements in a zipperposition-based theorem proving context.",
      "description_length": 316,
      "index": 49,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Env.Make.StmQ.WeightFun",
      "library": "libzipperposition",
      "description": "This module defines weight functions for assigning integer weights to streams of statements. It includes operations to retrieve a stream's penalty and to combine multiple weighted functions into a single function. These functions are used to prioritize or evaluate streams based on customizable weighted criteria.",
      "description_length": 313,
      "index": 50,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.AC.Make.C.ClauseSet",
      "library": "libzipperposition",
      "description": "This module offers a rich set of ordered set operations for managing collections of clauses, including membership checks, element insertion/removal, set algebra (union, intersection, difference), and ordered traversal. It works with sets of clauses (`C.ClauseSet.t`) and supports transformations via mapping, filtering, and folding, along with conversions to lists, sequences, and string representations. It is particularly useful in formal verification or theorem proving contexts where maintaining element ordering and performing predicate-driven queries or safe modifications are critical.",
      "description_length": 592,
      "index": 51,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.Combinators.Make.C.Eligible",
      "library": "libzipperposition",
      "description": "This module defines eligibility criteria for selecting literals in a clause based on logical operations and properties such as positivity, negativity, maximality, and equation status. It provides functions to filter literals for resolution, paramodulation, or custom conditions, combining criteria using logical operators. Use cases include guiding inference rules in automated theorem proving by restricting which literals can participate in resolution or paramodulation steps.",
      "description_length": 478,
      "index": 52,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Lift_lambdas.Make.C.ClauseSet",
      "library": "libzipperposition",
      "description": "This module implements a functional set structure for ordered clauses, supporting operations like union, intersection, difference, and comparison, along with element retrieval (min, max) and ordered iteration. It works with immutable sets of clauses (`C.ClauseSet.t`) using a total ordering for organization, and includes utilities for filtering, converting to/from lists/sequences, and serializing to strings. It is particularly useful in theorem proving or logic programming contexts where ordered clause sets require efficient manipulation, predicate-based searches, or human-readable output.",
      "description_length": 595,
      "index": 53,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.ClauseQueue.Make.PriorityFun",
      "library": "libzipperposition",
      "description": "Implements priority functions for clause selection in theorem proving, where each function maps a clause to an integer priority. Parses string descriptions into concrete priority schemes, enabling dynamic configuration of clause ordering strategies during proof search. Useful for controlling the saturation process in automated reasoning tools.",
      "description_length": 345,
      "index": 54,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Bool_lit.Make.Set",
      "library": "libzipperposition",
      "description": "This module implements ordered set operations for element uniqueness, including union, intersection, difference, and functional transformations like filtering and mapping, alongside conversion utilities for sequences and lists. It works with comparator-parameterized ordered sets, enabling efficient queries (min/max, predicate-based searches) and bidirectional traversal, suitable for managing ordered finite collections, combinator-based processing, and string representation generation.",
      "description_length": 489,
      "index": 55,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.Bool_lit.Make.Tbl",
      "library": "libzipperposition",
      "description": "This module implements hash table operations for a custom key type, enabling polymorphic value storage and manipulation through insertion, lookup, iteration, and folding. It supports conversions between tables, sequences, and iterators, with specialized functions for counting elements, merging duplicates, and transforming values in contexts like statistical aggregation or data processing pipelines. The design emphasizes safe access patterns and idiomatic transformations for structured key-value workflows.",
      "description_length": 510,
      "index": 56,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.StreamQueue.Make.WeightFun",
      "library": "libzipperposition",
      "description": "This module implements weight functions for stream prioritization, where each function maps a stream statement to an integer weight. It provides `penalty` to calculate the penalty of a stream and `combine` to create a composite weight function from a list of weighted functions. These are used to prioritize streams in a weighted queue based on configurable coefficients.",
      "description_length": 371,
      "index": 57,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Combinators.Make.C",
      "library": "libzipperposition",
      "description": "This module centers on the manipulation and analysis of logical clauses, offering core operations for setting boolean flags, checking equality, computing weights, and applying substitutions, all centered around the `C.t` and `ClauseSet.t` types. It integrates structured clause traversal via subterm positioning, efficient key-value storage with `C.t` keys, and component extraction for literals, terms, and variables, enabling precise term navigation and transformation. The module supports advanced theorem proving workflows through eligibility checks for inference rules, ordered set operations on clause collections, and format-preserving utilities for debugging and output. Example tasks include detecting redundant clauses, guiding resolution steps based on literal properties, and maintaining dynamic counters over clause sets with custom hash tables.",
      "description_length": 858,
      "index": 58,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.BBox.Lit.Set",
      "library": "libzipperposition",
      "description": "This module manages ordered collections of literals, supporting standard set operations like union, intersection, and difference alongside ordered traversal and element transformation. It includes utilities for predicate-based filtering, safe element access via optional returns, and conversions to and from sequences and lists, enabling workflows that require ordered processing of logical literals in symbolic reasoning tasks.",
      "description_length": 428,
      "index": 59,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.ClauseQueue.Make.WeightFun",
      "library": "libzipperposition",
      "description": "This module defines weight functions that assign integer weights to clauses based on specific heuristic criteria. It supports operations like combining multiple weight functions with coefficients, favoring certain clause properties such as being ground or negative, and computing weights based on proximity to the goal. Use cases include guiding clause selection in automated theorem proving by prioritizing clauses with lower weights according to customizable heuristics.",
      "description_length": 472,
      "index": 60,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.Env.Make.FormRename",
      "library": "libzipperposition",
      "description": "This module manages formula renaming during proof search, integrating skolemization and definition extraction with context-aware transformations. It introduces skolem symbols, detects renaming clauses, and adjusts formulas based on context and polarity, supporting both fresh symbol generation and symbol recycling. The integrated context module handles term ordering, signature manipulation, and rewriting, enabling operations like symbol declaration and equivalence reasoning. Together, they facilitate tasks such as clausification, constraint solving, and atomic formula conversion using functions like `of_form` and `to_form`.",
      "description_length": 630,
      "index": 61,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.Lift_lambdas.Make.C",
      "library": "libzipperposition",
      "description": "This module manages clause properties, transformations, and analysis in automated reasoning pipelines. It supports trail-based clause construction, redundancy checks, proof extraction, and logical operations such as substitution and eligibility analysis for inference rules, working with clauses (`C.t`), literals, substitutions, and terms. Submodules enable positional term access, structured clause comparison with subterm tracking, imperative hash tables keyed on clauses, extraction of clause components, predicate-based literal filtering, and ordered functional sets of clauses. Examples include navigating term structures with positional access, aggregating clause data using custom hash tables, selecting eligible literals for resolution or paramodulation, and maintaining ordered clause sets with deterministic traversal and set-theoretic operations.",
      "description_length": 858,
      "index": 62,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Env.Make.StmQ",
      "library": "libzipperposition",
      "description": "This module manages a priority queue for streams of clauses, using weighted priorities to schedule and retrieve elements fairly or within bounded attempts. It supports adding streams, inspecting queue state, and applying weight functions that combine penalties and custom criteria to influence prioritization. The child module provides tools to define and compose these weight functions, enabling dynamic evaluation and selection strategies. For example, it can prioritize clause streams in theorem proving based on source reliability or complexity metrics.",
      "description_length": 557,
      "index": 63,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.BBox.Lit.Tbl",
      "library": "libzipperposition",
      "description": "This module offers imperative hash table operations for keys of type `Libzipperposition.BBox.Lit.t`, supporting modifications (add, remove, replace), safe lookups (get, get_or), iteration (iter, fold, keys, values), and bulk updates from sequences or iterators with customizable merging strategies. It manages hashtables mapping these keys to arbitrary values, providing utilities for counting occurrences, converting between collections, and handling duplicates through user-defined combination functions. Typical applications include efficient data aggregation, controlled in-place updates with fallback computations, and transforming large datasets with complex merge logic.",
      "description_length": 677,
      "index": 64,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Clause.Make.Eligible",
      "library": "libzipperposition",
      "description": "This module defines predicates for selecting eligible literals in a clause based on specific logical properties. It supports operations like filtering by positivity, negativity, equation status, and maximality, and allows combining criteria using logical operators. Use cases include guiding resolution and paramodulation steps in automated theorem proving by restricting inferences to relevant literals.",
      "description_length": 404,
      "index": 65,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.Ctx.Make.Lit",
      "library": "libzipperposition",
      "description": "This module manages bidirectional conversions between literals and their formula representations using customizable hooks. It provides functions to register and retrieve conversion hooks, as well as to convert between literal and formula forms. It works directly with `Logtk.Literal.t` and `Logtk.SLiteral.t` types, supporting use cases like integrating custom term representations in theorem proving or symbolic reasoning pipelines.",
      "description_length": 433,
      "index": 66,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.ProofState.Make.ActiveSet",
      "library": "libzipperposition",
      "description": "This module maintains a dynamic set of clauses with signals for additions and removals. It supports adding or removing clauses from an iterator and provides access to the current clause set and its size. Useful for tracking clause changes in a proof search or simplification process.",
      "description_length": 283,
      "index": 67,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Env.Make.C",
      "library": "libzipperposition",
      "description": "This module organizes and manipulates logical clauses through precise subterm addressing, set-based clause management, and term traversal. It supports key operations like extracting literals and terms, filtering clauses by logical properties, and maintaining efficient hash tables keyed on clause elements. Submodules enable positional term access, predicate-based literal selection, and structured transformations over sets and hash tables. Examples include tracking subterm positions during rewriting, aggregating clause statistics via hash tables, and implementing resolution strategies through ordered set operations.",
      "description_length": 621,
      "index": 68,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.AC.Make.C",
      "library": "libzipperposition",
      "description": "This module provides core operations for manipulating clauses in theorem proving, integrating submodules that enhance its capabilities. It supports redundancy checks, literal inspection, proof tracking, and eligibility analysis for inference rules, working with clauses, trails, substitutions, and bitvectors to enable resolution, paramodulation, and clause transformation. Submodules allow efficient clause storage via hash tables, literal filtering based on logical properties, subterm access by position, structured clause representation with positional context, traversal of clause components, and ordered set operations on clause collections. Examples include debugging with TSTP formatting, backward simplification, goal detection, weight computation, and precise term rewriting guided by proof context.",
      "description_length": 809,
      "index": 69,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.ProofState.Make.SubsumptionIndex",
      "library": "libzipperposition",
      "description": "This module organizes clauses into a structured hierarchy based on subsumption and alpha-equivalence, enabling efficient insertion, deletion, and querying. It centers on clause and literal data types, with operations to retrieve subsuming or subsumed clauses, and analyze clause relationships. The child module enhances these capabilities by exposing literal-level comparisons and ordering, allowing precise subsumption checks and redundancy management. Together, they support advanced clause indexing and logical simplification in theorem proving tasks.",
      "description_length": 554,
      "index": 70,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Clause.Make.WithPos",
      "library": "libzipperposition",
      "description": "This module represents clauses with a specific subterm and its position, enabling precise manipulation and analysis of terms within clauses. It provides comparison and pretty-printing operations for these enriched clauses. Use cases include tracking term occurrences in proof search or analyzing subterm positions during clause processing.",
      "description_length": 339,
      "index": 71,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.ProofState.Make.TermIndex",
      "library": "libzipperposition",
      "description": "This module organizes terms with positional annotations into a hierarchical index optimized for proof state manipulations, supporting insertion, deletion, and unification-based queries to find generalizations or specializations under substitutions. It directly handles terms paired with `C.WithPos.t` values and includes submodules that implement efficient storage and retrieval mechanisms, enabling precise unification and matching queries over Logtk terms and custom elements. The structure allows traversal and transformation of term relationships, with additional tools for generating DOT graphs to visualize index contents during debugging. Examples include finding relevant clauses during proof search, updating indexed terms under substitutions, and visualizing term hierarchies to analyze proof strategies.",
      "description_length": 814,
      "index": 72,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.ProofState.Make.CLAUSE_SET",
      "library": "libzipperposition",
      "description": "This module manages a dynamic set of clauses, providing operations to add or remove clauses and trigger signals on these changes. It works with clause data structures and supports iterative collections of clauses for bulk updates. It is used to maintain and monitor evolving sets of logical clauses during theorem proving processes.",
      "description_length": 332,
      "index": 73,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Env.Make.ProofState",
      "library": "libzipperposition",
      "description": "The module maintains proof states during automated reasoning by organizing clauses into active, simplification, and passive sets, supporting insertion, retrieval, and simplification through term and subsumption indexes. It coordinates with submodules that manage clause sets with callbacks, prioritize clauses using customizable strategies, and handle passive clauses with tracking signals and processing queues. Additional components manage logical equations, term indexing, and subsumption-based clause hierarchies to enable efficient querying, unification, and redundancy elimination. Examples include applying heuristic-based prioritization to favor Horn clauses, using term indexes for fast substitution, and tracking derived constraints during proof search.",
      "description_length": 763,
      "index": 74,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.Env.Make.Stm",
      "library": "libzipperposition",
      "description": "This module manages streams of clauses with dynamic penalties and hit counters, enabling efficient retrieval and prioritization of elements based on runtime behavior. It integrates logical context handling from its child modules, supporting term orderings, skolemization, and symbol type declarations alongside customizable literal-to-formula conversions. Key data types include streams with weighted elements and logical terms like `Logtk.Literal.t`, manipulated through operations such as `drip` for extraction and term comparison. Users can track inference sources, prioritize clause processing, and transform logical expressions within a coherent framework for theorem proving.",
      "description_length": 681,
      "index": 75,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Clause.Make.Pos",
      "library": "libzipperposition",
      "description": "This module provides a function `at` that retrieves a term from a clause at a specified position using a positional index. It operates on clauses and positional data structures to access specific subterms. A concrete use case is extracting a literal or subterm from a clause during proof search or term rewriting.",
      "description_length": 313,
      "index": 76,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.ProofState.Make.SimplSet",
      "library": "libzipperposition",
      "description": "This module maintains a dynamic set of clauses with signals for tracking additions and removals. It provides operations to add or remove multiple clauses using iterators, enabling reactive updates in proof state management. It is used to efficiently handle clause set modifications during automated reasoning tasks.",
      "description_length": 315,
      "index": 77,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.ProofState.Make.PassiveSet",
      "library": "libzipperposition",
      "description": "This module manages a passive clause set with dynamic addition and removal, providing signals for tracking changes. It supports operations to query, add, remove, and process clauses, along with checking clause status and retrieving the current clause queue. It is used to maintain and iterate over passive clauses during theorem proving processes.",
      "description_length": 347,
      "index": 78,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Clause.Make.Tbl",
      "library": "libzipperposition",
      "description": "This module implements hash tables mapping keys (from `Clause.Make`) to arbitrary values, supporting operations like bulk updates from sequences with customizable conflict resolution, atomic value transformations, and lazy value insertion via `get_or_add`. It provides efficient iteration, in-place filtering, and conversion to/from lists/sequences, along with utilities for counting elements from iterators and merging duplicates. These features are particularly useful in symbolic reasoning systems, data aggregation pipelines, or state management scenarios requiring precise control over key-value interactions and high-performance bulk operations.",
      "description_length": 651,
      "index": 79,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.ProofState.Make.CQueue",
      "library": "libzipperposition",
      "description": "This module organizes logical clauses into a priority queue, enabling dynamic management through insertion, prioritization, and retrieval based on proof search strategies. It supports key data types like `CQueue.t` for queues and `CQueue.C.t` for clauses, with operations for membership checks, weight-based prioritization, and property manipulation. Submodules handle weight function configuration, clause property management, and transformations, allowing tasks like assigning heuristic priorities, marking redundancy, and normalizing clauses. Example usage includes guiding automated theorem proving by dynamically adjusting clause selection based on goal proximity or structural properties.",
      "description_length": 694,
      "index": 80,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.ProofState.Make.UnitIndex",
      "library": "libzipperposition",
      "description": "This module organizes a term index that efficiently retrieves equations and inequalities by term structure and substitution, supporting fast subsumption and matching checks critical for theorem proving. It manages indexed equations\u2014pairs of terms with equality or inequality flags\u2014offering operations to add, remove, query, and prioritize them based on proof search needs. The module enables term iteration, generalization extraction, and direct logical inference management through its API and submodules. For example, users can insert an equation like `x + 0 = x`, query for matching terms, or remove redundant equations during simplification steps.",
      "description_length": 651,
      "index": 81,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.Clause.Make.Seq",
      "library": "libzipperposition",
      "description": "This module provides functions to iterate over literals, terms, and variables within a clause structure. It works with clause data types, exposing their internal components as iterators. Useful for analyzing or transforming logical clauses by processing their constituent literals, terms, or typed variables.",
      "description_length": 308,
      "index": 82,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Lift_lambdas.S-Env-ProofState-CQueue-WeightFun",
      "library": "libzipperposition",
      "description": "This module defines weight functions that compute integer weights for clauses in a proof state priority queue. It supports operations like parsing weight function descriptions, combining multiple weight functions with coefficients, and applying heuristic-based weighting strategies. Use cases include prioritizing clauses during automated theorem proving based on properties like goal proximity, Horn structure, or groundness.",
      "description_length": 426,
      "index": 83,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.StreamQueue.ARG",
      "library": "libzipperposition",
      "description": "This module defines a stream-based queue structure with a single abstract type `Stm.t` representing a stream of elements. It provides operations to create and manipulate streams, including functions to enqueue elements, retrieve the current state, and process elements in sequence. A typical use case involves managing a prioritized stream of terms during theorem proving, where `state` accesses the current context for term processing.",
      "description_length": 436,
      "index": 84,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Combinators.S-Env-ProofState-ActiveSet",
      "library": "libzipperposition",
      "description": "This module manages a dynamic set of clauses with operations to add, remove, and retrieve clauses, along with signals for tracking changes. It works with clause sets represented as `C.ClauseSet.t` and streams of clauses via `C.t Iter.t`. Concrete use cases include maintaining an active set of clauses during theorem proving, where tracking additions and removals is essential for proof search control.",
      "description_length": 402,
      "index": 85,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.ClauseContext.Set",
      "library": "libzipperposition",
      "description": "This module offers a comprehensive suite of operations for ordered sets of `ClauseContext.t` values, emphasizing set-theoretic manipulations (union, intersection, difference), ordered traversal (iteration, folding, min/max extraction), and transformations (filtering, mapping, partitioning). It supports efficient membership queries, cardinality checks, and safe empty-set handling, alongside conversions to and from lists, sequences, and formatted string representations. Designed for scenarios requiring deterministic ordered processing, it is particularly suited for managing clause collections in automated reasoning systems where set relations, element selection under predicates, and structured output are critical.",
      "description_length": 721,
      "index": 86,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.Clause.Make",
      "library": "libzipperposition",
      "description": "This module manages clause state and supports proof manipulation with operations for eligibility checks, literal selection, and subsumption, working with clauses, literals, substitutions, and trails. It integrates submodules that enable precise subterm analysis, term access by position, and iteration over clause components, enhancing automated reasoning tasks like resolution and paramodulation. Hash table utilities allow efficient key-value management with customizable updates and conflict resolution, while positional and iterator-based tools facilitate detailed clause transformations and analysis. Example uses include guiding inference steps by selecting eligible literals, extracting subterms during proof search, or aggregating clause data using high-performance tables.",
      "description_length": 781,
      "index": 87,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.AC_intf.S-C-WithPos",
      "library": "libzipperposition",
      "description": "This module represents clauses with a specific subterm and its position, enabling precise manipulation and analysis of terms within clauses. It provides comparison and pretty-printing operations for these structured clause-term-position triples. It is used in theorem proving contexts where tracking term positions within clauses is necessary for inference or simplification steps.",
      "description_length": 381,
      "index": 88,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.StreamQueue_intf.S-WeightFun",
      "library": "libzipperposition",
      "description": "This module defines weight functions that assign integer weights to streams. It includes operations to compute a penalty value for a stream and to combine multiple weighted functions into a single function using a weighted sum. These functions are used to prioritize or evaluate streams based on custom weighting strategies.",
      "description_length": 324,
      "index": 89,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Lift_lambdas.S-C-Seq",
      "library": "libzipperposition",
      "description": "This module processes logical clauses to extract literals, terms, and variables as iterative sequences. It works with clause (`C.t`) and literal (`Logtk.Literal.t`) types, along with terms and typed variables. It is used in clause analysis and transformation tasks, such as preprocessing for theorem proving or extracting subcomponents for indexing and rewriting.",
      "description_length": 363,
      "index": 90,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Stream.ARG-C",
      "library": "libzipperposition",
      "description": "This module offers operations for clause manipulation in automated reasoning, including flag management (redundancy, simplification), proof extraction, eligibility checks for inference rules, and symbolic analysis. It primarily works with clauses (`C.t`), clause sets (`ClauseSet.t`), substitutions, and term structures, supporting tasks like resolution, paramodulation, and goal detection. Key use cases involve clause transformation, proof derivation tracking, and heuristic-based simplification in theorem proving pipelines.",
      "description_length": 527,
      "index": 91,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Combinators.S-Env-ProofState-CQueue-C",
      "library": "libzipperposition",
      "description": "This module offers functions to manage clause properties and metadata, manipulate trails and proofs, analyze clause structure for resolution eligibility, and apply transformations like substitution and grounding. It operates on clauses, literals, and associated proof structures, facilitating automated reasoning tasks such as theorem proving and debugging through TSTP output. Key patterns include bitvector-driven eligibility tracking, scoped analysis for term properties, and trail-based subsumption checks to optimize logical inference workflows.",
      "description_length": 550,
      "index": 92,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Saturate.S-Env-ProofState-ActiveSet",
      "library": "libzipperposition",
      "description": "This module manages a dynamic set of clauses with signals for additions and removals. It provides operations to add or remove multiple clauses, retrieve the current set, and count clauses. Useful for tracking clause changes in a theorem prover or logic engine.",
      "description_length": 260,
      "index": 93,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.Saturate.S-Env-ProofState",
      "library": "libzipperposition",
      "description": "Manages clause queues, term indexing, and set structures for efficient clause retrieval and manipulation. Provides concrete implementations for priority-based clause processing, subsumption checks, and term-based indexing. Used to support saturation-based theorem proving by organizing and accessing logical statements efficiently.",
      "description_length": 331,
      "index": 94,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.AC_intf.S-C",
      "library": "libzipperposition",
      "description": "This module enables manipulation of clauses in resolution-based theorem proving, focusing on metadata management (flags, weights), trail-based reasoning with proof tracking, and eligibility checks for inference rules. It operates on clauses (`C.t`), trails (`Trail.t`), substitutions, and proof structures, supporting tasks like literal selection, term analysis, and clause transformation. Key use cases include automated reasoning, proof reconstruction, and generating formatted outputs (e.g., TSTP) for interoperability.",
      "description_length": 522,
      "index": 95,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.AC_intf.S-Env-C-WithPos",
      "library": "libzipperposition",
      "description": "This module represents clauses with a specific subterm and its position, enabling precise term manipulation and analysis. It provides comparison and pretty-printing operations for these structured clauses. Useful for tasks like term rewriting, proof tracing, or focused clause transformations where positional context is critical.",
      "description_length": 330,
      "index": 96,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.Saturate.S-Env-ProofState-SimplSet",
      "library": "libzipperposition",
      "description": "This module manages a dynamic set of clauses with operations to add or remove clauses and notify subscribers of changes. It uses iterators to process batches of clauses and provides signals to react to clause additions and removals. It is used to maintain and update a clause database during theorem proving or constraint solving.",
      "description_length": 330,
      "index": 97,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.AC_intf.S-Env-Stm-Ctx-Lit",
      "library": "libzipperposition",
      "description": "This module manages bidirectional conversions between literals and formulas using customizable hooks. It provides functions to register and retrieve conversion hooks for transforming literals to formulas and vice versa, along with direct conversion operations that enforce atomic formula constraints. It works with `Logtk.Literal.t` and `Logtk.SLiteral.t` types, enabling use cases like integrating theorem proving backends that require literal normalization or translation into specific formula forms.",
      "description_length": 502,
      "index": 98,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.Saturate.S-Env-ProofState-UnitIndex-E",
      "library": "libzipperposition",
      "description": "This module represents and compares indexed equations or inequations with their associated terms and proof state data. It provides operations to extract components of an equation, determine its priority, and establish a total order between equations. Concrete use cases include managing and selecting equations during theorem proving or term rewriting processes.",
      "description_length": 362,
      "index": 99,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.Env_intf.S-ProofState-SimplSet",
      "library": "libzipperposition",
      "description": "This module manages a dynamic set of clauses with signals for tracking additions and removals. It provides functions to add or remove multiple clauses using iterators, enabling reactive updates in proof state management. It is used to maintain and monitor changes to clause sets during automated theorem proving processes.",
      "description_length": 322,
      "index": 100,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Combinators.S-Env-ProofState-CQueue-PriorityFun",
      "library": "libzipperposition",
      "description": "This module defines a priority function type used to assign integer weights to proof state queues. It includes a function to parse string descriptions into these priority functions. The primary use case is to dynamically configure prioritization strategies for proof search based on textual input.",
      "description_length": 297,
      "index": 101,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.StreamQueue.Make",
      "library": "libzipperposition",
      "description": "This module manages a priority queue for processing streams of clauses, using customizable weight functions to determine priority. It allows adding streams individually or in groups, inspecting the queue size, and extracting clauses with different fairness and recursion strategies. The main data types include streams and weight functions, with operations like `add`, `size`, and `extract`. For example, users can prioritize streams using the `penalty` function or combine multiple weight functions with `combine` to fine-tune scheduling in automated theorem proving tasks.",
      "description_length": 574,
      "index": 102,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Clause_intf.S-ClauseSet",
      "library": "libzipperposition",
      "description": "This module provides a functional set interface for managing ordered collections of clauses, supporting membership tests, union/intersection operations, and ordered traversal based on a comparator. It emphasizes transformations (filtering, mapping, partitioning), safe element queries (with optional returns), and conversions to/from lists/sequences, maintaining canonical ordering for deterministic iteration. The structure is optimized for use cases requiring precise clause manipulation, such as formal verification workflows or automated reasoning systems where ordered subset selection and predicate-driven transformations are critical.",
      "description_length": 641,
      "index": 103,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Stream_intf.S",
      "library": "libzipperposition",
      "description": "This module implements a stream data structure with unique identifiers, parent tracking, and mutable state for heuristic penalties and retrieval attempts. It supports operations to create, compare, and inspect streams, as well as to extract elements incrementally with `drip` and `drip_n`. Concrete use cases include managing sequences of clause options in automated theorem proving, where streams represent delayed or incremental results tied to inference sources.",
      "description_length": 465,
      "index": 104,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Eprover_interface.S-Env-C-ClauseSet",
      "library": "libzipperposition",
      "description": "This module offers a functional interface for managing ordered collections of clauses, supporting set operations like union and difference, transformations such as mapping and filtering, extremal element queries, and conversions to and from lists and sequences. It works with comparator-parameterized ordered sets (`Env.C.ClauseSet.t`), ensuring deterministic traversal order and providing safe variants for partial operations. Designed for scenarios requiring precise clause management in theorem proving, it enables robust set manipulation, predicate-driven element searches, and seamless integration with other collection types while maintaining immutability.",
      "description_length": 662,
      "index": 105,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Env_intf.S-Stm",
      "library": "libzipperposition",
      "description": "This module implements a stream data structure with unique identifiers, parent tracking, and heuristic penalties, designed for managing sequences of clauses in a theorem proving context. It supports operations like creation, comparison, and incremental extraction of elements, while tracking metadata such as hits and penalties. Concrete use cases include handling clause streams during inference and guiding search heuristics in automated reasoning tasks.",
      "description_length": 456,
      "index": 106,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Saturate.S-Env-C",
      "library": "libzipperposition",
      "description": "This module provides operations for managing clause metadata, equality checks, and eligibility criteria in saturation-based theorem proving. It works with clauses (`Env.C.t`), trails (`Trail.t`), substitutions (`Logtk.Subst.t`), and bitvectors (`CCBV.t`) to support tasks like redundancy detection, proof extraction, and paramodulation. Key use cases include automated reasoning workflows such as clause simplification, goal derivation, and resolution inference rule application.",
      "description_length": 479,
      "index": 107,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Combinators.S-Env-ProofState",
      "library": "libzipperposition",
      "description": "Manages clause queues and indexes for efficient retrieval during automated theorem proving. Provides operations for inserting, selecting, and prioritizing clauses based on term structures and proof state statistics. Uses data types like `stats` and custom printers to track and display progress.",
      "description_length": 295,
      "index": 108,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.AC_intf.S-Env-ProofState-TermIndex",
      "library": "libzipperposition",
      "description": "This module provides operations for managing term indices with efficient insertion, deletion, iteration, and folding over terms paired with positional annotations (`C.WithPos.t`). It supports advanced retrieval operations like unification, generalization, and specialization of terms using scoped substitutions and higher-order unification, particularly useful in theorem proving for querying logical relationships. The `to_dot` function enables visualization of term structures during proof-state analysis by generating DOT-formatted representations.",
      "description_length": 551,
      "index": 109,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.ProofState_intf.S-SimplSet",
      "library": "libzipperposition",
      "description": "This module manages a dynamic set of clauses with operations to add or remove clauses and notify subscribers of changes. It provides signals for clause addition and removal, and bulk update operations using iterators. It is used in automated theorem proving to maintain and modify sets of logical clauses during proof search.",
      "description_length": 325,
      "index": 110,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.Lift_lambdas.S-Env-C-ClauseSet",
      "library": "libzipperposition",
      "description": "This module provides a functional set interface for ordered collections of clauses, supporting operations like union, intersection, ordered traversal, and transformations through mapping and folding. It operates on comparator-ordered sets (`Env.C.ClauseSet.t`) that preserve physical equality and enable efficient ordered iteration, making it suitable for structured clause manipulation in formal logic processing or symbolic reasoning tasks. Additional utilities for safe element queries, conversion to lists/sequences, and string formatting support robust error handling and interoperability in constraint solving or automated reasoning workflows.",
      "description_length": 649,
      "index": 111,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.StreamQueue_intf.S-Stm",
      "library": "libzipperposition",
      "description": "This module implements a queue structure for managing streams of clauses in a theorem proving context. It supports operations to create and manipulate streams with penalties and hit counters, and provides methods to extract elements from the stream. Concrete use cases include prioritizing and processing inference results during automated reasoning tasks.",
      "description_length": 356,
      "index": 112,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Libzipperposition.Saturate.S-Env-C-Tbl",
      "library": "libzipperposition",
      "description": "This module provides operations for creating, manipulating, and safely accessing hash tables where keys are of type `Env.C.t`, supporting standard actions like addition, removal, lookup, and iteration alongside bulk updates and transformations that handle duplicate keys with custom combination logic. It specializes in use cases such as frequency counting, conditional value updates, and controlled serialization of hash table contents, leveraging functions like `update`, `get_or_add`, and `pp` for precise control over data flow and representation.",
      "description_length": 551,
      "index": 113,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Env_intf.S-ProofState",
      "library": "libzipperposition",
      "description": "Manages proof states in automated theorem proving with operations for clause manipulation, indexing, and prioritization. It handles clause sets, term indexing, and subsumption checks, supporting efficient proof search. Used to maintain and update the state during saturation-based theorem proving.",
      "description_length": 297,
      "index": 114,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Lift_lambdas.S-C-Tbl",
      "library": "libzipperposition",
      "description": "This module implements imperative hash tables with keys of type `C.t` and arbitrary value types, offering operations for safe key-value access, bulk updates from sequences or iterators, and transformations like folding or mapping. It supports advanced use cases such as counter manipulation, element counting, and conflict-resolution strategies during aggregation, while enabling conversions between hash tables, lists, and sequences. Typical applications include tracking frequency counts, managing dynamic key-value associations, and efficiently processing large datasets with customizable merging logic.",
      "description_length": 606,
      "index": 115,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Saturate.S-Env-Ctx-Lit",
      "library": "libzipperposition",
      "description": "This module manages bidirectional conversions between literals and formulas using customizable hooks. It provides functions to register and retrieve conversion hooks for transforming literals to formulas and vice versa, as well as direct conversion functions that apply these hooks. Use cases include integrating custom literal representations with theorem proving engines or transforming logical expressions during proof search.",
      "description_length": 429,
      "index": 116,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.BBox.Lit",
      "library": "libzipperposition",
      "description": "This module provides a representation of boolean literals with support for sign manipulation, normalization, and payload handling, where each literal encapsulates an atomic proposition along with its truth value. Its first child module organizes these literals into ordered collections, enabling set operations, ordered traversal, and predicate-based filtering, suitable for symbolic reasoning tasks that require ordered processing. The second child module extends imperative hash table operations to literals, allowing efficient mapping, aggregation, and transformation with customizable merge strategies. Together, they support concrete operations such as negating literals, extracting signs, counting occurrences in a clause, or normalizing expressions within a theorem prover or SAT solver.",
      "description_length": 794,
      "index": 117,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Env_intf.S-C-ClauseSet",
      "library": "libzipperposition",
      "description": "This module provides ordered set operations for managing collections of clauses, supporting membership checks, union/intersection/difference calculations, and ordered traversal (e.g., min/max element retrieval). It works with `C.ClauseSet.t` structures\u2014sets ordered by a comparison function\u2014and includes functions for filtering, converting to/from lists/sequences, and safe element access (e.g., `find_last_opt`). Use cases include clause management in automated reasoning systems where ordered set operations and non-destructive transformations are critical for processing logical formulas.",
      "description_length": 591,
      "index": 118,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Combinators.S-Env-ProofState-SubsumptionIndex-C",
      "library": "libzipperposition",
      "description": "This module defines operations for comparing clauses, extracting literals, and retrieving label subsets. It works with clauses represented by the type `C.t` and provides access to their literals and labels. Concrete use cases include subsumption checking and indexing clauses based on their logical structure and associated metadata.",
      "description_length": 333,
      "index": 119,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.AC_intf.S-Env-ProofState-CQueue-C",
      "library": "libzipperposition",
      "description": "This module offers operations to manage and analyze clauses in a theorem-proving context, including tracking properties like redundancy and simplification status, manipulating proof trails, and evaluating heuristic measures. It works with clauses (represented as `CQueue.C.t`), trails (`Trail.t`), literals, substitutions, and metadata structures, supporting tasks such as clause transformation, proof-step updates, and literal selection for resolution. Specific use cases include automated reasoning, proof optimization, and structured output generation for debugging or external formats like TSTP.",
      "description_length": 599,
      "index": 120,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Lift_lambdas.S-Env-StmQ",
      "library": "libzipperposition",
      "description": "This module implements a priority queue for managing streams of clauses with weighted priorities. It provides operations to add streams or lists of streams, inspect queue state, and extract clauses either fairly or up to the recursion guard limit. The queue is used to control the order and fairness of clause selection in theorem proving processes where streams represent different sources of clauses.",
      "description_length": 402,
      "index": 121,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Eprover_interface.S-Env-ProofState-CQueue-WeightFun",
      "library": "libzipperposition",
      "description": "This module defines weight functions that compute integer weights for clauses in a proof state priority queue. It supports operations like parsing weight function descriptions, combining weighted sums of functions, and applying heuristics such as favoring ground or Horn clauses, penalizing non-goal-related clauses, and adjusting weights based on clause structure. These functions guide clause selection during automated theorem proving by influencing the priority queue's ordering.",
      "description_length": 483,
      "index": 122,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "Libzipperposition.Eprover_interface.S-Env-C-Eligible",
      "library": "libzipperposition",
      "description": "This module defines eligibility criteria for selecting literals in a clause based on specific logical properties. It provides functions to filter literals by resolution, paramodulation, positivity, negativity, maximality, and equation status, as well as logical combinations of these conditions. These operations are used to control inference rules in automated theorem proving, such as restricting resolution to only certain literals or combining multiple eligibility conditions for precise literal selection.",
      "description_length": 510,
      "index": 123,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Saturate.S-Env-Stm-Ctx",
      "library": "libzipperposition",
      "description": "This module supports operations for managing logical context in automated reasoning systems, focusing on term orderings, symbol type declarations, and skolemization contexts. It works with data structures like logical literals (via the Lit module) and identifiers, enabling precise checks for function injectivity and efficient manipulation of symbolic expressions. These capabilities are critical in applications like automated theorem proving and formal verification, where tracking symbol properties and normalizing logical terms are essential.",
      "description_length": 547,
      "index": 124,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.ProofState_intf.S-C-Ctx",
      "library": "libzipperposition",
      "description": "This module provides functionality for managing logical contexts in theorem proving, including term ordering, skolemization, injectivity checks for function symbols, and tracking symbol updates to preserve completeness. It operates on literals, clauses, and signatures, enabling tasks like clause manipulation, injectivity-driven reasoning, and maintaining logical consistency during signature changes.",
      "description_length": 402,
      "index": 125,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.StreamQueue_intf.S-Stm-Ctx-Lit",
      "library": "libzipperposition",
      "description": "This module manages bidirectional conversions between literals and formulas using customizable hooks. It provides functions to register and retrieve conversion hooks for transforming literals to formulas and vice versa, as well as direct conversion functions that apply these hooks. It works with `Logtk.Literal.t` and `Logtk.SLiteral.t` types, enabling use cases like integrating custom literal representations into theorem proving pipelines or translating between internal and external logic formats.",
      "description_length": 502,
      "index": 126,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.Env_intf.S-ProofState-ActiveSet",
      "library": "libzipperposition",
      "description": "This module manages a dynamic set of clauses with signals for additions and removals. It provides operations to add or remove multiple clauses, retrieve the current set, and count clauses. Useful for tracking clause changes in a proof state, such as during theorem proving or constraint solving.",
      "description_length": 295,
      "index": 127,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Saturate.S-Env-Stm",
      "library": "libzipperposition",
      "description": "This module manages streams of clauses with associated metadata, supporting operations to create, compare, and manipulate streams based on their content and provenance. It provides functions to access stream properties like ID and penalty, and to extract elements incrementally with `drip` or in batches with `drip_n`. Concrete use cases include managing inference streams in automated theorem proving, where streams represent sequences of derived clauses subject to heuristic control and prioritization.",
      "description_length": 504,
      "index": 128,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Lift_lambdas.S-Env-FormRename",
      "library": "libzipperposition",
      "description": "This module handles lambda lifting and formula renaming during proof search, specifically managing predicate skolemization and definition extraction. It operates on clauses and formulas, using a renaming context to track and apply substitutions. Concrete use cases include introducing skolem constants for existential quantifiers and renaming subformulas to preserve logical structure during transformation.",
      "description_length": 407,
      "index": 129,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Saturate.S-Env-C-Seq",
      "library": "libzipperposition",
      "description": "This module provides functions to extract literals, terms, and variables from a clause environment. It operates on clause structures using the `Env.C.t` type, enabling analysis of logical components in automated theorem proving. Concrete use cases include clause inspection during saturation-based reasoning and term traversal for proof search.",
      "description_length": 344,
      "index": 130,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Saturate.S",
      "library": "libzipperposition",
      "description": "This module implements the given clause algorithm for saturation-based theorem proving, performing inference steps and state reduction. It operates on logical clauses and proof states, managing clause selection and simplification. It supports running a fixed number of steps, full saturation, or presaturation for interreduction, returning proof status and step counts.",
      "description_length": 369,
      "index": 131,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.Eprover_interface.S-Env-C-WithPos",
      "library": "libzipperposition",
      "description": "This module represents clauses with a specific subterm and its position, enabling precise term manipulation and analysis. It provides comparison and pretty-printing operations for these structured clauses. Useful for tasks like subterm indexing, rewriting, or focused proof search where positional context is critical.",
      "description_length": 318,
      "index": 132,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Eprover_interface.S-Env-ProofState",
      "library": "libzipperposition",
      "description": "Manages clause queues and indexing structures for efficient retrieval during automated theorem proving. It handles term and unit indexing, subsumption checks, and organizes clauses into active, simplification, and passive sets. Used to maintain proof state statistics, enable detailed debugging output, and support efficient clause management in saturation-based provers.",
      "description_length": 371,
      "index": 133,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.ClauseQueue_intf.S-PriorityFun",
      "library": "libzipperposition",
      "description": "This module defines a priority function for clauses in a theorem prover, mapping each clause to an integer priority. It includes a function to parse string descriptions into these priority functions. This allows dynamic configuration of clause selection strategies based on textual input.",
      "description_length": 288,
      "index": 134,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.AC.Make",
      "library": "libzipperposition",
      "description": "This module combines AC theory handling with advanced clause manipulation to support precise equational reasoning and proof search. It introduces AC-aware simplification, triviality checks, and symbol detection over terms and clauses, while integrating submodules for redundancy control, literal analysis, and structured clause traversal. Operations include simplifying equations under AC properties, filtering AC-trivial clauses, and applying resolution or paramodulation with eligibility tracking. Examples include detecting and normalizing AC symbols in input clauses, rewriting terms modulo AC, and debugging proofs using TSTP-formatted clause output.",
      "description_length": 655,
      "index": 135,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.ProofState_intf.S-C-Tbl",
      "library": "libzipperposition",
      "description": "This module implements a polymorphic hash table structure with keys of type `C.t`, supporting imperative operations like insertion, deletion, and lookup, along with advanced transformations such as bulk updates from sequences, in-place filtering, and customizable merging of duplicate keys. It emphasizes safe value manipulation through combinators for aggregation, memoization patterns, and controlled mutation, while enabling efficient traversal and conversion to/from lists or sequences of bindings. Typical use cases include managing dynamic key-value mappings with custom collision handling, aggregating data streams into histograms, or implementing stateful accumulators with precise update policies.",
      "description_length": 706,
      "index": 136,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Eprover_interface.S-Env-ProofState-ActiveSet",
      "library": "libzipperposition",
      "description": "This module manages a dynamic set of clauses with signals for additions and removals. It provides operations to add or remove clauses, retrieve the current set, and count clauses. Useful for tracking clause changes in a proof state, such as during theorem proving or constraint solving.",
      "description_length": 286,
      "index": 137,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Eprover_interface.S-Env-Stm-Ctx",
      "library": "libzipperposition",
      "description": "This module supports operations for term ordering, symbol declaration, signature manipulation, and skolemization in first-order logic contexts. It works with terms, types, symbols, substitutions, and logical literals, facilitating tasks like injectivity checks for unification and literal normalization. These capabilities are used in theorem proving and term rewriting systems to manage logical reasoning and proof search.",
      "description_length": 423,
      "index": 138,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.AC_intf.S-Env-C-Seq",
      "library": "libzipperposition",
      "description": "This module provides functions to extract literals, terms, and variables from a given clause environment. It operates on clause structures and iterates over logical components such as literals, terms, and typed variables. It is used in clause processing tasks like analysis, transformation, and inference during automated reasoning.",
      "description_length": 332,
      "index": 139,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.Sat_solver_intf.S",
      "library": "libzipperposition",
      "description": "This module implements a SAT solver interface that supports adding clauses in various forms, checking satisfiability, and extracting valuation models, proofs, and decision levels. It operates on propositional literals (`Lit.t`) and structures such as clauses (lists of literals), proof steps, and sets of literals. Concrete use cases include integrating with theorem provers to manage logical constraints, validating models in formal verification, and generating resolution proofs for unsatisfiable formulas.",
      "description_length": 508,
      "index": 140,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.Lift_lambdas.S-Env-ProofState-SimplSet",
      "library": "libzipperposition",
      "description": "This module manages a set of clauses with operations to add or remove clauses and notify subscribers of changes. It uses signals to trigger actions when clauses are added or removed, working with clause sets through iterators. It is useful for tracking dynamic clause sets in theorem proving or constraint solving where changes need to be observed and processed.",
      "description_length": 362,
      "index": 141,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.Env_intf.S-ProofState-UnitIndex",
      "library": "libzipperposition",
      "description": "This module implements an index for managing and querying logical (in)equations within a proof state. It supports operations to add, remove, and retrieve indexed terms with substitution-based matching, enabling efficient lookups for clause generalization. The index is used during automated reasoning to find applicable rewrite rules or constraints that match a given term under specific substitutions.",
      "description_length": 402,
      "index": 142,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Env_intf.S-FormRename-Ctx-Lit",
      "library": "libzipperposition",
      "description": "This module manages bidirectional conversions between literals and formulas using customizable hooks. It provides functions to register and retrieve conversion hooks for transforming literals to formulas and vice versa, as well as direct conversion operations that enforce atomicity constraints. It works with `Logtk.Literal.t` and `Logtk.SLiteral.t` types, supporting use cases like integrating custom literal representations into theorem proving pipelines or translating between internal and external logic encodings.",
      "description_length": 519,
      "index": 143,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.AC_intf.S-C-Pos",
      "library": "libzipperposition",
      "description": "Extracts a subterm from a given term at a specified position. Works with terms and positions represented by `Logtk.Term.t` and `Logtk.Position.t` types. Useful for precise term manipulation and analysis in theorem proving or term rewriting systems.",
      "description_length": 248,
      "index": 144,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.StreamQueue.ARG-Stm-C-Pos",
      "library": "libzipperposition",
      "description": "This module provides a function `at` that retrieves a term from a stream at a specified position. It operates on streams of type `Stm.C.t` and uses positions defined by `Logtk.Position.t` to access specific elements. A concrete use case is extracting terms from a stream during proof search or term traversal.",
      "description_length": 309,
      "index": 145,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.Env_intf.S-ProofState-PassiveSet",
      "library": "libzipperposition",
      "description": "This module manages a passive clause set with dynamic addition and removal, providing signals for tracking changes. It supports operations to query, add, remove, and process clauses, along with checking clause status and queue state. Concrete use cases include managing passive clauses during theorem proving and coordinating clause processing in a saturation loop.",
      "description_length": 365,
      "index": 146,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.FormulaRename.S-C-Pos",
      "library": "libzipperposition",
      "description": "This module provides a function `at` that retrieves a subterm from a given formula at a specified position. It operates on logical formulas represented by the type `C.t` and uses positions of type `Logtk.Position.t` to navigate the term structure. A typical use case involves accessing specific parts of a logical expression for analysis or transformation during automated reasoning tasks.",
      "description_length": 389,
      "index": 147,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.AC_intf.S-Env-StmQ",
      "library": "libzipperposition",
      "description": "This module implements a priority queue for managing streams of clauses with weighted priorities. It supports operations to add streams or lists of streams, retrieve clauses fairly or under a guard, and inspect queue state. Concrete use cases include scheduling clause processing in automated theorem proving where streams represent different sources of clauses and weights control prioritization.",
      "description_length": 397,
      "index": 148,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.ProofState_intf.S-CQueue-PriorityFun",
      "library": "libzipperposition",
      "description": "This module defines a priority function type for weighted queue operations, where each function maps a `CQueue.C.t` element to an integer priority. It includes a parser to convert string descriptions into corresponding priority functions. This enables dynamic configuration of prioritization logic in proof state management systems.",
      "description_length": 332,
      "index": 149,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.SClause.TPSet",
      "library": "libzipperposition",
      "description": "This module implements an ordered set structure for managing pairs of logical terms and their positional annotations, supporting efficient membership checks, ordered traversal, and set-theoretic operations like union and intersection. It provides transformation utilities such as predicate-based filtering, bidirectional conversion with lists/sequences, and safe accessors that return optional values instead of raising exceptions. The ordered semantics enable applications in clause management for theorem proving, where hierarchical term relationships and positional metadata require structured querying, iterative refinement, and customizable serialization for analysis or debugging.",
      "description_length": 686,
      "index": 150,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.AC_intf.S-Env-ProofState-TermIndex-Leaf",
      "library": "libzipperposition",
      "description": "This module implements a term index structure that supports efficient insertion, removal, and querying of logical terms in a proof state context. It provides operations for unification and matching between indexed terms and query terms, returning substitutions that make the terms compatible. It is used in automated theorem proving to find relevant clauses or subterms during proof search.",
      "description_length": 390,
      "index": 151,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.AC_intf.S-Env-C-Tbl",
      "library": "libzipperposition",
      "description": "This module offers hash table operations centered on `Env.C.Tbl.t`, a structure mapping `Env.C.t` keys to values, with support for aggregation, conditional updates, and custom combination logic during bulk insertions. It includes advanced manipulations like safe retrieval, incrementing/decrementing counts, and serializing table contents, alongside standard creation, lookup, and iteration. Use cases include tracking term frequencies from sequences, merging datasets with conflict resolution, and functional-style transformations of key-value pairs.",
      "description_length": 551,
      "index": 152,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Libzipperposition.Saturate.S-Env-ProofState-SubsumptionIndex",
      "library": "libzipperposition",
      "description": "This module implements a subsumption index for managing and querying clauses in a proof state. It supports operations to add, remove, and retrieve clauses based on subsumption and alpha-equivalence relationships, using literals and labels as keys. Use cases include efficient clause indexing and retrieval during automated theorem proving processes, such as identifying redundant clauses or finding candidates for resolution steps.",
      "description_length": 431,
      "index": 153,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Stream.ARG-Ctx",
      "library": "libzipperposition",
      "description": "This module provides operations for managing term orderings, selection functions, and skolemization contexts, alongside tools for symbol declaration, type lookup, and injectivity analysis of function arguments. It works with terms, logical literals, and symbol signatures, enabling tasks like clause simplification, term rewriting, and logical reasoning where precise context management and term property checks are critical.",
      "description_length": 425,
      "index": 154,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Eprover_interface.S-Env-FormRename",
      "library": "libzipperposition",
      "description": "This module handles formula renaming and Skolemization during proof search. It provides functions to rename logical formulas, introduce predicate Skolem symbols, and retrieve skolemized terms based on context and polarity. Use cases include managing formula definitions and generating fresh Skolem symbols when processing clauses in automated theorem proving.",
      "description_length": 359,
      "index": 155,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.StreamQueue.ARG-Stm-C-Tbl",
      "library": "libzipperposition",
      "description": "This module implements a polymorphic hash table with keys of type `Stm.C.t`, supporting imperative operations like insertion, lookup, in-place updates, and bulk transformations from sequences. It emphasizes use cases such as counting, deterministic iteration over bindings, and aggregation with custom combining functions for duplicates. Key features include safe value retrieval, list-accumulation patterns, and serialization for structured data management in dynamic collections.",
      "description_length": 481,
      "index": 156,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Env_intf.S-C-Tbl",
      "library": "libzipperposition",
      "description": "The module implements imperative hash tables for key-value mappings with specialized operations on keys of type `C.t`, supporting efficient insertion, lookup, in-place modification, and bulk transformations. It works with hash tables that bind keys to arbitrary values (including integers for counters) and provides utilities for merging sequences of entries, customizing key collisions, and converting between tables and collections like lists or sequences. This structure is suited for tasks requiring memoization, environment tracking, or symbol table management where dynamic key-value updates and bulk processing are critical.",
      "description_length": 631,
      "index": 157,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Env_intf.S",
      "library": "libzipperposition",
      "description": "This module provides logical inference, simplification, and proof state management operations for automated reasoning systems. It operates on clauses, clause sets, and trails to enable redundancy checks, term normalization, and tautology elimination, while supporting rule registration for rewriting, inference prioritization, and dynamic state updates via signal handling during proof search. Key use cases include clause elimination, predicate variable management, and integrating simplification strategies with global state tracking for theorem proving workflows.",
      "description_length": 566,
      "index": 158,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.StreamQueue_intf.S-Stm-C-ClauseSet",
      "library": "libzipperposition",
      "description": "This module provides ordered set operations for managing collections of clauses, including membership checks, union, intersection, difference, and ordered traversal via functions like `map`, `fold`, and `iter`. It works with sets of type `Stm.C.ClauseSet.t`, which are ordered using a comparator function to ensure deterministic iteration and efficient querying of elements like min/max. Designed for applications requiring precise clause ordering and safe operations\u2014such as automated reasoning systems or formal verification tools\u2014it supports conversions to sequences/lists, predicate-based searches, and robust handling of edge cases via optional return types.",
      "description_length": 663,
      "index": 159,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Combinators.S-C-ClauseSet",
      "library": "libzipperposition",
      "description": "This module implements an immutable ordered set structure for managing collections of logical clauses, supporting standard set operations like union, intersection, and difference alongside element-wise transformations and filters. It provides ordered traversal, efficient membership checks, and safe variants of partial operations, all while preserving immutability through structural sharing. The set's elements are typically clauses used in automated reasoning tasks, with utilities for conversion to sequences/lists and human-readable serialization aiding debugging or result inspection.",
      "description_length": 590,
      "index": 160,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.FormulaRename.S",
      "library": "libzipperposition",
      "description": "This module handles formula renaming and skolemization during logical transformation. It provides functions to rename terms based on clauses, detect renaming clauses, and introduce predicate skolems with configurable freshness strategies. It works with terms and clauses, supporting use cases like formula normalization and definition extraction in theorem proving.",
      "description_length": 365,
      "index": 161,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Env_intf.S-ProofState-TermIndex",
      "library": "libzipperposition",
      "description": "The module implements a term indexing structure for efficient term management in logical reasoning, supporting operations to add, remove, and query terms alongside positional elements (`C.WithPos.t`) through unification, generalization, and specialization. It leverages term representations from `Logtk.Index_intf` and structures them into a graph-like index for fast retrieval and manipulation during proof state transitions. The `to_dot` function enables visual debugging of this index by rendering its hierarchy into DOT format, useful for analyzing term relationships in automated theorem proving workflows.",
      "description_length": 611,
      "index": 162,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Env_intf.S-C-Pos",
      "library": "libzipperposition",
      "description": "This module provides a function `at` that retrieves a term from a given position within a clause. It operates on clauses and positions to access specific subterms. Use it to inspect or manipulate terms at precise locations during proof search or term rewriting.",
      "description_length": 261,
      "index": 163,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Libzipperposition.StreamQueue_intf.S-Stm-Ctx",
      "library": "libzipperposition",
      "description": "This module provides operations for managing logical context in automated reasoning systems, including term ordering, symbol declaration, skolemization, and signature tracking with change notifications. It works with logical literals, terms, identifiers, and signatures to support tasks like injectivity checks for function arguments and literal manipulation. These capabilities are used in theorem proving and term rewriting systems to maintain consistency during proof search or clause processing.",
      "description_length": 499,
      "index": 164,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Saturate.Make",
      "library": "libzipperposition",
      "description": "Implements the given clause algorithm for automated reasoning, performing inference steps and saturation on logical clauses. It operates on internal states representing clause sets, supporting operations like interreduction and controlled inference generation. Used in theorem proving to derive conclusions from logical premises, with configurable execution limits and reduction strategies.",
      "description_length": 390,
      "index": 165,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Combinators.S-C-Pos",
      "library": "libzipperposition",
      "description": "This module provides a function `at` that retrieves a subterm from a given term at a specified position. It operates on terms represented by the `C.t` type and uses positions defined by `Logtk.Position.t`. A typical use case involves accessing specific parts of logical expressions during proof search or term rewriting.",
      "description_length": 320,
      "index": 166,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Saturate.S-Env-FormRename-Ctx",
      "library": "libzipperposition",
      "description": "This system includes operations for term ordering, symbol declaration, signature management, and skolemization, alongside injectivity checks for function arguments that influence inference and rewriting. It operates on terms, types, symbols, and substitutions, with the Lit module specifically handling logical literals through normalization, comparison, and inference rule application in first-order logic contexts. These tools are critical for automating theorem proving and term rewriting tasks where precise logical manipulation and quantifier handling are required.",
      "description_length": 570,
      "index": 167,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.Cut_form.Pos",
      "library": "libzipperposition",
      "description": "This module provides precise term manipulation within a structured logical context, enabling operations like retrieving subterms, literals, or clauses at specific positions. It supports in-place replacements of terms, either singly or in bulk, using positional addressing. Concrete use cases include term rewriting, logical formula transformation, and position-based analysis in automated reasoning tools.",
      "description_length": 405,
      "index": 168,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Eprover_interface.S-Env-ProofState-SubsumptionIndex-C",
      "library": "libzipperposition",
      "description": "This module defines operations for comparing clauses, extracting literals, and retrieving label subsets from clauses. It works with clause data structures and associated label sets. Concrete use cases include subsumption checking and literal iteration during proof search.",
      "description_length": 272,
      "index": 169,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Bool_lit_intf.S-Tbl",
      "library": "libzipperposition",
      "description": "This module provides hash table operations for managing key-value pairs with keys of type `t` (aliased as `key`) and values of arbitrary or integer types. It supports creation, modification, and querying of bindings, including safe lookups, in-place updates, bulk iteration via sequences or lists, frequency counting, and merging values with custom combinators. Typical use cases include tracking element frequencies, aggregating data from streams, and efficiently transforming or combining hash tables with domain-specific merge logic for duplicates.",
      "description_length": 551,
      "index": 170,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Env_intf.S-ProofState-SubsumptionIndex",
      "library": "libzipperposition",
      "description": "This module implements a subsumption index for managing and querying clauses in a theorem proving context. It supports operations to add, remove, and retrieve clauses based on subsumption and alpha-equivalence relationships, using literals and labels as keys. Use cases include efficient clause indexing and redundancy checking during proof search in automated reasoning systems.",
      "description_length": 379,
      "index": 171,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Saturate.S-Env-FormRename-Ctx-Lit",
      "library": "libzipperposition",
      "description": "This module manages bidirectional conversions between literals and atomic formulas using customizable hooks. It provides functions to register and retrieve conversion hooks, as well as to perform the actual conversions between `Logtk.Literal.t` and `Logtk.Term.t Logtk.SLiteral.t`. It is used in contexts where literals need to be transformed into atomic formulas and vice versa, such as during clause processing or formula normalization.",
      "description_length": 438,
      "index": 172,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.AC_intf.S",
      "library": "libzipperposition",
      "description": "This module handles AC (associative-commutative) symbol declarations and reasoning, providing operations to register symbols as AC, check AC status, and retrieve associated proofs. It works with symbols represented as `Logtk.ID.t`, clauses as `Logtk.Statement.clause_t`, and terms as `Logtk.Term.t`. Key use cases include detecting and simplifying AC-trivial literals and clauses, and integrating AC properties into proof contexts during theorem proving.",
      "description_length": 454,
      "index": 173,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.AC_intf.S-Env-ProofState-UnitIndex-E",
      "library": "libzipperposition",
      "description": "This module represents and compares indexed equations or inequations, providing a total order via `compare`, extracting term components with `extract`, and indicating usefulness through `priority`. It operates on pairs of terms along with a boolean flag and a clause, supporting indexing strategies in theorem proving. Concrete use cases include managing and prioritizing equations during clause processing in automated reasoning systems.",
      "description_length": 438,
      "index": 174,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.Combinators.S-Env-ProofState-PassiveSet",
      "library": "libzipperposition",
      "description": "This module manages a set of passive clauses with operations to add, remove, and retrieve clauses, as well as track their state via signals. It works with clause sets and a clause queue, providing direct access to the current set and the next clause to process. Concrete use cases include controlling clause processing in a saturation loop and monitoring clause additions or removals for debugging or logging.",
      "description_length": 409,
      "index": 175,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.AC_intf.S-C-Eligible",
      "library": "libzipperposition",
      "description": "This module defines a set of functions and combinators for determining which literals in a clause are eligible for specific inference rules during automated theorem proving. It operates on clauses and their literals, allowing filtering based on properties such as positivity, negativity, being an equation, or eligibility for resolution and paramodulation. Use cases include selecting maximal literals, combining eligibility conditions with logical operations, and defining custom literal selection strategies in proof search.",
      "description_length": 526,
      "index": 176,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Eprover_interface.S-Env-FormRename-Ctx-Lit",
      "library": "libzipperposition",
      "description": "This module provides functions to convert between logical literals and their term-based representations, using customizable hooks for transformation. It operates on `Logtk.Literal.t` and `Logtk.SLiteral.t` types, enabling bidirectional conversion while supporting atomic formulas only. Concrete use cases include integrating with theorem provers that require literal normalization or translation into specific term formats.",
      "description_length": 423,
      "index": 177,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Combinators.S-C-Eligible",
      "library": "libzipperposition",
      "description": "This module defines eligibility criteria for selecting literals in a clause based on specific logical properties. It provides operations to filter literals by resolution, paramodulation, positivity, negativity, equation status, and maximality, as well as logical combinations of these conditions. Use cases include guiding inference rules in automated theorem proving by restricting which literals can participate in resolution or paramodulation steps.",
      "description_length": 452,
      "index": 178,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Combinators.S-Env-ProofState-CQueue-WeightFun",
      "library": "libzipperposition",
      "description": "This module defines weight functions that compute integer weights for clauses in a proof state priority queue. It supports operations like parsing weight function descriptions, combining multiple weight functions with coefficients, and applying heuristic-based penalties or preferences based on clause properties such as goal proximity, groundness, or literal composition. Use cases include guiding clause selection in automated theorem proving by prioritizing relevant or structurally favorable clauses.",
      "description_length": 504,
      "index": 179,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.StreamQueue_intf.S",
      "library": "libzipperposition",
      "description": "This module implements a priority-based stream queue with weighted sorting and fair clause extraction. It manages a collection of streams, prioritizing clause retrieval based on configurable weights and guard limits. Concrete use cases include scheduling clause processing in automated theorem proving and managing prioritized work queues in parallel evaluation tasks.",
      "description_length": 368,
      "index": 180,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Lift_lambdas.S-Env-ProofState-SubsumptionIndex",
      "library": "libzipperposition",
      "description": "This module implements a subsumption index for managing and querying clauses in a proof state. It supports operations to add, remove, and retrieve clauses based on subsumption and alpha-equivalence relationships, using literals and labels as keys. Use cases include efficient clause indexing and retrieval during automated theorem proving processes.",
      "description_length": 349,
      "index": 181,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Saturate.S-Env-C-Pos",
      "library": "libzipperposition",
      "description": "Retrieves a term from a given position in a clause within a specific environment. Works with environments (`Env.C.t`) and logical terms (`Logtk.Term.t`) indexed by positions (`Logtk.Position.t`). Useful for accessing specific subterms during proof search or term rewriting.",
      "description_length": 273,
      "index": 182,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.ProofState_intf.S-module-type-CLAUSE_SET",
      "library": "libzipperposition",
      "description": "This module manages a set of clauses with operations to add or remove clauses and track changes through signals. It works with clause sets and provides signals for monitoring additions and removals. Concrete use cases include maintaining dynamic collections of logical clauses during theorem proving or constraint solving.",
      "description_length": 322,
      "index": 183,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Saturate.S-Env-ProofState-SubsumptionIndex-C",
      "library": "libzipperposition",
      "description": "This module defines operations for comparing clauses, extracting literals, and retrieving label subsets. It works with clause data types from the proof state subsumption index. Concrete use cases include managing clause ordering, literal iteration for indexing, and label-based subsumption checks during theorem proving.",
      "description_length": 320,
      "index": 184,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Ctx.Key",
      "library": "libzipperposition",
      "description": "This module defines a flexible state key for tracking whether completeness has been lost during logical reasoning processes. It works with boolean values stored in a state management system to indicate the integrity of inference steps. This key is used to ensure accurate error reporting and control flow in automated theorem proving scenarios.",
      "description_length": 344,
      "index": 185,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.ProofState_intf.S-UnitIndex-E",
      "library": "libzipperposition",
      "description": "This module represents and compares indexed equations or inequations, providing a total order via `compare` and utility to extract components with `extract`. It works with tuples of terms, a boolean sign, and a clause, allowing prioritization of equations through the `priority` function. Concrete use cases include managing and selecting equations during theorem proving or term rewriting processes.",
      "description_length": 400,
      "index": 186,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Bool_lit_intf.S",
      "library": "libzipperposition",
      "description": "This module represents boolean literals with sign and payload, supporting operations like negation, sign manipulation, and normalization. It provides comparison, hashing, and equality functions for literals, along with utilities to create, inspect, and format them. Use cases include implementing SAT solvers or symbolic logic systems where literals must carry additional data and support efficient set and table operations via the Set and Tbl submodules.",
      "description_length": 455,
      "index": 187,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Lift_lambdas.S-Env-Ctx",
      "library": "libzipperposition",
      "description": "This module manages logical contexts and term transformations for theorem proving, offering operations to configure ordering, selection, and skolemization settings while enabling term comparison and symbol type declarations. It works with first-order logic terms, identifiers, and signatures, alongside higher-order constructs like lambda-lifted representations. Key use cases include analyzing term injectivity for transformation decisions and manipulating literals during proof search in systems requiring both first-order and higher-order reasoning.",
      "description_length": 552,
      "index": 188,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.Stream.ARG-C-Eligible",
      "library": "libzipperposition",
      "description": "This module defines eligibility criteria for selecting literals in clauses based on specific logical properties and operations. It provides functions to filter literals by resolution, paramodulation, positivity, negativity, maximality, and equation status, as well as combining and negating these criteria. Use cases include guiding inference rules in automated theorem proving by restricting which literals can participate in resolution or paramodulation steps.",
      "description_length": 462,
      "index": 189,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.Lift_lambdas.S-Env-ProofState-module-type-CLAUSE_SET",
      "library": "libzipperposition",
      "description": "This module manages a set of clauses with operations to add or remove clauses and trigger signals on these changes. It works with clause sets and uses iterators over clauses for batch modifications. Concrete use cases include tracking clause additions or removals during theorem proving processes, such as in automated reasoning or logic-based systems.",
      "description_length": 352,
      "index": 190,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.Env_intf.S-StmQ",
      "library": "libzipperposition",
      "description": "This module implements a priority queue for managing streams of clauses with weighted priorities. It supports operations to add streams or lists of streams, retrieve clauses fairly or non-blocking, and inspect queue state. Concrete use cases include scheduling clause processing in automated theorem proving where streams represent different sources of clauses and prioritization affects proof search efficiency.",
      "description_length": 412,
      "index": 191,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.Stream.ARG-C-ClauseSet",
      "library": "libzipperposition",
      "description": "This module offers operations for managing ordered collections of logical clauses, supporting set-theoretic operations (union, intersection, difference), ordered traversal, and transformations (filtering, mapping, partitioning) with deterministic element selection. It works with sets represented via `C.ClauseSet.t`, which maintain canonical ordering through a comparator module (`Ord.compare`), enabling efficient queries, safe lookups via optional returns, and conversions to sequences or lists. Typical use cases involve automated reasoning systems where structured manipulation of clause sets\u2014such as iterative refinement, subset extraction, or ordered enumeration\u2014is required for tasks like theorem proving or constraint solving.",
      "description_length": 735,
      "index": 192,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Lift_lambdas.S-C-Pos",
      "library": "libzipperposition",
      "description": "Retrieves a subterm at a specified position within a given term. Works with terms and positions from the Logtk library. Useful for precise term manipulation and analysis in automated reasoning tasks.",
      "description_length": 199,
      "index": 193,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.Combinators.S",
      "library": "libzipperposition",
      "description": "This module provides functions to manipulate and transform terms in a theorem proving context. It includes operations for converting lambda expressions and expanding terms using registered rules. The module works with term structures and environments to support concrete tasks like term normalization and rule-based rewriting.",
      "description_length": 326,
      "index": 194,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Env_intf.S-Stm-Ctx-Lit",
      "library": "libzipperposition",
      "description": "This module manages bidirectional conversions between literals and formulas using customizable hooks. It provides operations to register and retrieve conversion functions for transforming literals to and from terms, supporting dynamic extension of literal handling logic. Concrete use cases include integrating custom term representations with theorem proving procedures that require atomic formulas as literals.",
      "description_length": 412,
      "index": 195,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Clause_intf.S-Eligible",
      "library": "libzipperposition",
      "description": "This module defines predicates for selecting eligible literals in a clause based on specific logical properties, such as positivity, negativity, maximality, or being an equation. It provides operations to filter literals for resolution, paramodulation, and custom criteria, supporting precise control over inference rules in automated theorem proving. Use cases include guiding the selection of literals during proof search and combining eligibility conditions using logical operators.",
      "description_length": 485,
      "index": 196,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.AC_intf.S-Env-FormRename-Ctx",
      "library": "libzipperposition",
      "description": "This module provides context management operations for terms and clauses in automated reasoning systems, supporting term ordering adjustments, skolemization, literal manipulation, and symbol declaration tracking. It works with logical literals (via the Lit submodule), term structures, and function symbol signatures, enabling use cases like equality reasoning and constraint solving. Specific features such as injectivity checks for function arguments and term comparison utilities facilitate precise handling of term equivalence and logical inference in formal verification tasks.",
      "description_length": 582,
      "index": 197,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.AC_intf.S-Env-Stm-Ctx",
      "library": "libzipperposition",
      "description": "This module offers operations for manipulating term orderings, selection functions, and skolemization contexts within logical systems, alongside managing symbol declarations and tracking changes through signals. It operates on logical literals and terms, utilizing identifiers to analyze properties like injectivity in specific argument positions. Its functionality supports tasks such as injectivity verification and dynamic adaptation to signature modifications during theorem proving or term rewriting.",
      "description_length": 505,
      "index": 198,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.Lift_lambdas.Make",
      "library": "libzipperposition",
      "description": "This module transforms lambda terms in clauses into first-order representations by introducing new symbols for lambda expressions and updating clauses accordingly, enabling first-order reasoning in higher-order theorem proving pipelines. It works directly with terms and clauses from the environment, eliminating lambdas during preprocessing to simplify logical structures. The child module extends this functionality by managing clause properties, transformations, and analysis, supporting operations such as substitution, redundancy checks, proof extraction, and literal filtering. Together, they allow tasks like navigating term structures with positional access, selecting eligible literals for inference rules, and maintaining ordered clause sets with deterministic traversal and set operations.",
      "description_length": 800,
      "index": 199,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.ClauseQueue_intf.S-C-Eligible",
      "library": "libzipperposition",
      "description": "This module defines eligibility criteria for selecting literals within clauses, primarily used in theorem proving operations. It provides functions to filter literals based on properties such as positivity, negativity, maximality, and equation status, along with logical combinations of these conditions. These criteria determine which literals are eligible for operations like resolution and paramodulation during proof search.",
      "description_length": 428,
      "index": 200,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.ProofState_intf.S-ActiveSet",
      "library": "libzipperposition",
      "description": "This module manages a dynamic set of clauses with operations to add or remove clauses, retrieve the current set, and track clause additions and removals via signals. It works with clause data types and maintains an internal set structure for efficient querying. It is used to monitor and manipulate logical clauses during proof search or theorem proving processes.",
      "description_length": 364,
      "index": 201,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.ProofState_intf.S",
      "library": "libzipperposition",
      "description": "This module manages the core components of a theorem prover's proof state, including active clauses, indexing structures, and clause sets. It provides operations for clause management, term indexing, subsumption checks, and statistics tracking using concrete data types like clauses, terms, and indexed collections. Use cases include organizing clauses during resolution, efficiently retrieving related clauses via term indices, and maintaining state during proof search.",
      "description_length": 471,
      "index": 202,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.StreamQueue.ARG-Stm-Ctx-Lit",
      "library": "libzipperposition",
      "description": "This module manages bidirectional conversions between literals and formulas using customizable hooks. It provides operations to register and retrieve conversion functions for transforming literals to formulas and vice versa. The module works with literals and terms from the Logtk library, specifically `Logtk.Literal.t` and `Logtk.Term.t Logtk.SLiteral.t`.",
      "description_length": 357,
      "index": 203,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Saturate.S-Env-ProofState-module-type-CLAUSE_SET",
      "library": "libzipperposition",
      "description": "This module manages a dynamic set of clauses with operations to add or remove clauses and attach event handlers for changes. It provides signals triggered on clause insertion and removal, enabling reactive updates or logging. Use cases include maintaining a clause database during theorem proving or tracking clause lifecycle events for debugging and analysis.",
      "description_length": 360,
      "index": 204,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Combinators.S-Env-ProofState-TermIndex-Leaf",
      "library": "libzipperposition",
      "description": "This module implements a term indexing structure that supports efficient insertion, removal, and querying of logical terms within a proof state environment. It provides operations for unification and matching between indexed terms and query terms, enabling concrete use cases such as clause retrieval during resolution-based theorem proving. The structure works directly with logical terms and elements tied to a proof state, supporting advanced search and substitution operations used in automated reasoning.",
      "description_length": 509,
      "index": 205,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.Combinators.S-Env-ProofState-SimplSet",
      "library": "libzipperposition",
      "description": "This module manages a dynamic set of clauses with operations to add or remove clauses and notify subscribers of changes. It works with clause data types and uses iterators for batch modifications. It is used in theorem proving contexts to maintain and update clause sets during proof search.",
      "description_length": 291,
      "index": 206,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.StreamQueue_intf.S-Stm-C-Eligible",
      "library": "libzipperposition",
      "description": "This module defines eligibility criteria for selecting literals in clauses based on logical operations. It provides functions to filter literals by resolution, paramodulation, positivity, negativity, maximality, and equation status, along with logical combinators to compose these criteria. These operations are used to control inference rules in automated theorem proving, such as restricting resolution to specific literals or combining multiple selection conditions.",
      "description_length": 469,
      "index": 207,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.AC_intf.S-Env-C-ClauseSet",
      "library": "libzipperposition",
      "description": "This module supports functional manipulation of ordered clause collections, offering operations like union, intersection, difference, and ordered traversal via minimum/maximum element access. It works with immutable sets of clauses (`Env.C.ClauseSet.t`) ordered by a comparator (`Ord`), providing safe and unsafe variants for element selection, filtering, and conversion to lists or sequences. Designed for logical reasoning systems, it facilitates tasks like clause prioritization, iterative processing, and structured input/output in theorem-proving contexts.",
      "description_length": 561,
      "index": 208,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.ProofState_intf.S-Ctx",
      "library": "libzipperposition",
      "description": "This module supports operations for configuring logical contexts, such as defining term orderings, selection functions, and skolemization scopes, while enabling dynamic manipulation of term signatures and symbol declarations. It works with logical terms, literals (including atoms and their negations), and symbol metadata to facilitate term analysis and logical inference steps. Key use cases include proof search in theorem proving systems, where injectivity checks for function symbols or tracking symbol modifications guide resolution and rewriting rules.",
      "description_length": 559,
      "index": 209,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Eprover_interface.S-Env-ProofState-CQueue",
      "library": "libzipperposition",
      "description": "This module supports managing a priority queue of clauses with operations for insertion, retrieval using strategies like FIFO or heuristic-based selection, and configuration via customizable weight and priority functions. It operates on `Env.ProofState.CQueue.t` queues and `Env.ProofState.CQueue.C.t` clauses, enabling tasks like membership checks, removal, and string representation conversion. Designed for automated theorem proving, it facilitates proof state management by prioritizing clauses according to roles (e.g., goal-oriented) or dynamic heuristics during deduction processes.",
      "description_length": 589,
      "index": 210,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.ProofState_intf.S-UnitIndex",
      "library": "libzipperposition",
      "description": "This module implements an index for efficiently storing, retrieving, and manipulating sets of (in)equations, represented as terms with associated substitutions. It supports operations like adding or removing equations, querying for matches or generalizations of a given term under substitutions, and iterating over stored equations. Use cases include automated theorem proving tasks such as clause indexing, rewriting, and subsumption checking.",
      "description_length": 444,
      "index": 211,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Combinators.S-Env-ProofState-UnitIndex",
      "library": "libzipperposition",
      "description": "This module implements an index for managing and querying a collection of (in)equations within a proof state, supporting operations like adding, removing, and retrieving terms with substitutions. It works with terms and substitutions from the `Logtk.Index_intf` module and maintains an internal structure for efficient lookups. Use cases include indexing logical expressions for fast retrieval during theorem proving and generating DOT visualizations of the index structure.",
      "description_length": 474,
      "index": 212,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.Combinators.S-C-Seq",
      "library": "libzipperposition",
      "description": "This module provides functions to extract literals, terms, and variables from clauses. It works with clause (`C.t`) and sequent (`S.t`) data structures, along with term and literal types from the Logtk library. Concrete use cases include analyzing clause content during theorem proving or extracting components for further processing in proof search.",
      "description_length": 350,
      "index": 213,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Lift_lambdas.S-Env-ProofState-SubsumptionIndex-C",
      "library": "libzipperposition",
      "description": "This module defines operations for comparing clauses, extracting literals, and retrieving label subsets from clauses. It works with clause data structures from the subsumption index, providing direct access to their logical components and metadata. Concrete use cases include subsumption checking, literal iteration for indexing, and label-based filtering in proof state management.",
      "description_length": 382,
      "index": 214,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.ProofState_intf.S-C-Pos",
      "library": "libzipperposition",
      "description": "Retrieves a subterm at a specified position within a given term. Works with terms and positions, enabling precise navigation and manipulation of term structures. Useful for inspecting or transforming specific parts of terms during proof construction or term rewriting.",
      "description_length": 268,
      "index": 215,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.Eprover_interface.S-Env-ProofState-TermIndex",
      "library": "libzipperposition",
      "description": "This module provides term indexing structures with operations for efficient insertion, deletion, and retrieval of terms, alongside advanced logic operations like unification, generalization, and specialization. It works with terms conforming to `Logtk.Index_intf` paired with `C.WithPos.t` elements, leveraging scoped terms and substitutions to manage contextual dependencies. These capabilities are particularly useful in theorem proving workflows, where the `to_dot` function enables visualizing term index states for debugging or analysis.",
      "description_length": 542,
      "index": 216,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Eprover_interface.S-Env-C-Tbl",
      "library": "libzipperposition",
      "description": "This module offers imperative hash table operations for mappings between environment keys (`Env.C.t`) and polymorphic values, emphasizing safe value manipulation through functions like `get_or`, `incr`, and `replace`, alongside bulk transformations (`fold`, `filter_map_inplace`). It supports sequence conversions with customizable merge strategies and provides utilities for key-based aggregation, counting, and conditional updates, such as combining duplicate entries or tracking key occurrences from iterators. The module is suited for scenarios requiring efficient, environment-aware data structuring, such as managing symbolic mappings in theorem proving contexts or aggregating dynamic key-value streams with domain-specific merging rules.",
      "description_length": 745,
      "index": 217,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Lift_lambdas.S-C-WithPos",
      "library": "libzipperposition",
      "description": "This module represents clauses with a specific subterm and its position, enabling precise term manipulation and analysis. It provides comparison and pretty-printing operations for these structured clauses. Useful for tasks like term rewriting, proof tracing, or focused clause transformations where positional context is critical.",
      "description_length": 330,
      "index": 218,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.Ctx_intf.S",
      "library": "libzipperposition",
      "description": "This module manages logical term and symbol contexts, enabling operations like term ordering configuration, skolemization, and symbol type declaration while ensuring injectivity checks for identifiers in argument positions. It works with terms, logical literals, and signatures to support formal verification tasks such as clause normalization, proof search, and logical reasoning in automated deduction systems. The `Lit` module specifically facilitates literal comparison, hashing, and traversal, which are critical for manipulating logical formulas during theorem proving.",
      "description_length": 575,
      "index": 219,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Eprover_interface.S-Env-C-Seq",
      "library": "libzipperposition",
      "description": "This module provides functions to extract literals, terms, and variables from a clause environment. It operates on data structures representing logical clauses, terms, and typed variables. Use cases include analyzing or transforming logical expressions during automated theorem proving.",
      "description_length": 286,
      "index": 220,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.AC_intf.S-C-ClauseSet",
      "library": "libzipperposition",
      "description": "This module offers operations for managing ordered collections of clauses, supporting standard set manipulations like union, intersection, and difference, alongside ordered traversal, filtering, and element selection (e.g., min/max extraction). It works with `C.ClauseSet.t` structures, enforcing strict ordering via `Ord.compare` to enable efficient membership checks, transformations, and safe element access through predicates or positional queries. Designed for formal verification or automated reasoning workflows, it facilitates tasks like clause set normalization, proof search pruning, and structured output generation in theorem proving systems.",
      "description_length": 654,
      "index": 221,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Env_intf.S-ProofState-CQueue-PriorityFun",
      "library": "libzipperposition",
      "description": "This module defines a priority function type for weighting proof state queues, mapping queue elements to integer priorities. It includes a function to parse string descriptions into these priority functions. Use cases include configuring heuristic-based prioritization of proof goals in automated theorem proving.",
      "description_length": 313,
      "index": 222,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Stream.ARG-C-Tbl",
      "library": "libzipperposition",
      "description": "This module provides imperative hash table operations for key-value bindings with keys of type `C.t` and polymorphic values, supporting safe retrieval, bulk updates from sequences/iterators, atomic increments/decrements, and transformations between tables and collections. It includes utilities for counting elements from streams, aggregating statistics, and formatting tables for debugging, with applications in frequency tracking, data processing pipelines, and structured output generation. The",
      "description_length": 497,
      "index": 223,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.AC_intf.S-Env-ProofState-ActiveSet",
      "library": "libzipperposition",
      "description": "This module manages a dynamic set of clauses with support for adding, removing, and querying clauses. It provides signals to monitor changes in the clause set and maintains the current state as a clause set data structure. It is used to track active clauses during theorem proving, enabling reaction to clause additions and removals.",
      "description_length": 333,
      "index": 224,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.Combinators.S-Env-ProofState-module-type-CLAUSE_SET",
      "library": "libzipperposition",
      "description": "This module manages a dynamic set of clauses with operations to add or remove clauses and subscribe to events when clauses are added or removed. It works with clause sets and provides signals to react to modifications. Useful for tracking changes in clause sets during theorem proving or constraint solving.",
      "description_length": 307,
      "index": 225,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.Saturate.S-Env-C-WithPos",
      "library": "libzipperposition",
      "description": "This module represents clauses with a specific subterm and its position, enabling precise term manipulation and analysis. It provides comparison and pretty-printing operations for these structured clauses. Useful for tasks like subterm indexing, rewriting, or focused proof search where positional context is critical.",
      "description_length": 318,
      "index": 226,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.FormulaRename.S-C",
      "library": "libzipperposition",
      "description": "This module provides operations for managing clause metadata (e.g., redundancy, simplification status, goal derivation), analyzing clause properties (emptiness, unit status, literal eligibility), and transforming clauses through substitutions, grounding, or proof manipulation. It operates on clauses (`C.t`), trails (`Trail.t`), substitutions, and structured representations like clause sets and positions, with support for inference rule eligibility checks and TSTP-compatible output. Key use cases include automated theorem proving tasks such as redundancy elimination, resolution/paramodulation inference preparation, and proof trace generation.",
      "description_length": 649,
      "index": 227,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Lift_lambdas.S-Env-C-Tbl",
      "library": "libzipperposition",
      "description": "This module offers hash table manipulation operations for key-value pairs with keys of type `Env.C.t`, supporting in-place updates, safe lookups, bulk additions, and customizable merging strategies. It operates on `Env.C.Tbl.t` tables, enabling conversions to and from sequences, iterators, and lists, while emphasizing aggregation, key-value transformation, and iteration over both keys and values. Specific use cases include managing dynamic environments with efficient key-based access, merging tables with conflict resolution, and processing large datasets through iterative transformations.",
      "description_length": 595,
      "index": 228,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.Eprover_interface.S-Env-StmQ",
      "library": "libzipperposition",
      "description": "This module implements a priority queue for managing streams of clauses with weighted priorities. It provides operations to add streams or lists of streams, inspect queue state, and extract clauses either fairly or prioritizing available streams. Use cases include scheduling clause processing in automated theorem proving where streams represent different sources of clauses and priority weights influence proof search strategy.",
      "description_length": 429,
      "index": 229,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.AC_intf.S-Env-Ctx-Lit",
      "library": "libzipperposition",
      "description": "This module manages bidirectional conversions between literals and formulas using customizable hooks. It provides functions to register and retrieve conversion hooks for transforming literals to formulas and vice versa, as well as direct conversion functions that apply these hooks. It works with `Logtk.Literal.t` and `Logtk.SLiteral.t` types, supporting use cases like integrating custom literal representations into theorem proving pipelines or translating between internal and external logic encodings.",
      "description_length": 506,
      "index": 230,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.Saturate.S-Env-C-ClauseSet",
      "library": "libzipperposition",
      "description": "This module offers a purely functional API for ordered sets of clauses, supporting creation, membership checks, modification via insertion/deletion, and set-theoretic operations like union and intersection, alongside higher-order functions for mapping, folding, and filtering. It operates on `Env.C.ClauseSet.t` structures, which maintain elements in an order defined by a comparison function, and includes utilities for safe traversal, extremal element access, and conversions to lists or sequences. Designed for theorem proving workflows, it facilitates tasks like saturation-based clause processing, where ordered set manipulation and efficient predicate-driven searches are critical.",
      "description_length": 687,
      "index": 231,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Bool_lit.PAYLOAD",
      "library": "libzipperposition",
      "description": "The module defines a type `t` representing boolean literals with an associated payload and provides a single value `dummy` as a placeholder for default or uninitialized payloads. It is used to handle truth values paired with additional data in logical operations or term representations. This supports scenarios like encoding propositions with metadata or managing boolean expressions in theorem proving.",
      "description_length": 404,
      "index": 232,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.FormulaRename.S-Ctx",
      "library": "libzipperposition",
      "description": "This module facilitates operations for managing logical contexts in theorem proving, such as configuring term orderings, selection functions, and skolemization, while providing tools to manipulate and query symbol signatures, compare terms, and handle renaming. It works with logical terms, literals, and function symbols, including checks for argument-specific injectivity, and supports tasks like symbol declaration and type resolution. These capabilities are critical in formal verification workflows where dynamic context updates and term analysis drive proof automation.",
      "description_length": 575,
      "index": 233,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Saturate.S-Env-ProofState-TermIndex-Leaf",
      "library": "libzipperposition",
      "description": "This module implements a term index structure for efficient retrieval of terms during proof search, supporting operations like adding, removing, and updating indexed terms. It works with logical terms and their associated proof state elements, enabling unification and matching queries with substitutions. Concrete use cases include accelerating clause subsumption checks and managing term-level proof data in automated theorem proving.",
      "description_length": 436,
      "index": 234,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Eprover_interface.S-Env-Stm-Ctx-Lit",
      "library": "libzipperposition",
      "description": "This module manages bidirectional conversions between literals and their atomic formula representations using customizable hooks. It provides functions to register and retrieve conversion hooks for transforming literals to and from terms, supporting dynamic extensions to the conversion process. The primary use case involves enabling flexible parsing and pretty-printing of logical formulas in theorem proving systems.",
      "description_length": 419,
      "index": 235,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.AC_intf.S-C-Seq",
      "library": "libzipperposition",
      "description": "This module provides functions to extract literals, terms, and variables from a clause structure. It works with clauses (`C.t`), literals (`Logtk.Literal.t`), terms (`Logtk.Term.t`), and typed variables (`Logtk.Type.t Logtk.HVar.t`). Use it to analyze or transform first-order logic clauses by inspecting their constituent elements.",
      "description_length": 332,
      "index": 236,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Lift_lambdas.S-Env-Stm-Ctx-Lit",
      "library": "libzipperposition",
      "description": "This module manages bidirectional conversions between literals and formulas using customizable hooks. It provides functions to register and retrieve conversion hooks, as well as to perform the actual conversions between `Logtk.Literal.t` and `Logtk.Term.t Logtk.SLiteral.t`. It is used to integrate lambda-aware literal handling within theorem proving or term processing pipelines, particularly when translating between different internal representations.",
      "description_length": 455,
      "index": 237,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Stream.ARG",
      "library": "libzipperposition",
      "description": "This module implements stream-based processing for term rewriting and equational reasoning tasks. It provides operations for managing streams of terms, including filtering, mapping, and combining streams based on rewrite rules and constraints. It works with term structures and contexts to support concrete use cases like normalization, matching, and rule application in automated reasoning systems.",
      "description_length": 399,
      "index": 238,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.AC_intf.S-Env-ProofState",
      "library": "libzipperposition",
      "description": "This module manages the proof state in a theorem prover, providing clause sets for active, simplified, and passive clauses, along with priority queues for clause selection. It includes term and unit indexing structures for efficient retrieval and subsumption checks, and tracks proof statistics. Use cases include organizing clauses during saturation-based reasoning and accelerating inference operations through indexed lookups.",
      "description_length": 429,
      "index": 239,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Stream.ARG-Ctx-Lit",
      "library": "libzipperposition",
      "description": "This module manages bidirectional conversions between literals and formulas using hooks. It provides functions to register and retrieve conversion hooks for transforming literals to and from terms. The module works directly with `Logtk.Literal.t` and `Logtk.SLiteral.t` types, supporting use cases like integrating custom literal representations in theorem proving or term rewriting systems.",
      "description_length": 391,
      "index": 240,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.Lift_lambdas.S-Env-ProofState-CQueue-C",
      "library": "libzipperposition",
      "description": "This module provides functions to inspect and modify clause metadata such as redundancy, simplification status, and proof properties, alongside utilities for constructing clauses with trails and managing proof steps. It supports structural analysis of clauses (e.g., emptiness checks, literal selection) and transformations like normalization, grounding, and TSTP-formatted output, operating on data structures like `CQueue.C.t` and `ClauseSet.t`. These operations are critical for automated theorem proving tasks, including proof state management, clause derivation, and symbolic reasoning workflows.",
      "description_length": 601,
      "index": 241,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.AC_intf.S-Env-C",
      "library": "libzipperposition",
      "description": "This module provides operations for manipulating clauses, trails, and proofs in automated reasoning tasks, including flag management, redundancy checks, eligibility analysis for resolution/paramodulation, and substitution application. It operates on clauses (`Env.C.t`), trails (`Trail.t`), substitutions (`Logtk.Subst.t`), and bitvectors (`CCBV.t`), supporting transformations like grounding, proof extraction, and format conversion (e.g., TSTP). Specific use cases include goal detection, literal selection for term rewriting, and debugging via structured printing or metadata tracking like penalty scores.",
      "description_length": 608,
      "index": 242,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.FormulaRename.S-Ctx-Lit",
      "library": "libzipperposition",
      "description": "This module manages bidirectional conversions between literals and formulas using customizable hooks. It provides operations to register and retrieve conversion hooks for transforming literals to formulas and vice versa, as well as direct conversion functions that enforce atomic formula constraints. It works with `Logtk.Literal.t` and `Logtk.SLiteral.t` types, supporting use cases like integrating custom literal representations into theorem proving pipelines or translating between internal and external formula formats.",
      "description_length": 524,
      "index": 243,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Combinators.S-Env-C-WithPos",
      "library": "libzipperposition",
      "description": "This module represents clauses with a focused subterm and its position, enabling precise manipulation of terms within clauses. It provides comparison and pretty-printing operations for these structured clauses. Useful for implementing rewriting or inference rules that require tracking specific subterm locations within logical expressions.",
      "description_length": 340,
      "index": 244,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Env_intf.S-Stm-Ctx",
      "library": "libzipperposition",
      "description": "This module facilitates logical context management and signature manipulation in theorem proving systems, offering operations to configure term orderings, selection functions, and skolemization contexts. It works with terms, types, symbols (IDs), and logical literals, enabling tasks like injectivity checks for function arguments and literal-level transformations in constraint solving or unification workflows. Key use cases include maintaining context-sensitive term comparisons, managing symbol declarations during proof search, and supporting logical literal manipulations in automated reasoning pipelines.",
      "description_length": 611,
      "index": 245,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Cut_form.Seq",
      "library": "libzipperposition",
      "description": "Extracts terms from cut forms, either as a sequence of terms or with their positions. Works with `Cut_form.t` and `Cut_form.term` types. Useful for analyzing or transforming logical formulas by accessing embedded terms and their locations.",
      "description_length": 239,
      "index": 246,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.ClauseQueue_intf.S-C-Seq",
      "library": "libzipperposition",
      "description": "This module provides operations to extract literals, terms, and variables from clauses. It works with clause data structures (`C.t`) and iterates over literals, terms, and typed variables. Useful for analyzing or transforming logical clauses during theorem proving or formula manipulation tasks.",
      "description_length": 295,
      "index": 247,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.FormulaRename.S-C-Eligible",
      "library": "libzipperposition",
      "description": "This module defines a set of functions for determining which literals in a clause are eligible for specific inference rules during automated theorem proving. It operates on clauses and literals, providing criteria to select literals based on their role in resolution, paramodulation, positivity, negativity, or equation status. Use cases include filtering literals for resolution steps, selecting maximal or positive equations for paramodulation, and combining eligibility conditions using logical operators.",
      "description_length": 508,
      "index": 248,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Saturate.S-Env-Stm-Ctx-Lit",
      "library": "libzipperposition",
      "description": "This module manages bidirectional conversions between literals and their atomic formula representations using customizable hooks. It provides functions to register and retrieve conversion hooks for transforming literals to and from terms, supporting dynamic extensions to the conversion process. The primary use case involves enabling flexible parsing and pretty-printing of logical formulas in theorem proving systems.",
      "description_length": 419,
      "index": 249,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Lift_lambdas.S-Env-C-Pos",
      "library": "libzipperposition",
      "description": "This module provides a single operation, `at`, which retrieves a term from a context at a specified position. It works with environments (`Env.C.t`), positions (`Logtk.Position.t`), and terms (`Logtk.Term.t`). A concrete use case is extracting subterms during proof search or term traversal in automated theorem proving.",
      "description_length": 320,
      "index": 250,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.StreamQueue_intf.S-Stm-C-Seq",
      "library": "libzipperposition",
      "description": "This module processes clauses to extract literals, terms, or variables as iterated sequences. It operates on clause data structures from the `Stm.C` module and produces iterations of literals, terms, or typed variables. Useful for analyzing or transforming logical expressions in automated theorem proving tasks.",
      "description_length": 312,
      "index": 251,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.Saturate.S-Env-ProofState-UnitIndex",
      "library": "libzipperposition",
      "description": "This module implements an index for managing and querying logical (in)equations within a proof state, supporting operations like adding, removing, and retrieving terms with substitution constraints. It works with terms and substitutions from a scoped environment, enabling efficient lookups for generalization queries during theorem proving. Use cases include indexing clauses for resolution or paramodulation steps in automated reasoning systems.",
      "description_length": 447,
      "index": 252,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.AC_intf.S-Env-ProofState-SimplSet",
      "library": "libzipperposition",
      "description": "This module manages a dynamic set of clauses with operations to add or remove clauses and notify subscribers when changes occur. It provides signals for clause addition and removal, along with functions to bulk modify the set using iterators. It is used in theorem proving contexts to track and react to changes in a set of logical clauses.",
      "description_length": 340,
      "index": 253,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.ProofState_intf.S-CQueue-C",
      "library": "libzipperposition",
      "description": "This module provides operations for managing and analyzing logical clauses in automated reasoning systems, focusing on flag manipulation, redundancy checks, and simplification status tracking. It works with clauses (`CQueue.C.t`), proof trails (`Trail.t`), and logical representations like `SClause.t` and `SLiteral.t`, supporting tasks such as literal selection, eligibility checks for resolution, and proof step transformations. Key use cases include clause queue management, theorem proving with dynamic clause instantiation, and symbolic analysis for automated deduction.",
      "description_length": 575,
      "index": 254,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Lift_lambdas.S-Env-ProofState-CQueue-PriorityFun",
      "library": "libzipperposition",
      "description": "This module defines a priority function type for weighting elements in a proof state queue, based on an environment and proof state context. It includes a function to parse string descriptions into concrete priority functions that map queue elements to integer weights. This is used to dynamically configure prioritization strategies in automated theorem proving processes.",
      "description_length": 373,
      "index": 255,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.Saturate.S-Env-ProofState-CQueue-PriorityFun",
      "library": "libzipperposition",
      "description": "This module defines a priority function type for weighting elements in a clause queue during saturation-based theorem proving. It includes a function to parse string descriptions into concrete priority functions that map clause queues to integer weights. It is used to control the order in which clauses are processed in automated reasoning systems.",
      "description_length": 349,
      "index": 256,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Combinators.S-Env",
      "library": "libzipperposition",
      "description": "This module provides operations for clause management, inference rule application, and proof state manipulation in saturation-based theorem proving. It works with clauses, literals, terms, and proof states organized into active/passive sets, alongside statement queues and flexible state stores for dynamic configuration. Key use cases include redundancy elimination, tautology detection, term rewriting, prioritized clause generation, and trail analysis for automated reasoning systems.",
      "description_length": 487,
      "index": 257,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Eprover_interface.S-Env",
      "library": "libzipperposition",
      "description": "This module orchestrates clause manipulation, simplification, and inference rule management in automated theorem proving workflows. It operates on clauses, clause sets, inference streams, and proof states, enabling tasks like redundancy checking, term rewriting, and iterative proof state transformation through registered rules. Key use cases include contradiction detection via empty clause checks, priority-driven proof search control, and integration of input statements with dynamic signal handling.",
      "description_length": 504,
      "index": 258,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.Env_intf.S-StmQ-WeightFun",
      "library": "libzipperposition",
      "description": "This module defines weight functions that assign integer weights to streams of statements. It includes operations to compute the penalty of a stream and to combine multiple weight functions using weighted sums with positive coefficients. These functions are used to prioritize or evaluate the relevance of logical statements in automated reasoning tasks.",
      "description_length": 354,
      "index": 259,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.AC_intf.S-Env-Ctx",
      "library": "libzipperposition",
      "description": "This module provides operations to manage logical context and state in theorem proving and term rewriting systems, including term orderings, symbol declarations, signature management, and injectivity checks for term manipulation. It works with terms, literal atoms, and symbolic data structures, utilizing signals to track state changes and enforce completeness preservation. These capabilities support unification strategies and abstract interpretation frameworks in formal verification tasks.",
      "description_length": 494,
      "index": 260,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Eprover_interface.Make",
      "library": "libzipperposition",
      "description": "Implements an interface for integrating the E theorem prover within a larger system, enabling direct interaction through specific functions. It provides operations to set the E prover binary path, attempt to solve goals using E, and register necessary environment rules for execution. Designed for use in automated reasoning pipelines where concrete goal solving and tactic application are required.",
      "description_length": 399,
      "index": 261,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Lift_lambdas.S-Env-Stm",
      "library": "libzipperposition",
      "description": "This module manages streams of clauses with associated metadata, supporting operations to create, compare, and manipulate streams based on their content and provenance. It works with streams of optional clauses (`C.t option OSeq.t`), tracking unique identifiers, parent clauses, and heuristic penalties. Concrete use cases include retrieving clause unifiers, penalizing streams based on usage metrics, and incrementally consuming clause sequences during theorem proving.",
      "description_length": 470,
      "index": 262,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.AC_intf.S-Env-ProofState-CQueue-WeightFun",
      "library": "libzipperposition",
      "description": "This module defines weight functions that calculate integer weights for clauses in a proof state's priority queue. It supports operations like parsing weight function descriptions, combining multiple weight functions with coefficients, and applying heuristic-based penalties or preferences based on clause properties such as negation, grounding, or proximity to the goal. Use cases include guiding clause selection in automated theorem proving by prioritizing relevant or structurally favorable clauses.",
      "description_length": 503,
      "index": 263,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.AC_intf.S-Env-ProofState-SubsumptionIndex",
      "library": "libzipperposition",
      "description": "This module implements a subsumption index for managing and querying clauses in a proof state. It supports operations to add, remove, and retrieve clauses based on subsumption and alpha-equivalence relationships, using literals and labels as keys. Use cases include efficient clause indexing and retrieval during automated theorem proving, particularly for subsumption checking and clause simplification.",
      "description_length": 404,
      "index": 264,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Eprover_interface.S-Env-Ctx-Lit",
      "library": "libzipperposition",
      "description": "This module manages bidirectional conversion hooks between different literal representations, specifically between `Logtk.Literal.t` and `Logtk.Term.t Logtk.SLiteral.t`. It provides functions to register and retrieve conversion hooks, as well as to perform conversions that are required when translating logical formulas to a format suitable for automated provers. Use cases include integrating custom literal transformations and ensuring compatibility between internal term representations and external prover interfaces.",
      "description_length": 522,
      "index": 265,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Eprover_interface.S-Env-ProofState-PassiveSet",
      "library": "libzipperposition",
      "description": "This module manages a set of passive clauses in a theorem proving context, providing operations to add, remove, and query clauses. It supports data types such as `C.t` for clauses, `C.ClauseSet.t` for the set representation, and `Env.ProofState.CQueue.t` for the clause queue. Concrete use cases include tracking passive clauses during proof search, signaling clause additions and removals, and retrieving the next clause to process in a saturation-based prover.",
      "description_length": 462,
      "index": 266,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Eprover_interface.S-Env-ProofState-CQueue-C",
      "library": "libzipperposition",
      "description": "This module enables manipulation of clause properties such as redundancy, simplification status, and metadata (e.g., ID, weight), alongside structural analysis of literals for inference eligibility (e.g., resolution, paramodulation) and transformations like substitution or grounding. It operates on clauses, trails, proof steps, and substitutions, supporting automated theorem proving workflows that require proof state inspection, logical structure conversion, and debugging output in TSTP/CNF formats. Key applications include managing clause evolution during proving, tracking literal maximality or selection, and formatting proof traces for external tools.",
      "description_length": 661,
      "index": 267,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Env_intf.S-C-Seq",
      "library": "libzipperposition",
      "description": "This module provides functions to extract literals, terms, and variables from clauses. It works with clause (`C.t`) and logic term (`Logtk.Term.t`, `Logtk.Literal.t`, `Logtk.HVar.t`) data types. Use it to analyze or transform logical expressions in proof search or theorem proving tasks.",
      "description_length": 287,
      "index": 268,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Eprover_interface.S-Env-C",
      "library": "libzipperposition",
      "description": "The module provides operations for managing clause metadata (e.g., redundancy, eligibility, and goal status), transforming clauses via substitutions and logical simplifications, and analyzing properties like literal maximality or proof dependencies in automated reasoning systems. It works with clauses, trails, proof steps, substitutions, and clause sets, leveraging bitvectors and position-based structures for efficient manipulation. These tools are used for tasks such as inference rule application, redundancy elimination, and generating standardized clause representations for debugging or proof output.",
      "description_length": 609,
      "index": 269,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Lift_lambdas.S-Env-ProofState-UnitIndex",
      "library": "libzipperposition",
      "description": "This module implements a term index for efficiently storing, querying, and retrieving logical (in)equations during proof search. It supports operations like adding or removing equations, checking emptiness, iterating over indexed terms, and pattern-based retrieval with substitutions. The index is used to find generalizations of terms during theorem proving, enabling efficient clause subsumption and rewriting steps.",
      "description_length": 418,
      "index": 270,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.ClauseQueue_intf.S-C-ClauseSet",
      "library": "libzipperposition",
      "description": "This module implements ordered sets of clauses with operations for transformation, filtering, and ordered traversal, leveraging a total ordering to manage element relationships. It works with sets of `C.t` values, structured as `C.ClauseSet.t`, and supports conversions to sequences, lists, and iterative formats while preserving ordering invariants. Designed for scenarios requiring prioritized clause processing\u2014such as theorem proving pipelines\u2014it enables efficient queries (e.g., finding minimal/maximal elements), conditional transformations, and safe optional lookups tailored to ordered clause sets.",
      "description_length": 606,
      "index": 271,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.Eprover_interface.S-Env-FormRename-Ctx",
      "library": "libzipperposition",
      "description": "This module provides operations for logical context management, including skolemization, term ordering, symbol declaration, and signature manipulation, working with terms, types, and symbols from the Logtk library. The Lit module supports handling logical literals for atomic propositions or clauses, enabling use cases like term rewriting, simplification, and injectivity checks in theorem proving workflows.",
      "description_length": 409,
      "index": 272,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.Combinators.S-Env-Stm",
      "library": "libzipperposition",
      "description": "This module manages streams of clauses with dynamic penalties and hit counters, primarily used in heuristic-driven theorem proving. It supports operations like creating streams, comparing and hashing them, and extracting elements incrementally with `drip` or in batches with `drip_n`. Concrete use cases include tracking and prioritizing clauses during inference in automated reasoning systems.",
      "description_length": 394,
      "index": 273,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.Env_intf.S-FormRename",
      "library": "libzipperposition",
      "description": "This module handles formula renaming and Skolemization during proof search. It provides operations to rename clauses, detect renaming clauses, and introduce predicate Skolems, working with clauses (`C.t`) and formula renaming contexts (`FormulaRename.T.t`). Concrete use cases include managing formula definitions during CNF conversion and handling Skolem symbol introduction with configurable freshness strategies.",
      "description_length": 415,
      "index": 274,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Stream_intf.S-Ctx-Lit",
      "library": "libzipperposition",
      "description": "This module manages bidirectional conversions between literals and formulas using hooks for customization. It provides functions to register and retrieve conversion hooks, as well as to perform the actual conversions. It works with literals and atomic formulas, enabling use cases like parsing input formulas into internal literal representations or serializing literals back into formulas for output.",
      "description_length": 401,
      "index": 275,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Bool_lit.Make",
      "library": "libzipperposition",
      "description": "This module represents boolean literals with payloads, supporting negation, sign manipulation, and normalization, along with comparison, hashing, and formatting operations. Its set submodule provides ordered set functionality with union, intersection, and traversal, enabling efficient management of finite ordered collections and transformations over sequences and lists. The hash table submodule allows polymorphic value storage keyed by these literals, supporting insertion, lookup, and aggregation operations useful for data processing and statistical analysis. Together, these components enable symbolic computation, theorem proving, and structured key-value workflows with efficient querying and transformation.",
      "description_length": 717,
      "index": 276,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.Saturate.S-Env-StmQ",
      "library": "libzipperposition",
      "description": "This module implements a priority queue for managing streams of clauses with weighted priorities. It supports operations to add streams or lists of streams, retrieve clauses based on priority, and control fairness and recursion depth during extraction. Use cases include scheduling clause processing in automated theorem proving where prioritization and bounded resource usage are critical.",
      "description_length": 390,
      "index": 277,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Sat_solver.Make",
      "library": "libzipperposition",
      "description": "This module implements a SAT solver that supports adding clauses, checking satisfiability, and extracting valuations, proofs, and decision levels for literals. It works with clauses represented as lists of literals (`Lit.t`), and maintains internal state for solving, including proof tracking and model generation. Concrete use cases include validating logical formulas, generating counterexamples, and supporting proof-producing reasoning in automated theorem proving.",
      "description_length": 469,
      "index": 278,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Eprover_interface.S-Env-ProofState-SimplSet",
      "library": "libzipperposition",
      "description": "This module manages a dynamic set of clauses with operations to add or remove clauses and notify subscribers of changes. It uses iterators to process batches of clauses and signals to communicate modifications. It is useful for maintaining and updating clause sets during theorem proving processes where incremental changes and observers are needed.",
      "description_length": 349,
      "index": 279,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Combinators.S-Env-FormRename-Ctx",
      "library": "libzipperposition",
      "description": "This module provides operations for managing logical contexts, including skolemization, term ordering, selection functions, and signature manipulation, while maintaining context state to ensure logical completeness. It operates on terms, types, and symbols from the Logtk and Libzipperposition libraries, emphasizing term comparison, symbol declaration, and equality reasoning. These capabilities are applied in theorem proving and logic manipulation, particularly for handling literals and verifying injectivity of function symbols at specific argument positions.",
      "description_length": 564,
      "index": 280,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.Combinators.S-Env-Ctx",
      "library": "libzipperposition",
      "description": "This module offers operations to manage logical environments for theorem proving, focusing on term comparison, symbol declaration, and context updates like ordering or skolemization. It works with terms, types, symbols, and literals, enabling dynamic adjustments to logical signatures and injectivity checks for function symbols. It supports use cases requiring precise control over proof search contexts, such as automated reasoning systems needing term-level analysis and environment consistency.",
      "description_length": 498,
      "index": 281,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.AC_intf.S-Env-C-Pos",
      "library": "libzipperposition",
      "description": "This module provides a function `at` that retrieves a term from a given position in an environment. It operates on environments of type `Env.C.t` and positions of type `Logtk.Position.t`, returning terms of type `Logtk.Term.t`. A concrete use case is querying specific subterms during theorem proving or term rewriting tasks.",
      "description_length": 325,
      "index": 282,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Libzipperposition.Env_intf.S-ProofState-TermIndex-Leaf",
      "library": "libzipperposition",
      "description": "This module implements a term index structure that supports efficient insertion, removal, and querying of elements based on logical terms. It provides operations for unification and matching between indexed terms and query terms, returning sequences of matches along with substitution data. It is used in theorem proving contexts to retrieve candidate terms that can be unified or matched with a given term.",
      "description_length": 407,
      "index": 283,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.StreamQueue.ARG-Stm-C-Seq",
      "library": "libzipperposition",
      "description": "This module provides functions to extract literals, terms, and variables from clauses using stream-based processing. It operates on clause data structures and returns iterators over literals, terms, or typed variables contained within a clause. Useful for analyzing or transforming logical expressions in automated reasoning tasks.",
      "description_length": 331,
      "index": 284,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Cover_set.Case",
      "library": "libzipperposition",
      "description": "This module represents inductive cases in a coverset, starting with a constructor of their type. It provides operations to compare, hash, and print cases, as well as access their associated terms, literals, and constants. Use cases include analyzing inductive structures, checking recursion status, and extracting sub-constants or skolem variables from specific cases.",
      "description_length": 368,
      "index": 285,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Combinators.S-Env-C-Tbl",
      "library": "libzipperposition",
      "description": "This module implements imperative hash tables with keys of type `Env.C.t`, supporting efficient insertion, deletion, lookup, and in-place updates using standard combinators like `replace_seq`, `incr`, and `decr`. It provides safe value retrieval via `find_opt` and `get_or`, aggregation operations for counting or list accumulation, and conversions between tables, sequences, and iterators with customizable merge strategies for duplicate keys. Typical use cases include managing dynamic key-value mappings with atomic updates, aggregating data from iterative processes, and handling sparse or evolving datasets requiring efficient lookups and modifications.",
      "description_length": 658,
      "index": 286,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.ProofState_intf.S-C-Ctx-Lit",
      "library": "libzipperposition",
      "description": "This module manages bidirectional conversions between literals and formulas using customizable hooks. It provides functions to register and retrieve conversion hooks for transforming literals to formulas and vice versa, as well as direct conversion operations that enforce atomic formula constraints. It works with `Logtk.Literal.t` and `Logtk.Term.t Logtk.SLiteral.t` types, supporting use cases like integrating custom literal representations into theorem proving pipelines or translating between internal and external logic encodings.",
      "description_length": 537,
      "index": 287,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.Saturate.S-Env-StmQ-WeightFun",
      "library": "libzipperposition",
      "description": "This module defines weight functions that assign integer weights to streams of statements. It provides operations to retrieve a stream's penalty and combine multiple weight functions using weighted sums. These functions are used to prioritize or evaluate the importance of different statement streams in a formal verification or theorem proving context.",
      "description_length": 353,
      "index": 288,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.Eprover_interface.S-Env-Ctx",
      "library": "libzipperposition",
      "description": "This module manages logical context operations such as term ordering configuration, skolemization state tracking, and selection function management, while providing tools for signature manipulation, symbol declaration, and term comparison. It works with logical literals (via the Lit module), term structures, and symbol tables to support tasks like injectivity analysis for rewriting and inference. These capabilities are used in theorem proving workflows to maintain consistent logical state, optimize term representations, and drive automated reasoning steps.",
      "description_length": 562,
      "index": 289,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Eprover_interface.S-Env-C-Pos",
      "library": "libzipperposition",
      "description": "Retrieves a term from a given position in an environment. Works with environments (`Env.C.t`) and logical terms (`Logtk.Term.t`). Useful for inspecting specific parts of a term during proof search or term traversal.",
      "description_length": 215,
      "index": 290,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Eprover_interface.S-Env-ProofState-CQueue-PriorityFun",
      "library": "libzipperposition",
      "description": "This module defines a priority function type for weighting proof states in a queue, using an integer-based ranking. It includes a function to parse string descriptions into these priority functions, enabling customizable prioritization strategies. Concrete use cases include controlling the order of clause processing in automated theorem proving based on dynamic weight calculations.",
      "description_length": 384,
      "index": 291,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.ClauseQueue_intf.S-C-Ctx-Lit",
      "library": "libzipperposition",
      "description": "This module manages bidirectional conversions between literals and formulas using customizable hooks. It provides functions to register and retrieve conversion hooks for transforming literals to formulas and vice versa, as well as direct conversion functions that enforce atomic formula constraints. It works with literals and formulas represented using Logtk types, specifically `Logtk.Literal.t` and `Logtk.Term.t Logtk.SLiteral.t`. Use this module when integrating custom literal representations with existing formula-based logic, such as during parsing, normalization, or output formatting in theorem proving systems.",
      "description_length": 621,
      "index": 292,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.ProofState_intf.S-CQueue",
      "library": "libzipperposition",
      "description": "This module provides priority-based queue operations for managing clauses, including insertion, priority-driven retrieval, membership checks, removal, and serialization. It operates on a priority queue data structure (`CQueue.t`) where clauses are weighted using customizable functions, enabling dynamic prioritization strategies like breadth-first search, goal-oriented selection, or ground clause preference. These capabilities are tailored for automated reasoning systems, where clauses must be efficiently prioritized during proof search, passive set queries, or proof state initialization workflows.",
      "description_length": 604,
      "index": 293,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.StreamQueue.ARG-Stm",
      "library": "libzipperposition",
      "description": "This module implements a stream-based queue structure with support for incremental retrieval and heuristic-based prioritization. It provides operations to create and manipulate streams of clauses, track dependencies, and apply penalties, working directly with `Stm.C.t` clause types and sequences. Use cases include managing logic inference streams where partial results are processed incrementally, such as in automated theorem proving or constraint solving.",
      "description_length": 459,
      "index": 294,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.StreamQueue.ARG-Stm-Ctx",
      "library": "libzipperposition",
      "description": "This module provides operations for term ordering, symbol declaration, signature manipulation, and clause selection in logical contexts. It works with terms, symbols, signatures, and literals, supporting use cases such as injectivity analysis for identifiers, term comparison, and literal manipulation in theorem proving workflows.",
      "description_length": 331,
      "index": 295,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.ClauseQueue_intf.S-C-Ctx",
      "library": "libzipperposition",
      "description": "This module provides operations for configuring term orderings, selection functions, and skolemization contexts in logical reasoning systems. It works with symbol signatures, logical literals, and clauses to support tasks like symbol declaration, injectivity analysis of function arguments, and clause manipulation during automated theorem proving. Key use cases include managing hierarchical logical contexts and optimizing term-level deductions through signature-aware transformations.",
      "description_length": 487,
      "index": 296,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Stream_intf.S-Ctx",
      "library": "libzipperposition",
      "description": "This module supports operations for managing logical contexts in theorem proving systems, including querying term orderings, handling skolemization contexts, and tracking symbol declarations or signature updates. It operates on terms, types, logical symbols, substitution renamings, and literals (via the `Lit` module), with specific functionality for injectivity checks on function symbol arguments and clause-based reasoning. These tools enable tasks like maintaining consistent logical signatures, automating term rewriting, and analyzing term properties through selection functions or substitution mechanisms.",
      "description_length": 613,
      "index": 297,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.FormulaRename.Make",
      "library": "libzipperposition",
      "description": "This module implements formula renaming and Skolemization during clausification, handling predicate Skolem introduction and definition extraction. It operates on clauses and terms, supporting controlled renaming based on polarity and customizable conditions. Useful for managing formula transformations in theorem proving where predicate variables require explicit definitions or fresh Skolem symbols.",
      "description_length": 401,
      "index": 298,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Env_intf.S-ProofState-CQueue-C",
      "library": "libzipperposition",
      "description": "This module provides operations to manage clause properties (e.g., redundancy, simplification status, goal distance), analyze clause structure and literals for inference eligibility (e.g., resolution, paramodulation), and transform clauses through substitution, clausification, and trail-based proof manipulation. It operates on clauses, substitutions, proofs, and trails, enabling tasks like eligibility checks for inference rules, metadata tracking (e.g., penalties, symbol counts), and TSTP-formatted output generation. These functionalities support automated reasoning in superposition-based theorem proving systems, including proof debugging, clause analysis, and logical statement transformation.",
      "description_length": 702,
      "index": 299,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Lift_lambdas.S-Env-ProofState-UnitIndex-E",
      "library": "libzipperposition",
      "description": "This module represents and compares indexed equations or inequations, pairing terms with a boolean flag indicating equality or inequality and a clause. It provides operations to extract components of an equation, compare equations for ordering, and determine their priority for use in theorem proving or term rewriting systems. Use cases include managing and selecting equations during proof search or clause processing in automated reasoning tools.",
      "description_length": 449,
      "index": 300,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Combinators.Make",
      "library": "libzipperposition",
      "description": "This module implements term transformation strategies using environment-driven rules, combining lambda conversion with clause manipulation to enable context-sensitive rewriting. It provides core data types like logical terms and environments, alongside operations for normalization, substitution, and clause analysis via types such as `C.t` and `ClauseSet.t`. You can perform tasks like detecting redundant clauses, applying resolution steps based on literal properties, and maintaining dynamic counters over clause sets. Submodules enhance this with structured traversal, eligibility checks, and ordered set operations, supporting advanced theorem proving and term transformation workflows.",
      "description_length": 691,
      "index": 301,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.StreamQueue_intf.S-Stm-C-Tbl",
      "library": "libzipperposition",
      "description": "This module enables efficient management of key-value associations with support for in-place updates, bulk operations, and customizable traversal. It operates on mutable hash tables mapping `Stm.C.t` keys to arbitrary values, offering safe retrieval, atomic modifications, and conversions to sequences, iterators, or lists. Typical applications include frequency counting, cache implementation, and data transformation pipelines requiring efficient aggregation or iterative refinement of key-value bindings.",
      "description_length": 507,
      "index": 302,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Env_intf.S-ProofState-SubsumptionIndex-C",
      "library": "libzipperposition",
      "description": "This module defines operations for comparing clauses, extracting literals, and retrieving label subsets. It works with clause data structures from the subsumption index, providing direct access to their logical components and metadata. These functions support subsumption checks and indexing in automated theorem proving.",
      "description_length": 321,
      "index": 303,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.AC_intf.S-Env-ProofState-UnitIndex",
      "library": "libzipperposition",
      "description": "This module implements an index for managing and querying a set of logical (in)equations, supporting operations like adding, removing, and retrieving terms with substitution-based matching. It works with terms and substitutions from a logical environment, enabling efficient lookups for generalizations of query terms. Use cases include indexing equations during proof search and retrieving applicable rewrite rules or constraints.",
      "description_length": 431,
      "index": 304,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Saturate.S-Env-Ctx",
      "library": "libzipperposition",
      "description": "This module supports managing logical context and state in theorem proving systems, offering operations to manipulate term orderings, selection functions, symbol declarations, and signatures while tracking state changes to preserve completeness. It includes utilities for injectivity checks on symbols and representations for logical literals, enabling precise clause processing and unification. These features are critical for dynamic term rewriting and automated reasoning tasks where context-sensitive reasoning and symbol properties must adapt during proof search.",
      "description_length": 568,
      "index": 305,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.ProofState_intf.S-SubsumptionIndex-C",
      "library": "libzipperposition",
      "description": "This module defines operations for comparing and analyzing clauses in a subsumption index. It provides functions to compare clauses, iterate over their literals, and retrieve integer labels associated with them. These operations support subsumption checks and indexing in automated theorem proving, where clauses are represented as terms with literals and labels.",
      "description_length": 363,
      "index": 306,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Saturate.S-Env-ProofState-CQueue",
      "library": "libzipperposition",
      "description": "This module supports operations for prioritizing, inserting, and retrieving clauses within a customizable priority queue structure (Env.ProofState.CQueue.t), using weight functions to determine clause ordering. It enables efficient management of passive clause sets in saturation-based theorem proving, including membership checks, selective removal, and strategy-driven prioritization (e.g., FIFO, goal-oriented, or heuristic-based selection). The structure operates on clauses (C.t) and supports introspection via string conversions, facilitating debugging and dynamic strategy adjustments during proof search.",
      "description_length": 612,
      "index": 307,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.Lift_lambdas.S-C-Eligible",
      "library": "libzipperposition",
      "description": "This module defines a set of functions and combinators for determining which literals in a clause are eligible for specific inference rules during automated theorem proving. It operates on clauses and literals, providing filters based on properties like positivity, negativity, maximality, and equation status, as well as logical combinations of these conditions. Use cases include selecting literals for resolution, paramodulation, or other rule applications in a prover's inference engine.",
      "description_length": 491,
      "index": 308,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.ProofState_intf.S-C",
      "library": "libzipperposition",
      "description": "This module offers operations for managing clause metadata (e.g., redundancy, simplification, goal status), manipulating proofs and literals (e.g., eligibility, paramodulation, substitution application), and transforming clauses into normalized forms or structured representations. It operates on clauses (`C.t`), clause sets (`ClauseSet.t`), substitutions (`Logtk.Subst.t`), and trail/bitvector data structures, with use cases in automated theorem proving workflows such as proof search optimization, inference rule application, and clause state tracking during resolution or paramodulation steps.",
      "description_length": 598,
      "index": 309,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.ClauseQueue_intf.S-C-Pos",
      "library": "libzipperposition",
      "description": "Retrieves a subterm at a specified position within a clause. Works with clauses and positions to access specific terms. Useful for analyzing or transforming clauses at precise locations during proof search or term rewriting.",
      "description_length": 224,
      "index": 310,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Ind_cst.Cst_set",
      "library": "libzipperposition",
      "description": "This module implements an ordered set structure for constants with efficient functional operations, supporting membership tests, algebraic set operations, and ordered traversal. It works with sets of `Libzipperposition.Ind_cst.t` values, maintaining elements in a sorted order and enabling transformations via mapping, filtering, and folding with structural sharing. Typical use cases include managing collections of constants for symbolic computation, performing predicate-based queries, and converting structured data to customizable string representations for debugging or output.",
      "description_length": 583,
      "index": 311,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Combinators.S-C-WithPos",
      "library": "libzipperposition",
      "description": "This module represents clauses with a specific subterm and its position, enabling precise manipulation of terms within clauses. It provides comparison and pretty-printing operations for these structured clause-term pairs. Useful for tasks like subterm indexing, rewriting, or focused proof search where term positions matter.",
      "description_length": 325,
      "index": 312,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Stream_intf.S-C-Tbl",
      "library": "libzipperposition",
      "description": "This module provides imperative hash table operations for key-value pairs, including addition, removal, and safe retrieval, alongside advanced transformations like aggregation, filtering, and bulk conversion from sequences. It works with hash tables parametrized over a key type `C.t` and arbitrary value types, supporting use cases such as counting elements in iterators, merging duplicates with custom logic, and formatting data structures for output.",
      "description_length": 453,
      "index": 313,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.Stream.ARG-C-Seq",
      "library": "libzipperposition",
      "description": "This module provides functions to extract literals, terms, and variables from a clause structure. It works with clauses (`C.t`), iterating over their components as streams. Use it to analyze or transform logical expressions in proof search or term rewriting tasks.",
      "description_length": 264,
      "index": 314,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Eprover_interface.S-Env-ProofState-UnitIndex-E",
      "library": "libzipperposition",
      "description": "This module represents and compares indexed equations or inequations, each paired with a clause. It provides a total order via `compare`, extracts term components and sign via `extract`, and assigns heuristic usefulness via `priority`. Useful for indexing and prioritizing equations during automated theorem proving.",
      "description_length": 316,
      "index": 315,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Combinators.S-Env-C-Pos",
      "library": "libzipperposition",
      "description": "Retrieves a term from a given environment at a specified position. Works with environments and terms indexed by positions. Useful for accessing specific subterms during proof search or term traversal.",
      "description_length": 200,
      "index": 316,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.ProofState_intf.S-C-WithPos",
      "library": "libzipperposition",
      "description": "This module represents clauses with a specific subterm and its position, enabling precise manipulation and analysis of terms within clauses. It provides comparison and pretty-printing operations for these structured clause-term-position triples. It is used in proof systems where tracking subterm positions is essential for operations like rewriting or inference rule application.",
      "description_length": 380,
      "index": 317,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.StreamQueue_intf.S-Stm-C-Pos",
      "library": "libzipperposition",
      "description": "This module provides a function `at` that retrieves a term from a stream at a specified position. It operates on streams of terms and positions, allowing precise access to elements within the stream based on positional indexing. A concrete use case is extracting specific terms from a stream during parsing or term traversal.",
      "description_length": 325,
      "index": 318,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.ProofState_intf.S-SubsumptionIndex",
      "library": "libzipperposition",
      "description": "This module implements a subsumption index for clauses, supporting operations to add, remove, and retrieve clauses based on subsumption and alpha-equivalence relations. It works with clauses represented as literals and labels, providing indexed lookups for efficient proof state management. Concrete use cases include clause indexing in automated theorem proving, identifying redundant clauses, and managing clause sets during saturation-based reasoning.",
      "description_length": 454,
      "index": 319,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Clause_intf.S-WithPos",
      "library": "libzipperposition",
      "description": "This module represents clauses with a specific subterm and its position, enabling precise manipulation and analysis of terms within clauses. It provides comparison and pretty-printing operations for these structured clauses. Useful for tasks like term indexing, rewriting, or focused proof search where subterm positions matter.",
      "description_length": 328,
      "index": 320,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Lift_lambdas.S-Env-ProofState-PassiveSet",
      "library": "libzipperposition",
      "description": "This module manages a set of passive clauses with operations to add, remove, and retrieve clauses, as well as track their state via signals. It works with clause sets and a clause queue, providing direct access to the current set and queue state. Concrete use cases include controlling clause processing in a saturation loop and monitoring clause additions or removals for debugging or triggering actions.",
      "description_length": 405,
      "index": 321,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Env_intf.S-ProofState-CQueue",
      "library": "libzipperposition",
      "description": "This module manages clause prioritization and selection in automated theorem proving, offering operations to insert, retrieve, and prioritize clauses using FIFO, heuristic-based, or goal-oriented strategies. It supports membership checks, removals, and string conversions for clauses within a structured queue, facilitating dynamic management of proof search processes. The data structures include prioritized queues (`ProofState.CQueue.t`) and associated clause types (`ProofState.CQueue.C.t`), enabling efficient handling of passive sets and strategy-driven clause selection through customizable weight and priority functions.",
      "description_length": 628,
      "index": 322,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Saturate.S-Env-ProofState-PassiveSet",
      "library": "libzipperposition",
      "description": "This module manages a set of passive clauses in a theorem proving context, providing operations to add, remove, and retrieve clauses based on their passive status. It tracks clause changes through signals and maintains a queue for clause processing order. Concrete use cases include controlling clause selection during saturation-based proof search and monitoring clause lifecycle events for logging or strategy adjustments.",
      "description_length": 424,
      "index": 323,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.FormulaRename.S-C-ClauseSet",
      "library": "libzipperposition",
      "description": "This module provides a functional interface for manipulating immutable sets of clauses (C.ClauseSet.t), supporting standard operations like membership testing, insertion, deletion, union, intersection, and ordered iteration. It emphasizes ordered set manipulations, safe element retrieval via option-returning functions, and conversions between sets, lists, sequences, and iterators. Designed for automated reasoning systems, it facilitates tasks like clause management, logical formula transformation, and ordered traversal in theorem proving workflows.",
      "description_length": 554,
      "index": 324,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.Combinators.S-Env-ProofState-CQueue",
      "library": "libzipperposition",
      "description": "This module supports priority-based clause management in automated reasoning, offering operations to insert clauses, retrieve top-priority elements, and configure queue behavior using strategies like FIFO, goal-oriented, or heuristic-driven approaches. It manipulates typed priority queues (`Env.ProofState.CQueue.t`) and their associated clauses (`Env.ProofState.CQueue.C.t`), with utilities for membership testing, removal, and string representation. These capabilities enable efficient proof state management, passive clause set analysis, and conjecture tracking in theorem proving workflows.",
      "description_length": 595,
      "index": 325,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Saturate.S-Env-ProofState-CQueue-C",
      "library": "libzipperposition",
      "description": "This module focuses on clause analysis and manipulation for automated theorem proving, offering operations to inspect and modify clause properties like redundancy, eligibility for inference rules, and trail management. It works with clauses (`C.t`) and clause sets, providing functionality for structural analysis (e.g., literal selection, maximality checks), proof transformation (e.g., substitution, grounding), and output formatting. Key use cases include resolution and paramodulation inferences, proof state maintenance, and TSTP-compatible proof generation.",
      "description_length": 563,
      "index": 326,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.AC_intf.S-Env-C-Eligible",
      "library": "libzipperposition",
      "description": "This module defines eligibility criteria for selecting literals within clauses based on logical operations and specific properties. It provides functions to filter literals by resolution, paramodulation, positivity, negativity, maximality, and equation status, as well as combining and negating these criteria. These operations are used to control inference rules in automated theorem proving, such as deciding which literals can participate in resolution or paramodulation steps.",
      "description_length": 480,
      "index": 327,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Eprover_interface.S-Env-Stm",
      "library": "libzipperposition",
      "description": "This module manages streams of clauses with dynamic penalties and hit counters, providing operations to create, compare, and manipulate these streams. It supports concrete use cases like prioritizing clause resolution attempts in a theorem prover based on stream properties such as ID, penalty, or parent clauses. Key functions include `drip` to extract elements from the stream and `make` to construct streams with configurable initial state.",
      "description_length": 443,
      "index": 328,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.AC_intf.S-Env-ProofState-CQueue-PriorityFun",
      "library": "libzipperposition",
      "description": "This module defines a priority function type used to assign integer weights to elements in a proof state queue. It includes a function to parse string descriptions into these priority functions. This enables dynamic configuration of prioritization strategies for clauses during automated theorem proving.",
      "description_length": 304,
      "index": 329,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.StreamQueue_intf.S-Stm-C",
      "library": "libzipperposition",
      "description": "This module enables clause management in theorem proving through operations like property marking (e.g., redundancy, simplification), trail-based clause construction, proof extraction, and eligibility checks for inference rules. It works with clauses, trails, substitutions, and bitvector-encoded literal sets to support tasks such as redundancy elimination, proof generation, and literal selection",
      "description_length": 398,
      "index": 330,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.AC_intf.S-Env-Stm",
      "library": "libzipperposition",
      "description": "This module implements a stream-based structure for managing sequences of clauses with dynamic penalties and hit counters. It supports operations to create, compare, and hash streams, as well as to retrieve and remove elements incrementally. Concrete use cases include prioritizing and processing logical inferences in automated theorem proving.",
      "description_length": 345,
      "index": 331,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Stream.ARG-C-Pos",
      "library": "libzipperposition",
      "description": "This module provides a function `at` that retrieves a term from a given position in a clause. It operates on clauses (`C.t`) and positions (`Logtk.Position.t`), returning the corresponding term (`Logtk.Term.t`). A concrete use case is extracting specific subterms from clauses during proof search or term analysis.",
      "description_length": 314,
      "index": 332,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.Lift_lambdas.S-Env-StmQ-WeightFun",
      "library": "libzipperposition",
      "description": "This module defines weight functions that assign integer weights to streams of statements. It provides operations to retrieve a penalty value for a stream and to combine multiple weighted functions into a single function using a weighted sum. These functions are used to prioritize or evaluate streams based on customizable weighting schemes.",
      "description_length": 342,
      "index": 333,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.Clause_intf.S-Seq",
      "library": "libzipperposition",
      "description": "This module provides operations to iterate over literals, terms, and variables within a clause structure. It works with clause data types, exposing elements as iterators for processing. Use it to analyze or transform logical clauses by accessing their constituent literals, terms, or typed variables directly.",
      "description_length": 309,
      "index": 334,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Lift_lambdas.S-C-ClauseSet",
      "library": "libzipperposition",
      "description": "This module provides ordered set operations for managing collections of clauses with total ordering and equality checks, supporting standard transformations like union, intersection, and difference alongside higher-order functions for mapping, folding, and predicate-based filtering. It works with sets of type `C.t` structured via a comparator `Ord`, enabling efficient element retrieval (min/max), range iteration, and conversions to lists, sequences, or strings. Key use cases include symbolic reasoning tasks requiring ordered clause manipulation, safe conditional searches, and customizable serialization for debugging or data interchange.",
      "description_length": 644,
      "index": 335,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Env_intf.S-ProofState-module-type-CLAUSE_SET",
      "library": "libzipperposition",
      "description": "This module manages a set of clauses with operations to add or remove clauses and trigger signals on these changes. It works with clause sets and uses iterators over clauses for bulk modifications. Concrete use cases include tracking clause additions and deletions during theorem proving processes.",
      "description_length": 298,
      "index": 336,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.AC_intf.S-C-Tbl",
      "library": "libzipperposition",
      "description": "This module provides operations for manipulating key-value associations with efficient insertion, lookup, and in-place modification, alongside bulk updates from sequences or iterators, safe value retrieval with fallbacks, and counter management via increment/decrement. It works with hashtables mapping keys of type `C.t` to arbitrary values `'a`, supporting transformations like merging duplicate keys using custom logic, aggregating keys or values into lists, and converting data to or from sequences and iterable formats. These capabilities are particularly useful for tasks involving data aggregation, bulk data processing with duplicate resolution, and debugging through structured visualization or counter tracking.",
      "description_length": 721,
      "index": 337,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.StreamQueue.ARG-Stm-C-ClauseSet",
      "library": "libzipperposition",
      "description": "This module implements a functional set interface for ordered clause collections, supporting membership checks, set operations (union, intersection, difference), and transformations (map, fold, filter) over immutable `Stm.C.ClauseSet.t` structures backed by ordered elements. It provides utilities for querying specific elements (min/max, predicate-based searches), converting between sets and sequences/lists, and safely handling edge cases via optional return values. Designed for scenarios requiring efficient manipulation of logical clause sets, such as theorem proving or constraint solving workflows.",
      "description_length": 606,
      "index": 338,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.AC_intf.S-Env-StmQ-WeightFun",
      "library": "libzipperposition",
      "description": "This module defines weight functions used to assign integer weights to streams of statements. It includes operations to retrieve a penalty value for a stream and to combine multiple weighted functions into a single function through a weighted sum. These functions are applied in scenarios like prioritizing or filtering statement streams based on configurable criteria, such as in proof search or constraint solving.",
      "description_length": 416,
      "index": 339,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "Libzipperposition.Ctx.PARAMETERS",
      "library": "libzipperposition",
      "description": "This module defines core parameters used in theorem proving, including a logical signature, term ordering, clause selection strategies, and skolemization context. It provides concrete values for configuring proof search in first-order logic. These parameters directly influence the behavior of inference rules and clause processing during automated reasoning tasks.",
      "description_length": 365,
      "index": 340,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.FormulaRename.S-C-WithPos",
      "library": "libzipperposition",
      "description": "This module represents clauses with a specific subterm and its position, enabling precise manipulation and analysis of terms within clauses. It provides comparison and pretty-printing operations for these structured clauses. Useful for tasks like term rewriting, proof tracing, or focused term transformations where positional context is critical.",
      "description_length": 347,
      "index": 341,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.ProofState.Make",
      "library": "libzipperposition",
      "description": "This module orchestrates the dynamic management of logical clauses and term structures throughout a theorem prover's proof search. It organizes clauses into active, passive, and prioritized sets, supporting operations like subsumption checks, retrieval, and heuristic-based prioritization, with core data types including clauses, term indices, and priority queues. Submodules refine this functionality by maintaining reactive clause sets with change tracking, structuring clauses under subsumption and equivalence hierarchies, and indexing terms with positional annotations for unification-based queries. Specific capabilities include dynamically updating clause sets during search, identifying and eliminating redundant clauses, guiding proof strategies through prioritized clause selection, and visualizing term relationships to analyze proof progress.",
      "description_length": 854,
      "index": 342,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Lift_lambdas.S-C",
      "library": "libzipperposition",
      "description": "This module provides clause management operations such as metadata manipulation (tracking redundancy, weight, and goal status), trail modification, and proof extraction, alongside transformations like lambda-lifting, grounding, and eta-reduction in first-order logic. It supports eligibility checks for inference rules (resolution, paramodulation), literal selection,",
      "description_length": 367,
      "index": 343,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.Combinators.S-Env-C-Eligible",
      "library": "libzipperposition",
      "description": "This module defines eligibility criteria for selecting literals in a clause based on logical operations and properties such as positivity, negativity, maximality, and equation status. It provides functions to filter literals for resolution, paramodulation, and equation handling, and supports combining criteria using logical operators. Use cases include guiding inference rules in automated theorem proving by restricting which literals can participate in specific operations.",
      "description_length": 477,
      "index": 344,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Env_intf.S-C",
      "library": "libzipperposition",
      "description": "This module provides operations to manipulate clause properties (e.g., redundancy, goal status), construct and modify clauses with trails and proofs, and perform eligibility checks for resolution/paramodulation. It works with clauses (`C.t`), trails (`Trail.t`), substitutions (`Logtk.Subst.t`), and proof structures, supporting tasks like literal selection, penalty tracking, and proof extraction. Specific use cases include redundancy elimination, goal derivation, clause transformation (e.g., TSTP conversion), and term manipulation underpinning theorem proving workflows.",
      "description_length": 575,
      "index": 345,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Clause_intf.S",
      "library": "libzipperposition",
      "description": "This module supports operations for manipulating and analyzing logical clauses in automated reasoning systems, focusing on metadata management (flags, weight, groundness), proof-related properties (goal status, trail handling, proof extraction), and structural analysis (literal selection, eligibility checks for inference rules). It operates on an abstract clause type alongside data structures like trails, substitutions, and bitvectors, with utilities for clause transformation, symbolic representation, and format conversion. Key use cases include theorem proving tasks such as resolution, paramodulation, and clause set manipulation in logic processing pipelines.",
      "description_length": 668,
      "index": 346,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.Eprover_interface.S-Env-ProofState-SubsumptionIndex",
      "library": "libzipperposition",
      "description": "This module implements a subsumption index for managing and querying clauses in a proof state. It supports operations to add, remove, and retrieve clauses based on subsumption and alpha-equivalence relationships, using literals and labels as keys. Use cases include efficient clause indexing and retrieval during automated theorem proving processes.",
      "description_length": 349,
      "index": 347,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Env_intf.S-Ctx",
      "library": "libzipperposition",
      "description": "This module provides operations for term ordering management, injectivity checks in unification, and dynamic symbol tracking within logical reasoning systems. It operates on terms, formulas, and logical literals, leveraging signatures, selection functions, and skolemization mechanisms to support proof construction. These capabilities are applied in automated reasoning tasks like term rewriting, quantifier handling, and maintaining consistency during symbol definition updates.",
      "description_length": 480,
      "index": 348,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.ProofState_intf.S-Ctx-Lit",
      "library": "libzipperposition",
      "description": "This module manages bidirectional conversions between literals and formulas using customizable hooks. It provides functions to register and retrieve conversion hooks for transforming literals to formulas and vice versa, as well as direct conversion functions that apply these hooks. It works with `Logtk.Literal.t` and `Logtk.Term.t Logtk.SLiteral.t`, supporting use cases like integrating custom literal representations into theorem proving workflows.",
      "description_length": 452,
      "index": 349,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Lift_lambdas.S-Env-ProofState-TermIndex-Leaf",
      "library": "libzipperposition",
      "description": "This module implements a term index structure for efficient retrieval of terms during proof search. It supports operations to add, remove, and update indexed terms, as well as perform unification and matching queries against stored terms. It is used to accelerate term-level lookups in automated reasoning tasks, such as finding applicable clauses or substitutions during resolution-based theorem proving.",
      "description_length": 405,
      "index": 350,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Lift_lambdas.S-Env-Ctx-Lit",
      "library": "libzipperposition",
      "description": "This module manages bidirectional conversions between literals and formulas using customizable hooks. It provides functions to register and retrieve conversion hooks for transforming between `Logtk.Literal.t` and `Logtk.Term.t Logtk.SLiteral.t` types. It is used to integrate lambda-lifting transformations with literal-level processing in theorem proving pipelines.",
      "description_length": 366,
      "index": 351,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.Lift_lambdas.S-Env-ProofState-CQueue",
      "library": "libzipperposition",
      "description": "This module provides operations for managing priority queues of logical clauses, supporting actions like insertion, prioritization, retrieval of top-priority elements, and membership checks. It operates on `Env.ProofState.CQueue.t` structures, which encapsulate clauses alongside weight and priority functions to govern their ordering. These capabilities are specifically applied in theorem proving to manage passive clause sets, prioritize proof exploration strategies (e.g., goal-oriented or heuristic-driven), and facilitate debugging through string serialization.",
      "description_length": 567,
      "index": 352,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.ProofState_intf.S-C-Seq",
      "library": "libzipperposition",
      "description": "This module provides functions to extract literals, terms, and variables from a clause. It works with clauses (`C.t`), literals (`Logtk.Literal.t`), terms (`Logtk.Term.t`), and typed variables (`Logtk.Type.t Logtk.HVar.t`). Use it to analyze or transform logical clauses by inspecting their components.",
      "description_length": 302,
      "index": 353,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Eprover_interface.S-Env-StmQ-WeightFun",
      "library": "libzipperposition",
      "description": "This module defines weight functions for assigning integer weights to streams of statements. It provides operations to retrieve a penalty value for a stream and to combine multiple weighted functions into a single function using a weighted sum. These functions are used to prioritize or evaluate the relevance of logical statements in automated theorem proving tasks.",
      "description_length": 367,
      "index": 354,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.Stream_intf.S-C-Pos",
      "library": "libzipperposition",
      "description": "Retrieves a subterm at a specified position in a term. Works with terms and positions. Useful for precise term manipulation and analysis.",
      "description_length": 137,
      "index": 355,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.StreamQueue.ARG-Stm-C-Eligible",
      "library": "libzipperposition",
      "description": "This module defines eligibility criteria for selecting literals in clauses based on logical operations and properties such as positivity, negativity, maximality, and equation status. It provides functions to filter literals by resolution, paramodulation, or custom conditions, and supports combining criteria using logical operators (and, or, not). Use cases include guiding inference rules in automated theorem proving by restricting which literals can participate in resolution or paramodulation steps.",
      "description_length": 504,
      "index": 356,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Combinators.S-C-Tbl",
      "library": "libzipperposition",
      "description": "This module implements imperative hash tables with key-value operations like insertion, removal, and safe lookup with default values, supporting in-place transformations and bulk updates. It works with keys of type `C.t` and arbitrary value types, offering utilities for frequency counting, sequence conversion, and customizable table manipulation. Typical use cases include tracking element frequencies, merging key-value pairs with custom strategies, and efficiently managing dynamic key-value collections with guaranteed safe access patterns.",
      "description_length": 545,
      "index": 357,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Ctx.Make",
      "library": "libzipperposition",
      "description": "This module manages logical contexts with support for term orderings, signature manipulation, and skolemization, operating on types like `Logtk.Ordering.t`, `Logtk.Signature.t`, and `Logtk.Term.t`. Its `Lit` submodule enables bidirectional conversions between literals and formulas through customizable hooks, working with `Logtk.Literal.t` and `Logtk.SLiteral.t` to support custom term representations in theorem proving. It tracks identifier injectivity for indexing and unification, enabling context-sensitive reasoning and formula normalization. Examples include automating proof search with custom literal encodings or transforming terms during normalization passes.",
      "description_length": 671,
      "index": 358,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Env_intf.S-ProofState-CQueue-WeightFun",
      "library": "libzipperposition",
      "description": "This module defines weight functions that assign integer weights to clauses in a proof state's queue, guiding the selection strategy during automated theorem proving. It supports operations like parsing weight function descriptions, combining multiple weight functions with coefficients, and applying heuristics such as favoring ground or Horn clauses, penalizing non-goal-related clauses, or adjusting based on clause structure. Concrete use cases include prioritizing clauses close to the goal, penalizing complex clauses, or favoring specific logical forms to improve proof search efficiency.",
      "description_length": 595,
      "index": 359,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.Combinators.S-Env-ProofState-SubsumptionIndex",
      "library": "libzipperposition",
      "description": "This module implements a subsumption index for managing and querying clauses in a proof state. It supports operations to add, remove, and retrieve clauses based on subsumption and alpha-equivalence relationships, using literals and labels as keys. Use cases include efficient clause indexing and retrieval during automated theorem proving processes, such as identifying redundant clauses or finding candidates for resolution steps.",
      "description_length": 431,
      "index": 360,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Combinators.S-Env-Ctx-Lit",
      "library": "libzipperposition",
      "description": "This module manages bidirectional conversions between literals and their atomic formula representations using hook-based extensible mechanisms. It provides operations to register and retrieve conversion hooks, and to convert between literal and term-based atomic formulas. It works directly with `Logtk.Literal.t` and `Logtk.SLiteral.t` types, enabling integration of custom literal handling in theorem proving pipelines.",
      "description_length": 421,
      "index": 361,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Stream_intf.S-C",
      "library": "libzipperposition",
      "description": "This module supports automated reasoning by enabling clause analysis, transformation, and metadata tracking for proof management. It operates on clauses (`C.t`), trails (`Trail.t`), substitutions, and bitvectors, offering tools to inspect literals, manage proof states, and determine eligibility for inference rules like resolution or paramodulation. Specific applications include redundancy marking, heuristic penalty tracking, semantic validation, and format conversion (e.g., TSTP) for debugging or interoperability.",
      "description_length": 519,
      "index": 362,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Stream.Make",
      "library": "libzipperposition",
      "description": "This module implements a stream data structure with unique identifiers, heuristic penalties, and hit counters, designed to manage sequences of clauses in automated theorem proving. It supports operations to create, compare, and manipulate streams, including extracting elements incrementally and measuring stream activity. Concrete use cases include tracking and prioritizing inference results during proof search, where streams represent evolving sets of candidate clauses.",
      "description_length": 474,
      "index": 363,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.AC_intf.S-Env-ProofState-CQueue",
      "library": "libzipperposition",
      "description": "This module implements priority queues for logic clauses, offering operations to insert clauses with customizable prioritization strategies (e.g., heuristic exploration, goal orientation, or weighted scoring), retrieve top-priority elements, check membership, and remove clauses dynamically. It operates on `Env.ProofState.CQueue.t` structures, which encapsulate clauses alongside metadata for proof-state tracking in automated theorem proving. These queues are critical for managing clause processing order during proof search, enabling efficient exploration of logical derivations and iterative refinement of proof states.",
      "description_length": 624,
      "index": 364,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.ClauseQueue.Make",
      "library": "libzipperposition",
      "description": "This module manages and prioritizes logical clauses for theorem proving using a queue-based system with customizable strategies. It supports key operations like adding, selecting, and removing clauses, with priority and weight functions guiding selection heuristics such as goal-oriented reasoning or ground clause emphasis. The module allows dynamic configuration of prioritization schemes through string descriptions and enables combining weight functions with coefficients for fine-grained control. Examples include selecting clauses in FIFO order, favoring low-weight clauses, or emphasizing ground and negative clauses during proof search.",
      "description_length": 644,
      "index": 365,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Env_intf.S-ProofState-UnitIndex-E",
      "library": "libzipperposition",
      "description": "This module represents and compares indexed equations or inequations, pairing terms with a boolean flag and a clause. It provides a total order via `compare`, extracts term representations with their sign and right-hand side, and assigns a usefulness priority to each equation. It is used to manage and prioritize equations during theorem proving processes.",
      "description_length": 357,
      "index": 366,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Combinators.S-Env-FormRename-Ctx-Lit",
      "library": "libzipperposition",
      "description": "This module manages bidirectional conversions between literals and atomic formulas using customizable hooks. It provides functions to register and retrieve conversion hooks, as well as to perform the actual conversions with `of_form` and `to_form`. It works directly with `Logtk.Literal.t` and `Logtk.Term.t Logtk.SLiteral.t` types, enabling integration with theorem proving or term rewriting systems where literal normalization and transformation are required.",
      "description_length": 461,
      "index": 367,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Stream_intf.S-C-Seq",
      "library": "libzipperposition",
      "description": "This module provides streaming access to literals, terms, and variables contained in a clause. It enables iteration over these components using the `Iter` module, facilitating on-demand processing without full in-memory representation. Concrete use cases include analyzing clause structure during theorem proving or extracting specific elements for further logical manipulation.",
      "description_length": 378,
      "index": 368,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.Saturate.S-Env-ProofState-CQueue-WeightFun",
      "library": "libzipperposition",
      "description": "This module defines weight functions that compute integer weights for clauses in a proof state priority queue. It supports operations like parsing weight function descriptions, combining weighted sums of functions, and applying heuristic-based penalties or preferences based on clause properties such as goal proximity, horn shape, or groundness. Use cases include guiding clause selection during saturation-based theorem proving by prioritizing clauses with specific logical characteristics.",
      "description_length": 492,
      "index": 369,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.AC_intf.S-Env-ProofState-SubsumptionIndex-C",
      "library": "libzipperposition",
      "description": "This module defines operations for comparing clauses, iterating over their literals, and retrieving label subsets used in subsumption checks. It works with clause data structures from a proof state and their associated literals and labels. It supports subsumption indexing by managing relationships between clauses based on literal content and label inclusion.",
      "description_length": 360,
      "index": 370,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Combinators.S-Env-ProofState-TermIndex",
      "library": "libzipperposition",
      "description": "This module implements a term indexing structure for efficient management of term-element pairs within a proof state, supporting operations like insertion, deletion, unification-based queries, and retrieval of generalized or specialized terms with substitutions. It operates on indexed collections of terms represented in a proof state's term index, enabling iterative traversal and transformation. The functionality is particularly useful in automated theorem proving for optimizing proof search and for debugging through DOT format visualization of term relationships.",
      "description_length": 570,
      "index": 371,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.AC_intf.S-Env-FormRename-Ctx-Lit",
      "library": "libzipperposition",
      "description": "This module manages bidirectional conversions between atomic formulas and literals using customizable hooks. It provides functions to register and retrieve conversion hooks for transforming formulas to literals and vice versa, along with direct conversion operations that enforce atomicity constraints. It works with terms and literals from the Logtk library, specifically `Logtk.Term.t` and `Logtk.Literal.t`, and is used in theorem proving or formal verification contexts where formula-literal translation is required.",
      "description_length": 520,
      "index": 372,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.Combinators.S-Env-C-ClauseSet",
      "library": "libzipperposition",
      "description": "This module offers operations for managing ordered clause sets, including union, intersection, difference, and subset checks, as well as ordered traversal via mapping, folding, and extremal element queries. It works with `Env.C.ClauseSet.t` structures built using a comparator module to enforce canonical ordering, supporting efficient identity-preserving updates and safe empty-set handling through optional returns. Typical use cases include formal verification tasks requiring precise clause set manipulation, such as automated theorem proving or logic-based constraint solving, where ordered traversal and structural integrity are critical.",
      "description_length": 644,
      "index": 373,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Eprover_interface.S",
      "library": "libzipperposition",
      "description": "This module configures and integrates an E prover interface, providing functions to set the E binary path, attempt E-based proof steps on clause iterators, and register relevant inference rules in the environment. It operates on clause iterators and optional clauses, targeting integration with automated reasoning pipelines. Concrete use cases include invoking E prover during clause processing and setting up rule-based proof search in a theorem proving system.",
      "description_length": 463,
      "index": 374,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.FormulaRename.S-C-Tbl",
      "library": "libzipperposition",
      "description": "This module provides imperative hash table operations for key-value pairs where keys are of type `C.t`, supporting in-place updates, element counting, and customizable merging of duplicate keys. It works with hash tables (`C.Tbl.t`) to enable efficient lookups, iteration over keys/values, and transformations like `map_list` or `fold`, while specialized functions handle counting, sequence conversion, and stateful modifications (e.g., `incr`, `decr`). Typical use cases include data aggregation pipelines, frequency tracking, or stateful memoization where dynamic key-value management and performance-critical operations are required.",
      "description_length": 636,
      "index": 375,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.StreamQueue.ARG-Stm-C",
      "library": "libzipperposition",
      "description": "This module provides operations for managing clause metadata (e.g., redundancy flags, simplification status), structural inspection (e.g., literal access, weight comparison), and transformations (e.g., substitution application, proof extraction). It works with clauses (`Stm.C.t`), trails (`Trail.t`), proof steps, and auxiliary structures like substitutions and bitvectors. Specific use cases include automated reasoning tasks such as clause simplification, eligibility checks for resolution or paramodulation, and generating TSTP-formatted output for theorem-proving workflows.",
      "description_length": 579,
      "index": 376,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Env_intf.S-C-WithPos",
      "library": "libzipperposition",
      "description": "This module represents clauses with a specific subterm and its position, enabling precise manipulation and analysis of terms within clauses. It provides comparison and pretty-printing operations for values containing a clause, a term, and its logical position. It is used in theorem proving and term rewriting systems to track and operate on subterms within their clause context.",
      "description_length": 379,
      "index": 377,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.ProofState_intf.S-PassiveSet",
      "library": "libzipperposition",
      "description": "This module manages a set of passive clauses with operations to add, remove, and retrieve clauses based on a queue. It provides signals for tracking clause additions and removals, a predicate to check if a clause is passive, and access to the current clause queue and set. Concrete use cases include controlling clause processing in automated theorem proving and managing passive clause state during proof search.",
      "description_length": 413,
      "index": 378,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Lift_lambdas.S-Env-ProofState-ActiveSet",
      "library": "libzipperposition",
      "description": "This module manages a dynamic set of clauses with signals for tracking additions and removals. It provides operations to add or remove multiple clauses, retrieve the current set, and get the number of clauses. Useful for maintaining and monitoring clause sets during theorem proving processes where dynamic updates and notifications are required.",
      "description_length": 346,
      "index": 379,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.SimplM.Infix",
      "library": "libzipperposition",
      "description": "This module defines infix operators for monadic chaining and mapping over values within the `SimplM` monad. It provides `>>=` for sequencing computations that return `SimplM` values and `>|=` for applying pure transformations to the result of a `SimplM` computation. These operations are used to build and manipulate sequences of stateful, possibly failing simplification steps in theorem proving processes.",
      "description_length": 407,
      "index": 380,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.Stream_intf.S-C-WithPos",
      "library": "libzipperposition",
      "description": "Represents a clause with a specific subterm and its position for precise term manipulation. Provides comparison and pretty-printing operations for structured analysis. Useful in proof search and term rewriting systems where positional context is critical.",
      "description_length": 255,
      "index": 381,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.Ctx_intf.S-Lit",
      "library": "libzipperposition",
      "description": "This module manages bidirectional conversions between literals and formulas using customizable hooks. It provides functions to register and retrieve conversion hooks for transforming literals to and from terms, supporting dynamic extensions to the conversion process. The primary use case involves enabling seamless interoperability between literal representations and term-based formulas in theorem proving or logic processing tasks.",
      "description_length": 434,
      "index": 382,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.AC_intf.S-Env-FormRename",
      "library": "libzipperposition",
      "description": "This module handles formula renaming and Skolemization during clause processing. It provides operations to rename logical formulas, introduce predicate Skolem symbols, and identify renaming clauses. Key functions include `rename_form` for definition-based renaming and `get_skolem` for generating Skolem terms in different modes, working with clauses and formula rename contexts. Use cases include formula normalization and handling existential quantifiers in automated theorem proving.",
      "description_length": 486,
      "index": 383,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.AC_intf.S-Env-ProofState-module-type-CLAUSE_SET",
      "library": "libzipperposition",
      "description": "This module manages a set of clauses with operations to add or remove clauses and trigger signals on these changes. It works with clause sets and uses iterators over clauses for bulk modifications. Concrete use cases include tracking clause additions and deletions during theorem proving processes, such as in automated reasoning systems or logic solvers.",
      "description_length": 355,
      "index": 384,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.ClauseQueue_intf.S-C-Tbl",
      "library": "libzipperposition",
      "description": "This module provides imperative hash table operations for managing key-value associations with keys of type `C.t` and arbitrary value types, emphasizing safe access, bulk updates, and transformations. It supports element frequency counting, conversions between tables and sequences/lists, and customizable merging of duplicate keys, making it suitable for tasks like statistical aggregation, data structure translation, and incremental table refinement. Use cases include tracking term frequencies in symbolic data, merging intermediate results with combiners, and iterative table population with on-demand key insertion.",
      "description_length": 621,
      "index": 385,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.ClauseQueue_intf.S",
      "library": "libzipperposition",
      "description": "This interface orchestrates clause prioritization and selection strategies in a theorem prover, offering operations to insert clauses, select them via FIFO or heuristic-driven methods, and apply specialized preferences like favoring ground clauses or conjecture-proximity. It manipulates a queue structure (`t`) containing clauses (`C.t`) with supporting functions for membership checks, removals, and serialization, primarily serving passive set management and debugging in automated reasoning workflows.",
      "description_length": 505,
      "index": 386,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.Lift_lambdas.S-Env-FormRename-Ctx",
      "library": "libzipperposition",
      "description": "This module provides operations for logical context manipulation, including skolemization, term ordering, and symbol declaration, alongside injectivity checks for identifiers to guide term rewriting. It works with terms, types, signatures, and logical literals, supporting tasks like simplification and constraint handling. These capabilities are critical in theorem proving for managing logical consistency and optimizing proof search strategies.",
      "description_length": 447,
      "index": 387,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.Env_intf.S-C-Eligible",
      "library": "libzipperposition",
      "description": "This module defines a set of functions and combinators for determining which literals in a clause are eligible for specific inference rules during automated theorem proving. It operates on clauses and their literals, allowing filtering based on properties like positivity, negativity, being an equation, or eligibility for resolution and paramodulation. Use cases include configuring proof search strategies by restricting inference rules to certain subsets of literals.",
      "description_length": 470,
      "index": 388,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Combinators.S-Env-StmQ-WeightFun",
      "library": "libzipperposition",
      "description": "This module defines weight functions that assign integer weights to streams of statements. It provides operations to retrieve a stream's penalty and combine multiple weight functions using weighted sums. Concrete use cases include prioritizing or filtering streams based on configurable weight metrics in proof search or resource-constrained evaluation.",
      "description_length": 353,
      "index": 389,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.ProofState_intf.S-C-ClauseSet",
      "library": "libzipperposition",
      "description": "This module provides a persistent set structure for managing clauses with comparison-based ordering, supporting standard set operations like union, intersection, and difference, along with filtering, mapping, and ordered traversal. It works with sets of clauses (`C.ClauseSet.t`) and facilitates transformations between sets, lists, and sequences, including safe variants for partial operations. Designed for theorem proving contexts, it enables efficient querying, combination, and serialization of clause sets during proof state manipulation.",
      "description_length": 544,
      "index": 390,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Combinators.S-Env-C",
      "library": "libzipperposition",
      "description": "This module focuses on managing clause metadata (e.g., redundancy flags, equality checks, and status tracking), constructing clauses with proofs or trails, and performing transformations like substitution application, eligibility checks for resolution, and literal selection. It operates on clauses (`Env.C.t`), substitutions (`Logtk.Subst.t`), and bitvectors (`CCBV.t`), enabling automated theorem proving tasks such as proof extraction, paramodulation, and clause simplification. Specific utilities include converting clauses to standardized forms (e.g., TSTP) and handling metadata like depth or penalty for clause-based reasoning.",
      "description_length": 634,
      "index": 391,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Saturate.S-Env-ProofState-TermIndex",
      "library": "libzipperposition",
      "description": "The structure provides term indexing operations for efficient clause retrieval during saturation-based theorem proving, supporting modifications like insertion, deletion, and updates alongside queries for unifiable terms, generalizations, and specializations using scoped unification. It operates on term indices and proof state elements, leveraging substitutions to manage relationships between logical expressions. This facilitates critical tasks like redundancy checking and inference rule application, with additional utilities for generating DOT-formatted visualizations of indexed term hierarchies.",
      "description_length": 604,
      "index": 392,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Clause_intf.S-Tbl",
      "library": "libzipperposition",
      "description": "This module implements hash tables with key-value storage, iteration, and bulk transformation capabilities, supporting polymorphic values and keys of a specific type with efficient operations like counter updates, list aggregation, and sequence-based conversions. It emphasizes customizable handling of duplicate keys during merges, safe value retrieval, and imperative-style updates combined with functional transformations. Typical applications include data aggregation pipelines, collection manipulation with custom reduction logic, and state management requiring hybrid functional-imperative processing.",
      "description_length": 607,
      "index": 393,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Combinators.S-Env-Stm-Ctx",
      "library": "libzipperposition",
      "description": "This module provides operations for skolemization, term ordering, and symbol declaration within logical contexts, along with injectivity analysis for identifiers in specific argument positions. It works with terms, types, signatures, and literals or clauses in formal logic systems. These capabilities are essential for tasks like theorem proving, formal verification, and automated reasoning where logical structure manipulation and term property analysis are critical.",
      "description_length": 470,
      "index": 394,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Saturate.S-Env-C-Eligible",
      "library": "libzipperposition",
      "description": "This module defines eligibility criteria for selecting literals in a clause based on logical operations. It provides functions to filter literals by resolution, paramodulation, positivity, negativity, maximality, and equation status, as well as logical combinations of these conditions. These criteria are used to control inference rules in automated theorem proving, such as restricting resolution or paramodulation steps to specific subsets of literals.",
      "description_length": 455,
      "index": 395,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.FormulaRename.S-C-Seq",
      "library": "libzipperposition",
      "description": "This module provides functions to extract literals, terms, and variables from a clause structure. It works with clauses (`C.t`), iterating over their components as sequences. Use it to analyze or transform clause content in theorem proving tasks, such as preprocessing or rule application.",
      "description_length": 289,
      "index": 396,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Saturate.S-Env",
      "library": "libzipperposition",
      "description": "This module orchestrates saturation-based automated reasoning through clause manipulation, logical inference, and simplification strategies. It operates on clauses, clause sets, proof states, and trails, employing inference rules, simplification procedures, and redundancy checks to manage proof search control. Key use cases include term rewriting, subsumption detection, prioritization of saturation rules, and lifecycle management of clauses during theorem proving.",
      "description_length": 468,
      "index": 397,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.Combinators.S-Env-StmQ",
      "library": "libzipperposition",
      "description": "This module implements a priority queue for managing streams of clauses with weighted priorities. It provides operations to add streams or lists of streams, inspect queue state, and extract clauses fairly or by priority, with controlled recursion depth. Concrete use cases include scheduling clause processing in automated theorem proving where streams represent different proof strategies with varying urgency.",
      "description_length": 411,
      "index": 398,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.ClauseQueue_intf.S-C-WithPos",
      "library": "libzipperposition",
      "description": "This module represents clauses with a specific subterm and its position, enabling precise term manipulation and analysis. It provides comparison and pretty-printing operations for these structured clauses. Useful for tasks like subterm indexing, rewriting, or focused proof search where positional context is critical.",
      "description_length": 318,
      "index": 399,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Eprover_interface.S-Env-ProofState-UnitIndex",
      "library": "libzipperposition",
      "description": "This module implements a term index for efficiently storing, retrieving, and manipulating sets of (in)equations during automated theorem proving. It supports operations like adding or removing equations, querying for matches under substitutions, and iterating over indexed terms. Use cases include clause indexing in resolution provers and efficient subsumption checks during proof search.",
      "description_length": 389,
      "index": 400,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.ProofState_intf.S-CQueue-WeightFun",
      "library": "libzipperposition",
      "description": "This module defines weight functions used to prioritize clauses in a queue based on specific heuristic criteria. It operates on clause data structures and supports concrete operations such as penalizing complex clauses, favoring goal-related or Horn clauses, and combining multiple weight metrics. Use cases include guiding automated theorem proving by influencing clause selection order based on logical structure and proximity to the proof goal.",
      "description_length": 447,
      "index": 401,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Lift_lambdas.S-Env-C-Seq",
      "library": "libzipperposition",
      "description": "This module provides functions to extract literals, terms, and typed variables from a given clause environment. It operates on clause structures and supports iteration over their components. Useful for analyzing or transforming logical expressions during proof search or term rewriting tasks.",
      "description_length": 292,
      "index": 402,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.ClauseQueue_intf.S-WeightFun",
      "library": "libzipperposition",
      "description": "This module defines weight functions that assign integer weights to clauses based on specific heuristic criteria. It supports operations like combining multiple weighted functions, favoring clause shapes (e.g., ground, Horn, all-negative), and measuring proximity to the initial goal. Use cases include guiding clause selection in automated theorem proving by prioritizing clauses with specific properties or structural features.",
      "description_length": 429,
      "index": 403,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Lift_lambdas.S-Env-ProofState",
      "library": "libzipperposition",
      "description": "Manages clause queues and indexed data structures for efficient retrieval and manipulation during automated theorem proving. Provides priority-based clause management via `CQueue`, term and unit indexing for fast subsumption checks, and set implementations for active, simplified, and passive clauses. Used to organize and process logical statements in saturation-based proof search.",
      "description_length": 383,
      "index": 404,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.Combinators.S-Env-Stm-Ctx-Lit",
      "library": "libzipperposition",
      "description": "This module manages bidirectional conversions between literals and formulas using customizable hooks. It provides functions to register and retrieve conversion hooks, as well as to perform the actual conversions between `Logtk.Literal.t` and `Logtk.SLiteral.t` types. It is used to integrate literal-level transformations within theorem proving or formula processing pipelines.",
      "description_length": 377,
      "index": 405,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Libzipperposition.ClauseQueue_intf.S-C",
      "library": "libzipperposition",
      "description": "This module provides operations for managing clause properties (redundancy, eligibility for inference rules), manipulating proof structures through trail-based reasoning and substitution application, and transforming clauses via grounding, \u03b7-reduction, and format conversion. It operates on clauses, trails, substitutions, and scoped terms, supporting use cases such as inference control, proof derivation, and debugging output in automated theorem proving contexts.",
      "description_length": 466,
      "index": 406,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.Saturate.S-Env-FormRename",
      "library": "libzipperposition",
      "description": "This module handles formula renaming and Skolemization during clause processing. It provides functions to rename logical formulas, detect renaming clauses, and introduce predicate Skolems with configurable freshness strategies. Key operations include `rename_form` for definition-based renaming and `get_skolem` for generating Skolem terms, working directly with clauses and formula structures. Use cases include managing formula equivalences and introducing fresh symbols during proof search.",
      "description_length": 493,
      "index": 407,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.Combinators.S-Env-ProofState-UnitIndex-E",
      "library": "libzipperposition",
      "description": "This module represents and compares indexed equations or inequations, providing a total order via `compare`, extracting term components with `extract`, and signaling usefulness through `priority`. It operates on pairs of terms paired with a boolean flag and a clause, returning term-rhs pairs with sign information. It is used to manage and prioritize equations during proof search or term indexing operations.",
      "description_length": 410,
      "index": 408,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.AC_intf.S-Env-ProofState-PassiveSet",
      "library": "libzipperposition",
      "description": "This module manages a set of passive clauses with operations to add, remove, and retrieve clauses, as well as track their state via signals. It works with clause data types (`C.t`) and structures like `ClauseSet.t` and `CQueue.t` to maintain the current set and processing queue. Concrete use cases include controlling clause insertion and removal during theorem proving, monitoring clause state changes, and selecting the next passive clause for processing in a proof search.",
      "description_length": 476,
      "index": 409,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.ProofState_intf.S-TermIndex",
      "library": "libzipperposition",
      "description": "This module organizes terms as keys in an indexed structure, enabling efficient insertion, deletion, and unification-driven queries to retrieve associated values, generalizations, or specializations using scoped terms and substitutions. It supports proof systems requiring dynamic term indexing by efficiently resolving unifiable elements, while its `to_dot` function generates graphical representations of the index for visualization in tools like Graphviz.",
      "description_length": 458,
      "index": 410,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Combinators.S-C",
      "library": "libzipperposition",
      "description": "This module provides operations for managing clause metadata (e.g., redundancy flags, origin tracking), identity checks (hashing, comparison), and property access (literals, weight) while supporting transformations like proof extraction, substitution application, and eligibility checks for inference rules. It operates on clauses (`C.t`), trails (`Trail.t`), and proof-related structures, enabling automated reasoning tasks such as resolution, paramodulation, and simplification. Specific use cases include clause analysis for Boolean subterms, eligibility filtering for rule application, and output formatting (e.g., TSTP) for interoperability with theorem proving tools.",
      "description_length": 673,
      "index": 411,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Combinators.S-Env-C-Seq",
      "library": "libzipperposition",
      "description": "This module provides functions to extract literals, terms, and variables from a clause environment. It operates on environments containing logical clauses and iterates over their components. Useful for analyzing or transforming logical expressions in automated reasoning tasks.",
      "description_length": 277,
      "index": 412,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Env_intf.S-Ctx-Lit",
      "library": "libzipperposition",
      "description": "This module manages bidirectional conversions between literals and formulas using customizable hooks. It provides functions to register and retrieve conversion hooks for transforming literals to and from terms, supporting dynamic extensions to the conversion process. The primary use case involves enabling seamless integration of custom literal representations with theorem proving or logic processing systems.",
      "description_length": 411,
      "index": 413,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.Lift_lambdas.S-Env-FormRename-Ctx-Lit",
      "library": "libzipperposition",
      "description": "This module manages bidirectional conversions between literals and formulas using customizable hooks. It provides functions to register and retrieve conversion hooks, and to convert between literal and formula representations. It works with `Logtk.Literal.t` and `Logtk.SLiteral.t` types, specifically handling atomic formulas during conversion. Use cases include integrating lambda-lifting transformations with theorem proving backends that require literal-based input.",
      "description_length": 470,
      "index": 414,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Sat_solver.S",
      "library": "libzipperposition",
      "description": "This module implements a SAT solver interface for managing clauses and literals, providing operations to add clauses, check satisfiability, and retrieve valuations, proofs, and decision levels. It works with clauses represented as lists of literals (`Lit.t`), valuation results, and proof structures. Concrete use cases include integrating with theorem provers to manage logical constraints, extracting proofs of unsatisfiability, and querying model assignments for literals after solving.",
      "description_length": 489,
      "index": 415,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Cut_form.FV_tbl",
      "library": "libzipperposition",
      "description": "This module implements a hash table that maps cut forms (modulo \u03b1-equivalence) to arbitrary values of type `X.t`. It supports standard operations like insertion, membership checking, and lookup, using cut forms as keys. The table is useful for managing associations between logical cut forms and attached data, such as annotations or computed properties, in a way that respects \u03b1-equivalence.",
      "description_length": 392,
      "index": 416,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Combinators.S-Env-FormRename",
      "library": "libzipperposition",
      "description": "This module handles formula renaming and Skolemization during clause processing. It provides operations to detect renaming clauses, introduce predicate Skolem symbols, and rename formulas based on context and polarity. Key use cases include managing formula definitions during proof search and controlling Skolem symbol generation in different modes like recycling or freshness.",
      "description_length": 378,
      "index": 417,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.Lift_lambdas.S-Env-C-Eligible",
      "library": "libzipperposition",
      "description": "This module defines eligibility criteria for selecting literals in a clause based on logical operations. It provides functions to filter literals by type (positive, negative, equations), role in inference rules (resolution, paramodulation), and their maximality within the clause. These criteria can be combined using logical operators to form complex conditions for literal selection in theorem proving contexts.",
      "description_length": 413,
      "index": 418,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Lift_lambdas.S-Env-C-WithPos",
      "library": "libzipperposition",
      "description": "This module represents clauses with a specific subterm and its position, enabling precise manipulation of terms within clauses. It provides comparison and pretty-printing operations for these structured clauses. Useful for tasks like term rewriting or focused proof search where tracking subterm positions is critical.",
      "description_length": 318,
      "index": 419,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Eprover_interface.S-Env-ProofState-TermIndex-Leaf",
      "library": "libzipperposition",
      "description": "This module implements a term index structure for efficient retrieval of terms during automated theorem proving. It supports operations to add, remove, and update indexed terms along with their associated values, and provides specialized folding functions for unification and matching queries. The index is used to accelerate proof search by enabling fast access to potentially matching terms based on structural properties.",
      "description_length": 424,
      "index": 420,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.ProofState_intf.S-TermIndex-Leaf",
      "library": "libzipperposition",
      "description": "This module implements a term index structure for efficient storage and retrieval of terms with associated values. It supports operations to add, remove, and update indexed terms, as well as iterate, fold, and query based on unification and matching. Use cases include managing clauses during automated theorem proving and enabling fast lookups for term-based reasoning tasks.",
      "description_length": 376,
      "index": 421,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Lift_lambdas.S-Env-ProofState-TermIndex",
      "library": "libzipperposition",
      "description": "This module provides operations for managing term indices that support efficient unification (including higher-order handling), generalization, and specialization of logical terms, paired with proof state elements (`C.WithPos.t`). It enables dynamic modification of indexed terms through addition, removal, and retrieval, with visualization capabilities via DOT format export for analysis or debugging.",
      "description_length": 402,
      "index": 422,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.StreamQueue_intf.S-Stm-C-WithPos",
      "library": "libzipperposition",
      "description": "This module defines a structure for representing clauses with a highlighted subterm and its position. It includes operations for comparing and pretty-printing these structured clauses. It is used to track specific subterm positions within clauses for tasks like proof reconstruction or term indexing.",
      "description_length": 300,
      "index": 423,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Stream.ARG-C-WithPos",
      "library": "libzipperposition",
      "description": "This module represents clauses with a specific subterm and its position, enabling precise term manipulation and analysis. It provides comparison and pretty-printing operations for these structured clauses. Useful for tasks like subterm indexing, rewriting, or focused proof search where positional context is critical.",
      "description_length": 318,
      "index": 424,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.ProofState_intf.S-C-Eligible",
      "library": "libzipperposition",
      "description": "This module defines a set of functions for determining which literals in a clause are eligible for various inference rules during automated theorem proving. It operates on clauses and literals, providing filters based on properties like positivity, negativity, maximality, and equation status, as well as logical combinations of these conditions. Use cases include selecting literals for resolution, paramodulation, or other rule applications in a prover's search process.",
      "description_length": 472,
      "index": 425,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Clause_intf.S-Ctx",
      "library": "libzipperposition",
      "description": "This module enables the management of logical contexts in theorem proving systems, offering operations to set and query term orderings, selection functions, skolemization contexts, and symbol signatures. It works with literals, clauses, and terms, supporting tasks such as injectivity analysis for function symbols, term comparison, and dynamic updates to symbols or signatures. These capabilities are essential for logical reasoning, term analysis, and clause manipulation in automated deduction workflows.",
      "description_length": 507,
      "index": 426,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Stream_intf.S-C-Eligible",
      "library": "libzipperposition",
      "description": "This module defines a set of functions and combinators for determining which literals in a clause are eligible for specific inference rules during automated theorem proving. It operates on clauses and literals, providing criteria to select literals based on their role in resolution, paramodulation, positivity, negativity, or maximality. Use cases include filtering eligible literals during clause processing in a superposition prover to control inference generation.",
      "description_length": 468,
      "index": 427,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Clause_intf.S-Pos",
      "library": "libzipperposition",
      "description": "Accesses a term at a specific position within a clause, returning the corresponding subterm. Works with clauses and positions to navigate term structures. Useful for precise term manipulation during proof search or clause transformation.",
      "description_length": 237,
      "index": 428,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.AC_intf.S-Env",
      "library": "libzipperposition",
      "description": "This module orchestrates logical inference and simplification workflows for automated reasoning by manipulating clauses, clause sets, and proof states through operations like redundancy elimination, term rewriting, and normalization. It manages dynamic rule registries (e.g., simplification, rewriting) and state transitions for clauses across active/passive lifecycles, leveraging trails and flex state for context-sensitive computations. Designed for saturation-based theorem proving, it enables applications in formal verification and logic programming by structuring proof search via prioritized simplification strategies and event-driven state updates.",
      "description_length": 657,
      "index": 429,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.Lift_lambdas.S",
      "library": "libzipperposition",
      "description": "This module implements lambda-lifting transformations on clauses, converting higher-order terms into first-order representations by eliminating lambda abstractions. It works with clauses and terms from the environment's type system, specifically transforming `C.t` structures through the `lift_lambdas` function. Use cases include preprocessing higher-order logic formulas into a format suitable for first-order theorem proving procedures.",
      "description_length": 439,
      "index": 430,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.Eprover_interface.S-Env-ProofState-module-type-CLAUSE_SET",
      "library": "libzipperposition",
      "description": "This module manages a dynamic set of clauses with signals for tracking additions and removals. It provides operations to add or remove multiple clauses at once using iterators. Useful for maintaining clause sets in automated theorem proving where changes need to be observed or reacted to in real time.",
      "description_length": 302,
      "index": 431,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Clause_intf.S-Ctx-Lit",
      "library": "libzipperposition",
      "description": "This module manages bidirectional conversions between literals and their formula representations using customizable hooks. It provides functions to register and retrieve conversion hooks for transforming literals to and from atomic formulas, along with direct conversion operations that enforce atomicity constraints. It works with `Logtk.Literal.t` and `Logtk.SLiteral.t` types, supporting use cases like integrating custom literal encodings or decoding external logic representations.",
      "description_length": 486,
      "index": 432,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.StreamQueue.ARG-Stm-C-WithPos",
      "library": "libzipperposition",
      "description": "Represents a clause with a specific subterm and its position within the term structure. Provides comparison and pretty-printing operations for clauses annotated with subterm positions. Useful for tracking term occurrences in proof search or term indexing tasks.",
      "description_length": 261,
      "index": 433,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Env.Make",
      "library": "libzipperposition",
      "description": "This module orchestrates automated reasoning by integrating core proof search mechanisms with specialized submodules for clause management, prioritization, and logical transformations. It operates on clauses, clause sets, and proof states, supporting inference, simplification, subsumption, and higher-order normalization through dynamic rewriting and predicate elimination. Submodules handle skolemization, formula renaming, weighted clause scheduling, subterm addressing, and state organization, enabling tasks like clausification, constraint solving, and heuristic-driven prioritization of Horn clauses. Specific operations include converting formulas with `of_form`, prioritizing streams using custom weight functions, extracting literals by position, and managing active/passive clause sets with term indexes and hit counters.",
      "description_length": 831,
      "index": 434,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.Cut_form",
      "library": "libzipperposition",
      "description": "This module handles the construction and manipulation of logical formulas built from clauses and variables, supporting operations like substitution, normalization, and alpha-equivalence checking. It works with the `Cut_form.t` structure, integrating terms and literals from `Logtk`, and includes submodules for positional term access, term extraction, and \u03b1-equivalence-based hash tables. You can use it to rewrite terms in place, extract formula components with positional data, or associate metadata with normalized forms. Example workflows include transforming logical expressions, analyzing term structure, and caching results based on formula equivalence.",
      "description_length": 660,
      "index": 435,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Ctx_intf",
      "library": "libzipperposition",
      "description": "The module defines a context interface for managing proof search in automated theorem provers, offering operations to add and query clauses, handle substitutions, and track proof states. It integrates term and symbol context management, supporting skolemization, term ordering, and injectivity checks, while enabling literal comparison and traversal through the `Lit` module. Bidirectional literal-to-formula conversions are handled via customizable hooks, allowing dynamic extensions during proof search. This combination supports tasks like clause normalization, logical reasoning, and term-based formula manipulation in resolution-based provers.",
      "description_length": 648,
      "index": 436,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.ClauseContext",
      "library": "libzipperposition",
      "description": "This module represents clauses with a single term placeholder and provides operations to create, modify, and apply these contexts, working with literals, terms, and substitutions. It supports extracting contexts from literals, applying terms to fill holes, and comparing or hashing contexts, enabling manipulation of logical clauses during theorem proving, such as generalizing or specializing clauses while managing variable scope. The child module extends this by offering ordered set operations over these contexts, supporting union, intersection, traversal, and transformations, making it possible to manage collections of clause contexts with deterministic ordering and efficient membership checks. Together, they enable structured manipulation and set-theoretic processing of clause contexts in automated reasoning workflows.",
      "description_length": 831,
      "index": 437,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.StreamQueue_intf",
      "library": "libzipperposition",
      "description": "This module organizes a priority-based structure for managing and retrieving elements based on dynamic weighting and logical constraints. It centers on a priority queue that maintains streams of clauses, guided by weight functions, eligibility criteria, and penalty calculations to ensure efficient and semantically meaningful processing. Users can prioritize inference results, convert literals using customizable hooks, and manage logical contexts with skolemization and signature tracking. Additional capabilities include ordered clause sets, term indexing, and subterm tracking, enabling precise control over automated reasoning workflows and stream-based evaluations.",
      "description_length": 672,
      "index": 438,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.AC_intf",
      "library": "libzipperposition",
      "description": "This module defines the core structures and operations for working with AC (associative-commutative) term matching and rewriting, centered around the `spec` type and the `S` signature. It enables term equivalence checking under AC properties, subterm analysis, and normalization, supporting tasks like simplification and inference in equational logic and automated theorem proving. Submodules provide specialized functionality for clause manipulation, term indexing, literal conversion, priority-based clause scheduling, and proof state management, enabling precise control over term structure, logical context, and inference strategies. Examples include tracking term positions for rewriting, prioritizing clauses during proof search, converting literals to atomic formulas, and managing AC-aware term indices for efficient unification and subsumption checks.",
      "description_length": 860,
      "index": 439,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Bool_selection",
      "library": "libzipperposition",
      "description": "This module defines selection functions for choosing boolean subterms in logical expressions, based on ordering and eligibility criteria. It operates on terms and literals, using term positions to identify selected subterms. Concrete use cases include guiding resolution or superposition proofs by selecting specific subterms for inference steps.",
      "description_length": 346,
      "index": 440,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Stream_intf",
      "library": "libzipperposition",
      "description": "The module defines a stream interface for creating, transforming, and consuming sequences of values with lazy evaluation and iterative processing, using core operations like `map`, `filter`, and `fold`. It integrates submodules that extend stream functionality for specialized domains: one implements streams with identifiers and mutable state for theorem proving, supporting incremental extraction with `drip`, while others handle logical context management, literal-term conversion, and imperative hash tables for structured data processing. Additional submodules enable term traversal, clause component streaming, and inference rule eligibility checks, supporting concrete tasks like parsing formulas, analyzing clause structure, and managing proof states with positional precision. Together, these components provide a framework for efficient, on-demand data and logic processing across theorem proving and general-purpose streaming workflows.",
      "description_length": 947,
      "index": 441,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.SimplM",
      "library": "libzipperposition",
      "description": "This module provides a monadic framework for composing simplification steps that track whether each transformation produces a new value or leaves the original unchanged. It supports operations like bind, map, and fold, enabling precise control over iterative simplification processes on arbitrary types wrapped in the `t` monadic structure. The module includes infix operators for sequencing computations (`>>=`) and applying pure transformations (`>|=`), facilitating concise expression of stateful simplification pipelines. Together, these features allow building complex, change-aware simplification logic for tasks like theorem proving.",
      "description_length": 640,
      "index": 442,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.ProofState",
      "library": "libzipperposition",
      "description": "This module coordinates the management of logical clauses and term structures during proof search, organizing them into active, passive, and prioritized sets. It supports key operations such as subsumption checking, clause retrieval, and heuristic prioritization, using data types like clauses, term indices, and priority queues. Submodules enable change tracking, subsumption hierarchies, and indexed term queries for unification. Examples include dynamically updating clause sets, removing redundancies, guiding proof strategies via priority selection, and visualizing term relationships.",
      "description_length": 590,
      "index": 443,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Clause_intf",
      "library": "libzipperposition",
      "description": "This module centers on the representation and manipulation of logical clauses for automated theorem proving, offering core data types for clauses, literals, and proofs alongside operations for their construction, transformation, and analysis. It supports precise control over clause content through ordered sets, literal eligibility, term positions, and traversal iterators, enabling tasks like resolution, paramodulation, and proof extraction. Submodules enhance this functionality with structured contexts, metadata handling, term indexing, and customizable conversions between literals and formulas. Examples include filtering literals based on logical properties, navigating and rewriting subterms, managing proof trails, and converting between internal and external logic representations.",
      "description_length": 793,
      "index": 444,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Env_intf",
      "library": "libzipperposition",
      "description": "The environment interface manages state and configuration in a theorem prover, coordinating proof contexts, term transformations, and parameter access. It integrates modules for clause sets, streams, and queues that enable dynamic management and prioritization of logical statements, alongside indices and conversion hooks for term manipulation and formula translation. You can use it to track clause additions with signals, prioritize proof goals using heuristic weight functions, or unify terms through indexed structures. Specific operations include extracting subterms from clauses, managing logical inference rules, and visualizing term relationships via DOT output for debugging proof states.",
      "description_length": 698,
      "index": 445,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Clause",
      "library": "libzipperposition",
      "description": "This module manages hashconsed clauses with support for conditional guards through trails, enabling efficient sharing and context-dependent clause manipulation. It provides core operations for creating and managing clauses, while its child modules enhance reasoning tasks with features like eligibility checks, literal selection, and subsumption, along with hash table utilities for efficient data aggregation. Submodules allow precise clause analysis through positional term access and iteration, supporting advanced operations like resolution and paramodulation. Example uses include guiding inference steps by selecting literals, extracting subterms during proof search, and managing clause state in a theorem prover.",
      "description_length": 720,
      "index": 446,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.Ctx",
      "library": "libzipperposition",
      "description": "This module maintains logical contexts for literals and clauses during theorem proving, supporting operations to add, retrieve, and manage clauses and literals efficiently. It integrates a state key to track completeness during inference steps and a set of core parameters that define logical signature, term ordering, and clause selection strategies. The context system manages term orderings, signature manipulation, and skolemization, with a dedicated Lit submodule for converting between literals and formulas using customizable hooks. These features enable tasks like automating proof search, transforming terms during normalization, and implementing custom literal encodings for indexing and unification.",
      "description_length": 710,
      "index": 447,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.SClause",
      "library": "libzipperposition",
      "description": "This module provides operations for constructing and modifying logical clauses, with support for identity checks, trail management, and flag-based metadata manipulation. It works with literals, trails, and boolean flags to enable redundancy detection, backward simplification, and proof transformation, including converting clauses to logical formulas and formatting output in TPTP/TSTP. The child module enhances clause management by implementing an ordered set structure for term pairs with positional annotations, supporting efficient membership checks, ordered traversal, and set operations. Together, they enable structured querying, iterative refinement, and customizable serialization of logical terms during theorem proving.",
      "description_length": 732,
      "index": 448,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.Bool_lit",
      "library": "libzipperposition",
      "description": "This module represents boolean literals with arbitrary payloads, enabling the creation, comparison, and transformation of truth-valued data structures with attached information. It supports operations like negation, sign manipulation, and normalization, along with set-like structures for union and intersection, and hash tables for key-based aggregation. You can use it to model logical expressions with metadata, perform symbolic computations, or manage structured key-value mappings indexed by boolean terms. The combination of direct literal operations and set and hash table submodules provides a foundation for theorem proving, logical analysis, and data grouping tasks.",
      "description_length": 676,
      "index": 449,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Const",
      "library": "libzipperposition",
      "description": "Contains constants and configuration settings used throughout the library, including the version string and logging section identifiers. It supports logging and debugging by providing predefined section tags for consistent message categorization. Useful for maintaining uniformity in log output across different components.",
      "description_length": 323,
      "index": 450,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Lift_lambdas",
      "library": "libzipperposition",
      "description": "This module transforms lambda terms into first-order representations by eliminating bound variables through lambda lifting, directly supporting higher-order logic preprocessing in automated theorem proving. It provides core operations to lift lambda expressions into combinators, enabling integration with first-order provers, while child modules extend this foundation with clause management, indexing, priority queues, and term analysis tools. Specific capabilities include skolemization, literal eligibility checks, subterm access, weight functions, and lambda-aware conversions between literals and formulas, all structured around efficient data types like ordered clause sets, hash tables, and streams. These components collectively enable tasks such as proof search, clause prioritization, term rewriting, and resolution-based reasoning in systems handling both first-order and higher-order logic.",
      "description_length": 903,
      "index": 451,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.StreamQueue",
      "library": "libzipperposition",
      "description": "This module organizes a priority-driven system for managing streams of logical clauses, using dynamic heuristics to balance fairness and efficiency in proof search. It centers on a priority queue that adjusts stream weights based on factors like clause age and selection ratio, working with streams (`Stm.t`, `Stm.C.t`) and state keys to guide automated reasoning. Submodules support stream manipulation, term access by position, hash tables for stream elements, and set operations over clauses, enabling tasks like term traversal, eligibility filtering, and metadata management. Examples include prioritizing clause processing with custom weight functions, extracting literals for resolution, and maintaining indexed clause sets for efficient logical transformations.",
      "description_length": 768,
      "index": 452,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Trail",
      "library": "libzipperposition",
      "description": "This module implements a trail data structure representing sets of boolean literals, supporting set-theoretic operations like union, subset checks, and filtering alongside logical transformations. It provides analysis tools for consistency verification, emptiness checks, and valuation-based satisfaction evaluation, with conversions to logical formulas. Designed for SAT/SMT applications, it facilitates trail composition, constraint propagation, and formula simplification tasks.",
      "description_length": 481,
      "index": 453,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.Cover_set",
      "library": "libzipperposition",
      "description": "This module manages cover sets for inductive reasoning, enabling the construction and manipulation of case distinctions over terms by integrating inductive constants, types, and term structures. It supports operations to generate subcases, retrieve declarations, and print structured case representations, while its child module represents individual inductive cases with support for comparison, hashing, and extraction of terms and constants. Use cases include analyzing inductive structures, checking recursion status, and introducing skolem variables during proof search. Together, the module and its submodules provide a structured approach to case analysis by combining high-level cover set manipulation with detailed case-level operations.",
      "description_length": 745,
      "index": 454,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Ind_cst",
      "library": "libzipperposition",
      "description": "This module manages ordered sets of constants with efficient functional operations, supporting membership tests, set algebra, and ordered traversal. It provides data types for sets and operations like union, intersection, and difference, along with mapping, filtering, and folding over sorted elements. Users can perform symbolic computations, query sets with predicates, or convert sets to custom string representations. Submodules enhance this core functionality with specialized transformations and utilities for structured data manipulation.",
      "description_length": 545,
      "index": 455,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.Env",
      "library": "libzipperposition",
      "description": "This module enables automated reasoning by combining proof search with clause management, prioritization, and logical transformations. It operates on clauses, clause sets, and proof states, supporting inference, simplification, subsumption, and higher-order normalization through dynamic rewriting and predicate elimination. Specific operations include converting formulas with `of_form`, prioritizing streams using custom weight functions, extracting literals by position, and managing active/passive clause sets with term indexes and hit counters. Submodules handle skolemization, formula renaming, weighted scheduling, and subterm addressing to support clausification and heuristic-driven Horn clause prioritization.",
      "description_length": 719,
      "index": 456,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Extensions",
      "library": "libzipperposition",
      "description": "This module manages dynamic extensions for a theorem prover, allowing plugins to register custom actions at various stages of the proof process. It supports operations like modifying clause normal forms, adjusting term orderings, and interacting with the prover's context and environment. Extensions can be registered, retrieved by name, or listed, enabling modular and configurable theorem proving workflows.",
      "description_length": 409,
      "index": 457,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Sat_solver_intf",
      "library": "libzipperposition",
      "description": "This module defines the interface for a SAT solver, including types for proof steps, proofs, and solver results, and supports operations to check satisfiability of logical formulas and produce proofs when unsatisfiable. It operates on propositional literals (`Lit.t`), clauses, and sets of literals, allowing integration with theorem provers for clause learning or conflict analysis. The implementation supports adding clauses in various forms, extracting valuation models, decision levels, and resolution proofs, enabling use cases such as formal verification and logical constraint management. Together, the interface and its implementation provide a foundation for building and querying logical solvers with detailed proof and model tracking capabilities.",
      "description_length": 758,
      "index": 458,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.ClauseQueue_intf",
      "library": "libzipperposition",
      "description": "This module organizes clause management in automated theorem proving through a priority queue interface that supports configurable selection strategies like breadth-first or goal-oriented exploration. It provides core operations to insert clauses with priorities and retrieve them according to active profiles, while integrating submodules that define priority functions, eligibility criteria for literals, and weight-based heuristics to influence selection. Additional components handle literal and term extraction, ordered set transformations, and subterm-based analysis, enabling precise clause manipulation and analysis during proof search. It also supports imperative hash tables for clause metadata tracking, term ordering configuration, and integration with formula representations for flexible logical transformations.",
      "description_length": 826,
      "index": 459,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.ClauseQueue",
      "library": "libzipperposition",
      "description": "This module organizes and prioritizes logical clauses using a customizable queue system, where selection strategies can be dynamically configured through weight functions and coefficients. It supports operations to add, select, and remove clauses based on heuristics such as age, weight, or goal-oriented criteria, enabling strategies like FIFO processing or favoring ground and negative clauses. The module allows fine-grained control over prioritization profiles and integrates customizable comparison logic to guide proof search effectively. Example uses include selecting the most promising clauses for expansion in automated theorem proving or managing clause eviction based on dynamic thresholds.",
      "description_length": 702,
      "index": 460,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.BBox",
      "library": "libzipperposition",
      "description": "This module manages boolean literals with embedded payloads such as clauses and lemmas, organizing them into hierarchical logical structures like `BBox.t` and `Lit.t` for use in proof systems. It supports operations including splitting, injection, sign manipulation, normalization, and conversion into typed first-order logic formulas for output in formats like TSTP or ZF. Child modules provide ordered collections and imperative hash tables for efficient set operations, traversal, filtering, and aggregation of literals. Examples include negating literals, tracking lemma occurrences, normalizing expressions in a SAT solver, or extracting signed propositions during theorem proving.",
      "description_length": 686,
      "index": 461,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.Saturate",
      "library": "libzipperposition",
      "description": "The module orchestrates saturation-based automated reasoning by combining core algorithmic control with rich infrastructure for clause management, indexing, and logical context manipulation. It processes clauses through inference and simplification rules, maintaining active and passive sets to drive proof search toward contradiction or resource exhaustion, while submodules handle clause sets with signals, priority queues, term indexing, and stream processing to enable efficient retrieval and dynamic updates. Key data types include clauses with literals, terms, substitutions, and proof states, with operations for eligibility filtering, weight computation, subsumption, and bidirectional formula conversion. Users can implement theorem provers with customizable clause selection strategies, perform paramodulation and resolution inferences, manage logical context with skolemization and term orderings, and track clause lifecycle events for debugging or heuristic refinement.",
      "description_length": 981,
      "index": 462,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Eprover_interface",
      "library": "libzipperposition",
      "description": "This module orchestrates communication with the E theorem prover through string-based I/O channels, enabling query submission and response parsing within automated verification workflows. It provides core utilities for managing clause sets, defining weight and priority functions, and controlling literal eligibility, while supporting term manipulation, indexing, and logical context management through specialized submodules. Users can configure proof search strategies using priority queues, perform subsumption checks with indexed clauses, and transform logical literals using customizable conversion hooks. Concrete tasks include guiding clause selection via heuristic weighting, tracking dynamic clause sets with change signals, and integrating E-based proof steps into larger reasoning pipelines.",
      "description_length": 802,
      "index": 463,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Signals",
      "library": "libzipperposition",
      "description": "This module defines signals triggered at key points during execution, such as before processing a file, when printing statistics, on exit, and when activating dot output. It works with unit and integer signals, as well as string-valued signals for file names. These signals allow external code to hook into the solver's lifecycle for logging, profiling, or output customization.",
      "description_length": 378,
      "index": 464,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.Params",
      "library": "libzipperposition",
      "description": "This module manages configuration parameters for a theorem proving system, handling command-line arguments, default settings, and mode-specific initialization. It works with strings, integers, floats, options, and vectors to store and manipulate settings like selection functions, file paths, proof checking options, and resource limits. Concrete use cases include parsing command-line flags to control proof search behavior, setting timeouts, enabling proof output in DOT format, and configuring definition expansion or interreduction strategies.",
      "description_length": 547,
      "index": 465,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.ProofState_intf",
      "library": "libzipperposition",
      "description": "This module defines an interface for managing proof states in automated reasoning systems, supporting operations to track and manipulate logical formulas, clauses, and inference rules. It coordinates dynamic clause sets, logical contexts, and term indexing structures to maintain state during saturation-based theorem proving and proof search. Key data types include clauses, literals, terms, substitutions, and priority queues, with operations for adding and removing clauses, tracking changes via signals, comparing and prioritizing equations, and managing logical contexts with term orderings and skolemization. Examples include using priority functions to guide clause selection, applying subsumption checks to eliminate redundant clauses, and leveraging term indices for efficient unification-driven lookups during inference.",
      "description_length": 830,
      "index": 466,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Bool_lit_intf",
      "library": "libzipperposition",
      "description": "This module combines boolean literal handling with efficient data management through its submodules. It supports creation, negation, and comparison of boolean literals, while the Tbl submodule enables hash table operations for key-value storage with customizable merging. The Lit submodule extends literals with sign and payload, enabling advanced logic systems like SAT solvers. Examples include tracking variable frequencies, simplifying logical constraints, and normalizing expressions with efficient set and table integration.",
      "description_length": 530,
      "index": 467,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Sat_solver",
      "library": "libzipperposition",
      "description": "This module provides a SAT solver interface that supports adding clauses, checking satisfiability, and extracting valuations, proofs, and decision levels for literals. It works with propositional logic formulas represented as lists of literals (`Lit.t`), and includes operations to control proof generation, retrieve proof steps, and inspect solver state. Users can validate logical formulas, generate counterexamples, or produce resolution proofs for unsatisfiable instances. It integrates with theorem provers by managing logical constraints, querying model assignments, and exporting proofs of unsatisfiability.",
      "description_length": 614,
      "index": 468,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.Selection",
      "library": "libzipperposition",
      "description": "This module implements literal selection strategies for automated theorem proving, focusing on criteria like term ordering, clause classification (e.g., Horn, range-restricted), and complexity metrics. It operates on arrays of logical literals (`Logtk.Literal.t array`) paired with bitmasks (`CCBV.t`) to track selected elements, offering methods to prioritize maximal, negative, or ground literals, along with specialized handling for rewrite rules and higher-order logic clauses. These mechanisms guide clause processing in proof search, particularly in systems requiring integration with E prover-compatible strategies or higher-order reasoning.",
      "description_length": 648,
      "index": 469,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.FormulaRename",
      "library": "libzipperposition",
      "description": "This module performs variable renaming and skolemization in logical formulas, ensuring safe substitution and avoiding variable capture during transformations. It operates on first-order logic expressions, providing functions to rename variables, introduce skolems, and normalize formulas, with support for clause-based transformations and definition extraction. Submodules enable positional term access, clause metadata management, literal eligibility checks, and structured clause set manipulations, facilitating tasks like resolution, paramodulation, and proof trace generation. Examples include normalizing variable bindings before unification, extracting definitions during clausification, and managing ordered clause sets for automated reasoning workflows.",
      "description_length": 761,
      "index": 470,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Combinators_base",
      "library": "libzipperposition",
      "description": "This module implements combinatory logic transformations and optimizations for terms in a formal logic system. It provides functions to construct specific combinator terms (S, B, C, K, I) and applies optimization rules for currying, B-under, and narrowing. These operations are used to normalize and compare complex logical expressions, particularly during theorem proving or term rewriting tasks.",
      "description_length": 397,
      "index": 471,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.Classify_cst",
      "library": "libzipperposition",
      "description": "This module classifies constants based on their role in inductive reasoning, distinguishing constructors, projectors, defined constants, parameters, and other categories. It operates on identifiers (`ID.t`) and inductive type structures, providing functions to determine roles such as whether an identifier is a constructor, projector, or defined constant. Use cases include guiding term ordering and inductive reasoning during automated theorem proving.",
      "description_length": 454,
      "index": 472,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.Bool_clause",
      "library": "libzipperposition",
      "description": "This module represents and manipulates boolean clauses, which are lists of boolean literals. It provides functions to construct proof results from clauses, extract clauses from proof results, and handle clause-based logic operations. It is used in formal verification tasks where boolean constraints must be tracked and resolved during proof search.",
      "description_length": 349,
      "index": 473,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Combinators",
      "library": "libzipperposition",
      "description": "This module provides higher-order term combination and manipulation functions essential for superposition-based theorem proving, enabling advanced rewriting and inference operations on terms and formulas. It supports custom inference rules and logical expression transformations, with core data types including terms, clauses, literals, and proof structures, and operations such as substitution, eligibility filtering, and term indexing. Submodules manage dynamic clause sets, priority queues, weight functions, and term indexing, allowing efficient clause retrieval, prioritization, and metadata tracking during proof search. Specific capabilities include subsumption checking, eligibility-based literal selection, trail analysis, and environment-driven term transformations, all structured around immutable and imperative data types like `C.t`, `ClauseSet.t`, and `Env.CQueue.t` to support both functional and stateful theorem proving workflows.",
      "description_length": 947,
      "index": 474,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition.Stream",
      "library": "libzipperposition",
      "description": "This module implements lazy streams of clauses with support for mapping, filtering, and merging, enabling efficient processing of infinite sequences in automated reasoning workflows. It integrates clause manipulation, term ordering, and stream-based transformations, offering operations to analyze, transform, and prioritize clauses based on logical properties, term structure, and heuristic metrics. Key data types include clauses (`C.t`), term streams, clause sets (`ClauseSet.t`), and literal eligibility criteria, with operations spanning proof derivation, normalization, literal selection, and subterm extraction. Examples include tracking inference results with prioritized streams, rewriting terms using positional context, and refining clause sets through ordered traversal and filtering.",
      "description_length": 796,
      "index": 475,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition.AC",
      "library": "libzipperposition",
      "description": "This module implements AC redundancy checks and simplifications for equational reasoning, combining term and clause analysis with AC theory properties to enhance proof search in superposition-based theorem proving. It provides operations to normalize terms modulo AC, detect and remove redundant or trivial clauses, and apply resolution or paramodulation with AC-aware eligibility tracking. Examples include rewriting equations involving addition or multiplication symbols, filtering out clauses that are trivial under AC properties, and simplifying input clauses during automated proof search. Submodules extend these capabilities with advanced literal analysis, redundancy control, and structured traversal of clauses during reasoning.",
      "description_length": 737,
      "index": 476,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition",
      "library": "libzipperposition",
      "description": "This library provides a comprehensive framework for automated theorem proving and logical reasoning, centered around the manipulation of clauses, literals, terms, and formulas. It supports core operations such as substitution, normalization, unification, skolemization, and AC-aware rewriting, with data structures like priority queues, streams, hashconsed clauses, and trail-based state tracking enabling efficient proof search and simplification pipelines. Users can perform resolution, paramodulation, and superposition inferences, manage logical contexts with term orderings and selection functions, and integrate SAT/SMT solvers for constraint analysis. Specific applications include transforming higher-order logic into first-order representations, prioritizing clauses based on dynamic heuristics, and managing inductive reasoning through cover sets and constructor classification.",
      "description_length": 888,
      "index": 477,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_avatar.UnionFind.PAIR",
      "library": "libzipperposition.avatar",
      "description": "This module implements a union-find data structure for managing equivalence classes of key-value pairs, where keys support hashing and equality checks, and values form a commutative monoid under the `merge` operation with `zero` as the identity. It is suitable for scenarios like merging symbolic expressions or combining annotated data in constraint solving.",
      "description_length": 359,
      "index": 478,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_avatar.UnionFind.Make",
      "library": "libzipperposition.avatar",
      "description": "Implements a union-find data structure with monoidal value aggregation for managing equivalence classes of keys. It supports operations like merging classes, querying class representatives, and accumulating values associated with each class. Useful for constraint solving or equivalence reasoning where elements are grouped dynamically and values must be merged according to a monoid.",
      "description_length": 384,
      "index": 479,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_avatar.S-E-ProofState-UnitIndex",
      "library": "libzipperposition.avatar",
      "description": "This module implements an index for managing and querying a collection of logical (in)equations within a proof state. It supports operations to add, remove, and retrieve indexed terms, with specialized retrieval for matching or generalizing query terms under substitutions. The index is used to efficiently find relevant equations during automated reasoning tasks, such as clause subsumption or rewriting.",
      "description_length": 405,
      "index": 480,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_avatar.UnionFind",
      "library": "libzipperposition.avatar",
      "description": "This module provides an imperative union-find structure for managing dynamic equivalence classes of hashable keys, where each class maintains an aggregated value using a user-defined monoid. It supports efficient union and find operations with path compression, along with value merging during set unions, enabling incremental computation of combined values. The structure is ideal for unification algorithms and constraint propagation systems where both equivalence relations and value aggregation evolve dynamically. For example, it can merge symbolic expressions with associated weights or combine annotated data under constraints.",
      "description_length": 634,
      "index": 481,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_avatar.S-E-Ctx",
      "library": "libzipperposition.avatar",
      "description": "This module provides operations for logical reasoning and term analysis, focusing on equality constraints, term ordering, and symbol properties. It works with function symbols, logical literals (via the Lit module), and contexts for skolemization, selection functions, and signature changes. Specific use cases include automated theorem proving tasks like equality reasoning, term normalization, and injectivity analysis for argument positions in function symbols.",
      "description_length": 464,
      "index": 482,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_avatar.S-E-StmQ",
      "library": "libzipperposition.avatar",
      "description": "This module implements a priority queue for managing streams with weighted priorities, supporting operations to add streams, extract clauses fairly or under a guard, and inspect queue state. It works with streams and clauses, using a customizable weight function to prioritize streams. Concrete use cases include scheduling clause extraction from multiple streams in a theorem proving context, ensuring fairness or bounded resource usage.",
      "description_length": 438,
      "index": 483,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_avatar.S-E-ProofState-UnitIndex-E",
      "library": "libzipperposition.avatar",
      "description": "This module represents and manipulates indexed equations, providing a total order via `compare`, extraction of equation components with `extract`, and a utility `priority` function. It operates on terms and clauses from the Logtk library, tracking equality or inequality between terms. Useful for indexing and prioritizing equations during automated theorem proving.",
      "description_length": 366,
      "index": 484,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_avatar.S-E-ProofState-CQueue-WeightFun",
      "library": "libzipperposition.avatar",
      "description": "This module defines weight functions that assign integer weights to clauses in a proof state's queue, influencing the priority of clauses during automated reasoning. It supports operations like parsing weight function descriptions, combining multiple weight functions with coefficients, and applying domain-specific heuristics such as favoring ground or Horn clauses, penalizing certain clause forms, or prioritizing clauses closer to the goal. Use cases include guiding the clause selection strategy in a theorem prover to optimize proof search.",
      "description_length": 546,
      "index": 485,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_avatar.S-E-ProofState-TermIndex",
      "library": "libzipperposition.avatar",
      "description": "This module implements a term index for managing logical terms paired with metadata such as clauses and positions, supporting efficient insertion, removal, and dynamic updates. It enables advanced querying operations like higher-order unification, generalization, and specialization using pattern and substitution-based matching, optimized for proof state scenarios requiring rapid access to related terms. A visualization function outputs the index structure in DOT format, facilitating analysis and debugging of term relationships during theorem proving workflows.",
      "description_length": 566,
      "index": 486,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_avatar.S-E-C-Pos",
      "library": "libzipperposition.avatar",
      "description": "Retrieves a subterm at a specified position within a given term. Works with terms and positions represented by `Logtk.Term.t` and `Logtk.Position.t` types. Useful for precise term manipulation in theorem proving or term rewriting systems.",
      "description_length": 238,
      "index": 487,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_avatar.S-E-Ctx-Lit",
      "library": "libzipperposition.avatar",
      "description": "This module manages bidirectional conversions between literals and formulas using customizable hooks. It provides functions to register and retrieve conversion hooks for transforming literals to formulas and vice versa, as well as direct conversion functions that apply these hooks. It works with `Logtk.Literal.t` and `Logtk.Term.t Logtk.SLiteral.t` types, enabling integration of different literal representations in theorem proving or logic processing tasks.",
      "description_length": 461,
      "index": 488,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_avatar.S-E-ProofState-PassiveSet",
      "library": "libzipperposition.avatar",
      "description": "This module manages a set of logical clauses with operations to add, remove, and retrieve clauses, while providing signals for tracking changes. It works with clause sets and a clause queue, supporting dynamic updates and passive clause processing. Concrete use cases include maintaining the current set of clauses during theorem proving and managing clause selection in saturation-based reasoning.",
      "description_length": 398,
      "index": 489,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_avatar.S-E-ProofState-SimplSet",
      "library": "libzipperposition.avatar",
      "description": "This module manages a dynamic set of clauses with signals for tracking additions and removals. It provides functions to add or remove multiple clauses using iterators and supports event-driven updates through signal handlers. It is used in proof state management to maintain and react to changes in clause sets during automated reasoning tasks.",
      "description_length": 344,
      "index": 490,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_avatar.S-E-Stm",
      "library": "libzipperposition.avatar",
      "description": "This module implements a stream management system for handling sequences of clauses in a theorem proving context. It provides operations to create, compare, and manipulate streams, including retrieving elements, tracking access attempts, and applying penalties for heuristic adjustments. Use cases include managing inference streams during proof search, where streams represent sequences of derived clauses that can be incrementally processed and prioritized.",
      "description_length": 459,
      "index": 491,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_avatar.S-E-ProofState-TermIndex-Leaf",
      "library": "libzipperposition.avatar",
      "description": "This module implements a term index for efficient insertion, removal, and unification-based querying of logical terms in proof states. It supports operations like adding or removing elements by term, iterating over indexed entries, and performing unification or matching queries with substitution tracking. It is used to manage and search collections of terms during automated reasoning tasks such as clause processing or inference.",
      "description_length": 432,
      "index": 492,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_avatar.S-E-C",
      "library": "libzipperposition.avatar",
      "description": "This module supports operations for managing, analyzing, and transforming clauses (`E.C.t`) in automated reasoning systems, focusing on proof search and clause classification. It provides utilities for manipulating clause metadata (e.g., redundancy flags, penalties), inspecting proofs and substitutions (`Logtk.Subst.t`), and determining eligibility for inference rules, while also enabling conversions between clause representations (e.g., TSTP format) and normalization tasks like groundness checks or eta-reduction. Key use cases include theorem proving, clause filtering in saturation-based algorithms, and integration with external proof assistants via standardized output formats.",
      "description_length": 687,
      "index": 493,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_avatar.S-E-ProofState-CQueue-C",
      "library": "libzipperposition.avatar",
      "description": "This module provides functionality for managing and analyzing clauses in automated reasoning workflows, focusing on metadata tracking (e.g., redundancy, simplification status), trail and proof manipulation, structural analysis (depth, literal eligibility), and transformations (substitution, grounding). It operates on clauses represented as `E.ProofState.CQueue.C.t`, alongside literals, substitutions, and scoped structures, supporting tasks like resolution-based inference, proof trail optimization, and debugging output generation. Specific use cases include redundancy checking, literal selection for paramodulation, and TSTP-compliant proof serialization.",
      "description_length": 661,
      "index": 494,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_avatar.S-E-C-Eligible",
      "library": "libzipperposition.avatar",
      "description": "This module defines a set of functions for determining which literals in a clause are eligible for specific inference rules during automated theorem proving. It operates on clauses and literals, providing criteria to select literals based on their role in resolution, paramodulation, positivity, negativity, or equation status. Use cases include filtering literals for inference steps, combining eligibility conditions with logical operators, and selecting maximal or equation literals for clause processing.",
      "description_length": 508,
      "index": 495,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_avatar.S-E-C-Tbl",
      "library": "libzipperposition.avatar",
      "description": "This module supports imperative manipulation of hash tables with keys of type `E.C.Tbl.key` and values of arbitrary type `'a`, offering operations for insertion, deletion, lookup, and in-place updates. It emphasizes bulk transformations with custom aggregation logic, enabling efficient frequency counting, sequence-based construction, and conflict resolution during merges. Use cases include managing dynamic key-value datasets, aggregating data streams with user-defined combinators, and debugging via customizable table serialization.",
      "description_length": 537,
      "index": 496,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_avatar.S-E-C-ClauseSet",
      "library": "libzipperposition.avatar",
      "description": "This module supports standard set operations for ordered collections of clauses, including creation, membership checks, insertion, deletion, union, intersection, and difference, alongside higher-order transformations like map and fold. It works with ordered sets (`E.C.ClauseSet.t`) maintained via a comparison function, enabling efficient traversal, filtering, and querying (e.g., min/max retrieval). Designed for automated reasoning systems, it facilitates tasks like clause management, logical inference, and proof search by providing safe, ordered set manipulations and conversions to sequences or strings for debugging and analysis.",
      "description_length": 637,
      "index": 497,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_avatar.S-E-C-WithPos",
      "library": "libzipperposition.avatar",
      "description": "Represents a clause with a specific subterm and its position for focused term manipulation. Provides comparison and pretty-printing operations for clauses with positional context. Useful in proof search and term rewriting systems where tracking subterm positions is critical.",
      "description_length": 275,
      "index": 498,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_avatar.S-E-Stm-Ctx-Lit",
      "library": "libzipperposition.avatar",
      "description": "This module manages bidirectional conversions between literals and formulas using hooks. It provides operations to register and retrieve conversion hooks for transforming literals to formulas and vice versa. The module works with `Logtk.Literal.t` and `Logtk.SLiteral.t` types, specifically handling atomic formulas during conversion. Use cases include integrating custom literal representations with theorem proving systems or transforming logical expressions for automated reasoning tasks.",
      "description_length": 491,
      "index": 499,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_avatar.S-E-ProofState-ActiveSet",
      "library": "libzipperposition.avatar",
      "description": "This module manages a dynamic set of clauses with signals for additions and removals. It provides operations to add or remove multiple clauses, retrieve the current set, and count clauses. Use it to track clause changes in a proof state or manage active clauses during theorem proving.",
      "description_length": 285,
      "index": 500,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_avatar.S-E-FormRename-Ctx-Lit",
      "library": "libzipperposition.avatar",
      "description": "This module manages bidirectional conversions between literals and formulas using customizable hooks. It provides functions to register and retrieve conversion hooks, as well as to convert atomic formulas to literals and vice versa. It directly works with `Logtk.Literal.t` and `Logtk.Term.t Logtk.SLiteral.t`, supporting use cases like integrating custom literal representations in theorem proving pipelines or transforming logical expressions during proof search.",
      "description_length": 465,
      "index": 501,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_avatar.S-E-ProofState-SubsumptionIndex-C",
      "library": "libzipperposition.avatar",
      "description": "This module defines operations for comparing clauses, extracting literals, and retrieving label subsets from clauses in a subsumption index. It works with clause data structures from a proof state and provides access to their logical literals and associated integer labels. It is used to support subsumption checks and literal-based indexing in automated theorem proving.",
      "description_length": 371,
      "index": 502,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_avatar.S-E-C-Seq",
      "library": "libzipperposition.avatar",
      "description": "This module provides functions to extract literals, terms, and variables from a clause structure. It operates on clauses (`E.C.t`) and returns iterators over literals, terms, and typed variables. Useful for clause analysis and transformation in automated theorem proving tasks.",
      "description_length": 277,
      "index": 503,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_avatar.S-E-FormRename",
      "library": "libzipperposition.avatar",
      "description": "This module handles formula renaming during clause processing, specifically managing predicate skolemization and definition extraction. It provides functions to detect renaming clauses, introduce skolem symbols conditionally, and rename formulas based on context and polarity. Use cases include transforming logical formulas during theorem proving, particularly when handling quantifier elimination or clausification with skolem functions.",
      "description_length": 439,
      "index": 504,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_avatar.S-E-ProofState-module-type-CLAUSE_SET",
      "library": "libzipperposition.avatar",
      "description": "This module manages a set of clauses with operations to add or remove clauses and trigger signals on these changes. It works with clause sets and uses iterators over clauses for bulk modifications. Concrete use cases include tracking clause additions and deletions during theorem proving processes.",
      "description_length": 298,
      "index": 505,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_avatar.S-E-ProofState-CQueue-PriorityFun",
      "library": "libzipperposition.avatar",
      "description": "This module defines a priority function type for weighting proof state elements in a queue. It includes a function to parse string descriptions into priority functions. It is used to control the order of clause processing in automated theorem proving by assigning integer weights to queue elements.",
      "description_length": 298,
      "index": 506,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_avatar.S-E-FormRename-Ctx",
      "library": "libzipperposition.avatar",
      "description": "This module provides operations for managing logical context and configuration, including term ordering, signature management, and injectivity checks for function symbols. It works with logical terms, literals, and symbols, enabling term-level reasoning and context state manipulation. These capabilities are particularly useful in theorem proving and term rewriting systems where precise term analysis and logical property verification are required.",
      "description_length": 450,
      "index": 507,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_avatar.S-E-ProofState-SubsumptionIndex",
      "library": "libzipperposition.avatar",
      "description": "This module implements a subsumption index for managing and querying clauses in a proof state. It supports operations to add, remove, and retrieve clauses based on subsumption and alpha-equivalence relationships, using literals and labels as keys. Use cases include efficient clause indexing and retrieval during automated theorem proving processes, such as identifying redundant clauses or finding relevant inferences.",
      "description_length": 419,
      "index": 508,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_avatar.Make",
      "library": "libzipperposition.avatar",
      "description": "This module provides operations for splitting clauses, integrating SAT solvers, and managing lemmas through introduction, implication definition, and inference rule registration. It works with clauses, trails, SAT solver interfaces, and lemma structures augmented with dependency tracking and proof metadata. These capabilities are used in formal verification tasks requiring automated reasoning, such as lemma-driven proof search and SAT-guided clause elimination in theorem provers.",
      "description_length": 484,
      "index": 509,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_avatar.S",
      "library": "libzipperposition.avatar",
      "description": "This module provides operations for manipulating and splitting clauses, managing lemmas through addition, implication tracking, and cut integration, and coordinating with a SAT solver for satisfiability checks and proof management. It operates on clauses, lemmas, and proof trails, enabling use cases in automated theorem proving such as optimizing logical inferences via cuts, handling lemma dependencies, and streamlining proof search in formal verification tasks.",
      "description_length": 466,
      "index": 510,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_avatar.S-Solver",
      "library": "libzipperposition.avatar",
      "description": "This module implements a SAT solver interface that supports adding clauses in various forms\u2014individual clauses, lists of clauses, or sequences of clauses\u2014each annotated with a proof step. It provides operations to check satisfiability, retrieve valuations and decision levels of literals, access proved literals, and extract proofs for unsatisfiable results or specific literals. Use cases include integrating with theorem provers that require SAT-solving capabilities with detailed proof tracking and model analysis.",
      "description_length": 517,
      "index": 511,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_avatar.S-E-ProofState-CQueue",
      "library": "libzipperposition.avatar",
      "description": "This module supports operations for managing priority queues of clauses, including adding, retrieving, removing, and membership checks, using weight and priority functions to determine clause ordering. Designed for automated theorem proving, it enables strategies like FIFO, goal-oriented, and heuristic-based prioritization to efficiently manage clause selection in reasoning systems.",
      "description_length": 385,
      "index": 512,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_avatar.S-E-ProofState",
      "library": "libzipperposition.avatar",
      "description": "Manages clause queues and indexes for efficient retrieval during automated reasoning. Provides operations for inserting, selecting, and prioritizing clauses based on term structure and logical dependencies. Supports concrete use cases like clause selection in saturation-based theorem proving and subsumption checking during proof search.",
      "description_length": 338,
      "index": 513,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_avatar.S-E-Stm-Ctx",
      "library": "libzipperposition.avatar",
      "description": "This module provides operations for skolemization, term ordering, clause selection, and injectivity checks on logical terms, working with terms, types, symbols, substitutions, and literals. These capabilities support theorem proving tasks like managing logical context, optimizing proof search strategies, and ensuring correct symbol declarations in first-order logic systems.",
      "description_length": 376,
      "index": 514,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_avatar.S-E-StmQ-WeightFun",
      "library": "libzipperposition.avatar",
      "description": "This module defines weight functions that assign integer weights to streams of statements. It provides operations to retrieve a penalty value from a stream and combine multiple weighted functions into a single function through a weighted sum. These functions are used to prioritize or evaluate streams based on customizable numeric criteria.",
      "description_length": 341,
      "index": 515,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_avatar.S-E",
      "library": "libzipperposition.avatar",
      "description": "This module provides operations for clause manipulation, simplification, and inference rule management in automated theorem proving. It works with clauses (`C.t`), clause sets (`ClauseSet.t`), proof states (`ProofState`), and statement queues (`StmQ`), supporting tasks like redundancy checking, term rewriting, and multi-clause simplification. Specific use cases include driving proof search through saturation, managing active/passive clause sets, and applying prioritized simplification rules during logical reasoning processes.",
      "description_length": 531,
      "index": 516,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_avatar",
      "library": "libzipperposition.avatar",
      "description": "This module orchestrates Avatar-style splitting and SAT-solving in theorem proving workflows, using trails to guide clause decomposition without strict trail-based activation. It introduces flags, keys, and a dedicated SAT-solver interface to manage logical state and drive splitting decisions dynamically, working with clauses, literals, and proof trails. Submodules handle term indexing with unification support, efficient clause prioritization via weight functions and priority queues, and advanced clause manipulation including eligibility checks, subsumption, and lemma integration. Together, they enable sophisticated proof search strategies, from SAT-guided backtracking to incremental clause processing and indexed term analysis.",
      "description_length": 737,
      "index": 517,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_induction.S-Env-ProofState-ActiveSet",
      "library": "libzipperposition.induction",
      "description": "This module manages a dynamic set of clauses with signals for additions and removals. It provides operations to add or remove clauses, retrieve the current set, and count clauses. Useful for tracking clause changes in automated theorem proving processes.",
      "description_length": 254,
      "index": 518,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_induction.S-Env-Stm-Ctx-Lit",
      "library": "libzipperposition.induction",
      "description": "This module manages bidirectional conversions between literals and formulas using customizable hooks. It provides operations to register and retrieve conversion hooks for transforming between `Logtk.Literal.t` and `Logtk.Term.t Logtk.SLiteral.t` types. It is used to integrate custom literal handling logic during proof search or term processing in theorem proving pipelines.",
      "description_length": 375,
      "index": 519,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_induction.S",
      "library": "libzipperposition.induction",
      "description": "Registers inference rules for inductive reasoning during theorem proving. Operates on logical formulas and proof states to support automated induction. Enables case analysis and inductive proof steps in formal verification tasks.",
      "description_length": 229,
      "index": 520,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_induction.S-Env-FormRename-Ctx",
      "library": "libzipperposition.induction",
      "description": "This module offers operations for logical inference and term analysis, including skolemization, term ordering, selection functions, and injectivity checks on function symbols. It manipulates terms, types, literals, and symbols from the `Logtk` library, alongside function identifiers (`Logtk.ID.t`) and integers. These capabilities support automated theorem proving and formal verification tasks, enabling precise reasoning about symbolic expressions and logical contexts.",
      "description_length": 472,
      "index": 521,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_induction.S-Env-ProofState-SimplSet",
      "library": "libzipperposition.induction",
      "description": "This module manages a dynamic set of clauses with operations to add or remove clauses and subscribe to events when clauses are added or removed. It works with clause data structures and uses iterators for batch modifications. It is useful for tracking changes to a set of logical clauses in real-time, such as during theorem proving or constraint solving.",
      "description_length": 355,
      "index": 522,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_induction.S-Env-FormRename",
      "library": "libzipperposition.induction",
      "description": "This module handles formula renaming and Skolem management during proof search. It provides operations to detect renaming clauses, introduce predicate Skolem symbols, and rename formulas based on context and polarity. Key data structures include clauses and formula renaming contexts, with use cases in managing logical equivalences and introducing fresh symbols during clause transformation.",
      "description_length": 392,
      "index": 523,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_induction.S-Env-Ctx-Lit",
      "library": "libzipperposition.induction",
      "description": "This module manages bidirectional conversions between literals and formulas using customizable hooks. It provides functions to register and retrieve conversion hooks for transforming literals to formulas and vice versa, as well as direct conversion functions that apply these hooks. It works with `Logtk.Literal.t` and `Logtk.Term.t Logtk.SLiteral.t` types, enabling integration of different literal representations in proof search and term processing tasks.",
      "description_length": 458,
      "index": 524,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_induction.S-Env-ProofState-SubsumptionIndex",
      "library": "libzipperposition.induction",
      "description": "This module implements a subsumption index for managing and querying clauses in a proof state. It supports operations to add, remove, and retrieve clauses based on subsumption and alpha-equivalence relationships, using literals and labels as keys. Use cases include efficient clause indexing and retrieval during automated theorem proving processes, such as identifying redundant clauses or finding candidates for resolution.",
      "description_length": 425,
      "index": 525,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_induction.Make",
      "library": "libzipperposition.induction",
      "description": "This module implements inference rules for inductive reasoning by integrating with the given term and clause modules. It operates on terms and clauses to support automated reasoning tasks such as lemma generation and proof search. Concrete use cases include enhancing theorem proving procedures with inductive capabilities in formal verification systems.",
      "description_length": 354,
      "index": 526,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_induction.S-Env-C-Tbl",
      "library": "libzipperposition.induction",
      "description": "This module provides imperative hash table operations for managing key-value associations with `Env.C.t` keys, supporting efficient insertion, lookup, iteration, and in-place modifications. It handles arbitrary value types and specialized operations like counter manipulation, list aggregation, and merging duplicate keys with custom logic, while offering conversions to and from sequences and iterators. Typical use cases include tracking dynamic state, accumulating statistics, or managing heterogeneous data mappings requiring imperative updates and bulk transformations.",
      "description_length": 574,
      "index": 527,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_induction.S-Env",
      "library": "libzipperposition.induction",
      "description": "This module provides operations for clause manipulation, simplification, and inference rule management in automated theorem proving, focusing on saturation-based logical deduction. It works with clauses, trails, proof states, and clause queues, supporting tasks like redundancy elimination, tautology detection, and rule registration for rewriting or normalization. Key use cases include managing logical clause states during proof search, implementing simplification pipelines, and handling event-driven state transitions or predicate elimination in formal verification workflows.",
      "description_length": 581,
      "index": 528,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_induction.S-Env-ProofState-CQueue-PriorityFun",
      "library": "libzipperposition.induction",
      "description": "This module defines a priority function type for ordering clauses in a proof state's clause queue. It includes a function to parse string descriptions into integer weighting functions for clauses. It is used to control the heuristic priority of clauses during automated theorem proving.",
      "description_length": 286,
      "index": 529,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_induction.S-Env-StmQ",
      "library": "libzipperposition.induction",
      "description": "This module implements a priority queue for managing streams of clauses with weighted priorities. It supports operations to add individual streams or lists of streams, inspect queue size, and extract clauses either fairly or up to the number of streams available. Concrete use cases include scheduling clause processing in automated theorem proving where streams represent different sources of clauses and priority is determined by a weight function.",
      "description_length": 450,
      "index": 530,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_induction.S-Env-ProofState-UnitIndex-E",
      "library": "libzipperposition.induction",
      "description": "This module represents and compares indexed equations or inequations, pairing terms with a boolean flag and a clause. It provides operations to extract components of these equations and determine their priority for use in proof search or term indexing systems.",
      "description_length": 260,
      "index": 531,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_induction.S-Env-C",
      "library": "libzipperposition.induction",
      "description": "This module centers on manipulating and analyzing logical clauses with rich metadata, including operations to track boolean flags (e.g., redundancy, simplification status), manage proofs and trails, and inspect structural properties like literals, weight, and eligibility for inference rules. It operates on clauses paired with trails, proofs, substitutions, and clause sets, supporting transformations such as term reduction, substitution application, and format conversion for output. Key use cases include automated theorem proving, clause state tracking, proof derivation, and term analysis in formal verification systems.",
      "description_length": 626,
      "index": 532,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_induction.S-Env-ProofState-module-type-CLAUSE_SET",
      "library": "libzipperposition.induction",
      "description": "This module manages a dynamic set of clauses with operations to add or remove clauses and subscribe to events when clauses are added or removed. It works with clause sets using the `C.t` type and provides signals for reacting to changes in the set. Concrete use cases include tracking clause modifications during theorem proving or maintaining derived clause sets in automated reasoning systems.",
      "description_length": 395,
      "index": 533,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_induction.S-Env-FormRename-Ctx-Lit",
      "library": "libzipperposition.induction",
      "description": "This module manages bidirectional conversions between literals and formulas using customizable hooks. It provides functions to register and retrieve conversion hooks, ensuring atomic formulas are properly transformed into literals and vice versa. Concrete use cases include integrating custom term representations with theorem proving pipelines and enabling flexible literal normalization during clause processing.",
      "description_length": 414,
      "index": 534,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_induction.S-Env-ProofState-CQueue",
      "library": "libzipperposition.induction",
      "description": "This module implements priority queues for managing clauses with customizable selection strategies like FIFO, goal-oriented, and heuristic-driven ordering. It operates on `Env.ProofState.CQueue.t` structures, which track clause prioritization within a proof state, and supports operations such as weighted insertion, priority-based retrieval, membership checks, and string serialization. It is used in automated reasoning systems to dynamically order clauses during proof search and facilitate debugging through passive set inspection and output formatting.",
      "description_length": 557,
      "index": 535,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_induction.S-Env-ProofState-UnitIndex",
      "library": "libzipperposition.induction",
      "description": "This module implements an index for managing and querying a collection of (in)equations within a proof state, supporting operations like adding, removing, and retrieving terms based on substitution and matching conditions. It works with terms and substitutions from the `Logtk.Index_intf` module, along with proof state elements from the `E` submodule, enabling efficient indexing and lookup during theorem proving. Use cases include retrieving applicable rewrite rules, finding matching clauses for a given term, and maintaining a dynamic set of equations for automated reasoning tasks.",
      "description_length": 587,
      "index": 536,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_induction.S-Env-Stm",
      "library": "libzipperposition.induction",
      "description": "This module manages streams of clauses with associated metadata, supporting operations to create, compare, and manipulate streams based on their content and provenance. It works with streams of optional clauses (`C.t option OSeq.t`), tracking parent clauses, penalties, and access counts. Concrete use cases include managing inference results in automated theorem proving, where streams represent sequences of derived clauses and operations like `drip` and `drip_n` control clause retrieval for further processing.",
      "description_length": 514,
      "index": 537,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_induction.S-Env-ProofState-TermIndex",
      "library": "libzipperposition.induction",
      "description": "This module enables efficient term indexing with operations for inserting, querying, and transforming terms alongside associated values, emphasizing unification, generalization, and specialization under scoped substitutions. It operates on a hierarchical term index structure (`Env.ProofState.TermIndex.t`) designed for managing logical terms in automated reasoning contexts. The inclusion of a `to_dot` function highlights applications in visualizing proof state dependencies or term relationships during theorem proving and logic programming workflows.",
      "description_length": 554,
      "index": 538,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_induction.S-Env-Stm-Ctx",
      "library": "libzipperposition.induction",
      "description": "This module supports logical context management, including term comparison, symbol declaration, and signature manipulation, using a global context with dynamic settings for ordering and selection. It facilitates inductive reasoning through operations like injectivity checks for identifiers and manipulation of logical literals in first-order logic. These capabilities are applied in tasks such as unification, logical inference, and automated theorem proving.",
      "description_length": 460,
      "index": 539,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_induction.S-Env-ProofState",
      "library": "libzipperposition.induction",
      "description": "Manages proof states in automated theorem proving with operations for clause manipulation, indexing, and statistics tracking. Uses data structures like queues, term indexes, and specialized clause sets to handle logical formulas and inference steps. Enables efficient proof search by organizing clauses into active, simplification, and passive sets with dedicated indexing for fast retrieval and subsumption checks.",
      "description_length": 415,
      "index": 540,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_induction.S-Env-ProofState-PassiveSet",
      "library": "libzipperposition.induction",
      "description": "This module manages a set of logical clauses with operations to add, remove, and query clauses, as well as track their passive status. It provides signals for clause addition and removal, a queue interface for clause processing, and direct access to the current clause set and count. Concrete use cases include managing passive clauses during automated theorem proving and coordinating clause selection in a proof state.",
      "description_length": 420,
      "index": 541,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_induction.S-Env-C-Eligible",
      "library": "libzipperposition.induction",
      "description": "This module defines a set of functions for determining which literals in a clause are eligible for specific inference rules during automated theorem proving. It operates on clauses and literals, providing filters to select eligible literals based on properties like positivity, negativity, maximality, equation status, and combinations of these conditions. Use cases include selecting literals for resolution, paramodulation, or simplification steps in a prover's inner loop.",
      "description_length": 475,
      "index": 542,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_induction.S-Env-C-WithPos",
      "library": "libzipperposition.induction",
      "description": "This module represents clauses with a focused subterm and its position, enabling precise manipulation of terms within clauses. It provides comparison and pretty-printing operations for these structured clauses. Useful for implementing rewriting or inference rules that require tracking specific subterm positions within logical expressions.",
      "description_length": 340,
      "index": 543,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_induction.S-Env-ProofState-CQueue-WeightFun",
      "library": "libzipperposition.induction",
      "description": "This module defines weight functions that assign integer weights to clauses in a proof state's clause queue. It supports operations to construct and combine weight functions, including parsing from strings, combining with coefficients, and applying heuristic-based penalties or preferences. Use cases include guiding clause selection during automated theorem proving by prioritizing clauses based on properties like goal proximity, groundness, or Horn structure.",
      "description_length": 462,
      "index": 544,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_induction.S-Env-Ctx",
      "library": "libzipperposition.induction",
      "description": "This module provides operations for managing logical contexts and signature states in automated theorem proving, including term ordering management, skolemization, and injectivity checks for function symbols with respect to specific arguments. It operates on logical literals, atomic propositions, equations, and term structures, enabling tasks like proof consistency verification, existential quantifier handling, and term comparison in reasoning systems.",
      "description_length": 456,
      "index": 545,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_induction.S-Env-C-Seq",
      "library": "libzipperposition.induction",
      "description": "This module provides functions to extract literals, terms, and typed variables from a given clause environment. It operates on data structures like clauses (`Env.C.t`), literals (`Logtk.Literal.t`), terms (`Logtk.Term.t`), and typed variables (`Logtk.HVar.t`). It is used in proof search and term rewriting systems to analyze and manipulate logical expressions during automated reasoning tasks.",
      "description_length": 394,
      "index": 546,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_induction.S-Env-ProofState-TermIndex-Leaf",
      "library": "libzipperposition.induction",
      "description": "This module implements a term index structure that supports efficient insertion, removal, and querying of logical terms in a proof state context. It provides operations for unification and matching between indexed terms and query terms, producing substitutions that satisfy the respective operations. The module is used in automated theorem proving to manage and retrieve terms based on structural or logical equivalence.",
      "description_length": 421,
      "index": 547,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_induction.S-Env-ProofState-CQueue-C",
      "library": "libzipperposition.induction",
      "description": "This module provides operations for managing and transforming logical clauses within a proof state queue, focusing on metadata manipulation (e.g., redundancy flags, simplification status), trail and proof tracking (e.g., subsumption checks, valuation-based activation), and structural analysis (e.g., literal eligibility, maximal terms under substitution). It works with clauses containing literals, trails, and proof annotations, supporting tasks like \u03b7-reduction, TSTP formatting, and dependency tracking. Key use cases include automated redundancy elimination, clause prioritization in resolution/paramodulation, and debugging via structured output in theorem proving workflows.",
      "description_length": 681,
      "index": 548,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "Libzipperposition_induction.S-Env-StmQ-WeightFun",
      "library": "libzipperposition.induction",
      "description": "This module defines weight functions that assign integer weights to streams of statements. It provides operations to retrieve a penalty value for a stream and to combine multiple weight functions using weighted sums. These functions are used to prioritize or evaluate streams based on customizable weighting schemes.",
      "description_length": 316,
      "index": 549,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_induction.S-Env-ProofState-SubsumptionIndex-C",
      "library": "libzipperposition.induction",
      "description": "This module defines operations for comparing clauses, extracting literals, and retrieving label subsets. It works with clause data structures and associated integer labels and literals. Concrete use cases include subsumption checking and indexing for efficient clause retrieval in automated theorem proving.",
      "description_length": 307,
      "index": 550,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_induction.S-Env-C-Pos",
      "library": "libzipperposition.induction",
      "description": "Retrieves a term from a context at a specified position. Works with environments and logical terms indexed by positions. Useful for accessing specific subterms during proof search or term analysis.",
      "description_length": 197,
      "index": 551,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_induction",
      "library": "libzipperposition.induction",
      "description": "This module orchestrates inductive reasoning within automated theorem proving by integrating logical inference, clause management, and term analysis. It supports key data types such as clauses, literals, terms, and proof states, with operations for skolemization, injectivity checks, term ordering, and eligibility filtering. Users can define and apply custom inference rules, manage dynamic clause sets with event tracking, and prioritize clauses using weight functions and priority queues. Specific tasks include verifying recursive properties, simplifying logical expressions, and guiding proof search through heuristic-driven clause selection and subsumption-based indexing.",
      "description_length": 678,
      "index": 552,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Superposition.Make.PS.TermIndex.Leaf",
      "library": "libzipperposition.calculi",
      "description": "This module implements a term index structure for efficient retrieval of terms during superposition-based theorem proving. It supports operations to add, remove, and update indexed terms along with their associated values, and provides methods for unification and matching queries against indexed terms. The index works directly with logical terms and substitutions, enabling concrete use cases such as clause subsumption and inference rule application in automated reasoning systems.",
      "description_length": 484,
      "index": 553,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Superposition.Make.PS.CQueue.C",
      "library": "libzipperposition.calculi",
      "description": "This module supports managing clause properties such as redundancy and simplification status, analyzing structural features like literal selection and term properties, and transforming clauses through substitutions and proof manipulation. It operates on clause representations alongside trails, substitutions, and bitvectors to facilitate superposition-based theorem proving strategies, including redundancy elimination, proof generation in standardized formats, and eligibility checks for resolution steps.",
      "description_length": 507,
      "index": 554,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Heuristics.Make.PS.CQueue.PriorityFun",
      "library": "libzipperposition.calculi",
      "description": "Implements priority functions for clause selection in theorem proving, assigning integer weights to clauses based on configurable heuristics. Uses string-based configuration to define weight calculation logic, enabling dynamic control over prioritization strategies. Useful for guiding proof search by adjusting clause importance dynamically during solving.",
      "description_length": 357,
      "index": 555,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Heuristics.Make.PS.UnitIndex.E",
      "library": "libzipperposition.calculi",
      "description": "This module represents and compares indexed equations with their associated terms and signs. It provides operations to extract components of equations, compare them for ordering, and assess their usefulness through a priority value. It is used to manage and manipulate logical equations or inequations in term indexing structures.",
      "description_length": 330,
      "index": 556,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Heuristics.Make.PS.CQueue.C",
      "library": "libzipperposition.calculi",
      "description": "This module manages clause properties, transformations, and analysis in automated theorem proving. It provides utilities to track redundancy, eligibility, and literal selection, manipulate clauses with trails and proofs, and convert clauses into grounded forms or output formats like TSTP/CNF. These operations support heuristic-driven processing, proof construction, and trail-based reasoning in deduction systems.",
      "description_length": 415,
      "index": 557,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Superposition.Make.PS.SubsumptionIndex.C",
      "library": "libzipperposition.calculi",
      "description": "This module provides comparison, literal iteration, and label extraction operations for clauses used in subsumption indexing. It works with clauses represented as type `t`, which is an alias for `PS.C.t`. Concrete use cases include managing clause ordering, extracting literals for indexing, and tracking dependencies via integer labels during subsumption checks.",
      "description_length": 363,
      "index": 558,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Heuristics.Make.PS.SubsumptionIndex.C",
      "library": "libzipperposition.calculi",
      "description": "This module defines operations for comparing clauses, iterating over their literals, and retrieving label subsets used in subsumption checks. It works with clauses represented by the type `C.t`, treating them as collections of literals and labels. Concrete use cases include subsumption testing and indexing clauses for efficient retrieval in theorem proving procedures.",
      "description_length": 370,
      "index": 559,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Superposition.Make.PS.CQueue.PriorityFun",
      "library": "libzipperposition.calculi",
      "description": "Implements priority functions for clause selection in superposition provers. It assigns integer weights to clauses based on parsed string descriptions of priority rules. Used to guide proof search by determining which clauses to process next.",
      "description_length": 242,
      "index": 560,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Superposition.Make.PS.CQueue.WeightFun",
      "library": "libzipperposition.calculi",
      "description": "This module defines weight functions for prioritizing clauses in a superposition prover. It includes functions to compute clause weights based on properties like literal count, penalty, goal proximity, and syntactic forms (e.g., Horn, ground, negative-only). These weight functions guide clause selection during proof search, influencing the prover's efficiency and effectiveness by prioritizing potentially useful clauses.",
      "description_length": 423,
      "index": 561,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Superposition.Make.PS.UnitIndex.E",
      "library": "libzipperposition.calculi",
      "description": "This module represents and compares indexed equations with their associated terms and boolean signs indicating equality or inequality. It provides operations to extract components of equations, such as terms and their right-hand sides, and assigns priority values to indicate usefulness in reasoning tasks. It is used in automated theorem proving to manage and process logical equations efficiently.",
      "description_length": 399,
      "index": 562,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Heuristics.Make.PS.CQueue.WeightFun",
      "library": "libzipperposition.calculi",
      "description": "This module defines weight functions for prioritizing clauses in a priority queue based on heuristic criteria. It supports operations like parsing weight function descriptions, combining multiple weight functions with coefficients, and applying specific heuristics such as favoring ground or Horn clauses. Concrete use cases include guiding clause selection in automated theorem proving by assigning dynamic weights based on clause properties like penalty, goal proximity, or literal composition.",
      "description_length": 496,
      "index": 563,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Heuristics.Make.PS.TermIndex.Leaf",
      "library": "libzipperposition.calculi",
      "description": "This module implements a term index structure for efficient retrieval of terms based on unification and matching operations. It supports adding, removing, and updating indexed terms along with their associated values, and provides iteration and folding over the indexed data. It is used to accelerate term-level lookups in theorem proving procedures, particularly for tasks like subsumption checking and clause retrieval during saturation-based reasoning.",
      "description_length": 455,
      "index": 564,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Superposition.Make.C.Tbl",
      "library": "libzipperposition.calculi",
      "description": "This module implements a hash table for managing key-value pairs with keys of type `C.t` and arbitrary value types, supporting efficient insertion, lookup, and in-place transformations. It provides bulk operations for data aggregation, sequence conversions for interoperability with iterators and lists, and customizable logic for handling duplicate keys or missing entries. Typical use cases include dynamic data accumulation, iterative processing pipelines, and structured data representation requiring precise memory control or tailored output formatting.",
      "description_length": 558,
      "index": 565,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.EnumTypes.Make.C.WithPos",
      "library": "libzipperposition.calculi",
      "description": "This module represents clauses with a specific subterm and its position, enabling precise term manipulation and analysis. It provides comparison and pretty-printing operations for these structured clauses. Useful for tasks like subterm indexing, rewriting, or focused proof search where positional context is critical.",
      "description_length": 318,
      "index": 566,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Fool.Make.C.Eligible",
      "library": "libzipperposition.calculi",
      "description": "This module defines eligibility criteria for selecting literals in first-order logic clauses, primarily used in automated theorem proving. It provides functions to filter literals based on properties like positivity, negativity, being an equation, or maximal status, and supports combining criteria using logical operations. These operations enable precise control over which literals are considered during resolution and paramodulation steps in a prover.",
      "description_length": 455,
      "index": 567,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Lazy_cnf.Make.C.Tbl",
      "library": "libzipperposition.calculi",
      "description": "This module implements a mutable hash table for key-value associations with `C.t` keys and arbitrary values, offering imperative operations like insertion, deletion, lookup, and in-place transformations. It emphasizes efficient counting, aggregation, and bulk updates with customizable conflict resolution, supporting use cases such as frequency tracking, list-based table construction, and bidirectional conversion between hash tables and sequences/iterators. Key patterns include atomic updates, value folding over bindings, and statistics-gathering via specialized counting functions.",
      "description_length": 587,
      "index": 568,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Heuristics.Make.PS.SimplSet",
      "library": "libzipperposition.calculi",
      "description": "This module manages a set of clauses with operations to add or remove clauses and trigger signals on these changes. It uses an underlying set structure to store clauses and provides iteration-based updates for bulk modifications. It is used in theorem proving contexts to track and react to dynamic changes in clause sets during proof search.",
      "description_length": 342,
      "index": 569,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Superposition.Make.C.WithPos",
      "library": "libzipperposition.calculi",
      "description": "This module represents clauses with a specific subterm and its position, enabling precise term manipulation and analysis. It provides comparison and pretty-printing operations for these structured clauses. Useful for implementing focused rewriting or inference rules that require positional context within terms.",
      "description_length": 312,
      "index": 570,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Lazy_cnf.Make.C.Eligible",
      "library": "libzipperposition.calculi",
      "description": "This module defines predicates to select eligible literals in clauses for specific inference rules. It supports operations like filtering by resolution, paramodulation, equation status, sign, and maximality, with combinators for composing conditions using logical operators. These predicates are used to determine which literals can participate in proof search steps like resolution or paramodulation.",
      "description_length": 401,
      "index": 571,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Heuristics.Make.C.WithPos",
      "library": "libzipperposition.calculi",
      "description": "Represents clauses with a specific subterm and its position, enabling precise term manipulation. Provides comparison and pretty-printing operations for these structured clauses. Useful for implementing rewriting or inference rules that require tracking subterm locations within logical expressions.",
      "description_length": 298,
      "index": 572,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Superposition.Make.PS.UnitIndex",
      "library": "libzipperposition.calculi",
      "description": "This module implements a term index for efficient retrieval of equations and inequations based on term structure and substitutions, supporting operations to add, remove, and query indexed entries. It includes a child module that represents and compares indexed equations, providing access to their terms, right-hand sides, and priority values for reasoning tasks. The index enables fast lookup of matching or generalizing equations during proof search, and supports iteration over stored terms and DOT visualization generation. Users can, for example, efficiently retrieve candidate equations for resolution or visualize the structure of indexed terms during theorem proving.",
      "description_length": 675,
      "index": 573,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Higher_order.Make.C.Eligible",
      "library": "libzipperposition.calculi",
      "description": "This module defines eligibility criteria for selecting literals in clauses based on specific logical properties. It provides functions to filter literals by resolution, paramodulation, positivity, negativity, maximality, and equation status, as well as logical combinations of these conditions. Use cases include guiding inference rules in theorem proving by restricting which literals can participate in resolution or paramodulation steps.",
      "description_length": 440,
      "index": 574,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Superposition.Make.PS.SimplSet",
      "library": "libzipperposition.calculi",
      "description": "This module manages a set of clauses with operations to add or remove clauses and trigger signals on these changes. It uses an underlying clause data structure and supports iteration over clauses. It is used to track and respond to modifications in a clause set during theorem proving processes.",
      "description_length": 295,
      "index": 575,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Superposition.Make.PS.C",
      "library": "libzipperposition.calculi",
      "description": "This module enables manipulation of clauses through operations that manage boolean flags, analyze properties like goal status and redundancy, and perform trail-based modifications with provenance tracking. It handles clauses, substitutions, and bitvectors, supporting tasks such as literal selection, proof step updates, and eligibility checks for resolution, while also providing transformations for simplification, format conversion, and TSTP-compliant output generation in automated theorem proving workflows.",
      "description_length": 512,
      "index": 576,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.EnumTypes.Make.C.Seq",
      "library": "libzipperposition.calculi",
      "description": "Extracts literals, terms, and variables from a clause structure. Works with clauses (`C.t`), literals (`Logtk.Literal.t`), terms (`Logtk.Term.t`), and typed variables (`Logtk.Type.t Logtk.HVar.t`). Useful for analyzing or transforming logical clauses during theorem proving or formula manipulation tasks.",
      "description_length": 304,
      "index": 577,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Heuristics.Make.PS.CQueue",
      "library": "libzipperposition.calculi",
      "description": "This module organizes clauses into a priority queue for efficient selection and processing in theorem proving, allowing clauses to be enqueued, dequeued based on dynamic priorities, and inspected for debugging. It supports customizable heuristics through weight functions that assign and combine priorities based on clause properties such as goal proximity or groundedness, enabling fine-grained control over proof search strategies. Submodules handle clause metadata, transformations, and weight function manipulation, providing tools to analyze redundancy, apply proof trails, and adjust prioritization logic on the fly. Example uses include selecting ground clauses for expansion, penalizing complex clauses, or dynamically shifting focus toward goal-oriented subgoals during saturation.",
      "description_length": 790,
      "index": 578,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Higher_order.Make.C.Seq",
      "library": "libzipperposition.calculi",
      "description": "Extracts literals, terms, and typed variables from clauses for higher-order reasoning. Works with clause (`C.t`), literal, term, and typed variable data types. Used in clause processing for automated theorem proving tasks like subsumption or term indexing.",
      "description_length": 256,
      "index": 579,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Superposition.Make.PS.TermIndex",
      "library": "libzipperposition.calculi",
      "description": "This module organizes terms into a hierarchical index optimized for fast retrieval and unification in automated theorem proving. It supports adding, removing, and querying terms with associated values, enabling operations like clause subsumption and inference rule application. Submodules refine these capabilities with specialized indexing strategies, while direct APIs allow term manipulation and substitution. Example uses include matching terms under scoped unification and exporting index structures in DOT format for visualization.",
      "description_length": 537,
      "index": 580,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Hlt_elim.Make.C.Tbl",
      "library": "libzipperposition.calculi",
      "description": "This module implements a specialized imperative hash table with operations for key-based insertion, deletion, and transformation of values, augmented with utilities for bulk updates, statistical tracking, and sequence conversion. It operates on tables mapping keys of type `C.t` to arbitrary values, supporting use cases like counting elements via `add_iter_count`, merging duplicates with custom functions, and bidirectional conversion with lists. Applications include efficient data aggregation, in-place value manipulation (e.g., `incr`/`decr`), and structured serialization with customizable output formatting.",
      "description_length": 614,
      "index": 581,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Heuristics.Make.C.Seq",
      "library": "libzipperposition.calculi",
      "description": "Extracts literals, terms, and variables from clauses for analysis or transformation tasks. Works directly with clause (`C.t`) and logic term (`Logtk.Term.t`, `Logtk.Literal.t`) types. Useful in proof search, clause preprocessing, or term traversal routines.",
      "description_length": 257,
      "index": 582,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Fool.Make.C.ClauseSet",
      "library": "libzipperposition.calculi",
      "description": "This module implements a functional, persistent set structure for clauses ordered by a comparator, offering operations like membership checks, union/intersection, filtering, and ordered traversal (e.g., `min_elt`, `max_elt`). It supports transformations between sets and lists/sequences, safe lookup variants (`find_opt`), and ordered predicate-based searches (`find_first_map`). Designed for automated reasoning tasks, it enables efficient clause management in scenarios requiring ordered processing, such as proof search or constraint filtering.",
      "description_length": 547,
      "index": 583,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Higher_order.Make.C.ClauseSet",
      "library": "libzipperposition.calculi",
      "description": "This module implements ordered set operations for clause collections, supporting membership checks, union/intersection/difference calculations, and ordered traversal based on a comparison function. It works with `C.ClauseSet.t` structures that maintain elements in a sorted order, enabling efficient retrieval of extremal elements (min/max) and predicate-based filtering. The functionality is particularly useful in formal verification contexts requiring ordered clause set manipulation, such as theorem proving workflows that demand deterministic traversal or transformation of logical statements.",
      "description_length": 598,
      "index": 584,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.EnumTypes.Make.C.ClauseSet",
      "library": "libzipperposition.calculi",
      "description": "This module supports operations for managing ordered sets of clauses, including membership testing, insertion, deletion, union, intersection, and difference, alongside iteration, mapping, and folding while preserving element ordering. It works with `C.ClauseSet.t` structures\u2014sets built from a clause type `C.t` using a comparison function to ensure efficient ordered operations\u2014and provides utilities for converting between sets, lists, and sequences, as well as safely handling edge cases like empty sets. These capabilities are particularly useful in logical reasoning systems for aggregating, transforming, and analyzing collections of clauses during proof search or constraint management.",
      "description_length": 693,
      "index": 585,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Lazy_cnf.Make.C.WithPos",
      "library": "libzipperposition.calculi",
      "description": "This module represents clauses with a specific subterm and its position, enabling precise manipulation and tracking of terms within clauses. It provides comparison and pretty-printing operations for these structured clauses. Useful for implementing proof search strategies that require term-level navigation or subterm analysis.",
      "description_length": 328,
      "index": 586,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Heuristics.Make.C.Pos",
      "library": "libzipperposition.calculi",
      "description": "This module provides a function `at` that retrieves a subterm from a given term at a specified position. It operates on terms represented by the `C.t` type and positions defined by `Logtk.Position.t`. A typical use case involves accessing specific parts of logical expressions during proof search or term analysis.",
      "description_length": 314,
      "index": 587,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Booleans.Make.C.Pos",
      "library": "libzipperposition.calculi",
      "description": "Extracts a subterm at a specific position from a clause's term structure. Works with clauses and terms, using positions to navigate nested logical expressions. Useful for analyzing or transforming specific parts of logical formulas during proof search.",
      "description_length": 252,
      "index": 588,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Superposition.Make.PS.PassiveSet",
      "library": "libzipperposition.calculi",
      "description": "This module manages a passive clause set in a theorem proving context, supporting dynamic updates and retrieval of clauses for processing. It provides operations to add or remove clauses, check clause status, and access the current clause queue and set. Concrete use cases include tracking and processing passive clauses during superposition-based automated reasoning tasks.",
      "description_length": 374,
      "index": 589,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Heuristics.Make.PS.CLAUSE_SET",
      "library": "libzipperposition.calculi",
      "description": "This module manages a set of clauses with operations to add or remove clauses and signals for tracking changes. It works with clause sets and supports iteration over clauses using `Iter.t`. Concrete use cases include maintaining a dynamic collection of logical clauses for theorem proving, where additions and removals trigger notifications for dependent systems.",
      "description_length": 363,
      "index": 590,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Superposition.Make.C.Seq",
      "library": "libzipperposition.calculi",
      "description": "This module provides functions to extract literals, terms, and variables from clauses. It works with clause (`C.t`), literal (`Logtk.Literal.t`), term (`Logtk.Term.t`), and variable (`Logtk.HVar.t`) data structures. Use it to analyze or transform logical clauses by inspecting their constituent elements.",
      "description_length": 304,
      "index": 591,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Lazy_cnf.Make.C.Seq",
      "library": "libzipperposition.calculi",
      "description": "This module provides functions to iterate over literals, terms, and variables contained in a clause. It works with clause (`C.t`), literal (`Logtk.Literal.t`), term (`Logtk.Term.t`), and variable (`Logtk.HVar.t`) data types. Use it to extract and process logical components from clauses in a lazy CNF transformation context.",
      "description_length": 324,
      "index": 592,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Hlt_elim.Make.C.Pos",
      "library": "libzipperposition.calculi",
      "description": "This module provides a function `at` that retrieves a subterm from a given term at a specified position. It operates on terms and positions, enabling precise navigation within term structures. Useful for analyzing or transforming specific parts of logical expressions during proof search or term rewriting.",
      "description_length": 306,
      "index": 593,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Heuristics.Make.PS.SubsumptionIndex",
      "library": "libzipperposition.calculi",
      "description": "The module organizes clauses as sequences of literals and labels, enabling efficient subsumption checks and index-based retrieval. It supports adding, removing, and querying clauses through literal and label patterns, with operations for alpha-equivalence comparison and subset extraction. Submodules enhance this functionality by providing direct comparison tools, iteration over clause components, and label-based filtering for use in theorem proving tasks. Example uses include pruning redundant clauses during resolution or identifying subsuming clauses in a knowledge base.",
      "description_length": 578,
      "index": 594,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.EnumTypes.Make.C.Tbl",
      "library": "libzipperposition.calculi",
      "description": "This module implements a hash table structure for key-value pairs where keys are of type `C.t` and values can be arbitrary, supporting imperative operations like insertion, deletion, and in-place updates alongside functional transformations. It emphasizes handling duplicate keys with custom combination logic, bulk data ingestion from sequences or iterators, and efficient element counting, with utilities for converting tables to lists/sequences and customizing output formatting. Typical use cases include aggregating statistics from streams of data, maintaining dynamic mappings with merge strategies for conflicts, and transforming large datasets through in-place modifications or bulk operations.",
      "description_length": 702,
      "index": 595,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Hlt_elim.Make.C.Eligible",
      "library": "libzipperposition.calculi",
      "description": "This module defines eligibility criteria for selecting literals in a clause based on specific logical properties. It provides functions to filter literals by resolution, paramodulation, positivity, negativity, maximality, and equation status, as well as logical combinations of these conditions. Use cases include guiding inference rules in automated theorem proving by restricting which literals can participate in resolution or paramodulation steps.",
      "description_length": 451,
      "index": 596,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Superposition.Make.PS.ActiveSet",
      "library": "libzipperposition.calculi",
      "description": "This module manages a dynamic set of clauses with support for adding, removing, and querying clauses. It provides signals triggered on clause insertion and removal, and exposes the current clause set as a `ClauseSet.t` along with the total count. It is used to maintain and monitor an active set of logical clauses during theorem proving processes.",
      "description_length": 348,
      "index": 597,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Fool.Make.C.Seq",
      "library": "libzipperposition.calculi",
      "description": "This module provides functions to extract literals, terms, and variables from a clause structure. It works with data types representing logical clauses, literals, terms, and typed variables. Concrete use cases include analyzing or transforming first-order logic clauses during automated theorem proving.",
      "description_length": 303,
      "index": 598,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Lazy_cnf.Make.C.Pos",
      "library": "libzipperposition.calculi",
      "description": "This module provides a function `at` that retrieves a term at a specified position within a clause. It operates on clauses (`C.t`) and term positions (`Logtk.Position.t`). A concrete use case is extracting specific subterms from a clause during proof search or term analysis.",
      "description_length": 275,
      "index": 599,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.EnumTypes.Make.C.Eligible",
      "library": "libzipperposition.calculi",
      "description": "This module defines eligibility criteria for selecting literals in automated theorem proving. It provides functions to filter literals based on properties like positivity, negativity, equation status, and maximality, as well as logical combinations of these conditions. These criteria are used to control resolution and paramodulation steps during clause processing.",
      "description_length": 366,
      "index": 600,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Superposition.Make.PS.CQueue",
      "library": "libzipperposition.calculi",
      "description": "This module manages priority queues of clauses for theorem proving, offering insertion, prioritization via customizable weight and ordering functions, and search strategies like breadth-first or goal-oriented selection. It integrates clause management with dynamic adjustment of proof search behavior, supporting operations such as weight assignment based on literal count, syntactic form, or goal proximity. Submodules handle clause properties, transformations, and priority rule parsing, enabling redundancy checks, proof manipulation, and strategy-driven clause selection. Specific uses include guiding superposition-based provers by selecting eligible clauses, applying weight functions from string descriptions, and adjusting priorities during proof search.",
      "description_length": 762,
      "index": 601,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Higher_order.Make.C.Pos",
      "library": "libzipperposition.calculi",
      "description": "This module provides a function `at` that retrieves a subterm at a specified position within a term. It operates on terms and positions, enabling precise navigation and manipulation of term structures. A concrete use case is extracting specific components from complex logical expressions during proof search or term rewriting.",
      "description_length": 327,
      "index": 602,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Hlt_elim.Make.C.WithPos",
      "library": "libzipperposition.calculi",
      "description": "Represents clauses with a specific subterm and its position, enabling precise term manipulation. Provides comparison and pretty-printing operations for these structured clauses. Useful for implementing rewriting or inference rules that require tracking subterm locations within logical expressions.",
      "description_length": 298,
      "index": 603,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Fool.Make.C.WithPos",
      "library": "libzipperposition.calculi",
      "description": "This module represents clauses with a specific subterm and its position, enabling precise manipulation and tracking of terms within clauses. It provides comparison and pretty-printing operations for these structured clauses. Useful for implementing focused proof search or term rewriting where positional context is critical.",
      "description_length": 325,
      "index": 604,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Higher_order.Make.C.Tbl",
      "library": "libzipperposition.calculi",
      "description": "This module supports efficient key-value storage and manipulation using hash tables with keys of type `C.t` and polymorphic values. It emphasizes safe access patterns through functions like default-based retrieval, counter management, and list aggregation, alongside bulk updates from sequences or iterators for functional-style transformations. Typical applications include frequency tracking from iterative sources, customizable merging during table construction, and structured data serialization or formatting for debugging and reporting.",
      "description_length": 542,
      "index": 605,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Hlt_elim.Make.C.ClauseSet",
      "library": "libzipperposition.calculi",
      "description": "This module supports operations for managing ordered collections of clauses, enabling standard set manipulations like union, intersection, and difference, along with ordered traversal and comparison. It provides functions for transforming and querying clause sets through filtering, mapping, and folding, as well as converting between sets and other data structures such as lists and sequences. Designed for deterministic processing in theorem proving scenarios, it facilitates safe element access, predicate-based searches, and customizable string representations for analysis or debugging.",
      "description_length": 591,
      "index": 606,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Heuristics.Make.C.Tbl",
      "library": "libzipperposition.calculi",
      "description": "This module supports creation, modification, and traversal of hash tables with keys of type `C.Tbl.key`, offering safe value retrieval, bulk updates via sequences/iterators, and customizable merging of duplicate keys. It operates on `C.Tbl.t` structures with arbitrary value types, enabling efficient frequency counting, list conversions, and functional transformations of key-value pairs. Typical use cases include aggregating data from streams, maintaining dynamic mappings with atomic updates, and generating human-readable representations of structured data.",
      "description_length": 562,
      "index": 607,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Heuristics.Make.PS.PassiveSet",
      "library": "libzipperposition.calculi",
      "description": "This module manages a passive clause set with dynamic addition and removal, supporting incremental updates through signals. It provides direct access to the current clause set, queue state, and passive clause processing. Useful for implementing theorem proving strategies that require selective clause processing and monitoring.",
      "description_length": 328,
      "index": 608,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Fool.Make.C.Pos",
      "library": "libzipperposition.calculi",
      "description": "This module provides a function `at` that retrieves a term at a specific position within a given clause. It operates on clauses and positions, enabling precise navigation and manipulation of terms in first-order logic formulas. Use cases include proof search and term rewriting where access to specific subterms is required.",
      "description_length": 324,
      "index": 609,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.EnumTypes.Make.C.Pos",
      "library": "libzipperposition.calculi",
      "description": "This module provides a function `at` that retrieves a term at a specific position within a clause. It operates on clauses and positions, enabling precise navigation and manipulation of term structures. Useful for inspecting or transforming specific parts of logical expressions during proof search or term rewriting.",
      "description_length": 316,
      "index": 610,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Booleans.Make.C.Seq",
      "library": "libzipperposition.calculi",
      "description": "This module provides functions to extract literals, terms, and variables from a clause structure. It operates on clauses (`C.t`) and returns iterators over literals, terms, and typed variables. Useful for analyzing or transforming logical clauses during theorem proving or formula manipulation tasks.",
      "description_length": 300,
      "index": 611,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Superposition.Make.C.ClauseSet",
      "library": "libzipperposition.calculi",
      "description": "This module implements an ordered set interface for managing collections of logical clauses, supporting membership checks, union/intersection/difference operations, and ordered traversal via iteration or folding. It operates on `C.ClauseSet.t` structures with comparison logic derived from a fixed ordering, enabling transformations like filtering, partitioning, and predicate-based element selection while preserving set invariants. Designed for applications in automated reasoning, such as clause management in superposition calculus implementations, where ordered set manipulation and safe element access (e.g., minimal/maximal elements) are critical for inference steps.",
      "description_length": 674,
      "index": 612,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Heuristics.Make.PS.TermIndex",
      "library": "libzipperposition.calculi",
      "description": "This module organizes terms into an index optimized for fast unification and matching queries, enabling efficient retrieval of clauses based on term structure and position. It supports core operations like adding and removing terms with associated values, and allows iteration and folding over indexed data. Submodules extend this functionality to handle specific term properties and indexing strategies, such as path-based or symbol-based lookups. For example, it can quickly find all clauses containing a given subterm or identify matches for a query pattern during saturation-based theorem proving.",
      "description_length": 601,
      "index": 613,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Heuristics.Make.C.Eligible",
      "library": "libzipperposition.calculi",
      "description": "This module defines eligibility predicates for selecting literals in clausal reasoning tasks, such as resolution and paramodulation. It provides operations to filter literals based on properties like positivity, negativity, equation status, and maximality, and supports combining criteria using logical operators. These functions are used to control inference rule applications in automated theorem proving.",
      "description_length": 407,
      "index": 614,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Superposition.Make.PS.SubsumptionIndex",
      "library": "libzipperposition.calculi",
      "description": "This module organizes clauses using a subsumption index, enabling efficient addition, removal, and querying based on subsumption and alpha-equivalence. It treats clauses as literals and labels, supporting indexed retrieval and comparison through operations like subsumption checking and literal iteration. The core type `t` represents clauses from `PS.C.t`, allowing dependency tracking and ordering comparisons. For example, it can filter clauses that are subsumed by a given clause or identify alpha-equivalent clauses during theorem proving tasks.",
      "description_length": 550,
      "index": 615,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Superposition.Make.C.Pos",
      "library": "libzipperposition.calculi",
      "description": "This module provides a function `at` that retrieves a subterm from a given term at a specified position. It operates on terms and positions, enabling precise navigation within term structures. Use cases include analyzing or transforming specific parts of logical expressions during theorem proving or term rewriting tasks.",
      "description_length": 322,
      "index": 616,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Superposition.Make.C.Eligible",
      "library": "libzipperposition.calculi",
      "description": "This module defines eligibility criteria for selecting literals in superposition-based theorem proving. It provides functions to filter literals based on properties such as positivity, negativity, equation status, and maximality within a clause. These criteria are combined using logical operations to control which literals participate in inference rules like resolution and paramodulation.",
      "description_length": 391,
      "index": 617,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Superposition.Make.PS.CLAUSE_SET",
      "library": "libzipperposition.calculi",
      "description": "This module manages a dynamic set of clauses with operations to add or remove clauses and signals to notify when changes occur. It works with clause data types from the `PS.C` module and uses iterators to process multiple clauses efficiently. Concrete use cases include maintaining a clause database during theorem proving where incremental updates and event-driven responses are required.",
      "description_length": 389,
      "index": 618,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Higher_order.Make.C.WithPos",
      "library": "libzipperposition.calculi",
      "description": "This module represents clauses with a specific subterm and its position, enabling precise manipulation and analysis of terms within clauses. It provides comparison and pretty-printing operations for these annotated clauses. Useful for implementing higher-order reasoning rules that require tracking term positions within logical expressions.",
      "description_length": 341,
      "index": 619,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Hlt_elim.Make.C.Seq",
      "library": "libzipperposition.calculi",
      "description": "This module provides functions to extract literals, terms, and variables from a clause structure. It operates on clauses (`C.t`) and returns iterators over their components, including literals, terms, and typed variables. Useful for clause analysis and transformation in automated theorem proving tasks.",
      "description_length": 303,
      "index": 620,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Booleans.Make.C.WithPos",
      "library": "libzipperposition.calculi",
      "description": "This module represents clauses with a specific subterm and its position, enabling precise term manipulation and analysis. It provides comparison and pretty-printing operations for these structured clauses. Useful for tasks like subterm indexing, rewriting, or focused proof search where term positions matter.",
      "description_length": 309,
      "index": 621,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Heuristics.Make.C.ClauseSet",
      "library": "libzipperposition.calculi",
      "description": "This module offers ordered set operations for managing collections of clauses with functional transformations, supporting efficient membership checks, ordered traversal, and set algebra like union and difference. It works with immutable sets of ordered elements (`C.t`), providing utilities for filtering by predicates, extracting min/max elements, and converting between sequences, lists, and string representations. Designed for applications requiring ordered clause processing\u2014such as logical reasoning systems or proof search\u2014it enables safe element selection, partitioning, and structured iteration over ordered clause sets.",
      "description_length": 629,
      "index": 622,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Lazy_cnf.Make.C.ClauseSet",
      "library": "libzipperposition.calculi",
      "description": "This module implements an ordered set structure for managing collections of logical clauses, supporting efficient membership checks, insertion, deletion, and set algebra operations like union and difference. It provides ordered traversal, range queries, and transformation functions such as filtered mapping and partitioning, optimized for clause manipulation in formal verification tasks. Designed for use in theorem proving contexts, it facilitates operations like CNF conversion, clause elimination, and resolution-based reasoning through safe lookup variants and customizable serialization.",
      "description_length": 594,
      "index": 623,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Booleans.Make.C.Eligible",
      "library": "libzipperposition.calculi",
      "description": "This module defines eligibility criteria for selecting literals in a clause based on logical operations and properties such as positivity, negativity, maximality, and equation status. It provides functions to filter literals eligible for specific inference rules like resolution and paramodulation, and supports combining criteria using logical conjunction, disjunction, and negation. Use cases include controlling the application of inference rules in automated theorem proving by restricting which literals can be used in a given step.",
      "description_length": 537,
      "index": 624,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Heuristics.Make.PS.UnitIndex",
      "library": "libzipperposition.calculi",
      "description": "This module organizes and prioritizes equations and inequations for efficient retrieval during term rewriting and equational reasoning. It supports operations to add, remove, and query equations under substitutions, while its child module handles comparison, extraction, and priority assessment of individual equations. Users can, for example, index a set of rewrite rules and efficiently find applicable rules during proof search. The combination enables fast lookup and dynamic management of logical equations based on term structure and priority.",
      "description_length": 549,
      "index": 625,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Heuristics.Make.PS.ActiveSet",
      "library": "libzipperposition.calculi",
      "description": "This module maintains a dynamic set of clauses with signals for additions and removals. It supports adding or removing multiple clauses, retrieving the current set, and counting clauses. It is used to track active clauses during theorem proving where clause management is critical.",
      "description_length": 281,
      "index": 626,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Heuristics.Make.PS",
      "library": "libzipperposition.calculi",
      "description": "This module orchestrates clause prioritization, indexing, and set management for automated theorem proving. It integrates a priority queue for heuristic-driven clause selection, term and unit indexes for fast retrieval, and multiple clause sets for tracking active, passive, and simplified clauses. Operations include dynamic addition and removal of clauses with change notifications, priority-based scheduling, and efficient subsumption and unification queries. Example workflows include selecting ground clauses for expansion, pruning redundant clauses, or dynamically adjusting proof strategies based on term structure and goal proximity.",
      "description_length": 641,
      "index": 627,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Hlt_elim.Make.C",
      "library": "libzipperposition.calculi",
      "description": "This module manages clause metadata, logical analysis, and transformations while integrating specialized data structures and traversal utilities. It supports key operations like redundancy tracking, clause construction with trails and proofs, literal eligibility filtering, and term navigation via positional access. Data types include clauses (`C.t`), trails, substitutions, clause sets (`C.ClauseSet.t`), and term positions, with functions for normalization, inference planning, and proof tracking. Specific capabilities include literal selection with custom criteria, subterm manipulation, efficient aggregation with hash tables, and ordered clause set processing for deterministic theorem proving pipelines.",
      "description_length": 711,
      "index": 628,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Lazy_cnf.Make.C",
      "library": "libzipperposition.calculi",
      "description": "This module enables clause manipulation and analysis in automated theorem proving by combining CNF transformations, proof tracking, and inference control with structured data types like clauses with metadata, substitutions, and clause sets. It supports operations to manage clause properties, analyze term eligibility for inference rules, and extract or traverse logical components within clauses. Submodules enhance this functionality with mutable hash tables for efficient aggregation, ordered sets for clause collection management, literal and term selection predicates, and positional term access for precise subterm manipulation. Example uses include redundancy elimination, TSTP output generation, and implementing resolution or paramodulation strategies with fine-grained term analysis.",
      "description_length": 793,
      "index": 629,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Fool.Make.C",
      "library": "libzipperposition.calculi",
      "description": "This module manages clause metadata, transformations, and analysis for automated theorem proving, centered around clauses (`C.t`) and operations involving literals, substitutions, and proofs. It supports literal selection via eligibility criteria, ordered clause sets for efficient management, and term extraction for analysis or rewriting, enabling tasks like resolution control, clause simplification, and TSTP conversion. Submodules provide positional term access, structured clause representations, and functional set operations with ordered traversal and filtering. Examples include selecting maximal literals for paramodulation, maintaining ordered clause databases during saturation, and extracting subterms for proof search or rewriting steps.",
      "description_length": 751,
      "index": 630,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Superposition.Make.PS",
      "library": "libzipperposition.calculi",
      "description": "This module implements a superposition calculus for automated reasoning, managing clause processing through selection, simplification, and indexing mechanisms. It provides data structures for active, passive, and indexed clauses, supporting operations like subsumption checking, priority-based selection, and term indexing for efficient retrieval during proof search. Users can guide theorem proving tasks by configuring clause priorities, tracking clause state changes, and applying transformations for redundancy elimination or format conversion. Submodules enhance these capabilities with specialized indices, visualization exports, and trail-based modifications, enabling concrete workflows such as selecting resolution candidates, filtering subsumed clauses, or exporting proof state structures in DOT format.",
      "description_length": 814,
      "index": 631,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.EnumTypes.Make.C",
      "library": "libzipperposition.calculi",
      "description": "This module manages clause metadata, trail-based reasoning, and inference control for automated theorem proving tasks. It works with clauses, trails, substitutions, and scoped terms to support redundancy checks, proof reconstruction, and clause normalization, while submodules enable positional term analysis, literal extraction, ordered clause sets, hash tables with custom merge logic, literal eligibility filtering, and term navigation by position. Operations include filtering clauses for resolution, grounding formulas, and generating TSTP output, with data structures optimized for efficient iteration, comparison, and transformation. Examples include tracking active clauses during proof search, selecting eligible literals for paramodulation, and maintaining dynamic clause sets with ordered unions and intersections.",
      "description_length": 825,
      "index": 632,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Booleans.Make.C",
      "library": "libzipperposition.calculi",
      "description": "This module provides core operations for manipulating logical clauses and their subterms, integrating functionality for term extraction, literal analysis, and eligibility filtering. It defines clauses as the primary data type, with operations to extract and traverse literals, terms, and variables, while supporting transformations based on term positions and logical properties. Child modules enable precise subterm access, structured comparisons, and eligibility-based literal selection, allowing tasks like focused proof search, rewriting, and clause analysis. For example, users can extract a literal at a given position, iterate over all variables in a clause, or select eligible literals for resolution based on positivity and maximality.",
      "description_length": 744,
      "index": 633,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Superposition.Make.C",
      "library": "libzipperposition.calculi",
      "description": "This module manages logical clauses with support for property tracking, transformation, and analysis, working with data types such as `C.t`, trails, proofs, and term orderings. It enables clause modification through substitutions and simplifications, redundancy checks, literal selection, and proof extraction, with use cases in theorem proving and automated reasoning. Submodules extend this functionality with structured term manipulation, literal and variable extraction, ordered clause set operations, and eligibility-based inference control, while a dedicated hash table supports efficient data aggregation and structured traversal. Together, they provide a comprehensive toolkit for clause-level reasoning, including positional term access, dynamic data handling, and precise control over inference rule application.",
      "description_length": 822,
      "index": 634,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Heuristics.Make.C",
      "library": "libzipperposition.calculi",
      "description": "This module manages clause metadata and transformations for theorem proving tasks, operating on clauses with literals, substitutions, and bitvectors to support analyses of structural properties and heuristic-driven inference eligibility. It enables precise term manipulation through subterm tracking, literal extraction, and position-based access, facilitating rewriting, inference rule implementation, and proof search. The module supports efficient data aggregation and mapping through customizable hash tables, while eligibility predicates filter literals for resolution and paramodulation. Ordered sets provide functional operations for managing and transforming immutable clause collections with ordered traversal and set algebra.",
      "description_length": 735,
      "index": 635,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Higher_order.Make.C",
      "library": "libzipperposition.calculi",
      "description": "This module manages higher-order clauses (`C.t`) with rich metadata, supporting operations like redundancy checking, proof-aware transformations, and eligibility analysis for inference rules. It enables literal selection based on logical properties, term and variable extraction for indexing, and ordered set manipulation for deterministic clause processing. Submodules facilitate positional term access, hash-based clause storage with polymorphic values, and positional tracking for precise clause analysis. Examples include filtering literals for resolution, extracting subterms during rewriting, and maintaining ordered clause sets for theorem proving workflows.",
      "description_length": 665,
      "index": 636,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Hlt_elim.S-Env-StmQ",
      "library": "libzipperposition.calculi",
      "description": "This module implements a priority queue for managing streams of clauses in a theorem proving context. It provides operations to add streams or lists of streams to the queue, inspect its size, and extract clauses according to different fairness and recursion strategies. The queue is parameterized by a weight function that determines stream priority, and supports configurations like a default queue or custom queues with specified guard and ratio parameters.",
      "description_length": 459,
      "index": 637,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Lazy_cnf.S-C-ClauseSet",
      "library": "libzipperposition.calculi",
      "description": "This module provides ordered set operations for managing collections of clauses, supporting membership checks, union/intersection/difference, and ordered traversal. It works with strictly ordered sets of clauses (`C.ClauseSet.t`), enabling transformations like filtering, mapping, and partitioning while preserving structural constraints. Use cases include logical reasoning pipelines where clause ordering dictates inference steps, such as in resolution theorem proving or CNF transformation workflows that require deterministic element selection and set comparisons.",
      "description_length": 568,
      "index": 638,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Superposition_intf.S-PS-UnitIndex",
      "library": "libzipperposition.calculi",
      "description": "This module implements a term index for efficient retrieval of equations and inequations based on matching and substitution. It supports operations to add, remove, and query indexed terms, with capabilities to iterate over stored equations and visualize the index structure. It is used in theorem proving to quickly find applicable rewrite rules or constraints during inference steps.",
      "description_length": 384,
      "index": 639,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Fool.S-Env-FormRename-Ctx",
      "library": "libzipperposition.calculi",
      "description": "This module suite enables managing logical contexts through skolemization, term ordering, and signature manipulation, working with terms, types, and symbols from the Logtk library. It supports automated reasoning in first-order logic by handling injectivity checks for function symbols and processing literals, which are essential for formal proof construction and equality constraint resolution. Key applications include theorem proving and formal verification tasks requiring precise term analysis and context-sensitive logical transformations.",
      "description_length": 546,
      "index": 640,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Heuristics.S-Env-ProofState-SubsumptionIndex",
      "library": "libzipperposition.calculi",
      "description": "This module implements a subsumption index for managing and querying clauses in a proof state. It supports operations to add, remove, and retrieve clauses based on subsumption and alpha-equivalence relations, using literals and labels as keys. Use cases include efficient clause indexing and retrieval during automated theorem proving processes.",
      "description_length": 345,
      "index": 641,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Libzipperposition_calculi.Fool.S-Env-Stm-Ctx-Lit",
      "library": "libzipperposition.calculi",
      "description": "This module manages bidirectional conversions between literals and formulas using hooks for customization. It provides functions to register and retrieve conversion hooks, as well as to convert between literal and formula representations. It works directly with `Logtk.Literal.t` and `Logtk.SLiteral.t` types, supporting use cases like integrating custom literal encodings or decoding literals into higher-level formula structures during proof search.",
      "description_length": 451,
      "index": 642,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Heuristics.S-Env-Ctx-Lit",
      "library": "libzipperposition.calculi",
      "description": "This module manages bidirectional conversions between literals and formulas using customizable hooks. It provides functions to register and retrieve conversion hooks for transforming literals to formulas and vice versa, as well as direct conversion functions that apply these hooks. It works with `Logtk.Literal.t` and `Logtk.SLiteral.t` types, specifically handling atomic formulas during conversion.",
      "description_length": 401,
      "index": 643,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Bce_pe_fixpoint.S-Env-ProofState-SubsumptionIndex-C",
      "library": "libzipperposition.calculi",
      "description": "This module defines operations for comparing clauses, extracting literals, and retrieving label subsets from clauses. It works with the clause type `C.t` and provides direct access to structural components like literals and labels. Concrete use cases include subsumption checking and clause indexing in automated theorem proving.",
      "description_length": 329,
      "index": 644,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Fool.S-Env-FormRename",
      "library": "libzipperposition.calculi",
      "description": "This module handles formula renaming and Skolemization during higher-order reasoning. It provides operations to rename formulas, detect renaming clauses, and introduce predicate Skolems with configurable freshness strategies. Key data structures include clauses and term-level representations of formulas, used in transformations and proof search involving higher-order logic.",
      "description_length": 376,
      "index": 645,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Superposition_intf.S-PS-CQueue",
      "library": "libzipperposition.calculi",
      "description": "This module provides priority queue operations for managing clauses in automated theorem provers, supporting prioritization strategies like FIFO, heuristic exploration, goal orientation, and grounding. It enables efficient insertion, retrieval, membership checks, and removal of clauses, along with pretty-printing, to optimize proof search in superposition calculus-based systems by dynamically ordering clauses based on relevance or urgency.",
      "description_length": 443,
      "index": 646,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Bce_pe_fixpoint.S-Env-Stm-Ctx-Lit",
      "library": "libzipperposition.calculi",
      "description": "This module manages bidirectional conversions between literals and formulas using hooks. It provides functions to register and retrieve conversion hooks, and to convert atomic formulas to literals and vice versa. It works with `Logtk.Literal.t` and `Logtk.SLiteral.t` types, specifically handling term-based logical literals.",
      "description_length": 325,
      "index": 647,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Lazy_cnf.S-Env-ProofState-TermIndex",
      "library": "libzipperposition.calculi",
      "description": "This module provides term indexing structures optimized for efficient insertion, deletion, and query operations on logical terms paired with positional metadata, supporting specialized retrieval of unifiable terms (including decidable and infinite unification cases), generalizations, and specializations. It operates on first-order and higher-order terms within a proof state context, enabling applications like automated theorem proving or formal verification workflows. A dedicated `to_dot` utility visualizes index contents via graph representations, aiding debugging and analysis of term relationships.",
      "description_length": 607,
      "index": 648,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "Libzipperposition_calculi.Hlt_elim.S-Env-Stm",
      "library": "libzipperposition.calculi",
      "description": "This module manages streams of clauses with associated metadata, supporting operations to create, compare, and manipulate streams based on their content and provenance. It works with streams of clauses (`C.t option OSeq.t`), tracking parent clauses, penalties, and access counts. Concrete use cases include managing inference results in theorem proving, retrieving clause sequences with controlled consumption via `drip` and `drip_n`, and identifying or comparing streams based on their structure or origin.",
      "description_length": 507,
      "index": 649,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Bce_pe_fixpoint.S-Env-FormRename-Ctx-Lit",
      "library": "libzipperposition.calculi",
      "description": "This module manages bidirectional conversions between literals and formulas using customizable hooks. It provides functions to register and retrieve conversion hooks, ensuring that only atomic formulas are converted to literals. It directly supports transformations on `Logtk.Literal.t` and `Logtk.SLiteral.t` values, targeting use cases like formula preprocessing and literal normalization in theorem proving.",
      "description_length": 410,
      "index": 650,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Pred_elim.S-Env-Stm-Ctx",
      "library": "libzipperposition.calculi",
      "description": "This module provides operations for logical context management, including skolemization, term ordering, and symbol declaration handling, primarily working with terms, types, and signatures. It supports first-order logic reasoning through injectivity checks for symbols and manipulation of logical literals, enabling tasks like formula simplification and proof search. Specific utilities include analyzing symbol properties and managing logical context during deduction processes.",
      "description_length": 479,
      "index": 651,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Fool.S-Env-ProofState-CQueue-WeightFun",
      "library": "libzipperposition.calculi",
      "description": "This module defines weight functions that compute integer weights for proof state clause queues, guiding clause selection during automated reasoning. It supports operations like parsing weight function strings, combining weighted functions, and applying heuristic-based penalties or preferences for specific clause properties such as goal proximity, horn shape, or groundness. Use cases include tuning clause selection strategies in theorem proving by favoring certain logical structures or penalizing complexity.",
      "description_length": 513,
      "index": 652,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Lazy_cnf.S-Env-ProofState-CQueue-C",
      "library": "libzipperposition.calculi",
      "description": "This module provides operations for clause manipulation, including transformation, conversion, and proof tracking, alongside analysis of clause properties like redundancy and inference eligibility. It operates on clauses (`Env.ProofState.CQueue.C.t`) and clause sets (`ClauseSet.t`), integrating term-level analysis, substitution handling, and proof-state metadata for automated reasoning. Use cases include lazy CNF conversion, theorem proving with resolution or paramodulation, and proof-step management in formal verification contexts.",
      "description_length": 538,
      "index": 653,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Fool.S-Env-ProofState-TermIndex-Leaf",
      "library": "libzipperposition.calculi",
      "description": "This module implements a term indexing structure that supports efficient insertion, removal, and querying of logical terms within a proof state. It provides operations for unification and matching between indexed terms and query terms, returning substitutions that make the terms compatible. It is used in automated theorem proving to quickly find relevant clauses or terms during inference steps.",
      "description_length": 397,
      "index": 654,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Higher_order.Make",
      "library": "libzipperposition.calculi",
      "description": "This module implements higher-order reasoning rules for term structures, enabling the registration of deduction rules and transformation of clauses through primitive enumeration. It operates on clauses and terms represented by `Env.C.t`, supporting advanced proof search and clause normalization in automated theorem proving. The child module enhances this functionality by managing higher-order clauses with metadata, offering redundancy checks, literal selection, and ordered set manipulation for deterministic processing. Specific capabilities include filtering literals for resolution, extracting subterms during rewriting, and maintaining ordered clause sets for theorem proving workflows.",
      "description_length": 694,
      "index": 655,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Bce.S-Env-ProofState-TermIndex",
      "library": "libzipperposition.calculi",
      "description": "This module implements a term index structure for managing logical terms in a proof state environment, enabling operations like adding, removing, and updating terms alongside queries for unifiables, generalizations, and specializations. It supports higher-order reasoning and scoped term manipulations, working directly with logical terms structured for efficient retrieval. Its functionality is critical for proof search tasks requiring rapid term matching and for visualizing term relationships through DOT format exports.",
      "description_length": 524,
      "index": 656,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Pred_elim.S-Env-Stm-Ctx-Lit",
      "library": "libzipperposition.calculi",
      "description": "This module manages bidirectional conversions between atomic formulas and literals using customizable hooks. It provides functions to register and retrieve conversion hooks, as well as to perform the actual conversions. It works with types like `Logtk.Literal.t` and `Logtk.SLiteral.t`, targeting use cases such as integrating custom term representations with theorem proving systems.",
      "description_length": 384,
      "index": 657,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Fool.S-Env-ProofState-SubsumptionIndex",
      "library": "libzipperposition.calculi",
      "description": "This module implements a subsumption index for managing and querying clauses in a proof state. It supports operations to add, remove, and retrieve clauses based on subsumption and alpha-equivalence relations, using literals and labels as keys. Use cases include efficient clause indexing and retrieval during automated theorem proving processes.",
      "description_length": 345,
      "index": 658,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Libzipperposition_calculi.Qle.S-Env-ProofState-PassiveSet",
      "library": "libzipperposition.calculi",
      "description": "This module manages a passive clause set with dynamic addition and removal, supporting incremental updates and real-time monitoring through signals. It provides direct access to the current clause set, checks clause status, and processes clauses in sequence via a queue. Concrete use cases include managing passive clauses during automated theorem proving, enabling selective clause processing and external monitoring of clause state changes.",
      "description_length": 442,
      "index": 659,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Booleans.S-Env-FormRename",
      "library": "libzipperposition.calculi",
      "description": "This module handles formula renaming and Skolemization during proof search. It provides operations to detect renaming clauses, introduce predicate Skolems, and rename formulas based on context and polarity. Key data structures include clauses and formula renaming tables, with use cases in managing logical equivalences and introducing fresh symbols during clause normalization.",
      "description_length": 378,
      "index": 660,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Fool.S-Env",
      "library": "libzipperposition.calculi",
      "description": "This module supports operations like clause simplification, redundancy checking, inference generation, and rule-based transformations for saturation-based theorem proving. It operates on clauses, literals, terms, and proof state components such as active/passive clause sets, statement queues, and dynamic configuration state objects. These capabilities enable proof search optimization, normalization, and automated deduction tasks requiring iterative clause manipulation and state management.",
      "description_length": 494,
      "index": 661,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Bce_pe_fixpoint.S-Env-ProofState-UnitIndex-E",
      "library": "libzipperposition.calculi",
      "description": "This module represents and compares indexed equations and inequations, providing operations to extract their components and determine their priority. It works with terms from `Logtk.Term` and clauses from `C`, organizing them as tuples in the form `(left, right, is_equation, clause)`. It is used to manage and prioritize equations during theorem proving, particularly in clause processing and indexing.",
      "description_length": 403,
      "index": 662,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Lazy_cnf.S-Env-FormRename-Ctx-Lit",
      "library": "libzipperposition.calculi",
      "description": "This module provides functions to convert between logical literals and their atomic formula representations, using customizable hooks for preprocessing and postprocessing. It operates on `Logtk.Literal.t` and `Logtk.Term.t Logtk.SLiteral.t` types, ensuring bidirectional transformation while enforcing atomicity constraints. Concrete use cases include integrating CNF conversion pipelines with custom literal normalization or analysis passes.",
      "description_length": 442,
      "index": 663,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Qle.S-Env-C-Eligible",
      "library": "libzipperposition.calculi",
      "description": "This module defines eligibility criteria for selecting literals in a clause based on logical operations and properties such as positivity, negativity, maximality, and equation status. It provides functions to filter literals by resolution, paramodulation, and custom predicates, and supports combining criteria using logical operators (and, or, not). Use cases include guiding inference rules in automated theorem proving by restricting which literals can trigger specific proof steps.",
      "description_length": 485,
      "index": 664,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Booleans.S-Env-ProofState-CQueue-WeightFun",
      "library": "libzipperposition.calculi",
      "description": "This module defines weight functions that compute integer weights for clauses in a proof state priority queue. It supports operations like parsing weight function descriptions, combining multiple weight functions with coefficients, and applying penalties or preferences based on clause properties such as goal proximity, horn shape, or groundness. Use cases include guiding clause selection in automated theorem proving by prioritizing clauses with specific logical characteristics.",
      "description_length": 482,
      "index": 665,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Heuristics.S-Env-ProofState",
      "library": "libzipperposition.calculi",
      "description": "Manages clause prioritization and selection with a clause queue (CQueue), efficient term-based indexing structures (TermIndex, UnitIndex, SubsumptionIndex), and categorized clause sets (ActiveSet, SimplSet, PassiveSet). It tracks proof state statistics and provides detailed state inspection through `pp` and `debug`. Used to organize and optimize clause processing in automated theorem proving.",
      "description_length": 395,
      "index": 666,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.EnumTypes.S-C-Pos",
      "library": "libzipperposition.calculi",
      "description": "This module provides the `at` function, which retrieves a subterm at a specified position within a term. It operates on terms and positions, enabling precise navigation and manipulation of term structures. A concrete use case is extracting specific components from complex logical expressions during proof search or term rewriting.",
      "description_length": 331,
      "index": 667,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Booleans.S-Env-StmQ",
      "library": "libzipperposition.calculi",
      "description": "This module implements a priority queue for managing streams of clauses with weighted priorities. It supports operations to add streams or lists of streams, check queue state, and extract clauses either individually or in batches, using fair or guarded strategies. The queue is used to prioritize clause selection in theorem proving, where streams represent sources of clauses and weights determine processing order.",
      "description_length": 416,
      "index": 668,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Superposition_intf.S-Env-ProofState-module-type-CLAUSE_SET",
      "library": "libzipperposition.calculi",
      "description": "This module manages a dynamic set of clauses with operations to add or remove clauses and attach event handlers for changes. It provides signals triggered on clause insertion or removal and processes clause updates via iterators. It is used in theorem proving systems to track and react to modifications in clause sets during proof search.",
      "description_length": 339,
      "index": 669,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Hlt_elim.S-Env-ProofState-ActiveSet",
      "library": "libzipperposition.calculi",
      "description": "This module manages a dynamic set of clauses with signals for additions and removals. It provides operations to add or remove clauses, retrieve the current set, and count clauses. Useful for tracking clause changes in a proof state, such as during theorem proving or constraint solving.",
      "description_length": 286,
      "index": 670,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Superposition_intf.S-Env-Ctx",
      "library": "libzipperposition.calculi",
      "description": "This module provides operations for managing logical contexts in theorem proving, including term orderings, selection functions, skolemization, and signature management. It works with terms, types, and symbols from the Logtk library, along with logical literals via the `Lit` module, supporting tasks like term comparison, symbol injectivity analysis, and context updates through signal-driven modifications. These capabilities are critical in automated reasoning systems that implement superposition calculus for formal verification and proof automation.",
      "description_length": 555,
      "index": 671,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Heuristics.S-C-Seq",
      "library": "libzipperposition.calculi",
      "description": "This module provides functions to extract literals, terms, and variables from a given clause structure. It operates on clauses (`C.t`) and iterates over their components using specific data types like literals, terms, and typed variables. It is useful for implementing clause analysis and transformation heuristics in automated theorem proving.",
      "description_length": 344,
      "index": 672,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Higher_order.S-Env",
      "library": "libzipperposition.calculi",
      "description": "This module facilitates logical deduction and clause manipulation in higher-order theorem proving through operations like inference rule application, simplification (e.g., rewriting, tautology detection, normalization), and redundancy checks. It operates on clauses, proof states, contexts, and clause sets, supporting use cases such as predicate elimination, trail-based reasoning, and lifecycle-managed inference streams. Key patterns include rule registration for unary/multi-clause simplifications, flex state management, and signal-driven integration with proof search control.",
      "description_length": 582,
      "index": 673,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Booleans.S-Env-C-Eligible",
      "library": "libzipperposition.calculi",
      "description": "This module defines eligibility criteria for selecting literals in a clause based on boolean operations and logical combinations. It provides functions to filter literals by resolution, paramodulation, positivity, negativity, maximality, and equation status, along with logical operators to combine these conditions. These criteria are used to control inference rules in automated theorem proving, such as determining which literals can participate in resolution or paramodulation steps.",
      "description_length": 487,
      "index": 674,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Superposition_intf.S-Env-C-Tbl",
      "library": "libzipperposition.calculi",
      "description": "This module provides imperative hash table operations for a polymorphic table with keys of type `Env.C.t`, supporting insertion, lookup, iteration, folding, and sequence conversion. It includes utilities for safe value updates with custom collision handling, atomic modifications, and lazy additions, alongside specialized functions for counting elements from sequences and resolving conflicts during table construction. Typical use cases involve tracking term frequencies from iterative data sources, merging key-value pairs with user-defined combination logic, or maintaining stateful counters with atomic increments.",
      "description_length": 619,
      "index": 675,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Heuristics.S-PS-UnitIndex-E",
      "library": "libzipperposition.calculi",
      "description": "This module represents and compares indexed equations and inequations, providing a total order via `compare`, extraction of term components with `extract`, and a heuristic `priority` function. It operates on pairs of terms along with a boolean sign and a clause, and is used to manage and prioritize equations during theorem proving. Concrete use cases include selecting and indexing key equations for rewriting or resolution steps.",
      "description_length": 432,
      "index": 676,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Hlt_elim.S-Env-Ctx-Lit",
      "library": "libzipperposition.calculi",
      "description": "This module manages bidirectional conversions between literals and formulas using customizable hooks. It provides functions to register and retrieve conversion hooks for transforming literals to formulas and vice versa, as well as direct conversion functions that apply these hooks. It operates specifically on `Logtk.Literal.t` and `Logtk.Term.t Logtk.SLiteral.t` types, enforcing atomic formula constraints during conversion.",
      "description_length": 427,
      "index": 677,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Pred_elim.S-Env-ProofState-TermIndex",
      "library": "libzipperposition.calculi",
      "description": "This module provides a term indexing structure optimized for efficient retrieval of terms and their associated elements (`C.WithPos.t`) through unification, generalization, and specialization operations. It supports dynamic updates, iteration, and specialized queries over indexed terms, leveraging scoped substitutions to manage term relationships. The module is particularly useful in automated reasoning systems requiring fast term matching and substitution management, with additional debugging capabilities via DOT graph visualization of the index structure.",
      "description_length": 563,
      "index": 678,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.EnumTypes.Make",
      "library": "libzipperposition.calculi",
      "description": "This module defines finite enumerated types using logical type representations and generates all possible term instances for case analysis in proofs. It integrates with submodules that manage clause metadata, control inference steps, and optimize term manipulation for automated reasoning tasks. Key data types include `Logtk.Type.t` for type definitions, `Libzipperposition_calculi.EnumTypes.term` for typed terms, and supporting structures like clauses, substitutions, and trails. You can use it to declare an enumerated type like `bool` with values `true` and `false`, then automatically expand logical expressions over all cases during proof simplification.",
      "description_length": 661,
      "index": 679,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Qle.S-Env-ProofState",
      "library": "libzipperposition.calculi",
      "description": "This module manages the proof state in a theorem proving process, providing operations for clause manipulation and indexing. It works with clauses, terms, and proof states, offering concrete functionality for storing, retrieving, and simplifying logical units. Use cases include maintaining active and passive clause sets, performing subsumption checks, and tracking proof statistics during automated reasoning tasks.",
      "description_length": 417,
      "index": 680,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Hlt_elim.S-Env-ProofState-CQueue",
      "library": "libzipperposition.calculi",
      "description": "This module provides priority-based management of clauses through operations like insertion, retrieval of highest-priority elements, and strategy-driven selection (e.g., FIFO, goal-oriented, ground clause prioritization). It operates on clause queues (`Env.ProofState.CQueue.t`) and individual clauses, supporting passive set manipulations, membership checks, and debugging via string conversions. These capabilities are tailored for automated theorem proving workflows where dynamic clause prioritization and efficient queue state management are critical.",
      "description_length": 556,
      "index": 681,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.EnumTypes.S-Env-Stm-Ctx",
      "library": "libzipperposition.calculi",
      "description": "This module offers operations for logical context management, including skolemization, term ordering, and injectivity checks for identifiers, alongside literal manipulation capabilities. It operates on terms, literals, and signatures, supporting tasks like logical inference, term rewriting, and normalization in theorem proving systems. Key components include analysis of literal properties and symbol declarations, which are critical for resolution-based reasoning and unification processes.",
      "description_length": 493,
      "index": 682,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Lazy_cnf.S-Env-ProofState-SubsumptionIndex",
      "library": "libzipperposition.calculi",
      "description": "This module implements a subsumption index for managing and querying clauses in a proof state. It supports operations to add, remove, and retrieve clauses based on subsumption and alpha-equivalence relations, using literals and labels as keys. The index is used to efficiently find clauses that are subsumed by or subsume a given clause, enabling optimizations in automated theorem proving.",
      "description_length": 390,
      "index": 683,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Pred_elim.S-Env-C-Tbl",
      "library": "libzipperposition.calculi",
      "description": "This module offers operations for hash tables mapping keys of type `Env.C.t` to arbitrary values, supporting creation, modification, and querying with custom conflict resolution. It provides utilities for bulk updates from sequences, atomic value transformations like incrementing, and iteration over keys or values, with specialized handling for counting and aggregation tasks. Typical use cases include tracking term frequencies, managing dynamic key-value associations with merge strategies, and processing structured data streams into tabular form.",
      "description_length": 552,
      "index": 684,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Bce.S-Env-ProofState-CQueue-C",
      "library": "libzipperposition.calculi",
      "description": "This module offers operations to manage clause properties like redundancy and goal distance, manipulate clause trails and proofs, and analyze structural features such as literal eligibility and term properties. It works with clauses represented as `Env.ProofState.CQueue.C.t`, alongside substitutions, bitvectors, and proof-specific structures to track dependencies and logical origins. Designed for theorem proving workflows, it supports tasks like heuristic-driven simplification, proof reconstruction, and TSTP-formatted output generation through clause transformation and term grounding.",
      "description_length": 591,
      "index": 685,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.EnumTypes.S-Env-ProofState-ActiveSet",
      "library": "libzipperposition.calculi",
      "description": "This module manages a dynamic set of clauses with support for adding, removing, and querying clauses. It provides signals for tracking clause additions and removals, along with functions to retrieve the current clause set and its size. It is used in theorem proving contexts to maintain and monitor the active clause set during proof search.",
      "description_length": 341,
      "index": 686,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Lazy_cnf.S-Env-ProofState-CQueue",
      "library": "libzipperposition.calculi",
      "description": "This module manages clause prioritization and selection in automated reasoning systems through operations like inserting clauses into queues, selecting top-priority elements, and applying strategies such as goal-oriented or ground-first processing. It operates on priority queues (`Env.ProofState.CQueue.t`) and individual clauses (`Env.ProofState.CQueue.C.t`), supporting use cases in proof state exploration, passive set manipulation, and debugging via membership checks, removals, and human-readable output generation.",
      "description_length": 521,
      "index": 687,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Heuristics.S-Env-ProofState-CQueue-PriorityFun",
      "library": "libzipperposition.calculi",
      "description": "This module defines a priority function type used to assign integer weights to proof state queues, guiding heuristic selection in automated reasoning. It includes a parser to convert string descriptions into corresponding priority functions. Concrete use cases include configuring proof search strategies by prioritizing certain proof paths based on syntactic or semantic criteria.",
      "description_length": 381,
      "index": 688,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Booleans.S-Env-Stm-Ctx",
      "library": "libzipperposition.calculi",
      "description": "This module manages logical contexts for theorem proving, enabling operations like term ordering, symbol signature manipulation, and skolemization state tracking. It works with logical literals, symbols, and term structures, supporting tasks like injectivity checks, literal normalization, and unification. These capabilities are critical for automated reasoning systems in formal verification and logic-based analysis workflows.",
      "description_length": 429,
      "index": 689,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Bce_pe_fixpoint.S-Env-C-Eligible",
      "library": "libzipperposition.calculi",
      "description": "This module defines eligibility criteria for selecting literals in a clause based on specific logical properties. It provides functions to filter literals by resolution, paramodulation, positivity, negativity, maximality, and equation status, as well as logical combinations of these conditions. These criteria are used to control inference rules in automated theorem proving, such as restricting resolution or paramodulation steps to certain literals.",
      "description_length": 452,
      "index": 690,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Bce.S-Env",
      "library": "libzipperposition.calculi",
      "description": "This module provides operations for managing clause sets, defining rule types, and implementing simplification strategies in a theorem proving system. It works with clauses, proof states, flex state configurations, and rule types like backward redundancy checks, multi-simplification rules, and inference generators. Use cases include automated reasoning tasks requiring clause normalization, redundancy elimination, logical inference generation, and event-driven proof state updates.",
      "description_length": 484,
      "index": 691,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Hlt_elim.S-Env-ProofState-TermIndex",
      "library": "libzipperposition.calculi",
      "description": "This module implements a term index structure that enables efficient management of logical terms paired with arbitrary data through operations like insertion, unification-based querying, and iterative traversal. It supports advanced operations to retrieve unifiable terms, generalizations, and specializations, which are critical for theorem proving and logic engine applications. A dedicated function also allows visualizing the index\u2019s structure via the DOT format, using a custom printer for element representation.",
      "description_length": 518,
      "index": 692,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Lazy_cnf.Make",
      "library": "libzipperposition.calculi",
      "description": "This module orchestrates lazy CNF transformation during theorem proving by integrating core clause management with structured analysis and inference control. It centers on clauses with metadata, substitutions, and clause sets, supporting operations like redundancy elimination, literal selection, and term traversal, while submodules provide efficient aggregation, ordered collections, and positional access for precise manipulation. Functionality enables incremental formula conversion, proof-guided clause updates, and strategy-specific inference such as resolution or paramodulation. Example applications include TSTP output generation and term eligibility checks for dynamic proof search.",
      "description_length": 692,
      "index": 693,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Higher_order.S-Env-C-Pos",
      "library": "libzipperposition.calculi",
      "description": "This module provides a function `at` that retrieves a term from a given position in an environment. It operates on environments (`Env.C.t`) and positions (`Logtk.Position.t`), returning terms (`Logtk.Term.t`). A concrete use case is extracting specific subterms during proof search or term analysis in automated theorem proving.",
      "description_length": 328,
      "index": 694,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Qle.S-Env-ProofState-TermIndex-Leaf",
      "library": "libzipperposition.calculi",
      "description": "This module implements a term index structure for efficient retrieval of elements based on term unification and matching. It supports operations like adding or removing elements associated with terms, iterating and folding over indexed terms, and performing scoped unification and matching queries with substitution tracking. It is used in proof search procedures to quickly find relevant terms or clauses that unify or match a given pattern.",
      "description_length": 442,
      "index": 695,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Fool.S-C-WithPos",
      "library": "libzipperposition.calculi",
      "description": "This module represents clauses with a specific subterm and its position, enabling precise term manipulation and analysis. It provides comparison and pretty-printing operations for these structured clauses. Useful for tasks like subterm indexing, rewriting, or focused proof search where term positions matter.",
      "description_length": 309,
      "index": 696,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Fool.Make",
      "library": "libzipperposition.calculi",
      "description": "This module simplifies first-order logic clauses by normalizing structures and removing tautologies, operating on terms and clauses defined in supporting modules. It integrates metadata handling, literal selection, and ordered clause management to support tasks like resolution control and proof search. Specific capabilities include eliminating redundant clauses, selecting maximal literals for paramodulation, and maintaining efficient clause databases during saturation. Submodules enable positional term access, structured representations, and functional set operations with ordered traversal and filtering.",
      "description_length": 611,
      "index": 697,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Qle.S-Env-ProofState-CQueue-C",
      "library": "libzipperposition.calculi",
      "description": "This module manages clause properties like redundancy, simplification status, and goal-related metadata, while enabling structural analysis of literals, term properties, and eligibility for inference rules. It operates on clauses with associated proof data and trails (boolean sequences tracking derivation paths), alongside substitutions, clause sets, and bitvectors, supporting transformations such as grounding, heuristic measurement, and literal selection. These features are applied in automated reasoning tasks",
      "description_length": 516,
      "index": 698,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Lazy_cnf.S-Env-C-Eligible",
      "library": "libzipperposition.calculi",
      "description": "This module defines eligibility criteria for selecting literals in clausal reasoning, primarily used in resolution and paramodulation operations. It provides functions to filter literals based on properties like positivity, negativity, maximality, and equation status, as well as logical combinations of these criteria. These operations are applied to clauses to determine which literals can participate in inference steps during automated theorem proving.",
      "description_length": 456,
      "index": 699,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Booleans.Make",
      "library": "libzipperposition.calculi",
      "description": "This module implements Boolean simplification and propagation rules for a theorem proving system, working with clauses and literals represented in structures from the `E` and `C` modules. It provides core operations for manipulating logical clauses, including literal extraction, term traversal, and eligibility-based filtering, supporting transformations like normalization, tautology detection, and resolution-based inference. Child modules enable precise subterm access, structured comparisons, and literal selection based on logical properties, allowing tasks such as focused proof search and clause analysis. For example, users can extract literals at specific positions, iterate over variables in a clause, or derive new clauses through eligibility-driven resolution.",
      "description_length": 773,
      "index": 700,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Superposition_intf.S-PS-CQueue-C",
      "library": "libzipperposition.calculi",
      "description": "This module provides operations for managing and analyzing clauses in a superposition calculus, focusing on boolean flag manipulation (e.g., redundancy, activation status), literal selection, substitution application, and proof extraction. It operates on clause structures (`PS.CQueue.C.t`), substitutions, trails, and bitvectors to support tasks like redundancy elimination, resolution/paramodulation eligibility checks, and \u03b7-reduction. Specific use cases include automated theorem proving for goal-oriented reasoning, proof analysis under valuations, and generating TSTP-formatted output for formal verification workflows.",
      "description_length": 625,
      "index": 701,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Qle.S-Env-FormRename-Ctx-Lit",
      "library": "libzipperposition.calculi",
      "description": "This module manages bidirectional conversions between literals and atomic formulas using customizable hooks. It provides functions to register and retrieve conversion hooks, as well as to perform the actual conversions between `Logtk.Literal.t` and `Logtk.Term.t Logtk.SLiteral.t`. It is used to integrate literal-level operations with term-level representations in proof search and rewriting contexts.",
      "description_length": 402,
      "index": 702,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.EnumTypes.S-Env-C",
      "library": "libzipperposition.calculi",
      "description": "This module provides operations for managing clause metadata (e.g., redundancy flags, eligibility status), analyzing clause structure (e.g., literal selection, maximal terms), and transforming clauses through substitutions, grounding, and proof manipulations. It operates on clauses (`Env.C.t`), trails, proof steps, and associated data structures like clause sets and term positions. These capabilities support critical theorem proving tasks such as inference rule eligibility checks, goal derivation verification, and TSTP-compliant output generation for automated reasoning systems.",
      "description_length": 585,
      "index": 703,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Heuristics.S-Env-Stm",
      "library": "libzipperposition.calculi",
      "description": "This module manages streams of clauses with associated metadata, supporting operations to create, compare, and manipulate streams based on their content and provenance. It provides functions to extract elements incrementally, track access attempts, and apply penalties for heuristic control in clause selection. Concrete use cases include managing inference results in automated theorem proving, where streams represent sequences of derived clauses that are processed lazily and prioritized based on heuristic metrics.",
      "description_length": 518,
      "index": 704,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Heuristics.S-Env-Stm-Ctx-Lit",
      "library": "libzipperposition.calculi",
      "description": "This module manages bidirectional conversions between literals and formulas using customizable hooks. It provides functions to register and retrieve conversion hooks, as well as to perform the actual conversions between `Logtk.Literal.t` and `Logtk.SLiteral.t` types. It is used to integrate literal-level transformations into theorem proving processes, particularly when translating between different literal representations during proof search.",
      "description_length": 446,
      "index": 705,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Bce_pe_fixpoint.S-Env-C-Pos",
      "library": "libzipperposition.calculi",
      "description": "This module provides a function `at` that retrieves a term from a given position in a clause within a specific environment. It operates on environments (`Env.C.t`), clauses, and positions (`Logtk.Position.t`), focusing on precise term access during proof search. Use cases include analyzing or modifying clause structure during automated reasoning tasks.",
      "description_length": 354,
      "index": 706,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Heuristics.S-C-Pos",
      "library": "libzipperposition.calculi",
      "description": "This module provides a function `at` that retrieves a subterm at a specified position within a term. It operates on terms and positions, enabling precise navigation and manipulation of term structures. A concrete use case is extracting specific subterms during proof search or term rewriting processes.",
      "description_length": 302,
      "index": 707,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Fool.S-Env-C-Seq",
      "library": "libzipperposition.calculi",
      "description": "This module provides functions to extract literals, terms, and typed variables from a given clause environment. It operates on clause structures and interfaces with term and literal representations from the Logtk library. Useful for analyzing or transforming logical clauses during theorem proving or formula manipulation tasks.",
      "description_length": 328,
      "index": 708,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Heuristics.S-Env-C-Eligible",
      "library": "libzipperposition.calculi",
      "description": "This module defines eligibility criteria for selecting literals in a clause based on logical operations and specific properties such as positivity, negativity, maximality, and equation status. It works with clauses and literals, using functions that map integers and literals to boolean values to determine eligibility. Concrete use cases include filtering literals eligible for resolution or paramodulation, selecting maximal or positive equations, and combining eligibility conditions using logical operators.",
      "description_length": 511,
      "index": 709,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Heuristics.S-PS-PassiveSet",
      "library": "libzipperposition.calculi",
      "description": "This module manages a passive clause set with dynamic addition and removal, providing signals for tracking changes. It supports operations to query the current clause set, check clause status, and retrieve the next clause to process. It is used to manage passive clauses in a theorem proving context, where clauses are selectively processed based on their state and priority.",
      "description_length": 375,
      "index": 710,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Rewriting.Make",
      "library": "libzipperposition.calculi",
      "description": "Implements rewriting and narrowing operations for equational logic, using a given equational theory module E. It supports configurable setup for narrowing strategies and enables rewriting-based reasoning in automated theorem proving. Useful for implementing custom rewriting systems over algebraic structures with specific equality handling.",
      "description_length": 341,
      "index": 711,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Pred_elim.S-Env-Ctx-Lit",
      "library": "libzipperposition.calculi",
      "description": "This module manages bidirectional conversions between atomic formulas and literals using customizable hooks. It provides functions to register and retrieve conversion hooks, as well as to perform the actual conversions. It works directly with `Logtk.Literal.t` and `Logtk.Term.t Logtk.SLiteral.t` types, specifically handling atomic formulas during the transformation.",
      "description_length": 368,
      "index": 712,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Higher_order.S-Env-Stm-Ctx-Lit",
      "library": "libzipperposition.calculi",
      "description": "This module manages bidirectional conversions between literals and formulas using a set of hooks. It provides functions to register and retrieve conversion hooks, and to convert between literal and formula representations. It works with `Logtk.Literal.t` and `Logtk.SLiteral.t` types, specifically handling atomic formulas during conversion. Use cases include integrating custom literal representations with theorem proving systems or transforming logical expressions for internal processing.",
      "description_length": 492,
      "index": 713,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Heuristics.S-Env-ProofState-CQueue-C",
      "library": "libzipperposition.calculi",
      "description": "This module provides functionalities for clause introspection and metadata manipulation, including redundancy marking, selection status tracking, and heuristic penalty adjustments, operating on clauses and their associated proof states. It enables automated reasoning workflows through trail-based reasoning, resolution and paramodulation eligibility checks, and clause transformations like substitution application and grounding, while also supporting proof manipulation and standardized output formatting for debugging or interoperability. Key use cases include theorem proving, proof optimization, and integration with external tools via TSTP/CF representations.",
      "description_length": 665,
      "index": 714,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Booleans.S-Env-ProofState-CQueue",
      "library": "libzipperposition.calculi",
      "description": "This module supports managing priority queues of clauses with operations for addition, retrieval, and iteration using configurable strategies like FIFO, goal-oriented, or heuristic-based selection. It works with the `Env.ProofState.CQueue.t` data structure, allowing dynamic configuration via weight and priority functions, and provides utilities for membership checks, removal, and string representations. This facilitates efficient passive clause handling in theorem proving contexts, particularly for automated reasoning tasks requiring adaptive clause prioritization.",
      "description_length": 571,
      "index": 715,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Superposition_intf.S-Env-C-Seq",
      "library": "libzipperposition.calculi",
      "description": "This module provides functions to extract literals, terms, and typed variables from a clause environment. It operates on clause structures defined in the `Env.C` module, enabling inspection of logical components such as atoms, terms, and variable bindings. Concrete use cases include clause analysis, term traversal, and variable management during automated reasoning tasks like resolution or superposition-based theorem proving.",
      "description_length": 429,
      "index": 716,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.EnumTypes.S-Env-ProofState-TermIndex",
      "library": "libzipperposition.calculi",
      "description": "This module provides term indexing operations for managing collections of terms paired with annotated elements (`C.WithPos.t`), supporting insertion, deletion, substitution-based queries for unifiable terms, generalizations, and specializations. It operates on term indices within proof states, enabling efficient retrieval and transformation of terms during unification tasks. The `to_dot` function visualizes index structures, aiding in debugging and analysis of term relationships during theorem proving workflows.",
      "description_length": 517,
      "index": 717,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Hlt_elim.S-Env-ProofState-CQueue-WeightFun",
      "library": "libzipperposition.calculi",
      "description": "This module defines weight functions that assign integer weights to clauses in a proof state's priority queue. It supports operations like parsing weight function descriptions, combining multiple weight functions with coefficients, and applying heuristics such as favoring ground or Horn clauses, adjusting based on goal proximity, or penalizing based on clause properties. These functions are used to guide the selection of clauses during automated theorem proving by influencing the priority queue's ordering.",
      "description_length": 511,
      "index": 718,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Heuristics.S-PS",
      "library": "libzipperposition.calculi",
      "description": "Manages clause prioritization and indexing for efficient retrieval during proof search. It uses term and subsumption indexes to organize clauses, and provides prioritized queues for managing active, simplified, and passive clause sets. This module is used to implement efficient saturation-based reasoning strategies in automated theorem proving.",
      "description_length": 346,
      "index": 719,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Bce.S-Env-ProofState-SimplSet",
      "library": "libzipperposition.calculi",
      "description": "This module manages a dynamic set of clauses with operations to add or remove clauses and notify subscribers when changes occur. It provides signals for tracking additions and removals, and uses iterators to process multiple clauses in bulk. It is useful for maintaining and updating clause sets in automated reasoning systems where incremental changes and event-driven responses are required.",
      "description_length": 393,
      "index": 720,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.EnumTypes.S-Env-ProofState-UnitIndex",
      "library": "libzipperposition.calculi",
      "description": "This module implements an indexing structure for managing and querying logical (in)equations within a proof state. It supports operations to add, remove, and retrieve indexed terms with substitutions, enabling efficient lookups for clause matching and generalization during automated reasoning. The module is used to accelerate term rewriting and inference rule applications in theorem proving by organizing equations into a structured index.",
      "description_length": 442,
      "index": 721,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Qle.S-Env-Stm-Ctx",
      "library": "libzipperposition.calculi",
      "description": "This module supports operations for managing logical contexts in theorem proving, including term ordering configuration, skolemization handling, and injectivity analysis for function arguments. It works with term signatures for symbol declarations, logical literals for expressions, and contexts tracking symbol updates and selection functions. These tools are used in proof search to maintain term consistency, reason about function properties, and manage dynamic context changes during logical deduction.",
      "description_length": 506,
      "index": 722,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Superposition_intf.S-Env-ProofState-SubsumptionIndex-C",
      "library": "libzipperposition.calculi",
      "description": "This module defines operations for comparing clauses, extracting literals, and retrieving label subsets. It works with clause data structures from a proof state subsumption index. Concrete use cases include managing clause ordering, literal iteration for indexing, and label-based subsumption checks during theorem proving.",
      "description_length": 323,
      "index": 723,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Booleans.S-Env-C-Pos",
      "library": "libzipperposition.calculi",
      "description": "This module provides a function `at` that retrieves a term from a given position in a clause within a specific environment. It operates on environments (`Env.C.t`), clauses, and positions (`Logtk.Position.t`), working with terms (`Logtk.Term.t`) as both input and output. A concrete use case is extracting subterms during proof search or term indexing in automated theorem proving.",
      "description_length": 381,
      "index": 724,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Libzipperposition_calculi.Pred_elim.S-Env-ProofState-UnitIndex-E",
      "library": "libzipperposition.calculi",
      "description": "This module represents and compares indexed equations or inequations, pairing terms with a boolean flag indicating equality or inequality and a clause. It provides operations to extract components of an equation and determine its priority for use in theorem proving or term rewriting systems. The module is used to manage and prioritize equations during proof search or simplification processes.",
      "description_length": 395,
      "index": 725,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Higher_order.S-Env-ProofState-CQueue-WeightFun",
      "library": "libzipperposition.calculi",
      "description": "This module defines weight functions that assign integer weights to clauses in a proof state's clause queue. It supports operations to parse weight functions from strings, combine multiple weight functions with coefficients, and apply domain-specific heuristics such as favoring ground clauses, Horn clauses, or clauses close to the goal. Concrete use cases include guiding clause selection during automated theorem proving by prioritizing clauses based on customizable heuristic criteria.",
      "description_length": 489,
      "index": 726,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Heuristics.S-PS-SimplSet",
      "library": "libzipperposition.calculi",
      "description": "This module manages a dynamic set of clauses with signals for tracking additions and removals. It provides functions to add or remove multiple clauses using iterators, enabling reactive updates in theorem proving contexts. Use cases include maintaining clause sets during saturation-based reasoning where real-time monitoring of set changes is required.",
      "description_length": 353,
      "index": 727,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Pred_elim.S-Env-StmQ-WeightFun",
      "library": "libzipperposition.calculi",
      "description": "This module defines weight functions for assigning integer weights to streams of statements. It supports combining multiple weight functions using weighted sums with positive coefficients. A concrete use case is prioritizing or penalizing certain statement sequences during automated reasoning or proof search.",
      "description_length": 310,
      "index": 728,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.EnumTypes.S-Env-ProofState-CQueue-C",
      "library": "libzipperposition.calculi",
      "description": "This module provides operations for managing clause metadata such as flags, redundancy, and simplification states, alongside structural analysis of clauses for equality, weight, and goal status. It works with clauses represented as `Env.ProofState.CQueue.C.t`, utilizing substitutions, bitvectors, and scoped literals to support reasoning tasks like resolution eligibility checks and paramodulation analysis. Key use cases include proof state inspection, trail-based clause modification, and transforming clauses through grounding or formatting for debugging and output in automated theorem proving pipelines.",
      "description_length": 609,
      "index": 729,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Bce.S-Env-C-ClauseSet",
      "library": "libzipperposition.calculi",
      "description": "This module provides a suite of operations for managing ordered, immutable sets of logical clauses, supporting membership testing, union/intersection, filtering, and ordered traversal. It works with `Env.C.ClauseSet.t` structures built using a comparator to ensure sorted iteration, offering transformations like mapping, partitioning, and safe element queries via optional-returning lookups. Designed for theorem proving contexts, it facilitates clause manipulation, serialization to strings or lists, and predicate-driven searches while preserving functional purity and efficient equality checks.",
      "description_length": 598,
      "index": 730,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.EnumTypes.S-C-Eligible",
      "library": "libzipperposition.calculi",
      "description": "This module defines eligibility criteria for selecting literals in theorem proving operations, using a function type that determines whether a literal at a given position in a clause is eligible. It provides operations to filter literals based on resolution, paramodulation, positivity, negativity, maximality, and equation status, as well as logical combinations of these conditions. Use cases include guiding inference rules in automated reasoning by restricting which literals can participate in resolution or paramodulation steps.",
      "description_length": 534,
      "index": 731,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Pred_elim.S-Env-ProofState-SubsumptionIndex-C",
      "library": "libzipperposition.calculi",
      "description": "This module defines operations for comparing clauses, extracting literals, and retrieving label subsets from clauses in a subsumption index. It works with clause data types and label sets to support subsumption checks and indexing strategies. Concrete use cases include optimizing clause retrieval during automated theorem proving by leveraging label inclusion and literal structure.",
      "description_length": 383,
      "index": 732,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Hlt_elim.S-Env-ProofState",
      "library": "libzipperposition.calculi",
      "description": "Manages clause queues and indexes for efficient retrieval during theorem proving. Uses term and unit indexes to support subsumption checks and clause management. Tracks proof state statistics and provides detailed debugging output.",
      "description_length": 231,
      "index": 733,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Lazy_cnf.S-Env-ProofState-SimplSet",
      "library": "libzipperposition.calculi",
      "description": "This module manages a set of clauses with dynamic addition and removal, providing signals to track changes. It works with clauses represented as `C.t` values, organized in an iterative structure (`Iter.t`). Use this module to maintain a mutable collection of clauses while reacting to modifications in real time, such as for proof state tracking or clause-based reasoning in automated theorem proving.",
      "description_length": 401,
      "index": 734,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Fool.S-Env-ProofState-UnitIndex-E",
      "library": "libzipperposition.calculi",
      "description": "This module represents and compares indexed equations or inequations, pairing terms with a boolean flag indicating equality or inequality and a clause. It provides operations to extract components of these equations, compare them, and determine their priority for use in proof search or term indexing strategies.",
      "description_length": 312,
      "index": 735,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Pred_elim.S-Env-C-Eligible",
      "library": "libzipperposition.calculi",
      "description": "This module defines eligibility criteria for selecting literals within clauses, primarily used in automated theorem proving. It provides operations to filter literals based on properties like positivity, negativity, maximality, and equation status, as well as logical combinations of these conditions. These criteria directly guide inference rules such as resolution and paramodulation by determining which literals can participate in them.",
      "description_length": 440,
      "index": 736,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Lazy_cnf.S-Env-ProofState-CQueue-PriorityFun",
      "library": "libzipperposition.calculi",
      "description": "This module defines a priority function type for weighting clauses in a proof state queue. It includes a function to parse string descriptions into concrete priority functions. It is used to control clause selection strategies in automated theorem proving.",
      "description_length": 256,
      "index": 737,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Pred_elim.S-Env-ProofState-PassiveSet",
      "library": "libzipperposition.calculi",
      "description": "This module manages a set of passive clauses with operations to add, remove, and retrieve clauses, as well as track their passive status. It provides signals for clause addition and removal, a clause iterator, and access to the current clause queue state. It is used in theorem proving to manage passive clause processing within a proof state.",
      "description_length": 343,
      "index": 738,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Bce.S-Env-Stm",
      "library": "libzipperposition.calculi",
      "description": "This module manages streams of clauses with associated metadata, supporting operations to create, compare, and manipulate streams based on their content and provenance. It works with streams of clauses (`C.t option OSeq.t`), tracking parent clauses, penalties, and access counts. Concrete use cases include managing inference results in theorem proving, where streams represent sequences of derived clauses and operations like `drip` and `drip_n` control clause retrieval for further processing.",
      "description_length": 495,
      "index": 739,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Pred_elim.S-Env-StmQ",
      "library": "libzipperposition.calculi",
      "description": "This module implements a priority queue for managing streams of clauses with weighted priorities. It supports operations to add streams or lists of streams, retrieve clauses fairly or under a guard, and inspect queue state. Use cases include scheduling clause processing in automated theorem proving where streams represent different sources of clauses and priority weights guide exploration.",
      "description_length": 392,
      "index": 740,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Bce_pe_fixpoint.S-Env-ProofState-module-type-CLAUSE_SET",
      "library": "libzipperposition.calculi",
      "description": "This module manages a set of clauses with operations to add or remove clauses and trigger signals on these changes. It works with clause sets and uses iterators over clauses for bulk modifications. It is used to maintain and update a collection of logical clauses during theorem proving processes.",
      "description_length": 297,
      "index": 741,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Superposition_intf.S-Env-ProofState-UnitIndex-E",
      "library": "libzipperposition.calculi",
      "description": "This module represents and compares indexed equations and inequations, providing a total order via `compare`, extraction of term components with `extract`, and a utility `priority` function. It operates on equations composed of terms, booleans, and clauses, enabling discrimination between equality and inequality forms. Useful in theorem proving for managing and prioritizing equational constraints during proof search.",
      "description_length": 420,
      "index": 742,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Higher_order.S-Env-FormRename-Ctx",
      "library": "libzipperposition.calculi",
      "description": "This module manages logical contexts for higher-order automated reasoning, offering operations to manipulate term orderings, selection functions, skolemization states, and symbol declarations. It works with terms, types, symbols, and signatures to support tasks like term comparison, renaming, and injectivity checks for function symbols, particularly in theorem proving scenarios involving logical literals and constraint transformations. Key use cases include maintaining context-sensitive symbol typing, optimizing term representations, and enabling precise literal manipulation during proof search.",
      "description_length": 602,
      "index": 743,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.EnumTypes.S-C-ClauseSet",
      "library": "libzipperposition.calculi",
      "description": "This module implements a persistent set structure for clauses (`C.ClauseSet.t`) with fixed element ordering, supporting standard set operations like union, intersection, difference, and membership testing, alongside ordered traversal and transformations via mapping, folding, and filtering. It includes utilities for retrieving extremal elements (min/max), conditional selection, and conversions to lists or sequences, ensuring structural equality and set invariants. Designed for applications requiring precise clause manipulation\u2014such as automated reasoning or formal verification\u2014it emphasizes efficient ordered traversal, predicate-based filtering, and safe element retrieval with optional results.",
      "description_length": 702,
      "index": 744,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Heuristics.S-Env-ProofState-ActiveSet",
      "library": "libzipperposition.calculi",
      "description": "This module manages a dynamic set of clauses with signals for additions and removals. It supports adding or removing clauses via iterators, retrieving the current clause set, and querying the number of clauses. It is used to track and manipulate active clauses during theorem proving processes.",
      "description_length": 294,
      "index": 745,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Pred_elim.S-Env-C-WithPos",
      "library": "libzipperposition.calculi",
      "description": "This module represents clauses with a specific subterm and its position, enabling precise manipulation and analysis of terms within clauses. It provides comparison and pretty-printing operations for these structured clauses. Useful for tasks like subterm indexing, rewriting, or focused proof search where term positions matter.",
      "description_length": 328,
      "index": 746,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Bce.S-Env-ProofState-module-type-CLAUSE_SET",
      "library": "libzipperposition.calculi",
      "description": "This module manages a dynamic set of clauses, providing operations to add or remove clauses and to subscribe to events when clauses are added or removed. It works with clause sets using the `C.t` type and supports iteration over clauses via `Iter.t`. Concrete use cases include tracking clause modifications during theorem proving and enabling reactive updates in proof state monitoring systems.",
      "description_length": 395,
      "index": 747,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Hlt_elim.S-Env-FormRename-Ctx",
      "library": "libzipperposition.calculi",
      "description": "This module supports logical context management through skolemization, term ordering, and selection functions, while manipulating terms, types, symbols, and literals from the Logtk library. It enables formal logic systems to perform unification, injectivity checks for argument positions, and inference rule application by maintaining context state and signature integrity. Key use cases include theorem proving and ensuring completeness in logical reasoning via structured term analysis and context transformations.",
      "description_length": 516,
      "index": 748,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Lazy_cnf.S-Env-C-Seq",
      "library": "libzipperposition.calculi",
      "description": "This module provides functions to extract literals, terms, and typed variables from a clause in an environment. It operates on clause data structures and uses iterators to traverse their components. Useful for analyzing or transforming logical clauses during theorem proving or formula processing.",
      "description_length": 297,
      "index": 749,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Fool.S-Env-Stm",
      "library": "libzipperposition.calculi",
      "description": "This module manages streams of clauses with associated metadata, supporting operations to create, compare, and manipulate streams based on their content and provenance. It works with streams of clauses (`C.t option OSeq.t`), tracking parent clauses, penalties, and access counts. Concrete use cases include managing inference results in theorem proving, prioritizing clause exploration based on heuristic penalties, and retrieving clause sequences incrementally during proof search.",
      "description_length": 482,
      "index": 750,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.EnumTypes.S-Env",
      "library": "libzipperposition.calculi",
      "description": "This module supports clause-based automated reasoning with operations for inference, simplification, redundancy checking, and trail analysis. It works on clauses, clause sets, literals, terms, and proof states, facilitating saturation-based proving, term rewriting, tautology detection, and subsumption. Specific use cases include dynamic configuration via flex state management and signal handling for clause events during finite inference processing.",
      "description_length": 452,
      "index": 751,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Heuristics.S-Env-ProofState-PassiveSet",
      "library": "libzipperposition.calculi",
      "description": "This module manages a passive clause set with dynamic addition and removal, providing signals for tracking changes. It supports operations to query the current clause set, check clause status, and retrieve the next clause for processing. It is used to control clause selection and processing order during theorem proving.",
      "description_length": 321,
      "index": 752,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Hlt_elim.S-Env-ProofState-SubsumptionIndex",
      "library": "libzipperposition.calculi",
      "description": "This module implements a subsumption index for managing and querying clauses in a proof state. It supports operations to add, remove, and retrieve clauses based on subsumption and alpha-equivalence relationships, using literals and labels as keys. Use cases include efficient clause indexing and retrieval during automated theorem proving processes.",
      "description_length": 349,
      "index": 753,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Booleans.S-Env-Stm-Ctx-Lit",
      "library": "libzipperposition.calculi",
      "description": "This module provides functions to convert between literals and formulas, specifically handling atomic formulas. It maintains lists of conversion hooks for customizing transformations, with operations to add or retrieve these hooks. Use cases include integrating literal-level transformations into theorem proving processes where atomic formulas must be translated to and from terms.",
      "description_length": 382,
      "index": 754,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Lazy_cnf.S-Env-C-Pos",
      "library": "libzipperposition.calculi",
      "description": "This module provides a function `at` that retrieves a term from a clause at a specified position in a given environment. It operates on environments and terms, specifically using `Logtk.Position.t` to navigate clause structures. It is used to access specific subterms within clauses during proof search or term manipulation tasks.",
      "description_length": 330,
      "index": 755,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Heuristics.S-C-Eligible",
      "library": "libzipperposition.calculi",
      "description": "This module defines eligibility criteria for selecting literals in automated theorem proving. It provides functions to filter literals based on properties such as positivity, negativity, equation status, and maximality within a clause. These criteria can be combined using logical operations to control which literals are eligible for resolution or paramodulation steps during proof search.",
      "description_length": 390,
      "index": 756,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Bce_pe_fixpoint.S-Env-StmQ",
      "library": "libzipperposition.calculi",
      "description": "This module implements a priority queue for managing streams of clauses with weighted priorities. It supports operations to add streams or lists of streams, inspect queue size, and extract clauses either individually or in batches using different fairness strategies. The queue is used to control the order of clause processing in theorem proving algorithms, where streams represent sources of clauses and weights influence selection priority.",
      "description_length": 443,
      "index": 757,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Hlt_elim.S-C-Tbl",
      "library": "libzipperposition.calculi",
      "description": "This module provides imperative hash table operations for efficient key-value storage and manipulation, supporting insertion, deletion, iteration, and in-place transformations over keys of type `C.t`. It works with `C.Tbl.t` hashtables, enabling bulk updates, safe access, and conversions to lists or sequences, while offering customization through combination functions for handling duplicates. Use cases include memoization, element counting, structured serialization, and scenarios requiring fine-grained control over hash table behavior with introspection capabilities.",
      "description_length": 573,
      "index": 758,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Bce.S-Env-ProofState",
      "library": "libzipperposition.calculi",
      "description": "Manages clause queues and indexes for efficient retrieval during automated reasoning. Provides operations for inserting, selecting, and prioritizing clauses using term-based, unit, and subsumption indexes. Used to control proof search by maintaining active, simplified, and passive clause sets with precise statistics and debugging output.",
      "description_length": 339,
      "index": 759,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Fool.S-C-Eligible",
      "library": "libzipperposition.calculi",
      "description": "This module defines eligibility criteria for selecting literals in first-order logic clauses, using a function type that determines whether a literal at a given position is eligible. It provides operations to construct and combine eligibility predicates, such as selecting maximal, positive, negative, or equational literals, and supports logical operations (and, or, not) to compose complex conditions. These criteria are used to guide inference rules like resolution and paramodulation in automated theorem proving.",
      "description_length": 517,
      "index": 760,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.EnumTypes.S-Env-ProofState-TermIndex-Leaf",
      "library": "libzipperposition.calculi",
      "description": "This module implements a term index structure for efficient retrieval of elements based on term unification and matching. It supports operations such as adding or removing elements associated with terms, iterating and folding over indexed entries, and performing scoped unification or matching queries with substitution tracking. It is used in proof search procedures to quickly find relevant clauses or terms that match or unify with a given term.",
      "description_length": 448,
      "index": 761,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Superposition_intf.S-Env-ProofState-TermIndex",
      "library": "libzipperposition.calculi",
      "description": "This module offers term indexing capabilities tailored for superposition theorem proving, enabling efficient management of terms with associated elements through addition, removal, retrieval, and advanced queries like unification, generalization, and specialization. It operates on term indices within a proof state, accommodating higher-order unification and scoped term manipulations. A dedicated visualization function generates DOT representations of the index structure for analysis and debugging purposes.",
      "description_length": 511,
      "index": 762,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Pred_elim.S-Env-C-Seq",
      "library": "libzipperposition.calculi",
      "description": "This module provides functions to extract literals, terms, and variables from a clause environment. It operates on clause structures using the `Env.C.t` type, which represents clauses in a first-order logic context. Concrete use cases include analyzing or transforming logical clauses during automated theorem proving or formula simplification.",
      "description_length": 344,
      "index": 763,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Bce_pe_fixpoint.S-Env-ProofState",
      "library": "libzipperposition.calculi",
      "description": "Manages clause queues and indexes for efficient retrieval during automated reasoning. Provides priority-based clause processing with `CQueue`, term and unit indexing for fast lookups, and subsumption checks. Used to implement saturation-based theorem proving with precise control over clause selection and redundancy.",
      "description_length": 317,
      "index": 764,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Qle.S-Env-FormRename-Ctx",
      "library": "libzipperposition.calculi",
      "description": "This module provides operations for managing logical contexts, including term ordering, symbol declaration, and skolemization state, while supporting term comparison and renaming. It works with term signatures, logical literals (represented via the Lit submodule), and first-order logic formulas, enabling injectivity checks for unification and inference rule application. These tools are used in theorem proving tasks like SMT solving or automated reasoning where symbol updates and context-sensitive term manipulation are critical.",
      "description_length": 533,
      "index": 765,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Heuristics.S-Env-ProofState-SubsumptionIndex-C",
      "library": "libzipperposition.calculi",
      "description": "This module defines operations for comparing clauses, extracting literals, and retrieving label subsets from clauses. It works with clause types and label sets to support subsumption checks. Concrete use cases include clause indexing and subsumption-based redundancy elimination in automated theorem proving.",
      "description_length": 308,
      "index": 766,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Superposition_intf.S-PS-SubsumptionIndex",
      "library": "libzipperposition.calculi",
      "description": "This module implements a subsumption index for clauses, supporting operations to add or remove clauses and retrieve subsuming, subsumed, or alpha-equivalent clauses. It works with clauses represented as literals and labels, using efficient indexing to accelerate logical inferences during automated reasoning. Use cases include optimizing resolution-based theorem proving by quickly identifying relevant clauses for subsumption checks.",
      "description_length": 435,
      "index": 767,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Superposition_intf.S-Env-ProofState-ActiveSet",
      "library": "libzipperposition.calculi",
      "description": "This module manages a dynamic set of clauses with signals for additions and removals. It provides operations to add or remove multiple clauses, retrieve the current set, and count clauses. Useful for tracking clause changes in a proof state during automated reasoning tasks.",
      "description_length": 274,
      "index": 768,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Fool.S-Env-ProofState-PassiveSet",
      "library": "libzipperposition.calculi",
      "description": "This module manages a passive clause set with dynamic addition and removal, supporting incremental updates through signals. It provides direct access to the current clause set, queue state, and passive clause checking, enabling precise control over clause processing in automated theorem proving. Concrete use cases include tracking and retrieving passive clauses during proof search and integrating with clause selection strategies.",
      "description_length": 433,
      "index": 769,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Booleans.S-C-ClauseSet",
      "library": "libzipperposition.calculi",
      "description": "This module offers operations for managing ordered, unique collections of clauses, supporting standard set manipulations (union, intersection, difference) alongside ordered traversal, filtering, and safe element queries (e.g., `find_first_map`, `find_last_opt`). It works with clause sets (`C.ClauseSet.t`), ensuring ordered iteration and providing conversions to and from lists, sequences, and strings for integration with other data-processing workflows. Designed for automated reasoning contexts, it facilitates tasks like clause management in theorem proving, predicate-driven filtering, and structured debugging output through its formatting utilities.",
      "description_length": 657,
      "index": 770,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Bce.S-Env-C-WithPos",
      "library": "libzipperposition.calculi",
      "description": "This module represents clauses with a specific subterm and its position, enabling precise term manipulation and analysis. It provides comparison and pretty-printing operations for these structured clauses. Useful for tasks like subterm indexing, rewriting, or focused proof search where positional context is critical.",
      "description_length": 318,
      "index": 771,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Superposition_intf.S-Env-Stm-Ctx-Lit",
      "library": "libzipperposition.calculi",
      "description": "This module manages bidirectional conversions between literals and formulas using customizable hooks. It provides functions to register and retrieve conversion hooks, as well as to perform the actual conversions between `Logtk.Literal.t` and `Logtk.Term.t Logtk.SLiteral.t`. It is used to integrate literal-level transformations within theorem proving processes, particularly when translating between different internal representations of logical terms.",
      "description_length": 453,
      "index": 772,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Superposition_intf.S-PS-SubsumptionIndex-C",
      "library": "libzipperposition.calculi",
      "description": "This module defines operations for comparing clauses, extracting literals, and retrieving label subsets. It works with clause data structures and associated labels used in subsumption checks. Concrete use cases include managing clause indexing and subsumption logic in automated theorem proving.",
      "description_length": 295,
      "index": 773,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.EnumTypes.S-Env-Stm-Ctx-Lit",
      "library": "libzipperposition.calculi",
      "description": "This module manages bidirectional conversions between literals and their atomic formula representations using customizable hooks. It provides functions to register and retrieve conversion hooks for transforming literals to and from atomic formulas, along with direct conversion operations that enforce atomicity constraints. It works with `Logtk.Literal.t` and `Logtk.SLiteral.t` types, serving use cases such as integrating custom literal encodings or supporting different logical backends.",
      "description_length": 491,
      "index": 774,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Libzipperposition_calculi.Hlt_elim.S-Env-ProofState-SubsumptionIndex-C",
      "library": "libzipperposition.calculi",
      "description": "This module defines operations for comparing clauses, extracting literals, and retrieving label subsets. It works with clause data types from a proof state subsumption index. Concrete use cases include clause subsumption checks and literal-level analysis during automated theorem proving.",
      "description_length": 288,
      "index": 775,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Hlt_elim.S-Env-FormRename-Ctx-Lit",
      "library": "libzipperposition.calculi",
      "description": "This module implements literal conversion hooks and transformations for formulas in a term-based logic representation. It provides functions to register and retrieve hooks for converting between literal forms, along with direct conversion operations that map between atomic formulas and literals. It is used to support proof transformation and normalization tasks in automated reasoning pipelines.",
      "description_length": 397,
      "index": 776,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Heuristics.S-Env",
      "library": "libzipperposition.calculi",
      "description": "This module provides operations for inference rule application, clause simplification, and redundancy detection in automated theorem proving. It works with logical clauses, clause sets, terms, and proof states to manage deduction processes like binary/unary inference, term rewriting, and tautology elimination. Designed for saturation provers, it supports use cases such as priority-controlled clause processing, proof state transformation, and event-driven reasoning through mechanisms like empty clause detection and flex state management.",
      "description_length": 542,
      "index": 777,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.EnumTypes.S-Env-ProofState-module-type-CLAUSE_SET",
      "library": "libzipperposition.calculi",
      "description": "This module manages a set of clauses with operations to add or remove clauses and to subscribe to events when clauses are added or removed. It works with clause sets and uses iterators for batch operations. It is useful for tracking changes to clause sets during theorem proving processes.",
      "description_length": 289,
      "index": 778,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Superposition_intf.S-PS-C",
      "library": "libzipperposition.calculi",
      "description": "This module enables clause-centric automated reasoning through operations for metadata inspection, redundancy control, structural transformation, and logical analysis of clauses in superposition calculus. It manipulates clauses augmented with literals, substitutions, trails, and proof data to support tasks like paramodulation eligibility checks, simplification, and redundancy elimination. Key applications include proof generation, clause normalization, and TSTP",
      "description_length": 465,
      "index": 779,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.EnumTypes.S-Env-Stm",
      "library": "libzipperposition.calculi",
      "description": "This module manages streams of clauses with associated metadata, supporting operations to create, compare, and manipulate streams based on their content and provenance. It provides functions to access stream properties like ID and penalty, and to extract elements incrementally with `drip` or in batches with `drip_n`. Concrete use cases include managing inference results in automated theorem proving, where streams represent sequences of derived clauses with tracking for heuristic scoring and retrieval attempts.",
      "description_length": 515,
      "index": 780,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.EnumTypes.S-Env-Ctx-Lit",
      "library": "libzipperposition.calculi",
      "description": "This module manages bidirectional conversions between literals and formulas using customizable hooks. It provides functions to register and retrieve conversion hooks for transforming between `Logtk.Literal.t` and `Logtk.Term.t Logtk.SLiteral.t` types. Concrete use cases include integrating custom literal representations with theorem proving procedures that require atomic formulas.",
      "description_length": 383,
      "index": 781,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Superposition.Make",
      "library": "libzipperposition.calculi",
      "description": "This module orchestrates automated theorem proving by integrating inference rules for superposition and equality handling with syntactic and semantic checks, operating on clauses and terms through efficient term and subsumption indexes. It supports core data types like clauses (`C.t`), trails, proofs, and term orderings, enabling operations such as simplification, redundancy elimination, literal selection, and subsumption checking, all guided by configurable priorities and indexing strategies. Users can perform concrete tasks like selecting resolution candidates, filtering redundant clauses, exporting proof states in DOT format, or applying substitutions and transformations to evolve the proof state dynamically. Submodules enhance these capabilities with structured term manipulation, ordered clause set operations, and trail-based modifications, ensuring fine-grained control over inference workflows and data aggregation.",
      "description_length": 933,
      "index": 782,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Higher_order.S-Env-Stm-Ctx",
      "library": "libzipperposition.calculi",
      "description": "This module supports operations for managing logical contexts in higher-order theorem proving, including term ordering, symbol declaration/lookup, skolemization, and injectivity control for function arguments. It works with term identifiers, function symbols, logical literals, and signature data structures to enable precise term comparison and context-sensitive reasoning. These capabilities are particularly useful in unification, formula simplification, and proof search scenarios requiring injective function analysis or dynamic signature updates.",
      "description_length": 552,
      "index": 783,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Lazy_cnf.S-Env-Stm-Ctx",
      "library": "libzipperposition.calculi",
      "description": "This module provides operations for logical context management, including skolemization, term ordering, and injectivity checks for function symbols, alongside CNF-specific transformations. It works with terms, types, signatures, and logical literals, leveraging these structures to enable theorem proving tasks like formula normalization and simplification. Key use cases include guiding logical reductions through injectivity properties and managing term comparisons during proof search.",
      "description_length": 488,
      "index": 784,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Heuristics.S-PS-CQueue",
      "library": "libzipperposition.calculi",
      "description": "This module supports operations for managing priority queues of clauses in a theorem prover, including adding clauses, retrieving them by priority, and applying strategies like FIFO, goal-oriented selection, or favoring ground clauses. It operates on priority queues (`PS.CQueue.t`) and individual clauses (`PS.CQueue.C.t`), leveraging weighting and priority functions to govern clause ordering. These capabilities enable efficient clause processing workflows, such as dynamically adjusting priorities based on heuristics or selectively removing clauses during saturation-based proof search.",
      "description_length": 591,
      "index": 785,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Heuristics.S-Env-StmQ",
      "library": "libzipperposition.calculi",
      "description": "This module implements a priority queue for managing streams of clauses in a theorem proving context. It provides operations to add streams or lists of streams to the queue, take clauses based on priority and fairness strategies, and inspect queue state such as length and emptiness. The queue is constructed with a weight function to determine stream priority, and supports concrete use cases like fair clause selection for resolution or prioritized stream processing in automated reasoning.",
      "description_length": 492,
      "index": 786,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Heuristics.S-Env-ProofState-TermIndex",
      "library": "libzipperposition.calculi",
      "description": "This module implements a term indexing system that supports efficient insertion, deletion, and query operations for terms paired with arbitrary elements (`elt`), using scoped terms and substitutions to handle higher-order unification. It operates on hierarchical term indices within a proof state, enabling advanced operations like unification, generalization, and specialization through both incremental modifications and bulk processing of sequences or lists. The structure is particularly suited for managing complex term relationships during proof search, with a `to_dot` utility providing visualization capabilities for debugging or analysis of the index's internal structure.",
      "description_length": 681,
      "index": 787,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.EnumTypes.S-Env-ProofState-CQueue-WeightFun",
      "library": "libzipperposition.calculi",
      "description": "This module defines weight functions that compute integer weights for clauses in a proof state's priority queue. It supports operations to parse weight functions from strings, combine multiple weight functions with coefficients, and apply heuristic-based weighting strategies such as favoring ground or Horn clauses, penalizing non-goal-related clauses, and prioritizing clauses based on their relation to the initial goal. These functions are used to guide the clause selection strategy in automated theorem proving by influencing the priority queue's ordering.",
      "description_length": 562,
      "index": 788,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Booleans.S-C",
      "library": "libzipperposition.calculi",
      "description": "This module supports boolean reasoning in automated theorem proving by offering operations to track and modify clause properties such as redundancy, simplification status, and goal distance, while integrating trail-based proof management and injectivity axiom handling. It works with clauses (`C.t`), literals, substitutions, and bitvectors to enable inference control via eligibility checks for resolution and paramodulation, as well as clause transformations like symbol extraction and format conversion. Specific use cases include clause analysis, literal selection tracking, and iterative proof construction in automated reasoning systems.",
      "description_length": 643,
      "index": 789,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Fool.S-Env-ProofState",
      "library": "libzipperposition.calculi",
      "description": "Manages clause queues and indexing structures for efficient retrieval during automated reasoning. It handles term and unit indexing, subsumption checks, and maintains sets of active, simplified, and passive clauses. Used to track proof state statistics, enable detailed debugging output, and support efficient clause management in saturation-based theorem proving.",
      "description_length": 364,
      "index": 790,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Lazy_cnf.S-Env-StmQ",
      "library": "libzipperposition.calculi",
      "description": "This module implements a priority queue for managing streams of clauses with weighted priorities. It provides operations to add streams or lists of streams, inspect queue size, and extract clauses either individually or in batches, using guarded or unguarded recursion. Concrete use cases include scheduling clause processing in automated theorem proving where streams represent different sources of clauses and priority is determined by a weight function.",
      "description_length": 456,
      "index": 791,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Hlt_elim.S",
      "library": "libzipperposition.calculi",
      "description": "Implements a higher-order logic elimination calculus for superposition-based theorem proving. Operates on clauses and literals, providing functions to simplify or eliminate redundant subgoals during proof search. Used to enhance reasoning in higher-order logic by integrating with clause management systems.",
      "description_length": 307,
      "index": 792,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Superposition_intf.S-Env-ProofState-PassiveSet",
      "library": "libzipperposition.calculi",
      "description": "This module manages a passive clause set in a theorem proving context, supporting dynamic updates and retrieval of clauses. It provides operations to add or remove clauses, check clause status, and access the current clause queue state. Concrete use cases include tracking and processing passive clauses during superposition-based proof search.",
      "description_length": 344,
      "index": 793,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Superposition_intf.S-Env-ProofState-CQueue-WeightFun",
      "library": "libzipperposition.calculi",
      "description": "This module defines weight functions that assign integer weights to clauses in a proof state's clause queue. It provides specific strategies for prioritizing clauses during theorem proving, such as favoring negative ground clauses, Horn clauses, or clauses close to the goal. Functions include parsing weight function strings, combining multiple weight functions with coefficients, and applying heuristic-based penalties or preferences.",
      "description_length": 436,
      "index": 794,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "Libzipperposition_calculi.Superposition_intf.S-C-ClauseSet",
      "library": "libzipperposition.calculi",
      "description": "This module provides operations for managing ordered collections of clauses, supporting set-theoretic manipulations (union, intersection, difference), ordered traversal (min, max, iteration), and transformations (filtering, partitioning, conversion to lists/sequences). It operates on sets of type `C.ClauseSet.t`, which enforce a total order via a comparison function, ensuring efficient membership checks and structural invariants. These capabilities are particularly useful in automated reasoning systems where clause sets must be dynamically maintained and queried during proof search.",
      "description_length": 589,
      "index": 795,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Hlt_elim.S-Env-C-Eligible",
      "library": "libzipperposition.calculi",
      "description": "This module defines eligibility criteria for selecting literals within clauses based on logical operations and structural properties. It provides functions to filter literals by resolution, paramodulation, positivity, negativity, maximality, and equation status, as well as ways to combine these criteria using logical conjunction, disjunction, and negation. Use cases include guiding inference rules in automated theorem proving by restricting which literals can participate in resolution or paramodulation steps.",
      "description_length": 514,
      "index": 796,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Qle.S-Env-Ctx-Lit",
      "library": "libzipperposition.calculi",
      "description": "This module manages bidirectional conversions between literals and formulas using hooks for customization. It provides functions to register and retrieve conversion hooks, as well as to convert between literal and formula representations. It works directly with `Logtk.Literal.t` and `Logtk.SLiteral.t` types, supporting use cases like integrating custom literal encodings or decoding logic in theorem proving pipelines.",
      "description_length": 420,
      "index": 797,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Bce.S-Env-C-Pos",
      "library": "libzipperposition.calculi",
      "description": "This module provides a function `at` that retrieves a term from a given position in a clause within a specific environment. It operates on environments (`Env.C.t`), positions (`Logtk.Position.t`), and terms (`Logtk.Term.t`). A concrete use case is extracting subterms during clause processing in automated theorem proving.",
      "description_length": 322,
      "index": 798,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.EnumTypes.S-Env-ProofState-CQueue-PriorityFun",
      "library": "libzipperposition.calculi",
      "description": "This module defines a priority function type for weighting elements in a proof state queue, based on an environment and proof state context. It includes a function to parse string descriptions into concrete priority functions. It is used to control the order in which clauses are processed during automated reasoning tasks.",
      "description_length": 323,
      "index": 799,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Booleans.S-Env-StmQ-WeightFun",
      "library": "libzipperposition.calculi",
      "description": "This module defines weight functions that assign integer weights to statements in a stream. It provides operations to retrieve a penalty value for a stream and to combine multiple weight functions using weighted sums. These functions are used to prioritize or evaluate the relevance of statements in automated reasoning tasks.",
      "description_length": 326,
      "index": 800,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.EnumTypes.S-Env-C-Seq",
      "library": "libzipperposition.calculi",
      "description": "This module provides functions to extract literals, terms, and typed variables from a given clause environment. It operates on clause structures and iterates over their components. Useful for analyzing or transforming logical clauses during theorem proving or formula manipulation tasks.",
      "description_length": 287,
      "index": 801,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Qle.S-Env-StmQ-WeightFun",
      "library": "libzipperposition.calculi",
      "description": "This module defines weight functions that assign integer weights to streams of statements. It includes operations to compute the penalty of a stream and to combine multiple weight functions using weighted sums. These functions are used to prioritize or evaluate the importance of different statement streams in automated reasoning tasks.",
      "description_length": 337,
      "index": 802,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Fool.S-Env-Ctx",
      "library": "libzipperposition.calculi",
      "description": "This module supports operations for managing logical contexts in automated reasoning systems, including term ordering, symbol declaration tracking, and skolemization context manipulation, alongside injectivity checks for function arguments. It works with term signatures, logical literals (via the Lit submodule), and clause-level data structures to enable analysis and transformation of first-order logic expressions. These capabilities are used in formal verification, automated theorem proving, and logic programming environments where precise term-level reasoning and context-sensitive transformations are required.",
      "description_length": 619,
      "index": 803,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Heuristics.S-PS-CQueue-WeightFun",
      "library": "libzipperposition.calculi",
      "description": "This module defines weight functions for clauses in a priority queue, used to guide clause selection during automated reasoning. It supports operations like parsing weight function descriptions, combining multiple weight functions with coefficients, and applying heuristic-based weights such as favoring ground, Horn, or goal-related clauses. The functions operate on clause queues and influence proof search by assigning integer weights based on clause properties.",
      "description_length": 465,
      "index": 804,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Higher_order.S-C-Seq",
      "library": "libzipperposition.calculi",
      "description": "This module provides functions to extract literals, terms, and variables from a clause structure. It operates on clauses (`C.t`) and returns iterators over literals, terms, and typed variables. Useful for analyzing or transforming logical clauses during theorem proving or term rewriting tasks.",
      "description_length": 294,
      "index": 805,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.EnumTypes.S-Env-ProofState-UnitIndex-E",
      "library": "libzipperposition.calculi",
      "description": "This module defines and compares indexed equations, working with terms and clauses. It provides operations to extract components of equations and determine their priority. Concrete use cases include managing and prioritizing equations during automated theorem proving.",
      "description_length": 268,
      "index": 806,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Qle.S-Env-C-WithPos",
      "library": "libzipperposition.calculi",
      "description": "This module represents clauses with a specific subterm and its position, enabling precise term manipulation and analysis. It provides comparison and pretty-printing operations for these structured clauses. Useful for tasks like subterm indexing or focused clause transformations in automated reasoning.",
      "description_length": 302,
      "index": 807,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Libzipperposition_calculi.EnumTypes.S-Env-FormRename",
      "library": "libzipperposition.calculi",
      "description": "This module manages formula renaming and Skolemization during proof search. It provides operations to detect renaming clauses, introduce predicate Skolems, and rename formulas based on context and polarity. Key data structures include clauses and formula renaming maps, used in tasks like clausification and definition elimination.",
      "description_length": 331,
      "index": 808,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Bce_pe_fixpoint.S-Env-ProofState-CQueue-C",
      "library": "libzipperposition.calculi",
      "description": "This module provides operations for managing clause metadata and state in theorem proving, including inspecting and modifying properties like redundancy, goal status, and inference eligibility. It works with clauses (`CQueue.C.t`), trails (`Trail.t`), substitutions (`Subst.t`), and clause sets (`ClauseSet.t`), supporting tasks like proof construction, literal selection, term analysis, and transformations such as grounding and eta-reduction. Specific use cases include tracking clause activation in valuations, determining eligibility for inference rules, and generating formatted output for external tools like TSTP.",
      "description_length": 620,
      "index": 809,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Superposition_intf.S-Env-ProofState",
      "library": "libzipperposition.calculi",
      "description": "Manages clause queues and indexes for efficient retrieval during automated reasoning. Provides operations for inserting, selecting, and prioritizing clauses based on term structures. Used to implement saturation-based proof search with term ordering and redundancy elimination.",
      "description_length": 277,
      "index": 810,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Heuristics.S-Env-C-Pos",
      "library": "libzipperposition.calculi",
      "description": "This module provides a function `at` that retrieves a term from a given position within a clause in a specific environment. It operates on environments of type `Env.C.t` and positions of type `Logtk.Position.t`, returning terms of type `Logtk.Term.t`. A concrete use case is extracting subterms during proof search or term analysis in automated theorem proving.",
      "description_length": 361,
      "index": 811,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Superposition_intf.S-Env-C-Pos",
      "library": "libzipperposition.calculi",
      "description": "This module provides a function `at` that retrieves a term from a given position in an environment. It operates on environments (`Env.C.t`) and positions (`Logtk.Position.t`), returning terms (`Logtk.Term.t`). Useful for accessing specific subterms during proof search or term manipulation tasks.",
      "description_length": 296,
      "index": 812,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Qle.S-Env-ProofState-UnitIndex",
      "library": "libzipperposition.calculi",
      "description": "This module implements an indexing structure for managing and querying equations or inequations within a proof state, supporting efficient addition, removal, and retrieval of terms based on pattern matching and substitutions. It works with terms and substitutions from the `Logtk.Index_intf` module, alongside equation data from the `E` submodule, enabling fast access during theorem proving or constraint solving. Operations include adding or removing equations, iterating over indexed terms, and retrieving matches for a given query term with optional substitution, commonly used in automated reasoning or term rewriting systems.",
      "description_length": 631,
      "index": 813,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Bce.S",
      "library": "libzipperposition.calculi",
      "description": "This module implements a fixpoint computation engine for a specific calculus, providing operations to initialize, step through, and finalize a fixpoint iteration. It works with internal state managed through the `Env` submodule, which holds the necessary context for the calculus. Concrete use cases include iterative simplification or saturation processes in theorem proving or constraint solving.",
      "description_length": 398,
      "index": 814,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Fool.S-Env-ProofState-CQueue-C",
      "library": "libzipperposition.calculi",
      "description": "This module provides operations for analyzing and transforming logical clauses in a theorem proving context, focusing on properties like redundancy, simplification status, and structural characteristics (e.g., groundness, literal selection). It works with clauses represented as `Env.ProofState.CQueue.C.t`, alongside substitutions, bitvectors, and scoped literals, to support tasks such as trail-based reasoning, proof-step manipulation, and \u03b7-reduction. Specific use cases include clause normalization, metadata tracking for resolution/paramodulation eligibility, and generating TSTP-formatted output for formal verification workflows.",
      "description_length": 637,
      "index": 815,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Hlt_elim.S-Env-C-Seq",
      "library": "libzipperposition.calculi",
      "description": "This module provides functions to extract literals, terms, and variables from a clause in an environment. It operates on clause structures and uses iterators to traverse their components. Useful for analyzing or transforming logical clauses during theorem proving or constraint solving.",
      "description_length": 286,
      "index": 816,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Higher_order.S-Env-C-ClauseSet",
      "library": "libzipperposition.calculi",
      "description": "This module provides a rich set of operations for managing ordered collections of clauses, supporting standard set manipulations (union, intersection, difference), higher-order transformations (map, fold, iter), and ordered element retrieval (min, max, find). It operates on sets of clauses (`Env.C.ClauseSet.t`) with a strict ordering derived from `Ord.compare`, enabling efficient filtering, partitioning, and safe conversions to and from lists, sequences, and iterators. These capabilities are critical in theorem proving workflows for tasks like logical inference, clause elimination, and proof search, where structured traversal and dynamic set modification are required.",
      "description_length": 676,
      "index": 817,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Lazy_cnf.S-Env-ProofState-UnitIndex",
      "library": "libzipperposition.calculi",
      "description": "This module implements a term index for efficiently storing, retrieving, and manipulating sets of (in)equations during proof search. It supports operations like adding or removing equations, querying for matches under substitutions, and iterating over indexed terms. Use cases include clause indexing in automated theorem proving and efficient subsumption checks during saturation-based reasoning.",
      "description_length": 397,
      "index": 818,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Booleans.S-Env-Stm",
      "library": "libzipperposition.calculi",
      "description": "This module manages streams of clauses with dynamic penalties and hit counters, supporting operations to create, compare, and manipulate streams by id, penalty, and content retrieval. It works with streams of optional clauses (`C.t option OSeq.t`), maintaining metadata like parent clauses and heuristic penalties. Concrete use cases include prioritizing clause retrieval in theorem proving, tracking stream origins for inference, and controlling stream processing via penalties.",
      "description_length": 479,
      "index": 819,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.EnumTypes.S-Env-ProofState-PassiveSet",
      "library": "libzipperposition.calculi",
      "description": "This module manages a passive clause set with dynamic addition and removal, providing signals for tracking changes. It supports operations to query the current clause set, check clause status, and process clauses in sequence. It is used to manage passive clauses during theorem proving, enabling controlled clause selection and modification.",
      "description_length": 341,
      "index": 820,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Bce_pe_fixpoint.S-Env-Stm-Ctx",
      "library": "libzipperposition.calculi",
      "description": "This module provides operations for logical context management, including term comparison, symbol declaration, skolemization, and signature manipulation. It operates on terms, types, symbols, and logical literals, supporting tasks like ordering, selection, and completeness preservation. These functionalities are applied in formal logic systems for theorem proving, injectivity analysis of function arguments, and logical inference within propositional or first-order logic frameworks.",
      "description_length": 486,
      "index": 821,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Superposition_intf.S-PS-TermIndex-Leaf",
      "library": "libzipperposition.calculi",
      "description": "This module implements a term indexing structure that supports efficient insertion, removal, and querying of logical terms. It provides operations for unification and matching between indexed terms and query terms, returning substitutions that make the terms equivalent. It is used in automated theorem proving to find relevant clauses during inference steps.",
      "description_length": 359,
      "index": 822,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Qle.S-Env-ProofState-CQueue-WeightFun",
      "library": "libzipperposition.calculi",
      "description": "This module defines weight functions that assign integer weights to clauses in a proof state priority queue, guiding clause selection during automated reasoning. It supports operations like parsing weight function descriptions, combining weighted functions, and applying heuristics such as favoring ground or Horn clauses, penalizing non-goal-related clauses, or prioritizing clauses based on their relation to the initial goal. These functions are used to influence the search strategy in theorem proving by adjusting clause priorities dynamically.",
      "description_length": 549,
      "index": 823,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Superposition_intf.S-Env-ProofState-CQueue",
      "library": "libzipperposition.calculi",
      "description": "This module provides operations for managing a priority queue of clauses, including insertion, prioritized selection (e.g., FIFO, heuristic-based), membership checks, and removal. It operates on a priority queue structure (`Env.ProofState.CQueue.t`) containing clauses (`C.t`), with utilities for string conversion and iteration. These capabilities are used in automated reasoning systems to handle proof states where clauses must be processed according to dynamic strategies or goal-oriented criteria.",
      "description_length": 502,
      "index": 824,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Higher_order.S-Env-Ctx",
      "library": "libzipperposition.calculi",
      "description": "This module manages logical contexts for higher-order theorem proving, focusing on term orderings, selection functions, and skolemization contexts, while enabling dynamic signature manipulation through symbol declarations and type updates. It operates on terms, types, symbols, and logical literals, supporting critical operations like injectivity checks for unification and inference rules. Its components track symbol introductions and signature changes, facilitating proof contexts where literals and formulas are systematically transformed.",
      "description_length": 544,
      "index": 825,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Hlt_elim.S-Env-ProofState-UnitIndex-E",
      "library": "libzipperposition.calculi",
      "description": "This module defines operations for managing and comparing indexed equations, which consist of term pairs, a boolean flag indicating equality or inequality, and an associated clause. It provides functions to extract components of an equation, establish a total order between equations, and determine their priority for use in theorem proving. Concrete use cases include selecting and ordering equations during clause processing in automated reasoning systems.",
      "description_length": 458,
      "index": 826,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Heuristics.S-Env-ProofState-module-type-CLAUSE_SET",
      "library": "libzipperposition.calculi",
      "description": "This module manages a dynamic set of clauses, providing operations to add or remove clauses and to subscribe to events when clauses are added or removed. It works with clause sets using the `C.t` type and supports iteration over clauses via `Iter.t`. Concrete use cases include tracking clause modifications during theorem proving and enabling reactive updates to clause set changes in automated reasoning systems.",
      "description_length": 414,
      "index": 827,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Superposition_intf.S-PS-ActiveSet",
      "library": "libzipperposition.calculi",
      "description": "This module manages a dynamic set of clauses with operations to add, remove, and retrieve clauses, as well as track changes via signals. It works with clause sets represented as `C.ClauseSet.t` and supports iteration over clauses through `C.t Iter.t`. Concrete use cases include maintaining an active set of clauses during theorem proving and triggering actions when clauses are inserted or removed.",
      "description_length": 399,
      "index": 828,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Bce.S-Env-ProofState-SubsumptionIndex",
      "library": "libzipperposition.calculi",
      "description": "This module implements a subsumption index for managing and querying clauses in a proof state. It supports operations to add or remove clauses, retrieve subsuming or subsumed clauses, and check for alpha-equivalence, all based on literal and label patterns. The index is used during automated theorem proving to efficiently find relevant clauses for inference or simplification steps.",
      "description_length": 384,
      "index": 829,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Hlt_elim.S-Env-Stm-Ctx-Lit",
      "library": "libzipperposition.calculi",
      "description": "This module manages bidirectional conversions between literals and formulas in a logical context. It provides hooks to customize conversion behavior, supporting integration with term rewriting and theorem proving systems. Key operations include `of_form` and `to_form`, which convert between atomic formulas and literals, enabling precise manipulation of logical expressions in automated reasoning tasks.",
      "description_length": 404,
      "index": 830,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Qle.S-Env-ProofState-SubsumptionIndex-C",
      "library": "libzipperposition.calculi",
      "description": "This module defines operations for comparing clauses, extracting literals, and retrieving label subsets from clauses. It works with clause data structures and associated label sets. Concrete use cases include subsumption checking and literal-based indexing in automated theorem proving.",
      "description_length": 286,
      "index": 831,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Higher_order.S-Env-ProofState",
      "library": "libzipperposition.calculi",
      "description": "Manages clause queues and indexing structures for efficient retrieval during proof search. It includes priority queues for clause scheduling and term-based indexes for fast lookups. Used to organize and process clauses in saturation-based theorem proving.",
      "description_length": 255,
      "index": 832,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Superposition_intf.S-PS-CQueue-PriorityFun",
      "library": "libzipperposition.calculi",
      "description": "This module defines a priority function type for weighting clauses in a superposition calculus, mapping clause queues to integer priorities. It includes a function to parse string descriptions into these priority functions. Use it to dynamically configure clause selection strategies based on textual input, such as assigning higher priority to shorter clauses or specific clause types.",
      "description_length": 386,
      "index": 833,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Bce.S-Env-FormRename-Ctx",
      "library": "libzipperposition.calculi",
      "description": "This module provides operations for manipulating logical contexts, term comparisons, and injectivity checks in formal reasoning systems. It works with terms, literals, types, signatures, and substitutions to support tasks like unification, skolemization, and logical literal normalization. Key use cases include managing symbol declarations during proof search and analyzing term properties for term rewriting or automated reasoning.",
      "description_length": 433,
      "index": 834,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Bce_pe_fixpoint.S-Env-FormRename",
      "library": "libzipperposition.calculi",
      "description": "This module handles formula renaming and Skolem management during logical transformations. It provides operations to detect renaming clauses, introduce predicate Skolem symbols, and rename formulas based on context and polarity. Key use cases include formula normalization and definition extraction in theorem proving pipelines.",
      "description_length": 328,
      "index": 835,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Qle.S-Env-ProofState-UnitIndex-E",
      "library": "libzipperposition.calculi",
      "description": "This module represents and compares indexed equations or inequations, each paired with a clause. It provides a total order via `compare`, extracts term components and sign via `extract`, and assigns usefulness via `priority`. Useful for managing and prioritizing equations during automated reasoning tasks.",
      "description_length": 306,
      "index": 836,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Fool.S-Env-ProofState-UnitIndex",
      "library": "libzipperposition.calculi",
      "description": "This module implements an indexing structure for managing and querying logical (in)equations within a proof state. It supports operations to add, remove, and retrieve indexed terms with substitution-based pattern matching, focusing on efficient term generalization queries. The module is used to track and manipulate logical constraints during automated reasoning tasks.",
      "description_length": 370,
      "index": 837,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Hlt_elim.S-C-WithPos",
      "library": "libzipperposition.calculi",
      "description": "This module represents clauses with a highlighted subterm and its position, enabling precise manipulation of terms within clauses. It provides comparison and pretty-printing operations for these structured clauses. Use cases include implementing rewriting or inference rules that require tracking specific subterms during proof search.",
      "description_length": 335,
      "index": 838,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Higher_order.S-Env-ProofState-SubsumptionIndex",
      "library": "libzipperposition.calculi",
      "description": "This module implements a subsumption index for clauses in a theorem proving context, supporting operations to add, remove, and query clauses based on subsumption and alpha-equivalence. It works with clauses represented as literals and labels, providing indexed retrieval of candidates that may subsume or be subsumed by a given clause. Concrete use cases include efficient clause indexing and redundancy checking during saturation-based proof search.",
      "description_length": 450,
      "index": 839,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Heuristics.S-Env-FormRename-Ctx",
      "library": "libzipperposition.calculi",
      "description": "This module offers logical context management through skolemization, term ordering, and clause selection, operating on terms, symbols, and literals from the Logtk and Libzipperposition libraries. It supports first-order logic operations via injectivity checks for identifiers and literal manipulation, enabling applications in superposition-based theorem proving and term rewriting systems. Key functionality includes maintaining context state for completeness and guiding unification strategies through term comparison and symbol declaration.",
      "description_length": 543,
      "index": 840,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Bce.S-Env-Stm-Ctx",
      "library": "libzipperposition.calculi",
      "description": "This module offers operations for managing logical contexts in theorem proving, including term orderings, selection functions, and skolemization, alongside term signature manipulation via symbol declarations and type queries. It supports injectivity analysis of function arguments in logical terms, utilizing identifiers and term structures to enforce properties during proof search. These capabilities are critical in automated reasoning systems for validating term-level constraints and dynamically managing symbol definitions during deduction.",
      "description_length": 546,
      "index": 841,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Heuristics.S-PS-module-type-CLAUSE_SET",
      "library": "libzipperposition.calculi",
      "description": "This module manages a dynamic set of clauses, providing operations to add or remove clauses and trigger signals when changes occur. It works with clause sets using the `C.t` type and supports iteration over clauses via `Iter.t`. Concrete use cases include maintaining active clause sets in automated theorem proving where tracking additions and removals is essential for strategy implementation.",
      "description_length": 395,
      "index": 842,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Higher_order.S-Env-ProofState-module-type-CLAUSE_SET",
      "library": "libzipperposition.calculi",
      "description": "This module manages a set of clauses with operations to add or remove clauses and to register callbacks for when clauses are added or removed. It works with clause sets and uses signals to notify listeners of changes. Concrete use cases include tracking clause modifications during theorem proving and enabling reactive updates in proof state management.",
      "description_length": 354,
      "index": 843,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Higher_order.S-C-Tbl",
      "library": "libzipperposition.calculi",
      "description": "This module implements a hash table with imperative operations for managing key-value pairs where keys are of type `C.t` or `C.Tbl.key`. It supports standard dictionary workflows like insertion, lookup, iteration, and folding, alongside specialized utilities for safe value retrieval with defaults, bulk updates, and in-place transformations, including statistical tracking for table introspection. Common use cases include counting occurrences of keys, converting between hash tables and collections like lists or sequences, and customizing value aggregation or string representations for domain-specific data.",
      "description_length": 611,
      "index": 844,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Higher_order.S-Env-C-WithPos",
      "library": "libzipperposition.calculi",
      "description": "Represents a clause with a specific subterm and its position within that clause. It includes operations to compare such structures based on their components and to pretty-print them for debugging or logging. This is useful when implementing term rewriting or superposition-based theorem proving steps that require tracking subterm locations.",
      "description_length": 341,
      "index": 845,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.EnumTypes.S-Env-FormRename-Ctx-Lit",
      "library": "libzipperposition.calculi",
      "description": "This module manages bidirectional conversions between literals and formulas using customizable hooks. It provides functions to register and retrieve conversion hooks for transforming literals to formulas and vice versa, along with direct conversion operations that enforce atomic formula constraints. It works with `Logtk.Literal.t` and `Logtk.SLiteral.t` types, supporting use cases like integrating custom literal representations into theorem proving pipelines or translating between internal and external logic encodings.",
      "description_length": 524,
      "index": 846,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Fool.S-C-ClauseSet",
      "library": "libzipperposition.calculi",
      "description": "This module offers set-theoretic operations for managing ordered collections of clauses, emphasizing immutable transformations and ordered traversal. It works with `C.ClauseSet.t` structures\u2014sets of clauses ordered via a comparison function\u2014to support efficient membership checks, union/intersection/difference computations, and predicate-based filtering or partitioning. Designed for automated reasoning tasks, it enables use cases like clause normalization, logical inference, and formal verification workflows requiring precise set manipulation and ordered element retrieval.",
      "description_length": 578,
      "index": 847,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Pred_elim.S-Env-C-Pos",
      "library": "libzipperposition.calculi",
      "description": "This module provides a function `at` that retrieves a term from a given position within a clause in a specific environment. It operates on environments of type `Env.C.t` and terms represented by `Logtk.Term.t`, using positions from `Logtk.Position.t`. A concrete use case is extracting subterms during proof search or term analysis in automated theorem proving.",
      "description_length": 361,
      "index": 848,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Lazy_cnf.S-Env-C-ClauseSet",
      "library": "libzipperposition.calculi",
      "description": "This module provides a rich interface for manipulating ordered sets of clauses with operations like union, intersection, filtering, and ordered traversal, alongside utilities for conversion to and from sequences, lists, and iterators. It relies on a sorted set data structure (`Env.C.ClauseSet.t`) that enforces ordering via a comparison function, supporting efficient queries for min/max elements, cardinality checks, and predicate-based searches. These capabilities are particularly useful for tasks requiring ordered clause processing, such as theorem proving strategies that depend on prioritized clause selection or generating human-readable representations of clause sets for debugging.",
      "description_length": 692,
      "index": 849,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Hlt_elim.S-Env-FormRename",
      "library": "libzipperposition.calculi",
      "description": "This module handles formula renaming and Skolemization during proof search. It provides operations to detect renaming clauses, introduce predicate Skolem symbols, and rename formulas under specific conditions. Key data structures include clauses and formula renaming contexts, used in transformation and simplification of logical expressions.",
      "description_length": 342,
      "index": 850,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Bce.S-Env-ProofState-SubsumptionIndex-C",
      "library": "libzipperposition.calculi",
      "description": "This module defines operations for comparing clauses, extracting literals, and retrieving label subsets from clauses. It works with clause data structures and associated labels and literals. Concrete use cases include subsumption checking and indexing for efficient retrieval in automated theorem proving.",
      "description_length": 305,
      "index": 851,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Pred_elim.S-Env-ProofState-CQueue-C",
      "library": "libzipperposition.calculi",
      "description": "Supports operations for clause manipulation, analysis, and transformation in automated reasoning tasks, including flag management, redundancy checks, trail modification, proof handling, and eligibility assessment for inference rules. It works with clauses, substitutions, and clause sets, enabling use cases like proof state management, formula grounding, and term analysis for resolution/paramodulation. Utilities for \u03b7-reduction, literal selection, and structured printing further aid theorem proving workflows.",
      "description_length": 513,
      "index": 852,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Fool.S-Env-ProofState-SubsumptionIndex-C",
      "library": "libzipperposition.calculi",
      "description": "This module defines operations for comparing clauses, extracting literals, and retrieving label subsets. It works with clauses represented by the type `C.t` and associated integer labels. It supports subsumption checks by ensuring label sets are subsets during clause comparison.",
      "description_length": 279,
      "index": 853,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Booleans.S-Env-ProofState-TermIndex",
      "library": "libzipperposition.calculi",
      "description": "The module provides operations for managing a term index with efficient insertion, deletion, and retrieval of terms paired with positional elements, supporting advanced queries for unification, generalization, and specialization in higher-order logic contexts. It leverages scoped environments and substitutions to handle complex term manipulations, with iterative result sequences for incremental processing. A dedicated visualization function outputs the index structure in DOT format, aiding analysis and debugging of proof states involving hierarchical term relationships.",
      "description_length": 576,
      "index": 854,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Superposition_intf.S-PS-module-type-CLAUSE_SET",
      "library": "libzipperposition.calculi",
      "description": "This module manages a set of clauses with operations to add or remove clauses and to subscribe to events when clauses are added or removed. It works with clause sets and uses iterators to process multiple clauses. Concrete use cases include tracking changes to a clause set during theorem proving or maintaining derived constraints in a logical solver.",
      "description_length": 352,
      "index": 855,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Heuristics.S-Env-ProofState-SimplSet",
      "library": "libzipperposition.calculi",
      "description": "This module manages a dynamic set of clauses with signals for tracking additions and removals. It provides functions to add or remove multiple clauses at once using iterators. Useful for maintaining and updating clause sets during theorem proving processes where specific clauses need to be monitored or processed incrementally.",
      "description_length": 328,
      "index": 856,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Heuristics.S-Env-FormRename-Ctx-Lit",
      "library": "libzipperposition.calculi",
      "description": "This module provides functions to convert between literals and formulas, specifically handling atomic formulas. It maintains lists of conversion hooks for transforming literals to and from formulas, supporting customizable conversion logic. The primary data types are `Logtk.Literal.t` and `Logtk.SLiteral.t`, with use cases in proof search and term rewriting where literal-level transformations are required.",
      "description_length": 409,
      "index": 857,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Superposition_intf.S-Env-FormRename-Ctx-Lit",
      "library": "libzipperposition.calculi",
      "description": "This module manages bidirectional conversions between literals and atomic formulas using customizable hooks. It provides functions to register and retrieve conversion hooks, ensuring that input literals can be transformed into atomic formulas and vice versa. Concrete use cases include integrating custom literal representations with theorem proving procedures that require atomic formula inputs.",
      "description_length": 396,
      "index": 858,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Lazy_cnf.S-Env-ProofState-PassiveSet",
      "library": "libzipperposition.calculi",
      "description": "This module manages a set of clauses with dynamic addition and removal, supporting passive clause processing in a theorem proving context. It provides signals for clause modifications, direct access to the clause set and queue, and operations to add, remove, and retrieve clauses. Concrete use cases include tracking and processing passive clauses during the proof search in automated reasoning systems.",
      "description_length": 403,
      "index": 859,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Higher_order.S-Env-ProofState-SimplSet",
      "library": "libzipperposition.calculi",
      "description": "This module manages a set of clauses with operations to add or remove clauses and trigger signals on these changes. It works with clause data types and iterators over clauses. It is used to maintain a dynamic collection of clauses with event notifications for additions and removals.",
      "description_length": 283,
      "index": 860,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Hlt_elim.S-Env-ProofState-SimplSet",
      "library": "libzipperposition.calculi",
      "description": "This module manages a dynamic set of clauses with operations to add or remove clauses and trigger signals on these changes. It works with clause data structures and uses iterators for batch modifications. It supports scenarios like maintaining active clause sets in theorem proving where tracking additions and removals is essential.",
      "description_length": 333,
      "index": 861,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Bce.S-Env-StmQ-WeightFun",
      "library": "libzipperposition.calculi",
      "description": "This module defines weight functions that assign integer weights to streams of statements. It provides operations to retrieve a penalty value for a stream and to combine multiple weight functions with coefficients into a single weighted sum. These functions are used to prioritize or evaluate the relevance of statement sequences in automated reasoning tasks.",
      "description_length": 359,
      "index": 862,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Fool.S-Env-C-Tbl",
      "library": "libzipperposition.calculi",
      "description": "This module provides hash table operations for mappings with keys of type `Env.C.t`, emphasizing safe retrieval, bulk updates from sequences/iterators, and merging entries with customizable conflict resolution. It supports key-based transformations, aggregation over data streams, and statistics tracking, with utilities for in-place modifications and structured table construction. Typical use cases include managing environment bindings, implementing caches with structured keys, and aggregating frequency counts from iterative processes.",
      "description_length": 540,
      "index": 863,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Fool.S-Env-ProofState-CQueue-PriorityFun",
      "library": "libzipperposition.calculi",
      "description": "This module defines a priority function type for ordering clauses in a proof state's clause queue. It supports parsing string descriptions into integer-weighting functions that prioritize clauses during automated reasoning tasks. The priority function is used to guide the selection of clauses in saturation-based theorem proving.",
      "description_length": 330,
      "index": 864,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Bce_pe_fixpoint.S-Env-Ctx",
      "library": "libzipperposition.calculi",
      "description": "This module manages logical context and state operations for theorem proving systems, focusing on term orderings, symbol declarations, and skolemization contexts. It works with terms, types, symbols, and signatures from Logtk/Libzipperposition, supporting tasks like injectivity checks for function symbols and literal manipulation via the Lit submodule. Key use cases include clause processing in resolution provers and maintaining consistency during term rewriting or signature evolution.",
      "description_length": 490,
      "index": 865,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Fool.S",
      "library": "libzipperposition.calculi",
      "description": "This module implements first-order logic simplification rules and setup procedures for automated reasoning. It provides operations to register simplification rules within an environment and specifically handles boolean literals through targeted rewriting. The module works with logical expressions and environment structures to facilitate rule-based transformations in theorem proving tasks.",
      "description_length": 391,
      "index": 866,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Fool.S-C-Pos",
      "library": "libzipperposition.calculi",
      "description": "Extracts a subterm at a specified position from a given term. Works with terms and positions in a formal logic representation. Useful for precise term manipulation in automated reasoning tasks.",
      "description_length": 193,
      "index": 867,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Pred_elim.S-Env-ProofState-CQueue-PriorityFun",
      "library": "libzipperposition.calculi",
      "description": "This module defines a priority function type for ordering clauses in a proof state's clause queue. It supports parsing string descriptions into weighting functions that assign integer priorities to clauses. Concrete use cases include configuring clause selection strategies in automated theorem proving based on syntactic or semantic features of clauses.",
      "description_length": 354,
      "index": 868,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Lazy_cnf.S-Env-ProofState-module-type-CLAUSE_SET",
      "library": "libzipperposition.calculi",
      "description": "This module manages a set of clauses with operations to add or remove clauses using iterators. It provides signals that trigger when clauses are added or removed, enabling reactive updates. It is used in theorem proving contexts to maintain and monitor dynamic collections of logical clauses.",
      "description_length": 292,
      "index": 869,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Bce_pe_fixpoint.S-Env-FormRename-Ctx",
      "library": "libzipperposition.calculi",
      "description": "This module provides operations for skolemization, term ordering, selection functions, and signature manipulation, alongside injectivity checks for identifiers in argument positions. It operates on terms, types, and symbols from the Logtk library, as well as logical literals managed via the Lit module, which supports comparison, matching, and hashing. These capabilities are used in logical reasoning tasks such as maintaining context state for completeness, term rewriting, and formal verification workflows.",
      "description_length": 511,
      "index": 870,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Bce.S-Env-Ctx-Lit",
      "library": "libzipperposition.calculi",
      "description": "This module manages bidirectional conversions between literals and formulas using hooks for customization. It provides functions to register and retrieve conversion hooks, as well as to convert between literal and formula representations. It works directly with `Logtk.Literal.t` and `Logtk.SLiteral.t` types, supporting use cases like integrating custom literal encodings or decoding literals into higher-level formula structures during proof search.",
      "description_length": 451,
      "index": 871,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Higher_order.S-Env-C",
      "library": "libzipperposition.calculi",
      "description": "This module provides operations for managing clause metadata (e.g., redundancy flags, weights, proof trails), logical analysis (eligibility for inference rules, literal maximality), and transformations (substitution application, clause normalization) in higher-order logic. It works with clauses (`Env.C.t`), substitutions (`Logtk.Subst.t`), terms (`Logtk.Term.t`), and bitvectors (`CCBV.t`) to support tasks like redundancy checking, proof construction, and guiding resolution/paramodulation inferences. Key use cases include clause simplification, goal detection, and maintaining trail-based state during theorem proving.",
      "description_length": 623,
      "index": 872,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Higher_order.S-C-ClauseSet",
      "library": "libzipperposition.calculi",
      "description": "This module provides ordered set operations for managing collections of clauses, including filtering, partitioning, element retrieval (e.g., min/max), and conversions to lists or sequences, with safe variants that return optional values. It operates on persistent, ordered sets of clauses (`ClauseSet.t`) structured by a comparison function, emphasizing functional purity and efficient structural sharing. These capabilities are particularly useful for applications requiring precise clause manipulation, such as automated theorem proving or logic-based systems where ordered clause processing, transformation, and structured output formatting are critical.",
      "description_length": 657,
      "index": 873,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Lazy_cnf.S",
      "library": "libzipperposition.calculi",
      "description": "Converts first-order logic formulas into clausal normal form using lazy CNF transformation. It tracks and updates clause counters during the transformation process. Useful for theorem proving systems where clause management and formula manipulation are required.",
      "description_length": 262,
      "index": 874,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Hlt_elim.S-C-Pos",
      "library": "libzipperposition.calculi",
      "description": "This module provides a function `at` that retrieves a subterm from a given term at a specified position. It operates on terms and positions, enabling precise navigation within term structures. Useful for tasks like term rewriting or analysis where specific subterms must be accessed or modified.",
      "description_length": 295,
      "index": 875,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Pred_elim.S-Env-FormRename-Ctx-Lit",
      "library": "libzipperposition.calculi",
      "description": "This module implements conversions between literals and atomic formulas, supporting operations to register and retrieve transformation hooks for customizing the conversion logic. It works with literals and terms wrapped in `SLiteral.t` structures, enforcing atomicity constraints during conversion. Concrete use cases include integrating custom literal normalization routines or mapping logical atoms to specialized term representations in theorem proving pipelines.",
      "description_length": 466,
      "index": 876,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Pred_elim.Make",
      "library": "libzipperposition.calculi",
      "description": "This module implements a fixpoint-based predicate elimination algorithm using a parameterized equality module. It provides operations to initialize the elimination process, perform iterative fixpoint steps, and finalize the computation, working with logical formulas and equality constraints. It is used for simplifying logical expressions by removing redundant predicates through fixpoint iteration.",
      "description_length": 400,
      "index": 877,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Bce.S-Env-ProofState-PassiveSet",
      "library": "libzipperposition.calculi",
      "description": "This module manages a set of passive clauses with operations to add, remove, and retrieve clauses, as well as track their state via signals. It works with clause data types and structures such as `C.t`, `C.ClauseSet.t`, and `Env.ProofState.CQueue.t`. It is used to maintain and process passive clauses during theorem proving, enabling event-driven updates and efficient clause selection.",
      "description_length": 387,
      "index": 878,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Higher_order.S-Env-ProofState-TermIndex",
      "library": "libzipperposition.calculi",
      "description": "This module provides operations to manage and query term indices, supporting efficient term retrieval through unification, generalization, and specialization checks during proof search. It works with term indices structured over proof states, enabling dynamic updates as terms evolve during higher-order reasoning. The DOT format export allows visualization of index contents for debugging or analysis in theorem proving workflows.",
      "description_length": 431,
      "index": 879,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Higher_order.S-Env-ProofState-CQueue-C",
      "library": "libzipperposition.calculi",
      "description": "This module provides operations for analyzing, modifying, and transforming logical clauses in higher-order theorem proving, including flag management, redundancy checks, trail merging, and eligibility determination for resolution or paramodulation. It works with clauses (`C.t`), substitutions, bitvectors, literals, and proof trails, enabling tasks like dependency tracking, proof updating, and symbolic grounding. Specific use cases include clause simplification, goal-oriented proof search, and generating debug/TSTP-formatted output for verification workflows.",
      "description_length": 564,
      "index": 880,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Fool.S-Env-C-Eligible",
      "library": "libzipperposition.calculi",
      "description": "This module defines eligibility criteria for selecting literals in first-order logic clauses, particularly for use in automated theorem proving. It provides functions to filter literals based on properties like positivity, negativity, maximality, and equation status, as well as logical combinations of these conditions. These criteria are used to control resolution and paramodulation steps during clause processing.",
      "description_length": 417,
      "index": 881,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Fool.S-Env-StmQ-WeightFun",
      "library": "libzipperposition.calculi",
      "description": "This module defines weight functions for assigning integer weights to streams of statements. It includes operations to retrieve a penalty value for a stream and to combine multiple weighted functions into a single function using a weighted sum. These functions are used to prioritize or evaluate the relevance of statement streams in automated reasoning tasks.",
      "description_length": 360,
      "index": 882,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Lazy_cnf.S-Env-C-Tbl",
      "library": "libzipperposition.calculi",
      "description": "This module offers imperative hash table operations for managing key-value associations with keys of type `Env.C.t`, emphasizing in-place transformations, statistical tracking, and sequence interoperability. It supports safe key manipulation, counter aggregation, and customizable merging strategies for handling duplicates, alongside utilities for converting lists or iterators into tables and formatting their contents. Typical applications include dynamic term frequency tracking, associative data merging, and incremental table updates requiring efficient aggregation or structured output.",
      "description_length": 593,
      "index": 883,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Hlt_elim.S-C-ClauseSet",
      "library": "libzipperposition.calculi",
      "description": "This module provides a suite of ordered set operations for managing collections of clauses with comparator-driven ordering, supporting functional transformations like union, intersection, and mapping alongside safe traversal, filtering, and cardinality checks. It works with `C.ClauseSet.t` structures\u2014persistent, ordered sets parameterized by a comparator module\u2014holding elements of type `C.t`, which are typically logical clauses in automated reasoning contexts. Designed for applications requiring precise clause manipulation, such as theorem proving or constraint solving, it enables efficient querying, ordered iteration, and serialization to formats like lists or formatted strings, particularly useful in proof search algorithms where clause prioritization or structured analysis is critical.",
      "description_length": 799,
      "index": 884,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Pred_elim.S-Env-ProofState-module-type-CLAUSE_SET",
      "library": "libzipperposition.calculi",
      "description": "This module manages a dynamic set of clauses with support for adding and removing clauses using iterators. It provides signals to monitor changes when clauses are added or removed. Useful for implementing clause management in automated theorem proving or logic-based systems where dynamic clause manipulation is required.",
      "description_length": 321,
      "index": 885,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Pred_elim.S-Env-ProofState",
      "library": "libzipperposition.calculi",
      "description": "Manages clause queues and indexes for efficient retrieval during automated reasoning. Provides operations for prioritizing clauses, indexing terms, and handling subsumption checks. Used to organize and process logical formulas in saturation-based theorem proving.",
      "description_length": 263,
      "index": 886,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Booleans.S-Env-C-Seq",
      "library": "libzipperposition.calculi",
      "description": "This module processes logical clauses by extracting literals, terms, or variables from a given clause environment. It operates on clause structures (`Env.C.t`) and produces iterators over literals, terms, or typed variables. It is used in theorem proving tasks to analyze and manipulate logical expressions during clause processing.",
      "description_length": 332,
      "index": 887,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Booleans.S-Env-ProofState-CQueue-PriorityFun",
      "library": "libzipperposition.calculi",
      "description": "This module defines a priority function type for ordering clauses in a proof state's clause queue. It supports parsing string descriptions into integer-weight functions that guide clause selection during automated reasoning. Use cases include configuring prioritization strategies in theorem proving algorithms based on clause attributes.",
      "description_length": 338,
      "index": 888,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Booleans.S-Env-Ctx",
      "library": "libzipperposition.calculi",
      "description": "This module type provides context management operations for theorem proving systems, including term ordering, selection functions, and skolemization contexts. It works with logical literals, term signatures, and symbol declarations, supporting tasks like unification, term rewriting, and type analysis through functions such as injectivity checks and literal normalization. Key data structures include typed symbols and skolem contexts, while operations on literals enable comparison, hashing, and logical simplification.",
      "description_length": 521,
      "index": 889,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Fool.S-Env-StmQ",
      "library": "libzipperposition.calculi",
      "description": "This module implements a priority queue for managing streams of clauses with weighted priorities. It supports operations to add streams or lists of streams, inspect queue length, and extract clauses either individually or in batches, using strategies that ensure fairness or bounded execution. The queue is used to schedule clause processing in a way that balances between priority-based selection and resource constraints.",
      "description_length": 423,
      "index": 890,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Lazy_cnf.S-Env-ProofState-SubsumptionIndex-C",
      "library": "libzipperposition.calculi",
      "description": "This module defines operations for comparing clauses, extracting literals, and retrieving label subsets, all working directly with clause data structures. It supports subsumption checks by ensuring label inclusion and provides literal iteration for indexing or proof search. Concrete use cases include clause subsumption testing and literal-based indexing in automated theorem proving.",
      "description_length": 385,
      "index": 891,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.EnumTypes.S-Env-C-Tbl",
      "library": "libzipperposition.calculi",
      "description": "This module manipulates hash tables that map keys of type `Env.C.Tbl.key` to arbitrary values, supporting operations like insertion, lookup, deletion, iteration, and conversion to sequences or iterators. It emphasizes use cases such as frequency counting, aggregating data with custom combination functions for duplicate keys, and safe value retrieval with default fallbacks. Iteration over keys and values, along with configurable printers for formatted output, further enable tasks like data summarization and structured traversal.",
      "description_length": 533,
      "index": 892,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Libzipperposition_calculi.EnumTypes.S-Env-Ctx",
      "library": "libzipperposition.calculi",
      "description": "This module provides operations for managing logical context components such as term orderings, selection functions, and skolemization contexts, alongside utilities for term signature manipulation, including symbol declaration, type resolution, and injectivity tracking. It operates on symbolic representations, logical literals, and term structures, enabling use cases like unification, inference rule application, and handling injective function assumptions in theorem proving workflows.",
      "description_length": 489,
      "index": 893,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Heuristics.S-Env-C-WithPos",
      "library": "libzipperposition.calculi",
      "description": "This module represents clauses with a specific subterm and its position, enabling precise term manipulation and analysis. It provides comparison and pretty-printing operations for these structured clauses. Useful for implementing rewriting strategies or focused proof search where term positions are critical.",
      "description_length": 309,
      "index": 894,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Lazy_cnf.S-C-WithPos",
      "library": "libzipperposition.calculi",
      "description": "This module represents clauses with a specific subterm and its position, enabling precise manipulation and analysis of terms within clauses. It provides comparison and pretty-printing operations for these structured clauses. Useful for tasks like subterm indexing, rewriting, or focused proof search where term positions matter.",
      "description_length": 328,
      "index": 895,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Pred_elim.S-Env",
      "library": "libzipperposition.calculi",
      "description": "This module provides operations for clause management, inference rule application, and logical simplification in a saturation-based theorem proving environment. It works with clauses, clause sets, terms, literals, and flex state objects to support use cases like redundancy elimination, predicate elimination, and normalization through rule-based transformations and structured proof state control. Specific mechanisms include handling inference streams, detecting empty clauses, and managing tautology or rewriting rules for higher-order logic reasoning.",
      "description_length": 555,
      "index": 896,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Booleans.S-Env-ProofState-SubsumptionIndex-C",
      "library": "libzipperposition.calculi",
      "description": "This module defines operations for comparing clauses, extracting literals, and retrieving label subsets. It works with clause data structures from a proof state subsumption index. Concrete use cases include subsumption checking and clause indexing in automated theorem proving.",
      "description_length": 277,
      "index": 897,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Bce_pe_fixpoint.S-Env-C-WithPos",
      "library": "libzipperposition.calculi",
      "description": "This module represents clauses with a specific subterm and its position, enabling precise term manipulation and analysis. It provides comparison and pretty-printing operations for these structured clauses. Useful for tasks like subterm indexing, rewriting, or focused proof search where positional context is critical.",
      "description_length": 318,
      "index": 898,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Booleans.S-Env-ProofState-SubsumptionIndex",
      "library": "libzipperposition.calculi",
      "description": "This module implements a subsumption index for managing and querying clauses in a proof state, supporting operations to add or remove clauses and retrieve subsuming, subsumed, or alpha-equivalent clauses. It works with clause data types defined in the `C` submodule and uses literal and label sequences for indexing and querying. Concrete use cases include efficient clause subsumption checks during automated theorem proving and maintaining a dynamic set of clauses for inference and simplification.",
      "description_length": 500,
      "index": 899,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.EnumTypes.S-C-Tbl",
      "library": "libzipperposition.calculi",
      "description": "This module provides specialized hash table operations for keys of type `C.t`, supporting imperative updates, duplicate handling with custom merge strategies, and efficient counting/incrementing of values. It works with hash tables mapping `C.t` keys to arbitrary values, offering conversions to and from sequences and iterators while managing conflicts during insertion. Typical use cases include aggregating key-value bindings from lists or iterators, safely updating counters, and maintaining tables with dynamic entries requiring custom merge logic.",
      "description_length": 553,
      "index": 900,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Superposition_intf.S-Env-Stm-Ctx",
      "library": "libzipperposition.calculi",
      "description": "This module provides operations for managing logical contexts in a superposition calculus, focusing on term orderings, selection functions, skolemization, and signature manipulation. It works with term signatures, logical literals (via the `Lit` module), and symbols with properties like injectivity for specific argument positions. These tools are used in theorem proving to guide unification, inference rules, and term comparisons within formal verification tasks.",
      "description_length": 466,
      "index": 901,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Superposition_intf.S-Env-FormRename",
      "library": "libzipperposition.calculi",
      "description": "This module supports formula renaming and Skolem management during theorem proving. It provides operations to detect renaming clauses, introduce predicate Skolems, and rename formulas based on definitional transformations. Key data structures include clauses and formula renaming contexts, used to manage logical equivalences and Skolem symbols in superposition-based reasoning.",
      "description_length": 378,
      "index": 902,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Fool.S-Env-ProofState-ActiveSet",
      "library": "libzipperposition.calculi",
      "description": "This module manages a dynamic set of clauses with signals for additions and removals. It provides functions to add or remove clauses, retrieve the current set, and count clauses. Useful for tracking clause changes in automated theorem proving processes.",
      "description_length": 253,
      "index": 903,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.EnumTypes.S-Env-StmQ-WeightFun",
      "library": "libzipperposition.calculi",
      "description": "This module defines weight functions that assign integer weights to statements, with operations to retrieve a default penalty function and combine multiple weight functions using weighted sums. It works with streams of statements and supports composing custom weighting strategies from existing functions. Concrete use cases include defining prioritization schemes for statement selection based on configurable coefficients.",
      "description_length": 424,
      "index": 904,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Bce.S-Env-Stm-Ctx-Lit",
      "library": "libzipperposition.calculi",
      "description": "This module manages bidirectional conversions between literals and formulas using hooks. It provides functions to register and retrieve conversion hooks for transforming literals to and from atomic formulas. The module works directly with `Logtk.Literal.t` and `Logtk.SLiteral.t` types, supporting use cases like integrating custom literal representations into theorem proving pipelines or translating logical expressions for solver input.",
      "description_length": 439,
      "index": 905,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Heuristics.S-PS-SubsumptionIndex",
      "library": "libzipperposition.calculi",
      "description": "This module implements a subsumption index for efficient retrieval of clauses that may subsume or be subsumed by a given clause. It supports operations to add or remove clauses, and to query for subsuming, subsumed, or alpha-equivalent clauses using literal and label sequences. The index works with clauses represented as sequences of literals and labels, and is used in theorem proving to accelerate subsumption checks during saturation-based reasoning.",
      "description_length": 455,
      "index": 906,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Superposition_intf.S",
      "library": "libzipperposition.calculi",
      "description": "This module implements superposition calculus operations, including term indexing for efficient inference, equality resolution/factoring rules, and clause simplification via subsumption and tautology elimination. It operates on clauses, literals, and substitutions to manage logical formulas during automated reasoning. These mechanisms optimize proof search by reducing redundancy and maintaining efficient inference through active set management and contextual literal simplification.",
      "description_length": 486,
      "index": 907,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Lazy_cnf.S-Env-Ctx-Lit",
      "library": "libzipperposition.calculi",
      "description": "This module manages conversions between literals and formulas using customizable hooks. It provides functions to register and retrieve hooks for transforming literals to and from formulas, specifically working with `Logtk.Literal.t` and `Logtk.Term.t Logtk.SLiteral.t` types. It is used to support lazy CNF conversion in theorem proving contexts by allowing modular customization of literal transformations.",
      "description_length": 407,
      "index": 908,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Superposition_intf.S-PS-CQueue-WeightFun",
      "library": "libzipperposition.calculi",
      "description": "This module defines weight functions for assigning integer weights to clauses in a clause queue, used to prioritize clauses during automated reasoning. It operates on clause data structures and provides functions like `default`, `penalty`, and `favor_goal` to compute weights based on clause properties such as literal content, goal proximity, and penalties. Use cases include guiding clause selection in superposition-based theorem proving by favoring specific clause characteristics like being ground, Horn, or close to the initial goal.",
      "description_length": 539,
      "index": 909,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Booleans.S-Env-ProofState-PassiveSet",
      "library": "libzipperposition.calculi",
      "description": "This module manages a set of passive clauses within a theorem proving system, providing operations to add, remove, and query clauses, as well as access the current clause queue. It supports data types including clause sets, queues, and boolean checks for clause status. Concrete use cases include controlling clause processing order, tracking passive clauses, and integrating with proof state management during automated reasoning tasks.",
      "description_length": 437,
      "index": 910,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Qle.S-Env-ProofState-CQueue-PriorityFun",
      "library": "libzipperposition.calculi",
      "description": "This module defines a priority function type used to assign integer weights to elements in a proof state queue, guiding their processing order. It includes a function to parse string descriptions into these priority functions. It is used to dynamically configure prioritization strategies for managing proof states during automated reasoning tasks.",
      "description_length": 348,
      "index": 911,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Heuristics.S-Env-C-Seq",
      "library": "libzipperposition.calculi",
      "description": "This module provides functions to extract literals, terms, and variables from a clause environment. It operates on clause structures and supports iteration over their components. Use it to analyze or transform logical clauses during proof search or formula processing.",
      "description_length": 268,
      "index": 912,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Hlt_elim.S-C-Seq",
      "library": "libzipperposition.calculi",
      "description": "This module provides functions to extract literals, terms, and variables from a given clause structure. It operates on clauses (`C.t`) and returns iterators over literals, terms, and typed variables. Useful for analyzing or transforming logical clauses during theorem proving or formula manipulation tasks.",
      "description_length": 306,
      "index": 913,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.EnumTypes.S-C-Seq",
      "library": "libzipperposition.calculi",
      "description": "This module provides functions to extract literals, terms, and variables from a clause structure. It works with clauses (`C.t`), iterating over their components as literals, terms, or typed variables. Useful for analyzing or transforming logical clauses during theorem proving or formula manipulation tasks.",
      "description_length": 307,
      "index": 914,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Bce_pe_fixpoint.S-Env-ProofState-SubsumptionIndex",
      "library": "libzipperposition.calculi",
      "description": "This module implements a subsumption index for managing and querying clauses in a proof state. It supports operations to add, remove, and retrieve clauses based on subsumption and alpha-equivalence relationships, using literals and labels as keys. Use cases include efficient clause indexing and retrieval during automated theorem proving processes, such as identifying redundant clauses or finding candidates for resolution.",
      "description_length": 425,
      "index": 915,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Booleans.S-Env",
      "library": "libzipperposition.calculi",
      "description": "This module provides operations for clause manipulation, inference rule application, and proof state management in a saturation-based theorem prover. It works with logical clauses, literals, proof states, clause sets, and trails, supporting transformations like rewriting, normalization, and redundancy elimination. Key use cases include tautology detection, prioritized rule application, predicate elimination, and event-driven processing via signals to track clause simplification and inference steps.",
      "description_length": 503,
      "index": 916,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Bce_pe_fixpoint.S-Env-ProofState-SimplSet",
      "library": "libzipperposition.calculi",
      "description": "This module manages a set of clauses with operations to add or remove clauses and trigger signals on these changes. It works with clause data types and iterators over clauses. It is used to maintain and modify a collection of clauses with event notifications for additions and removals.",
      "description_length": 286,
      "index": 917,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Hlt_elim.S-Env-ProofState-CQueue-PriorityFun",
      "library": "libzipperposition.calculi",
      "description": "This module defines a priority function type for ordering clauses in a proof state's clause queue. It includes a function to parse string descriptions into concrete priority functions that map clauses to integer weights. This enables dynamic configuration of clause selection strategies in automated theorem proving processes.",
      "description_length": 326,
      "index": 918,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Lazy_cnf.S-Env-ProofState-TermIndex-Leaf",
      "library": "libzipperposition.calculi",
      "description": "This module implements a term index structure for efficient retrieval of terms during theorem proving, specifically supporting operations like adding, removing, and updating indexed terms along with their associated values. It works with terms from the `Logtk.Index_intf` module and elements of the `Env.ProofState.TermIndex.Leaf` type, enabling precise term manipulation and retrieval. It is used in clause normalization and resolution-based reasoning where fast access to matching or unifiable terms is critical.",
      "description_length": 514,
      "index": 919,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Heuristics.S-Env-ProofState-UnitIndex",
      "library": "libzipperposition.calculi",
      "description": "This module implements an index for managing and querying a collection of logical (in)equations, supporting operations like adding, removing, and retrieving terms with substitution-based matching. It works with terms and substitutions from a logical environment, enabling efficient lookups for theorem proving tasks. Use cases include indexing clauses during proof search and finding applicable rewrite rules or lemmas during automated reasoning.",
      "description_length": 446,
      "index": 920,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Superposition_intf.S-C-Seq",
      "library": "libzipperposition.calculi",
      "description": "This module provides functions to extract literals, terms, and variables from clauses. It operates on clause data structures (`C.t`) and iterates over literals, terms, and typed variables. Useful for analyzing or transforming logical clauses during theorem proving or term rewriting tasks.",
      "description_length": 289,
      "index": 921,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Bce.S-Env-ProofState-CQueue-PriorityFun",
      "library": "libzipperposition.calculi",
      "description": "This module defines a priority function type used to assign integer weights to elements in a proof state queue, guiding their processing order. It includes a function to parse string descriptions into these priority functions. This enables customizable prioritization strategies for proof state exploration based on dynamic or heuristic criteria.",
      "description_length": 346,
      "index": 922,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Hlt_elim.S-Env-C-Tbl",
      "library": "libzipperposition.calculi",
      "description": "This module implements hash tables that map keys of type `Env.C.Tbl.key` to arbitrary values, offering operations for safe retrieval, in-place updates, and bulk modifications with customizable merge strategies for duplicate keys. It supports advanced workflows like atomic updates, lazy value insertion, and statistics aggregation through iteration, counting, and sequence-based initialization. Typical applications include managing mutable environments with complex key semantics, handling conflict resolution during data ingestion, and maintaining dynamic counters or caches with efficient update mechanisms.",
      "description_length": 610,
      "index": 923,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Qle.S-Env-ProofState-module-type-CLAUSE_SET",
      "library": "libzipperposition.calculi",
      "description": "This module manages a dynamic set of clauses with operations to add or remove clauses and attach event handlers for changes. It provides signals triggered on clause insertion or removal and processes clause updates through iterable sequences. It is used in theorem proving contexts to track and react to modifications in clause sets during proof search.",
      "description_length": 353,
      "index": 924,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Booleans.S-Env-ProofState",
      "library": "libzipperposition.calculi",
      "description": "Manages clause queues and indexing structures for efficient clause retrieval and manipulation. It supports operations for scheduling clauses during proof search, indexing terms and units for fast lookup, and maintaining sets of active, simplified, and passive clauses. Use cases include optimizing resolution-based theorem proving by managing clause selection and subsumption checks.",
      "description_length": 383,
      "index": 925,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Superposition_intf.S-PS-TermIndex",
      "library": "libzipperposition.calculi",
      "description": "The module provides operations for managing a term index optimized for first-order logic manipulations, supporting efficient insertion, removal, and retrieval of terms annotated with positional data. It implements specialized indexed access patterns for unification with substitution, generalization, and scoped queries over a data structure mapping terms to `elt` values. This structure is particularly useful in theorem proving or term rewriting systems where precise term relationships and positional metadata are critical, with additional debugging support through DOT visualization of the index's internal state.",
      "description_length": 617,
      "index": 926,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "Libzipperposition_calculi.Qle.S",
      "library": "libzipperposition.calculi",
      "description": "This module implements term ordering and simplification routines for first-order logic terms, focusing on handling inequalities and equalities during automated reasoning. It operates on term and formula data structures, providing functions to normalize expressions and compare terms based on a built-in ordering. Concrete use cases include clause simplification and redundancy elimination in theorem proving tasks.",
      "description_length": 414,
      "index": 927,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Qle.S-Env-Ctx",
      "library": "libzipperposition.calculi",
      "description": "This module provides operations for configuring and querying logical contexts, including managing term orderings, selection functions, skolemization parameters, and symbol declarations. It works with terms, types, and signatures to support advanced logical reasoning tasks like term analysis and symbol property tracking. Specific capabilities include determining injectivity of function symbols in argument positions, which is critical for term rewriting and unification in theorem proving workflows.",
      "description_length": 501,
      "index": 928,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Heuristics.S-Env-ProofState-TermIndex-Leaf",
      "library": "libzipperposition.calculi",
      "description": "This module implements a term index structure for efficient retrieval of terms during automated reasoning tasks. It supports operations to add, remove, and update indexed terms, as well as to perform unification and matching queries over scoped terms. The module is used to accelerate proof search by enabling fast access to potentially relevant terms based on structural similarity or substitution compatibility.",
      "description_length": 413,
      "index": 929,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Superposition_intf.S-PS-UnitIndex-E",
      "library": "libzipperposition.calculi",
      "description": "This module represents and compares indexed equations and inequations, providing a total order via `compare`, extraction of term components with `extract`, and a heuristic utility measure through `priority`. It operates on pairs of terms combined with a boolean flag and an additional value of type `C.t`, representing logical equations or inequations. It is used to manage and prioritize equations during theorem proving, particularly in superposition-based reasoning.",
      "description_length": 469,
      "index": 930,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Higher_order.S-Env-Stm",
      "library": "libzipperposition.calculi",
      "description": "This module manages streams of clauses with associated metadata, supporting operations like creation, comparison, and incremental extraction. It works with streams of optional clauses (`C.t option OSeq.t`), tracking penalties, hits, and parent clauses. Concrete use cases include managing inference streams in theorem proving, where streams are incrementally processed and prioritized based on heuristic penalties.",
      "description_length": 414,
      "index": 931,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Hlt_elim.S-C",
      "library": "libzipperposition.calculi",
      "description": "This module enables detailed clause manipulation and analysis in automated reasoning tasks. It offers operations to inspect and modify clause properties like redundancy and goal status, manage trails and proofs, determine literal eligibility for inference rules, and transform clauses through substitutions or format conversions. It primarily works with clauses (`C.t`), trails (`Trail.t`), proof steps, and substitutions, supporting use cases such as redundancy checks, inference control in resolution and paramodulation, and generating TSTP output.",
      "description_length": 550,
      "index": 932,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Superposition_intf.S-Env-ProofState-CQueue-C",
      "library": "libzipperposition.calculi",
      "description": "This module provides functionality for clause manipulation, analysis, and transformation in a superposition calculus, including redundancy checks, proof trail tracking, and inference eligibility determination via substitutions and bitvector-based literal selection. It operates on clause structures (`C.t`) and clause sets (`ClauseSet.t`), supporting operations like clause creation from literals, equality reasoning, paramodulation eligibility checks, and ground clause generation. These capabilities are essential for automated theorem proving tasks such as proof state management, simplification ordering enforcement, and TSTP-formatted debugging output.",
      "description_length": 657,
      "index": 933,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Pred_elim.S-Env-ProofState-SubsumptionIndex",
      "library": "libzipperposition.calculi",
      "description": "This module implements a subsumption index for managing and querying clauses in a proof state. It supports operations to add, remove, and retrieve clauses based on subsumption and alpha-equivalence relations, using literals and labels as keys. Use cases include efficient clause indexing and retrieval during automated theorem proving, particularly for subsumption and redundancy checks.",
      "description_length": 387,
      "index": 934,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Hlt_elim.S-Env-ProofState-UnitIndex",
      "library": "libzipperposition.calculi",
      "description": "This module implements a term index for efficiently storing, retrieving, and manipulating sets of (in)equations during theorem proving. It supports operations like adding or removing equations, querying for matches or generalizations of a given term under substitutions, and iterating over indexed terms. Use cases include clause indexing in resolution provers and efficient subsumption/simplification checks during proof search.",
      "description_length": 429,
      "index": 935,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Higher_order.S-Env-ProofState-CQueue",
      "library": "libzipperposition.calculi",
      "description": "This module supports operations for managing priority queues of clauses, including insertion, priority-based retrieval, and membership queries, while integrating weight and priority functions to govern clause ordering. It operates on structured proof states containing passive clause sets, enabling use cases such as heuristic-driven theorem proving, goal-oriented clause prioritization, and efficient management of dynamically updated clause databases with customizable strategies like FIFO or heuristic-based scheduling.",
      "description_length": 522,
      "index": 936,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Booleans.S-Env-ProofState-UnitIndex-E",
      "library": "libzipperposition.calculi",
      "description": "This module defines and compares indexed equations, working with terms and clauses from the Logtk library. It provides operations to extract components of equations and determine their priority for use in theorem proving. Concrete use cases include managing equalities and inequalities during clause processing in automated reasoning systems.",
      "description_length": 342,
      "index": 937,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Qle.S-Env-ProofState-ActiveSet",
      "library": "libzipperposition.calculi",
      "description": "This module manages a dynamic set of clauses with signals for additions and removals. It provides operations to add or remove multiple clauses, retrieve the current set, and count clauses. Useful for tracking clause changes in a proof state, such as during theorem proving or constraint solving.",
      "description_length": 295,
      "index": 938,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Qle.S-Env-FormRename",
      "library": "libzipperposition.calculi",
      "description": "Handles formula renaming and Skolemization during proof search. It provides operations to rename formulas, introduce predicate Skolem symbols, and manage renaming clauses, working with terms, clauses, and formula renaming contexts. Used to generate fresh Skolems or reuse existing ones based on context and polarity, supporting precise formula manipulation in theorem proving.",
      "description_length": 376,
      "index": 939,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Hlt_elim.S-Env-C-ClauseSet",
      "library": "libzipperposition.calculi",
      "description": "This module implements an ordered set structure for managing collections of logical clauses, supporting set-theoretic operations like union, intersection, and difference alongside ordered traversals, element selection (min/max), and predicate-based filtering. It works with totally ordered clause sets using comparison functions to maintain structure, enabling transformations to lists/sequences and safe access patterns via option-returning variants. Typical applications include clause management in automated reasoning systems where ordered set manipulation, iterative processing, and conditional element extraction are required for tasks like formula simplification or proof search.",
      "description_length": 686,
      "index": 940,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.EnumTypes.S-Env-C-ClauseSet",
      "library": "libzipperposition.calculi",
      "description": "The module provides operations for managing ordered sets of clauses, including membership checks, insertion, deletion, union, intersection, and difference, alongside iteration, mapping, and folding. It works with `Env.C.ClauseSet.t` structures, which are ordered using a comparator, enabling efficient predicate-based filtering, safe traversal, and conversion to lists or sequences. These capabilities are particularly useful in logical reasoning tasks requiring precise manipulation of clause sets, such as automated theorem proving or constraint solving.",
      "description_length": 556,
      "index": 941,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Bce.S-Env-C-Seq",
      "library": "libzipperposition.calculi",
      "description": "This module provides functions to extract literals, terms, and variables from a clause environment. It operates on clause structures using iterators to traverse their components. Use it to analyze or manipulate logical clauses by accessing their constituent literals, terms, or typed variables directly.",
      "description_length": 303,
      "index": 942,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Pred_elim.S-Env-FormRename-Ctx",
      "library": "libzipperposition.calculi",
      "description": "This module provides operations for skolemization, term ordering, symbol declaration, and injectivity analysis in first-order logic theorem proving. It manages logical contexts, signatures with dynamic symbol updates, and clause-based reasoning through data structures like terms, literals, and function symbols. These capabilities support critical tasks such as clause processing, inference rule application, and equality reasoning in automated deduction systems.",
      "description_length": 464,
      "index": 943,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Superposition_intf.S-Env-ProofState-UnitIndex",
      "library": "libzipperposition.calculi",
      "description": "This module implements an index for managing and querying a set of (in)equations during automated theorem proving. It supports operations to add, remove, and iterate over indexed equations, as well as efficient retrieval of matching or generalizing terms with optional substitutions. The index is used to accelerate clause lookups and inference steps in superposition-based provers by structuring (in)equations for fast access.",
      "description_length": 427,
      "index": 944,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Bce.S-Env-ProofState-UnitIndex-E",
      "library": "libzipperposition.calculi",
      "description": "This module represents and compares indexed equations or inequations with their associated terms and priority. It provides operations to extract components of an equation and determine its usefulness. Concrete use cases include managing and prioritizing equations during theorem proving or term rewriting processes.",
      "description_length": 315,
      "index": 945,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Booleans.S-C-Pos",
      "library": "libzipperposition.calculi",
      "description": "This module provides a function `at` that retrieves a subterm at a specified position within a logical term. It operates on terms and positions from the `Logtk` library, specifically interacting with the `C.t` type representing logical clauses. A typical use case involves extracting specific subterms during proof search or term analysis in automated theorem proving.",
      "description_length": 368,
      "index": 946,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Hlt_elim.S-Env-ProofState-module-type-CLAUSE_SET",
      "library": "libzipperposition.calculi",
      "description": "This module manages a dynamic set of clauses with operations to add or remove clauses and subscribe to events when clauses are added or removed. It works with clause sets and supports iterative collections of clauses. It is used in theorem proving contexts to track and react to changes in clause sets during proof search.",
      "description_length": 322,
      "index": 947,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Heuristics.S-PS-CQueue-C",
      "library": "libzipperposition.calculi",
      "description": "The module centers on analyzing and modifying boolean flags, trails, and proof structures associated with clauses in automated reasoning systems, supporting operations like redundancy checks, simplification, and goal-oriented analysis. It works with clause data structures to enable resolution, paramodulation, and literal selection by evaluating structural properties, metadata, and eligibility criteria. Additional functionality includes transforming clauses through substitution, grounding, and conversion to logical forms, alongside generating debug-friendly representations for TSTP output and interactive workflows.",
      "description_length": 621,
      "index": 948,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Bce.S-Env-ProofState-CQueue-WeightFun",
      "library": "libzipperposition.calculi",
      "description": "This module defines weight functions that assign integer weights to clauses in a proof state's clause queue. It supports operations like parsing weight function descriptions, combining multiple weight functions with coefficients, and applying heuristics such as favoring ground or Horn clauses, penalizing non-goal proximity, and prioritizing clauses based on literal properties. These functions guide clause selection during automated theorem proving by influencing the priority of clauses in the queue.",
      "description_length": 504,
      "index": 949,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Higher_order.S-Env-C-Eligible",
      "library": "libzipperposition.calculi",
      "description": "This module defines eligibility criteria for selecting literals in a clause based on logical operations and properties such as positivity, negativity, maximality, and equation status. It provides functions to filter literals for resolution, paramodulation, and equation handling, and supports combining criteria using logical operators (and, or, not). These operations are used to control inference rules in automated theorem proving by determining which literals can participate in specific proof steps.",
      "description_length": 504,
      "index": 950,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Heuristics.S-PS-TermIndex-Leaf",
      "library": "libzipperposition.calculi",
      "description": "This module implements a term index structure for efficient retrieval of terms based on unification and matching operations. It supports adding, removing, and updating indexed elements, as well as iterating and folding over indexed terms and their associated values. It is used in theorem proving and term rewriting systems to quickly find applicable rules or clauses during proof search.",
      "description_length": 388,
      "index": 951,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Bce.Make",
      "library": "libzipperposition.calculi",
      "description": "This module implements a fixpoint computation engine for a custom equality type provided by the `E` module. It supports setup, iteration, and teardown of fixpoint calculations, with an optional mode flag to control behavior during fixed-point detection. Concrete use cases include solving constraint systems or propagating equalities in a theorem-proving or symbolic reasoning context.",
      "description_length": 385,
      "index": 952,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Higher_order.S-Env-Ctx-Lit",
      "library": "libzipperposition.calculi",
      "description": "This module manages bidirectional conversions between literals and formulas in a higher-order logic context. It provides hooks to customize conversion behavior, supporting atomic formulas during transformation. Concrete use cases include integrating custom literal representations with theorem proving procedures that require term-level manipulation.",
      "description_length": 350,
      "index": 953,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Bce_pe_fixpoint.S-Env-C",
      "library": "libzipperposition.calculi",
      "description": "This module offers operations for clause manipulation, analysis, and transformation in automated reasoning systems, focusing on tasks like flag management (redundancy, simplification status), proof extraction, eligibility checks for inference rules, and clause normalization. It operates on clauses (`Env.C.t`), substitutions, and bitvectors, with structured access to literals, metadata (weight, depth, penalty), and positional information via submodules like `Pos` and `Eligible`. Use cases include saturation-based theorem proving, where clauses are processed for logical inference, trail management, and goal-directed transformations in formats like TSTP.",
      "description_length": 659,
      "index": 954,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Lazy_cnf.S-Env-C-WithPos",
      "library": "libzipperposition.calculi",
      "description": "This module represents clauses with a specific subterm and its position, enabling precise manipulation and analysis of terms within clauses. It provides comparison and pretty-printing operations for these structured clauses. Use cases include tracking term positions during proof search or clause transformation in automated theorem proving.",
      "description_length": 341,
      "index": 955,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.EnumTypes.S-Env-ProofState-CQueue",
      "library": "libzipperposition.calculi",
      "description": "This component provides priority queue operations for managing and prioritizing clauses during theorem proving, including insertion, extraction, membership checks, and strategy-driven traversal orders (e.g., FIFO, goal-oriented, heuristic-based). It operates on clause queues parameterized by weighting and priority functions, supporting proof state interactions like passive set management and configurable clause selection. Use cases include optimizing proof search efficiency through prioritization strategies and debugging via queue inspection and string serialization.",
      "description_length": 573,
      "index": 956,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Heuristics.S-C",
      "library": "libzipperposition.calculi",
      "description": "This module type provides operations for managing clause metadata, structural analysis, and proof manipulation in automated reasoning. It works with clauses, substitutions, clause sets, and bitvectors, offering utilities for eligibility checks, literal selection, and heuristic-driven inference. Specific use cases include clause simplification, goal derivation tracking, and positional analysis for resolution-based theorem proving.",
      "description_length": 433,
      "index": 957,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Pred_elim.S-Env-ProofState-ActiveSet",
      "library": "libzipperposition.calculi",
      "description": "This module manages a dynamic set of clauses with support for adding, removing, and querying clauses. It provides signals for tracking clause additions and removals, along with functions to retrieve the current clause set and its size. It is used in theorem proving contexts to maintain and monitor the active clause set during proof search.",
      "description_length": 341,
      "index": 958,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Hlt_elim.S-Env-C-Pos",
      "library": "libzipperposition.calculi",
      "description": "This module provides a function `at` that retrieves a term from a specific position in an environment. It operates on environments (`Env.C.t`) and positions (`Logtk.Position.t`), returning the corresponding term (`Logtk.Term.t`). A concrete use case is querying structured term data during theorem proving or term rewriting tasks.",
      "description_length": 330,
      "index": 959,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Higher_order.S",
      "library": "libzipperposition.calculi",
      "description": "This module implements higher-order calculus operations for term enumeration and transformation, working with term and clause data structures. It provides concrete functions like `setup` to register inference rules and `prim_enum_tf` to generate transformed clauses from a given clause. Use cases include higher-order term normalization and clause set expansion in automated theorem proving.",
      "description_length": 391,
      "index": 960,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Bce.S-Env-FormRename",
      "library": "libzipperposition.calculi",
      "description": "This module handles formula renaming and Skolemization during proof search. It provides operations to detect renaming clauses, introduce predicate Skolem symbols, and rename formulas based on context and polarity. Key data structures include clauses and term-level representations of formulas, used in transformations and simplifications during automated reasoning.",
      "description_length": 365,
      "index": 961,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Lazy_cnf.S-C-Eligible",
      "library": "libzipperposition.calculi",
      "description": "This module defines eligibility criteria for selecting literals in clausal reasoning, using a function type that determines whether a literal at a given position in a clause is eligible. It provides operations to construct and combine eligibility predicates, such as selecting literals based on positivity, negativity, being equations, or maximal in a clause, as well as logical combinations of these conditions. These criteria are used to control inference rules like resolution and paramodulation by restricting them to specific subsets of literals.",
      "description_length": 551,
      "index": 962,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Higher_order.S-Env-C-Tbl",
      "library": "libzipperposition.calculi",
      "description": "This module type provides core operations for managing hash tables that map environment-structured keys to arbitrary values, emphasizing safe value retrieval, in-place updates, and bulk transformations. It supports iteration, aggregation, and merging strategies for handling duplicates, while enabling conversions between tables, lists, and sequences. Key use cases include counting elements from iterators, merging key-value pairs with custom logic, and serializing tables for debugging or data exchange.",
      "description_length": 505,
      "index": 963,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Libzipperposition_calculi.Pred_elim.S-Env-ProofState-TermIndex-Leaf",
      "library": "libzipperposition.calculi",
      "description": "This module implements a term index structure for efficient retrieval of terms during automated reasoning tasks. It supports operations to add, remove, and update indexed terms, as well as to perform unification and matching queries over scoped terms. The index is used to accelerate proof search by enabling fast access to potentially matching terms based on structural and substitutional properties.",
      "description_length": 401,
      "index": 964,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Booleans.S-Env-ProofState-SimplSet",
      "library": "libzipperposition.calculi",
      "description": "This module manages a set of clauses with operations to add or remove clauses and notify listeners of changes. It uses signals to trigger actions when clauses are added or removed, supporting dynamic tracking of clause modifications. Concrete use cases include maintaining a clause database during theorem proving where incremental updates must be observed and processed.",
      "description_length": 371,
      "index": 965,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Heuristics.S-Env-FormRename",
      "library": "libzipperposition.calculi",
      "description": "This module implements formula renaming and Skolem management during proof search. It provides operations to detect renaming clauses, introduce predicate Skolem symbols, and rename formulas based on definitional control. Key data structures include clauses and formula renaming contexts, used to track and apply renamings during saturation-based reasoning.",
      "description_length": 356,
      "index": 966,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Qle.S-Env-C-Seq",
      "library": "libzipperposition.calculi",
      "description": "This module provides functions to extract literals, terms, and variables from a clause environment. It operates on clause structures using the `Env.C.t` type, which represents logical clauses in a theorem proving context. Concrete use cases include analyzing or transforming clauses during automated reasoning tasks such as resolution or simplification.",
      "description_length": 353,
      "index": 967,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Hlt_elim.S-Env-Ctx",
      "library": "libzipperposition.calculi",
      "description": "This module manages logical context and state for theorem proving, offering operations to manipulate term orderings, injectivity constraints, and skolemization contexts while tracking symbol declarations and signature changes. It works with logical terms, literals, and signatures to enforce properties like function argument injectivity and term comparisons, supporting tasks such as completeness-preserving proof search and formal verification. Key use cases include automated reasoning with equality constraints and managing dynamic symbol dependencies during proof construction.",
      "description_length": 582,
      "index": 968,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.EnumTypes.S-Env-C-WithPos",
      "library": "libzipperposition.calculi",
      "description": "Represents a clause with a specific subterm and its position within the term structure. It includes operations to compare and pretty-print these structured values. Useful for tracking term positions during proof search or term rewriting processes.",
      "description_length": 247,
      "index": 969,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Fool.S-Env-FormRename-Ctx-Lit",
      "library": "libzipperposition.calculi",
      "description": "This module provides functions to convert between literals and their atomic formula representations, using customizable hooks for preprocessing and postprocessing. It operates on literals and terms from the Logtk library, specifically handling atomic formulas during the conversion. Use cases include integrating custom logic during literal-to-formula transformations, such as normalization or syntax adjustments in theorem proving contexts.",
      "description_length": 441,
      "index": 970,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Pred_elim.S-Env-Ctx",
      "library": "libzipperposition.calculi",
      "description": "This module supports logical context management and term manipulation in automated reasoning systems, operating on data structures such as literals, terms, symbols, and signatures. It provides capabilities for controlling function argument injectivity, maintaining term orderings, and handling skolemization, which are critical for resolution-based theorem proving and completeness-preserving transformations. The `Lit` module enables efficient literal comparison and term extraction, facilitating operations like clause normalization and subsumption checking in formal verification workflows.",
      "description_length": 593,
      "index": 971,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Pred_elim.S",
      "library": "libzipperposition.calculi",
      "description": "This module implements predicate elimination procedures for first-order logic, providing operations to initialize and control a fixpoint computation. It includes functions to set up the elimination process, perform individual fixpoint steps, and finalize the computation, all operating within an environment managing logical variables and constraints. It is used in automated theorem proving to simplify formulas by removing existential quantifiers while preserving satisfiability.",
      "description_length": 481,
      "index": 972,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.EnumTypes.S",
      "library": "libzipperposition.calculi",
      "description": "This module handles declarations and instantiation of enumerated types. It allows defining a type's domain as a finite set of values, using `declare_ty` to specify the valid cases for a type, and `instantiate_vars` to generate all possible values for variables of such types. It works directly with type declarations, terms, and variables from the Logtk library, and is used to reason about and manipulate enumerated domains during proof search.",
      "description_length": 445,
      "index": 973,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Superposition_intf.S-Env-Stm",
      "library": "libzipperposition.calculi",
      "description": "This module manages streams of clauses with associated metadata, supporting operations like creation, comparison, and incremental extraction. It works with streams of optional clauses (`C.t option OSeq.t`), tracking penalties, hits, and parent clauses for each stream. Concrete use cases include managing inference results in theorem proving, where streams represent sequences of derived clauses, and metadata guides heuristic decisions during proof search.",
      "description_length": 457,
      "index": 974,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Heuristics.S",
      "library": "libzipperposition.calculi",
      "description": "This module implements heuristic strategies for clause selection and processing in automated theorem proving. It operates on clauses and proof states through the `C` and `PS` submodules, integrating with the environment via `Env` to guide search behavior. Concrete use cases include prioritizing clauses during resolution and managing proof state transformations based on heuristic rules.",
      "description_length": 388,
      "index": 975,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Higher_order.S-Env-StmQ-WeightFun",
      "library": "libzipperposition.calculi",
      "description": "This module defines weight functions that assign integer weights to streams of statements. It provides operations to retrieve a stream's penalty and combine multiple weighted functions into a single function. These functions are used to prioritize or evaluate the complexity of statement streams in proof search or theorem proving contexts.",
      "description_length": 340,
      "index": 976,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Lazy_cnf.S-Env-C",
      "library": "libzipperposition.calculi",
      "description": "This module provides operations for managing clause properties (e.g., redundancy, groundness, goal status), transforming clauses in CNF form (conversion, substitution application, symbol extraction), and manipulating trails and proofs (inspection, modification, extraction). It operates on clauses (`Env.C.t`), trails (`Trail.t`), substitutions (`Logtk.Subst.t`), and proof structures, supporting tasks like resolution/paramodulation eligibility checks, proof analysis, and clause debugging via TSTP formatting. Key use cases include logical inference step tracking, clause simplification in theorem proving, and proof derivation validation.",
      "description_length": 641,
      "index": 977,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Superposition_intf.S-C-Eligible",
      "library": "libzipperposition.calculi",
      "description": "This module defines eligibility criteria for selecting literals in superposition-based theorem proving. It provides functions to filter literals based on their role in resolution, paramodulation, sign, maximality, and equation status, as well as logical combinations of these conditions. Use cases include controlling inference rule application and implementing literal selection strategies in automated reasoning systems.",
      "description_length": 422,
      "index": 978,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Bce.S-Env-ProofState-CQueue",
      "library": "libzipperposition.calculi",
      "description": "This module supports operations for managing a priority queue of clauses, including insertion, retrieval, and iteration using strategies like FIFO, goal-oriented selection, or heuristic prioritization. It works with `Env.ProofState.CQueue.t` structures to organize clauses of type `Env.ProofState.CQueue.C.t`, enabling dynamic configuration of prioritization via weight and priority functions. It is particularly useful in proof search scenarios where clause selection must adapt to evolving proof states, such as optimizing resolution order or debugging queue contents through string representations.",
      "description_length": 601,
      "index": 979,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Bce.S-Env-ProofState-UnitIndex",
      "library": "libzipperposition.calculi",
      "description": "This module implements a term index for efficiently storing, retrieving, and manipulating sets of (in)equations during automated reasoning tasks. It supports operations like adding or removing individual or batches of equations, querying for matching or generalizing terms with optional substitution constraints, and inspecting the structure of the index. The index is particularly useful in theorem proving contexts where fast access to relevant clauses is needed during proof search.",
      "description_length": 485,
      "index": 980,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Higher_order.S-Env-FormRename-Ctx-Lit",
      "library": "libzipperposition.calculi",
      "description": "This module manages bidirectional conversions between literals and formulas in a higher-order logic context. It provides functions to register and retrieve conversion hooks for transforming literals to formulas and vice versa, ensuring atomicity constraints are enforced during the conversion process. Use cases include integrating custom literal representations with theorem proving procedures that require strict formula-level manipulation.",
      "description_length": 442,
      "index": 981,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Booleans.S-Env-Ctx-Lit",
      "library": "libzipperposition.calculi",
      "description": "This module manages bidirectional conversions between literals and formulas in a logical context. It provides hooks to customize conversion behavior, supporting integration with different logic frameworks. Key operations include `of_form` and `to_form`, which convert between atomic formulas and literals, enabling use in theorem proving or SMT solver pipelines.",
      "description_length": 362,
      "index": 982,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Hlt_elim.S-Env-ProofState-PassiveSet",
      "library": "libzipperposition.calculi",
      "description": "This module manages a passive clause set with dynamic addition and removal, supporting incremental updates and real-time monitoring through signals. It provides direct access to the current clause set, checks clause status, and processes clauses in sequence via a queue. Concrete use cases include managing passive clauses during theorem proving, enabling reactive updates to clause state, and coordinating clause processing in automated reasoning systems.",
      "description_length": 456,
      "index": 983,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Lazy_cnf.S-Env-ProofState-CQueue-WeightFun",
      "library": "libzipperposition.calculi",
      "description": "This module defines weight functions that assign integer weights to clauses in a proof state's priority queue. It supports operations like parsing weight function descriptions, combining multiple weight functions with coefficients, and applying heuristic-based weighting strategies. Use cases include guiding clause selection during automated theorem proving by prioritizing clauses based on properties like goal proximity, Horn structure, or groundness.",
      "description_length": 454,
      "index": 984,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Bce.S-Env-FormRename-Ctx-Lit",
      "library": "libzipperposition.calculi",
      "description": "This module provides functions to convert between literals and formulas, specifically handling atomic formulas. It maintains lists of conversion hooks for customizing transformations to and from literals. Use cases include integrating literal-level operations with higher-level formula manipulations in theorem proving or term rewriting systems.",
      "description_length": 345,
      "index": 985,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Heuristics.S-Env-Ctx",
      "library": "libzipperposition.calculi",
      "description": "This module provides operations for managing logical context and signature state in automated reasoning systems, focusing on term ordering, symbol type declarations, and skolemization context handling. It works with logical literals (via the Lit module), symbols, and term comparisons to support tasks like heuristic-driven term simplification and injectivity-based ordering optimizations. Specific use cases include maintaining dynamic logical environments during theorem proving and implementing selection function strategies that influence proof search efficiency.",
      "description_length": 567,
      "index": 986,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Bce_pe_fixpoint.S-Env-Ctx-Lit",
      "library": "libzipperposition.calculi",
      "description": "This module manages bidirectional conversions between atomic formulas and literals, providing hooks to customize the transformation logic. It operates on terms and literals from the Logtk library, specifically handling atomic formulas as input for conversion. Use cases include integrating custom logic during literal-to-formula transformations in theorem proving or term processing pipelines.",
      "description_length": 393,
      "index": 987,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.MyHeap.Make",
      "library": "libzipperposition.calculi",
      "description": "Implements a mutable heap data structure using a vector, supporting efficient insertion, removal of the minimum element, and priority adjustments. It provides core operations like `insert`, `remove_min`, `decrease`, and `increase`, maintaining heap invariants through `percolate_up` and `percolate_down`. This structure is ideal for priority queue implementations and Dijkstra-like algorithms where dynamic priority updates are required.",
      "description_length": 437,
      "index": 988,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Bce_pe_fixpoint.S-Env-StmQ-WeightFun",
      "library": "libzipperposition.calculi",
      "description": "This module defines weight functions that assign integer weights to streams of statements. It provides operations to retrieve a stream's penalty and combine multiple weighted functions into a single function through a weighted sum. These functions are used to prioritize or evaluate streams based on customizable weighting schemes.",
      "description_length": 331,
      "index": 989,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.EnumTypes.S-Env-C-Pos",
      "library": "libzipperposition.calculi",
      "description": "This module provides a single operation, `at`, which retrieves a term from a given position in an environment. It works with environments (`Env.C.t`) and logical terms (`Logtk.Term.t`) indexed by positions (`Logtk.Position.t`). A concrete use case is querying specific subterms during proof search or term traversal in automated reasoning tasks.",
      "description_length": 345,
      "index": 990,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Lazy_cnf.S-Env-FormRename-Ctx",
      "library": "libzipperposition.calculi",
      "description": "This module provides operations for logical context manipulation, including skolemization, term ordering, and symbol declaration, while also supporting CNF conversion through clausification logic and injectivity checks for function symbols. It works with terms, types, signatures, and logical literals (via the `Lit` module), organizing data into clauses and contexts for automated reasoning. These capabilities are specifically used in theorem proving to manage symbolic representations and optimize normal form transformations.",
      "description_length": 529,
      "index": 991,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Superposition_intf.S-Env-C-Eligible",
      "library": "libzipperposition.calculi",
      "description": "This module defines eligibility criteria for selecting literals in superposition-based theorem proving. It provides operations to filter literals based on their role in resolution, paramodulation, positivity, negativity, and maximality, as well as logical combinations of these conditions. Use cases include controlling inference rules in automated reasoning engines by specifying which literals can participate in specific proof steps.",
      "description_length": 436,
      "index": 992,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Fool.S-Env-C-Pos",
      "library": "libzipperposition.calculi",
      "description": "This module provides a function `at` that retrieves a term from a given position in an environment. It operates on environments (`Env.C.t`) and positions (`Logtk.Position.t`), returning terms (`Logtk.Term.t`). A concrete use case is querying specific subterms during theorem proving or term rewriting tasks.",
      "description_length": 307,
      "index": 993,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Heuristics.S-Env-C-Tbl",
      "library": "libzipperposition.calculi",
      "description": "This module provides hash table operations for key-value stores with keys of type `Env.C.t`, supporting safe insertion, retrieval, and transformation of values with customizable conflict resolution. It includes utilities for frequency counting, bulk updates from sequences or lists, and structured iteration, with specialized functions for handling integer-valued counters and customizable printing. Typical use cases involve tracking term frequencies in symbolic data, aggregating statistics from iterative processes, or managing environment mappings with merge strategies for duplicate keys.",
      "description_length": 593,
      "index": 994,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Lazy_cnf.S-Env-ProofState",
      "library": "libzipperposition.calculi",
      "description": "This module manages the core components of a saturation-based theorem prover. It provides clause management through priority queues, indexing structures for efficient retrieval, and set implementations for active, simplified, and passive clauses. Use cases include clause selection, redundancy checking, and maintaining proof state statistics during automated reasoning tasks.",
      "description_length": 376,
      "index": 995,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Pred_elim.S-Env-ProofState-SimplSet",
      "library": "libzipperposition.calculi",
      "description": "This module manages a dynamic set of clauses with operations to add or remove clauses and notify subscribers of changes. It uses iterators to process multiple clauses and provides signals to react to additions or removals. It is used in automated theorem proving to maintain and modify clause sets during proof search.",
      "description_length": 318,
      "index": 996,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Lazy_cnf.S-C-Tbl",
      "library": "libzipperposition.calculi",
      "description": "This module provides imperative hash table operations for efficient key-value management, bulk updates with customizable merge strategies, and atomic counter manipulations over keys of type `C.t`. It operates on polymorphic hash tables (`'a C.Tbl.t`) with support for iterators, sequences, and functional transformations, enabling use cases like term indexing, clause management, and dynamic data aggregation where structured key-value updates or duplicate key resolution are required. Core functionality includes safe value retrieval, list appending, count tracking, and conversions between collections, all emphasizing performance-critical workflows in formal verification or symbolic computation contexts.",
      "description_length": 708,
      "index": 997,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Heuristics.S-Env-ProofState-CQueue-WeightFun",
      "library": "libzipperposition.calculi",
      "description": "This module defines weight functions that compute integer weights for clauses in a proof state's priority queue. It supports operations to parse weight functions from strings, combine multiple weight functions linearly, and apply heuristic-based weighting such as favoring ground or Horn clauses, penalizing non-goal-related clauses, or prioritizing clauses based on their relation to the initial goal. These functions are used to guide the selection of clauses during automated theorem proving by influencing the priority queue's ordering.",
      "description_length": 540,
      "index": 998,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Superposition_intf.S-Env-FormRename-Ctx",
      "library": "libzipperposition.calculi",
      "description": "This module manages logical context operations for theorem proving, including skolemization, term ordering, selection function application, and signature manipulation. It operates on terms, types, and symbols using data structures like orderings, substitutions, and logical literals, with specialized checks for function symbol injectivity. These capabilities support superposition calculus tasks such as symbol management, term normalization, and inference rule execution during automated reasoning.",
      "description_length": 500,
      "index": 999,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Superposition_intf.S-Env-ProofState-TermIndex-Leaf",
      "library": "libzipperposition.calculi",
      "description": "This module implements a term index structure that supports efficient insertion, removal, and querying of logical terms in a proof state context. It provides operations for unification and matching between indexed terms and query terms, returning substitutions that make the terms equivalent. It is used in automated theorem proving to find clauses that can be resolved or simplified based on term relationships.",
      "description_length": 412,
      "index": 1000,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Lazy_cnf.S-Env-StmQ-WeightFun",
      "library": "libzipperposition.calculi",
      "description": "This module defines weight functions that assign integer weights to streams of statements. It provides operations to retrieve a penalty value for a stream and to combine multiple weighted functions into a single function using a weighted sum. These functions are used to prioritize or evaluate the importance of different statement streams in a formal logic or theorem proving context.",
      "description_length": 385,
      "index": 1001,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Superposition_intf.S-Env-StmQ",
      "library": "libzipperposition.calculi",
      "description": "This module implements a priority queue for managing streams of clauses in a theorem proving context. It provides operations to add streams or lists of streams to the queue, retrieve clauses with various fairness guarantees, and inspect queue state. The queue prioritizes streams using a weight function, enabling use cases like selecting the most promising clause stream for next inference steps in a superposition prover.",
      "description_length": 423,
      "index": 1002,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Fool.S-Env-ProofState-SimplSet",
      "library": "libzipperposition.calculi",
      "description": "This module manages a dynamic set of clauses with signals for tracking additions and removals. It supports adding or removing multiple clauses at once using iterators and provides event hooks for monitoring changes. It is used to maintain and update a clause set during theorem proving or logical reasoning tasks.",
      "description_length": 313,
      "index": 1003,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.EnumTypes.S-Env-ProofState-SubsumptionIndex-C",
      "library": "libzipperposition.calculi",
      "description": "This module defines operations for comparing clauses, extracting literals, and retrieving label subsets. It works with clause data structures that support subsumption checks through literal and label comparisons. Concrete use cases include indexing clauses for efficient subsumption testing in automated theorem proving.",
      "description_length": 320,
      "index": 1004,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Booleans.S-Env-ProofState-UnitIndex",
      "library": "libzipperposition.calculi",
      "description": "This module implements an index for managing and querying a collection of logical (in)equations, supporting operations like adding, removing, and retrieving terms with substitution-based matching. It works with terms and substitutions from a logical environment, using a scoped context for retrieval. Concrete use cases include efficient lookups of equations during proof search or term rewriting, where generalizations of a query term must be identified.",
      "description_length": 455,
      "index": 1005,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Booleans.S-Env-C-WithPos",
      "library": "libzipperposition.calculi",
      "description": "This module represents clauses with a specific subterm and its position, enabling precise term manipulation and analysis. It provides comparison and pretty-printing operations for these structured clauses. Useful for tasks like subterm indexing, rewriting, or focused proof search where positional context is critical.",
      "description_length": 318,
      "index": 1006,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Heuristics.S-PS-UnitIndex",
      "library": "libzipperposition.calculi",
      "description": "This module implements a term index for efficient retrieval of (in)equations based on term structure and substitutions. It supports adding, removing, and querying equations or inequalities with first-order terms, enabling fast lookup of matching or generalizing terms. Use cases include clause indexing in automated theorem proving and efficient access to large sets of logical expressions during proof search.",
      "description_length": 410,
      "index": 1007,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Bce_pe_fixpoint.S-Env-C-Tbl",
      "library": "libzipperposition.calculi",
      "description": "This module offers hash table manipulation capabilities tailored for a specialized table structure, supporting operations like atomic updates, bulk insertions from sequences, and value transformations. It operates on tables keyed by `Env.C.Tbl.key`, facilitating tasks such as count aggregation, list merging, and custom conflict resolution during key collisions. Use cases include managing frequency counters, constructing tables from iterative data sources, and applying domain-specific merging logic in data processing pipelines.",
      "description_length": 532,
      "index": 1008,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Bce_pe_fixpoint.S-Env-Stm",
      "library": "libzipperposition.calculi",
      "description": "This module implements a stream-based structure for managing sequences of clauses with dynamic penalties and hit counters. It supports operations to create, compare, and manipulate streams, including extracting elements incrementally and checking stream state. Use cases include guiding clause selection in automated theorem proving by tracking stream origins and adjusting priority based on heuristic feedback.",
      "description_length": 411,
      "index": 1009,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Fool.S-C-Seq",
      "library": "libzipperposition.calculi",
      "description": "This module provides functions to extract literals, terms, and variables from a given clause structure. It operates on clauses (`C.t`) and iterates over their components using specific data types like literals, terms, and typed variables. It is useful for analyzing or transforming logical clauses in automated reasoning tasks.",
      "description_length": 327,
      "index": 1010,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Pred_elim.S-Env-C-ClauseSet",
      "library": "libzipperposition.calculi",
      "description": "This module offers ordered set operations for managing collections of logical clauses, supporting insertion, deletion, union, intersection, and ordered traversal while maintaining a consistent sort order via a comparison function. It works with `Env.C.ClauseSet.t` structures, which store elements of type `Env.C.ClauseSet.elt`, and provides utilities for filtering, mapping, and querying sets based on clause properties. Designed for automated reasoning contexts, it enables efficient clause set manipulation, serialization to lists/strings, and integration with theorem-proving workflows requiring ordered logical assertions.",
      "description_length": 627,
      "index": 1011,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Booleans.S-Env-ProofState-module-type-CLAUSE_SET",
      "library": "libzipperposition.calculi",
      "description": "This module manages a set of clauses with operations to add or remove clauses and trigger signals on these changes. It works with clause sets and uses iterators over clauses for bulk modifications. It is used in theorem proving contexts to track and react to clause additions and removals during proof search.",
      "description_length": 309,
      "index": 1012,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Qle.S-Env",
      "library": "libzipperposition.calculi",
      "description": "This module provides operations for managing logical clauses, inference rules, and proof states in automated reasoning systems. It works with data structures like clauses, contexts, and flex states, supporting rule registration, clause simplification, and redundancy checks through signal-driven workflows. Specific use cases include saturation-based theorem proving, term normalization, and clause transformation via strategies like backward/forward simplification and tautology elimination.",
      "description_length": 492,
      "index": 1013,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Bce_pe_fixpoint.Make",
      "library": "libzipperposition.calculi",
      "description": "Implements a fixpoint computation engine for clause elimination and predicate elimination in a superposition calculus context. It operates on clause sets and predicate symbols, performing iterative simplification steps until a stable state is reached. This module is used to implement bounded clause elimination and predicate elimination procedures in theorem proving algorithms.",
      "description_length": 379,
      "index": 1014,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Heuristics.S-Env-C",
      "library": "libzipperposition.calculi",
      "description": "This module facilitates clause manipulation and heuristic-driven reasoning in automated theorem proving, offering operations to inspect and modify clause properties like redundancy, simplification status, and proof metadata, alongside transformations involving substitutions and term traversal. It operates on logical clauses (`Env.C.t`), proofs, trails, and substitutions (`Logtk.Subst.FO.t`), leveraging auxiliary structures like bitvectors and tables to manage metadata such as depth, weight, and eligibility for inference rules. Specific applications include resolution, paramodulation, injectivity axiom handling, and goal-directed simplification, with utilities for proof extraction, clause normalization, and heuristic-based clause selection.",
      "description_length": 749,
      "index": 1015,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Qle.S-Env-ProofState-CQueue",
      "library": "libzipperposition.calculi",
      "description": "This module manages priority queues of clauses with operations for insertion, priority-based retrieval, and inspection, supporting strategies like FIFO, heuristic-driven, and goal-oriented selection. It works with clause data structures within `Env.ProofState.CQueue.t`, incorporating weight functions and profile-driven queue prioritization. Use cases include clause selection in proof states, passive set management, and debugging output generation.",
      "description_length": 451,
      "index": 1016,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Booleans.S-C-Seq",
      "library": "libzipperposition.calculi",
      "description": "This module provides functions to extract literals, terms, and variables from a clause structure. It operates on clauses (`C.t`) and returns iterators over their components, including literals (`Logtk.Literal.t`), terms (`Logtk.Term.t`), and typed variables (`Logtk.Type.t Logtk.HVar.t`). It is useful for analyzing or transforming logical clauses during theorem proving or formula manipulation tasks.",
      "description_length": 401,
      "index": 1017,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Hlt_elim.S-C-Eligible",
      "library": "libzipperposition.calculi",
      "description": "This module defines eligibility criteria for selecting literals in first-order logic clauses, primarily used in automated theorem proving. It provides functions to filter literals based on properties like positivity, negativity, equation status, and logical combinations of these properties. Operations include conjunction, disjunction, and negation of eligibility conditions, enabling precise control over which literals are considered for resolution or paramodulation steps.",
      "description_length": 476,
      "index": 1018,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Hlt_elim.S-Env-ProofState-CQueue-C",
      "library": "libzipperposition.calculi",
      "description": "The module provides operations for managing clause metadata (e.g., redundancy checks, simplification status, goal-related properties) and manipulating clause lifecycles through trail management, proof tracking, and origin tracing. It supports structural analysis of clauses (e.g., literal selection, eligibility for inference rules, term properties) and transformations like substitution application, grounding, and \u03b7-reduction, operating on clauses (`Env.ProofState.CQueue.C.t`), substitutions (`Logtk.Subst.t`), and bitvectors (`CCBV.t`). These capabilities are used in theorem proving tasks such as logical analysis, proof search optimization, and debugging proof states.",
      "description_length": 674,
      "index": 1019,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Superposition_intf.S-Env-Ctx-Lit",
      "library": "libzipperposition.calculi",
      "description": "This module manages bidirectional conversions between literals and formulas using customizable hooks. It provides functions to register and retrieve conversion hooks, as well as to perform the actual conversions between `Logtk.Literal.t` and `Logtk.Term.t Logtk.SLiteral.t`. It is used to integrate literal-level transformations within theorem proving processes, particularly when translating between different logical representations.",
      "description_length": 435,
      "index": 1020,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.EnumTypes.S-Env-ProofState-SubsumptionIndex",
      "library": "libzipperposition.calculi",
      "description": "This module implements a subsumption index for managing and querying clauses in a proof state. It supports operations to add or remove clauses from the index and retrieve clauses that are subsumed by, subsume, or are alpha-equivalent to a given clause. The index works directly with clauses (`C.t`) and literals (`Logtk.Index_intf.lits`), enabling efficient subsumption checks and clause management in automated theorem proving workflows.",
      "description_length": 438,
      "index": 1021,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Booleans.S-Env-FormRename-Ctx-Lit",
      "library": "libzipperposition.calculi",
      "description": "This module provides functions to convert between literals and formulas, specifically handling atomic formulas. It maintains lists of conversion hooks for customizing transformations, with `from_hooks` and `to_hooks` retrieving the current hook lists, and `add_from_hook` and `add_to_hook` extending them. The `of_form` and `to_form` functions perform direct conversions between `SLiteral.t` and `Literal.t` types, enforcing atomicity constraints.",
      "description_length": 447,
      "index": 1022,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Pred_elim.S-Env-Stm",
      "library": "libzipperposition.calculi",
      "description": "This module manages streams of clauses with associated metadata, supporting operations to create, compare, and manipulate streams based on their content and provenance. It works with streams of clauses (`C.t option OSeq.t`), tracking parent clauses, penalties, and access statistics. Concrete use cases include managing inference results in theorem proving, prioritizing stream processing based on heuristic penalties, and retrieving clause sequences incrementally for resolution steps.",
      "description_length": 486,
      "index": 1023,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Booleans.S",
      "library": "libzipperposition.calculi",
      "description": "This module implements Boolean simplification and propagation rules for a theorem proving system. It provides operations to register and apply Boolean inference rules, working with clauses and literals represented in the C module. Use cases include simplifying propositional logic expressions and propagating Boolean constraints during proof search.",
      "description_length": 349,
      "index": 1024,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.EnumTypes.S-Env-ProofState",
      "library": "libzipperposition.calculi",
      "description": "Manages clause queues, term and unit indexing, and set structures for efficient clause retrieval and manipulation. Provides concrete implementations for active, simplified, and passive clause sets, along with priority-based scheduling via the clause queue. Supports proof state tracking with statistics, pretty printing, and debug capabilities for clause processing workflows.",
      "description_length": 376,
      "index": 1025,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Higher_order.S-Env-ProofState-UnitIndex-E",
      "library": "libzipperposition.calculi",
      "description": "This module defines a structure for managing indexed equations, where each equation consists of two terms, a boolean flag indicating equality or inequality, and an associated clause. It provides operations to compare equations, extract their components, and determine their priority for use in theorem proving. These equations are used to represent logical statements during proof search, enabling efficient indexing and retrieval based on term structure.",
      "description_length": 455,
      "index": 1026,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Booleans.S-Env-ProofState-CQueue-C",
      "library": "libzipperposition.calculi",
      "description": "This module provides operations for managing boolean properties of clauses (e.g., redundancy, selection status), structural analysis (e.g., literal eligibility, clause length), and transformations (e.g., substitution, grounding) within a proof state. It operates on clauses (`C.t`), trails (`Trail.t`), and clause sets, supporting automated reasoning tasks like resolution and paramodulation by tracking proof metadata, managing clause origins, and enabling debugging through TSTP output. Specific use cases include guiding inference rule application via clause penalties and proof-depth tracking, as well as maintaining logical consistency during trail-based subsumption and activation.",
      "description_length": 687,
      "index": 1027,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Lazy_cnf.S-C-Seq",
      "library": "libzipperposition.calculi",
      "description": "This module provides functions to extract literals, terms, and variables from clauses. It operates on clause data structures, specifically sequences of literals, and returns iterators over literals, terms, or typed variables. Useful for analyzing or transforming logical clauses during proof search or formula preprocessing.",
      "description_length": 324,
      "index": 1028,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Bce_pe_fixpoint.S-Env-C-ClauseSet",
      "library": "libzipperposition.calculi",
      "description": "This module supports ordered traversal and manipulation of clause sets (`Env.C.ClauseSet.t`) with operations like union, intersection, filtering, and safe element queries (e.g., `find_first_map`, `find_last_opt`), leveraging a fixed ordering via `Ord.compare`. It enables conversions to and from lists, sequences, and iterators while ensuring deterministic processing of logical clauses. Specific use cases include automated reasoning workflows requiring ordered clause management, iterative transformations, and robust error handling through option-returning variants instead of exceptions.",
      "description_length": 591,
      "index": 1029,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Booleans.S-Env-ProofState-ActiveSet",
      "library": "libzipperposition.calculi",
      "description": "This module manages a dynamic set of clauses with signals for additions and removals. It provides operations to add or remove clauses, retrieve the current set, and count clauses. Useful for tracking clause changes in a proof state, such as during theorem proving or constraint solving.",
      "description_length": 286,
      "index": 1030,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Qle.S-Env-C-ClauseSet",
      "library": "libzipperposition.calculi",
      "description": "This module offers ordered set operations for managing collections of logical clauses, supporting set-theoretic operations (union, intersection, difference), ordered traversal (iter, fold), and conversion to/from lists/sequences. It works with `Env.C.ClauseSet.t` sets, which enforce element ordering via a comparison function, and includes utilities for filtering, extremal element queries, and safe/error-handling variants of operations. Designed for automated reasoning systems, it facilitates tasks like clause management in theorem proving, ordered clause evaluation, and structured data interchange through serialization functions like `to_string` and `pp`.",
      "description_length": 663,
      "index": 1031,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Hlt_elim.S-Env-ProofState-TermIndex-Leaf",
      "library": "libzipperposition.calculi",
      "description": "This module implements a term indexing structure that supports efficient insertion, removal, and unification-based queries over logical terms. It works with terms and substitutions from the Logtk library, along with proof state elements from the TermIndex module, to enable operations like unification, matching, and scoped iteration. It is used in theorem proving contexts to manage and query sets of terms during proof search, particularly for tasks like clause resolution and subsumption checking.",
      "description_length": 500,
      "index": 1032,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Booleans.S-C-WithPos",
      "library": "libzipperposition.calculi",
      "description": "This module represents clauses with a specific subterm and its position, enabling precise manipulation and analysis of terms within clauses. It provides comparison and pretty-printing operations for these structured clauses. Useful for tasks like subterm indexing, rewriting, or focused proof search where term positions matter.",
      "description_length": 328,
      "index": 1033,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Lazy_cnf.S-Env-Stm",
      "library": "libzipperposition.calculi",
      "description": "This module implements lazy CNF streams with unique identifiers, parent tracking, and mutable state for penalties and access statistics. It provides operations to create, compare, and query streams, along with functions to extract elements incrementally. Useful for managing clause sequences in theorem proving where streams represent delayed clause generation with dynamic prioritization.",
      "description_length": 389,
      "index": 1034,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Superposition_intf.S-Env-ProofState-CQueue-PriorityFun",
      "library": "libzipperposition.calculi",
      "description": "This module defines a priority function type used to assign integer weights to clauses in a clause queue, guiding the selection order during automated theorem proving. It includes a function to parse string descriptions into concrete priority functions, enabling dynamic configuration of clause prioritization strategies. Use cases include implementing and switching between different weighting schemes like clause size, age, or heuristic-based priorities.",
      "description_length": 456,
      "index": 1035,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.EnumTypes.S-Env-StmQ",
      "library": "libzipperposition.calculi",
      "description": "This module implements a priority queue for managing streams of clauses with weighted priorities. It supports operations to add streams or lists of streams, inspect queue size, and extract clauses either fairly or up to the stream count, using guarded or unguarded recursion. The queue is used to control the order and fairness of clause selection during theorem proving, where each stream represents a source of clauses and the weight function determines priority.",
      "description_length": 465,
      "index": 1036,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Higher_order.S-C-Pos",
      "library": "libzipperposition.calculi",
      "description": "Extracts a subterm from a given term at a specified position. Works with terms and positions in a higher-order context. Useful for precise term manipulation and analysis during proof search.",
      "description_length": 190,
      "index": 1037,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Pred_elim.S-Env-C",
      "library": "libzipperposition.calculi",
      "description": "This module provides operations for clause manipulation and analysis in theorem proving, including flag management, property tracking (redundancy, simplification status), proof extraction, and term analysis. It works with clauses (`Env.C.t`), substitutions (`Logtk.Subst.t`), terms (`Logtk.Term.t`), and trails, supporting tasks like resolution, paramodulation, and proof transformation. Key use cases include clause eligibility checks, literal selection, term position analysis, and transformations for simplification or goal-directed reasoning.",
      "description_length": 546,
      "index": 1038,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Qle.S-Env-C-Pos",
      "library": "libzipperposition.calculi",
      "description": "This module provides a function `at` that retrieves a term from an environment at a specified position. It operates on environments and positions, enabling precise access to terms within a logical context. Useful for querying specific term locations during proof search or term manipulation tasks.",
      "description_length": 297,
      "index": 1039,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Superposition_intf.S-C-Pos",
      "library": "libzipperposition.calculi",
      "description": "Extracts a subterm from a given term at a specified position. Works with terms and positions in a formal logic context. Useful for precise term manipulation in automated theorem proving tasks.",
      "description_length": 192,
      "index": 1040,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Bce.S-Env-C",
      "library": "libzipperposition.calculi",
      "description": "This module manages logical clauses in automated theorem proving by handling properties like redundancy, simplification status, and weight computation, while supporting operations on clauses with trails (Trail.t) and proofs. It enables resolution and paramodulation through eligibility checks, literal selection, and term ordering, along with transformations such as substitution application (Logtk.Subst.t) and TSTP-compatible output formatting for terms and clauses (Env.C.t). Key use cases include proof construction, clause normalization, and logic-specific inference rule selection.",
      "description_length": 587,
      "index": 1041,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Bce_pe_fixpoint.S-Env-C-Seq",
      "library": "libzipperposition.calculi",
      "description": "This module provides functions to extract literals, terms, and typed variables from a given clause environment. It operates on clause structures and supports iteration over their components. Use cases include analyzing or transforming logical clauses during theorem proving or formula manipulation tasks.",
      "description_length": 304,
      "index": 1042,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Heuristics.S-Env-Stm-Ctx",
      "library": "libzipperposition.calculi",
      "description": "This module provides operations for logical context management, term ordering, and selection function configuration, working with terms, types, and symbols from the Logtk library. It supports theorem proving by enabling term analysis, literal handling, and injectivity checks for symbols, which guide reasoning strategies in deduction systems.",
      "description_length": 343,
      "index": 1043,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Superposition_intf.S-C-WithPos",
      "library": "libzipperposition.calculi",
      "description": "This module represents clauses with a specific subterm and its position, enabling precise term manipulation and comparison. It provides a structured way to track and operate on terms within clauses, using Logtk types for terms and positions. Useful for implementing rewriting or inference rules that require positional context within logical expressions.",
      "description_length": 354,
      "index": 1044,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Higher_order.S-C-WithPos",
      "library": "libzipperposition.calculi",
      "description": "This module represents clauses with a specific subterm and its position, enabling precise manipulation and analysis of terms within clauses. It provides comparison and pretty-printing operations for these structured clauses. It is used in higher-order theorem proving to track and operate on specific subterms during inference steps.",
      "description_length": 333,
      "index": 1045,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Superposition_intf.S-Env-C-WithPos",
      "library": "libzipperposition.calculi",
      "description": "This module represents clauses with a specific subterm and its position, enabling precise term manipulation and analysis. It provides comparison and pretty-printing operations for these structured clauses. Useful for tasks like subterm indexing, rewriting, or focused proof search where positional context is critical.",
      "description_length": 318,
      "index": 1046,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Hlt_elim.S-Env-C",
      "library": "libzipperposition.calculi",
      "description": "This module manages clause metadata and transformations in automated reasoning systems, offering operations to track properties like redundancy, weight, and goal status while enabling proof-aware clause manipulation through trail inspection and eligibility checks for inference rules. It operates on logical clauses, substitutions, and terms, supporting tasks such as literal selection, paramodulation eligibility analysis, and term traversal for Boolean subterm detection. Key use cases include clause simplification, resolution-based reasoning, and maintaining proof contexts during theorem proving workflows.",
      "description_length": 611,
      "index": 1047,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Fool.S-Env-ProofState-module-type-CLAUSE_SET",
      "library": "libzipperposition.calculi",
      "description": "This module manages a set of clauses with operations to add or remove clauses and trigger signals on these changes. It works with clause sets and uses iterators to process multiple clauses. Concrete use cases include tracking clause modifications during theorem proving and enabling reactive updates in proof state management.",
      "description_length": 326,
      "index": 1048,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Higher_order.S-Env-ProofState-ActiveSet",
      "library": "libzipperposition.calculi",
      "description": "This module manages a dynamic set of clauses with signals for additions and removals. It provides operations to add or remove clauses, retrieve the current set, and count clauses. Use it to track clause changes in a proof state or maintain active clauses during theorem proving.",
      "description_length": 278,
      "index": 1049,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Superposition_intf.S-C",
      "library": "libzipperposition.calculi",
      "description": "This module provides operations for managing clauses in automated reasoning systems, focusing on metadata tracking (e.g., redundancy flags, proof annotations), eligibility checks for inference rules (resolution, paramodulation), and transformations (substitution application, normalization). It operates on clauses (`C.t`), literals (`Logtk.Literal.t`), substitutions, and proof-aware data structures like trails and scoped clauses, with utilities for symbol extraction, term selection tracking, and penalty-based simplification. These capabilities are used in superposition-based theorem proving for tasks like goal derivation, clause comparison, and generating standardized output formats (e.g., TSTP) for interoperability with external tools.",
      "description_length": 745,
      "index": 1050,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Bce_pe_fixpoint.S-Env-ProofState-CQueue",
      "library": "libzipperposition.calculi",
      "description": "This module provides priority queue operations for managing clauses in automated reasoning systems, supporting dynamic insertion, prioritized retrieval (e.g., FIFO, goal-oriented, ground-first), and set-like manipulation. It works with clause data structures through the `Env.ProofState.CQueue.t` type, enabling efficient membership checks, removals, and customizable heuristic-driven selection strategies. Key use cases include implementing proof search algorithms that require adaptive clause prioritization and passive set management with diagnostic formatting capabilities.",
      "description_length": 577,
      "index": 1051,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Superposition_intf.S-PS-SimplSet",
      "library": "libzipperposition.calculi",
      "description": "This module manages a dynamic set of clauses with operations to add or remove clauses and subscribe to events when clauses are added or removed. It works with clause data structures and supports iterative collections of clauses. It is used to track and react to changes in clause sets during theorem proving processes.",
      "description_length": 318,
      "index": 1052,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Heuristics.S-C-WithPos",
      "library": "libzipperposition.calculi",
      "description": "This module represents clauses with a specific subterm and its position, enabling precise term manipulation and analysis. It provides comparison and pretty-printing operations for these structured clauses. Useful for implementing rewriting strategies or focused proof search where term positions are critical.",
      "description_length": 309,
      "index": 1053,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Superposition_intf.S-C-Tbl",
      "library": "libzipperposition.calculi",
      "description": "This module provides imperative hash table operations for managing key-value associations with keys of type `C.t`, supporting in-place modifications, functional queries, and traversal via iterators or sequences. It works with hash tables (`'a C.Tbl.t`), lists, and custom merge strategies to handle tasks like counter incrementing, key collision resolution, and bulk conversions between collections. Typical use cases include efficient symbol table management, frequency counting with customizable aggregation, and scenarios requiring seamless interoperability between hash tables and sequential data processing.",
      "description_length": 612,
      "index": 1054,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Heuristics.S-C-ClauseSet",
      "library": "libzipperposition.calculi",
      "description": "This module implements a set algebra for clause manipulation, offering ordered traversal, element-wise transformations, and set-theoretic operations like union and intersection over collections of clauses. It operates on structured clause sets with safe lookup variants, min/max selection, and bidirectional conversions to sequences/lists, enabling efficient filtering, partitioning, and predicate-based searches. Designed for formal verification workflows, it supports use cases such as clause set normalization, logical invariant checking, and proof state manipulation through its ordered iteration and extensible transformation primitives.",
      "description_length": 642,
      "index": 1055,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Booleans.S-Env-C",
      "library": "libzipperposition.calculi",
      "description": "This module provides operations for managing boolean flags, trail-based reasoning, proof extraction, eligibility checks, literal selection, and clause normalization in theorem proving workflows. It operates on clause structures (`Env.C.t`), trail data (`Trail.t`), substitutions (`Logtk.Subst.t`), and bitvectors (`CCBV.t`), enabling use cases like redundancy elimination, paramodulation-driven literal analysis, and TSTP-compliant clause serialization.",
      "description_length": 453,
      "index": 1056,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Qle.S-Env-ProofState-TermIndex",
      "library": "libzipperposition.calculi",
      "description": "This module provides operations for managing and querying indexed logical terms paired with proof state elements, supporting efficient insertion, deletion, iteration, and unification-based retrieval (e.g., finding unifiable terms, generalizations, or specializations). It operates on a scoped environment for term variables and works with structures like `Logtk.Index_intf.term` and `C.WithPos.t` to represent logical terms and their proof state associations. A `to_dot` utility is included for visualizing the term index structure, aiding in debugging or analysis of term relationships during proof processes.",
      "description_length": 610,
      "index": 1057,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Qle.S-Env-StmQ",
      "library": "libzipperposition.calculi",
      "description": "This module implements a priority queue for managing streams of clauses with weighted priorities. It supports operations to add streams or lists of streams, inspect queue length, and extract clauses either individually or in batches, using fair or guarded strategies. The queue is used to prioritize clause selection in theorem proving, where streams represent sequences of logical clauses to be processed.",
      "description_length": 406,
      "index": 1058,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Hlt_elim.S-Env-C-WithPos",
      "library": "libzipperposition.calculi",
      "description": "Represents a clause with a highlighted subterm and its position, enabling precise term manipulation. It includes comparison and pretty-printing operations for managing and displaying clauses with positional context. Useful for implementing rewriting or inference rules that require tracking specific subterms within logical expressions.",
      "description_length": 336,
      "index": 1059,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Booleans.S-Env-C-ClauseSet",
      "library": "libzipperposition.calculi",
      "description": "This module supports operations for managing ordered sets of clauses with precise traversal and transformation capabilities, including standard set operations (union, intersection, difference), filtering, mapping, folding, and ordered element selection. It works with `Env.C.ClauseSet.t` structures, which are built using a comparison function to enforce ordering, and emphasizes efficient iteration, conversion to and from lists/sequences, and safe element access via optional returns. These capabilities are particularly useful in theorem proving contexts where maintaining and manipulating clauses in a specific order is critical for algorithmic correctness or performance.",
      "description_length": 676,
      "index": 1060,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Bce_pe_fixpoint.S",
      "library": "libzipperposition.calculi",
      "description": "This module implements fixed-point computations for binary clause elimination and predicate elimination in formal verification tasks. It operates on clause sets and logical formulas, applying simplification rules until no further changes occur. Use cases include optimizing logic formulas in automated theorem proving and static analysis of programs.",
      "description_length": 350,
      "index": 1061,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Qle.S-Env-C",
      "library": "libzipperposition.calculi",
      "description": "This module supports clause management and analysis in theorem proving, offering operations to manipulate boolean flags (e.g., redundancy, simplification status), inspect properties (literals, weight, IDs), and determine logical status (ground, goal). It works with clause data structures (`Env.C.t`), trails, proofs, and scoped terms (`Logtk.Scoped.t`), using bitvectors and sets for selections. Key applications include proof search, inference rule eligibility checks (resolution, paramodulation), clause transformation, and automated reasoning tasks like TSTP format generation.",
      "description_length": 581,
      "index": 1062,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Bce_pe_fixpoint.S-Env",
      "library": "libzipperposition.calculi",
      "description": "This module provides operations for saturation-based theorem proving, including inference rule registration (unary/binary), simplification strategies (forward/backward, unary/binary), redundancy elimination, and fixpoint-driven clause processing. It operates on logical clauses, active/passive clause sets, and proof states, with support for flex state management, signal handling, and theory-aware transformations. Use cases include clause generation, tautology detection, predicate elimination, and event-driven proof state evolution during saturation-based reasoning.",
      "description_length": 570,
      "index": 1063,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Lazy_cnf.S-Env-Stm-Ctx-Lit",
      "library": "libzipperposition.calculi",
      "description": "This module provides functions to convert between logical literals and their atomic formula representations, using customizable hooks for preprocessing and postprocessing. It operates on `Logtk.Literal.t` and `Logtk.Term.t Logtk.SLiteral.t` types, ensuring correct transformation of logical expressions. Concrete use cases include integrating custom logic during literal normalization and enabling compatibility between different stages of a theorem proving pipeline.",
      "description_length": 467,
      "index": 1064,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Pred_elim.S-Env-ProofState-CQueue",
      "library": "libzipperposition.calculi",
      "description": "This module provides operations for managing prioritized clause queues, including insertion, priority-based retrieval, membership checks, and strategy selection (e.g., FIFO, goal-oriented, ground-first). It operates on `Env.ProofState.CQueue.t` structures, which organize clauses using customizable weight and priority functions to guide automated reasoning tasks. These queues are specifically used in theorem proving to dynamically prioritize clause selection based on proof state context and user-defined heuristics.",
      "description_length": 519,
      "index": 1065,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Heuristics.Make",
      "library": "libzipperposition.calculi",
      "description": "This module organizes clause processing in automated theorem proving by combining heuristic-driven prioritization, metadata management, and efficient data structures. It handles clauses through dynamic sets, priority queues, and indexes that enable fast retrieval and transformation, supporting operations like subsumption, unification, and literal filtering. Key data types include clauses with literals and substitutions, indexed terms, and ordered sets for immutable collections. Examples include selecting high-priority clauses for resolution, simplifying redundant clauses using metadata, and dynamically adapting proof strategies based on term analysis and goal proximity.",
      "description_length": 678,
      "index": 1066,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Higher_order.S-Env-ProofState-CQueue-PriorityFun",
      "library": "libzipperposition.calculi",
      "description": "This module defines a priority function type for ordering clauses in a proof state's clause queue. It includes a function to parse string descriptions into priority functions that assign integer weights to clauses. This enables dynamic configuration of clause selection strategies in automated theorem proving based on syntactic features of clauses.",
      "description_length": 349,
      "index": 1067,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Hlt_elim.S-Env-Stm-Ctx",
      "library": "libzipperposition.calculi",
      "description": "This module provides operations for managing logical contexts, including skolemization, term ordering, and symbol declaration, operating on terms, types, and signatures. It supports theorem proving by enabling logical reasoning and term manipulation, with the Lit module offering tools for handling atomic logical statements and functions like checking injectivity of identifiers to influence unification or inference rules.",
      "description_length": 424,
      "index": 1068,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Heuristics.S-Env-C-ClauseSet",
      "library": "libzipperposition.calculi",
      "description": "This module offers ordered set operations for managing collections of logical clauses, including union, intersection, difference, filtering, mapping, and extremal element queries (min/max), all while preserving ordering invariants. It works with ordered clause sets (`Env.C.ClauseSet.t`) that rely on a comparison function for structure, supporting conversions to lists, sequences, and iterators. It is particularly useful in formal logic and theorem proving scenarios requiring precise clause manipulation, safe error-handled traversals, and ordered data transformations.",
      "description_length": 572,
      "index": 1069,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Heuristics.S-Env-ProofState-UnitIndex-E",
      "library": "libzipperposition.calculi",
      "description": "This module defines operations for managing and comparing indexed equations, which include terms, their equality status, and associated clauses. It provides functions to extract components of equations, establish a total order between them, and determine their priority for use in theorem proving. These operations are essential for implementing selection strategies and simplification rules in automated reasoning systems.",
      "description_length": 423,
      "index": 1070,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Hlt_elim.S-Env",
      "library": "libzipperposition.calculi",
      "description": "This module provides operations for logical deduction, clause simplification, and proof state management in automated reasoning systems. It works with clauses (`Env.C.t`), clause sets (`Env.C.ClauseSet.t`), trails (`Libzipperposition.Trail.t`), and flexible state objects to support inference generation, redundancy elimination, and term normalization. Key use cases include tautology removal, priority-driven rule application, and event-based simplification during proof search.",
      "description_length": 479,
      "index": 1071,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Bce_pe_fixpoint.S-Env-ProofState-UnitIndex",
      "library": "libzipperposition.calculi",
      "description": "This module implements a term index for efficiently storing, retrieving, and manipulating sets of (in)equations during theorem proving. It supports operations like adding or removing equations, querying for matches under substitutions, and iterating over indexed terms. Use cases include clause indexing in saturation-based provers and fast lookup of rewrite rules or constraints during proof search.",
      "description_length": 400,
      "index": 1072,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Higher_order.S-Env-C-Seq",
      "library": "libzipperposition.calculi",
      "description": "This module provides functions to extract literals, terms, and typed variables from a higher-order clause environment. It operates on environments (`Env.C.t`) and uses data types such as literals, terms, and type-annotated variables. It is useful for analyzing and manipulating logical expressions in automated theorem proving tasks.",
      "description_length": 333,
      "index": 1073,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Ind_types.Make",
      "library": "libzipperposition.calculi",
      "description": "Handles inductive reasoning for term-based logic systems by defining and manipulating inductive types. It works with term structures and inductive definitions, enabling operations like term instantiation and inductive hypothesis application. Useful for implementing proof search procedures in formal verification tools.",
      "description_length": 319,
      "index": 1074,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "Libzipperposition_calculi.Lazy_cnf.S-Env-ProofState-UnitIndex-E",
      "library": "libzipperposition.calculi",
      "description": "This module represents and compares indexed equations and inequations, providing a total order via `compare`, extraction of term components with `extract`, and a utility `priority` function for heuristic use. It operates on a tuple type combining terms, a boolean flag, and a clause, with a separate `rhs` type alias for right-hand sides. Concrete use cases include managing and prioritizing equations during clause processing in a theorem prover's inference engine.",
      "description_length": 466,
      "index": 1075,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Bce.S-Env-C-Tbl",
      "library": "libzipperposition.calculi",
      "description": "This module provides hash table operations for managing mappings from environment keys (`Env.C.t`) to arbitrary values, supporting standard manipulations like insertion, lookup, iteration, and statistics, as well as advanced merging of duplicate entries using custom functions. It includes utilities for bulk updates, counter incrementing from sequences, converting between tables and lists with merging strategies, and pretty-printing tables with customizable formatting, making it suitable for tasks like environment state tracking, frequency counting, or structured data transformation.",
      "description_length": 589,
      "index": 1076,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.EnumTypes.S-Env-FormRename-Ctx",
      "library": "libzipperposition.calculi",
      "description": "This module supports logical reasoning through skolemization, term ordering, and selection functions, alongside signature manipulation and injectivity analysis for function symbols. It operates on terms, types, and symbols from the Logtk library, managing context state and logical literals for applications in theorem proving and formal verification. Specific use cases include ensuring completeness during proof search and analyzing term-level properties like argument-specific injectivity.",
      "description_length": 492,
      "index": 1077,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Pure_literal_elim.IDMap",
      "library": "libzipperposition.calculi",
      "description": "This module implements a dictionary structure for mapping `id_sgn` keys to polymorphic values, emphasizing operations for creation, transformation, and traversal. It supports ordered key iteration, value manipulation via higher-order functions, and customizable merging strategies for combining maps, with utilities to convert between maps and sequences, lists, or iterators. It is particularly useful for scenarios requiring efficient management of identifier-to-data mappings with ordered key processing or complex value aggregation logic.",
      "description_length": 541,
      "index": 1078,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Libzipperposition_calculi.Fool.S-Env-ProofState-TermIndex",
      "library": "libzipperposition.calculi",
      "description": "This module provides term indexing structures for efficient manipulation of scoped terms and substitutions, supporting unification (both decidable and complete with infinite unifiers), generalization, and specialization. It manages associations between terms and arbitrary elements through batched updates and traversal operations, operating within a proof state context to handle logical term relationships. Use cases include optimizing term retrieval during theorem proving and generating DOT visualizations of indexed terms via the `to_dot` function.",
      "description_length": 553,
      "index": 1079,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Heuristics.S-Env-ProofState-CQueue",
      "library": "libzipperposition.calculi",
      "description": "This module supports operations for inserting clauses, extracting the highest-priority element, and selecting heuristic-driven prioritization strategies (e.g., goal-oriented or ground clause favoring) within a priority queue structure. It operates on `Env.ProofState.CQueue.t` data structures, which encapsulate clauses alongside weight and priority functions to dynamically order elements, while also providing membership checks, removal, and string conversion utilities. It is used in theorem proving to manage clause selection during proof search, interact with passive clause sets, and facilitate debugging through human-readable representations.",
      "description_length": 650,
      "index": 1080,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Lazy_cnf.S-C",
      "library": "libzipperposition.calculi",
      "description": "This module provides operations for manipulating clause properties (e.g., redundancy flags, proof annotations), transforming clauses via substitutions and trail-based logic, and analyzing literals for eligibility in resolution or paramodulation. It operates on clauses, trails, substitutions, and clause sets, supporting use cases such as proof construction, theorem proving, and debug output generation in automated reasoning systems. Key patterns include clause state management, proof-step tracking, and symbolic transformation for logical analysis.",
      "description_length": 552,
      "index": 1081,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Bce.S-Env-Ctx",
      "library": "libzipperposition.calculi",
      "description": "This module enables managing logical contexts in theorem proving systems through term ordering configuration, skolemization state tracking, and injectivity analysis for function arguments. It operates on logical literals, terms, and symbol declarations, supporting tasks like unification, literal normalization, and formal verification via context updates and term comparison mechanisms. Key features include signature manipulation, selection function application, and notification systems for tracking changes in logical environments.",
      "description_length": 535,
      "index": 1082,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Superposition_intf.S-Env-StmQ-WeightFun",
      "library": "libzipperposition.calculi",
      "description": "This module defines weight functions that assign integer weights to streams of statements. It provides operations to retrieve a penalty value for a stream and to combine multiple weight functions using weighted sums. These functions are used to prioritize or evaluate the complexity of logical statements in automated reasoning tasks.",
      "description_length": 334,
      "index": 1083,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Higher_order.S-Env-ProofState-UnitIndex",
      "library": "libzipperposition.calculi",
      "description": "This module implements a term index for efficiently storing, retrieving, and manipulating sets of (in)equations during proof search in higher-order logic. It supports operations like adding or removing equations, querying for matches under substitution, and iterating over indexed terms. Use cases include clause indexing in automated theorem proving and efficient subsumption or rewriting checks during saturation-based reasoning.",
      "description_length": 431,
      "index": 1084,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Higher_order.S-Env-ProofState-PassiveSet",
      "library": "libzipperposition.calculi",
      "description": "This module manages a set of clauses with dynamic addition and removal, supporting passive clause processing in a theorem proving context. It provides signals for tracking clause modifications, operations to add or remove clauses, and access to the current clause set and queue state. Concrete use cases include managing passive clauses during saturation-based reasoning and controlling clause selection in proof search.",
      "description_length": 420,
      "index": 1085,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Bce.S-Env-ProofState-ActiveSet",
      "library": "libzipperposition.calculi",
      "description": "This module manages a dynamic set of clauses with operations to add, remove, and retrieve clauses, along with signals for tracking changes. It works with clause data types and maintains an internal set structure for efficient querying and modification. It is used to monitor and manipulate logical clauses during theorem proving processes, such as tracking active clauses in a saturation loop.",
      "description_length": 393,
      "index": 1086,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Fool.S-Env-C-WithPos",
      "library": "libzipperposition.calculi",
      "description": "This module represents clauses with a specific subterm and its position, enabling precise term manipulation and analysis. It provides comparison and pretty-printing operations for these structured clauses. Useful for tasks like subterm indexing, rewriting, or focused proof search where term positions matter.",
      "description_length": 309,
      "index": 1087,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.EnumTypes.S-Env-ProofState-SimplSet",
      "library": "libzipperposition.calculi",
      "description": "This module manages a dynamic set of clauses with operations to add or remove clauses and signals to notify when changes occur. It works with clause data types and iterators over clauses. Concrete use cases include maintaining a clause database during theorem proving where change notifications are needed.",
      "description_length": 306,
      "index": 1088,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Bce.S-Env-ProofState-TermIndex-Leaf",
      "library": "libzipperposition.calculi",
      "description": "This module implements a term index structure for efficient retrieval of elements based on term unification and matching. It supports operations like adding or removing elements associated with terms, iterating and folding over indexed entries, and performing scoped unification or matching queries with substitution tracking. It is used in theorem proving contexts to quickly find relevant clauses or terms during proof search.",
      "description_length": 428,
      "index": 1089,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Qle.S-Env-ProofState-SubsumptionIndex",
      "library": "libzipperposition.calculi",
      "description": "This module implements a subsumption index for managing and querying clauses in a proof state. It supports operations to add, remove, and retrieve clauses based on subsumption and alpha-equivalence relationships, using literals and labels as keys. Use cases include efficient clause indexing and retrieval during automated theorem proving processes.",
      "description_length": 349,
      "index": 1090,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Bce_pe_fixpoint.S-Env-ProofState-TermIndex",
      "library": "libzipperposition.calculi",
      "description": "This module provides term indexing operations for automated reasoning, enabling efficient management of terms paired with clause positions through insertion, removal, and traversal. It supports specialized queries for unifiable terms, generalizations, and specializations, optimized for theorem proving tasks like clause retrieval during proof search. The structure can be visualized as a graph via the `to_dot` function, aiding analysis of term relationships in proof states.",
      "description_length": 476,
      "index": 1091,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.EnumTypes.S-C-WithPos",
      "library": "libzipperposition.calculi",
      "description": "This module represents clauses with a specific subterm and its position, enabling precise term manipulation and comparison. It provides structured access to the clause, term, and position data, supporting operations like ordering and pretty-printing. Use this for tasks like subterm indexing, rewriting, or focused proof search where positional context is critical.",
      "description_length": 365,
      "index": 1092,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Superposition_intf.S-Env-ProofState-SubsumptionIndex",
      "library": "libzipperposition.calculi",
      "description": "This module implements a subsumption index for managing and querying clauses in a proof state. It supports operations to add, remove, and retrieve clauses based on subsumption and alpha-equivalence relations, using literals and labels as keys. The index is used during automated reasoning to efficiently find relevant clauses for inference or simplification steps.",
      "description_length": 364,
      "index": 1093,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "Libzipperposition_calculi.Booleans.S-C-Tbl",
      "library": "libzipperposition.calculi",
      "description": "This module provides a specialized imperative hash table implementation for key type `C.t`, supporting efficient in-place modifications (insertion, deletion, incrementing), bulk operations (sequence/iterator conversions, list folding), and safe querying (default-aware lookups, key existence checks). It works with key-value pairs where values often represent counts or require aggregation, offering utilities like `add_seq_count` for frequency analysis and `map_list` for value transformation. Typical use cases include tracking term frequencies in symbolic data, maintaining dynamic mappings during theorem proving, and optimizing iterative algorithms through in-place updates and bulk initialization from collections.",
      "description_length": 720,
      "index": 1094,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Heuristics.S-Env-StmQ-WeightFun",
      "library": "libzipperposition.calculi",
      "description": "This module defines weight functions for assigning integer weights to statements in a stream, primarily used to prioritize or evaluate elements in a weighted queue. It includes operations to retrieve a penalty value and combine multiple weighted functions into a single function through a weighted sum. These functions are applied in scenarios like theorem proving or constraint solving, where prioritizing statements based on custom metrics improves efficiency.",
      "description_length": 462,
      "index": 1095,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Pred_elim.S-Env-ProofState-CQueue-WeightFun",
      "library": "libzipperposition.calculi",
      "description": "This module defines weight functions that assign integer weights to clauses in a proof state's priority queue. It supports operations to construct and combine weight functions using penalties, syntactic properties like groundness or Horn shape, and proximity to the initial goal. These functions guide clause selection in automated theorem proving by influencing the priority queue's ordering.",
      "description_length": 393,
      "index": 1096,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Hlt_elim.S-Env-StmQ-WeightFun",
      "library": "libzipperposition.calculi",
      "description": "This module defines weight functions for assigning integer weights to streams of statements. It includes operations to compute a penalty value for a stream and to combine multiple weight functions using weighted sums. These functions are used to prioritize or evaluate the relevance of statement sequences in automated reasoning tasks.",
      "description_length": 335,
      "index": 1097,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Pred_elim.S-Env-ProofState-UnitIndex",
      "library": "libzipperposition.calculi",
      "description": "This module implements an index for managing and querying a collection of (in)equations during automated reasoning tasks. It supports operations to add, remove, and retrieve equations or inequations, with specialized retrieval for matching or generalizing terms under substitutions. The index enables efficient lookups in proof state management, particularly for term rewriting and clause subsumption checks.",
      "description_length": 408,
      "index": 1098,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Higher_order.S-C",
      "library": "libzipperposition.calculi",
      "description": "This module supports core operations for clause manipulation, proof handling, and inference control in higher-order automated reasoning. It works with clauses (`C.t`), trails, substitutions, scoped literals, and clause sets, enabling tasks like redundancy checks, paramodulation eligibility analysis, and \u03b7-reduction transformations. Key use cases include theorem proving with trail-based reasoning, proof extraction, and normalizing clauses for formats like TSTP.",
      "description_length": 464,
      "index": 1099,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Superposition_intf.S-PS",
      "library": "libzipperposition.calculi",
      "description": "This module implements core components for a superposition-based automated theorem prover. It manages clause sets with specialized structures like active, simplification, and passive sets, and uses term and unit indexes for efficient retrieval and subsumption checks. Concrete operations include clause processing, redundancy elimination, and state management with detailed statistics tracking and pretty printing for debugging.",
      "description_length": 428,
      "index": 1100,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.EnumTypes.S-Env-C-Eligible",
      "library": "libzipperposition.calculi",
      "description": "This module defines eligibility criteria for selecting literals in a clause based on logical operations and properties such as positivity, negativity, maximality, and equation status. It provides functions to filter literals for resolution, paramodulation, and equation handling, along with logical combinators to compose and modify criteria. Use cases include guiding inference rules in automated theorem proving by restricting which literals can participate in resolution or paramodulation steps.",
      "description_length": 498,
      "index": 1101,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Higher_order.S-C-Eligible",
      "library": "libzipperposition.calculi",
      "description": "This module defines a set of functions for determining literal eligibility in higher-order theorem proving operations, such as resolution and paramodulation. It works with clauses and literals, providing filters based on properties like positivity, negativity, and equation status. These functions are used to control inference rules by selecting which literals can participate in specific proof steps.",
      "description_length": 402,
      "index": 1102,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Superposition_intf.S-Env-C-ClauseSet",
      "library": "libzipperposition.calculi",
      "description": "This module provides a functional set interface for managing immutable, ordered collections of clauses, supporting operations like membership checks, union/intersection/difference, ordered traversal, and predicate-based filtering. It works with sets of type `Env.C.ClauseSet.t`, emphasizing ordered iteration, element selection via comparison ordering, and conversions to/from lists or sequences. Specific use cases include automated reasoning tasks requiring structured clause manipulation, such as superposition-based theorem proving, where ordered set operations and precise element control are critical.",
      "description_length": 607,
      "index": 1103,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Bce_pe_fixpoint.S-Env-ProofState-PassiveSet",
      "library": "libzipperposition.calculi",
      "description": "This module manages a set of passive clauses with operations to add, remove, and query clauses, as well as track their passive status. It provides signals for clause addition and removal, a queue interface for clause processing, and access to the current clause set and count. Concrete use cases include controlling clause processing in automated theorem proving and managing passive clause state during proof search.",
      "description_length": 417,
      "index": 1104,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Lazy_cnf.S-Env-FormRename",
      "library": "libzipperposition.calculi",
      "description": "This module handles formula renaming and Skolemization during CNF conversion. It provides operations to rename logical formulas, introduce predicate Skolem symbols, and identify renaming clauses. It works with clauses, formulas, and renaming contexts, supporting use cases like formula abstraction and definition extraction in theorem proving pipelines.",
      "description_length": 353,
      "index": 1105,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Hlt_elim.Make",
      "library": "libzipperposition.calculi",
      "description": "This module implements a clause transformation and simplification engine for higher-order logic, focusing on hlt-elimination and related inferences, operating on clause structures and term representations from supporting modules. It provides core data types such as clauses (`C.t`), trails, substitutions, and term positions, with operations for redundancy tracking, literal eligibility filtering, and proof-aware clause construction. Submodules enable literal selection with custom criteria, subterm manipulation, and ordered clause set processing, supporting deterministic theorem proving pipelines. Specific use cases include normalizing clauses, planning inferences based on term positions, and aggregating results efficiently using hash tables.",
      "description_length": 749,
      "index": 1106,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Heuristics.S-PS-CQueue-PriorityFun",
      "library": "libzipperposition.calculi",
      "description": "This module defines a priority function type for weighted selection of clauses in a prover's given clause algorithm. It operates on clause queues, assigning integer weights to guide search strategy. Use it to implement custom clause selection heuristics like \"largest clause first\" or \"lowest symbol count first\" by parsing string descriptions into concrete priority functions.",
      "description_length": 377,
      "index": 1107,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Qle.S-Env-Stm",
      "library": "libzipperposition.calculi",
      "description": "This module manages streams of clauses with associated metadata, supporting operations to create, compare, and manipulate these streams. It provides functions to access stream properties like unique IDs, penalties, and content retrieval via `drip` and `drip_n`. Concrete use cases include managing clause streams during theorem proving, tracking inference sources, and controlling stream processing with heuristic penalties.",
      "description_length": 424,
      "index": 1108,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Lazy_cnf.S-Env-Ctx",
      "library": "libzipperposition.calculi",
      "description": "This module provides operations for managing logical contexts in theorem proving, including term ordering, selection functions, and skolemization, while enabling term signature manipulation through symbol declaration, type tracking, and injectivity checks. It works with term signatures, logical literals, and function symbols to support CNF conversion by determining clause generation validity based on argument-specific injectivity and handling symbol properties during term comparison. Key use cases include logical reasoning tasks requiring precise control over term normalization, skolemization, and injectivity-aware clause transformation.",
      "description_length": 645,
      "index": 1109,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Qle.Make",
      "library": "libzipperposition.calculi",
      "description": "Implements a selection function for the QLE (Quick Lemma Elimination) calculus used in automated theorem proving. It operates on clauses and literals, prioritizing those that are most promising for lemma generation. This module is useful in proof search scenarios where efficient lemma selection improves performance.",
      "description_length": 317,
      "index": 1110,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Fool.S-Env-Stm-Ctx",
      "library": "libzipperposition.calculi",
      "description": "This module supports logical context management through operations like term ordering, symbol declaration, and injectivity checks for identifiers. It operates on terms, literals, identifiers, and signatures, enabling first-order logic manipulation and context updates. These capabilities are used in automated reasoning and theorem proving to manage logical formulae and verify structural properties of terms.",
      "description_length": 409,
      "index": 1111,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Higher_order.S-Env-ProofState-TermIndex-Leaf",
      "library": "libzipperposition.calculi",
      "description": "This module implements a term index structure for efficient retrieval of terms during proof search in higher-order logic. It supports operations to add, remove, and update indexed terms along with their associated elements, and provides specialized folding functions for unification and matching. Use cases include fast lookup of candidate terms during resolution or superposition steps in automated theorem proving.",
      "description_length": 416,
      "index": 1112,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Booleans.S-Env-ProofState-TermIndex-Leaf",
      "library": "libzipperposition.calculi",
      "description": "This module implements a term index structure for efficient retrieval of logical terms during automated reasoning tasks. It supports operations to add, remove, and update indexed terms, as well as to perform unification and matching queries over scoped terms. The index is used to accelerate proof search by enabling fast access to potentially matching or unifiable terms in the proof state.",
      "description_length": 391,
      "index": 1113,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Superposition_intf.S-PS-PassiveSet",
      "library": "libzipperposition.calculi",
      "description": "This module manages a passive clause set for a superposition prover, supporting dynamic updates via signals when clauses are added or removed. It provides operations to add or remove clauses, retrieve the current clause set, check if a clause is passive, and process clauses in a queue. Concrete use cases include tracking passive clauses during theorem proving and controlling clause selection strategies in automated reasoning systems.",
      "description_length": 437,
      "index": 1114,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Qle.S-Env-ProofState-SimplSet",
      "library": "libzipperposition.calculi",
      "description": "This module manages a dynamic set of clauses with operations to add or remove clauses and subscribe to events when clauses are modified. It provides signals for tracking additions and removals, and uses iterators to process multiple clauses efficiently. It is useful in theorem proving contexts where clause sets need to be monitored or simplified incrementally.",
      "description_length": 362,
      "index": 1115,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Heuristics.S-PS-SubsumptionIndex-C",
      "library": "libzipperposition.calculi",
      "description": "This module defines operations for comparing and analyzing clauses in a subsumption index. It provides functions to compare clauses, iterate over their literals, and retrieve label sets that enforce subsumption constraints. It works with clauses (`C.t`) and exposes their structure for indexing and subsumption checks in automated reasoning tasks.",
      "description_length": 347,
      "index": 1116,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Bce_pe_fixpoint.S-Env-ProofState-CQueue-WeightFun",
      "library": "libzipperposition.calculi",
      "description": "This module defines weight functions that compute integer weights for clauses in a proof state's priority queue. It supports operations like parsing weight function descriptions, combining multiple weight functions with coefficients, and applying heuristic-based weighting strategies. Use cases include guiding clause selection during automated theorem proving by prioritizing specific clause properties, such as proximity to the goal, presence of Horn clauses, or ground literals.",
      "description_length": 481,
      "index": 1117,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Fool.S-C",
      "library": "libzipperposition.calculi",
      "description": "The module offers operations for managing and analyzing first-order logic clauses, including flag manipulation (redundancy, simplification status), property checks (groundness, orphan status), and transformations (substitution application, symbol extraction). It works with clauses (`C.t`), trails (`Trail.t`), clause sets (`ClauseSet.t`), substitutions, and proof-related structures, supporting tasks like redundancy elimination, trail-based reasoning, and proof construction. Specific use cases include clause normalization for saturation-based theorem proving, eligibility checks for resolution/paramodulation, and debugging via TSTP-formatted output.",
      "description_length": 654,
      "index": 1118,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Qle.S-Env-Stm-Ctx-Lit",
      "library": "libzipperposition.calculi",
      "description": "This module manages bidirectional conversions between literals and formulas using customizable hooks. It provides functions to register and retrieve conversion hooks, as well as to perform the actual conversions. It works with literals and formulas represented using Logtk types, specifically `Logtk.Literal.t` and `Logtk.SLiteral.t`. Use cases include integrating custom literal representations into theorem proving pipelines or transforming logical expressions for solver interaction.",
      "description_length": 486,
      "index": 1119,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Fool.S-Env-Ctx-Lit",
      "library": "libzipperposition.calculi",
      "description": "This module manages bidirectional conversions between literals and formulas using hooks. It provides functions to register and retrieve conversion hooks for transforming literals to formulas and vice versa. The primary data types are `Logtk.Literal.t` and `Logtk.Term.t Logtk.SLiteral.t`, with direct use in parsing or pretty-printing logical expressions where atomic formulas must be converted to literals and back.",
      "description_length": 416,
      "index": 1120,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Heuristics.S-PS-ActiveSet",
      "library": "libzipperposition.calculi",
      "description": "This module manages a dynamic set of clauses with operations to add, remove, and retrieve clauses, along with signals triggered on clause additions and removals. It works with clause data types and maintains an internal set structure for efficient querying and updates. Concrete use cases include tracking active clauses during theorem proving and enabling reactive updates in proof search strategies.",
      "description_length": 401,
      "index": 1121,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Bce_pe_fixpoint.S-Env-ProofState-ActiveSet",
      "library": "libzipperposition.calculi",
      "description": "This module manages a dynamic set of clauses with support for adding, removing, and querying clauses. It provides signals for tracking clause additions and removals, along with functions to retrieve the current clause set and its size. It is used in theorem proving contexts to maintain and monitor the active clause set during deduction processes.",
      "description_length": 348,
      "index": 1122,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Superposition_intf.S-Env-ProofState-SimplSet",
      "library": "libzipperposition.calculi",
      "description": "This module manages a dynamic set of clauses with signals for tracking additions and removals. It provides operations to add or remove multiple clauses using iterators, enabling reactive updates in theorem proving contexts. It is used to maintain and manipulate clause sets during superposition-based automated reasoning tasks.",
      "description_length": 327,
      "index": 1123,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Bce.S-Env-StmQ",
      "library": "libzipperposition.calculi",
      "description": "This module implements a priority queue for managing streams of clauses with weighted priorities. It provides operations to add streams or lists of streams, inspect queue state, and extract clauses with varying fairness and recursion guarantees. Use cases include prioritizing clause processing in automated theorem proving where streams represent different sources of clauses and weights determine processing order.",
      "description_length": 416,
      "index": 1124,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Superposition_intf.S-Env-C",
      "library": "libzipperposition.calculi",
      "description": "This module type provides operations for managing and analyzing logical clauses, including setting boolean flags (e.g., redundancy, simplification status), comparing and hashing clauses, and transforming them via substitutions or proof manipulations. It operates on clauses (`Env.C.t`), substitutions, scoped terms, and bitvectors, enabling tasks like inference rule eligibility checks, literal selection, and penalty tracking. These capabilities are critical in automated theorem proving for formal verification, proof generation, and logical simplification workflows.",
      "description_length": 569,
      "index": 1125,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Bce_pe_fixpoint.S-Env-ProofState-CQueue-PriorityFun",
      "library": "libzipperposition.calculi",
      "description": "This module defines a priority function type used to assign integer weights to elements in a proof state queue, guiding their processing order. It includes a function to parse string descriptions into these priority functions. This enables dynamic configuration of prioritization strategies during automated theorem proving.",
      "description_length": 324,
      "index": 1126,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Heuristics.S-PS-TermIndex",
      "library": "libzipperposition.calculi",
      "description": "This module provides a term index structure for managing collections of terms paired with positional data (`C.WithPos.t`), enabling efficient operations like insertion, deletion, and traversal, as well as advanced queries for unifiable terms, generalizations, and specializations using higher-order unification. It supports use cases requiring precise term indexing, such as automated theorem proving or symbolic computation, and includes utilities to visualize the index's structure via DOT format for analysis.",
      "description_length": 512,
      "index": 1127,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Higher_order.S-Env-ProofState-SubsumptionIndex-C",
      "library": "libzipperposition.calculi",
      "description": "This module defines operations for comparing clauses, extracting literals, and retrieving label subsets. It works with clauses represented by the type `C.t` and associated integer labels. It supports subsumption checks by ensuring labels of one clause are a subset of another's.",
      "description_length": 278,
      "index": 1128,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Higher_order.S-Env-FormRename",
      "library": "libzipperposition.calculi",
      "description": "This module handles formula renaming and Skolemization during higher-order reasoning. It provides operations to rename formulas, detect renaming clauses, and introduce predicate Skolems with configurable freshness strategies. Key data structures include clauses and formula renaming contexts, used to manage symbol substitutions and definition extraction in proof search.",
      "description_length": 371,
      "index": 1129,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Booleans.S-C-Eligible",
      "library": "libzipperposition.calculi",
      "description": "This module defines eligibility criteria for selecting literals in first-order logic clauses, primarily used in automated theorem proving. It provides operations to filter literals based on properties like positivity, negativity, equation status, and maximality, as well as logical combinations of these conditions. Functions like `res`, `param`, and `combine` enable precise control over which literals participate in resolution, paramodulation, or other inference steps.",
      "description_length": 472,
      "index": 1130,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Bce_pe_fixpoint.S-Env-ProofState-TermIndex-Leaf",
      "library": "libzipperposition.calculi",
      "description": "This module implements a term index structure that supports efficient insertion, removal, and querying of logical terms in a proof state context. It provides operations for unification and matching between indexed terms and query terms, returning substitutions that make the terms equivalent. It is used in automated theorem proving to find relevant clauses or subterms that can be used for inference steps like resolution or paramodulation.",
      "description_length": 441,
      "index": 1131,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Lazy_cnf.S-Env",
      "library": "libzipperposition.calculi",
      "description": "Core operations include clause manipulation (addition, removal, retrieval), logical inference (resolution, simplification, redundancy checks), and normalization strategies (term rewriting, tautology elimination) within a saturation-based proving loop. The module operates on clauses, proof states with active/passive clause sets, flex state key-value pairs, and inference streams, while supporting rule registration for unary/multi-clause transformations. It is used in CNF conversion pipelines, event-driven theorem proving, and state management for clause processing with proof tracking and finite unification constraints.",
      "description_length": 624,
      "index": 1132,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Fool.S-C-Tbl",
      "library": "libzipperposition.calculi",
      "description": "This module implements a polymorphic hash table with imperative operations for key-value storage and manipulation, emphasizing safe access patterns and bulk transformations. It operates on `C.Tbl.t` structures where keys are of type `C.Tbl.key` and values can be arbitrary types, supporting use cases like element frequency counting, sequence-based table construction, and atomic value updates with default fallbacks. Specialized functions handle statistical aggregation, list/sequence conversions, and customizable textual representations for debugging or serialization.",
      "description_length": 571,
      "index": 1133,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Bce.S-Env-C-Eligible",
      "library": "libzipperposition.calculi",
      "description": "This module defines eligibility criteria for selecting literals in a clause based on logical operations and properties such as positivity, negativity, maximality, and equation status. It provides functions to filter literals for resolution, paramodulation, and custom conditions, combining them with logical operators (and, or, not). It works directly with clauses and literals from the Logtk library, enabling precise control over inference rules in automated theorem proving.",
      "description_length": 477,
      "index": 1134,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Higher_order.S-Env-StmQ",
      "library": "libzipperposition.calculi",
      "description": "This module implements a priority queue for managing streams of clauses in a higher-order theorem proving context. It provides operations to add streams or lists of streams to the queue, take clauses based on priority and fairness strategies, and inspect queue state such as length and emptiness. The queue is constructed with a weight function to determine stream priority, and supports concrete use cases like fair clause selection for proof search and resource-bounded stream processing.",
      "description_length": 490,
      "index": 1135,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Superposition_intf.S-Env",
      "library": "libzipperposition.calculi",
      "description": "This module provides operations for implementing superposition calculus rules, including deduction, simplification, redundancy checks, and proof state transformations. It manages clauses, clause sets (active/passive), trails, and flex state data, supporting tasks like tautology elimination, term normalization, and event-driven simplification tracking. These components facilitate automated reasoning through inference rule application, multi-clause simplification, and ordering-based state management.",
      "description_length": 503,
      "index": 1136,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Lazy_cnf.S-C-Pos",
      "library": "libzipperposition.calculi",
      "description": "This module provides a function `at` that retrieves a term at a specific position within a clause. It operates on clauses and positions, enabling precise navigation and manipulation of terms in logical expressions. Useful for implementing proof search strategies that require term-level inspection or transformation.",
      "description_length": 316,
      "index": 1137,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Booleans.S-Env-FormRename-Ctx",
      "library": "libzipperposition.calculi",
      "description": "This module provides operations for managing logical contexts in theorem proving, including term ordering, selection function configuration, and skolemization context handling. It works with term signatures, symbols, and logical literals, supporting tasks like injectivity checks for unification and type-aware symbol manipulation. Key use cases involve proof search, term rewriting, and maintaining context-sensitive state during logical reasoning.",
      "description_length": 449,
      "index": 1138,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Lazy_cnf.S-Env-ProofState-ActiveSet",
      "library": "libzipperposition.calculi",
      "description": "This module manages a dynamic set of clauses with signals for additions and removals. It supports adding or removing clauses from an iterator, retrieving the current clause set, and querying the number of clauses. It is used in CNF transformation processes where clause set changes must be tracked and handled incrementally.",
      "description_length": 324,
      "index": 1139,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Pred_elim.S-Env-FormRename",
      "library": "libzipperposition.calculi",
      "description": "This module handles predicate elimination through formula renaming and Skolemization. It provides operations to detect renaming clauses, introduce predicate Skolems, and rename formulas based on context and polarity. It works with clauses, formulas, and term structures to support transformations during automated reasoning.",
      "description_length": 324,
      "index": 1140,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Ind_types",
      "library": "libzipperposition.calculi",
      "description": "This module supports inductive reasoning over term-based logic systems by defining and manipulating inductive types, enabling operations like term instantiation and hypothesis application. It provides core data types for representing inductive structures and operations for building and extending inductive hypotheses over terms and formulas. Submodules enhance these capabilities with specialized logic for proof search procedures in formal verification. For example, it can derive inductive invariants for lists or natural numbers and apply them in automated reasoning tasks.",
      "description_length": 577,
      "index": 1141,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Eq_encode",
      "library": "libzipperposition.calculi",
      "description": "This module supports encoding equality within logical statements by defining symbols, literals, and clauses that capture reflexivity, symmetry, and transitivity, operating on data structures like terms and formulas in automated reasoning systems. It includes an extension component that integrates with logical calculus frameworks to handle equality in both extensional and intensional contexts. Use cases include theorem proving and formal verification where equality properties must be explicitly represented or manipulated.",
      "description_length": 526,
      "index": 1142,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.MyHeap",
      "library": "libzipperposition.calculi",
      "description": "This module provides a mutable heap based on a vector, offering efficient insertion, removal of the minimum element, and priority adjustments. Core operations include `insert`, `remove_min`, `decrease`, and `increase`, with invariant maintenance via `percolate_up` and `percolate_down`. It supports use cases like priority queues and Dijkstra\u2019s algorithm, where elements must be processed in order of priority and priorities change dynamically. For example, you can insert elements with varying priorities, remove the smallest efficiently, or adjust an element's priority and restore the heap structure accordingly.",
      "description_length": 615,
      "index": 1143,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Rewriting",
      "library": "libzipperposition.calculi",
      "description": "This module provides rewriting-based transformations for first-order logic formulas, focusing on unfolding definitions and simplifying expressions before clausal normalization. It operates on typed terms and statements, applying rewrite rules to support preprocessing in automated theorem proving pipelines. The core functionality includes controlled rewriting and narrowing operations, configurable with respect to an equational theory module E and supporting strategies such as leftmost-innermost or lazy rewriting. Specific applications include simplifying logical expressions using algebraic identities, normalizing terms modulo associativity or commutativity, and enabling custom rewriting systems over structured data.",
      "description_length": 724,
      "index": 1144,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Superposition_intf",
      "library": "libzipperposition.calculi",
      "description": "This module forms the foundation of a superposition calculus system for automated theorem proving, orchestrating clause manipulation, inference rule application, and redundancy checking across a network of specialized submodules. Core data types include clauses, literals, terms, substitutions, and proof states, with operations spanning term indexing, priority queues, dynamic clause sets, logical context management, and term traversal for efficient inference and transformation. Submodules enable term indexing for fast equation retrieval, priority-based clause scheduling, signal-driven clause set updates, context-sensitive term ordering, and proof-guided simplification, supporting concrete tasks like paramodulation, subsumption checking, literal selection, and TSTP output generation. Together, these components facilitate sophisticated proof search strategies, from low-level term manipulation to high-level state management and heuristic-driven reasoning.",
      "description_length": 965,
      "index": 1145,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Booleans",
      "library": "libzipperposition.calculi",
      "description": "This module combines Boolean reasoning with clause management and logical context handling to support automated theorem proving. It provides core operations for preprocessing and simplifying logical formulas, managing clause sets and priority queues, and defining eligibility criteria for inference rules. Users can manipulate clauses through transformations like renaming, Skolemization, and normalization, while tracking properties such as redundancy and goal distance. Specific tasks include extracting subterms by position, converting between literals and formulas, prioritizing clauses using weight functions, and maintaining indexed collections for efficient retrieval and subsumption checks.",
      "description_length": 698,
      "index": 1146,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Superposition",
      "library": "libzipperposition.calculi",
      "description": "This module implements the superposition calculus for automated theorem proving, combining inference rules, unification algorithms, and higher-order reasoning with clauses and terms from the Logtk library. It manages substitutions, term orderings, and scoped variables to support operations like clause normalization, redundancy elimination, and equality reasoning through indexed term structures and trail-based state modifications. Concrete tasks include selecting resolution candidates, simplifying clauses, exporting proof states, and applying transformations guided by configurable strategies. Submodules extend these capabilities with ordered clause sets, term indexing, and structured proof manipulations for precise control over reasoning workflows.",
      "description_length": 757,
      "index": 1147,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Higher_order",
      "library": "libzipperposition.calculi",
      "description": "This module orchestrates higher-order term enumeration and pruning strategies for superposition-based theorem proving, coordinating term expansion control with state management for constants and argument functions. It supports key data types like clauses (`C.t`), literals, terms (`Logtk.Term.t`), environments (`Env.C.t`), and ordered clause sets (`ClauseSet.t`), with operations for weight assignment, literal selection, subterm extraction, and clause metadata manipulation. Functionality spans term indexing, clause prioritization via weight functions, redundancy checking, and bidirectional literal-formula conversions, enabling precise control over proof search heuristics and clause lifecycle. Concrete use cases include guided saturation-based reasoning, subsumption checking, trail-driven inference, and dynamic clause set management with event notifications.",
      "description_length": 867,
      "index": 1148,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Heuristics",
      "library": "libzipperposition.calculi",
      "description": "This module controls term depth in logical clauses to prevent excessive complexity during proof search, using the `enable_depth_limit` function to enforce a maximum depth constraint. It integrates submodules for clause indexing, prioritization, and transformation, enabling efficient management of proof states through structures like priority queues, term indexes, and clause sets. Key operations include clause subsumption checks, literal-to-formula conversions, eligibility filtering, and term traversal, supporting tasks like resolution, paramodulation, and rewriting. Examples include prioritizing ground clauses during saturation, extracting subterms for rewriting, and managing dynamic clause sets with reactive updates for real-time strategy adjustments.",
      "description_length": 762,
      "index": 1149,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Bce",
      "library": "libzipperposition.calculi",
      "description": "This module implements blocked clause elimination for simplifying logical formulas by removing redundant clauses that cannot contribute to unsatisfiable cores. It integrates with term and formula structures from the broader library, enabling direct use in proof search preprocessing. Core operations include identifying blocked clauses, applying simplifications, and updating proof states with reduced clause sets. It leverages child modules for term indexing, clause prioritization, and fixpoint computation to support dynamic clause management, heuristic-driven simplification, and efficient retrieval during automated reasoning.",
      "description_length": 631,
      "index": 1150,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Lazy_cnf",
      "library": "libzipperposition.calculi",
      "description": "This module performs lazy CNF transformation on first-order logic formulas using Tseitin encoding, introducing fresh symbols to preserve logical equivalence while eliminating negation, implication, and equivalence. It integrates with submodules that manage clause sets (`ClauseSet.t`), manipulate literals and terms, track proof state metadata, and support term indexing for efficient retrieval and unification. Key operations include clause transformation, redundancy checking, eligibility filtering for resolution, and priority-based selection via customizable weight functions. Example workflows include incremental CNF conversion, dynamic clause prioritization, and resolution-based theorem proving with tracked proof steps and term-level analysis.",
      "description_length": 752,
      "index": 1151,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Bool_encode",
      "library": "libzipperposition.calculi",
      "description": "This module provides utilities for encoding and manipulating Boolean logic expressions, logical connectives (disjunction, negation, implication), and CNF formulas using term and type representations from the `T` and `T.Ty` modules. It supports automated reasoning tasks by enabling booleanization of terms, handling quantifiers, and managing clause-based representations for resolution proofs. Key applications include formal verification and logical formula transformation in theorem proving systems.",
      "description_length": 501,
      "index": 1152,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Fool",
      "library": "libzipperposition.calculi",
      "description": "This module provides core operations for manipulating first-order logic terms and formulas, with support for boolean subterms, term traversal, transformation, and logical simplification. It works directly with `Logtk.Term.t` and related types, enabling deep term inspection and modification for tasks like theorem proving and formal verification. Submodules handle skolemization, literal conversion, clause indexing, weight functions, and eligibility criteria, supporting advanced reasoning techniques such as saturation-based proof search, unification, and subsumption checking. Specific capabilities include term rewriting, clause normalization, stream prioritization, and context-sensitive transformations using customizable hooks and ordered set operations.",
      "description_length": 761,
      "index": 1153,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Qle",
      "library": "libzipperposition.calculi",
      "description": "This module simplifies clauses by eliminating quasipure literals based on their global occurrence patterns, reducing the search space in saturation-based theorem proving. It integrates with submodules that manage clause sets, track proof state, define literal eligibility, and implement term and equation indexing for efficient retrieval and transformation. Key data types include clauses, literals, terms, substitutions, and priority queues, with operations for filtering, comparison, conversion, and weight-based selection. Examples include prioritizing ground clauses during proof search, eliminating redundant literals via subsumption, converting between literal and formula representations, and using term indices to find unifiable clauses or subterms.",
      "description_length": 757,
      "index": 1154,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Pure_literal_elim",
      "library": "libzipperposition.calculi",
      "description": "This module performs pure literal elimination in theorem proving by analyzing and simplifying clause sets based on literal occurrences. It computes occurrence maps over terms, identifies pure literals, and filters clauses, leveraging a polymorphic dictionary structure for tracking symbol data during processing. The dictionary submodule manages identifier-to-value mappings with ordered iteration and customizable merging, enabling efficient aggregation and transformation of term metadata. Example usage includes eliminating redundant clauses by detecting literals that appear consistently with a single polarity across a formula.",
      "description_length": 632,
      "index": 1155,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Hlt_elim",
      "library": "libzipperposition.calculi",
      "description": "This module implements a higher-order logic elimination calculus for theorem proving, centered on HLT elimination through heuristic-guided simplification and redundancy removal. It provides a `Make` functor that configures clause processing with flags, depth limits, and rule modes, operating on clauses, literals, and proof states to drive inference and simplification steps. Child modules support clause prioritization via weight functions and priority queues, efficient term and clause indexing for subsumption and unification, dynamic clause set management with event tracking, and literal eligibility checks to control inference rule application. Specific capabilities include guided clause selection, subterm-aware rewriting, proof state transformation, and integration with term indexing and stream prioritization for scalable automated reasoning.",
      "description_length": 854,
      "index": 1156,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.EnumTypes",
      "library": "libzipperposition.calculi",
      "description": "This module provides mechanisms for handling enumerated types in a theorem prover by replacing exhaustive equality axioms with efficient reasoning strategies, particularly for algebraic data types with fixed constructors. It supports case analysis and term elimination through direct operations and submodules that manage term navigation (`at`), enumerated type declarations (`declare_ty`, `instantiate_vars`), logical context, clause sets, and term indexing. Key data types include `Logtk.Type.t` for type definitions, `Libzipperposition_calculi.EnumTypes.term` for typed terms, and `Env.C.t` for clauses, enabling tasks like automatic case expansion, subterm extraction, and efficient inference over finite domains such as `bool`. Specific capabilities include skolemization, literal selection, clause prioritization via weight functions, and subsumption checking, all integrated to support automated proof search and term rewriting workflows.",
      "description_length": 945,
      "index": 1157,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.App_encode",
      "library": "libzipperposition.calculi",
      "description": "This module offers operations for encoding terms, types, and literals through a type-encoding scheme tailored for applicative handling in higher-order logic. It works with `Logtk.Statement.t` structures, providing functionalities such as type checking, term consistency enforcement during resolution proofs, and insertion of extensionality axioms. These tools are used in theorem proving to transform and extend logical statements while maintaining correctness.",
      "description_length": 461,
      "index": 1158,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libzipperposition_calculi.Pred_elim",
      "library": "libzipperposition.calculi",
      "description": "This module performs blocked clause elimination in first-order logic by identifying and removing redundant clauses that cannot contribute to a refutation, simplifying formulas while preserving satisfiability. It integrates with submodules that manage logical contexts, clause indexing, term manipulation, and priority queues to support automated theorem proving workflows. Key data types include clauses, literals, terms, and substitutions, with operations for skolemization, symbol injectivity, equation prioritization, and dynamic clause set management. Examples include using term indexing for efficient matching, applying weight functions to prioritize clause processing, and leveraging fixpoint-based predicate elimination to simplify logical expressions during proof search.",
      "description_length": 780,
      "index": 1159,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libzipperposition_calculi.Bce_pe_fixpoint",
      "library": "libzipperposition.calculi",
      "description": "This module performs iterative simplifications of propositional logic formulas using blocked clause elimination and positive elimination, reducing clause sets to their minimal equivalent forms. It directly supports operations on clauses, literals, and formulas through structural analysis, eligibility checks, and fixpoint-driven reductions, with utilities for term indexing, priority-based clause processing, and subsumption management. Users can apply transformations like literal normalization, clause prioritization, and redundancy elimination, enabling advanced preprocessing for theorem proving and model checking workflows. Submodules enhance these capabilities with fine-grained control over literals, term orderings, clause metadata, and dynamic clause sets, supporting use cases from proof search to formula normalization.",
      "description_length": 832,
      "index": 1160,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Libzipperposition_calculi",
      "library": "libzipperposition.calculi",
      "description": "This module suite provides a comprehensive framework for automated theorem proving with a focus on first-order and higher-order logic, combining term manipulation, clause management, and logical transformations. Core data types include terms, literals, clauses, substitutions, and proof states, with operations for unification, rewriting, inductive reasoning, and equality handling. It supports advanced proof techniques such as superposition, paramodulation, blocked clause elimination, and lazy CNF conversion, enabling tasks like simplification, normalization, and heuristic-driven proof search. Specific applications include formal verification, automated reasoning with algebraic data types, and efficient handling of equality and Boolean logic through specialized encodings and priority-based processing.",
      "description_length": 810,
      "index": 1161,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 1180,
    "meaningful_modules": 1162,
    "filtered_empty_modules": 18,
    "retention_rate": 0.9847457627118644
  },
  "statistics": {
    "max_description_length": 981,
    "min_description_length": 137,
    "avg_description_length": 461.58089500860586,
    "embedding_file_size_mb": 4.221700668334961
  }
}