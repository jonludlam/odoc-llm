{
  "package": "accessor_core",
  "embedding_model": "Qwen/Qwen3-Embedding-8B",
  "embedding_dimension": 4096,
  "total_modules": 26,
  "creation_timestamp": "2025-08-15T12:20:00.505817",
  "modules": [
    {
      "module_path": "Accessor_core.Command.Param",
      "library": "accessor_core",
      "description": "This module manipulates command-line parameter specifications by applying transformations and aggregations over structured data. It supports operations like mapping, iterating, counting, and reducing over values wrapped in command parameter contexts, enabling composition of command-line interfaces with typed accessors. Concrete use cases include building complex command-line argument parsers with validation, accumulating values from multiple flags, and conditional parameter processing based on index or value.",
      "description_length": 514,
      "index": 0,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Accessor_core.Time_ns.Span",
      "library": "accessor_core",
      "description": "This module provides direct access to time spans in units ranging from nanoseconds to days. It allows extracting or modifying specific components of a time span as floating-point values. Use it to convert between different time units or manipulate durations in a structured way.",
      "description_length": 278,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Accessor_core.Time.Span",
      "library": "accessor_core",
      "description": "This module provides accessors to convert a time span into various time units such as nanoseconds, microseconds, milliseconds, seconds, minutes, hours, and days. It works directly with `Core.Time_float.Span.t` values, exposing them as floats in the target unit. These accessors are useful for extracting duration values in specific units for logging, display, or arithmetic operations.",
      "description_length": 385,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Accessor_core.Quickcheck.Generator",
      "library": "accessor_core",
      "description": "This module provides operations for building Quickcheck generators by mapping, iterating, summing, and reducing over values accessed through general-purpose accessor combinators. It supports both indexed and non-indexed traversals, enabling the generation of structured test data for complex types like containers, records, and variants. Concrete use cases include generating test inputs for property-based testing, where accessors define how to traverse and transform parts of a data structure during generation.",
      "description_length": 513,
      "index": 3,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Accessor_core.Gc.Stat",
      "library": "accessor_core",
      "description": "This module provides direct access to individual fields of the `Core.Gc.Stat.t` type, enabling precise manipulation and retrieval of garbage collection statistics such as memory allocation, collection counts, and heap usage. Each function corresponds to a specific metric like `minor_words`, `heap_words`, or `compactions`, allowing for fine-grained updates or observations within a functional pipeline. It is used when inspecting or transforming GC performance data, such as analyzing memory behavior or tuning application performance based on live heap metrics.",
      "description_length": 563,
      "index": 4,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Accessor_core.Fqueue",
      "library": "accessor_core",
      "description": "This module provides operations to access and transform elements in a functional queue, including mapping, iterating, summing, and reducing over elements with or without indices. It supports data types involving `Core.Fqueue.t` and allows for both pure transformations and effectful computations over queued values. Concrete use cases include processing asynchronous data streams, applying indexed transformations to queued elements, and aggregating values from a queue using custom reduction logic.",
      "description_length": 499,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Accessor_core.Map",
      "library": "accessor_core",
      "description": "This module provides operations for key-based access, indexed transformations, and aggregation over map-like structures, primarily working with `Base.Map.t` and `Core.Map.t`. It supports use cases like conditional value retrieval (`found`), range-restricted traversal (`each_in_subrange`), and constructing maps from folded traversals (`of_accessor_fold`), while enabling indexed computations for keyed summation, boolean counting, or custom reductions over subsets of keys. Key features include handling optional values, managing duplicates during map construction, and performing efficient aggregations with or without key inclusion in computations.",
      "description_length": 651,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Accessor_core.Only_in_test",
      "library": "accessor_core",
      "description": "This module provides operations for mapping, iterating, summing, counting, and reducing over test-only values within an accessor context. It supports both indexed and non-indexed variants of these operations, allowing for parallel or sequential execution. These functions are designed to work on data structures that can be accessed via `Accessor.General.t` and produce results wrapped in `Core.Only_in_test.t`, enabling test-specific computations and assertions.",
      "description_length": 463,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Accessor_core.Fdeque",
      "library": "accessor_core",
      "description": "This module provides operations for element-wise access, transformation, and aggregation in functional deques, supporting indexed and non-indexed traversal, map-reduce workflows, and parallelizable reductions. It works with immutable deque structures (`'at`) and element types (`'a`), using accessors to project and process values. Typical applications include data pipeline construction, parallel sequence processing, and incremental aggregation tasks like summing or counting elements with customizable execution strategies.",
      "description_length": 526,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Accessor_core.Date",
      "library": "accessor_core",
      "description": "This module provides accessors for extracting and modifying the year, month, and day fields of a `Core.Date.t` value. Each accessor allows reading or updating the respective component of a date, using `Date.create_exn` internally to construct new date values. These accessors are useful when working with date transformations or validations that require direct manipulation of individual date components.",
      "description_length": 404,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Accessor_core.Quickcheck",
      "library": "accessor_core",
      "description": "This module builds Quickcheck generators using accessor combinators to map, iterate, sum, and reduce over data structures. It handles complex types such as containers, records, and variants, supporting both indexed and non-indexed traversals. It is used to generate structured test inputs for property-based testing by defining how to access and modify specific parts of a structure during generation.",
      "description_length": 401,
      "index": 10,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Accessor_core.Month",
      "library": "accessor_core",
      "description": "This module provides accessors for each calendar month (e.g., jan, feb, ..., dec) that allow setting or retrieving a specific month value within a larger data structure. It also supports accessing a month shifted by a given number of months forward or backward. These operations are useful when manipulating date-like values where month alignment or traversal is required, such as in scheduling or time-series data processing.",
      "description_length": 426,
      "index": 11,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Accessor_core.Gc",
      "library": "accessor_core",
      "description": "This module exposes precise accessors for individual fields of the `Core.Gc.Stat.t` type, enabling direct reads and updates of specific garbage collection metrics such as `minor_words`, `heap_words`, and `compactions`. It supports functional transformations and inspections of GC statistics, useful for performance analysis or adaptive memory management strategies.",
      "description_length": 365,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Accessor_core.Nothing",
      "library": "accessor_core",
      "description": "This module provides a single value `unreachable` that represents an accessor which can theoretically access any field but always results in a `Nothing` type, effectively modeling impossible or unattainable data paths. It works with the `Nothing` type and is used in scenarios where an accessor must be provided but cannot produce a meaningful result, such as in placeholder implementations or exhaustive pattern matching where certain cases are proven unreachable.",
      "description_length": 465,
      "index": 13,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Accessor_core.Unit_of_time",
      "library": "accessor_core",
      "description": "This module provides accessors for manipulating individual time units within a `Core.Unit_of_time.t` value, including nanoseconds, microseconds, milliseconds, seconds, minutes, hours, and days. Each accessor allows getting or setting a specific time component as a function of a record or structure containing time data. Concrete use cases include extracting or modifying a specific time unit, such as adjusting the number of milliseconds in a duration or retrieving the hour component from a time interval.",
      "description_length": 507,
      "index": 14,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Accessor_core.Host_and_port",
      "library": "accessor_core",
      "description": "This module provides accessors for working with `Host_and_port.t` values, allowing direct manipulation of the `host` and `port` fields. It supports extracting or updating the host as a string and the port as an integer, as well as converting between a `Host_and_port.t` and a `(string * int)` tuple. Concrete use cases include validating network endpoints, transforming connection addresses, and extracting components for logging or serialization.",
      "description_length": 447,
      "index": 15,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Accessor_core.Percent",
      "library": "accessor_core",
      "description": "This module provides accessors to convert between percentages and various scaled numeric representations. It supports operations to view a percentage as a float, a percentage scaled by 100, a percentage scaled by 10,000 (basis points), and a custom scaled value. These functions are useful when interfacing with financial calculations or data formats that represent percentages in different numeric forms, such as displaying or parsing values in configuration files or APIs.",
      "description_length": 474,
      "index": 16,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Accessor_core.Blang",
      "library": "accessor_core",
      "description": "This module implements monadic transformations and aggregations over data structures using Blang computations. It provides operations like `map`, `iter`, `sum`, `count`, and `map_reduce` that apply functions across values accessed through general accessors, supporting both indexed and non-indexed variants. These functions are designed for working with containers that have multiple elements, enabling parallel or sequential execution strategies, counting elements matching a predicate, summing values, or reducing with custom logic.",
      "description_length": 534,
      "index": 17,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Accessor_core.Day_of_week",
      "library": "accessor_core",
      "description": "This module provides direct accessors for each day of the week (e.g., `sun`, `mon`, etc.) as first-class values, allowing manipulation and transformation of `Day_of_week.t` values within functional pipelines. It works specifically with the `Day_of_week.t` enumerated type representing days of the week. Concrete use cases include selecting, mapping, or folding over specific weekdays in scheduling or calendar-related logic.",
      "description_length": 424,
      "index": 18,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Accessor_core.Command",
      "library": "accessor_core",
      "description": "This module processes command-line parameters by transforming and aggregating structured data through operations like mapping, iteration, counting, and reduction. It works with typed command parameter contexts, enabling composition of command-line interfaces with precise accessors. Use cases include constructing validated argument parsers, accumulating values from multiple flags, and conditionally processing parameters based on index or value.",
      "description_length": 447,
      "index": 19,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Accessor_core.Time_ns",
      "library": "accessor_core",
      "description": "This module provides accessors to convert between `Time_ns.t` values and their components, such as spans since epoch, date, and time of day, using a specified time zone. It supports operations to extract or modify date and time fields directly or as composite values. Concrete use cases include formatting timestamps, calculating durations relative to the epoch, and breaking down times into human-readable components.",
      "description_length": 418,
      "index": 20,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Accessor_core.Time",
      "library": "accessor_core",
      "description": "This module provides accessors to extract and manipulate time values in various representations, such as spans since epoch, date and time-of-day components, and date or time-of-day fields individually. It operates on `Core.Time_float.t` values and uses `Core.Time_float.Zone.t` to interpret dates in specific time zones. These accessors are useful for tasks like formatting timestamps, performing time arithmetic, or extracting duration values in specific units.",
      "description_length": 462,
      "index": 21,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Accessor_core.Pid",
      "library": "accessor_core",
      "description": "This module provides an accessor to convert a process ID to its integer representation. It works with `Core.Pid.t` values, exposing the underlying `int` value. Useful when interfacing with low-level system calls or logging mechanisms that require numeric process identifiers.",
      "description_length": 275,
      "index": 22,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Accessor_core.List",
      "library": "accessor_core",
      "description": "This module provides structural manipulation, indexed element access, and transformation operations for lists and list-like structures. It supports parallel and sequential map-reduce workflows, element-wise zipping of non-empty lists, and aggregation with user-defined combining functions, enabling efficient processing of indexed data and parallelizable list computations.",
      "description_length": 373,
      "index": 23,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Accessor_core.Byte_units",
      "library": "accessor_core",
      "description": "This module provides accessors for converting between byte quantities and various units like kilobytes, megabytes, and gigabytes, all the way up to exabytes. It works with `Core.Byte_units.t`, allowing both integer and floating-point representations of storage sizes. These accessors are useful for precise memory or disk size manipulations where unit conversion and bounds checking are critical, such as in system monitoring or resource allocation.",
      "description_length": 449,
      "index": 24,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Accessor_core",
      "library": "accessor_core",
      "description": "This module provides accessor combinators for structured data manipulation, enabling composition, mapping, and isomorphisms to access, transform, and aggregate values within nested data structures. It operates on composite types like records, variants, and collections, alongside domain-specific representations such as dates, byte units, and system metrics. Use cases include querying and modifying deeply nested fields, performing index-aware traversals over collections, and building transformation pipelines for data conversion or aggregation tasks like summation, filtering, or existence checks.",
      "description_length": 600,
      "index": 25,
      "embedding_norm": 0.9999999403953552
    }
  ],
  "filtering": {
    "total_modules_in_package": 26,
    "meaningful_modules": 26,
    "filtered_empty_modules": 0,
    "retention_rate": 1.0
  },
  "statistics": {
    "max_description_length": 651,
    "min_description_length": 275,
    "avg_description_length": 456.2692307692308,
    "embedding_file_size_mb": 0.3771944046020508
  }
}