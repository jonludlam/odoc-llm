{
  "package": "yices2",
  "embedding_model": "Qwen/Qwen3-Embedding-8B",
  "embedding_dimension": 4096,
  "total_modules": 16,
  "creation_timestamp": "2025-08-14T23:24:01.562993",
  "modules": [
    {
      "module_path": "Yices2.Term.Fun",
      "library": "yices2",
      "description": "This module handles the creation and manipulation of function terms in Yices, including function application, updates, and lambda expressions. It operates on arrays of terms and types to construct complex function representations. Use cases include building symbolic functions for SMT solving and defining term transformations within logical expressions.",
      "description_length": 354,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Yices2.Term.Bitvector",
      "library": "yices2",
      "description": "This module enables bit-level arithmetic, bitwise manipulation, and structural transformations of bit-vector terms, including operations like signed/unsigned division, logical shifts, and concatenation. It works with bit-vectors represented as `Yices2.term` values, supporting conversions from integers, booleans, and binary/hex strings while providing reduction operations and comparison operators. These capabilities are particularly useful for formal verification of hardware circuits, cryptographic algorithms, or low-level system code where precise bit-level reasoning is required.",
      "description_length": 586,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Yices2.Term.RatioPoly",
      "library": "yices2",
      "description": "Constructs rational polynomial terms from coefficient arrays and variable terms. Supports integer types (int, int32, int64, nativeint) and exact rationals via Q.t. Used to build polynomial expressions for SMT solving with Yices.",
      "description_length": 228,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Yices2.Context.Config",
      "library": "yices2",
      "description": "Manages configuration settings for SMT solver contexts. It provides functions to create a configuration object, set key-value pairs, and apply default settings for a given logic. Use when initializing or customizing solver behavior for specific SMT problems.",
      "description_length": 258,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Yices2.Term.Ratio",
      "library": "yices2",
      "description": "This module constructs rational number terms from various integer and string representations, supporting exact rationals and floating-point conversions. It operates on `Yices2.term` values, using integer pairs, GMP-style rationals (`Q.t`), or string inputs. Concrete use cases include creating rational constants for SMT solvers from integers or parsing them from textual specifications.",
      "description_length": 387,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Yices2.Term.Tuple",
      "library": "yices2",
      "description": "This module provides operations to create, access, and modify tuples in the Yices2 SMT solver. It works with arrays of terms to construct tuples, supports selecting elements by index, and allows updating specific positions with new terms. Concrete use cases include modeling fixed-size collections of values in SMT formulas, such as representing memory states or structured data in formal verification tasks.",
      "description_length": 408,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Yices2.Context.Params",
      "library": "yices2",
      "description": "This module manages configuration parameters for a context, supporting creation and modification of parameter records. It works with string-keyed parameter values, allowing dynamic settings adjustments. Useful for configuring solver behavior before execution, such as setting timeout limits or enabling specific solving strategies.",
      "description_length": 331,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Yices2.Term.Bool",
      "library": "yices2",
      "description": "This module enables the construction of Boolean expressions through propositional logic operations (conjunctions, disjunctions, negations), term-level conditionals (`ite`), and both universal/existential quantifiers over arbitrary types. It operates on `Yices2.term` values and `Yices2.Type.t` instances, supporting logical formulas with equality predicates, quantified variables, and nested conditional expressions. Typical applications include symbolic reasoning engines, formal verification of software/hardware, and constraint-based type systems requiring precise logical encodings.",
      "description_length": 586,
      "index": 7,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Yices2.Term.Int",
      "library": "yices2",
      "description": "This module converts integer values of various types into Yices2 terms. It supports conversions from standard OCaml integer types (`int`, `int32`, `int64`, `nativeint`) and arbitrary-precision integers (`Z.t`). Use this module when constructing integer expressions for use in Yices2's SMT solver, such as encoding numeric constraints or symbolic values.",
      "description_length": 353,
      "index": 8,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Yices2.Term.Poly",
      "library": "yices2",
      "description": "This module constructs integer polynomial terms from coefficient arrays and term arrays, supporting operations with various integer types such as `int`, `int32`, `int64`, `nativeint`, and `Z.t`. Each function creates a polynomial by combining the given coefficients with corresponding terms. It is used to build complex arithmetic expressions for SMT solving, where coefficients are applied to variables or constants in the term array.",
      "description_length": 435,
      "index": 9,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Yices2.Error",
      "library": "yices2",
      "description": "This module defines error codes and detailed error reports for invalid operations or malformed inputs in term and type manipulations. It includes specific errors for type mismatches, invalid indices, overflow conditions, and unsupported operations across arithmetic, bitvector, and solver contexts. Use cases include handling failed term construction, diagnosing solver configuration issues, and reporting syntax or type errors during formula evaluation.",
      "description_length": 454,
      "index": 10,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Yices2.Type",
      "library": "yices2",
      "description": "This module enables constructing and inspecting types such as integers, booleans, bitvectors, tuples, and functions, along with named type management via parsing and naming operations. It provides utilities to check type properties (e.g., `is_int`, `is_bitvector`), query subtyping relationships, retrieve bitvector sizes, and format types for display, all centered around the `Yices2.typ` data structure. These operations are critical for formal verification workflows requiring dynamic type creation, term typing, and symbolic reasoning.",
      "description_length": 539,
      "index": 11,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Yices2.Model",
      "library": "yices2",
      "description": "This module provides functions to extract values from a model, including booleans, integers, rationals, floats, and bitvectors, all based on a `Yices2.model` and `Yices2.term`. It supports precise value retrieval for terms, including scalar, numeric, and term-based outputs. Use cases include interpreting results from SMT solver queries, extracting concrete values for analysis, and integrating model outputs into typed OCaml data structures.",
      "description_length": 443,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Yices2.Context",
      "library": "yices2",
      "description": "This module creates and manages SMT solver contexts, supporting operations like assertion of formulas, stack manipulation for backtracking, and enabling/disabling solver options. It works with terms representing logical formulas, arrays of terms, and context objects that hold solver state. Concrete use cases include setting up and solving constraint systems incrementally, managing solver parameters dynamically, and retrieving models after satisfiability checks.",
      "description_length": 465,
      "index": 13,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Yices2.Experimental",
      "library": "yices2",
      "description": "Resets the Yices solver state to its initial configuration, clearing all assertions and variables. This operation is used to reuse a solver instance for solving different constraint problems sequentially. It works directly with the internal state of the SMT solver managed by the Yices2 module.",
      "description_length": 294,
      "index": 14,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Yices2",
      "library": "yices2",
      "description": "This module implements bindings to the Yices SMT solver, enabling type and term construction, constraint assertion, and model extraction. It provides low-level access to solver operations through types like `typ`, `term`, `context`, and `model`, supporting tasks such as incremental solving, type inspection, and value retrieval from models. Concrete use cases include formal verification of software properties, symbolic execution, and automated reasoning over arithmetic, bitvector, and Boolean constraints.",
      "description_length": 509,
      "index": 15,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 18,
    "meaningful_modules": 16,
    "filtered_empty_modules": 2,
    "retention_rate": 0.8888888888888888
  },
  "statistics": {
    "max_description_length": 586,
    "min_description_length": 228,
    "avg_description_length": 414.375,
    "embedding_file_size_mb": 0.23227405548095703
  }
}