{
  "package": "cloudi",
  "embedding_model": "BAAI/bge-base-en-v1.5",
  "embedding_dimension": 1024,
  "total_modules": 8,
  "creation_timestamp": "2025-06-18T16:30:56.626004",
  "modules": [
    {
      "module_path": "Cloudi.Instance",
      "description": "Provides functions to create, modify, and query instances of a stateful type 's t, including lifting values into instances, applying transformations, and extracting underlying values. Works with a parameterized type that encapsulates a state and associated operations. Used to manage mutable state in a controlled manner during event processing and configuration setup.",
      "description_length": 369,
      "index": 0,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Erlang.Pid",
      "description": "Provides functions to create, compare, and convert process identifiers, including parsing from strings and generating unique identifiers. Works with the `t` type, representing process IDs internally as opaque values. Used to manage system process tracking and inter-process communication identifiers.",
      "description_length": 300,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Erlang.Port",
      "description": "Provides functions to parse, validate, and manipulate port numbers, including conversion from strings, range checking, and comparison. Works with integers and string representations of ports, ensuring values fall within the 0\u201365535 range. Used to enforce valid port configurations in networked applications and to parse user-provided port inputs.",
      "description_length": 346,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Erlang.Reference",
      "description": "Provides functions to create, read, and update mutable references, including `get`, `set`, and `update`. Works with the `t` type, a private record containing a single mutable value. Used to manage shared state in imperative code, such as tracking counters or configuration settings across different parts of a program.",
      "description_length": 318,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Erlang.Function",
      "description": "Provides functions for composing, currying, and partially applying unary and binary operations, along with function inversion. Works with first-class functions and closures, supporting type-safe execution and transformation. Used to create reusable operation pipelines and implement callback-based control flow in event-driven systems.",
      "description_length": 335,
      "index": 4,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "cloudi",
      "description": "Handles asynchronous message passing between processes using a publish-subscribe model. It operates on topics, messages, and process identifiers, enabling real-time communication in distributed systems. Used to route notifications, trigger event handlers, and coordinate tasks across nodes in a cloud environment.",
      "description_length": 313,
      "index": 5,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Cloudi",
      "description": "manages mutable state through a parameterized type that encapsulates a state and its operations, enabling controlled modifications and queries. It supports lifting values into stateful instances, applying transformations, and extracting base values. Operations include state updates, value extraction, and composition of stateful actions. This allows for structured handling of dynamic configurations and event-driven state changes.",
      "description_length": 432,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Erlang",
      "description": "manages process identifiers, port numbers, mutable references, and function transformations, offering type-safe operations for system communication, network configuration, state management, and functional composition. It handles `t` types for process IDs and references, integers and strings for ports, and first-class functions for operation manipulation. Users can generate unique process IDs, validate port inputs, manage shared state through references, and build complex function pipelines. Examples include tracking inter-process communication, ensuring valid network ports, updating global counters, and creating curried operations for event handling.",
      "description_length": 658,
      "index": 7,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 8,
    "meaningful_modules": 8,
    "filtered_empty_modules": 0,
    "retention_rate": 1.0
  },
  "statistics": {
    "max_description_length": 658,
    "min_description_length": 300,
    "avg_description_length": 383.875,
    "embedding_file_size_mb": 0.0294647216796875
  }
}