{
  "package": "hardcaml_event_driven_sim",
  "embedding_model": "Qwen/Qwen3-Embedding-8B",
  "embedding_dimension": 4096,
  "total_modules": 72,
  "creation_timestamp": "2025-08-15T15:39:15.285961",
  "modules": [
    {
      "module_path": "Event_driven_sim.Mini_async.Deferred.Let_syntax.Let_syntax",
      "library": "hardcaml_event_driven_sim.kernel",
      "description": "This module provides monadic operations for working with deferred values, including binding, mapping, and combining asynchronous results. It supports concrete use cases like sequencing asynchronous computations, transforming deferred values, and parallel composition of two deferred actions. The primary data type it operates on is `'a Event_driven_sim.Mini_async.Deferred.t`.",
      "description_length": 376,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Event_driven_sim.Mini_async.Deferred.Let_syntax",
      "library": "hardcaml_event_driven_sim.kernel",
      "description": "This module provides monadic operations for sequencing, transforming, and combining asynchronous computations represented by `'a Event_driven_sim.Mini_async.Deferred.t`. It includes functions like `return`, `>>=`, and `>>|` to bind, map, and chain deferred actions, enabling precise control over asynchronous workflows. Concrete use cases include building event-driven simulations where asynchronous steps must be composed in sequence or in parallel, such as handling I/O events or scheduling timed actions.",
      "description_length": 507,
      "index": 1,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Event_driven_sim.Mini_async.Deferred.Monad_infix",
      "library": "hardcaml_event_driven_sim.kernel",
      "description": "This module provides monadic composition operators for sequencing asynchronous computations that produce values in the future. It works with the `Deferred.t` type, representing pending values, and functions that transform or chain these deferred computations. Concrete use cases include writing asynchronous workflows where one operation must complete before another starts, or mapping results of asynchronous operations without blocking.",
      "description_length": 438,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Event_driven_sim.Simulator.Process",
      "library": "hardcaml_event_driven_sim.kernel",
      "description": "Manages processes within an event-driven simulation environment, providing functions to create and schedule processes that react to signal changes. Works with signal identifiers and process types to define behaviors triggered by specific signal events. Used to model concurrent hardware components that update state in response to input changes, such as combinational logic blocks or clocked registers.",
      "description_length": 402,
      "index": 3,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Event_driven_sim.Simulator.Signal_id",
      "library": "hardcaml_event_driven_sim.kernel",
      "description": "Manages unique identifiers for signals in an event-driven simulation environment. Provides operations to create, compare, and generate signal IDs, ensuring each signal has a distinct identity. Used to track and differentiate signals during simulation steps, particularly when propagating changes and resolving event dependencies.",
      "description_length": 329,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Event_driven_sim.Simulator.Async",
      "library": "hardcaml_event_driven_sim.kernel",
      "description": "This module provides asynchronous process creation and timing control for event-driven simulations. It supports operations like delaying execution by a number of time steps, waiting for signal changes, and running infinite loops. It works with signals and processes, enabling behaviors such as timed event triggering and continuous monitoring of signal states.",
      "description_length": 360,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Event_driven_sim.Simulator.Change_monitor",
      "library": "hardcaml_event_driven_sim.kernel",
      "description": "Monitors changes in signal values during event-driven simulations. It provides functions to create a monitor for a list of signal IDs and wait asynchronously until any monitored signal changes. This module is used to synchronize simulation steps based on signal transitions, such as triggering component updates or capturing state changes in hardware models.",
      "description_length": 358,
      "index": 6,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Event_driven_sim.Mini_async.Deferred",
      "library": "hardcaml_event_driven_sim.kernel",
      "description": "This module implements asynchronous computations that produce values in the future using the `Deferred.t` type. It supports sequencing with `>>=`, mapping with `>>|`, and composing multiple deferred actions in parallel with `all` and `all_unit`. Concrete use cases include scheduling timed events, handling I/O completions, and structuring event-driven simulations where operations must run in a specific order without blocking.",
      "description_length": 428,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Event_driven_sim.Mini_async.Ivar",
      "library": "hardcaml_event_driven_sim.kernel",
      "description": "This module implements a simple asynchronous variable (ivar) for managing single-assignment values in an event-driven simulation. It allows creating an ivar, filling it with a value once, checking if it has been filled, and reading its value asynchronously. Concrete use cases include coordinating asynchronous computations and simulating event completion in a non-blocking manner.",
      "description_length": 381,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Event_driven_sim.Simulator.Signal",
      "library": "hardcaml_event_driven_sim.kernel",
      "description": "Handles signal creation, reading, and identity management for event-driven simulations. Works with typed signals that store and update values over simulation time steps. Used to model and track changes in signal values, such as in digital circuit simulations where signal transitions drive event scheduling.",
      "description_length": 307,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Event_driven_sim.Simulator.Expert",
      "library": "hardcaml_event_driven_sim.kernel",
      "description": "This module provides low-level scheduling operations for event-driven simulation, including functions to schedule signal updates and delayed function calls. It operates on simulation contexts and signals, enabling precise control over event timing and execution order. Use cases include implementing custom simulation behaviors, managing asynchronous events, and coordinating state changes in hardware models.",
      "description_length": 409,
      "index": 10,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Event_driven_sim.Simulator.Debug",
      "library": "hardcaml_event_driven_sim.kernel",
      "description": "This module provides debugging utilities for event-driven simulations, including functions to register callbacks at the start and end of time steps and to create processes that print signal changes. It works with simulation frameworks that use signals and processes, particularly for tracking and logging signal state transitions. Use cases include monitoring signal activity during simulation and injecting custom logging or analysis logic at specific simulation milestones.",
      "description_length": 475,
      "index": 11,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Event_driven_sim.Simulator.Version_signal",
      "library": "hardcaml_event_driven_sim.kernel",
      "description": "Tracks changes in external data state using a signal abstraction. Provides `create` to initialize a signal and `increment` to update its state. Useful for modeling versioned data dependencies in event-driven simulations, such as tracking signal transitions in hardware description workflows.",
      "description_length": 291,
      "index": 12,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Event_driven_sim.Mini_async",
      "library": "hardcaml_event_driven_sim.kernel",
      "description": "This module provides asynchronous programming primitives for building event-driven simulations. It includes `Deferred` for sequencing and composing non-blocking computations and `Ivar` for managing single-assignment variables that enable coordination between asynchronous tasks. Use it to model timed events, simulate I/O operations, and manage dependencies between asynchronous simulation steps.",
      "description_length": 396,
      "index": 13,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Event_driven_sim.Simulator",
      "library": "hardcaml_event_driven_sim.kernel",
      "description": "This module provides operations for time progression, signal manipulation, and process scheduling in event-driven simulations. It works with signals, processes, and versioned data structures to model digital circuits with precise timing and dependency tracking. Specific use cases include hardware simulation workflows requiring synchronization, logging signal transitions, and debugging state changes at simulation milestones.",
      "description_length": 427,
      "index": 14,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Event_driven_sim",
      "library": "hardcaml_event_driven_sim.kernel",
      "description": "This module implements event-driven simulations using asynchronous programming primitives and time-based coordination structures. It provides deferred computations and single-assignment synchronization variables alongside time progression control, signal tracking, and process scheduling. Concrete use cases include modeling digital circuits with precise timing, simulating I/O-bound processes, and debugging temporal dependencies in stateful systems.",
      "description_length": 451,
      "index": 15,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Make.With_interface.Output.Of_signal",
      "library": "hardcaml_event_driven_sim",
      "description": "This module enables the construction of complex signal networks through combinational logic, multiplexing, and register insertion, while supporting hierarchical signal naming and structured port connectivity. It operates on signals (`Hardcaml.Signal.t`) and output containers (`Output.Of_signal.t`), facilitating tasks like dynamic signal routing, register pipeline creation, and value conversion between integer representations. Use cases include implementing register-transfer level circuits (e.g., ALUs, state machines) and organizing large designs with named signal hierarchies for clarity and modularity.",
      "description_length": 609,
      "index": 16,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Make.With_interface.Output.Of_always",
      "library": "hardcaml_event_driven_sim",
      "description": "This module defines operations for constructing and manipulating event-driven simulation outputs from always blocks. It provides functions to assign signals to variables, create registers and wires, and access signal values with precise naming control. Use this to model sequential and combinational logic with named signals in hardware simulations.",
      "description_length": 349,
      "index": 17,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Make.With_interface.Output.Names_and_widths",
      "library": "hardcaml_event_driven_sim",
      "description": "This module provides direct access to metadata about output ports in a hardware simulation, specifically listing port names paired with their widths, or separately listing names and widths. It works with standard OCaml lists of strings and integers, along with a list of output tag values. Concrete use cases include inspecting the structure of simulation outputs, mapping signals to their bit widths, and generating reports or visualizations based on output port configurations.",
      "description_length": 479,
      "index": 18,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Make.With_interface.Output.Of_bits",
      "library": "hardcaml_event_driven_sim",
      "description": "This module provides operations for constructing and manipulating bit vector outputs in a hardware description context. It supports values of type `t`, representing bit vectors with combinational logic, and includes functions for packing/unpacking bits, multiplexing, concatenation, and priority/one-hot selection. Concrete use cases include building register files, implementing control logic, and modeling digital circuits with precise bit-level representations.",
      "description_length": 464,
      "index": 19,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Make.With_interface.Output.Unsafe_assoc_by_port_name",
      "library": "hardcaml_event_driven_sim",
      "description": "Converts between output signals and string-keyed lists, enabling direct mapping of signal values to named ports. Works with any output type `'a Output.t` and string-value pairs. Useful for debugging or serialization where port names must align with external representations.",
      "description_length": 274,
      "index": 20,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Make.With_interface.Input.Of_signal",
      "library": "hardcaml_event_driven_sim",
      "description": "This module provides combinational logic synthesis, sequential circuit construction, and signal routing capabilities for hardware design. It operates on hardware signal types and input interface wrappers (`Input.Of_signal.t`), enabling operations like signal conversion, multiplexer generation, register pipeline creation, and IO port connection with hierarchical naming. Typical applications include constructing synchronous digital circuits, implementing control logic with priority encoders, and managing signal interface hierarchies in simulation environments.",
      "description_length": 564,
      "index": 21,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Make.With_interface.Input.Of_always",
      "library": "hardcaml_event_driven_sim",
      "description": "This module provides functions to manipulate input signals within an event-driven simulation, specifically handling assignments, registers, and wire declarations. It works with `Always.Variable.t` and `Signal.t` types to model hardware behavior in a structured way. Concrete use cases include defining combinational logic with `assign`, creating sequential elements with `reg`, and connecting signals through `wire`.",
      "description_length": 416,
      "index": 22,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Make.With_interface.Logic.Unsigned",
      "library": "hardcaml_event_driven_sim",
      "description": "This module provides operations for performing arithmetic and comparison on unsigned integer values represented as logic signals. It supports addition, subtraction, multiplication, and comparisons like less than, greater than, and equality. These functions are used to model and simulate digital circuits where unsigned integers are manipulated directly as hardware signals.",
      "description_length": 374,
      "index": 23,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Make.With_interface.Input.Of_bits",
      "library": "hardcaml_event_driven_sim",
      "description": "This module provides functions to construct and manipulate bit vector inputs in a hardware description context. It supports operations like packing/unpacking bit vectors, multiplexing, concatenation, and selection from one-hot or priority-encoded inputs. Concrete use cases include defining testbenches with specific input patterns, modeling register file outputs, and implementing control logic with encoded selections.",
      "description_length": 420,
      "index": 24,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Make.With_interface.Logic.Signed",
      "library": "hardcaml_event_driven_sim",
      "description": "This module provides operations for working with signed logic values in an event-driven simulation environment. It supports arithmetic operations like addition, subtraction, and multiplication, as well as comparison operators for equality and ordering. These functions operate on the abstract type `v`, which represents signed logic signals, enabling simulation of digital circuits with signed integer behavior. A typical use case involves modeling and simulating signed arithmetic logic units or data paths in hardware designs.",
      "description_length": 528,
      "index": 25,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Make.With_interface.Input.Make_comb",
      "library": "hardcaml_event_driven_sim",
      "description": "This module provides combinational logic operations for manipulating input signals in a hardware description context. It supports data types like `comb Input.t` for representing structured input signals and includes functions for packing/unpacking, multiplexing, concatenation, and selection operations. Concrete use cases include building complex signal routing logic, such as priority encoders, multiplexers, and bit-level manipulations in digital circuit design.",
      "description_length": 465,
      "index": 26,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Make.With_interface.Logic.Sop",
      "library": "hardcaml_event_driven_sim",
      "description": "This module provides operations for constructing and manipulating logic expressions using a signal-based representation. It supports arithmetic operations like addition, subtraction, and multiplication, as well as comparison operators for equality and ordering. These functions operate on `Logic.t` values, enabling direct translation between signals and logic expressions, with resizing capabilities for bit-width adjustments. Use cases include building combinational logic circuits and performing bit-level manipulations in hardware descriptions.",
      "description_length": 548,
      "index": 27,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Make.With_interface.Output.All",
      "library": "hardcaml_event_driven_sim",
      "description": "Converts a record of outputs into an output of records. Works with any module M that implements the Output signature. Useful for combining multiple signal outputs into a single structured output value.",
      "description_length": 201,
      "index": 28,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Make.With_interface.Input.All",
      "library": "hardcaml_event_driven_sim",
      "description": "This module provides a function `all` that transforms a nested structure of input signals into a single input signal of a structured type. It operates on data types involving `'a M.t Input.t`, where `M` is a module encapsulating signal types. Use it to aggregate multiple input signals into a unified signal for simulation or testing purposes.",
      "description_length": 343,
      "index": 29,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Make.With_interface.Logic.Uop",
      "library": "hardcaml_event_driven_sim",
      "description": "This module provides unary and binary logic operations on `Logic.t` signals, including arithmetic, comparison, and resizing. It supports operations like addition, subtraction, multiplication, and comparisons (e.g., less than, equal to) between `Logic.t` values. These functions are used to model and simulate digital logic circuits with signal transformations and value manipulations.",
      "description_length": 384,
      "index": 30,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Make.With_interface.Input.Names_and_widths",
      "library": "hardcaml_event_driven_sim",
      "description": "This module defines and exposes input port metadata for hardware simulation, including port names, widths, and associated tags. It provides direct access to lists of port names, widths, and combined name-width pairs, along with a list of input tags. It is used to configure and inspect input interfaces in event-driven simulations, enabling precise signal mapping and testbench generation.",
      "description_length": 389,
      "index": 31,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Waveterm.Render.Static.R",
      "library": "hardcaml_event_driven_sim",
      "description": "This module offers operations for rendering waveform elements like clock cycles and binary data into a terminal UI canvas, along with interactive selection capabilities to identify elements (signals, values) at specific coordinates. It processes simulation data structures (`Waves.t`, `Events.t`) using dimension calculations, alignment, and styling to generate visual layouts, while supporting use cases like real-time waveform inspection and coordinate-driven analysis in event-driven simulations.",
      "description_length": 499,
      "index": 32,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Make.With_interface.Input.Unsafe_assoc_by_port_name",
      "library": "hardcaml_event_driven_sim",
      "description": "Converts between input structures and association lists mapping port names to values. Works with any type `'a Input.t` and string-keyed lists of values. Useful for dynamically constructing or inspecting input configurations by port name.",
      "description_length": 237,
      "index": 33,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Make.With_interface.Output.Make_comb",
      "library": "hardcaml_event_driven_sim",
      "description": "This module implements combinational logic operations for manipulating signal outputs in a hardware description context. It supports operations like packing/unpacking signals, multiplexing, concatenation, and selection from one-hot or priority-encoded inputs. The module works directly with combinational logic values and output interfaces, enabling precise control over signal routing and transformation in digital circuit design.",
      "description_length": 431,
      "index": 34,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Make.With_interface.Input",
      "library": "hardcaml_event_driven_sim",
      "description": "This module provides operations for transforming, combining, and folding over structured input signals with named ports, supporting conversions to association lists, S-expressions, and bit vector representations. It works with `'a Input.t` structures that encapsulate hierarchical signal data, enabling combinational logic synthesis, testbench signal aggregation, and dynamic interface inspection via metadata queries. Key use cases include hardware simulation testbenches, signal mapping by port names, and runtime generation of input interfaces with variable widths and tags.",
      "description_length": 577,
      "index": 35,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Waveterm.Waves.Config",
      "library": "hardcaml_event_driven_sim",
      "description": "This module defines configuration parameters for rendering waveforms in a terminal-based simulation viewer. It includes mutable fields for dimensions and scroll positions, along with serialization functions for saving and loading configurations. The module is used to customize the visual layout and interaction with signal waveforms during simulation debugging.",
      "description_length": 362,
      "index": 36,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Make.With_interface.Output",
      "library": "hardcaml_event_driven_sim",
      "description": "This module enables transforming, combining, and inspecting simulation outputs through operations like n-ary mapping, folding, bit vector manipulation, and combinational logic synthesis. It operates on structured data types including `Output.t`, association lists of named signals, and bit vectors, facilitating precise modeling of sequential and combinational circuits in event-driven hardware simulations. Specific utilities support introspecting port metadata (names, widths) for visualization, constructing",
      "description_length": 510,
      "index": 37,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Make.With_interface.Ops",
      "library": "hardcaml_event_driven_sim",
      "description": "This module provides operations for converting circuits into event-driven simulation processes and managing signal mappings. It works with simulation states, circuits, and signals, enabling the creation of process lists and signal translation. Concrete use cases include simulating hardware behavior by converting circuit descriptions into executable simulation processes with customizable delays and external instantiations.",
      "description_length": 425,
      "index": 38,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Waveterm.Render.Styles",
      "library": "hardcaml_event_driven_sim",
      "description": "This module defines and constructs style configurations for rendering waveform displays in a terminal-based simulation environment. It provides functions to customize visual elements such as borders, signals, values, waves, and status indicators using color and drawing styles. Specific use cases include setting up high-contrast waveforms for better visibility, applying color schemes like black-on-white or white-on-black, and dynamically adjusting styles for different display contexts.",
      "description_length": 489,
      "index": 39,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Waveterm.Render.Static",
      "library": "hardcaml_event_driven_sim",
      "description": "This module renders waveform data, including clock cycles and binary values, into a terminal UI canvas using `Waves.t` and `Events.t` structures. It supports drawing waveforms with configurable dimensions, alignment, and styling, and enables interactive element selection based on coordinates. Use cases include real-time simulation visualization and coordinate-based signal analysis.",
      "description_length": 384,
      "index": 40,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Waveterm.Render.Make",
      "library": "hardcaml_event_driven_sim",
      "description": "This module provides structured layout calculations and graphical rendering for waveform visualization, handling simulation data like clock cycles, binary signals, and status indicators. It operates on simulation state data structures and UI components using 2D graphics primitives, enabling use cases such as interactive signal inspection and time-aligned waveform display in simulation debuggers. Key operations include precise dimensioning, styled waveform drawing, and coordinate-based element picking to support interactive analysis of digital signal behavior.",
      "description_length": 565,
      "index": 41,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Make.With_interface.Logic",
      "library": "hardcaml_event_driven_sim",
      "description": "This module offers bitvector arithmetic, logic synthesis, and signal manipulation capabilities for digital circuit design and simulation. It operates on fixed-width bitvector values (`Logic.t`) with support for bitwise operations, arithmetic conversions, and structural transformations like shifting, concatenation, and encoding. Key applications include hardware verification, combinational logic construction, and modeling digital signals with precise control over bit-level representations and signed/unsigned behavior.",
      "description_length": 522,
      "index": 42,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Waveterm.Render.Bounds",
      "library": "hardcaml_event_driven_sim",
      "description": "This module manages layout calculations for waveform rendering by defining and adjusting rectangular regions for signals, values, waves, and status within a display window. It provides operations to expand or shrink areas to account for borders and fits the layout within a specified window size. Concrete use cases include adjusting UI elements to prevent overlap and ensuring proper spacing for visual clarity in waveform displays.",
      "description_length": 433,
      "index": 43,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Make.With_interface",
      "library": "hardcaml_event_driven_sim",
      "description": "This module implements event-driven simulation workflows for hardware verification with explicit input/output interfaces. It manages simulation processes, clock generation, and signal mappings for structured interfaces with named ports and bitvector signals. Concrete use cases include building testbenches with waveform visualization (VCD, Waveterm), verifying expected circuit behavior, and simulating hardware designs with precise timing control and external signal injection.",
      "description_length": 479,
      "index": 44,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Two_state_logic.Uop",
      "library": "hardcaml_event_driven_sim",
      "description": "This module implements arithmetic and comparison operations for unsigned bit vectors, working directly with `Bits.t` or `Signal.t` types. It supports addition, subtraction, multiplication, and comparisons (less than, greater than, equal, etc.), automatically handling width mismatches and sign extension. Concrete use cases include building arithmetic logic units (ALUs), implementing register-based counters, and performing bit-accurate data path operations in hardware simulations.",
      "description_length": 483,
      "index": 45,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Four_state_logic.Unsigned",
      "library": "hardcaml_event_driven_sim",
      "description": "This module implements arithmetic and comparison operations for unsigned vectors using four-state logic (1, 0, X, Z). It supports addition, subtraction, multiplication, and comparisons like less than or equal, operating on the `v` type which represents unsigned values. These operations are used to model digital circuit behavior in simulations where signal states include unknown (X) and high-impedance (Z) values.",
      "description_length": 415,
      "index": 46,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Four_state_logic.Sop",
      "library": "hardcaml_event_driven_sim",
      "description": "This module implements arithmetic and comparison operations for four-state logic values, supporting addition, subtraction, multiplication, and comparisons like less than or equal. It operates directly on `Bits.t` or `Signal.t` types, handling sign extension and resizing as needed during computations. Use this module for building digital circuits that require signed arithmetic and value comparisons in simulation environments.",
      "description_length": 428,
      "index": 47,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Make.Vcd",
      "library": "hardcaml_event_driven_sim",
      "description": "This module writes value change dump (VCD) files by tracking signal changes during simulation. It initializes with an output channel and a list of ports to monitor, then generates VCD output through a list of simulation processes. Use it to capture waveform data for debugging digital circuits in an event-driven simulation.",
      "description_length": 324,
      "index": 48,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Waveterm.Waveform",
      "library": "hardcaml_event_driven_sim",
      "description": "This module manages waveform data structures for simulation, providing operations to create, combine, and manipulate waveforms from signal data. It works with waves, ports, and display rules to represent and serialize simulation traces. Concrete use cases include generating textual waveform representations, comparing simulation outputs, and printing or saving waveforms for verification.",
      "description_length": 389,
      "index": 49,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Four_state_logic.Signed",
      "library": "hardcaml_event_driven_sim",
      "description": "This module implements arithmetic and comparison operations for signed vectors in a four-state logic system. It supports addition, subtraction, multiplication, and comparisons like less than or equal, operating on values of type `v` which represent signed numbers with 1, 0, X, or Z logic states. These operations are used to model and simulate digital circuits that handle signed integers in a logic simulation environment.",
      "description_length": 424,
      "index": 50,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Four_state_logic.Uop",
      "library": "hardcaml_event_driven_sim",
      "description": "This module implements arithmetic and comparison operations for four-state logic vectors, supporting addition, subtraction, multiplication, and comparisons like less than or equal. It operates directly on `Bits.t` or `Signal.t` types, handling width mismatches and sign/zero extension automatically. Use this for hardware simulation tasks like ALU operations or conditional branching logic.",
      "description_length": 390,
      "index": 51,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Two_state_logic.Unsigned",
      "library": "hardcaml_event_driven_sim",
      "description": "This module implements arithmetic and comparison operations for unsigned binary vectors, represented by the type `v`. It supports addition, subtraction, multiplication, and comparisons like less than or equal, directly on these vectors, with automatic bit-width extension to prevent truncation. These operations are useful for hardware simulation tasks such as implementing counters, arithmetic logic units, or data path components.",
      "description_length": 432,
      "index": 52,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Two_state_logic.Sop",
      "library": "hardcaml_event_driven_sim",
      "description": "This module provides arithmetic and comparison operations for signed vectors, supporting addition, subtraction, multiplication, and comparisons like less than or equal. It works directly with `Hardcaml_event_driven_sim.Two_state_logic.t`, allowing operations on signals and bit vectors with automatic sign extension. Use cases include implementing arithmetic logic units (ALUs) and comparison-based control logic in hardware descriptions.",
      "description_length": 438,
      "index": 53,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Make.Ops",
      "library": "hardcaml_event_driven_sim",
      "description": "This module provides operations for converting circuits into event-driven simulation processes and managing signal mappings. It works with event-driven simulation types like `Process.t` and `Signal.t`, along with Hardcaml's `Circuit.t` and `Signal.t`. Concrete use cases include translating a Hardcaml circuit into a list of simulation processes, mapping real signals to simulated ones, and handling external instantiations during simulation setup.",
      "description_length": 448,
      "index": 54,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Waveterm.Make",
      "library": "hardcaml_event_driven_sim",
      "description": "This module creates and manages simulation processes tied to a waveform, enabling waveform visualization during event-driven simulations. It works with logic signals represented as ports of type `Logic.t` and tracks their transitions over time. Concrete use cases include generating VCD (Value Change Dump) files for digital circuit simulation and visualizing signal behavior in testbenches.",
      "description_length": 391,
      "index": 55,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Waveterm.Render",
      "library": "hardcaml_event_driven_sim",
      "description": "This module renders waveform data from digital simulations into terminal-based UIs, supporting structured layout calculations, styled visual elements, and interactive inspection. It operates on simulation state representations like `Waves.t` and `Events.t`, using 2D graphics primitives to draw clock cycles, binary signals, and status indicators with customizable dimensions, alignment, and color schemes. Concrete use cases include real-time waveform visualization with dynamic style adjustments and coordinate-driven signal analysis in simulation debuggers.",
      "description_length": 560,
      "index": 56,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Two_state_logic.Signed",
      "library": "hardcaml_event_driven_sim",
      "description": "This module implements arithmetic and comparison operations for signed binary vectors, supporting addition, subtraction, multiplication, and comparisons like less than or equal. It works with the `v` type representing signed vectors, converting to and from standard two-state logic signals. Concrete use cases include building arithmetic units, implementing control logic with signed comparisons, and managing bit-width conversions in digital circuit simulations.",
      "description_length": 463,
      "index": 57,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Waveterm.Expect",
      "library": "hardcaml_event_driven_sim",
      "description": "This module provides an `expect` function that captures and validates waveform data during simulation, allowing optional display of a digest and serialization to a file. It operates on waveform data structures to enable verification of signal behavior against expected patterns. Use it to assert correctness of digital signal outputs in testbenches by comparing against golden waveforms.",
      "description_length": 387,
      "index": 58,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Ops.Make",
      "library": "hardcaml_event_driven_sim",
      "description": "This module compiles Hardcaml circuits into event-driven simulation processes, mapping Hardcaml signals to simulation signals. It supports constructing both real and fake simulation signals and allows customization of delays and external instantiations during compilation. Use it to simulate digital circuits at a high level, integrating Hardcaml descriptions with event-driven simulators.",
      "description_length": 389,
      "index": 59,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Waveterm.Serialize",
      "library": "hardcaml_event_driven_sim",
      "description": "This module provides functions to serialize and deserialize waveform data structures to and from strings. It supports operations for persisting waveform state through `marshall`, reconstructing waveforms with `unmarshall`, and comparing waveform equality with `equal`. These functions are used to save simulation results to disk, transmit waveform data between processes, or verify waveform consistency across runs.",
      "description_length": 415,
      "index": 60,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Vcd.Make",
      "library": "hardcaml_event_driven_sim",
      "description": "This module generates Value Change Dump (VCD) files from simulation data, capturing signal transitions over time. It works with logic values represented by the `Logic.t` type and tracks changes across a list of named ports. Use it to visualize waveforms in digital circuit simulations using tools like GTKWave.",
      "description_length": 310,
      "index": 61,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Waveterm.Waves",
      "library": "hardcaml_event_driven_sim",
      "description": "This module manages waveform data for terminal-based simulation visualization, providing structured storage for signal waveforms and their display configuration. It supports operations to serialize waveform state for persistence or sharing. Concrete use cases include rendering and navigating digital signal traces in a text terminal during hardware simulation debugging.",
      "description_length": 371,
      "index": 62,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Waveterm.Wave",
      "library": "hardcaml_event_driven_sim",
      "description": "This module defines a variant type `t` representing different kinds of waveform elements, including empty, clock, binary, and data waves, each carrying associated metadata and event data. It provides operations to access and modify wave properties such as name, data events, string conversion functions, alignment, and format. Concrete use cases include constructing and manipulating waveform visualizations with precise timing and formatting in simulation environments.",
      "description_length": 470,
      "index": 63,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Two_state_logic",
      "library": "hardcaml_event_driven_sim",
      "description": "This module offers bit-level arithmetic, logical, and conversion operations for digital logic simulation, focusing on precise manipulation of binary signals represented as bit vectors (`Bits.t`). It supports operations like concatenation, multiplexing, signed/unsigned comparisons, and tree-based reductions, while handling conversions between integers, strings, and boolean representations. Designed for hardware modeling tasks, it enables circuit verification scenarios requiring exact bitvector behavior, such as protocol implementation or arithmetic unit design.",
      "description_length": 566,
      "index": 64,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Ops",
      "library": "hardcaml_event_driven_sim",
      "description": "This module compiles Hardcaml circuits into event-driven simulation processes, mapping signals to simulation equivalents. It supports creating real and fake simulation signals, with customizable delays and external instantiations. Use it to simulate digital circuits at a high level, integrating Hardcaml designs with event-driven simulators.",
      "description_length": 342,
      "index": 65,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Make",
      "library": "hardcaml_event_driven_sim",
      "description": "This module translates Hardcaml circuits into event-driven simulation processes, managing signal mappings and supporting external instantiations. It operates on `Circuit.t`, `Signal.t`, and simulation types like `Process.t`, enabling direct simulation of digital designs. Use it to generate waveform data via VCD files, simulate circuit behavior, or integrate with external testbenches.",
      "description_length": 386,
      "index": 66,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Four_state_logic",
      "library": "hardcaml_event_driven_sim",
      "description": "This module implements four-state logic operations for digital signal simulation, supporting values 1, 0, X (unknown), and Z (high-impedance). It provides bit-level manipulation (slicing, concatenation, multiplexing), arithmetic (addition, multiplication), logical operations (AND/OR/XOR), and conversions between signals and integers/strings, while handling signed/unsigned interpretations and resolution of indeterminate states. These capabilities enable modeling complex digital circuits with tri-state buses, unknown value propagation, and mixed-logic simulations in verification workflows.",
      "description_length": 594,
      "index": 67,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Vcd",
      "library": "hardcaml_event_driven_sim",
      "description": "This module generates Value Change Dump (VCD) files by tracking changes in `Logic.t` values across a list of named ports. It captures signal transitions over time to enable waveform visualization in tools like GTKWave. Use it to record and analyze digital circuit behavior during simulation.",
      "description_length": 291,
      "index": 68,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Waveterm",
      "library": "hardcaml_event_driven_sim",
      "description": "This module provides structured waveform data management and terminal visualization for event-driven simulation, supporting waveform construction, serialization, and rendering with precise timing and formatting. It operates on waveform data structures representing digital signals, including clock, binary, and data waves, with associated metadata and event transitions. Concrete use cases include real-time simulation debugging with terminal-based waveform displays, generating VCD files, validating signal outputs against expected patterns, and persisting or transmitting waveform state for verification.",
      "description_length": 606,
      "index": 69,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Logic",
      "library": "hardcaml_event_driven_sim",
      "description": "This module defines a set of logical operations and combinational primitives for constructing and simulating digital circuits. It works with signal and port types to model gate-level behavior, enabling tasks like arithmetic operations, bitwise manipulation, and conditional routing. Concrete use cases include building ALUs, multiplexers, and state machines in a hardware description context.",
      "description_length": 392,
      "index": 70,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_event_driven_sim",
      "library": "hardcaml_event_driven_sim",
      "description": "This module implements an event-driven simulation framework for digital circuits, translating Hardcaml designs into executable simulation processes with precise signal propagation and timing. It works with signal, port, and waveform data structures to model circuit behavior, supporting simulation features like delayed transitions, external instantiations, and waveform capture. Concrete use cases include simulating register-transfer level designs, verifying control logic with waveform tracing, and integrating with testbenches for cycle-accurate validation.",
      "description_length": 561,
      "index": 71,
      "embedding_norm": 0.9999999403953552
    }
  ],
  "filtering": {
    "total_modules_in_package": 74,
    "meaningful_modules": 72,
    "filtered_empty_modules": 2,
    "retention_rate": 0.972972972972973
  },
  "statistics": {
    "max_description_length": 609,
    "min_description_length": 201,
    "avg_description_length": 426.6666666666667,
    "embedding_file_size_mb": 1.0440044403076172
  }
}