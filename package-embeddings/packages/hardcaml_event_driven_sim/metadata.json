{
  "package": "hardcaml_event_driven_sim",
  "embedding_model": "Qwen/Qwen3-Embedding-0.6B",
  "embedding_dimension": 1024,
  "total_modules": 85,
  "creation_timestamp": "2025-07-15T23:19:43.836165",
  "modules": [
    {
      "module_path": "Hardcaml_event_driven_sim.Make.With_interface.Output.Unsafe_assoc_by_port_name",
      "library": "hardcaml_event_driven_sim",
      "description": "Converts between output signals and association lists mapping port names to values. Works with any output type supporting the `Output.t` interface. Useful for dynamically inspecting or constructing output values by port name without static type checking.",
      "description_length": 254,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Make.With_interface.Input.Names_and_widths",
      "library": "hardcaml_event_driven_sim",
      "description": "This module provides direct access to metadata about input ports in a hardware design simulation, specifically listing port names paired with their widths, as well as separate lists of just names and just widths. It also exposes tags associated with these inputs, enabling structured access to signal identifiers. This is useful when generating testbenches or debugging simulations by correlating signal data with named ports and their bit widths.",
      "description_length": 447,
      "index": 1,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Make.With_interface.Logic.Unsigned",
      "library": "hardcaml_event_driven_sim",
      "description": "This module implements arithmetic and comparison operations for unsigned logic values, providing functions like addition, subtraction, multiplication, and comparisons such as less than or equal to. It works directly with the `Logic.Unsigned.v` type, which represents unsigned values in a hardware description context. Use this module to build combinational logic circuits that perform numerical computations on unsigned signals, such as counters, arithmetic units, or control logic components.",
      "description_length": 493,
      "index": 2,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Make.With_interface.Input.Comb",
      "library": "hardcaml_event_driven_sim",
      "description": "This module provides operations for constructing and manipulating event-driven simulation inputs composed of combinational logic values. It supports values of type `comb Input.t`, which represent structured collections of combinational signals, along with utilities for packing, unpacking, multiplexing, concatenation, and selection operations. Concrete use cases include modeling register file outputs, decoding instruction fields, and implementing control logic in digital circuits.",
      "description_length": 484,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Make.With_interface.Input.All",
      "library": "hardcaml_event_driven_sim",
      "description": "This module provides a function `all` that transforms a nested structure of input signals into a single input signal of a structured type. It operates on data types involving `'a M.t Input.t`, where `M` is a module encapsulating signal types. A concrete use case is aggregating multiple individual input signals into a single structured signal for simulation or testing purposes.",
      "description_length": 379,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Make.With_interface.Logic.Uop",
      "library": "hardcaml_event_driven_sim",
      "description": "This module provides unary and binary logical operations on `Logic.t` values, including arithmetic and comparison operators. It supports operations like addition, subtraction, multiplication, and comparisons (e.g., less than, equal to), all returning `Logic.t` values. These functions are used to build combinational logic circuits in a hardware description context, such as implementing ALUs or control logic.",
      "description_length": 410,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Make.With_interface.Input.Make_comb",
      "library": "hardcaml_event_driven_sim",
      "description": "This module provides functions for constructing and manipulating input signals in a combinatorial logic simulation. It supports operations like packing/unpacking values, multiplexing, concatenation, and selection from one-hot or priority-encoded inputs. Concrete use cases include modeling digital circuit inputs, simulating bus multiplexers, and handling encoded control signals in hardware verification.",
      "description_length": 405,
      "index": 6,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Make.With_interface.Input.Of_always",
      "library": "hardcaml_event_driven_sim",
      "description": "This module provides functions to manipulate input signals in an event-driven simulation, specifically handling assignments, registers, and wire declarations. It works with `Always.Variable.t` and `Signal.t` types to model hardware behavior. Use cases include defining combinational logic with `assign`, creating sequential elements with `reg`, and connecting signals in a simulation context.",
      "description_length": 392,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Make.With_interface.Output.Of_signal",
      "library": "hardcaml_event_driven_sim",
      "description": "This module implements combinational and sequential logic operations for constructing and transforming signal values in hardware designs, including signal creation (`of_int`, `wires`), bitwise manipulation (`pack`, `concat`), multiplexing (`mux`, `priority_select`), and register instantiation. It supports signal connection through assignment (`<==`), input/output port definition, and hierarchical naming with customizable prefixes, enabling structured circuit assembly and simulation validation. Use cases include building pipeline stages, connecting functional units, and generating named signal hierarchies for testbench integration.",
      "description_length": 638,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Make.With_interface.Output.Comb",
      "library": "hardcaml_event_driven_sim",
      "description": "This module provides operations for constructing and manipulating combinational logic signals in a hardware description context. It supports data types like `comb` for representing combinational logic and `t` for typed outputs, with functions for packing/unpacking, multiplexing, concatenation, and selection. Concrete use cases include building control logic, data path multiplexers, and signal routing structures in digital circuit designs.",
      "description_length": 442,
      "index": 9,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Make.With_interface.Logic.Signed",
      "library": "hardcaml_event_driven_sim",
      "description": "This module provides operations for performing arithmetic and comparison on signed logic values, including addition, subtraction, multiplication, and comparisons like less than or equal to. It works with the `v` type representing signed logic signals, allowing conversion to and from unsigned logic values. It is used to model and simulate digital circuits with signed integer behavior, such as arithmetic logic units or control logic requiring signed comparisons.",
      "description_length": 464,
      "index": 10,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Make.With_interface.Output.Of_always",
      "library": "hardcaml_event_driven_sim",
      "description": "This module defines operations for constructing and manipulating event-driven simulation outputs from always blocks. It works with `Hardcaml.Always.Variable.t` and `Hardcaml.Signal.t` types, enabling signal assignment, register instantiation, and wire creation within simulation contexts. Concrete use cases include modeling sequential logic, combinational assignments, and named signal tracing in hardware simulations.",
      "description_length": 419,
      "index": 11,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Make.With_interface.Output.All",
      "library": "hardcaml_event_driven_sim",
      "description": "Converts a record of outputs into an output of records, enabling the combination of multiple signal outputs into a single structured output. Works with any module `M` that defines a set of output signals. Useful for aggregating simulation results into a unified type for testing or waveform generation.",
      "description_length": 302,
      "index": 12,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Make.With_interface.Output.Names_and_widths",
      "library": "hardcaml_event_driven_sim",
      "description": "This module provides direct access to metadata about output ports in a hardware design simulation, specifically listing port names paired with their widths, as well as separate lists of just names and just widths. It also exposes tags associated with outputs for additional runtime identification or configuration. This is useful when dynamically generating testbenches, logging signals, or interfacing with external tools that require signal name and width information.",
      "description_length": 470,
      "index": 13,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Make.With_interface.Logic.Sop",
      "library": "hardcaml_event_driven_sim",
      "description": "This module provides operations for constructing and manipulating logic expressions using a signal-based representation. It supports arithmetic and comparison operations on `Logic.t` values, enabling the creation of digital circuits like adders, comparators, and multiplexers. Functions like `resize` allow for bit-width manipulation, making it suitable for hardware description tasks such as register design and data path implementation.",
      "description_length": 438,
      "index": 14,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Make.With_interface.Output.Make_comb",
      "library": "hardcaml_event_driven_sim",
      "description": "This module implements combinational logic operations for signal manipulation, including packing/unpacking signals, multiplexing, concatenation, and selection from one-hot or priority-encoded inputs. It works with `comb` types representing combinational circuits and `t` as a structured output type for signal vectors. Use this module to build logic for routing data between registers, decoding control signals, or constructing arbiters in digital designs.",
      "description_length": 456,
      "index": 15,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Make.With_interface.Logic.Typed_math",
      "library": "hardcaml_event_driven_sim",
      "description": "This module provides arithmetic and comparison operations on a typed signal representation, supporting addition, subtraction, multiplication, and comparisons like less than or greater than. It works with the `v` type, which wraps `Logic.t` signals for type-safe manipulation. Use it to build and manipulate digital logic expressions in a strongly-typed context, such as constructing combinational logic circuits or comparing signal values in a simulation.",
      "description_length": 455,
      "index": 16,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Make.With_interface.Output.Of_bits",
      "library": "hardcaml_event_driven_sim",
      "description": "This module provides functions to manipulate bit vector outputs in a hardware description context. It supports operations like packing/unpacking bit vectors, multiplexing, concatenation, and selection from one-hot or priority-encoded inputs. Concrete use cases include constructing and validating digital circuit outputs, simulating register file selections, and implementing control logic with bit-level precision.",
      "description_length": 415,
      "index": 17,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Make.With_interface.Input.Of_signal",
      "library": "hardcaml_event_driven_sim",
      "description": "This module provides combinational logic synthesis, sequential register operations, and signal routing capabilities for hardware design. It operates on hardware signals and input interface types, enabling structured construction of digital circuits through transformations like packing/unpacking, concatenation, and multiplexing. Typical use cases include building register blocks, data path multiplexers, and pipelined control logic within event-driven simulations, with support for hierarchical signal naming and interface connectivity.",
      "description_length": 538,
      "index": 18,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Make.With_interface.Input.Of_bits",
      "library": "hardcaml_event_driven_sim",
      "description": "This module provides functions to construct and manipulate input signals represented as bit vectors in a hardware description context. It supports operations like packing/unpacking bit vectors, multiplexing, concatenation, and priority/one-hot selection, with utilities to validate signal widths and convert between integer and bit representations. Concrete use cases include building custom digital circuits, testbenches, and simulation models where precise control over input signal behavior is required.",
      "description_length": 506,
      "index": 19,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Make.With_interface.Input.Unsafe_assoc_by_port_name",
      "library": "hardcaml_event_driven_sim",
      "description": "Converts between input structures and association lists mapping port names to values. Works with any type `'a` in the context of an `Input.t` structure. Useful for serializing or deserializing input configurations using string keys corresponding to port names.",
      "description_length": 260,
      "index": 20,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Waveterm.Render.Static.R",
      "library": "hardcaml_event_driven_sim",
      "description": "This module provides terminal-based waveform visualization capabilities, including layout calculations for waveform dimensions, rendering primitives for drawing clock cycles, binary values, and signals, and UI element composition. It handles user interaction through coordinate-based selection logic to identify clicked waveform elements, signals, or status indicators within a static rendering context. The core data structures include waveform metadata, simulation data, and terminal display elements, primarily used for building interactive waveform viewers in text-based environments.",
      "description_length": 588,
      "index": 21,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Waveterm.Render.Styles",
      "library": "hardcaml_event_driven_sim",
      "description": "This module defines and manipulates rendering styles for waveform visualization, including border, signal, value, wave, and status display. It works with style and color configuration data types to customize visual appearance. Concrete use cases include setting up waveform display themes such as black-on-white or color-on-black for simulation trace visualization.",
      "description_length": 365,
      "index": 22,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Make.With_interface.Output",
      "library": "hardcaml_event_driven_sim",
      "description": "This module enables the transformation, combination, and inspection of tagged output signals in hardware simulations, offering operations like mapping, zipping, and conversion to and from lists and S-expressions. It works with `Output.t` values to manage port names, bit widths, and metadata, supporting tasks such as defining combinational logic, extracting signal properties, and organizing hierarchical designs. Submodules provide utilities for converting signals to association lists, constructing logic with combinational and sequential operations, simulating event-driven outputs, and aggregating multiple outputs into structured records. Additional functionality includes bit vector manipulation, port metadata access, and signal routing structures for control logic and data path design.",
      "description_length": 795,
      "index": 23,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Make.With_interface.Logic",
      "library": "hardcaml_event_driven_sim",
      "description": "This module provides low-level digital logic operations on fixed-width bit vectors (`Logic.t`), supporting bitwise manipulation, arithmetic, and comparisons for both signed and unsigned interpretations. It includes utilities for conversions between bit vectors and integers, strings, or boolean signals, along with functions for simulation tasks like random signal generation and encoding transformations. Submodules extend this functionality with typed signal arithmetic, signed and unsigned numerical operations, and combinational logic construction for tasks like priority selection and population counting. Specific applications include designing arithmetic logic units, implementing control logic, and simulating digital circuits with resizable or encoded signal representations.",
      "description_length": 784,
      "index": 24,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Make.With_interface.Input",
      "library": "hardcaml_event_driven_sim",
      "description": "This module manages input signal structures in hardware simulations, offering operations to construct, transform, and inspect signals using combinational logic, bit vectors, and structured types. It supports key data types like `comb Input.t`, `Signal.t`, and bit vectors, with operations including packing, concatenation, multiplexing, and selection. Submodules enable aggregating signals into structured types, converting inputs to association lists, and modeling register blocks or control logic with precise signal routing. Example uses include decoding instruction fields, simulating bus multiplexers, and building testbenches with named, width-aware input ports.",
      "description_length": 668,
      "index": 25,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Make.With_interface.Ops",
      "library": "hardcaml_event_driven_sim",
      "description": "This module provides operations for converting circuits into event-driven simulation processes and managing signal mappings. It works with simulation states, circuits, and signals, enabling the creation of process lists and handling of input/output signals. Concrete use cases include simulating hardware behavior by translating circuit descriptions into executable simulation steps and linking signals to their simulated counterparts.",
      "description_length": 435,
      "index": 26,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Waveterm.Render.Bounds",
      "library": "hardcaml_event_driven_sim",
      "description": "This module manages layout calculations for waveform rendering by expanding or shrinking rectangular regions to account for borders and aligning them within a window. It operates on `rect` structures to define visible areas for signals, values, waves, and status. Concrete use cases include adjusting drawing regions to fit UI windows while preserving spacing for waveform elements and borders.",
      "description_length": 394,
      "index": 27,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Waveterm.Render.Static",
      "library": "hardcaml_event_driven_sim",
      "description": "This module renders waveforms and signal values into in-memory drawing contexts, enabling precise control over layout, styling, and visibility for visual display. It supports operations such as drawing clock cycles, binary values, and signals, with data types including waveform metadata, simulation data, and display elements. The terminal-based submodule extends this functionality by adding layout calculations, rendering primitives, and interaction handling for text-based waveform viewers. Together, they enable generating and interacting with static waveform images in both graphical and terminal environments.",
      "description_length": 616,
      "index": 28,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Waveterm.Waves.Config",
      "library": "hardcaml_event_driven_sim",
      "description": "This module defines configuration parameters for rendering waveforms in a terminal-based simulation viewer. It includes mutable fields for dimensions and scroll positions, along with serialization functions for saving and loading configurations. It is used to customize the visual layout and interaction with signal waveforms during simulation.",
      "description_length": 344,
      "index": 29,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Waveterm.Render.Make",
      "library": "hardcaml_event_driven_sim",
      "description": "This module provides graphical rendering and interaction handling for waveform visualization, operating on waveform data structures like `Waves.t` and `Wave.t`. It draws elements such as clock cycles, binary values, and cursors using a graphics context (`G.ctx`), with support for styling, alignment, and bounds customization. Key use cases include interactive simulation viewers for digital circuit debugging, where users can visually inspect signal transitions and select specific waveform elements via coordinate-based picking.",
      "description_length": 530,
      "index": 30,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Logic.S",
      "library": "hardcaml_event_driven_sim",
      "description": "This module enables bit-level signal manipulation and arithmetic operations for hardware simulation, focusing on precise control over fixed-width bit vectors (`t`). It supports conversions between integers, strings, and bit sequences, along with bitwise operations (AND/OR/XOR), arithmetic (addition, multiplication, comparisons), and structural transformations (resizing, shifting, concatenation) for both signed and unsigned representations. Key use cases include digital logic design, protocol implementation, and simulation tasks requiring low-level bitfield manipulation or arithmetic with configurable overflow handling.",
      "description_length": 626,
      "index": 31,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Make.Ops",
      "library": "hardcaml_event_driven_sim",
      "description": "This module provides operations for converting circuits into event-driven simulation processes and managing signal mappings. It works with event-driven simulation types such as `Process.t`, `Signal.t`, and `Circuit.t`, enabling direct manipulation and simulation of hardware descriptions. Concrete use cases include instantiating simulation processes from circuits, resolving or faking signal representations during simulation, and integrating external components with custom input/output behavior.",
      "description_length": 498,
      "index": 32,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Logic.S-Sop",
      "library": "hardcaml_event_driven_sim",
      "description": "This module provides arithmetic and comparison operations for signed bit vectors, supporting addition, subtraction, multiplication, and comparisons like less than or equal. It works directly with `t` values, which represent signed vectors, and includes resizing to adjust bit widths with appropriate sign extension. Concrete use cases include implementing arithmetic logic units (ALUs) and performing bit-accurate computations in hardware description tasks.",
      "description_length": 457,
      "index": 33,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Two_state_logic.Sop",
      "library": "hardcaml_event_driven_sim",
      "description": "This module provides arithmetic and comparison operations for signed logic vectors, supporting addition, subtraction, multiplication, and comparisons like less than or equal. It works directly with `Two_state_logic.t` values, which represent bit vectors or signals in a hardware description context. Use cases include implementing arithmetic logic units, comparators, or data path elements in digital circuits.",
      "description_length": 410,
      "index": 34,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Two_state_logic.Unsigned",
      "library": "hardcaml_event_driven_sim",
      "description": "This module implements arithmetic and comparison operations for unsigned binary vectors, represented as type `v`. It supports addition, subtraction, multiplication, and comparisons like less than or equal, greater than, and equality checks, with automatic bit-width extension to preserve precision. These operations are used to model and simulate digital circuits with unsigned integer values in a two-state logic system.",
      "description_length": 421,
      "index": 35,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Vcd.Make",
      "library": "hardcaml_event_driven_sim",
      "description": "This module writes signal change data to a VCD file during simulation. It tracks changes in logic values on specified ports and generates corresponding VCD output. Useful for debugging digital circuits by capturing waveform data for external analysis.",
      "description_length": 251,
      "index": 36,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Make.Vcd",
      "library": "hardcaml_event_driven_sim",
      "description": "This module writes value change dump (VCD) files by tracking signal changes during simulation. It initializes with an output channel and a list of logic ports to monitor, then generates VCD output through processes attached to a simulator. Use it to capture waveform data for debugging digital circuits in event-driven simulations.",
      "description_length": 331,
      "index": 37,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Ops.S",
      "library": "hardcaml_event_driven_sim",
      "description": "This module compiles Hardcaml circuits into event-driven simulation processes, mapping Hardcaml signals to simulation signals. It supports constructing both real and fake simulation signals and allows customization of delays and external instantiations during compilation. Use cases include simulating digital circuits with precise timing control and integrating custom hardware components into a simulation environment.",
      "description_length": 420,
      "index": 38,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Ops.Make",
      "library": "hardcaml_event_driven_sim",
      "description": "This module compiles Hardcaml circuits into event-driven simulation processes, mapping Hardcaml signals to simulation signals. It supports constructing both real and fake simulation signals and allows customization of delays and external instantiations during compilation. Concrete use cases include simulating digital circuits with precise timing control and integrating custom signal behaviors in testbenches.",
      "description_length": 411,
      "index": 39,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Logic.S-Unsigned",
      "library": "hardcaml_event_driven_sim",
      "description": "This module provides operations for working with unsigned binary vectors, including arithmetic (addition, subtraction, multiplication) and comparison (less than, greater than, equality). It supports conversions to and from combinational signals and allows resizing vectors to specified bit widths. Concrete use cases include implementing arithmetic logic units, performing bit-accurate calculations, and managing digital signal processing tasks.",
      "description_length": 445,
      "index": 40,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Four_state_logic.Unsigned",
      "library": "hardcaml_event_driven_sim",
      "description": "This module implements arithmetic and comparison operations for unsigned vectors in a four-state logic system. It supports addition, subtraction, multiplication, and comparisons like less than or equal, directly on unsigned vector values. These operations are used to model digital circuit behavior where signals can have unknown (X) or high-impedance (Z) states.",
      "description_length": 363,
      "index": 41,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Waveterm.Make",
      "library": "hardcaml_event_driven_sim",
      "description": "This module creates and manages a simulation environment for digital waveforms using a list of processes and a waveform structure. It works with logic values represented by the Logic module and operates on ports to simulate signal changes over time. Concrete use cases include modeling hardware circuits and simulating digital signal propagation for testing and verification.",
      "description_length": 375,
      "index": 42,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Four_state_logic.Uop",
      "library": "hardcaml_event_driven_sim",
      "description": "This module implements arithmetic and comparison operations for four-state logic values, including addition, subtraction, multiplication, and comparisons like less than or equal. It operates directly on typed values, supporting operations between vectors of different widths and automatically handling sign extension and result resizing. These functions are used to model and simulate digital circuits with unsigned arithmetic behavior in a four-state logic environment.",
      "description_length": 470,
      "index": 43,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Waveterm.Serialize",
      "library": "hardcaml_event_driven_sim",
      "description": "This module provides functions to serialize and deserialize waveform data structures to and from strings. It supports operations for persisting waveform state through `marshall`, reconstructing waveforms with `unmarshall`, and comparing waveform equality with `equal`. These functions are useful when saving simulation results to disk or transmitting waveform data between processes.",
      "description_length": 383,
      "index": 44,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Logic.S-module-type-Typed_math",
      "library": "hardcaml_event_driven_sim",
      "description": "This module provides arithmetic and comparison operations for a typed signal representation, supporting addition, subtraction, multiplication, and comparisons like less than or equal, with automatic bit-width extension to prevent truncation. It works with a type `v` representing signals, allowing conversion to and from combinational signals and resizing to specified bit widths. Concrete use cases include building and simulating digital circuits where precise bit-level control and signal manipulation are required.",
      "description_length": 518,
      "index": 45,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Waveterm.Waveform",
      "library": "hardcaml_event_driven_sim",
      "description": "This module represents and manipulates digital waveform data for simulation, providing operations to create, combine, and update waveforms from signal data. It works with arrays of `Wave.t` values and lists of `Port.t` to model signal transitions over time, supporting comparison, serialization, and display formatting. Concrete use cases include capturing simulation traces, generating waveform visualizations, and verifying expected signal behavior in hardware simulations.",
      "description_length": 475,
      "index": 46,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Waveterm.Waves",
      "library": "hardcaml_event_driven_sim",
      "description": "This module organizes waveform data for simulation, combining structured storage with terminal rendering capabilities through its child modules. It supports arrays of wave types and configuration settings for capturing and visualizing signal behavior over time. Key operations include recording signal transitions, exporting waveform data, and customizing display parameters like dimensions and scroll positions. Example uses include debugging event-driven simulations by saving waveform states and adjusting terminal layout dynamically.",
      "description_length": 537,
      "index": 47,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Waveterm.Wave",
      "library": "hardcaml_event_driven_sim",
      "description": "This module defines a variant type `t` representing different kinds of waveform elements such as empty markers, clocks, binary signals, and data signals, each carrying associated metadata like names, events, formatting, and alignment. It provides operations to access and modify waveform properties including name, data events, string conversion functions, alignment, and display format. Concrete use cases include constructing and manipulating signal visualizations in a waveform viewer or simulation tool.",
      "description_length": 507,
      "index": 48,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Four_state_logic.Typed_math",
      "library": "hardcaml_event_driven_sim",
      "description": "This module provides arithmetic and comparison operations for four-state logic values, supporting addition, subtraction, multiplication, and comparisons like less than or equal. It works with the `v` type representing logic values with 1, 0, X, Z states, allowing operations across different bit widths. Concrete use cases include building and simulating digital circuits where signed and unsigned arithmetic with variable bit widths must handle unknown or high-impedance states.",
      "description_length": 479,
      "index": 49,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Four_state_logic.Sop",
      "library": "hardcaml_event_driven_sim",
      "description": "This module implements arithmetic and comparison operations for four-state logic values, supporting addition, subtraction, multiplication, and comparisons like less than or equal. It operates directly on typed values representing logic signals, handling sign extension and resizing during operations to maintain precision. Use cases include building and simulating digital circuits where signed arithmetic and value comparisons are required.",
      "description_length": 441,
      "index": 50,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Logic.S-Signed",
      "library": "hardcaml_event_driven_sim",
      "description": "This module provides operations for working with signed binary vectors in a hardware description context. It supports arithmetic operations like addition, subtraction, and multiplication, with automatic sign extension and widening to prevent truncation. It also includes comparison operators for signed values of varying widths, and resizing functionality to adjust vector widths with proper sign extension.",
      "description_length": 407,
      "index": 51,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Make.With_interface",
      "library": "hardcaml_event_driven_sim",
      "description": "This module orchestrates event-driven hardware simulation by integrating clock generation, signal monitoring, and testbench execution with structured input and output handling. It models hardware components through logic signals, ports, and processes, enabling synchronous circuit simulation, VCD waveform generation, and behavioral verification using input stimuli and output assertions. Operations span low-level bit vector manipulation and combinational logic to high-level signal aggregation, mapping, and transformation, supporting tasks like arithmetic unit design, bus multiplexing, and hierarchical signal routing. Submodules refine these capabilities with typed signal arithmetic, structured input decoding, and simulation process construction for precise digital design modeling.",
      "description_length": 789,
      "index": 52,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Waveterm.Expect",
      "library": "hardcaml_event_driven_sim",
      "description": "This module provides an `expect` function to capture and verify waveform data during simulation, allowing optional digest display and serialization to a file. It operates on waveform values, which represent signal changes over time in a digital simulation. Use it to assert expected signal behavior in testbenches or to log waveform states for debugging.",
      "description_length": 354,
      "index": 53,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Two_state_logic.Uop",
      "library": "hardcaml_event_driven_sim",
      "description": "This module implements arithmetic and comparison operations for unsigned bit vectors, working directly with `Two_state_logic.t` values representing hardware signals. It supports addition, subtraction, multiplication, and comparisons like less-than or equal-to, with automatic bit-width extension to preserve precision. These operations are used to model combinational logic circuits where unsigned numeric behavior is required, such as counters, arithmetic units, or control logic.",
      "description_length": 481,
      "index": 54,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Waveterm.Render",
      "library": "hardcaml_event_driven_sim",
      "description": "This module handles the visualization of waveforms by combining layout management, styling, and rendering operations. It works with data types like `rect`, `Waves.t`, `Wave.t`, and styling configurations to control appearance and positioning. Operations include drawing clock cycles, binary signals, and status indicators, with support for both graphical and terminal-based displays. Examples include rendering a simulation trace with custom themes, adjusting waveform regions to fit UI windows, and enabling interactive selection of signal transitions in a digital circuit debugger.",
      "description_length": 583,
      "index": 55,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Two_state_logic.Typed_math",
      "library": "hardcaml_event_driven_sim",
      "description": "This module provides arithmetic and comparison operations for a typed signal representation, supporting addition, subtraction, multiplication, and comparisons like less than or equal. It works with the abstract type `v`, which represents values that can be converted to and from two-state logic signals. Use this module to perform bit-accurate arithmetic and comparisons in an event-driven simulation context, such as modeling digital circuits with variable-width signals.",
      "description_length": 472,
      "index": 56,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Four_state_logic.Signed",
      "library": "hardcaml_event_driven_sim",
      "description": "This module implements arithmetic and comparison operations for signed vectors in a four-state logic system. It supports addition, subtraction, multiplication, and comparisons like less than or equal, with automatic sign extension and resizing to maintain precision. These operations are used to model and simulate digital circuits with signed integer values in a hardware description context.",
      "description_length": 393,
      "index": 57,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Logic.S-Uop",
      "library": "hardcaml_event_driven_sim",
      "description": "This module provides operations for performing arithmetic and comparison on unsigned bit vectors, including addition, subtraction, multiplication, and comparisons like less than or equal. It supports data types `t` which represent unsigned vectors, allowing direct manipulation of `Bits.t` or `Signal.t`. These operations are used in hardware simulation to model combinational logic behavior with precise bit-width handling.",
      "description_length": 424,
      "index": 58,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Two_state_logic.Signed",
      "library": "hardcaml_event_driven_sim",
      "description": "This module implements arithmetic and comparison operations for signed binary vectors, including addition, subtraction, multiplication, and comparisons like less than or equal. It works with the `v` type representing signed vectors and supports operations between vectors of different widths. Use cases include implementing arithmetic logic units (ALUs) and performing signed numerical computations in hardware simulations.",
      "description_length": 423,
      "index": 59,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Ops",
      "library": "hardcaml_event_driven_sim",
      "description": "This module provides operations for manipulating digital signals and simulating event-driven behavior in circuits, centered around signal assignment, inversion, and conditional logic. It supports the construction of combinational and sequential logic, register transfers, and cycle-accurate gate-level simulations. The child modules compile Hardcaml circuits into simulation processes, mapping signals and enabling customizable delays, external instantiations, and integration of testbenches with custom signal behaviors. Together, they enable building, simulating, and testing digital circuits with precise timing and behavioral control.",
      "description_length": 638,
      "index": 60,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Logic",
      "library": "hardcaml_event_driven_sim",
      "description": "This module combines logical operations and combinational primitives with specialized submodules to model digital circuits at varying levels of abstraction. It supports signal and wire data types, enabling gate-level simulation with operations like AND, OR, NOT, and multiplexing, while submodules focus on bit-level manipulation, arithmetic, and comparisons for both signed and unsigned bit vectors. For example, arithmetic logic units (ALUs) can be built using signed or unsigned arithmetic submodules, control logic can be expressed with combinational signal operations, and bit-accurate simulations can leverage resizing, shifting, and conversion functions to manage bit widths and representations precisely.",
      "description_length": 712,
      "index": 61,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Make",
      "library": "hardcaml_event_driven_sim",
      "description": "This module enables event-driven simulation of digital circuits by combining signal management, waveform capture, and structured testbench execution. It supports core data types like `Process.t`, `Signal.t`, and `Circuit.t`, along with operations for signal mapping, bit vector manipulation, and simulation orchestration. You can instantiate simulation processes from circuits, generate VCD files to track signal changes, and verify designs using input stimuli and output assertions. Specific tasks include modeling arithmetic units, managing bus multiplexing, and integrating external components with custom I/O behavior.",
      "description_length": 622,
      "index": 62,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Vcd",
      "library": "hardcaml_event_driven_sim",
      "description": "This module captures and records changes in digital signal values during simulation, generating VCD output for external waveform analysis. It tracks logic value transitions on specified ports, allowing simulation tools to visualize timing and state changes. Key operations include initializing the VCD file, registering signals, and logging value changes at specific simulation times. For example, it can record a signal's transition from 0 to 1 at time 10ns, producing a timestamped entry in the VCD file for tools like GTKWave to display.",
      "description_length": 540,
      "index": 63,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Two_state_logic",
      "library": "hardcaml_event_driven_sim",
      "description": "This module supports bit-level manipulation and arithmetic operations on two-state logic signals represented as bit vectors, with both signed and unsigned interpretations. It provides core operations such as concatenation, logical operations, comparison predicates, and conversions to integers or strings, enabling tasks like signal creation, resizing, priority encoding, and arithmetic reductions. Child modules extend this functionality with specialized arithmetic for signed and unsigned vectors, supporting addition, multiplication, and comparisons with automatic bit-width handling, suitable for modeling ALUs, counters, and control logic. Specific use cases include event-driven simulation of digital circuits where precise bit-level control and numeric behavior are required.",
      "description_length": 782,
      "index": 64,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Waveterm",
      "library": "hardcaml_event_driven_sim",
      "description": "This module simulates, captures, and visualizes digital waveforms for hardware verification, organizing signal data into structured waveforms and rendering them in terminal or graphical interfaces. It defines core data types like `Wave.t` for individual signals, `Port.t` for signal sources, and variant waveform elements with metadata for display and behavior. Operations include creating and combining waveforms, recording signal transitions, asserting expected states with `expect`, serializing waveform data, and rendering clock cycles, binary signals, and status indicators. Example uses include debugging digital circuits by visualizing signal propagation, saving simulation traces to disk, and dynamically adjusting waveform views during interactive simulation sessions.",
      "description_length": 777,
      "index": 65,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_event_driven_sim.Four_state_logic",
      "library": "hardcaml_event_driven_sim",
      "description": "This module provides a four-state logic system for digital signal manipulation with fixed-width bit vectors that support signed and unsigned arithmetic, bitwise operations, and comparisons. It includes data types like `t` and `v` to represent logic values (1, 0, X, Z), enabling operations across varying bit widths with automatic sign extension and resizing. Users can perform addition, subtraction, multiplication, comparisons, shifting, masking, and encoding, making it suitable for modeling tri-state buffers, unresolved signals, and partial unknowns in FPGA prototyping or asynchronous logic verification. Submodules specialize in signed and unsigned arithmetic, offering precise control over signal behavior in hardware simulations.",
      "description_length": 738,
      "index": 66,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_event_driven_sim",
      "library": "hardcaml_event_driven_sim",
      "description": "This module enables event-driven simulation and verification of digital circuits with precise timing and behavioral control, centered around signal manipulation, bit vector arithmetic, and waveform capture. It provides core data types such as `Signal.t`, `Process.t`, `Wave.t`, and four-state logic values with operations for combinational logic, register transfers, arithmetic units, and testbench integration. Users can simulate gate-level circuits, generate VCD waveforms, model ALUs and counters, and verify designs using input stimuli, output assertions, and interactive waveform debugging. Specific examples include building signed arithmetic logic units, capturing signal transitions in VCD files, and simulating tri-state buffers with X and Z logic states.",
      "description_length": 764,
      "index": 67,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Event_driven_sim.Mini_async.Deferred.Let_syntax.Let_syntax",
      "library": "hardcaml_event_driven_sim.kernel",
      "description": "This module provides monadic operations for working with deferred values, enabling sequencing and combination of asynchronous computations. It supports direct use through operators like `bind`, `map`, and `both`, which allow structuring event-driven logic and handling concurrent tasks. The child module offers no additional functionality, leaving the focus on the core operations for deferred values. Examples include chaining asynchronous calls with `bind` or running two deferreds in parallel using `both`.",
      "description_length": 509,
      "index": 68,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Event_driven_sim.Mini_async.Deferred.Let_syntax",
      "library": "hardcaml_event_driven_sim.kernel",
      "description": "This module provides monadic operations for sequencing asynchronous computations that produce values in the future, centered around the `Deferred.t` type. It includes core functions like `>>=`, `>>|`, and `both`, enabling chaining and parallel execution of non-blocking I/O, event-driven tasks, and callback-based logic. The child module exposes these same operations directly, supporting idioms like binding deferred results with `bind` or combining concurrent deferreds with `both`. Together, they streamline structuring and composing asynchronous workflows in a linear, readable manner.",
      "description_length": 589,
      "index": 69,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Event_driven_sim.Mini_async.Deferred.Monad_infix",
      "library": "hardcaml_event_driven_sim.kernel",
      "description": "This module provides monadic composition operators for asynchronous computations represented by the `Deferred.t` type. The `(>>=)` operator sequences two deferred computations, where the result of the first determines the input of the second, while `(>>|)` applies a transformation to the result of a deferred computation. These operators are used to build complex asynchronous workflows, such as chaining network requests or scheduling dependent background tasks.",
      "description_length": 464,
      "index": 70,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Event_driven_sim.Simulator.Signal",
      "library": "hardcaml_event_driven_sim.kernel",
      "description": "Handles signal creation, reading, and identity management for event-driven simulation frameworks. Works with typed signals that store and track changes to values over simulation cycles. Used to model and observe state changes in hardware signals during simulation, such as tracking input/output transitions or internal register states.",
      "description_length": 335,
      "index": 71,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Event_driven_sim.Mini_async.Deferred",
      "library": "hardcaml_event_driven_sim.kernel",
      "description": "This module implements a monad for asynchronous computations centered around the `Deferred.t` type, enabling sequencing with `bind` (`>>=`) and transformation with `map` (`>>|`). It supports combining concurrent deferred values through `both`, `all`, and `join`, and observing results via `peek` and `upon`, allowing patterns like chaining network requests or aggregating parallel I/O operations. Submodules expose core monadic operators and combinators directly, facilitating idiomatic construction of non-blocking, event-driven workflows such as scheduling dependent tasks or handling asynchronous results in a structured way. Example uses include initiating background computations, waiting for multiple network responses, and composing callbacks into linear, readable pipelines.",
      "description_length": 782,
      "index": 72,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Event_driven_sim.Simulator.Signal_id",
      "library": "hardcaml_event_driven_sim.kernel",
      "description": "This module manages unique identifiers for signals in an event-driven simulation environment. It provides operations to create, compare, and hash signal IDs, ensuring each signal is uniquely tracked during simulation. These IDs are used to associate and manage signal values and events within the simulation framework.",
      "description_length": 318,
      "index": 73,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Event_driven_sim.Simulator.Async",
      "library": "hardcaml_event_driven_sim.kernel",
      "description": "This module provides functions to schedule and manage asynchronous processes in an event-driven simulation, using deferred values to model time delays and signal changes. It supports operations like delaying execution for a specified number of time steps, waiting for signal changes, and running infinite loops. These functions are used to model sequential behavior over time in hardware simulations, such as controlling signal transitions or modeling clock cycles.",
      "description_length": 465,
      "index": 74,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Event_driven_sim.Mini_async.Ivar",
      "library": "hardcaml_event_driven_sim.kernel",
      "description": "This module implements a single-assignment variable (IVar) for managing asynchronous computations. It allows creating an IVar, filling it with a value once, and reading its contents asynchronously. Typical use cases include synchronizing concurrent tasks and representing future results in event-driven simulations.",
      "description_length": 315,
      "index": 75,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Event_driven_sim.Simulator.Change_monitor",
      "library": "hardcaml_event_driven_sim.kernel",
      "description": "Tracks changes to specified signals in an event-driven simulation. Provides `create` to set up monitoring on a list of signal IDs and `wait` to asynchronously pause execution until any monitored signal updates. Useful for coordinating simulation steps that depend on signal transitions, such as triggering logic after specific hardware state changes.",
      "description_length": 350,
      "index": 76,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Event_driven_sim.Simulator.Process",
      "library": "hardcaml_event_driven_sim.kernel",
      "description": "Manages processes within an event-driven simulation environment, providing functions to create and schedule processes that react to signal changes. It works with signal identifiers and process types to model concurrent behaviors in hardware simulations. Used to implement sequential logic and stateful components in digital circuit simulations.",
      "description_length": 344,
      "index": 77,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Event_driven_sim.Simulator.Version_signal",
      "library": "hardcaml_event_driven_sim.kernel",
      "description": "Tracks changes in external data states using a signal. Provides `create` to initialize a signal and `increment` to update its value. Useful for modeling versioned state transitions in event-driven simulations, such as tracking signal updates in hardware description workflows.",
      "description_length": 276,
      "index": 78,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Event_driven_sim.Simulator.Value_S",
      "library": "hardcaml_event_driven_sim.kernel",
      "description": "This module defines the behavior of values used in event-driven simulations, including operations to resolve conflicts between multiple driving processes, validate value compatibility, and provide initial signal states. It works with a single abstract type `t` representing signal values, supporting equality checks and S-expression conversion. Concrete use cases include managing signal state transitions and ensuring correctness in digital circuit simulations.",
      "description_length": 462,
      "index": 79,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Event_driven_sim.Simulator.Expert",
      "library": "hardcaml_event_driven_sim.kernel",
      "description": "This module provides low-level scheduling operations for event-driven simulation, including functions to schedule signal updates and delayed function calls. It works directly with simulation time, signals, and event queues. Use it to implement custom simulation behaviors like timed state changes or asynchronous event triggers in digital circuit models.",
      "description_length": 354,
      "index": 80,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Event_driven_sim.Simulator.Debug",
      "library": "hardcaml_event_driven_sim.kernel",
      "description": "This module provides functions to instrument and observe simulation behavior by attaching actions to signal changes and time step boundaries. It works with simulation signals and processes, allowing users to register callbacks that trigger when signals update or at the start/end of time steps. Concrete use cases include debugging signal transitions, logging simulation progress, and validating expected behavior at specific simulation phases.",
      "description_length": 444,
      "index": 81,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Event_driven_sim.Mini_async",
      "library": "hardcaml_event_driven_sim.kernel",
      "description": "This module provides a framework for asynchronous programming using a monad based on `Deferred.t`, enabling structured composition of non-blocking computations through `bind` and `map`. It includes `IVar`, a single-assignment variable for synchronizing and sharing results between asynchronous tasks. Key operations allow combining deferred values, scheduling dependent actions, and observing results, supporting workflows like parallel I/O aggregation or chained network requests. Example uses include coordinating background tasks, awaiting multiple asynchronous results, and modeling future values in event-driven systems.",
      "description_length": 625,
      "index": 82,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Event_driven_sim.Simulator",
      "library": "hardcaml_event_driven_sim.kernel",
      "description": "This module orchestrates event-driven simulations by managing signals, processes, and time progression through delta cycles. It provides core operations to schedule signal transitions, inspect temporal state, and coordinate asynchronous behaviors, working with signals, processes, and events as primary data structures. Submodules handle signal identity, versioning, and monitoring, while supporting deferred execution, process scheduling, and value resolution to model digital circuits with precise event ordering. Examples include tracking register updates, simulating clock-driven logic, and debugging signal transitions through time-step callbacks.",
      "description_length": 652,
      "index": 83,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Event_driven_sim",
      "library": "hardcaml_event_driven_sim.kernel",
      "description": "This module enables event-driven simulations by integrating asynchronous computation with temporal state management. It combines deferred execution and single-assignment variables with signal-based modeling to coordinate time-sensitive behaviors and resolve values across processes. Primary data types include signals, events, and deferreds, supporting operations to schedule transitions, chain asynchronous actions, and track state changes over time. Example workflows include simulating digital circuits with precise timing, coordinating background tasks with event triggers, and observing signal updates during delta cycles.",
      "description_length": 627,
      "index": 84,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 87,
    "meaningful_modules": 85,
    "filtered_empty_modules": 2,
    "retention_rate": 0.9770114942528736
  },
  "statistics": {
    "max_description_length": 795,
    "min_description_length": 251,
    "avg_description_length": 484.8705882352941,
    "embedding_file_size_mb": 0.3091907501220703
  }
}