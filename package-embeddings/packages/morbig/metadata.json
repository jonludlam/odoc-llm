{
  "package": "morbig",
  "embedding_model": "Qwen/Qwen3-Embedding-8B",
  "embedding_dimension": 4096,
  "total_modules": 32,
  "creation_timestamp": "2025-08-15T12:26:20.831323",
  "modules": [
    {
      "module_path": "Morbig.PrelexerState.AtomBuffer",
      "library": "morbig",
      "description": "This module implements a buffer for managing a list of atoms, providing operations to retrieve, add, and inspect the contents. It supports data types including lists of atoms and strings, with functions to push string data into the buffer and extract the last line. Concrete use cases include building and manipulating sequences of lexical tokens during parsing.",
      "description_length": 362,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Morbig.HereDocument.Lexer",
      "library": "morbig",
      "description": "This module processes here documents during lexing by tracking delimiters and operators. It registers redirection operators and delimiters, controls lexing state transitions, and identifies when input matches registered here document boundaries. It works with lex buffers, located words, and custom syntax trees to handle shell-like here document syntax in a parser.",
      "description_length": 366,
      "index": 1,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Morbig.Engine.Lexer",
      "library": "morbig",
      "description": "This module implements a lexer for parsing input streams, providing operations to initialize the lexing state, retrieve the next token with its position and associated aliases, and track the current position in the input. It works with lexing buffers, parsing states, and lexing positions to support incremental tokenization of input. Concrete use cases include interactive shell input processing and step-by-step parsing of command-line expressions.",
      "description_length": 450,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Morbig.CSTHelpers.NameSet",
      "library": "morbig",
      "description": "This module offers a comprehensive set of ordered collection operations for managing unique elements with deterministic ordering, including standard set algebra, membership queries, and ordered traversal. It works with elements of a configurable type `elt` organized into sets that enforce sorted iteration and support transformations like mapping, filtering, and partitioning under monotonic constraints. Typical applications include maintaining symbol tables with lexicographic ordering, analyzing hierarchical data structures with ordered traversal guarantees, and implementing algorithms requiring efficient extremal element access or sequence-based set construction.",
      "description_length": 671,
      "index": 3,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Morbig.Parser.Incremental",
      "library": "morbig",
      "description": "This module provides incremental parsing capabilities for constructing a concrete syntax tree (CST) from shell script input. It includes `entry_point` for initiating the parsing process at a given position and `intended_error` for handling and signaling parsing errors at specific positions. These functions work directly with lexical positions and the CST representation of shell programs, enabling precise error reporting and partial parsing in interactive or streaming contexts.",
      "description_length": 481,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Morbig.Parser.MenhirInterpreter",
      "library": "morbig",
      "description": "This module enables low-level control of LR(1) parsing workflows through incremental token processing, checkpoint management, and stack manipulation. It operates on parser environments (`env`), grammar symbols (`terminal`, `nonterminal`, `xsymbol`), and LR(1) states (`lr1state`), providing introspection into production indices, acceptable tokens, and reduction strategies. Key use cases include implementing custom error recovery, dynamic grammar analysis via production inspection, and integrating lexers with parser state transitions through functions like `feed` and `force_reduction`.",
      "description_length": 590,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Morbig.Aliases",
      "library": "morbig",
      "description": "This module manages alias definitions and substitutions during shell command parsing. It provides an alias table type `t` and operations to expand aliases in command names when appropriate. The `alias_substitution` function replaces a word with its aliased definition during parsing, while `interpret` ensures aliases are not used in contexts where static expansion is impossible, such as nested commands.",
      "description_length": 405,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Morbig.Keyword",
      "library": "morbig",
      "description": "This module manages keyword recognition and parsing in a shell script context. It provides a list of keywords with their associated tokens and symbols, checks if a string is a reserved word, and determines if a token must be well-delimited. It is used during lexical analysis to correctly interpret shell syntax constructs such as control flow statements and command separators.",
      "description_length": 378,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Morbig.Pretokenizer",
      "library": "morbig",
      "description": "This module creates a tokenizer that processes a lexing buffer and produces pretokens with their start and end positions. It works with lexing buffers and pretoken values, tracking position information during lexical analysis. Useful for implementing custom parsing stages that require precise token positioning, such as syntax error reporting or source code transformation tools.",
      "description_length": 380,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Morbig.Scripts",
      "library": "morbig",
      "description": "This module identifies script types and parses shell files. It checks if a file is an ELF binary or non-POSIX shell script using magic numbers, and parses shell syntax into a concrete syntax tree. It operates on file names and strings, returning boolean checks or AST structures. Use cases include script analysis, file type detection, and shell syntax processing.",
      "description_length": 364,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Morbig.RecursiveParser",
      "library": "morbig",
      "description": "The module defines a recursive parser that processes a lexing buffer and generates a located program in the concrete syntax tree (CST) format. It operates on lexing buffers and prelexer states to produce structured CST nodes with positional information. This parser is used to transform raw input into a syntactically structured representation for further analysis or interpretation.",
      "description_length": 383,
      "index": 10,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Morbig.CSTHelpers",
      "library": "morbig",
      "description": "This module provides utilities for manipulating concrete syntax tree elements with a focus on positional tracking, lexical type conversions, and command structure analysis. It operates on located values, syntactic positions, and shell command components like redirects and words, while the embedded NameSet module enables ordered collection management for deterministic name traversal. Key use cases include CST validation, shell syntax parsing, and generating position-aware transformations in language processing tasks.",
      "description_length": 521,
      "index": 11,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Morbig.PrelexerState",
      "library": "morbig",
      "description": "This module manages lexical token buffering and nested context tracking during parsing, using atom-based representations of word components, quotes, and assignments alongside a stack-based system to handle nested states like here-documents, backquotes, or braces. It provides operations to build and manipulate these structures, supporting precise escape analysis, delimiter detection, and state transitions required for parsing shell-like syntax with layered quoting or structured constructs. Key applications include tokenizing complex command-line inputs involving nested contexts or syntactic elements like variable assignments and quoted strings.",
      "description_length": 651,
      "index": 12,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Morbig.Pretoken",
      "library": "morbig",
      "description": "This module represents preliminary token forms during parsing, handling conversions between strings and structured tokens. It supports operations like mapping strings to tokens, extracting word components, and identifying operators or newline markers. Use it to process raw input into categorized lexical elements before full CST construction.",
      "description_length": 343,
      "index": 13,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Morbig.Debug",
      "library": "morbig",
      "description": "This module provides a `printf` function for formatted output to standard channels, working with format strings and values of arbitrary types. It supports debugging by allowing precise control over output formatting, including type-safe string interpolation. Concrete use cases include logging intermediate values during parsing or tracing execution flow in compilers or interpreters.",
      "description_length": 384,
      "index": 14,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Morbig.Options",
      "library": "morbig",
      "description": "This module defines configuration options and operations for processing input files, selecting output formats, and controlling analysis behavior. It provides access to command-line settings such as the selected backend (Json, Bin, etc.), input file lists, and flags for error handling, debugging, and feature toggles. Concrete use cases include determining the output file path from an input file, checking whether to disable alias expansion, or deciding whether to continue analysis after encountering an error.",
      "description_length": 512,
      "index": 15,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Morbig.HereDocument",
      "library": "morbig",
      "description": "Lexer tracks here document delimiters and operators during lexing, managing state transitions and identifying boundary matches. It works with lex buffers, located words, and syntax trees to handle shell-like here document syntax. Use it to implement custom parsers that support here document constructs with proper delimiter registration and redirection handling.",
      "description_length": 363,
      "index": 16,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Morbig.Errors",
      "library": "morbig",
      "description": "Handles error conditions during parsing and I/O operations. Provides `string_of_error` to convert error exceptions into human-readable strings. Used to report parsing failures, alias handling limitations, and I/O issues with descriptive messages.",
      "description_length": 246,
      "index": 17,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Morbig.JsonHelpers",
      "library": "morbig",
      "description": "This module provides functions to serialize and deserialize concrete syntax trees (CSTs) to and from JSON and DOT formats. It supports reading and writing CSTs with or without location information in JSON, and generating DOT representations for visualization. Use cases include persisting parsed program structures, exchanging data between tools, and generating graphical representations of CSTs.",
      "description_length": 396,
      "index": 18,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Morbig.Nesting",
      "library": "morbig",
      "description": "Handles nested shell syntax elements like quotes, parentheses, and command substitutions. It tracks nesting levels with specific markers such as backquotes, braces, and here-documents. Used to determine if a given nesting context is inside a backquoted-style command substitution.",
      "description_length": 280,
      "index": 19,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Morbig.Assignment",
      "library": "morbig",
      "description": "Processes checkpoints from the parser to recognize assignment statements in shell scripts. It analyzes word components and positions to identify variable assignments during syntactic analysis. Useful for static analysis tools that need to track variable definitions in scripting languages.",
      "description_length": 289,
      "index": 20,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Morbig.Parser",
      "library": "morbig",
      "description": "This module defines a token type representing lexical elements of shell scripts, including keywords, operators, and structured values like words and names. It provides parsing functions `intended_error` and `entry_point` for handling errors and constructing a located CST from token streams. Concrete use cases include parsing shell programs with precise error handling and incremental construction of syntax trees during interactive or streaming input processing.",
      "description_length": 464,
      "index": 21,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Morbig.Name",
      "library": "morbig",
      "description": "This module provides functions to validate characters and strings as names. It includes predicates to check if a character is alphabetic (`alpha`), alphanumeric (`alphanum`), and if a string qualifies as a valid name (`is_name`). These functions are used to ensure identifiers conform to naming rules in contexts like parsing or lexing.",
      "description_length": 336,
      "index": 22,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Morbig.Engine",
      "library": "morbig",
      "description": "This module manages parsing and lexing operations for command-line input, supporting incremental tokenization and state tracking. It handles lexing buffers, parsing checkpoints, and alias management to enable interactive input processing and step-by-step parsing of shell commands. Use cases include parsing user input in an interactive shell and evaluating command-line expressions incrementally.",
      "description_length": 397,
      "index": 23,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Morbig.Prelexer",
      "library": "morbig",
      "description": "This module processes lexing buffers to recognize shell tokens according to POSIX rules, handling cases outside here-document mode and context-independent token recognition. It operates on lexing buffers and prelexer state, producing pretokens with positional information. It is used to parse shell input into structured tokens for further processing in the parser.",
      "description_length": 365,
      "index": 24,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Morbig.QuoteRemoval",
      "library": "morbig",
      "description": "This module processes strings by removing quotes, handling escaped characters with a backslash state machine, and stripping leading tabs from lines. It operates directly on string inputs and maintains internal state for parsing sequences like escaped quotes. Concrete use cases include sanitizing input strings in parsers, preparing text for further lexical analysis, and normalizing quoted expressions.",
      "description_length": 403,
      "index": 25,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Morbig.CSTVisitors",
      "library": "morbig",
      "description": "This module provides traversal and transformation functions for concrete syntax trees, enabling operations like node inspection, modification, and extraction. It works directly with the node types defined in the Morbig CST (Concrete Syntax Tree) structure, such as expressions, statements, and declarations. Use cases include implementing linters, code refactoring tools, and static analysis passes that require deep syntactic inspection or manipulation of OCaml source code.",
      "description_length": 475,
      "index": 26,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Morbig.CST",
      "library": "morbig",
      "description": "This module defines the concrete syntax tree (CST) structure for parsed POSIX shell scripts, with data constructors directly mirroring the grammar's production rules. It includes detailed types for program elements such as commands, words, and line breaks, capturing the full syntactic structure of shell scripts beyond simple tokenization. Specific use cases include static analysis, transformation, and interpretation of shell scripts based on their precise syntactic representation.",
      "description_length": 485,
      "index": 27,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Morbig.ExtMenhirLib",
      "library": "morbig",
      "description": "This module extends the Menhir parser library with operations to inspect and manipulate parser checkpoints, query accepted tokens, and analyze the parser's state. It works with Menhir's incremental parser environment, checkpoints, and nonterminal symbols, enabling precise control over parsing decisions. Concrete use cases include implementing custom error recovery, dynamic token prediction, and parser introspection for debugging or tooling purposes.",
      "description_length": 453,
      "index": 28,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Morbig.Token",
      "library": "morbig",
      "description": "This module provides functions to convert various parsed token types into their string representations. It operates on structured data types such as `word`, `io_number`, `assignment_word`, and `token`, all originating from the CST (Concrete Syntax Tree) and parser modules. Use cases include debugging and logging during parsing, where human-readable forms of tokens are needed for inspection or error reporting.",
      "description_length": 412,
      "index": 29,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Morbig.CSTSerializers",
      "library": "morbig",
      "description": "This module converts concrete syntax tree nodes such as `program` and `bracket_expression` to and from Yojson representations. It supports structured serialization and deserialization for specific syntax elements in the Morbig CST. Use this module when persisting or transmitting parsed syntax trees in JSON format, or when reconstructing syntax trees from JSON input.",
      "description_length": 368,
      "index": 30,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Morbig",
      "library": "morbig",
      "description": "This module offers syntactic manipulation and analysis of shell scripts through concrete syntax tree (CST) transformations, alias expansion, and assignment resolution. It operates on lexing buffers, tokens, and nested contextual states to handle complex parsing scenarios like here-documents and quote removal, while supporting error recovery and custom serialization formats. Typical applications include static analysis tools, script refactoring utilities, and custom shell language extensions requiring precise syntax tree manipulation.",
      "description_length": 539,
      "index": 31,
      "embedding_norm": 0.9999999403953552
    }
  ],
  "filtering": {
    "total_modules_in_package": 32,
    "meaningful_modules": 32,
    "filtered_empty_modules": 0,
    "retention_rate": 1.0
  },
  "statistics": {
    "max_description_length": 671,
    "min_description_length": 246,
    "avg_description_length": 422.25,
    "embedding_file_size_mb": 0.46419811248779297
  }
}