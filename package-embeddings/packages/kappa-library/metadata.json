{
  "package": "kappa-library",
  "embedding_model": "Qwen/Qwen3-Embedding-0.6B",
  "embedding_dimension": 1024,
  "total_modules": 121,
  "creation_timestamp": "2025-07-15T23:25:42.663988",
  "modules": [
    {
      "module_path": "Kappa_terms.Pattern.Map",
      "library": "kappa-library.terms",
      "description": "This module implements associative containers mapping Kappa pattern identifiers to arbitrary data, supporting efficient lookups, transformations, and set-theoretic operations. It offers both basic manipulations like insertion/removal with optional logging, and advanced combinators for merging, differencing, and custom iteration strategies over sparse or restricted domains. Typical applications include analyzing Kappa rule-based models where pattern relationships must be tracked, transformed, or compared with error-resilient and audit-aware operations.",
      "description_length": 557,
      "index": 0,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kappa_terms.Pattern.Set",
      "library": "kappa-library.terms",
      "description": "This set interface provides operations for managing collections of pattern identifiers, including union, intersection, difference, element insertion/removal, and logging-aware variants that track modifications. It works with sets of `Kappa_terms.Pattern.id`, offering functions for ordered selection (min/max), random sampling via a state, and existence checks during updates. These capabilities are useful in graph navigation tasks requiring verifiable set manipulation, iterative analysis with logging, or probabilistic pattern selection.",
      "description_length": 540,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_terms.Pattern.ObsMap",
      "library": "kappa-library.terms",
      "description": "This module implements a map structure specialized for associating values with pattern identifiers in the Kappa_terms.Pattern domain. It supports operations like setting and retrieving values by pattern ID, folding over entries with indices, mapping functions across values, and formatted printing of contents. Concrete use cases include tracking pattern-specific metadata during graph traversal or maintaining per-pattern state in analysis tools.",
      "description_length": 447,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_terms.Primitives.Transformation",
      "library": "kappa-library.terms",
      "description": "This module implements elementary transformations on rule primitives in a Kappa model, handling operations like mapping, folding, and renaming agents within transformation structures. It supports concrete and abstract instantiations of transformations, enabling tasks like concretization, comparison, and printing of rule modifications. Specific use cases include processing rule actions to generate positive or negative transformations based on site graph signatures and link mappings.",
      "description_length": 486,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_terms.Pattern.PreEnv",
      "library": "kappa-library.terms",
      "description": "This module manages environments for pattern navigation in a graph, providing access to signatures, counters, and node statistics. It operates on the `t` type, which encapsulates graph state with fields for node count and navigation steps. Concrete use cases include initializing environments from existing configurations, debugging graph traversal, and tracking structural changes during pattern matching.",
      "description_length": 406,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_terms.Pattern.Env",
      "library": "kappa-library.terms",
      "description": "This module manages a mapping of pattern identifiers to structured graph navigation points, enabling efficient traversal and analysis of Kappa site graphs. It supports operations to retrieve pattern contents, dependencies, and transitions, as well as to construct and serialize navigation paths. Concrete use cases include pattern matching, graph exploration, and generating transition systems in biochemical modeling tools.",
      "description_length": 424,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_terms.Matching.Agent",
      "library": "kappa-library.terms",
      "description": "This module represents agents within a connected component, supporting operations to rename, concretize, and inspect agent identifiers and types. It works with agent values that may be existing or fresh, and it includes functions for printing agent details with optional signature formatting. Use cases include tracking agent identities during pattern matching and managing agent transformations in rule applications.",
      "description_length": 417,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_terms.Pattern_compiler",
      "library": "kappa-library.terms",
      "description": "This module compiles Kappa patterns into internal representations, handling ambiguous rule mixtures and extracting connected components. It operates on Kappa terms such as rule mixtures, raw mixtures, and contact maps, producing structured pattern data and instantiation events. It is used during rule compilation to manage pattern ambiguity and generate transformation events for simulation.",
      "description_length": 392,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_terms.Model",
      "library": "kappa-library.terms",
      "description": "This module enables manipulation, transformation, and analysis of compiled Kappa models through operations like rule and expression indexing, reverse dependency tracking, and constant propagation. It works with algebraic expressions, rules, observables, and perturbations represented as typed data structures, often indexed by integers for efficient traversal and modification. Specific applications include model serialization to JSON, counter usage validation, pattern extraction, and environment manipulation for simulation or analysis workflows.",
      "description_length": 549,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_terms.Primitives",
      "library": "kappa-library.terms",
      "description": "This module provides core utilities for parsing, transforming, and serializing Kappa model components such as algebraic expressions, dynamic influence networks, and condition-driven perturbations. It supports analysis of rule modifications, validation of preconditions, and extraction of structural elements like connected components, enabling model simulation and behavior verification. The child module extends this functionality by implementing transformations on rule primitives, allowing operations like mapping, renaming, and folding over agent structures, with support for concretization and comparison of rule actions. Together, they enable programmatic manipulation and inspection of Kappa models, including traversal of location-annotated expressions and transformation of rule-based elements based on site graph signatures.",
      "description_length": 834,
      "index": 9,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kappa_terms.LKappa",
      "library": "kappa-library.terms",
      "description": "The module provides operations for constructing and validating rule-based models by managing agent states, molecular mixtures, and interaction links. It supports transformations like marking components as erased or maintained, enforces consistency through error checking during rule creation, and extracts metadata such as link identifiers. Additionally, it facilitates model serialization to JSON and formatted output for analysis, enabling use cases like simulation setup validation and collaborative model sharing.",
      "description_length": 517,
      "index": 10,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_terms.Alg_expr_extra",
      "library": "kappa-library.terms",
      "description": "This module provides operations for manipulating algebraic expressions in the context of rule-based modeling, particularly for handling rate constants and detecting symmetries. It includes functions for simplifying expressions, dividing by integers, computing derivatives, and extracting corrected rate constants, all working with annotated algebraic expressions parameterized over mixture and identifier types. Concrete use cases include normalizing reaction rates and comparing symbolic expressions for equivalence in model analysis tasks.",
      "description_length": 541,
      "index": 11,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_terms.Matching",
      "library": "kappa-library.terms",
      "description": "This module coordinates pattern matching between rules and site graphs by constructing and manipulating matchings, renamings, and connected components. It enables adding agents to matchings, resolving identifier conflicts, and extracting typed elements such as roots or specific agent instances. The connected component submodule handles agent identity transformations, supporting renaming, concretization, and inspection of agent values during matching extension. Example operations include building a matching incrementally from agents, reconstructing a renaming after pattern instantiation, and querying a matching to extract all agents of a given type.",
      "description_length": 656,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_terms.Kappa_printer",
      "library": "kappa-library.terms",
      "description": "This module provides functions to print user-readable representations of Kappa expressions, rules, and models. It operates on data types such as algebraic expressions, boolean expressions, elementary rules, modifications, and perturbations, using a formatter to output structured and readable text. Concrete use cases include displaying compiled Kappa units for debugging, logging, or user interaction, such as printing rule transformations or model states during simulation.",
      "description_length": 475,
      "index": 13,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kappa_terms.Raw_mixture",
      "library": "kappa-library.terms",
      "description": "This module represents and manipulates raw mixtures of agents with ports and internal states, supporting operations like copying agents, printing mixtures, and serializing to or from JSON. It includes union-find functionality for managing connected components in site graphs, with support for tracking and merging equivalence classes during simulation or analysis. Concrete use cases include modeling biochemical reactions, analyzing connectivity in Kappa-encoded systems, and handling agent-based symbolic representations.",
      "description_length": 523,
      "index": 14,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_terms.Pattern_decompiler",
      "library": "kappa-library.terms",
      "description": "Decompiles contact maps into patterns by analyzing site graphs and edge connections. It processes a signature and pre-environment to generate connected components representing pattern structures. Useful for translating low-level site graph interactions into high-level biological pattern representations.",
      "description_length": 304,
      "index": 15,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_terms.Configuration",
      "library": "kappa-library.terms",
      "description": "This module defines a configuration type for simulation parameters, including fields like progress size, output file names, and trace settings. It supports parsing configuration data from a list of key-value pairs with locations and provides an empty default configuration. The module is used to initialize and manage simulation settings, such as setting the initial time, controlling output frequency, and specifying file paths for logging activities and traces.",
      "description_length": 463,
      "index": 16,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kappa_terms.Alg_expr",
      "library": "kappa-library.terms",
      "description": "This module provides tools for constructing, serializing, and transforming algebraic and boolean expressions, including arithmetic operations, JSON conversion, and pretty-printing. It operates on annotated expression trees parameterized by contextual data types, enabling dependency analysis (e.g., time, event, variable tracking), constant propagation, and property verification in formal modeling contexts such as rule-based systems. Use cases include modeling dynamic systems where expressions represent rates, constraints, or state transitions requiring precise dependency management and optimization.",
      "description_length": 605,
      "index": 17,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_terms.Contact_map",
      "library": "kappa-library.terms",
      "description": "This module represents contact maps as 2D arrays of integer sets, capturing interactions between sites in Kappa models. It provides functions to print contact maps and cycles in Kappa syntax, and to serialize/deserialize them to/from JSON. It is used to analyze and persist connectivity information in rule-based models.",
      "description_length": 320,
      "index": 18,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_terms.Pattern",
      "library": "kappa-library.terms",
      "description": "This module organizes pattern graphs with nodes, links, and internal states, enabling operations like comparison, merging, and matching in biochemical interaction models. It works with agent types, site identifiers, and counters, using auxiliary sets and maps to manage domains, track relationships, and maintain per-pattern state. Child modules enhance these capabilities with specialized containers for mapping and grouping pattern identifiers, supporting set operations, structured navigation, and environment tracking. Examples include logging-aware transformations, probabilistic pattern selection, and serializing navigation paths for transition system generation.",
      "description_length": 670,
      "index": 19,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_terms.Instantiation",
      "library": "kappa-library.terms",
      "description": "This module enables transforming, substituting, and comparing agent-based events and actions between abstract and concrete representations, using integer-based binding states and renaming maps. It operates on Kappa terms like tests, actions, and events, supporting both direct agent ID replacement and function-driven substitutions. Key applications include rule-based modeling workflows requiring dynamic identifier resolution, serialization to JSON for data interchange, and structured comparison of biochemical interaction patterns.",
      "description_length": 535,
      "index": 20,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_terms",
      "library": "kappa-library.terms",
      "description": "This module processes and manipulates Kappa models through compilation, transformation, and analysis of rule-based structures. It centers on data types like algebraic expressions, rule mixtures, contact maps, and agent-based patterns, supporting operations such as pattern matching, constant propagation, renaming, and serialization. Users can compile ambiguous rules into structured patterns, analyze dependencies in expressions, simulate biochemical reactions using site graphs, and decompile contact maps into readable biological patterns. Specific tasks include validating rule preconditions, normalizing reaction rates, extracting connected components, and managing simulation configurations for trace output and model analysis.",
      "description_length": 733,
      "index": 21,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_runtime.Counter.Efficiency",
      "library": "kappa-library.runtime",
      "description": "Handles serialization and deserialization of simulation progress counters to and from JSON. Works with a structured type `t` containing arrays and mutable integer fields tracking simulation events. Used to persist or transmit simulation state snapshots efficiently using JSON formatting.",
      "description_length": 287,
      "index": 22,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_runtime.Generic_rule_interpreter.Make",
      "library": "kappa-library.runtime",
      "description": "This module facilitates graph rewriting operations for Kappa models, enabling rule application, instance selection, and state manipulation with support for both deterministic and probabilistic execution. It operates on state structures containing graph data, randomization parameters, and tracked observables, while managing transformations of site graphs and chemical reaction networks through instance-based updates and dependency tracking. The implementation addresses use cases in biochemical simulation, such as dynamic state management, activity tracking, and statistics reporting for complex cellular processes.",
      "description_length": 618,
      "index": 23,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_runtime.Trace.Simulation_info",
      "library": "kappa-library.runtime",
      "description": "This module tracks simulation metadata such as event counts and story identifiers, supporting operations to compare, update, and serialize simulation state. It works with simulation info records containing event indices, story IDs, and profiling data. Use it to manage and persist simulation traces in JSON format or to correlate events across different simulation runs.",
      "description_length": 370,
      "index": 24,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_runtime.Instances_sig.S",
      "library": "kappa-library.runtime",
      "description": "This module manages dynamic collections of rectangular instances in a Kappa model, supporting operations to update, validate, count, and select instances based on patterns and connected components. It works with Kappa patterns, site graphs, and integer identifiers to represent and manipulate instance embeddings. Concrete use cases include tracking valid pattern matches during simulation, efficiently counting and selecting molecule complexes, and updating root mappings when connectivity changes during rule application.",
      "description_length": 523,
      "index": 25,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_runtime.Roots",
      "library": "kappa-library.runtime",
      "description": "This module manages dynamic equivalence classes of pattern identifiers during runtime, primarily using union-find operations to track connected components in a graph representation. It supports merging and splitting components, updating root mappings, and querying the number of distinct components associated with patterns. These operations are critical for efficiently maintaining connectivity information in dynamic graphs, such as those used in rule-based modeling and simulation of biochemical systems.",
      "description_length": 507,
      "index": 26,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kappa_runtime.Resource_strings",
      "library": "kappa-library.runtime",
      "description": "This module defines string constants used for JavaScript resources in a Kappa runtime environment. It includes `common_js` and `flux_js`, which likely represent JavaScript code or file paths required for client-side execution. These strings are directly used during runtime initialization or web interface setup.",
      "description_length": 312,
      "index": 27,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kappa_runtime.Counter",
      "library": "kappa-library.runtime",
      "description": "This module manages simulation state through time progression, event counting, and rule tracking, using a `Counter.t` structure to capture temporal and event-based metrics. It supports serialization to JSON via its child module, enabling efficient persistence or transmission of simulation snapshots. Main operations include incrementing event counts, applying time steps, and computing progress ratios, with specific use cases like enforcing simulation termination, optimizing plotting intervals, and analyzing blocked or null events.",
      "description_length": 535,
      "index": 28,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_runtime.State_interpreter",
      "library": "kappa-library.runtime",
      "description": "This module implements an event loop for simulating biological systems using rule-based models. It manages the execution of rule applications, modification of system states, and tracking of observables over time. Key operations include initializing the simulation state, processing modifications, running a single event loop step, and finalizing the simulation. It works with models defined in `Kappa_terms`, rule interpreters, counters, and state interpreters, producing observable values and updated system states. Concrete use cases include executing stochastic simulations of biochemical reactions and monitoring system behavior through observables.",
      "description_length": 653,
      "index": 29,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_runtime.Expr_interpreter",
      "library": "kappa-library.runtime",
      "description": "This module evaluates algebraic and boolean expressions using counters, time values, and functions to retrieve algebraic expressions, mixture counts, and token values. It operates on `Kappa_terms.Primitives.alg_expr`, `Kappa_terms.Alg_expr.bool`, and related structures involving patterns and identifiers. Concrete use cases include computing the numerical value of an algebraic expression or evaluating a boolean condition based on a rule's state in a biochemical reaction model.",
      "description_length": 480,
      "index": 30,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kappa_runtime.Data",
      "library": "kappa-library.runtime",
      "description": "This module handles serialization, deserialization, and formatting of simulation data for biochemical models, supporting JSON, TSV, DOT, and HTML formats. It operates on structured data types like snapshots (capturing agent states and tokens), DIN records (tracking rule fluxes), plots, and diagnostic messages with positional metadata. Key use cases include exporting simulation outputs for analysis, generating visualizations, and logging warnings or initial conditions with contextual details.",
      "description_length": 496,
      "index": 31,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_runtime.Replay",
      "library": "kappa-library.runtime",
      "description": "This module constructs and manipulates system states by applying trace steps to build Kappa mixtures. It operates on graph structures representing agent interactions, tracking time, events, and connected components during simulation replay. Functions support step validation, state transitions, and distance calculations between unary instances of binary rules, enabling precise reconstruction of dynamic biological processes from execution traces.",
      "description_length": 448,
      "index": 32,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kappa_runtime.Instances_sig",
      "library": "kappa-library.runtime",
      "description": "This module provides tools for working with rectangular instances, enabling the creation, manipulation, and analysis of structured two-dimensional data such as grids or matrices. It supports spatial and index-based operations, with applications in game boards, image buffers, and spatial simulations. The child module extends this functionality to dynamic collections within a Kappa model, allowing pattern-based updates, validation, and selection of connected components. Together, they enable efficient tracking, counting, and transformation of instance embeddings during rule-based simulations.",
      "description_length": 597,
      "index": 33,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_runtime.Instances",
      "library": "kappa-library.runtime",
      "description": "This module manages dynamic collections of pattern instances within a Kappa model, supporting operations to receive messages, update structural roots, and maintain connectivity during simulations. It provides functions to count, pick, and enumerate instances of patterns or pairs of patterns, enabling rule application based on current system states. Concrete use cases include tracking molecular complexes, validating pattern embeddings, and selecting reaction targets in stochastic simulations.",
      "description_length": 496,
      "index": 34,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kappa_runtime.Fluxmap",
      "library": "kappa-library.runtime",
      "description": "This module tracks and updates dynamic interaction networks using four key operations. It manipulates `din_data` structures to record flux values and hits between rules, supporting precise runtime analysis of rule-based models. Functions like `incr_flux_flux` and `incr_flux_hit` modify flux data, while `create_flux` and `stop_flux` initialize and finalize flux tracking for specific rule interactions.",
      "description_length": 403,
      "index": 35,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kappa_runtime.Trace",
      "library": "kappa-library.runtime",
      "description": "This module enables the construction, inspection, and serialization of simulation traces, tracking events like rule applications, initializations, and observations. It provides trace data structures with JSON conversion and file I/O support, along with metadata extraction for analysis and debugging. The included submodule handles simulation metadata, offering operations to manage event counts, story identifiers, and profiling data within simulation info records. Use the combined functionality to persist traces, compare simulation runs, or exchange trace data in standardized JSON formats.",
      "description_length": 594,
      "index": 36,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kappa_runtime.Generic_rule_interpreter",
      "library": "kappa-library.runtime",
      "description": "This module enables graph rewriting for Kappa models, supporting rule application, instance selection, and state manipulation in both deterministic and probabilistic modes. It operates on state structures containing graph data, randomization parameters, and observables, transforming site graphs and reaction networks through instance-based updates and dependency tracking. Users can simulate biochemical processes, track dynamic state changes, and report statistics for complex cellular systems. Example use cases include modeling signaling pathways, managing rule-based transformations, and analyzing reaction dependencies in stochastic simulations.",
      "description_length": 651,
      "index": 37,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_runtime.Rule_interpreter",
      "library": "kappa-library.runtime",
      "description": "This module interprets and applies rule-based transformations in biochemical systems by evaluating algebraic and boolean expressions, modifying agent-site graphs, and managing state changes through counters and connectivity caches. It validates rule instances to ensure consistency during simulations and supports dynamic updates to interaction networks. This facilitates modeling complex biological processes like signal transduction or metabolic pathways where entities undergo structural changes governed by predefined rules.",
      "description_length": 528,
      "index": 38,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kappa_runtime",
      "library": "kappa-library.runtime",
      "description": "This module orchestrates rule-based simulations of biochemical systems by integrating dynamic graph connectivity, state management, and event-driven execution. It centers on data types like `Counter.t` for tracking time and events, graph structures for representing agent interactions, and algebraic expressions for evaluating system states. Union-find operations maintain connected components, while flux tracking records rule interactions and serialization modules export simulation data in formats like JSON and TSV. Users can simulate stochastic biochemical reactions, monitor observables, reconstruct execution traces, and analyze dynamic network changes with support for pattern matching, rule application, and state validation.",
      "description_length": 734,
      "index": 39,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "Kappa_site_graphs.Agent.SetMap.Map",
      "library": "kappa-library.mixtures",
      "description": "This module manages maps with agent identifiers as keys and polymorphic values, enabling efficient insertions, deletions, and lookups alongside set-theoretic operations (union, intersection, difference) for combining agent sets. It includes logging-aware variants to track freshness during modifications, transformations via mapping and folding, and JSON serialization with customizable converters. Designed for agent-based modeling scenarios requiring dynamic data management, merging, or splitting of agent sets with sparse domains or restricted key ranges.",
      "description_length": 559,
      "index": 40,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_site_graphs.Agent.SetMap.Set",
      "library": "kappa-library.mixtures",
      "description": "This module supports core set operations like union, intersection, and difference, along with logging-aware variants for traceability in agent state management. It works with sets of agents, providing specialized functions to add or remove elements with status flags and retrieve elements (e.g., random, min, max) using option types to handle empty cases. These capabilities are particularly useful for modeling dynamic agent interactions and ensuring robust error handling during graph transformations.",
      "description_length": 503,
      "index": 41,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_site_graphs.Agent.SetMap",
      "library": "kappa-library.mixtures",
      "description": "This module implements a set-based map structure using agents as keys, enabling efficient lookups, insertions, and set operations over agent collections. It integrates maps and sets to support operations like union, intersection, and difference, with logging-aware variants for tracking modifications and custom serialization through JSON converters. The module allows working with polymorphic values, status flags, and sparse key domains, facilitating tasks such as tracking agent neighborhoods, managing equivalence classes, or aggregating properties in rule-based models. Specific capabilities include random element selection, min/max retrieval with option types, and transformations via mapping and folding over dynamic agent sets.",
      "description_length": 736,
      "index": 42,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_site_graphs.Signature",
      "library": "kappa-library.mixtures",
      "description": "This module manages agent definitions in Kappa models, focusing on querying site and internal state identifiers, validating counter constraints, and mapping agent-site-state relationships. It operates on structured representations of agent signatures (`t`) and signature collections (`s`), along with counters and site links, to enforce interaction rules and metadata consistency. Key use cases include modeling biochemical systems with structured agents, validating allowed molecular interactions, and serializing agent data for analysis or visualization workflows.",
      "description_length": 566,
      "index": 43,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kappa_site_graphs.User_graph",
      "library": "kappa-library.mixtures",
      "description": "This module defines data structures for representing biological molecular graphs, including nodes with typed ports and links between them. It supports operations for serializing and printing connected components in JSON and DOT formats. Use cases include modeling biochemical interactions in Kappa language tools and visualizing graph structures for simulation analysis.",
      "description_length": 370,
      "index": 44,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_site_graphs.Edges",
      "library": "kappa-library.mixtures",
      "description": "This module offers operations to construct and modify agent-site graphs by adding or removing agents, free sites, internal states, and inter-agent links, with optional tracking of connected components during mutations. It supports traversal and analysis tasks such as connectivity checks, neighbor iteration, path validation, and component snapshot generation, operating on agent-site graphs represented as typed structures with agent identifiers and site-level interactions. These capabilities are particularly useful for modeling biochemical systems where precise tracking of molecular interactions and dynamic connectivity is required.",
      "description_length": 638,
      "index": 45,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kappa_site_graphs.Agent",
      "library": "kappa-library.mixtures",
      "description": "Agents are represented as identifier-sort pairs with operations for creation, comparison, renaming, and formatted output, supporting identity management and serialization in graph transformations. The module provides set-based maps keyed by agents for efficient collection manipulation, including union, intersection, and difference with logging and JSON serialization. These structures enable tracking neighborhoods, managing equivalence classes, and aggregating properties dynamically through mapping, folding, and random or min/max selection. Direct operations and submodule utilities combine to support complex agent-based modeling and transformation workflows.",
      "description_length": 665,
      "index": 46,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_site_graphs.Counters_info",
      "library": "kappa-library.mixtures",
      "description": "This module manages counter information for site graphs, providing functions to translate, apply, and convert integer values based on counter signatures. It works with arrays of optional counter signature structures that include bounds, visibility origin, and default values, supporting operations like printing, serialization, and retrieving conversion metadata. Concrete use cases include handling counter semantics during model transformation, enforcing bounds, and tracking counter provenance in Kappa models.",
      "description_length": 513,
      "index": 47,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_site_graphs.Snapshot",
      "library": "kappa-library.mixtures",
      "description": "This module represents and manipulates snapshots of connected components in a site graph. It provides operations to build, update, and convert connected components, tracking site links and states within nodes. Key functions include creating empty snapshots, incrementing component counts, converting raw components to user-facing ones, and exporting component data with counts. It works directly with arrays of nodes and sites, handling typed identifiers and state information for biochemical modeling tasks.",
      "description_length": 508,
      "index": 48,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_site_graphs.Navigation",
      "library": "kappa-library.mixtures",
      "description": "This module provides operations for navigating and manipulating abstract paths in a site graph, including steps, edges, and agent renamings. It supports data types such as `abstract` (representing existing or fresh agents), `step`, and `t`, along with functions to convert, rename, and validate these structures. Concrete use cases include checking edge compatibility, concretizing paths, and extending renamings while validating graph navigation steps.",
      "description_length": 453,
      "index": 49,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kappa_site_graphs",
      "library": "kappa-library.mixtures",
      "description": "This collection of modules provides a comprehensive framework for modeling and manipulating biochemical systems using agent-based site graphs. It supports structured agent definitions with typed ports and internal states, enabling precise modeling of molecular interactions and constraints such as counters and connectivity. Key operations include graph construction, modification, and traversal, with support for serialization, visualization, and dynamic analysis of connected components and abstract paths. Examples include validating molecular binding rules, tracking state changes across simulations, and generating visual representations of interaction networks.",
      "description_length": 667,
      "index": 50,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_data_structures.Mods.CharSetMap.Map",
      "library": "kappa-library.generic",
      "description": "This module offers associative container operations for maps pairing character sets with arbitrary values, supporting transformations like union, difference, and intersection alongside folds, filters, and domain restrictions. It integrates logging-aware variants for error handling during stateful operations and includes serialization to JSON for data persistence or exchange. Use cases include managing hierarchical configurations, analyzing symbolic data relationships, or tracking state changes in systems requiring traceable modifications.",
      "description_length": 544,
      "index": 51,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kappa_data_structures.Mods.StringSetMap.Set",
      "library": "kappa-library.generic",
      "description": "This module offers set operations on string-based elements, including algebraic manipulations (union, intersection, difference), membership checks, filtering, and element selection (random, min, max) with both ordered and stateful transformations. It works with sets of strings, providing standard and logging-enabled variants for safe, traceable state changes. Use cases include scenarios requiring robust set algebra with error tracking, such as symbolic computation systems or configuration management tools where auditing transformations is critical.",
      "description_length": 554,
      "index": 52,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kappa_data_structures.Cache.Cache.O",
      "library": "kappa-library.generic",
      "description": "This module implements a cache structure with ordered elements. It supports comparison and pretty-printing of cached values. Useful for managing and displaying ordered collections of computed results in a memory-efficient way.",
      "description_length": 226,
      "index": 53,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_data_structures.Mods.StringSetMap.Map",
      "library": "kappa-library.generic",
      "description": "This module provides functional map manipulation with keys based on string sets and polymorphic values, supporting operations like union, difference, and merge with logging-aware variants for error tracking. It combines dense and sparse map transformations through higher-order functions such as fold, map, and mapi, while enabling JSON serialization and pretty-printing for data interchange and auditing. Typical applications include managing hierarchical configurations, tracking symbolic expressions, and processing structured data with customizable logging and error resilience.",
      "description_length": 582,
      "index": 54,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kappa_data_structures.SetMap.Make.Set",
      "library": "kappa-library.generic",
      "description": "This module provides creation, modification, and set-theoretic operations (union, intersection, difference) alongside element queries (membership, min/max, random retrieval) for a purely functional set structure (`Set.t`) with elements of type `Set.elt`. Logging-aware variants (e.g., `add_with_logs`) return results paired with error logs, enabling safe, exception-free manipulation. It supports use cases like ordered element processing, random sampling, and robust error handling in functional workflows requiring deterministic or probabilistic set transformations.",
      "description_length": 568,
      "index": 55,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_data_structures.Mods.IntSetMap.Map",
      "library": "kappa-library.generic",
      "description": "This module supports safe insertion, deletion, and lookup operations on maps with integer or integer set keys paired with polymorphic values, including set-theoretic combinations (union, difference) and bidirectional transformations. It provides functional iteration, filtering, and serialization capabilities alongside customizable logging for error auditing during map manipulation. These features are suited for applications requiring precise key management, such as sparse data modeling or event stream processing with audit trails.",
      "description_length": 536,
      "index": 56,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_data_structures.Mods.IntSetMap.Set",
      "library": "kappa-library.generic",
      "description": "This module provides operations for manipulating sets of integers, including union, intersection, difference, filtering, and partitioning, along with element selection based on ordering or randomness (e.g., min, max, random). It works with sets of integer keys, supporting both basic transformations and logging-enabled variants that handle errors during modifications like additions or removals. These capabilities are useful in scenarios requiring tracked updates, existence checks, or ordered/random sampling, such as dynamic data analysis or state management systems.",
      "description_length": 571,
      "index": 57,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_data_structures.Mods.CharSetMap.Set",
      "library": "kappa-library.generic",
      "description": "This module provides set-theoretic operations (union, intersection, difference, subset checks) and element manipulation (addition, removal, random selection, min/max extraction) for a specialized structure representing sets of character sets. It works with `CharSetMap.Set.t` values, which encapsulate mappings between character sets and their associated data, supporting logging-aware transformations and error handling through monadic wrappers. The functionality is particularly useful in scenarios requiring audited set manipulations, such as symbolic computation or constraint-solving systems where character set relationships must be tracked and validated.",
      "description_length": 661,
      "index": 58,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_data_structures.Mods.String2SetMap.Set",
      "library": "kappa-library.generic",
      "description": "This module implements standard set operations for string collections with support for union, intersection, difference, and element manipulation, alongside logging-aware variants to track errors during stateful modifications. It provides utilities to retrieve specific elements like random, minimum, or maximum values from sets, all operating on an abstract string set type. These capabilities are particularly useful in scenarios requiring precise set management with audit trails or ordered element access, such as symbolic computation or state-tracking systems.",
      "description_length": 564,
      "index": 59,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_data_structures.List_util.Infix",
      "library": "kappa-library.generic",
      "description": "This module defines an infix operator `($$)` that prepends a value from an option to a list if the option is `Some`, effectively filtering out `None` values during list construction. It operates on `'a option` and `'a list` types. A concrete use case is building lists dynamically where elements may be conditionally included based on optional values.",
      "description_length": 351,
      "index": 60,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kappa_data_structures.SetMap.S",
      "library": "kappa-library.generic",
      "description": "Implements associative containers with unique keys and efficient lookups, supporting operations like insertion, deletion, and membership testing. Works with ordered elements using customizable comparison functions. Used for managing symbol tables, caches, and indexed collections in compilers and analyzers.",
      "description_length": 307,
      "index": 61,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_data_structures.Mods.Int2SetMap",
      "library": "kappa-library.generic",
      "description": "This module implements finite maps indexed by integer pairs, offering efficient lookup, insertion, and traversal. It supports standard operations like `add`, `find`, `remove`, and `iter`, along with set-like key management. Integer pairs act as keys, making it ideal for bidirectional relationships or matrix-like data. The module streamlines complex key handling while maintaining performance and direct access to map operations.",
      "description_length": 430,
      "index": 62,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_data_structures.SetMap.S-Set",
      "library": "kappa-library.generic",
      "description": "This module implements a functional set interface with operations for union, intersection, difference, filtering, and ordered/random element selection (e.g., min, max, random), all acting on immutable `Set.t` structures containing elements of type `elt`. It provides both pure transformations and logging-aware variants that propagate error information, enabling robust data processing pipelines where immutable set manipulations and detailed error tracking are critical, such as in symbolic computation or stateful system modeling. Use cases include algorithms requiring deterministic set operations with optional error auditing and element sampling strategies that depend on ordering or probabilistic selection.",
      "description_length": 713,
      "index": 63,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kappa_data_structures.Mods.StringSetMap",
      "library": "kappa-library.generic",
      "description": "This module manages associative maps keyed by sets of strings, enabling efficient storage and retrieval of values tied to dynamic, set-based identifiers. It supports core operations like insertion, removal, and lookup, while combining set algebra and map transformations to handle complex dependencies or group-based associations. With integrated logging variants, it allows tracking of changes and errors during operations such as merging or filtering, making it suitable for configuration systems or symbolic computation. It also supports JSON serialization and pretty-printing, facilitating data interchange and auditing in structured workflows.",
      "description_length": 648,
      "index": 64,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kappa_data_structures.SetMap.Proj",
      "library": "kappa-library.generic",
      "description": "This module projects elements of sets and maps from one type to another using a provided function, supporting both pure and monadic operations. It transforms sets by applying a function to each element, and partitions sets into maps that group elements by their transformed values. Use cases include aggregating or categorizing data based on a computed key, such as grouping elements by a hash or mapping identifiers to related values.",
      "description_length": 435,
      "index": 65,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_data_structures.SetMap.Make",
      "library": "kappa-library.generic",
      "description": "This module implements purely functional sets and maps parameterized by a custom order, supporting operations like union, intersection, difference for sets, and insertion, lookup, and traversal for maps. It introduces the core data types `Set.t` and `Map.t`, where sets offer element queries such as membership, min/max, and random retrieval, and maps provide key-value associations with ordered traversal. Logging-aware variants like `add_with_logs` enable error-safe manipulation, making it suitable for symbolic manipulation, state tracking, and robust functional workflows involving ordered data transformations.",
      "description_length": 616,
      "index": 66,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_data_structures.Mods.String2SetMap",
      "library": "kappa-library.generic",
      "description": "This module organizes data as a hierarchical map where each key is a pair of strings, and the corresponding value behaves as a set indexed by strings. It enables efficient insertion, lookup, and traversal across both the pair-keyed map structure and the nested string sets. The first child module enriches this structure with standard and logging-aware set operations\u2014such as union, intersection, and difference\u2014alongside utilities to extract specific elements like minimum or maximum values. Together, they support advanced use cases like symbolic relationship tracking or stateful systems requiring audit trails and ordered access.",
      "description_length": 633,
      "index": 67,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_data_structures.DynamicArray.DynArray",
      "library": "kappa-library.generic",
      "description": "This module implements a dynamic array with contiguous storage for elements of a fixed type, supporting efficient indexing, resizing, and in-place updates. It provides operations for array creation, element access and mutation, slicing, concatenation, iteration, mapping, and formatted printing. Use cases include handling variable-length sequences with frequent index-based access or modification, such as implementing buffers, sequences of events, or mutable collections in performance-sensitive contexts.",
      "description_length": 507,
      "index": 68,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_data_structures.Mods.CharSetMap",
      "library": "kappa-library.generic",
      "description": "This module efficiently maps characters to values using optimized trie structures, supporting insertion, lookup, and traversal operations tailored to character-based keys. It extends to child modules that provide set-theoretic operations on character sets, enabling union, intersection, and difference computations, along with transformations, filtering, and serialization to JSON. The combined functionality supports use cases such as parsing workflows, managing hierarchical configurations, and implementing constraint-solving systems with audited modifications. You can, for example, build a tokenizer that maps character ranges to token types, then analyze or merge those mappings while tracking changes or exporting them for external processing.",
      "description_length": 750,
      "index": 69,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kappa_data_structures.GenArray.GenArray",
      "library": "kappa-library.generic",
      "description": "This module implements an extended array structure that supports arbitrary integer indexing up to `max_int`, enabling creation, modification, and traversal of large arrays beyond standard OCaml array limits. It provides operations for array construction, element access, slicing, concatenation, and mapping, along with indexed iteration and folding functions. Concrete use cases include handling large genomic sequences, simulation grids, or numerical data buffers where standard array sizes are insufficient.",
      "description_length": 509,
      "index": 70,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kappa_data_structures.Mods.IntSetMap",
      "library": "kappa-library.generic",
      "description": "This module manages finite maps keyed by integers, enabling efficient insertion, lookup, and traversal over polymorphic values, while integrating set-theoretic operations for key set manipulation and transformation. It supports core operations like union, difference, filtering, and ordered or random selection on both maps and integer sets, with logging-enabled variants for error auditing during modifications. You can use it to model sparse data with integer indices, perform dynamic programming with tracked updates, or manage node attributes in graph algorithms using safe, bidirectional transformations. The combined interface allows functional iteration, serialization, and precise key management across integer-keyed maps and integer sets.",
      "description_length": 747,
      "index": 71,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kappa_data_structures.Cache.Cache",
      "library": "kappa-library.generic",
      "description": "This module implements a bounded cache with ordered elements, supporting insertion, iteration, and folding over stored values. It provides operations to add elements, retrieve the most recently added item, and traverse the cache in insertion order, while also supporting comparison and pretty-printing of cached values. The structure is useful for managing and displaying ordered collections of computed results in a memory-efficient way, particularly in parsing or state-tracking contexts where recent values need to be tracked efficiently. Submodules enhance the core functionality by adding capabilities for structured traversal and formatted output.",
      "description_length": 653,
      "index": 72,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_data_structures.Hashed_list.Make",
      "library": "kappa-library.generic",
      "description": "This module implements a hashed list structure that efficiently caches shared prefixes of lists, enabling structural equality checks and memory-efficient storage. It works with elements of type `A.t` and maintains a cache to de-duplicate common list suffixes. Concrete use cases include representing and comparing sequences in symbolic computation or parsing, where identical sub-sequences frequently occur and need to be compared quickly.",
      "description_length": 439,
      "index": 73,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_data_structures.SetMap.OrderedType",
      "library": "kappa-library.generic",
      "description": "This module defines a type `t` along with a total ordering function `compare` and a pretty-printing function `print`. It is used to specify the element type for ordered sets and maps, ensuring consistent comparison and display behavior. Concrete use cases include defining key types for maps and elements for sets where ordering and readable output are required.",
      "description_length": 362,
      "index": 74,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kappa_data_structures.Operator.DepSet",
      "library": "kappa-library.generic",
      "description": "This module provides set-theoretic operations for dependency management, supporting union, intersection, difference, and ordered/random element retrieval with error-aware logging and state tracking. It operates on sets of dependency elements (`elt`) with optional audit trails, enabling robust handling of dynamic dependencies in scenarios like resource allocation or constraint resolution. Specialized functions for freshness checks and ordered traversal cater to use cases requiring precise dependency ordering or conflict detection.",
      "description_length": 535,
      "index": 75,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_data_structures.SetMap.Map",
      "library": "kappa-library.generic",
      "description": "This module implements a polymorphic map structure with keys of type `elt` and values of type `'a`, supporting standard operations like insertion (`add`), deletion (`remove`), lookup (`find_option`), and set-like combinations (`merge`, `diff`). It emphasizes error-aware variants (e.g., `find_option_with_logs`) and monadic traversal for handling sparse data, comparisons, and JSON serialization. Use cases include managing dynamic datasets requiring robust error logging, structured merging of keyed values, or conversion to/from JSON representations.",
      "description_length": 552,
      "index": 76,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_data_structures.Cache.Cache-O",
      "library": "kappa-library.generic",
      "description": "This module defines a cache structure with operations to compare and print cache entries. It works with a polymorphic type `t` that represents cached values, supporting ordered comparisons and formatted output. Concrete use cases include managing transient data storage with ordering constraints, such as LRU eviction policies or time-based expiration with ordered keys.",
      "description_length": 370,
      "index": 77,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_data_structures.SetMap.Projection",
      "library": "kappa-library.generic",
      "description": "This module projects elements of sets and maps through a function, computing new collections based on the results. It supports both pure and monadic projections, allowing aggregation over mapped values and partitioning sets based on projection keys. Use cases include grouping elements by computed keys, aggregating values in maps based on projected keys, and transforming sets while handling potential errors in a monadic context.",
      "description_length": 431,
      "index": 78,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kappa_data_structures.SetMap.Proj2",
      "library": "kappa-library.generic",
      "description": "This module implements projection operations over a map by transforming elements using two functions and accumulating results in a nested map structure. It works with map_a, a map type parameterized by modules A, B, and C, and produces a map_b of map_c values. A concrete use case is aggregating elements by two keys derived from each element, such as grouping events by user and action type.",
      "description_length": 392,
      "index": 79,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_data_structures.Buffers.Buffers",
      "library": "kappa-library.generic",
      "description": "This module implements a buffer structure that supports dynamic resizing. It provides operations to create a buffer with a specified initial size, add elements to the buffer, iterate over its contents, and clean (reset) the buffer. Concrete use cases include efficiently accumulating data streams, managing temporary storage during parsing, and handling variable-length input in network protocols.",
      "description_length": 397,
      "index": 80,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_data_structures.Hashed_list.Hash",
      "library": "kappa-library.generic",
      "description": "This module implements a hashed list structure that allows efficient construction and comparison of lists using hash values. It provides operations to create, extend, and print hashed lists, along with a cache to store intermediate results for performance. Concrete use cases include managing sequences of elements where structural equality and fast hashing are needed, such as in symbolic computation or version tracking.",
      "description_length": 422,
      "index": 81,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_data_structures.SetMap.S-Map",
      "library": "kappa-library.generic",
      "description": "This module enables functional map manipulations including key-based updates, existence checks, and value transformations, with optional logging for error tracking. It operates on polymorphic maps where keys are of type `Map.elt` and values can be arbitrary, supporting advanced operations like merged traversals, difference detection, and monadic combinations. Typical use cases involve state management requiring precise key-value consistency, such as configuration synchronization or audit trail generation with structured data comparisons.",
      "description_length": 543,
      "index": 82,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_data_structures.SetMap.Projection2",
      "library": "kappa-library.generic",
      "description": "This module implements projection operations over maps with two element transformations. It takes a map of type `elt_a`, projects its elements into two new types `elt_b` and `elt_c`, and constructs a nested map structure `elt_b map_c map_b` using accumulation logic. It supports both pure and monadic projections, handling transformations with or without effect tracking.",
      "description_length": 371,
      "index": 83,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kappa_data_structures.Mods.DynArray",
      "library": "kappa-library.generic",
      "description": "This module implements a dynamic array with indexed access, allowing efficient resizing and manipulation of sequences of arbitrary type. It supports operations like element access, in-place updates, slicing, concatenation, and mapping, as well as iteration and folding with indices. Use cases include managing variable-length sequences in simulations, buffering data streams, and representing indexed collections requiring fast access and modification.",
      "description_length": 452,
      "index": 84,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_data_structures.Pp_html",
      "library": "kappa-library.generic",
      "description": "This module generates HTML pages for visualizing graphs. It takes a title, optional subtitle, list of dependencies, and formatting functions for header, core content, and footer to produce a complete HTML document. Useful for rendering graph structures with custom layouts and metadata in web-based visualizations.",
      "description_length": 314,
      "index": 85,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_data_structures.Mods",
      "library": "kappa-library.generic",
      "description": "This module provides comparison and equality primitives for integers and pairs, alongside optimized map and set implementations for string, integer, and character keys, enabling efficient handling of sparse data, symbol tables, and multi-dimensional indices. It includes a dynamic array for indexed sequence manipulation and supports set-theoretic operations across key types, with logging-aware variants for audit trails during transformations. You can map integer pairs to values for matrix-like structures, associate string sets with values for configuration systems, or use character tries for tokenization workflows. The combination of direct key-value operations, hierarchical maps, and polymorphic sets supports parsing, symbolic computation, and stateful systems requiring structured data interchange and ordered access.",
      "description_length": 828,
      "index": 86,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kappa_data_structures.Loc",
      "library": "kappa-library.generic",
      "description": "This module enables creation and manipulation of location annotations that track line ranges and character positions in files, using `Loc.t` for precise source mapping and `'a annoted` to pair values with their locations. It supports operations like merging overlapping ranges, checking positional inclusion, and serializing to JSON with filename mappings, while handling optional strings and nested annotated data. These capabilities are particularly useful for error diagnostics in parsers, source-to-source transformations, and tools requiring precise positional metadata.",
      "description_length": 575,
      "index": 87,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_data_structures.Stop",
      "library": "kappa-library.generic",
      "description": "This module provides functions to construct and deconstruct a sum type representing either a successful value or a stopping condition. It works with pairs of types `'a` and `'b`, where one represents success and the other represents a stop. Concrete use cases include modeling computations that may terminate early with a result of type `'b` or continue with a value of type `'a`.",
      "description_length": 380,
      "index": 88,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_data_structures.Fractions",
      "library": "kappa-library.generic",
      "description": "This module implements arithmetic operations for fractions, including addition, subtraction, multiplication, inversion, and division, along with equality checks and constants for zero and one. It works with a fraction type represented by a record with integer numerator and denominator. Use this module to perform precise rational number calculations, such as combining chemical reaction rates or managing exact divisions in symbolic computations.",
      "description_length": 447,
      "index": 89,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kappa_data_structures.Crc32",
      "library": "kappa-library.generic",
      "description": "Computes CRC32 checksums over string segments using an optional initial checksum value. Accepts a string, start index, and length to process, returning the updated checksum. Useful for validating data integrity in binary formats or network protocols.",
      "description_length": 250,
      "index": 90,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kappa_data_structures.Infinite_buffers",
      "library": "kappa-library.generic",
      "description": "This module implements infinite buffers that dynamically expand as elements are added. It supports creating a buffer with a specified initial size and default value, adding elements to the buffer, iterating over its contents, and cleaning (resetting) the buffer to its initial state. These buffers are useful for scenarios requiring unbounded sequential storage, such as accumulating log entries or processing streaming data.",
      "description_length": 425,
      "index": 91,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_data_structures.DynamicArray",
      "library": "kappa-library.generic",
      "description": "This module provides a dynamic array implementation with contiguous storage for elements of a fixed type, enabling efficient indexing, resizing, and in-place updates. Key operations include creation, access, mutation, slicing, concatenation, iteration, mapping, and formatted printing, all optimized for performance. It supports use cases like buffers, event sequences, and mutable collections where variable-length data and frequent index-based operations are required. For example, it can efficiently grow a buffer as elements are appended or modify elements in place during iteration.",
      "description_length": 587,
      "index": 92,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_data_structures.Tools",
      "library": "kappa-library.generic",
      "description": "This module offers numerical computation tools (gcd, lcm, factorial, Cantor pairing), array/list transformation utilities (index-aware mapping/folding, deduplication, priority sorting), and string processing functions (case conversion, suffix manipulation, unique name generation). It operates on integers, arrays of tuples, generic lists, and strings. These functions support tasks like data normalization, combinatorial calculations, and text stream processing where structured transformations are required.",
      "description_length": 509,
      "index": 93,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kappa_data_structures.SetMap",
      "library": "kappa-library.generic",
      "description": "This module provides purely functional sets and maps for deterministic, exception-free manipulation of ordered collections, supporting core operations like union, intersection, and key-based transformations. It introduces `Set.t` and `Map.t` as the primary immutable data structures, with operations such as `add`, `find_option`, `filter`, and `merge`, alongside logging-aware variants like `add_with_logs` for error-safe processing. Child modules extend functionality with projections, custom orderings, and multi-key aggregations, enabling use cases such as grouping elements by computed keys, transforming sets with ordering constraints, and managing symbol tables with structured key-value consistency. Specific applications include symbolic computation, state tracking in formal verification, and robust data aggregation pipelines with customizable comparison and error logging.",
      "description_length": 883,
      "index": 94,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_data_structures.Color",
      "library": "kappa-library.generic",
      "description": "This module defines a set of color variants and provides a function to convert each color to its corresponding RGB triple. It works with the `color` sum type and returns integer tuples representing color values. Useful for rendering or visualization tasks where specific color mappings are required.",
      "description_length": 299,
      "index": 95,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kappa_data_structures.Nbr",
      "library": "kappa-library.generic",
      "description": "This module defines a variant type `t` that represents numeric values as `float`, `int`, or `int64`, enabling arithmetic operations, comparisons, and type conversions that preserve type distinctions while supporting mixed-type computations. It includes utilities for JSON serialization, string parsing, and conditional iteration, facilitating robust handling of heterogeneous numeric data. These capabilities are particularly valuable in dynamic environments where precise type management and interoperability with external formats like JSON or textual representations are required.",
      "description_length": 582,
      "index": 96,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_data_structures.Circular_buffers",
      "library": "kappa-library.generic",
      "description": "This module implements a circular buffer with fixed capacity, supporting operations to create, add elements, iterate over contents, and reset the buffer. It works with a polymorphic type `'a t`, maintaining internal state for efficient overwriting of oldest elements. Concrete use cases include logging recent events, maintaining a sliding window of data, or limiting memory usage in streaming applications.",
      "description_length": 407,
      "index": 97,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kappa_data_structures.Fifo",
      "library": "kappa-library.generic",
      "description": "Implements a first-in-first-out queue with operations to add elements to the back and remove elements from the front. Works with generic elements wrapped in a dedicated type representing the queue structure. Useful for managing event queues, scheduling tasks in order, or buffering data streams where strict ordering must be preserved.",
      "description_length": 335,
      "index": 98,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_data_structures.ExceptionDefn",
      "library": "kappa-library.generic",
      "description": "This module manages a buffer of warning messages with associated locations, using a list of optional location and formatter pairs wrapped in a reference. It provides direct access to the buffer for logging and retrieving warnings during program execution. A concrete use case includes collecting and displaying parse-time warnings in a compiler or interpreter.",
      "description_length": 360,
      "index": 99,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_data_structures.Bigbuffer",
      "library": "kappa-library.generic",
      "description": "This module provides extensible buffers optimized for efficient accumulation of characters and strings, offering operations like `add_char`, `add_string`, and `add_substring` to append data incrementally. It works with a custom `bigstring` type based on Bigarray for efficient memory handling and exposes functions to inspect (`nth`), retrieve contents (`contents`), and manage buffer size (`clear`, `reset`). Concrete use cases include building large text outputs incrementally, such as log messages or dynamically generated files, where minimizing memory reallocations and avoiding quadratic time complexity in concatenation is critical.",
      "description_length": 639,
      "index": 100,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kappa_data_structures.GenArray",
      "library": "kappa-library.generic",
      "description": "This module implements arrays with bounds limited only by the maximum integer value, supporting efficient indexing and in-place updates for polymorphic elements. It provides operations for creation, access, modification, slicing, concatenation, mapping, and indexed iteration over large arrays, enabling use cases such as numerical simulations, big data processing, and genomic sequence handling. The module includes submodules that extend functionality for specialized array manipulations, offering a comprehensive interface for working with arbitrarily large mutable sequences beyond standard array limits. Specific operations include array construction with custom initializers, element-wise transformations, and fold-based reductions over massive datasets.",
      "description_length": 760,
      "index": 101,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_data_structures.Renaming",
      "library": "kappa-library.generic",
      "description": "This module manages finite injective mappings between natural numbers, offering operations for safe composition, inversion, and conflict detection when merging or extending mappings. It supports JSON serialization for persistence or inter-process communication, making it suitable for applications like variable renaming in formal verification or identifier reallocation in data transformation workflows.",
      "description_length": 404,
      "index": 102,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_data_structures.Cache",
      "library": "kappa-library.generic",
      "description": "This module provides a bounded cache with efficient key-value storage, supporting insertion, lookup, and size management under eviction policies like LRU. It includes submodules for ordered caches that enable iteration and folding over values in insertion order, as well as caches with polymorphic entries that support comparison and pretty-printing. Main data types include `t` for cached values and structures for ordered traversal. Examples include caching parsed ASTs with LRU eviction and tracking recent analysis results with ordered storage.",
      "description_length": 548,
      "index": 103,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_data_structures.Result_util",
      "library": "kappa-library.generic",
      "description": "This module provides functions for serializing, deserializing, and manipulating result values that carry status codes and structured error messages, including operations for mapping, binding, and folding over result values. It works with result types parameterized by `ok` and `error` values, each optionally annotated with a severity level, text message, and source location range. Concrete use cases include handling API responses with rich error diagnostics, transforming and combining computation outcomes with status tracking, and converting result values to and from JSON for communication or logging.",
      "description_length": 607,
      "index": 104,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kappa_data_structures.NamedDecls",
      "library": "kappa-library.generic",
      "description": "This module manages named declarations by mapping string identifiers to values with optional source location annotations. It supports creating named collections from arrays or lists, looking up elements by name or ID, transforming values, and serializing to or from JSON. Use cases include tracking variable bindings in a compiler or interpreter, managing configuration settings with named keys, and persisting named entities in a structured format.",
      "description_length": 449,
      "index": 105,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_data_structures.JsonUtil",
      "library": "kappa-library.generic",
      "description": "This module enables JSON serialization and deserialization of OCaml data structures such as lists, arrays, maps, key-value pairs, and variants, with support for optional fields, compact representations, and custom conversion handlers. It handles system-level Unix errors, floating-point numbers, and structured parsing tasks, providing efficient reading and writing via buffers and channels for applications like configuration parsing, data interchange, and error reporting in JSON-based systems.",
      "description_length": 496,
      "index": 106,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kappa_data_structures.List_util",
      "library": "kappa-library.generic",
      "description": "This module enhances list manipulation with functions for element extraction, transformation, and combination, supporting operations like `last`, `map_flatten`, and `merge_uniq`. It integrates with options and stateful logic for tasks like conditional filtering and sampling, while the `($$)` operator allows concise, safe list building from optional values. Direct functions handle list processing in parsing and set-like operations, and child modules enable idiomatic list construction patterns. Examples include flattening mapped lists, removing duplicates, and dynamically building lists with optional elements.",
      "description_length": 615,
      "index": 107,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kappa_data_structures.Buffers",
      "library": "kappa-library.generic",
      "description": "This module provides efficient byte buffer management with support for both fixed-size and dynamically resizable buffers, enabling low-level I/O, serialization, and binary data manipulation. It includes operations for appending, slicing, iterating, and resetting buffers, working with both mutable and immutable data representations. The resizable buffer submodule enhances flexibility by allowing dynamic expansion, ideal for accumulating data streams or handling variable-length input. Example uses include network packet assembly, file parsing, and temporary storage during protocol parsing.",
      "description_length": 594,
      "index": 108,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kappa_data_structures.Base64",
      "library": "kappa-library.generic",
      "description": "This module implements Base64 encoding and decoding per RFC 4648, supporting both the standard and URI-safe alphabets. It operates on bigstrings for efficient handling of large binary data and provides direct encoding to and decoding from Base64 strings. Use cases include safely transmitting binary data over media designed for ASCII text, such as embedding binary content in URLs or JSON payloads.",
      "description_length": 399,
      "index": 109,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_data_structures.ValMap",
      "library": "kappa-library.generic",
      "description": "This module implements a map structure with integer keys and integer values, supporting operations such as adding, removing, and checking membership of keys, as well as computing the total sum of all values. It provides a way to efficiently track and manipulate integer-indexed value associations, including retrieving the sum of values and printing the structure. It is useful in scenarios requiring fast key-based updates and aggregations, such as in counters or frequency tracking.",
      "description_length": 484,
      "index": 110,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kappa_data_structures.Hashed_list",
      "library": "kappa-library.generic",
      "description": "This module combines ordered list traversal with efficient key-based access through a hash table, enabling both fast lookups and insertion-order preservation. It supports operations to add, remove, and find elements by key, while child modules enhance it with structural equality, shared prefix caching, and hash-based comparison for sequences used in symbolic computation or version tracking. You can build and manipulate sequences that compare quickly for equality, cache intermediate results, or track recent items with unique keys. Examples include managing parser states with common sub-expressions or version histories where both order and identity matter.",
      "description_length": 662,
      "index": 111,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_data_structures.Pp",
      "library": "kappa-library.generic",
      "description": "This module enables structured text generation for collections like lists, sets, hashtables, and pairs by applying customizable formatting to elements and delimiters. It supports indexed or non-indexed traversal with user-defined separators, trailing elements, and type-specific rendering, primarily serving tools that require precise control over pretty-printed output. Key applications include code generation, data serialization, and diagnostic logging where human-readable representations of complex data are needed.",
      "description_length": 520,
      "index": 112,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_data_structures.IntCollection",
      "library": "kappa-library.generic",
      "description": "This module implements an imperative set of integers with operations for adding, removing, and checking membership of elements. It supports efficient size tracking, random element selection, and folding over elements. Use cases include managing dynamic collections of unique integers where mutation is required, such as tracking active identifiers or maintaining a set of indices during iterative computations.",
      "description_length": 410,
      "index": 113,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_data_structures.Random_tree",
      "library": "kappa-library.generic",
      "description": "This module implements a tree structure for efficiently managing weighted integer keys with probabilistic sampling. It supports operations to create and copy trees, add or retrieve weighted values, and sample a key based on its weight using a random state. Concrete use cases include weighted random selection in stochastic simulations and dynamic management of weighted event probabilities.",
      "description_length": 391,
      "index": 114,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_data_structures.Operator",
      "library": "kappa-library.generic",
      "description": "This module defines algebraic and boolean operator types with operations for JSON serialization, pretty-printing, and string conversion, working over variants like binary arithmetic, unary logical, and comparison operators. It includes dependency tracking structures such as `DepSet` and `rev_dep`, enabling management of dependencies in compiled expressions and generation of JSON representations for storage or communication. The set-theoretic submodule supports union, intersection, difference, and ordered traversal of dependencies, with audit trails and error-aware logging for robust constraint resolution and resource allocation. Together, these components allow building, manipulating, and serializing complex expressions while tracking and managing dependencies with precision and flexibility.",
      "description_length": 802,
      "index": 115,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_data_structures.LargeArray",
      "library": "kappa-library.generic",
      "description": "This module implements an array structure that supports sizes up to the maximum integer limit. It provides standard array operations such as creation, indexing, slicing, mapping, and folding, along with bulk operations like appending, concatenation, and in-place fills. Use cases include handling very large datasets that exceed the capacity of OCaml's built-in array type, efficiently manipulating subarrays, and serializing or printing array contents with custom formatting.",
      "description_length": 476,
      "index": 116,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kappa_data_structures.Option_util",
      "library": "kappa-library.generic",
      "description": "This module provides operations for transforming, combining, and extracting values from `option` types. It includes functions like `map`, `bind`, and `fold` for chaining computations, along with utilities to safely extract values or compare optional values. Use cases include handling optional configuration fields, processing potentially missing data in parsers, and simplifying error propagation in computations.",
      "description_length": 414,
      "index": 117,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_data_structures",
      "library": "kappa-library.generic",
      "description": "This collection provides a comprehensive suite of data structures and utilities for efficient data manipulation, visualization, and transformation. Core components include graph rendering to HTML, precise location tracking for source mapping, customizable data visualization with color and formatting, and robust handling of integers, strings, and polymorphic data through maps, sets, buffers, and extensible arrays. You can build dynamic visualizations with annotated source data, manage large datasets with efficient indexing and memory handling, or model computations with early termination and error-aware results. Specific applications include compiler diagnostics, streaming data processing, symbolic computation, and structured data interchange with JSON and Base64 encoding.",
      "description_length": 782,
      "index": 118,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_utils.Utils",
      "library": "kappa-library.utils",
      "description": "This module provides a function `pp_exception` that formats and prints exception values using OCaml's standard formatting library. It works directly with the `exn` type and `formatter` type from `Stdlib.Format`. A concrete use case is displaying detailed error messages during exception handling in command-line tools or logging systems.",
      "description_length": 337,
      "index": 119,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_utils",
      "library": "kappa-library.utils",
      "description": "This module enhances error reporting by formatting and printing exception values using OCaml's standard formatting library. It operates on the `exn` and `formatter` types, enabling precise control over error message presentation. For example, it can display detailed exceptions in command-line interfaces or log errors with custom formatting. A specific use case includes integrating with logging systems to produce structured error output during exception handling.",
      "description_length": 466,
      "index": 120,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 126,
    "meaningful_modules": 121,
    "filtered_empty_modules": 5,
    "retention_rate": 0.9603174603174603
  },
  "statistics": {
    "max_description_length": 883,
    "min_description_length": 226,
    "avg_description_length": 517.4462809917355,
    "embedding_file_size_mb": 0.44001102447509766
  }
}