{
  "package": "kappa-library",
  "embedding_model": "Qwen/Qwen3-Embedding-8B",
  "embedding_dimension": 4096,
  "total_modules": 109,
  "creation_timestamp": "2025-08-14T20:35:57.235527",
  "modules": [
    {
      "module_path": "Kappa_runtime.Generic_rule_interpreter.Make",
      "library": "kappa-library.runtime",
      "description": "This module enables graph rewriting operations for rule-based modeling, focusing on stochastic application of transformation rules with conflict resolution and activity tracking. It manipulates state configurations, site graph edges, and rule instances to simulate dynamic systems where interactions evolve through ambiguous or competing rule applications. Key applications include modeling biochemical reaction networks and cellular processes that require tracking state changes, event blocking, and statistical observations during simulation.",
      "description_length": 544,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_runtime.Trace.Simulation_info",
      "library": "kappa-library.runtime",
      "description": "This module tracks simulation metadata such as event counts and story identifiers, providing functions to compare, update, and serialize simulation state. It works with a custom type `t` that wraps profiling data and identifiers, supporting JSON conversion for logging or checkpointing. Use cases include tracking execution timelines in biochemical simulations and persisting state for analysis or restart.",
      "description_length": 406,
      "index": 1,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kappa_runtime.Counter.Efficiency",
      "library": "kappa-library.runtime",
      "description": "This module tracks simulation efficiency metrics using a structured counter type. It provides JSON serialization and deserialization for counters that monitor events like blocked steps, clashing instances, and unary/binary operation limits. These counters are used to analyze and optimize the performance of biochemical reaction simulations.",
      "description_length": 341,
      "index": 2,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kappa_runtime.State_interpreter",
      "library": "kappa-library.runtime",
      "description": "This module implements an event loop for simulating rule-based models in systems biology. It provides functions to initialize the simulation state, apply rule modifications, evaluate observables, and run the simulation loop until termination or deadlock. The core data types include a state interpreter, rule interpreter, model definitions, and counters for tracking simulation progress. Use cases include executing Kappa language models to study biochemical interactions and analyzing system behavior through observable values.",
      "description_length": 528,
      "index": 3,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kappa_runtime.Counter",
      "library": "kappa-library.runtime",
      "description": "This module provides a simulation progress tracker that manages steps, events, and efficiency metrics through a counter type `t` encapsulating time, event counts, and rule-specific data. It supports incrementing counters, setting time or event limits, querying progress ratios, and generating trace information. These features are used to monitor simulation execution, analyze performance bottlenecks, and enforce constraints during analysis.",
      "description_length": 442,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_runtime.Instances",
      "library": "kappa-library.runtime",
      "description": "This module manages dynamic collections of pattern instances during the execution of a Kappa model. It supports operations for embedding patterns into a site graph, validating and counting instances, and efficiently picking or enumerating instances for simulation steps. Key data structures include the internal state `t`, message handling, and pattern identifiers, used to track and manipulate instances in the context of rule-based modeling and stochastic simulations.",
      "description_length": 470,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_runtime.Trace",
      "library": "kappa-library.runtime",
      "description": "This module provides tools for capturing, analyzing, and persisting simulation traces in biochemical models, supporting operations like step inspection, metadata extraction, and state-aware processing. It works with structured trace data representing events (rules, perturbations) and steps (applications, observations), alongside JSON serialization for interoperability. Use cases include debugging model behavior, auditing simulation progress, and converting trace data for visualization or external analysis tools.",
      "description_length": 517,
      "index": 6,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kappa_runtime.Rule_interpreter",
      "library": "kappa-library.runtime",
      "description": "This module facilitates rule-based modeling and simulation by enabling dynamic rule application, state updates, and side-effect management in biochemical systems. It operates on agent-site graphs, rule instances, and simulation traces to enforce transformations, track observables, and maintain execution states. Key use cases include validating reaction rules, propagating state changes in molecular interactions, and generating snapshots for analysis.",
      "description_length": 453,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_runtime.Data",
      "library": "kappa-library.runtime",
      "description": "This module offers serialization, deserialization, and formatting capabilities for structured simulation data such as snapshots of system states, discrete interaction networks (DINs), plot configurations, and log entries. It supports output in JSON, TSV, and dot formats to enable visualization of network structures, logging of simulation events, and analysis of time-series data through exported plots and initial configuration dumps. Specific utilities handle plot legends, warning messages, and tabular data exports, catering to both interactive analysis and automated pipeline integration.",
      "description_length": 594,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_runtime.Generic_rule_interpreter",
      "library": "kappa-library.runtime",
      "description": "This module implements a graph rewriting engine for rule-based modeling, supporting stochastic rule application, conflict resolution, and activity tracking. It operates on state configurations, site graphs, and rule instances to simulate dynamic systems with competing interactions. It is used to model biochemical reactions and cellular processes where state changes, event blocking, and statistical tracking during simulation are essential.",
      "description_length": 442,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_runtime.Roots",
      "library": "kappa-library.runtime",
      "description": "This module manages root tracking for connected components in a Kappa model, providing operations to merge, split, and update component roots during simulation. It works with pattern identifiers, edges, and integer collections to maintain dynamic connectivity state efficiently. Concrete use cases include tracking how patterns connect and evolve during rule application, particularly in dynamic compartmentalization or bond modification scenarios.",
      "description_length": 448,
      "index": 10,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kappa_runtime.Instances_sig",
      "library": "kappa-library.runtime",
      "description": "This module defines operations for managing rectangular instances, including creating, manipulating, and querying structured two-dimensional data layouts. It works with data types representing grids or matrices, supporting precise spatial and index-based operations. Concrete use cases include handling game boards, image buffers, and spatial simulations where fixed-size 2D structures are required.",
      "description_length": 399,
      "index": 11,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_runtime.Expr_interpreter",
      "library": "kappa-library.runtime",
      "description": "This module evaluates algebraic and boolean expressions using a counter, time value, and functions to retrieve algebraic expressions, mixture counts, and token values. It operates on algebraic expressions, boolean expressions, and pattern-based data structures from Kappa. Concrete use cases include computing the numerical value of a Kappa algebraic expression or evaluating a boolean condition over a mixture state.",
      "description_length": 417,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_runtime.Replay",
      "library": "kappa-library.runtime",
      "description": "This module processes traces to build and update a dynamic graph state, tracking time, events, and connected components. It supports operations to advance the state step-by-step, check step validity, and extract structural summaries such as distances between components. It is used to analyze and replay biological reaction traces with precise graph transformations and pattern matching.",
      "description_length": 387,
      "index": 13,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_runtime.Resource_strings",
      "library": "kappa-library.runtime",
      "description": "This module defines string constants for JavaScript resources used in the Kappa runtime environment. It includes `common_js` for shared JavaScript utilities and `flux_js` for Flux-specific JavaScript code. These strings are typically used to embed or reference JavaScript functionality within the application.",
      "description_length": 309,
      "index": 14,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_runtime.Fluxmap",
      "library": "kappa-library.runtime",
      "description": "This module tracks and updates dynamic flux data during model execution. It initializes flux maps based on model and counter state, records flux increments from rule applications, and logs hit counts for rule firings. Concrete use cases include monitoring reaction fluxes in biochemical simulations and aggregating rule application statistics for dynamic influence networks.",
      "description_length": 374,
      "index": 15,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_runtime",
      "library": "kappa-library.runtime",
      "description": "This module implements core runtime components for simulating and analyzing rule-based biochemical models. It provides structured tracking of simulation progress, dynamic flux monitoring, expression evaluation, and graph rewriting capabilities, working with state configurations, rule instances, and algebraic expressions. Concrete use cases include executing Kappa models with precise rule application, monitoring reaction fluxes, evaluating observables, and replaying simulation traces for analysis and visualization.",
      "description_length": 519,
      "index": 16,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_site_graphs.Agent.SetMap.Set",
      "library": "kappa-library.mixtures",
      "description": "This module implements a specialized set structure for managing collections of agent identifiers within Kappa site graphs, supporting standard operations like union, intersection, and difference alongside mutation-tracking variants such as `add_with_logs`. It provides ordered and random element selection capabilities through functions like `min_elt`, `max_elt`, and `random`, operating on sets that represent dynamic agent populations in biochemical models. These features enable precise manipulation and analysis of agent sets during rule-based modeling tasks, with logging functionality to trace modifications for debugging or verification purposes.",
      "description_length": 653,
      "index": 17,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_site_graphs.Agent.SetMap.Map",
      "library": "kappa-library.mixtures",
      "description": "This module offers map operations for key-value pairs where keys represent agents in a site graph and values are polymorphic, supporting insertions, deletions, set-theoretic combinations (union, diff), and transformations with logging-aware variants. It provides higher-order functions for folding, filtering, and serialization alongside error-handling mechanisms, enabling use cases like merging agent states with traceable modifications or auditing changes in site graph models.",
      "description_length": 480,
      "index": 18,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kappa_site_graphs.Agent.SetMap",
      "library": "kappa-library.mixtures",
      "description": "This module combines set and map operations for managing collections of agent identifiers in Kappa site graphs. It supports set-theoretic operations like union and difference, keyed value storage, and logging-aware mutations for tracking changes. Use cases include modeling dynamic agent populations with traceable state transitions and merging agent data during biochemical rule-based simulations.",
      "description_length": 398,
      "index": 19,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_site_graphs.User_graph",
      "library": "kappa-library.mixtures",
      "description": "This module represents and manipulates connected components in a Kappa-style site graph. It defines data structures for nodes, sites, ports, and their connections, supporting precise modeling of biochemical interactions with optional states and links. Functions include serialization to JSON, pretty-printing, and parsing from JSON, enabling integration with analysis tools and persistent storage of graph states.",
      "description_length": 413,
      "index": 20,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_site_graphs.Counters_info",
      "library": "kappa-library.mixtures",
      "description": "This module tracks and manipulates counter metadata for site graphs, handling conversions between integer values and deltas using basis offsets. It works with annotated counter signatures, origin tracking, and conversion rules, supporting operations like value translation, bound reordering, and counter printing. Concrete use cases include managing counter bounds during model compilation and serializing counter data for analysis outputs.",
      "description_length": 440,
      "index": 21,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_site_graphs.Navigation",
      "library": "kappa-library.mixtures",
      "description": "This module provides functions to navigate and manipulate abstract paths in a site graph, supporting operations like path validation, renaming, and injection of fresh agents. It works with abstract navigation types that represent paths through agents and edges, including steps and arrows, and interacts with edges and agent structures. Concrete use cases include checking compatibility of fresh points, validating edges in a path, and concretizing abstract paths into specific agent indices.",
      "description_length": 492,
      "index": 22,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_site_graphs.Agent",
      "library": "kappa-library.mixtures",
      "description": "This module represents nodes in a biochemical reaction graph, specifically for modeling agents with unique identifiers and types. It provides operations to create, compare, and manipulate agent identifiers, along with functions to print agent and site information, handle renaming, and serialize agents to and from JSON. It is used to track individual biochemical entities in rule-based modeling and simulation workflows.",
      "description_length": 421,
      "index": 23,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_site_graphs.Snapshot",
      "library": "kappa-library.mixtures",
      "description": "This module manages snapshots of connected components in a site graph, tracking changes over time. It supports operations to create, update, and export snapshots, converting internal representations to user-facing structures. Concrete use cases include analyzing dynamic graph states in biochemical simulations and tracking component occurrences during graph rewriting processes.",
      "description_length": 379,
      "index": 24,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_site_graphs.Signature",
      "library": "kappa-library.mixtures",
      "description": "This module manages agent signatures by handling site definitions, internal state identifiers, and counters, with operations for converting between names and numeric IDs, analyzing structural properties like arity, and validating constraints on site interactions. It works with agent and site definitions stored in a structured format, tracking metadata such as allowed links and counter bounds. The functionality supports use cases like enforcing structural validity in agent-based models, optimizing graph rewriting systems, and managing hierarchical state definitions in complex biological network simulations.",
      "description_length": 613,
      "index": 25,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_site_graphs.Edges",
      "library": "kappa-library.mixtures",
      "description": "This module provides operations for constructing and modifying graphs by adding or removing agents, managing their internal states and binding sites, and establishing or breaking links between them. It works with a graph data structure that represents agents and their biochemical interactions, tracking sites, states, and connectivity to model Kappa-style rule-based systems. These functions support tasks like analyzing connected components, validating interaction pathways, and generating snapshots or filtered views of the graph for debugging and",
      "description_length": 550,
      "index": 26,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kappa_site_graphs",
      "library": "kappa-library.mixtures",
      "description": "This module provides a suite of operations for modeling and manipulating biochemical reaction graphs using agents, edges, and structured pathways. It supports precise representation of agents with typed sites, counter metadata, and connected components, enabling tasks like graph rewriting, pathway validation, and simulation state tracking. Concrete use cases include rule-based modeling of biological networks, analysis of interaction graphs, and serialization of dynamic system states for debugging and output.",
      "description_length": 513,
      "index": 27,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kappa_data_structures.Mods.CharSetMap.Map",
      "library": "kappa-library.generic",
      "description": "This module implements map operations for key-value pairs where keys are characters or character sets, supporting insertion, lookup, deletion, and merging with both standard and logging-aware variants. It provides functions for combining maps through union and difference, transforming values, and handling sparse data efficiently, along with JSON serialization and monadic operations. This structure is suited for applications requiring precise character-based indexing with integrated error auditing, sparse data manipulation, or persistent storage of map states.",
      "description_length": 565,
      "index": 28,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_data_structures.Mods.Int2SetMap.Map",
      "library": "kappa-library.generic",
      "description": "This module provides operations for manipulating maps where keys are integer pairs and values are set-like structures, supporting additions, deletions, and custom merges with logging. It offers advanced transformations like union, difference, and monadic folds, alongside JSON serialization and subset restriction. Use cases include managing hierarchical data with integer-pair identifiers and set-valued attributes, such as tracking sparse multi-dimensional relationships or aggregating structured logs.",
      "description_length": 504,
      "index": 29,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_data_structures.Mods.IntSetMap.Map",
      "library": "kappa-library.generic",
      "description": "This module implements map structures with keys composed of integers or integer sets and polymorphic values, supporting set-theoretic operations (union, difference, merging), transformations (insertion, removal, updates), and traversals (folding, filtering) with built-in error tracking via logging. It includes JSON serialization for persistence and interoperability, along with comparison operators for structural analysis. The design emphasizes handling complex, nested data manipulations where key domains require hierarchical organization or sparse representations, such as in configuration management or state synchronization systems.",
      "description_length": 640,
      "index": 30,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_data_structures.Mods.IntSetMap.Set",
      "library": "kappa-library.generic",
      "description": "This module offers a suite of set operations on integer-based sets, including union, intersection, difference, filtering, and ordered element selection (min, max, random), all implemented with logging-aware wrappers for traceability. It operates on specialized integer-optimized set structures that track state changes and errors, supporting use cases requiring audit trails, such as dynamic set manipulation in diagnostic-heavy systems or priority-based element processing in distributed environments. The design emphasizes both efficiency in set operations and integration with logging frameworks for transparent state management.",
      "description_length": 632,
      "index": 31,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_data_structures.Mods.Int2SetMap.Set",
      "library": "kappa-library.generic",
      "description": "This module implements standard set operations (union, intersection, difference, filtering, and ordered traversal) alongside logging-aware variants that capture error metadata during immutable transformations. It operates on a specialized set structure for integer pairs, offering element retrieval via random sampling, min/max queries, and partitioning, all returning optional values to handle edge cases. These capabilities are particularly useful in scenarios requiring robust manipulation of integer pair collections with error tracking, such as data integrity validation or dynamic resource management systems.",
      "description_length": 615,
      "index": 32,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kappa_data_structures.Mods.String2SetMap.Map",
      "library": "kappa-library.generic",
      "description": "This module provides operations for maps with string-based keys and polymorphic set-like values, enabling both standard map manipulations (insertion, removal, lookup) and set-oriented operations (union, intersection, difference) on the values. It supports advanced transformations through monadic folds, filtering, and JSON serialization, while integrating logging-aware variants for error tracking during state modifications. Typical use cases include managing hierarchical data aggregations, tracking relationships with overlapping categories, or handling sparse collections where keys map to multiple associated values.",
      "description_length": 622,
      "index": 33,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_data_structures.Mods.StringSetMap.Set",
      "library": "kappa-library.generic",
      "description": "The module provides a suite of operations for managing sets of strings with support for standard manipulations (union, intersection, difference), conditional updates that enforce element state checks, and logging capabilities to track modifications. It operates on a specialized string set structure, catering to applications like stateful data validation, transaction logging, and algorithms requiring ordered element access through functions that retrieve minimum, maximum, or random elements.",
      "description_length": 495,
      "index": 34,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_data_structures.SetMap.Make.Set",
      "library": "kappa-library.generic",
      "description": "This module implements a purely functional set abstraction with operations for element manipulation, set algebra, and ordered/random sampling. It works with sets parameterized over arbitrary element types, supporting transformations like union, intersection, filtering, and error-aware logging variants (e.g., `add_with_logs`), while providing safe access to minima, maxima, and random elements via `option`-typed queries. It is designed for scenarios requiring immutable set semantics with explicit error tracking or statistical sampling from ordered datasets.",
      "description_length": 561,
      "index": 35,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_data_structures.Mods.StringSetMap.Map",
      "library": "kappa-library.generic",
      "description": "This module provides standard map operations (add, remove, merge) and logging-aware variants (find_option_with_logs) for maps with string sets as keys and arbitrary values, enabling set-based key manipulations. It includes utilities for JSON serialization, error handling via log-wrapped functions, and transformations like fold and filter, supporting scenarios requiring detailed audit trails, data transformation workflows, or structured data interchange.",
      "description_length": 457,
      "index": 36,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kappa_data_structures.Mods.String2SetMap.Set",
      "library": "kappa-library.generic",
      "description": "This module provides a typed functional interface for manipulating sets of strings with extended operations including standard algebraic set transformations (union, intersection, difference), element-wise logging-aware modifications, and ordered/random element retrieval. It specifically supports use cases requiring auditable set modifications through its logging wrappers, lexicographic extremum queries for ordered analysis, and random sampling capabilities. The structure is optimized for scenarios where string set operations must maintain strict ordering guarantees or track modification side-effects explicitly.",
      "description_length": 618,
      "index": 37,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_data_structures.SetMap.Make.Map",
      "library": "kappa-library.generic",
      "description": "This module provides polymorphic map structures parameterized by key and value types, supporting standard operations like insertion, deletion, and lookup, as well as advanced transformations including merging, differencing, and structural inspection. It includes both exception-safe base functions and logged variants to track modifications, alongside tools for JSON serialization and monadic traversals. These features cater to functional workflows requiring audit trails, data synchronization, or interoperability with external systems through structured formats.",
      "description_length": 565,
      "index": 38,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_data_structures.DynamicArray.DynArray",
      "library": "kappa-library.generic",
      "description": "This module implements a dynamic array with contiguous indexing and efficient resizing. It supports array creation, element access and modification, slicing, concatenation, and iteration with index. Use cases include handling variable-length sequences of elements, implementing buffers, or representing dense numerical data with flexible size.",
      "description_length": 343,
      "index": 39,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_data_structures.Mods.IntSetMap",
      "library": "kappa-library.generic",
      "description": "This module combines integer-optimized sets and maps to support key-based data aggregation, conditional element routing, and hierarchical state tracking. It enables operations like mapping values to integer sets, performing set-driven lookups, and managing dynamic partitions of data with precise control over key intersections and unions. Concrete use cases include policy-based routing in distributed systems, attribute grouping in analytics pipelines, and state versioning in transactional workflows.",
      "description_length": 503,
      "index": 40,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_data_structures.Mods.CharSetMap",
      "library": "kappa-library.generic",
      "description": "This module implements map operations for key-value pairs where keys are characters or character sets. It supports insertion, lookup, deletion, and merging with both standard and logging-aware variants, along with union, difference, value transformation, and JSON serialization. It is suited for applications requiring precise character-based indexing with integrated error auditing, sparse data manipulation, or persistent storage of map states.",
      "description_length": 446,
      "index": 41,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_data_structures.SetMap.Proj",
      "library": "kappa-library.generic",
      "description": "This module implements projection and partitioning operations between two custom set and map structures. It provides functions to map elements from one type to another, accumulate values based on a projection, and partition sets into maps based on a function. These operations are useful for transforming and aggregating data across different representations, such as grouping elements by a computed key or computing derived sets and maps under error-handling contexts.",
      "description_length": 469,
      "index": 42,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_data_structures.Mods.Int2SetMap",
      "library": "kappa-library.generic",
      "description": "Implements map operations for integer-pair keys with set-like values, supporting atomic updates, conditional merges, and error-aware transformations. Works directly with integer pairs and specialized sets of these pairs, enabling precise manipulation of sparse, multi-dimensional data relationships. Useful for tracking dynamic resource allocations or validating consistency in multi-keyed datasets.",
      "description_length": 399,
      "index": 43,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_data_structures.SetMap.Make",
      "library": "kappa-library.generic",
      "description": "This module creates a combined set and map structure parameterized by an ordered type. It provides operations for constructing, querying, and transforming sets and maps with a focus on functional purity and error tracking through optional logging. Use cases include managing immutable collections with ordered elements, such as tracking unique values with associated metadata or performing algebraic set operations with audit trails.",
      "description_length": 433,
      "index": 44,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kappa_data_structures.Mods.String2SetMap",
      "library": "kappa-library.generic",
      "description": "This module implements maps keyed by string pairs, where each key maps to a set of strings, supporting efficient insertion, lookup, and set-theoretic operations on the mapped values. It enables use cases such as tracking multi-valued relationships between string identifiers, aggregating string data under composite keys, and managing disjoint sets with structured labels. The design facilitates operations like merging sets under different keys, querying membership, and iterating over key-set pairs with logging-aware modifications.",
      "description_length": 534,
      "index": 45,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_data_structures.Hashed_list.Make",
      "library": "kappa-library.generic",
      "description": "This module implements a hashed list structure that efficiently caches shared prefixes of lists, reducing memory usage and improving performance for operations like `cons` and equality checks. It works with elements of type `A.t` and maintains a global cache to de-duplicate equivalent lists. Concrete use cases include representing and manipulating large sets of lists where structural sharing is beneficial, such as in symbolic computation or version-controlled state tracking.",
      "description_length": 479,
      "index": 46,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_data_structures.Mods.DynArray",
      "library": "kappa-library.generic",
      "description": "This module implements a dynamic array with indexed access, allowing efficient element retrieval, modification, and array transformations. It supports operations like initialization from functions or lists, slicing, appending, mapping, and folding with index tracking. Use cases include handling variable-length sequences of elements where indexed access and in-place updates are required, such as buffer management or iterative array processing.",
      "description_length": 446,
      "index": 47,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_data_structures.Operator.DepSet",
      "library": "kappa-library.generic",
      "description": "This module provides set manipulation operations for dependency tracking scenarios, supporting standard algebraic operations (union, intersection, difference) with both pure transformations and logging-aware variants that capture state changes. It works with sets of `rev_dep` elements (`DepSet.t`) and includes specialized functions for conditional modifications with freshness/existence checks, as well as element retrieval methods (random, min, max) that safely handle empty sets via optional return types. These capabilities are particularly useful in analysis pipelines where dependency relationships require audit trails or dynamic state validation during set evolution.",
      "description_length": 676,
      "index": 48,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_data_structures.Mods.StringSetMap",
      "library": "kappa-library.generic",
      "description": "This module implements associative maps where keys are sets of strings, supporting operations like union, intersection, and difference on keys to enable set-based routing or filtering logic. It works with string sets as keys and arbitrary values, providing functions for merging, filtering, and transforming maps while maintaining logging and error-handling capabilities. Concrete use cases include access control systems based on permission sets, dynamic routing tables indexed by tag sets, and configuration management with set-based feature flags.",
      "description_length": 550,
      "index": 49,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_data_structures.SetMap.Proj2",
      "library": "kappa-library.generic",
      "description": "This module implements projection operations over a map, transforming elements into a nested map structure by applying two functions to each key. It processes a map with elements of type `elt_a`, grouping values into a map of maps, where the outer map's keys come from the first function and the inner map's keys come from the second function. The `proj2_monadic` variant extends this operation with monadic behavior, allowing for stateful or effectful accumulation while projecting.",
      "description_length": 483,
      "index": 50,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_data_structures.List_util.Infix",
      "library": "kappa-library.generic",
      "description": "This module provides an infix operator `($$)` that prepends a value from an option to a list, if the option is `Some`. It operates on values of type `'a option` and `'a list`, returning a new list with the value added if present. A concrete use case is conditionally extending lists with optional values without explicit pattern matching.",
      "description_length": 338,
      "index": 51,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_data_structures.Bigbuffer",
      "library": "kappa-library.generic",
      "description": "This module provides extensible buffers optimized for efficient accumulation of characters and strings, particularly suited for scenarios requiring frequent appends. It works with custom buffer types and standard character sequences like strings and bigstrings. Concrete use cases include building large text outputs incrementally, such as log messages, network payloads, or file content aggregation, where minimizing reallocation overhead is critical.",
      "description_length": 452,
      "index": 52,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kappa_data_structures.Random_tree",
      "library": "kappa-library.generic",
      "description": "This module implements a tree structure for efficiently managing weighted integer keys with operations to add, retrieve, and sample elements based on their weights. It supports creating and copying trees, adding weighted values, sampling a random element based on weights, and checking if a key has an infinite weight. Concrete use cases include weighted random selection in probabilistic models and dynamic management of weighted event choices.",
      "description_length": 445,
      "index": 53,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kappa_data_structures.Nbr",
      "library": "kappa-library.generic",
      "description": "This module provides arithmetic, comparison, and type conversion operations for a polymorphic number type that can represent 32-bit integers, 64-bit integers, and floating-point values. It supports mixed-type computations, overflow-safe conversions, and integer-specific operations like precise division, along with JSON serialization and numeric validation utilities. These features make it suitable for applications requiring seamless numeric manipulation across different representations, such as financial calculations, dynamic language interpreters, or systems needing robust integer handling.",
      "description_length": 598,
      "index": 54,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_data_structures.SetMap",
      "library": "kappa-library.generic",
      "description": "This module implements a combined set and map structure parameterized by an ordered type, supporting construction, querying, and transformation of immutable collections. It works with ordered elements and associated metadata, enabling use cases like tracking unique values with audit trails or performing algebraic set operations with logging. The module emphasizes functional purity and safe error handling through optional logs.",
      "description_length": 430,
      "index": 55,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_data_structures.Renaming",
      "library": "kappa-library.generic",
      "description": "This module enables the manipulation of finite partial bijections between integers, offering operations to create, compose, invert mappings, verify injectivity, and detect cycles. It operates on structures representing mappings between subsets of natural numbers, supporting both imperative and functional updates, and includes JSON serialization for data interchange or persistence. These features are particularly useful in symbolic computation, state encoding, or systems requiring reversible transformations with integrity guarantees",
      "description_length": 537,
      "index": 56,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_data_structures.Cache",
      "library": "kappa-library.generic",
      "description": "This module implements a bounded cache for storing and managing a sequence of values from a comparable and printable data structure. It supports operations to add elements, retrieve the most recent element, and traverse the cached elements. It is used to track recent rule instantiations and normalized agent states in Kappa model analysis.",
      "description_length": 340,
      "index": 57,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_data_structures.IntCollection",
      "library": "kappa-library.generic",
      "description": "This module implements an imperative set of integers with operations for adding, removing, and checking membership of elements. It supports creating a set with an initial size estimate, querying its size or emptiness, and folding over its elements. Use cases include tracking unique integer identifiers or managing dynamic collections of integers in performance-sensitive contexts.",
      "description_length": 381,
      "index": 58,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_data_structures.Crc32",
      "library": "kappa-library.generic",
      "description": "Computes CRC32 checksums incrementally for substrings. Uses an `int32` type to represent checksum values. Useful for verifying data integrity in network protocols or file formats where partial checksums need to be updated dynamically.",
      "description_length": 234,
      "index": 59,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_data_structures.Tools",
      "library": "kappa-library.generic",
      "description": "This module offers utilities for transforming arrays with index-aware mapping and filtering, performing mathematical operations like gcd and factorial, and manipulating strings through case adjustments or suffix handling. It works with arrays, lists, integers, floats, strings, and optional values, supporting tasks like permutation generation, name uniquification in data processing, and precise numerical calculations. Use cases include data structure traversal with positional context, text normalization, and arithmetic-heavy computations.",
      "description_length": 543,
      "index": 60,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_data_structures.Base64",
      "library": "kappa-library.generic",
      "description": "This module implements Base64 encoding and decoding according to RFC 4648. It operates on strings and bigstrings, using customizable 64-character alphabets for encoding and decoding. It supports standard and URI-safe encodings, making it suitable for handling binary data in contexts like HTTP headers, URLs, or file storage where safe ASCII representation is required.",
      "description_length": 369,
      "index": 61,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_data_structures.List_util",
      "library": "kappa-library.generic",
      "description": "This module extends standard list operations with specialized functions for list manipulation, filtering, and mapping. It handles common transformations like safely extracting elements, merging sorted lists, and conditional list extensions. Use cases include processing ordered data, implementing custom list traversals, and efficiently constructing lists from optional values.",
      "description_length": 377,
      "index": 62,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_data_structures.ExceptionDefn",
      "library": "kappa-library.generic",
      "description": "This module manages a buffer of warnings, each associated with an optional location and a formatting function. It provides direct access to this buffer via the `warning_buffer` reference, allowing warnings to be collected and rendered during program execution. Concrete use cases include accumulating parse-time or analysis-time warnings in a compiler or static analysis tool.",
      "description_length": 376,
      "index": 63,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_data_structures.Mods",
      "library": "kappa-library.generic",
      "description": "This module instantiates functors for specialized data structures, including maps keyed by string sets, string pairs, integer sets, integer pairs, and character sets, along with a dynamic array implementation. It provides operations like set-theoretic merging, conditional routing, indexed access, and error-aware transformations tailored for structured data relationships. Concrete use cases include access control systems, dynamic routing tables, analytics pipelines, resource allocation tracking, and buffer management.",
      "description_length": 522,
      "index": 64,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_data_structures.Color",
      "library": "kappa-library.generic",
      "description": "This module defines a set of basic color variants and converts each color to a corresponding RGB triple. It works with the `color` sum type and integer tuples. Useful for rendering or visualization tasks where colors need to be mapped to numeric values.",
      "description_length": 253,
      "index": 65,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_data_structures.Infinite_buffers",
      "library": "kappa-library.generic",
      "description": "This module implements infinite buffers that dynamically expand as elements are added. It supports creating a buffer with a fixed initial size and a default value, adding elements to the buffer, iterating over its contents, and cleaning (resetting) the buffer to its initial state. These buffers are useful for scenarios requiring unbounded sequential storage, such as accumulating log entries or handling variable-length input streams.",
      "description_length": 436,
      "index": 66,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kappa_data_structures.Fractions",
      "library": "kappa-library.generic",
      "description": "This module implements arithmetic operations for fractions, including addition, subtraction, multiplication, inversion, and division, along with equality checks and constants for zero and one. It works with a fraction type represented by a record of numerator and denominator integers. Use this module to perform precise rational number calculations without floating-point loss of precision.",
      "description_length": 391,
      "index": 67,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_data_structures.Circular_buffers",
      "library": "kappa-library.generic",
      "description": "This module implements a circular buffer with fixed capacity, supporting operations to create a buffer, add elements, iterate over contents, and reset the buffer. It works with any data type `'a` and maintains a bounded history of elements. Concrete use cases include managing a sliding window of recent values or limiting memory usage in streaming data scenarios.",
      "description_length": 364,
      "index": 68,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_data_structures.Hashed_list",
      "library": "kappa-library.generic",
      "description": "This module implements a hashed list structure that caches shared prefixes of lists, optimizing memory usage and accelerating operations like `cons` and equality comparisons. It works with elements of type `A.t` and maintains a global cache to eliminate redundancy across equivalent lists. It is particularly useful for applications involving symbolic computation and version-controlled state tracking, where structural sharing significantly reduces overhead.",
      "description_length": 459,
      "index": 69,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_data_structures.Loc",
      "library": "kappa-library.generic",
      "description": "This module supports operations for managing source code location annotations, including creating, merging, and comparing file position ranges, as well as annotating arbitrary values with source metadata. It operates on structured types like `position` (representing file positions) and `t` (defining line ranges), enabling precise tracking of where data originated in source files. These capabilities are particularly useful for tools requiring source-to-AST mapping, error diagnostics with location context, or persisting location-aware data in JSON format for serialization workflows.",
      "description_length": 587,
      "index": 70,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kappa_data_structures.Fifo",
      "library": "kappa-library.generic",
      "description": "Implements a first-in-first-out queue with operations to add elements to the back and remove elements from the front. Works with generic elements wrapped in a dedicated type. Useful for managing event queues or processing tasks in order of arrival.",
      "description_length": 248,
      "index": 71,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kappa_data_structures.JsonUtil",
      "library": "kappa-library.generic",
      "description": "This module facilitates converting OCaml values to and from JSON representations, supporting basic types, collections, and Unix error codes through functions like `to_string`, `of_list`, and `read_of_string`. It handles structured data such as maps, triples, and optional fields with customizable parsing and serialization, enabling precise control over JSON formatting and error handling. Use cases include encoding system-level errors into JSON messages, transforming complex data structures for storage or transmission, and parsing JSON inputs with structured or nested content.",
      "description_length": 581,
      "index": 72,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kappa_data_structures.Option_util",
      "library": "kappa-library.generic",
      "description": "This module provides operations for transforming, combining, and extracting values from `option` types. It includes functions for mapping, folding, binding, and safely unwrapping optional values, along with equality checking. These functions are useful when handling optional data, such as parsing results or nullable configurations, where explicit `None` handling is required.",
      "description_length": 377,
      "index": 73,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_data_structures.Pp",
      "library": "kappa-library.generic",
      "description": "This module offers functions to format and render structured data into human-readable text, focusing on customizable separators, layout control, and indexed element handling. It operates on lists, arrays, sets, hashtables, and pairs of arbitrary types, requiring user-defined conversion functions for element-specific formatting. Common use cases include generating debug output, serializing nested data structures, and producing error messages with positional annotations.",
      "description_length": 473,
      "index": 74,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_data_structures.DynamicArray",
      "library": "kappa-library.generic",
      "description": "This module implements a dynamic array with contiguous indexing and efficient resizing. It supports array creation, element access and modification, slicing, concatenation, and iteration with index. Use cases include handling variable-length sequences of elements, implementing buffers, or representing dense numerical data with flexible size.",
      "description_length": 343,
      "index": 75,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_data_structures.Operator",
      "library": "kappa-library.generic",
      "description": "This module provides algebraic and boolean operator types for symbolic expression representation, including arithmetic, logical, and comparison operations, alongside JSON serialization capabilities. It works with dependency-tracking constructs like `DepSet.t` sets to manage relationships between expression elements and log modifications. These tools support use cases such as compiling mathematical expressions, analyzing dependency graphs for conditional evaluations, and maintaining audit trails during symbolic computation transformations.",
      "description_length": 544,
      "index": 76,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kappa_data_structures.Result_util",
      "library": "kappa-library.generic",
      "description": "This module provides functions for serializing, deserializing, and manipulating result values that carry status codes and structured error messages. It works with result types that have `ok` and `error` variants, along with associated `status` and `message` data, where messages include severity levels, text, and optional source ranges. Concrete use cases include handling API responses with rich error diagnostics, logging structured messages, and transforming result values while preserving or modifying their status and error information.",
      "description_length": 542,
      "index": 77,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_data_structures.Buffers",
      "library": "kappa-library.generic",
      "description": "This module implements efficient byte buffer management with operations for appending, slicing, and in-place modifications. It works with mutable and immutable byte sequences, supporting dynamic resizing and direct memory access. Concrete use cases include network packet assembly, binary file parsing, and zero-copy data manipulation in high-performance I/O operations.",
      "description_length": 370,
      "index": 78,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kappa_data_structures.NamedDecls",
      "library": "kappa-library.generic",
      "description": "This module manages named declarations by mapping string identifiers to values with optional source location tracking. It supports creating named collections from lists or arrays, looking up elements by name or ID, transforming values, and serializing to or from JSON. Use cases include managing variable bindings in a compiler or interpreter, tracking named entities in a configuration system, and handling symbol tables during program analysis.",
      "description_length": 446,
      "index": 79,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_data_structures.ValMap",
      "library": "kappa-library.generic",
      "description": "This module implements a map with integer keys and integer values, supporting operations like insertion, membership checks, removal, and summation of all values. It provides efficient lookups and updates, along with a function to compute the total of all stored values. A concrete use case is tracking and aggregating integer counts indexed by unique integer identifiers.",
      "description_length": 371,
      "index": 80,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_data_structures.GenArray",
      "library": "kappa-library.generic",
      "description": "This module implements an abstract data type for arrays that can grow beyond the size limits of standard OCaml arrays, using a tree-based structure to manage elements. It supports efficient indexing, updates, and length queries for large collections of elements of any type. Suitable for applications requiring sparse or very large arrays, such as scientific computing or large-scale data processing.",
      "description_length": 400,
      "index": 81,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kappa_data_structures.Stop",
      "library": "kappa-library.generic",
      "description": "This module provides functions to construct and deconstruct a sum type representing either a successful value or an error. It supports operations to create success or error values and to fold over them with custom handlers. Concrete use cases include error handling in parsers or computations where early termination with a reason is required.",
      "description_length": 343,
      "index": 82,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_data_structures.LargeArray",
      "library": "kappa-library.generic",
      "description": "This module implements arrays that can grow beyond the typical OCaml array size limit. It supports standard array operations like creation, indexing, slicing, mapping, and folding, along with bulk operations such as appending, concatenation, and in-place blitting. It is useful for handling very large datasets that require contiguous memory-like structures with efficient access and modification.",
      "description_length": 397,
      "index": 83,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_data_structures.Pp_html",
      "library": "kappa-library.generic",
      "description": "Generates HTML pages displaying graph structures with customizable headers, titles, and content. It works with lists of strings for dependencies and uses formatting functions to build the page layout. This module is useful for rendering visualizations of graph data in web-based interfaces.",
      "description_length": 290,
      "index": 84,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_utils.Utils",
      "library": "kappa-library.utils",
      "description": "This module provides a function `pp_exception` that formats and prints exception values using OCaml's standard formatting library. It works directly with the `exn` type and `formatter` type from `Stdlib.Format`. A concrete use case is logging or displaying detailed error messages during exception handling in command-line tools or debugging utilities.",
      "description_length": 352,
      "index": 85,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_utils",
      "library": "kappa-library.utils",
      "description": "The module includes a function `pp_exception` that formats and prints exception values using OCaml's `Format` module. It operates on the `exn` type and `formatter` type to produce readable error output. This is useful for logging or displaying detailed errors in command-line applications and debugging tools.",
      "description_length": 309,
      "index": 86,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_terms.Pattern.Map",
      "library": "kappa-library.terms",
      "description": "The module implements associative structures for managing key-value pairs where keys are identifiers from a pattern domain, supporting modification, combination, and traversal operations. These maps facilitate tasks like merging collections of graph elements with error propagation, transforming entries under logging constraints, and converting structured data to formats like JSON. They are particularly suited for scenarios requiring state tracking during navigation or analysis of graph-based models with integrated auditing and error resilience.",
      "description_length": 550,
      "index": 87,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_terms.Pattern.Set",
      "library": "kappa-library.terms",
      "description": "This module offers set-theoretic operations (union, intersection, difference, filtering) and element queries (random selection, min/max) for collections of pattern identifiers in a formal modeling language. It integrates logging and error handling during modifications, supporting workflows that require audit trails or freshness checks, such as dynamic analysis of biological models where ordered or stochastic pattern interactions are critical. The design emphasizes safe, traceable manipulation of pattern sets while enabling efficient access to elements for simulation or validation tasks.",
      "description_length": 593,
      "index": 88,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_terms.Matching.Agent",
      "library": "kappa-library.terms",
      "description": "This module represents agents within a connected component of a pattern-mixture, distinguishing between existing agents identified by type and instance ID, and fresh agents introduced during matching. It provides operations to rename agents, concretize their identifiers based on a matching context, inspect their type and ID, and print their structure with optional signature formatting. Use cases include pattern matching in rule-based models and managing agent identities during graph rewriting.",
      "description_length": 498,
      "index": 89,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_terms.Primitives.Transformation",
      "library": "kappa-library.terms",
      "description": "This module implements elementary transformations on rule primitives in a Kappa model, providing operations to map, fold, and compare agent-level transformations. It supports concrete and abstract instantiations of transformations, enabling renaming, concretization, and pretty-printing of rule changes. It is used to manipulate and analyze rule modifications during model compilation and simulation, such as generating negative and positive transformation effects from action lists.",
      "description_length": 483,
      "index": 90,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_terms.Pattern.Env",
      "library": "kappa-library.terms",
      "description": "This module manages a mapping of pattern identifiers to structured graph navigation points, enabling precise traversal and manipulation of Kappa language abstract syntax graphs. It supports operations to retrieve pattern contents, dependencies, and transitions, as well as to construct and serialize observation maps. Concrete use cases include analyzing rule-based biochemical models and tracking agent transformations in Kappa simulations.",
      "description_length": 441,
      "index": 91,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_terms.Pattern.PreEnv",
      "library": "kappa-library.terms",
      "description": "Maintains a pre-environment for pattern matching in a graph domain, tracking node counts and navigation steps. It works with signature and counter information to support pattern instantiation. Used during pattern analysis to manage state when traversing and matching graph structures.",
      "description_length": 284,
      "index": 92,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kappa_terms.Pattern.ObsMap",
      "library": "kappa-library.terms",
      "description": "This module implements a map structure keyed by pattern identifiers, providing operations to set, get, and iterate over values associated with patterns. It supports folding, mapping, and printing functions tailored to pattern-based data analysis. Use cases include tracking pattern occurrences or annotations in a graph navigation context.",
      "description_length": 339,
      "index": 93,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_terms.Instantiation",
      "library": "kappa-library.terms",
      "description": "This module facilitates renaming, concretization, and matching of agent-based events and actions in rule-driven systems, working with agent/site identifiers, internal states, and binding types. It supports substitution via mapping functions and serialization to JSON or string formats for structures like tests, actions, and binding states. These operations are used to bridge abstract syntax trees with concrete representations during rule execution or system state serialization.",
      "description_length": 481,
      "index": 94,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kappa_terms.Primitives",
      "library": "kappa-library.terms",
      "description": "This module provides operations for parsing, transforming, and analyzing rule-based models, focusing on components like algebraic expressions, boolean conditions, and modification lists. It works with data structures representing rules, perturbations, and dynamic model elements, supporting tasks such as serialization, instantiation manipulation, and runtime updates. Specific use cases include handling snapshots, applying rule transformations, and evaluating dynamic model changes through expressions and conditions.",
      "description_length": 519,
      "index": 95,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_terms.Alg_expr",
      "library": "kappa-library.terms",
      "description": "This module enables constructing and manipulating algebraic and boolean expressions with arithmetic operations, constants, and location-annotated smart constructors, supporting tasks like dependency analysis, simplification through constant propagation, and equality checks. It operates on expression types enriched with source location metadata and variable environments, facilitating precise formatting and cross-referencing during transformations. Key applications include model optimization, symbolic analysis, and interoperability via JSON serialization for external tools.",
      "description_length": 578,
      "index": 96,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_terms.Raw_mixture",
      "library": "kappa-library.terms",
      "description": "This module represents and manipulates raw mixtures of agents with typed ports and internal states. It supports operations for copying agents, union-find with counters, and serialization to/from JSON and textual formats. It is used to model biochemical systems with structured agents and their interactions.",
      "description_length": 307,
      "index": 97,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_terms.LKappa",
      "library": "kappa-library.terms",
      "description": "This module enables the manipulation and validation of rule-based models by managing agent and mixture states, internal modifications, and link structures, while enforcing correctness checks. It operates on structured representations of rules, links, counters, and signatures, facilitating tasks like error detection in rule constructs, state erasure for analysis, and conversion between model representations. Key applications include serializing model components to JSON for storage or exchange and formatting data for debugging or visualization.",
      "description_length": 548,
      "index": 98,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_terms.Contact_map",
      "library": "kappa-library.terms",
      "description": "This module represents contact maps as 2D arrays of integer sets, capturing interactions between agents and their sites. It provides functions to print contact maps and cycles in Kappa notation, serialize and deserialize them to JSON. It is used to analyze and visualize connectivity in rule-based models, such as signaling pathways or molecular interactions.",
      "description_length": 359,
      "index": 99,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_terms.Pattern_decompiler",
      "library": "kappa-library.terms",
      "description": "Decompiles contact maps into patterns by analyzing connectivity and site constraints. Processes edges and signatures to generate pattern components with site-specific rules. Useful for translating low-level interaction graphs into high-level biological pattern representations.",
      "description_length": 277,
      "index": 100,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_terms.Pattern_compiler",
      "library": "kappa-library.terms",
      "description": "This module compiles Kappa patterns into internal representations, handling ambiguous rule mixtures and connected components. It processes rule mixtures and raw mixtures to extract patterns, instantiations, and transformations, using contact maps and pre-environments. Concrete use cases include translating Kappa rules into executable structures and analyzing pattern connectivity during rule application.",
      "description_length": 406,
      "index": 101,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_terms.Model",
      "library": "kappa-library.terms",
      "description": "This module enables the construction and manipulation of compiled Kappa models, handling data such as signatures, rules, perturbations, algebraic expressions, and contact maps. It provides operations for querying components by name or index, transforming models through variable updates or constant propagation, and serializing structures into JSON or formatted text. These capabilities support tasks like model initialization, dynamic environment adjustments, and integration with analysis tools or external interfaces requiring structured data exports.",
      "description_length": 554,
      "index": 102,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kappa_terms.Configuration",
      "library": "kappa-library.terms",
      "description": "This module defines a configuration type for simulation parameters, including progress settings, output options, and runtime controls. It supports parsing configuration values from annotated key-value pairs and printing them in a formatted way. Use cases include setting up simulation environments with specific logging intervals, deadlock handling, and trace output destinations.",
      "description_length": 380,
      "index": 103,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_terms.Kappa_printer",
      "library": "kappa-library.terms",
      "description": "This module provides functions to print human-readable representations of Kappa language constructs, including algebraic expressions, boolean expressions, rules, modifications, and environments. It operates on data types such as `alg_expr`, `bool_expr`, `elementary_rule`, `modification`, and `Model.t`, using a formatter to output structured, readable output. These functions are used to display compiled Kappa models and rules for debugging, logging, or user interaction.",
      "description_length": 473,
      "index": 104,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kappa_terms.Pattern",
      "library": "kappa-library.terms",
      "description": "This domain enables constructing and transforming graph patterns via operations such as node and link creation, environment management, and pattern merging. It operates on graph structures consisting of agents, sites, and links, utilizing identifiers and mappings to track pattern states and equivalences. These capabilities are employed in rule-based modeling to analyze biological systems, optimize pattern sharing strategies, and compute state-informed values during formal verification.",
      "description_length": 490,
      "index": 105,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kappa_terms.Matching",
      "library": "kappa-library.terms",
      "description": "This module manages matchings between patterns and site graphs, tracking agent identities and renamings during pattern instantiation. It supports operations to reconstruct matchings from connected components, retrieve agent mappings, validate roots, and collect observable patterns based on agent types and states. Concrete use cases include matching rule patterns to molecular complexes and tracking agent identities during model simulation or analysis.",
      "description_length": 454,
      "index": 106,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_terms.Alg_expr_extra",
      "library": "kappa-library.terms",
      "description": "This module provides operations for manipulating algebraic expressions used in rule-based modeling, particularly for handling rate constants during symmetry detection. It includes functions for simplifying expressions, dividing by integers, computing derivatives, and extracting dependencies on mixture or identifier variables. Use cases include normalizing reaction rates, comparing symbolic expressions for equivalence, and analyzing expression structure in the context of rule-based models.",
      "description_length": 493,
      "index": 107,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kappa_terms",
      "library": "kappa-library.terms",
      "description": "This module provides functionalities for building, transforming, and analyzing rule-based models in systems biology. It works with algebraic expressions, contact maps, patterns, and agent-based structures to support concrete tasks such as model compilation, rule instantiation, dependency analysis, and serialization to JSON. Key use cases include simulating biochemical reactions, analyzing molecular interactions, and integrating with external analysis tools through structured data exchange.",
      "description_length": 494,
      "index": 108,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 111,
    "meaningful_modules": 109,
    "filtered_empty_modules": 2,
    "retention_rate": 0.9819819819819819
  },
  "statistics": {
    "max_description_length": 676,
    "min_description_length": 234,
    "avg_description_length": 456.8440366972477,
    "embedding_file_size_mb": 1.5801105499267578
  }
}