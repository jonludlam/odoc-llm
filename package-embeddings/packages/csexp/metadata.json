{
  "package": "csexp",
  "embedding_model": "Qwen/Qwen3-Embedding-8B",
  "embedding_dimension": 4096,
  "total_modules": 10,
  "creation_timestamp": "2025-08-15T12:10:38.623710",
  "modules": [
    {
      "module_path": "Csexp.Make.Parser.Stack",
      "library": "csexp",
      "description": "This module implements a stack-based parser for canonical S-expressions, tracking the current state of parsing through nested parentheses and atomic values. It supports operations to add atoms, open and close parentheses, and extract fully parsed S-expressions as a list. It is used to build a correct-by-construction representation of nested S-expressions during parsing.",
      "description_length": 372,
      "index": 0,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Csexp.Make.Parser.Lexer",
      "library": "csexp",
      "description": "This module implements a lexical analyzer for parsing canonical S-expressions, breaking input into tokens such as parentheses, atoms, and end-of-input markers. It processes character streams incrementally, identifying structural elements and integer atoms during tokenization. It is used to build efficient, custom S-expression parsers that consume input one character at a time.",
      "description_length": 379,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Csexp.Make.Make_parser",
      "library": "csexp",
      "description": "This module implements a minimal parser for canonical S-expressions, providing `parse` and `parse_many` functions to read S-expressions from an input source. It works with the `Sexp.t` type and is parameterized over the input type via the `Input` module. It is intended for straightforward parsing tasks where full-featured S-expression libraries are unnecessary.",
      "description_length": 363,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Csexp.Make.Parser",
      "library": "csexp",
      "description": "This module implements a lexer and stack-based parser for canonical S-expressions, processing character streams into structured values like atoms, lists, and nested expressions. It works with input sources that provide characters incrementally, using a token-driven approach to build S-expressions via a parsing stack. Concrete use cases include parsing network protocols, binary formats, or storage systems that encode structured data using canonical S-expressions.",
      "description_length": 466,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Csexp.Parser.Lexer",
      "library": "csexp",
      "description": "This module implements a lexical analyzer for parsing canonical S-expressions, processing input character by character to identify structural elements like parentheses and atomic values. It maintains internal state to track partial tokens and supports incremental parsing through a stepwise feed interface. The lexer is designed for direct integration into custom parsers, enabling efficient recognition of S-expression syntax in low-level input streams.",
      "description_length": 454,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Csexp.Parser.Stack",
      "library": "csexp",
      "description": "This module implements a stack-based parser for canonical S-expressions, supporting operations to add atoms, parentheses, and tokens, and to extract fully parsed S-expressions. It works with a custom stack type that represents the current parsing state as a sequence of nested S-expressions. Use this module when incrementally parsing canonical S-expressions from a stream of tokens, such as when reading from a file or network input.",
      "description_length": 434,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Csexp.Parser",
      "library": "csexp",
      "description": "This module implements a low-level, incremental parser for canonical S-expressions, designed to work with a user-provided lexer and stack-based structure builder. It processes input character by character, identifying structural elements like atoms, parentheses, and nested expressions, and constructs a structured representation of the S-expression being parsed. Concrete use cases include parsing binary-encoded S-expressions from a file descriptor or network stream, where control over memory allocation and error handling is critical.",
      "description_length": 538,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Csexp.Make",
      "library": "csexp",
      "description": "This module implements parsing and serialization for canonical S-expressions, supporting operations like `parse_string`, `input`, and `to_string`. It works with the `Sexp.t` type to handle structured values such as atoms and lists, primarily used for reading and writing data in a simple, standardized format. Concrete use cases include parsing configuration files, exchanging structured data over network protocols, and storing nested expressions in a canonical textual form.",
      "description_length": 476,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Csexp.Make_parser",
      "library": "csexp",
      "description": "This module implements parsers for canonical S-expressions, providing `parse` to read a single S-expression and `parse_many` to read multiple S-expressions from an input source. It works with the `Csexp.t` type for representing S-expressions and is parameterized over an input type. It is useful for parsing configuration files or data streams that use the canonical S-expression format.",
      "description_length": 387,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Csexp",
      "library": "csexp",
      "description": "This module parses and serializes canonical S-expressions, supporting direct operations like `parse_string`, `input`, and `to_string`. It handles structured values using the `t` type, which represents atoms and lists, enabling precise reading and writing of nested expressions. Concrete use cases include parsing binary-encoded data from network streams, reading configuration files, and exchanging structured data between systems using a minimal, standardized textual format.",
      "description_length": 476,
      "index": 9,
      "embedding_norm": 0.9999999403953552
    }
  ],
  "filtering": {
    "total_modules_in_package": 10,
    "meaningful_modules": 10,
    "filtered_empty_modules": 0,
    "retention_rate": 1.0
  },
  "statistics": {
    "max_description_length": 538,
    "min_description_length": 363,
    "avg_description_length": 434.5,
    "embedding_file_size_mb": 0.14532470703125
  }
}