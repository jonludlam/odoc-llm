{
  "package": "comby",
  "embedding_model": "Qwen/Qwen3-Embedding-8B",
  "embedding_dimension": 4096,
  "total_modules": 384,
  "creation_timestamp": "2025-08-18T19:42:09.742567",
  "modules": [
    {
      "module_path": "Pipeline",
      "library": "comby.pipeline",
      "description": "Handles processing and execution of matching and replacement operations over source code using customizable configurations and metasyntax. Works with source code inputs, match patterns, and replacement templates to produce structured outputs like lists of matches or transformed code. Used to perform precise code transformations or analysis tasks with optional timeouts and substitution strategies.",
      "description_length": 399,
      "index": 0,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Camlzip.Gzip",
      "library": "comby.camlzip",
      "description": "This module implements reading from and writing to gzip-compressed files using abstract input and output channel types. It supports operations such as character and byte-level reading and writing, bulk input/output with bytes and strings, and full or partial channel closure. Concrete use cases include processing compressed log files, streaming compressed data over network sockets, and extracting or creating gzip archives programmatically.",
      "description_length": 442,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Camlzip.Zip",
      "library": "comby.camlzip",
      "description": "This module supports creating, reading, and extracting ZIP archives with precise control over individual entries, including compression methods, timestamps, and metadata. It operates on file paths, raw data strings, and channels for efficient streaming operations. Concrete use cases include packaging application resources into ZIP files, extracting specific files from archives, and inspecting ZIP metadata without full decompression.",
      "description_length": 436,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Camlzip.Zlib",
      "library": "comby.camlzip",
      "description": "This module implements compression and decompression using the DEFLATE algorithm, with support for CRC checksums. It operates on byte sequences and strings, providing low-level control over compression streams, flush behavior, and header inclusion. Concrete use cases include implementing custom compression pipelines, verifying data integrity with CRC, and handling compressed network or file I/O formats like gzip or zlib.",
      "description_length": 424,
      "index": 3,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Camlzip",
      "library": "comby.camlzip",
      "description": "This module provides compression and decompression functionality through its submodules. Gzip handles gzip-compressed files with channel-based I/O operations, supporting both streaming and file-based use cases. Zip enables creation, reading, and extraction of ZIP archives with metadata control, operating on files, channels, and raw data. Zlib offers low-level DEFLATE compression with CRC support, suitable for custom data encoding and integrity verification workflows.",
      "description_length": 471,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Configuration.Command_configuration.Printer",
      "library": "comby.configuration",
      "description": "This module defines a function type for printing structured results from matching or replacement operations. It handles two forms of output: lists of matches or replacements along with source context, and final transformation results. It is used to format and display the outcome of pattern-based code transformations.",
      "description_length": 318,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Configuration.Diff_configuration",
      "library": "comby.configuration",
      "description": "This module defines configurations for diffing text, including plain, colored, HTML, default, and match-only modes. It provides functions to generate preconfigured diff settings, customize context lines, and apply diffs to string inputs. Use cases include generating colored terminal diffs, producing HTML-formatted diffs, or extracting matching lines between strings.",
      "description_length": 368,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Configuration.Command_input",
      "library": "comby.configuration",
      "description": "Handles input sources for command configurations, supporting individual paths, string content, batch paths, and ZIP archives. Provides a function to convert input types to string representations for display or logging. Useful for tools that process configuration data from mixed sources like files, inline strings, or compressed archives.",
      "description_length": 338,
      "index": 7,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Configuration.Ripgrep",
      "library": "comby.configuration",
      "description": "This module executes `ripgrep` commands with a given pattern and arguments, returning matching lines or an error. It operates on strings for patterns and lists of strings for command-line arguments. Use it to search files or input data for text patterns, such as finding log entries or code occurrences.",
      "description_length": 303,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Configuration.External_semantic",
      "library": "comby.configuration",
      "description": "Implements semantic queries for code navigation and hover information. It provides a `lsif_hover` function that retrieves documentation or type information for a symbol at a specific position in a file. Uses basic types like strings, integers, and optional return values. Useful for IDE integrations that require on-demand symbol analysis.",
      "description_length": 339,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Configuration.Command_configuration",
      "library": "comby.configuration",
      "description": "This module orchestrates pattern-based code transformations by processing user input into executable configurations. It parses command-line arguments, resolves file targets, and initializes matchers and output handlers for structured result rendering. Key operations include configuring match and rewrite templates, controlling execution modes (e.g., parallelism), and managing output formats (e.g., JSON, diff, in-place edits) with support for interactive review workflows.",
      "description_length": 474,
      "index": 10,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Configuration",
      "library": "comby.configuration",
      "description": "This module manages configuration and execution of code transformation workflows, including parsing command-line inputs, defining diffing strategies, executing text searches with `ripgrep`, and supporting semantic queries for IDE integrations. It works with file paths, string content, command arguments, and structured output formats like JSON and HTML diffs. Concrete use cases include batch code refactoring, generating colored or structured diffs, searching log files, and providing hover documentation in editors.",
      "description_length": 518,
      "index": 11,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Dhall.Syntax",
      "library": "comby",
      "description": "This module defines syntax elements for parsing and matching Dhall code, including user-defined delimiters, escapable and raw string literals, and comment styles. It provides precise string patterns and lexical rules that support accurate code transformation and analysis. Use cases include implementing custom parsers, linters, or refactoring tools for Dhall configurations.",
      "description_length": 375,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Elixir.Info",
      "library": "comby",
      "description": "This module defines metadata for the Elixir programming language, including its name and file extensions. It provides direct access to the language name as a string and a list of associated file extensions. This information is used to identify and handle Elixir source files in tooling that processes or analyzes code based on file type.",
      "description_length": 337,
      "index": 13,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Languages.Html.Syntax",
      "library": "comby",
      "description": "This module defines syntax-specific configurations for parsing and matching HTML, including delimiters for embedded expressions, escapable and raw string literals, and comment structures. It supports precise pattern matching and transformation of HTML content by specifying how different syntactic elements are represented. Concrete use cases include templating systems, static analysis tools, and code refactoring utilities that require accurate parsing of HTML syntax.",
      "description_length": 470,
      "index": 14,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Languages.Bash.Info",
      "library": "comby",
      "description": "This module defines metadata for the Bash programming language, including its name and file extensions. It provides direct access to the language name as a string and a list of associated file extensions. This information is used to identify and handle Bash source files in tooling contexts like syntax parsing or file type detection.",
      "description_length": 334,
      "index": 15,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Csharp.Syntax",
      "library": "comby",
      "description": "This module defines syntax elements specific to C# for pattern matching, including delimiters, string literals, and comments. It supports parsing and transforming C# code by handling escapable and raw string literals, as well as different comment styles. Concrete use cases include writing custom matchers for C# code analysis, refactoring tools, and syntax-aware search-and-replace operations.",
      "description_length": 394,
      "index": 16,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Languages.Swift.Syntax",
      "library": "comby",
      "description": "This module defines syntax elements specific to Swift, including delimiters for user-defined tokens, escapable and raw string literals, and comment styles. It provides concrete configurations for parsing and matching Swift code patterns. Use this module to handle Swift-specific syntactic constructs in code analysis or transformation tasks.",
      "description_length": 341,
      "index": 17,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Javascript.Syntax",
      "library": "comby",
      "description": "This module defines syntax elements for JavaScript, including user-defined delimiters, escapable and raw string literals, and comment kinds. It provides precise syntactic patterns used for parsing and matching JavaScript code structures. Use this module to handle JavaScript-specific syntax when analyzing or transforming code, such as identifying string boundaries or comment blocks.",
      "description_length": 384,
      "index": 18,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Languages.Coq.Syntax",
      "library": "comby",
      "description": "This module defines syntax elements for parsing and matching Coq code, including user-defined delimiters, escapable and raw string literals, and comment styles. It provides concrete configurations for handling Coq-specific syntax constructs such as notations, string encodings, and comment delimiters. Use cases include building parsers or transformers that accurately recognize Coq's syntax in source code analysis or refactoring tools.",
      "description_length": 437,
      "index": 19,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Languages.GraphQL.Syntax",
      "library": "comby",
      "description": "This module defines syntax elements for parsing and matching GraphQL code, including customizable delimiters, escapable and raw string literals, and comment styles. It supports precise pattern matching and transformation of GraphQL queries by specifying how different syntactic constructs are recognized. Concrete use cases include building custom linters, query validators, or automated refactoring tools for GraphQL schemas and operations.",
      "description_length": 441,
      "index": 20,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.R.Syntax",
      "library": "comby",
      "description": "This module defines syntax elements for parsing and matching R code, including user-defined delimiters, escapable and raw string literals, and comment styles. It provides precise specifications for identifying syntactic constructs in R source files. Use this module to configure parsers or matchers that need to handle R-specific syntax features like string escaping, comments, and custom delimiters in code transformations or analysis tools.",
      "description_length": 442,
      "index": 21,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Elm.Syntax",
      "library": "comby",
      "description": "This module defines syntax elements for parsing and matching Elm code, including user-defined delimiters, escapable and raw string literals, and comment styles. It provides concrete values that specify how these syntactic constructs are represented in Elm source files. Use this module to configure parsers or matchers that need to accurately recognize Elm's syntax features like string escaping, custom delimiters, and comment blocks.",
      "description_length": 435,
      "index": 22,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Kotlin.Syntax",
      "library": "comby",
      "description": "This module defines syntax elements specific to Kotlin, including user-defined delimiters for string literals, escapable and raw string configurations, and comment kinds. It provides precise syntactic patterns for parsing and matching Kotlin code structures. Use this module to handle Kotlin-specific string and comment syntax in code analysis or transformation tools.",
      "description_length": 368,
      "index": 23,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Assembly.Info",
      "library": "comby",
      "description": "This module defines metadata for an assembly language, including its name and associated file extensions. It works with string and list data types to store and retrieve language-specific identifiers. Concrete use cases include determining file type based on extension and providing human-readable names for assembly language variants.",
      "description_length": 334,
      "index": 24,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Ruby.Syntax",
      "library": "comby",
      "description": "This module defines syntax elements specific to Ruby, including delimiters for string literals, escapable and raw string markers, and comment styles. It provides precise pattern-matching capabilities for parsing and transforming Ruby code. Use cases include code refactoring tools and static analysis systems that require accurate handling of Ruby's syntactic constructs.",
      "description_length": 371,
      "index": 25,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Php.Syntax",
      "library": "comby",
      "description": "This module defines syntax-specific configurations for parsing PHP code, including delimiters for user-defined strings, escapable and raw string literals, and comment styles. It provides concrete values for handling PHP's syntactic elements like heredoc, nowdoc, and standard string enclosures. Use this module when implementing or extending PHP code analysis tools that require precise parsing of string literals and comments.",
      "description_length": 427,
      "index": 26,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Clojure.Syntax",
      "library": "comby",
      "description": "This module defines syntax elements for parsing and matching Clojure code, including customizable delimiters for string literals, escapable and raw string formats, and comment styles. It supports precise pattern matching by specifying how different syntactic constructs are represented in Clojure source. Use this module when implementing tools that analyze or transform Clojure code, such as linters, formatters, or refactoring utilities.",
      "description_length": 439,
      "index": 27,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Languages.Latex.Info",
      "library": "comby",
      "description": "This module defines metadata for the LaTeX language, including its name and file extensions. It provides direct access to the language name as a string and a list of associated file extensions. This information is used to identify and handle LaTeX files in parsing and processing workflows.",
      "description_length": 290,
      "index": 28,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Languages.Scala.Info",
      "library": "comby",
      "description": "This module defines metadata for the Scala programming language, including its name and file extensions. It provides direct access to the language name as a string and a list of associated file extensions. This information is used for language identification and file handling in code processing tools.",
      "description_length": 302,
      "index": 29,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.SQL.Info",
      "library": "comby",
      "description": "This module defines metadata for SQL language support, including the language name and file extensions. It provides concrete values for identifying SQL files and handling their specific characteristics. Useful for tools that process or analyze SQL files based on their extension or name.",
      "description_length": 287,
      "index": 30,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Generic.Syntax",
      "library": "comby",
      "description": "This module defines syntax configurations for parsing and matching code patterns, including delimiters, string literals, and comments. It supports customizable syntax elements like escapable and raw string delimiters, as well as comment styles. Used to configure language-specific matchers for code transformation and analysis tasks.",
      "description_length": 333,
      "index": 31,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Paren.Info",
      "library": "comby",
      "description": "This module defines metadata for a programming language, specifically its name and file extensions. It works with string and list data types to store and retrieve this information. A concrete use case is configuring language-specific settings in a code editor or tool based on file extension or display name.",
      "description_length": 308,
      "index": 32,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.C.Info",
      "library": "comby",
      "description": "This module defines metadata for the C programming language, including its name and common file extensions. It provides direct access to the language identifier and a list of associated file extensions. Use this module to retrieve C language-specific information for file processing or language detection tasks.",
      "description_length": 311,
      "index": 33,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Generic.Info",
      "library": "comby",
      "description": "This module defines metadata for a generic programming language, including its name and file extensions. It provides direct access to static information used for language identification and file association. Concrete use cases include determining supported languages by name and mapping file extensions to language configurations.",
      "description_length": 330,
      "index": 34,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Julia.Syntax",
      "library": "comby",
      "description": "This module defines syntax elements specific to the Julia programming language, including user-defined delimiters, escapable and raw string literals, and comment kinds. It provides precise syntactic patterns for parsing and matching Julia code structures. Use this module to handle Julia-specific syntax when analyzing or transforming code, such as identifying string literals or stripping comments.",
      "description_length": 399,
      "index": 35,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Matlab.Syntax",
      "library": "comby",
      "description": "This module defines syntax elements for parsing MATLAB code, including user-defined delimiters, escapable and raw string literals, and comment styles. It provides precise configurations for handling MATLAB-specific syntax features like string escaping and comment blocks. Use this module to customize parsers or analyzers that need to accurately recognize MATLAB's syntax structures.",
      "description_length": 383,
      "index": 36,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Xml.Syntax",
      "library": "comby",
      "description": "This module defines syntax elements for XML parsing, including user-defined delimiters, escapable and raw string literals, and comment structures. It provides precise configurations for handling XML-specific syntax features like tags, attributes, and text content. Use cases include parsing XML documents, processing embedded XML fragments, and supporting syntax-aware transformations.",
      "description_length": 385,
      "index": 37,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.CSS.Info",
      "library": "comby",
      "description": "This module defines metadata for CSS language support, including the language name and file extensions. It provides the `name` and `extensions` values to identify and associate files with CSS syntax. Use this module when integrating CSS files into a system that requires language-specific handling, such as syntax highlighting or parsing.",
      "description_length": 338,
      "index": 38,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Clojure.Info",
      "library": "comby",
      "description": "This module defines metadata for the Clojure language, including its name and file extensions. It provides direct access to a list of common file extensions associated with Clojure source files. Use this module when handling file-based operations specific to Clojure, such as identifying or filtering Clojure source files by extension.",
      "description_length": 335,
      "index": 39,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Languages.Reason.Syntax",
      "library": "comby",
      "description": "This module defines syntax elements for parsing and matching ReasonML code, including delimiters, string literals, and comments. It specifies escapable and raw string formats, along with comment styles, to support accurate pattern matching. Use this module when implementing syntax-aware tools like linters, formatters, or code analyzers for ReasonML.",
      "description_length": 351,
      "index": 40,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Solidity.Info",
      "library": "comby",
      "description": "This module defines metadata for the Solidity programming language, including its name and file extensions. It provides direct access to the language name as a string and a list of associated file extensions. Useful for tooling that needs to identify or process Solidity files based on their extension or display the language name.",
      "description_length": 331,
      "index": 41,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Javascript.Info",
      "library": "comby",
      "description": "This module defines metadata for JavaScript, including the language name and file extensions. It provides direct access to a list of common file extensions associated with JavaScript. Use this module to identify JavaScript files by extension or reference the language name in tooling or configuration contexts.",
      "description_length": 310,
      "index": 42,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Zig.Syntax",
      "library": "comby",
      "description": "This module defines syntax elements for parsing and matching Zig code, including user-defined delimiters, escapable and raw string literals, and comment styles. It provides concrete configurations for handling Zig-specific syntax features like string encoding and comment delimiters. Use this module to accurately parse or transform Zig source code by matching its syntactic structures.",
      "description_length": 386,
      "index": 43,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Csharp.Info",
      "library": "comby",
      "description": "This module defines metadata for the C# language, including the language name and file extensions. It provides direct access to static information used for identifying and handling C# source files. Concrete use cases include configuring parsers or tools that require language-specific file extension recognition.",
      "description_length": 312,
      "index": 44,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.GraphQL.Info",
      "library": "comby",
      "description": "This module defines metadata for the GraphQL language, including its name and file extensions. It provides direct access to the language identifier and a list of associated file extensions. Useful for tools that need to recognize or process GraphQL files based on their extension or display the language name.",
      "description_length": 309,
      "index": 45,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Rust.Syntax",
      "library": "comby",
      "description": "This module defines syntax-specific configurations for parsing and matching Rust code. It specifies delimiters, escapable and raw string literals, and comment styles unique to Rust. These values guide accurate pattern matching and transformation of Rust source files in tools like code formatters or linters.",
      "description_length": 308,
      "index": 46,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Tsx.Syntax",
      "library": "comby",
      "description": "This module defines syntax-specific configurations for parsing and matching in a language that supports JSX-like syntax, such as TypeScript with React. It specifies delimiters for embedded expressions, escapable and raw string literals, and comment styles. These values are used directly by pattern matchers to correctly identify and handle language constructs during code transformation or analysis tasks.",
      "description_length": 406,
      "index": 47,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Elm.Info",
      "library": "comby",
      "description": "This module defines metadata for the Elm programming language, including its name and file extensions. It provides direct access to the language name as a string and a list of associated file extensions. This information is used for language identification and file handling in tooling that processes Elm code, such as parsers or linters.",
      "description_length": 338,
      "index": 48,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Languages.Dyck.Syntax",
      "library": "comby",
      "description": "This module defines syntax configurations for handling delimiters, string literals, and comments in a structured format. It provides specific values for user-defined delimiters, escapable and raw string literals, and comment kinds, tailored for parsing and matching in language-specific contexts. These configurations are used directly in setting up language grammars for accurate code pattern recognition.",
      "description_length": 406,
      "index": 49,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Fsharp.Syntax",
      "library": "comby",
      "description": "This module defines syntax elements for F# such as user-defined delimiters, escapable and raw string literals, and comment kinds. It provides concrete configurations for parsing and matching F# code patterns. Use this module to handle F#-specific syntactic structures in code analysis or transformation tasks.",
      "description_length": 309,
      "index": 50,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Languages.Paren.Syntax",
      "library": "comby",
      "description": "This module defines syntax configurations for parenthetical languages, specifying delimiters, string literals, and comment styles. It supports customizable parsing through user-defined delimiters, escapable and raw string markers, and comment syntax. Concrete use cases include configuring parsers for languages like Lisp or Scheme where parentheses and specific string formats are significant.",
      "description_length": 394,
      "index": 51,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.OCaml.Syntax",
      "library": "comby",
      "description": "This module defines syntax elements specific to OCaml, including user-defined delimiters, escapable and raw string literals, and comment styles. It provides precise syntactic patterns used for parsing and matching OCaml code structures. Use cases include implementing custom syntax extensions, analyzing OCaml source files, and supporting tools like linters or refactoring utilities.",
      "description_length": 383,
      "index": 52,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Languages.JSON.Info",
      "library": "comby",
      "description": "This module defines metadata for JSON files, including the language name and associated file extensions. It provides direct access to the name as a string and the extensions as a list of strings. Concrete use cases include identifying JSON files by extension and referencing the language name in tooling or configuration contexts.",
      "description_length": 330,
      "index": 53,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Languages.Dyck.Info",
      "library": "comby",
      "description": "This module defines metadata for a language variant that enforces balanced parentheses structures, commonly used in formal language processing. It specifies the language name and associated file extensions. This information supports parsing and validation tools that require strict syntactic structure recognition.",
      "description_length": 314,
      "index": 54,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Pascal.Info",
      "library": "comby",
      "description": "This module defines metadata for Pascal language support, including the language name and file extensions. It provides concrete values for identifying Pascal source files, such as `name` set to \"Pascal\" and `extensions` listing common file suffixes like `.pas`. This information is used by tools that process or categorize Pascal code, such as linters, parsers, or project generators.",
      "description_length": 384,
      "index": 55,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Haskell.Syntax",
      "library": "comby",
      "description": "This module defines syntax elements specific to Haskell, including user-defined delimiters, escapable and raw string literals, and comment kinds. It provides precise syntactic patterns for parsing and matching Haskell code structures. Use this module when implementing custom parsing or transformation tools for Haskell source files, such as linters, formatters, or refactoring utilities.",
      "description_length": 388,
      "index": 56,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Languages.Python.Info",
      "library": "comby",
      "description": "This module defines metadata for the Python language, including its name and file extensions. It provides direct access to the language name as a string and a list of associated file extensions. This information is used to identify and handle Python files in tooling that requires language-specific configuration, such as syntax processing or file detection.",
      "description_length": 358,
      "index": 57,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Kotlin.Info",
      "library": "comby",
      "description": "This module defines metadata for the Kotlin programming language, including its name and file extensions. It provides direct access to the language name as a string and a list of associated file extensions. This information is used for language identification and file handling in code processing tools.",
      "description_length": 303,
      "index": 58,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Pascal.Syntax",
      "library": "comby",
      "description": "This module defines syntax elements for Pascal, including user-defined delimiters, escapable and raw string literals, and comment styles. It provides precise syntax configurations for parsing and matching Pascal code. Use this module to handle Pascal-specific syntactic constructs in code analysis or transformation tasks.",
      "description_length": 322,
      "index": 59,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.C_nested_comments.Syntax",
      "library": "comby",
      "description": "This module defines syntax configurations for handling nested comments, string literals, and delimiters in a language similar to C. It specifies pairs of delimiters for nested structures, escapable and raw string literal markers, and comment styles. Concrete use cases include parsing source code with custom syntax extensions or implementing linters and formatters that require precise handling of nested constructs.",
      "description_length": 417,
      "index": 60,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Dart.Syntax",
      "library": "comby",
      "description": "This module defines syntax elements specific to Dart, including user-defined delimiters, escapable and raw string literals, and comment kinds. It provides precise syntactic patterns for parsing and matching Dart code structures. Use this module to handle Dart-specific syntax when analyzing or transforming Dart source files.",
      "description_length": 325,
      "index": 61,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Python.Syntax",
      "library": "comby",
      "description": "This module defines syntax-specific configurations for parsing and matching Python code. It specifies delimiters for user-defined strings, escapable and raw string literals, and comment styles. These values are used to accurately match and transform Python syntax in code analysis tools.",
      "description_length": 287,
      "index": 62,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Languages.Scala.Syntax",
      "library": "comby",
      "description": "This module defines syntax elements specific to Scala, including user-defined delimiters for string literals, escapable and raw string configurations, and comment styles. It provides precise syntax boundary definitions required for parsing and matching Scala code. Use cases include configuring parsers for Scala string interpolation, handling multi-line comments, and supporting custom delimiters in code transformation tools.",
      "description_length": 427,
      "index": 63,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Languages.Solidity.Syntax",
      "library": "comby",
      "description": "This module defines syntax elements specific to Solidity, including user-defined delimiters, escapable and raw string literals, and comment styles. It provides precise configurations for parsing and matching Solidity code patterns. Use this module to handle Solidity-specific syntax when analyzing or transforming smart contract code.",
      "description_length": 334,
      "index": 64,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Languages.Julia.Info",
      "library": "comby",
      "description": "This module defines metadata for the Julia programming language, including its name and file extensions. It provides direct access to the language name as a string and a list of associated file extensions. This information is used to identify and handle Julia source files in tooling contexts like syntax parsing or file processing.",
      "description_length": 332,
      "index": 65,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.C_nested_comments.Info",
      "library": "comby",
      "description": "This module defines metadata for a language variant that supports nested comments, including its name and associated file extensions. It is used to configure parsing or analysis tools that require language-specific settings. The data types include a string for the language name and a list of strings for file extensions.",
      "description_length": 321,
      "index": 66,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Move.Info",
      "library": "comby",
      "description": "This module defines metadata for the Move programming language, including its name and file extensions. It provides direct access to a list of common file extensions associated with Move source code. Concrete use cases include language detection and file filtering in tooling that processes Move codebases.",
      "description_length": 306,
      "index": 67,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Languages.Ruby.Info",
      "library": "comby",
      "description": "This module defines metadata for the Ruby programming language, including its name and file extensions. It provides concrete values for identifying Ruby files, such as the language name \"Ruby\" and a list of common extensions like `.rb`. This information is used in file processing and language detection workflows.",
      "description_length": 314,
      "index": 68,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Text.Info",
      "library": "comby",
      "description": "This module defines metadata for text-based languages, including the language name and associated file extensions. It works with string and list data types to store and retrieve this information. Concrete use cases include identifying language-specific files and providing display names for text processing tools.",
      "description_length": 313,
      "index": 69,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.OCaml.Info",
      "library": "comby",
      "description": "This module defines metadata for the OCaml language, including the language name and its common file extensions. It provides direct access to predefined values such as `name` and `extensions`. This information is used in tooling that needs to identify or process OCaml source files based on their extension or language name.",
      "description_length": 324,
      "index": 70,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Dhall.Info",
      "library": "comby",
      "description": "This module defines metadata for the Dhall configuration language, including its name and file extensions. It provides direct access to the language identifier and a list of associated file extensions. Useful for tooling that needs to recognize or process Dhall files based on extension or name.",
      "description_length": 295,
      "index": 71,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Xml.Info",
      "library": "comby",
      "description": "This module defines metadata for XML language support, including the language name and file extensions. It provides the `name` and `extensions` values to identify and associate files with XML syntax. Use this module when integrating XML parsing or processing tools that rely on file extension or language name detection.",
      "description_length": 320,
      "index": 72,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Html.Info",
      "library": "comby",
      "description": "This module defines metadata for HTML, including the language name and file extensions. It provides direct access to static information used for identifying and handling HTML files. Concrete use cases include determining file type based on extension or referencing the language name in tooling interfaces.",
      "description_length": 305,
      "index": 73,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.HCL.Syntax",
      "library": "comby",
      "description": "This module defines syntax elements for HCL (HashiCorp Configuration Language), including user-defined delimiters, escapable and raw string literals, and comment kinds. It provides precise syntactic patterns used to parse and match HCL configurations. Use this module to handle HCL-specific syntax when analyzing or transforming infrastructure configuration files.",
      "description_length": 364,
      "index": 74,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Elixir.Syntax",
      "library": "comby",
      "description": "This module defines syntax elements for parsing and matching Elixir code, including custom delimiters, escapable and raw string literals, and comment styles. It provides precise string patterns and configurations that align with Elixir's syntax rules. Use this module to support accurate code transformation, pattern matching, or static analysis tasks specific to Elixir source files.",
      "description_length": 384,
      "index": 75,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.JSONC.Syntax",
      "library": "comby",
      "description": "This module defines syntax elements for parsing JSONC (JSON with comments), including user-defined delimiters, escapable and raw string literals, and comment styles. It provides precise configurations to handle JSONC-specific syntax features, enabling accurate parsing and manipulation of JSONC documents. Use cases include building parsers or formatters that require strict adherence to JSONC syntax rules.",
      "description_length": 407,
      "index": 76,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.JSONC.Info",
      "library": "comby",
      "description": "This module defines metadata for the JSONC language, including its name and file extensions. It provides direct access to the language identifier and a list of associated file extensions. This information supports parsing and processing JSONC files in tooling contexts like syntax analysis or file type detection.",
      "description_length": 313,
      "index": 77,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Php.Info",
      "library": "comby",
      "description": "This module defines metadata for the PHP language, including its name and file extensions. It provides direct access to the `name` and `extensions` values, which specify the language identifier and associated file types. Use this module to retrieve standard PHP language information for file processing or language detection tasks.",
      "description_length": 331,
      "index": 78,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Swift.Info",
      "library": "comby",
      "description": "This module defines metadata for the Swift programming language, including its name and file extensions. It provides concrete values for identifying Swift source files, such as the language name \"Swift\" and a list of extensions like `.swift`. These values are used in tooling that needs to recognize or process Swift files, such as linters, formatters, or code analyzers.",
      "description_length": 371,
      "index": 79,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Go.Info",
      "library": "comby",
      "description": "This module defines metadata for the Go programming language, including its name and file extensions. It provides direct access to the language name as a string and a list of associated file extensions. Concrete use cases include identifying Go source files by extension and referencing the language name in tooling or configuration contexts.",
      "description_length": 342,
      "index": 80,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Rust.Info",
      "library": "comby",
      "description": "This module defines metadata for the Rust programming language, including its name and file extensions. It provides direct access to the language name as a string and a list of associated file extensions. This information is used for identifying and handling Rust source files in tooling contexts.",
      "description_length": 297,
      "index": 81,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Languages.Java.Syntax",
      "library": "comby",
      "description": "This module defines syntax elements specific to Java, including user-defined delimiters, escapable and raw string literals, and comment kinds. It provides precise syntactic patterns for parsing and matching Java code structures. Use this module to handle Java-specific lexical elements in code analysis or transformation tasks.",
      "description_length": 327,
      "index": 82,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.SQL.Syntax",
      "library": "comby",
      "description": "This module defines syntax elements for SQL, including user-defined delimiters, escapable and raw string literals, and comment styles. It provides concrete configurations for parsing and matching SQL code patterns. Use this module to handle SQL-specific syntax when analyzing or transforming database queries.",
      "description_length": 309,
      "index": 83,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Lisp.Syntax",
      "library": "comby",
      "description": "This module defines syntax elements for parsing and matching Lisp code, including delimiters for expressions, escapable and raw string literals, and comment styles. It supports concrete use cases like identifying s-expressions, handling quoted strings with escapes, and recognizing inline or block comments in Lisp dialects.",
      "description_length": 324,
      "index": 84,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Nim.Info",
      "library": "comby",
      "description": "This module defines metadata for the Nim programming language, including its name and file extensions. It provides direct access to a list of common file extensions associated with Nim source code. Use this module to identify Nim files or configure tools that process Nim code based on file extension.",
      "description_length": 301,
      "index": 85,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Fsharp.Info",
      "library": "comby",
      "description": "This module defines metadata for the F# programming language, including its name and file extensions. It provides direct access to the language name as a string and a list of associated file extensions. This information is used to identify and handle F# files in code processing tools.",
      "description_length": 285,
      "index": 86,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Bash.Syntax",
      "library": "comby",
      "description": "This module defines syntax elements for parsing Bash scripts, including customizable delimiters, escapable and raw string literals, and comment styles. It supports concrete use cases like template matching and code transformation in Bash scripts by specifying how strings and comments are structured. The data types include lists of string pairs for delimiters and literals, and options for escapable syntax.",
      "description_length": 408,
      "index": 87,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Languages.Haskell.Info",
      "library": "comby",
      "description": "This module defines metadata for the Haskell programming language, including its name and file extensions. It provides concrete values for identifying Haskell source files, such as `.hs` and `.lhs`. Use this module when implementing language-specific features like syntax highlighting, file parsing, or tooling integration for Haskell.",
      "description_length": 335,
      "index": 88,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Erlang.Info",
      "library": "comby",
      "description": "This module defines metadata for the Erlang language, including the language name and file extensions. It provides direct access to static information used for identifying and handling Erlang source files. Concrete use cases include configuring parsers or tools to recognize Erlang files based on extension or language name.",
      "description_length": 324,
      "index": 89,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.C.Syntax",
      "library": "comby",
      "description": "This module defines syntax elements for parsing and matching C code, including user-defined delimiters, escapable and raw string literals, and comment styles. It provides concrete configurations for handling C-specific syntax features like string escaping, multi-line comments, and delimiter pairs. Use this module when implementing parsers or matchers that need to accurately recognize and process C language constructs.",
      "description_length": 421,
      "index": 90,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Languages.HCL.Info",
      "library": "comby",
      "description": "This module defines metadata for the HCL language, including its name and file extensions. It provides direct access to static information used for language identification and file handling. Concrete use cases include determining HCL file types based on extension and referencing the language name in tooling interfaces.",
      "description_length": 320,
      "index": 91,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Latex.Syntax",
      "library": "comby",
      "description": "This module defines syntax elements for parsing and matching LaTeX documents, including customizable delimiters for macros, escapable and raw string literals, and comment styles. It supports precise pattern matching in LaTeX code by specifying how strings and comments are structured. Concrete use cases include implementing LaTeX macro extractors, syntax highlighters, or linters that require accurate recognition of LaTeX constructs.",
      "description_length": 435,
      "index": 92,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Languages.Zig.Info",
      "library": "comby",
      "description": "This module defines metadata for the Zig programming language, including its name and file extensions. It provides direct access to the language name as a string and a list of associated file extensions. Useful for tools that need to identify or process Zig source files based on their extension or display the language name.",
      "description_length": 325,
      "index": 93,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.CSS.Syntax",
      "library": "comby",
      "description": "This module defines syntax elements for parsing and matching CSS code, including delimiters for templating, escapable and raw string literals, and comment styles. It supports concrete use cases like pattern matching in CSS files, enabling tools for code transformation and analysis. The data types include lists of string pairs for delimiters and literals, and structured representations of comment syntax.",
      "description_length": 406,
      "index": 94,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Languages.Erlang.Syntax",
      "library": "comby",
      "description": "This module defines syntax elements specific to Erlang, including user-defined delimiters, escapable and raw string literals, and comment kinds. It provides precise syntactic patterns for parsing and matching Erlang code structures. Use cases include implementing custom parsers, linters, or code transformation tools that require accurate recognition of Erlang's syntax features.",
      "description_length": 380,
      "index": 95,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Assembly.Syntax",
      "library": "comby",
      "description": "This module defines syntax elements for parsing assembly code, including user-defined delimiters, escapable and raw string literals, and comment styles. It supports concrete use cases like identifying string boundaries and comment blocks in assembly source files. The data structures include lists of delimiter pairs and comment kinds specific to assembly languages.",
      "description_length": 366,
      "index": 96,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Dart.Info",
      "library": "comby",
      "description": "This module defines metadata for the Dart programming language, including its name and file extensions. It provides direct access to the language name as a string and a list of associated file extensions. This information is used to identify and handle Dart source files in tooling contexts like syntax parsing or code analysis.",
      "description_length": 328,
      "index": 97,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Tsx.Info",
      "library": "comby",
      "description": "This module defines metadata for the TSX language, including its name and file extensions. It provides direct access to the language identifier and a list of associated file extensions. Useful for tooling that needs to recognize or process TSX files based on their extension or name.",
      "description_length": 283,
      "index": 98,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Coq.Info",
      "library": "comby",
      "description": "This module defines metadata for the Coq programming language, including its name and file extensions. It provides direct access to the language name as a string and a list of associated file extensions. This information is used to identify and handle Coq source files in tooling that processes or analyzes code, such as parsers or language servers.",
      "description_length": 349,
      "index": 99,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.JSON.Syntax",
      "library": "comby",
      "description": "This module defines syntax elements for parsing and matching JSON, including customizable delimiters, escapable and raw string literals, and comment styles. It works with lists of string pairs for delimiters and literals, and comment kind structures. Concrete use cases include configuring parsers to handle JSON-specific syntax variations and supporting different string escaping rules.",
      "description_length": 387,
      "index": 100,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Lisp.Info",
      "library": "comby",
      "description": "This module defines metadata for the Lisp programming language, including its name and file extensions. It provides direct access to the language name as a string and a list of associated file extensions. This information is used to identify and handle Lisp source files in tooling that processes or analyzes code.",
      "description_length": 314,
      "index": 101,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Java.Info",
      "library": "comby",
      "description": "This module defines metadata for the Java language, including the language name and file extensions associated with Java source files. It provides direct access to this information through the `name` and `extensions` values. This data is used in tooling contexts where Java file identification or language labeling is required, such as in code analysis or editor integrations.",
      "description_length": 376,
      "index": 102,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Typescript.Syntax",
      "library": "comby",
      "description": "This module defines syntax-specific configurations for parsing and matching TypeScript code. It specifies delimiters for user-defined constructs, escapable and raw string literals, and comment styles. These values guide accurate pattern matching and transformation of TypeScript source code in tools like code refactoring or static analysis systems.",
      "description_length": 349,
      "index": 103,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Languages.Go.Syntax",
      "library": "comby",
      "description": "This module defines syntax-specific elements for parsing and matching Go code, including user-defined delimiters, escapable and raw string literals, and comment kinds. It provides precise syntactic patterns used to identify and transform Go source code structures. Concrete use cases include matching function signatures, variable declarations, and comment blocks in Go files.",
      "description_length": 376,
      "index": 104,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Languages.Jsx.Syntax",
      "library": "comby",
      "description": "This module defines syntax elements for JSX, including user-defined delimiters, escapable and raw string literals, and comment kinds. It provides precise parsing and matching capabilities for JSX structures in source code analysis. Use cases include template-based code transformation and syntax-aware pattern matching in JSX files.",
      "description_length": 332,
      "index": 105,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Typescript.Info",
      "library": "comby",
      "description": "This module defines metadata for the TypeScript language, including the language name and file extensions. It provides direct access to the name as a string and the extensions as a list of strings. Concrete use cases include identifying TypeScript files by extension and referencing the language name in tooling or configuration contexts.",
      "description_length": 338,
      "index": 106,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Languages.Text.Syntax",
      "library": "comby",
      "description": "This module defines syntax elements for text-based languages, including user-defined delimiters, escapable and raw string literals, and comment styles. It provides precise configuration for parsing and matching textual constructs in source code. Use this module to customize syntax handling for specific programming languages or domain-specific text formats.",
      "description_length": 358,
      "index": 107,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Move.Syntax",
      "library": "comby",
      "description": "This module defines syntax-specific configurations for parsing and matching code in the Move language. It specifies delimiters, escapable and raw string literals, and comment styles used in Move source code. These values are used to customize pattern matching and transformation tools for Move programs.",
      "description_length": 303,
      "index": 108,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Languages.Fortran.Syntax",
      "library": "comby",
      "description": "This module defines syntax elements for Fortran, including user-defined delimiters, escapable and raw string literals, and comment styles. It supports parsing and matching Fortran code by specifying how strings and comments are structured in the language. Concrete use cases include configuring code transformation tools and implementing syntax-aware pattern matchers for Fortran source files.",
      "description_length": 393,
      "index": 109,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Languages.Matlab.Info",
      "library": "comby",
      "description": "This module defines metadata for the MATLAB programming language, including its name and file extensions. It provides direct access to the language name as a string and a list of associated file extensions. This information is used for identifying and handling MATLAB source files in tooling contexts like parsing or analysis.",
      "description_length": 326,
      "index": 110,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Nim.Syntax",
      "library": "comby",
      "description": "This module defines syntax elements for the Nim programming language, including user-defined delimiters, escapable and raw string literals, and comment kinds. It provides precise syntactic patterns used for parsing and matching Nim code structures. Use this module to handle Nim-specific syntax when analyzing or transforming Nim source files.",
      "description_length": 343,
      "index": 111,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Reason.Info",
      "library": "comby",
      "description": "This module defines metadata for the Reason programming language, including its name and file extensions. It provides direct access to a list of common file extensions associated with Reason source files. Use this module to identify or handle files related to the Reason language based on their extension.",
      "description_length": 305,
      "index": 112,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.R.Info",
      "library": "comby",
      "description": "This module defines metadata for a specific programming language, including its name and associated file extensions. It works with basic string and list data types to store and retrieve this information. Concrete use cases include identifying the language by name and determining file types based on extensions.",
      "description_length": 311,
      "index": 113,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Fortran.Info",
      "library": "comby",
      "description": "This module defines metadata for the Fortran language, including its name and file extensions. It provides direct access to the language name as a string and a list of associated file extensions. This information is used to identify and handle Fortran source files in tooling that requires language-specific configuration.",
      "description_length": 322,
      "index": 114,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Jsx.Info",
      "library": "comby",
      "description": "This module defines metadata for the JSX language, including its name and file extensions. It provides direct access to the language identifier and a list of associated file extensions. Useful for tools that need to recognize or process JSX files based on their extension or name.",
      "description_length": 280,
      "index": 115,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Languages.Swift",
      "library": "comby",
      "description": "This module provides concrete metadata and syntax definitions for the Swift programming language. It includes file extensions like `.swift` and syntax elements such as string delimiters, escapable characters, and comment markers. Use it to configure code processing tools like linters, formatters, or parsers to correctly identify and handle Swift source files.",
      "description_length": 361,
      "index": 116,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Alpha.Ruby",
      "library": "comby",
      "description": "This module provides functions to find all or the first matches of a template in Ruby source code, supporting recursive matching on nested structures. It operates on strings representing code templates and source input, returning lists of match results or individual match outcomes. Use cases include searching for specific Ruby code patterns, such as method definitions or variable assignments, within larger codebases.",
      "description_length": 420,
      "index": 117,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Alpha.Pascal",
      "library": "comby",
      "description": "This module provides functions to find all or the first matches of a template in a source string, supporting recursive matching and optional configuration. It works with strings as input and returns lists of matches or individual match results. Use cases include parsing and transforming code in languages like Pascal, where specific syntax patterns need to be identified and processed.",
      "description_length": 386,
      "index": 118,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Alpha.Dart",
      "library": "comby",
      "description": "This module provides functions to find all or the first matches of a template in a Dart source string, supporting recursive matching on nested content. It operates on strings for both template and source input, returning lists of matches or individual match results with optional configuration and file context. Use cases include parsing Dart code to identify specific syntactic patterns, such as function definitions or variable declarations, within a given source file or snippet.",
      "description_length": 482,
      "index": 119,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Omega.JSON",
      "library": "comby",
      "description": "This module provides functions to match JSON templates against source code, specifically `all` for finding all matches and `first` for locating the first match starting at a given position. It works with strings as input for both template and source data, returning lists of matches or individual match results. Use cases include structural code analysis and transformation tasks where precise JSON-based pattern matching is required.",
      "description_length": 434,
      "index": 120,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Omega.Paren",
      "library": "comby",
      "description": "This module provides functions to find all or first matches of a template in a source string, supporting recursive matching through a configuration flag. It works with strings as input and returns lists of matches or individual match results, using a configuration that includes language-specific rules. It is used for pattern matching in source code analysis, particularly for languages with parenthetical structures.",
      "description_length": 418,
      "index": 121,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Languages.Zig",
      "library": "comby",
      "description": "This module provides direct access to the Zig language name and its file extensions for identification and processing of Zig source files. It defines syntax configurations for parsing Zig code, including string literals, delimiters, and comments. Useful for tools that analyze or transform Zig code by matching its syntactic structures.",
      "description_length": 336,
      "index": 122,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Alpha.Reason",
      "library": "comby",
      "description": "This module provides functions to find all or the first matches of a template in a source string, supporting recursive matching through a configuration flag. It works with strings as input and returns lists of matches or individual match results, along with metadata like the language name and file extensions. It is used for pattern matching in source code, particularly for languages with specific syntax rules that can be described through templates.",
      "description_length": 453,
      "index": 123,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Go",
      "library": "comby",
      "description": "This module provides metadata and syntax definitions for working with Go source code. It includes operations to identify Go files by extension and define syntactic elements like delimiters, string literals, and comments. Concrete use cases involve parsing Go code, matching specific language constructs, and supporting tooling that requires Go-specific syntax handling.",
      "description_length": 369,
      "index": 124,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Alpha.Jsx",
      "library": "comby",
      "description": "This module provides functions to find all or the first matches of a template in JSX source code, supporting recursive matching through a configuration flag. It works with strings for templates and source code, returning lists of matches or individual match results. Use cases include searching for specific JSX patterns in files or extracting elements from JSX structures.",
      "description_length": 373,
      "index": 125,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Omega.Xml",
      "library": "comby",
      "description": "This module provides functions to match XML templates against source code, supporting both full and first-match searches with optional configuration and nested matching. It operates on strings for templates and source input, returning lists of matches or individual match results. Use cases include identifying specific XML structures in documents, extracting elements, or analyzing XML-based configurations.",
      "description_length": 408,
      "index": 126,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Alpha.JSONC",
      "library": "comby",
      "description": "This module provides functions to match JSONC templates in source code, including finding all matches or the first match at a specified position. It works with strings as input sources and templates, returning lists of matches or individual match results. Use cases include parsing and transforming JSONC-formatted data with structural pattern matching.",
      "description_length": 353,
      "index": 127,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Omega.Clojure",
      "library": "comby",
      "description": "This module provides functions to find all or the first matches of a template in a Clojure source string, supporting recursive matching on nested structures. It operates on strings as input sources and templates, returning lists of matches or error-handled single matches. Use cases include parsing and transforming Clojure code based on structural patterns, such as identifying function definitions or rewriting specific expressions.",
      "description_length": 434,
      "index": 128,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Alpha.Csharp",
      "library": "comby",
      "description": "This module implements template-based matching for C# code, supporting operations to find all matches or the first match of a given template within a source string. It works with string inputs representing C# code and templates, and returns structured match results. Use cases include code analysis, transformation, and refactoring tasks specific to C#.",
      "description_length": 353,
      "index": 129,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Alpha.C",
      "library": "comby",
      "description": "This module implements template-based matching and extraction for C language source code. It provides operations to find all matches or the first occurrence of a template in a source string, supporting recursive matching on nested structures. The module works with C syntax trees, handling concrete use cases like code pattern detection and transformation in C files.",
      "description_length": 367,
      "index": 130,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Alpha.Scala",
      "library": "comby",
      "description": "This module provides functions to find all or first matches of a template in Scala source code, supporting recursive matching on nested structures. It operates on strings for both template and source input, returning lists or individual match results. Use cases include searching for specific code patterns in Scala files, such as identifying function calls or syntactic constructs within a codebase.",
      "description_length": 400,
      "index": 131,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Paren",
      "library": "comby",
      "description": "This module provides functions to define and configure language metadata and syntax settings for parenthetical languages. It works with strings and lists to store language names, file extensions, delimiters, string markers, and comment syntax. Use it to set up custom language parsing for tools processing Lisp, Scheme, or similar languages with specific delimiter and formatting rules.",
      "description_length": 386,
      "index": 132,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Alpha.GraphQL",
      "library": "comby",
      "description": "This module implements template-based pattern matching for GraphQL syntax, providing functions to find all or the first match of a template in a source string. It operates on GraphQL documents and supports recursive matching within nested structures. Use cases include code analysis and transformation tasks specific to GraphQL schemas or queries.",
      "description_length": 347,
      "index": 133,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Omega.Swift",
      "library": "comby",
      "description": "This module provides functions to match templates within Swift source code, returning all matches or the first match based on a starting position. It operates on strings representing the template and source code, and produces structured match results. It is used for analyzing or transforming Swift code by identifying specific syntactic patterns.",
      "description_length": 347,
      "index": 134,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Java",
      "library": "comby",
      "description": "This module provides access to Java language metadata and syntax definitions. It includes values for identifying Java files by extension and tools for matching Java-specific lexical structures like comments, strings, and delimiters. Use it to build code analysis or transformation tools that require precise handling of Java syntax.",
      "description_length": 332,
      "index": 135,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Alpha.Elixir",
      "library": "comby",
      "description": "This module provides functions to find all or the first matches of a template in Elixir source code, supporting recursive matching on nested structures. It operates on strings for both template and source input, returning lists of match results or individual match errors. Use cases include searching for specific code patterns in Elixir files, such as function definitions or syntactic constructs, during code analysis or transformation tasks.",
      "description_length": 444,
      "index": 136,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Omega.Rust",
      "library": "comby",
      "description": "This module provides functions to find all or the first matches of a template in a source string, supporting recursive matching and optional configuration. It works with strings as input and returns lists of matches or individual match results. Use cases include parsing and transforming code by identifying specific patterns in source files based on language-specific extensions.",
      "description_length": 380,
      "index": 137,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Omega.Fortran",
      "library": "comby",
      "description": "This module implements template matching for Fortran code, providing functions to find all or the first match of a template within a source string. It operates on strings representing Fortran source code and templates, supporting recursive matching when enabled. Use cases include automated code transformation and static analysis tasks specific to Fortran.",
      "description_length": 357,
      "index": 138,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Omega.Haskell",
      "library": "comby",
      "description": "This module provides functions to find all or the first matches of a template in a source string, supporting recursive matching on nested content. It works with strings as input and returns lists of matches or individual match results, along with configuration options for file paths and rules. It is used for pattern matching in source code, particularly for languages like Haskell, with support for specifying file extensions and optional match configurations.",
      "description_length": 462,
      "index": 139,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Alpha.Xml",
      "library": "comby",
      "description": "This module provides functions to match XML templates against source code, supporting both first-match and all-matches operations with optional nested matching. It works with strings as input templates and sources, returning lists or individual match records. It is used for structural code analysis and transformation tasks in XML-based languages.",
      "description_length": 348,
      "index": 140,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Omega.Jsx",
      "library": "comby",
      "description": "This module provides functions to match templates within JSX source code, supporting both full and first-match searches with configurable parameters. It operates on strings representing templates and source code, returning lists of matches or individual match results. Use cases include identifying specific JSX patterns in files for refactoring or analysis, with support for recursive matching and file-specific configurations.",
      "description_length": 428,
      "index": 141,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Generic",
      "library": "comby",
      "description": "This module provides language metadata and syntax configuration for code pattern matching. It works with string delimiters, comments, and file extensions to enable language-specific parsing and transformation. Used to define and identify language syntax for code analysis and rewriting tasks.",
      "description_length": 292,
      "index": 142,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Typescript",
      "library": "comby",
      "description": "This module provides precise metadata and syntax configurations for working with TypeScript code. It includes the language name, file extensions, delimiters, string literal markers, and comment styles. It is used to identify TypeScript files, configure parsers, and enable accurate code matching and transformation in tools like linters, refactoring utilities, and code search engines.",
      "description_length": 385,
      "index": 143,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.SQL",
      "library": "comby",
      "description": "This module provides operations for identifying SQL files through metadata and handling SQL syntax elements like delimiters, string literals, and comments. It works with string and file data to support parsing and pattern matching in SQL code. Concrete use cases include query analysis, code transformation, and file type detection based on SQL-specific characteristics.",
      "description_length": 370,
      "index": 144,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Php",
      "library": "comby",
      "description": "This module provides access to PHP language metadata and syntax configurations. It includes values for identifying the PHP language, its file extensions, and syntax elements like string delimiters and comment styles. Use it to support PHP code parsing, language detection, or file processing tasks requiring precise knowledge of PHP's syntax and naming conventions.",
      "description_length": 365,
      "index": 145,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Languages.Lisp",
      "library": "comby",
      "description": "This module provides direct access to Lisp language metadata, such as its name and common file extensions like `.lisp` and `.el`. It defines syntax elements specific to Lisp, including delimiters for s-expressions, string literals, and comment markers. These are used to accurately parse and match Lisp code structures in tools like formatters, linters, or code analyzers.",
      "description_length": 372,
      "index": 146,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Elm",
      "library": "comby",
      "description": "This module provides direct access to metadata about the Elm programming language, including its name and common file extensions like `.elm`. It defines syntax elements specific to Elm, such as string delimiters, comment styles, and escapable characters, enabling accurate parsing and matching of Elm source code. These are used in tools like linters, parsers, or code matchers that need to process Elm files with precise syntactic recognition.",
      "description_length": 444,
      "index": 147,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Alpha.Html",
      "library": "comby",
      "description": "This module provides functions to match HTML content using templates, specifically `all` to find all matches and `first` to find the first match starting at a given position. It works with strings as input sources and templates, returning lists of matches or individual match results. Use cases include extracting or analyzing HTML structures, such as finding all script tags or locating specific elements within a document.",
      "description_length": 424,
      "index": 148,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Alpha.Kotlin",
      "library": "comby",
      "description": "This module provides functions to find all or the first occurrences of a template in Kotlin source code, returning detailed match information. It operates on strings representing source code and templates, with options to control matching behavior like recursion and starting position. Use cases include code analysis and transformation tasks where precise pattern matching in Kotlin files is required.",
      "description_length": 402,
      "index": 149,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Languages.Assembly",
      "library": "comby",
      "description": "This module provides operations for identifying assembly language file types through extensions and handling syntax elements like comments, strings, and delimiters in assembly code. It works with strings and lists to define language metadata and syntax rules. Concrete use cases include parsing assembly source files by detecting comment blocks, string literals, and matching file extensions to known assembly language variants.",
      "description_length": 428,
      "index": 150,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Alpha.Bash",
      "library": "comby",
      "description": "This module provides functions to match templates against Bash source code, returning all matches or the first match based on a starting position. It operates on strings representing templates and source code, producing lists of match results or individual match outcomes. Use cases include searching for specific Bash code patterns in scripts, such as finding all instances of a function definition or locating the first occurrence of a variable assignment.",
      "description_length": 458,
      "index": 151,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Alpha.Assembly",
      "library": "comby",
      "description": "This module implements template-based matching over source code, providing operations to find all matches or the first match of a template within a given source string. It works with string inputs representing code and templates, and returns structured match results that include positions and captured variables. The module is used to implement language-specific pattern matching for code analysis and transformation tasks, such as finding function calls or variable declarations in a specific programming language.",
      "description_length": 516,
      "index": 152,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Alpha.Julia",
      "library": "comby",
      "description": "This module implements template-based matching for Julia source code, supporting operations to find all or the first match of a given template within a source string. It works with string inputs representing Julia code and configuration parameters to control matching behavior, such as recursion into nested structures. Use cases include automated code analysis and transformation tasks specific to Julia, such as finding function definitions or specific syntactic patterns in Julia scripts.",
      "description_length": 491,
      "index": 153,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Alpha.Javascript",
      "library": "comby",
      "description": "This module provides functions to find all or first matches of a JavaScript template in a source string, supporting recursive matching on nested structures. It operates on strings and uses configuration options to customize matching behavior, returning lists of matches or individual match results. Use cases include code analysis and transformation tasks specific to JavaScript, such as identifying function calls or variable declarations.",
      "description_length": 440,
      "index": 154,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Alpha.Latex",
      "library": "comby",
      "description": "This module implements LaTeX-specific pattern matching operations, including finding all matches of a template string within a source document and retrieving the first match starting at a specified position. It works with LaTeX syntax structures, handling recursive matches when enabled. Use cases include searching for LaTeX macros, environments, or custom patterns in document content.",
      "description_length": 387,
      "index": 155,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Alpha.Python",
      "library": "comby",
      "description": "This module provides functions to find all or the first matches of a template in Python source code, supporting recursive matching on nested structures. It operates on strings for both template and source code, returning lists of matches or individual match results. Use cases include searching for specific syntax patterns in Python files, such as function definitions or expressions, with optional configuration and file context.",
      "description_length": 431,
      "index": 156,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Omega.JSONC",
      "library": "comby",
      "description": "This module provides functions to match JSONC templates against source code, supporting both full and first-match searches with optional configuration and file context. It operates on strings as input sources and templates, returning lists of matches or individual match results. Use cases include finding all instances of a JSONC pattern in a file or identifying the first occurrence starting at a specific position.",
      "description_length": 417,
      "index": 157,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Metasyntax.Default",
      "library": "comby",
      "description": "This module defines the default metasyntax configuration for parsing and matching, including a list of hole syntax rules, an identifier string, and a list of aliases. It is used to specify how patterns with metavariables and special placeholders should be interpreted during matching operations. Concrete use cases include configuring parsers to recognize specific syntax patterns in source code or structured text.",
      "description_length": 415,
      "index": 158,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Html",
      "library": "comby",
      "description": "This module provides functions to identify HTML files by extension and define syntax rules for parsing and matching HTML content. It works with string-based representations of HTML, including embedded expressions, comments, and literals. Concrete use cases include file type detection in build systems and configuring parsers for HTML templating or refactoring tools.",
      "description_length": 367,
      "index": 159,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Alpha.Swift",
      "library": "comby",
      "description": "This module provides functions to find all or first matches of a template in Swift source code, returning lists or individual match results. It works with strings for template and source input, and supports configuration parameters for matching behavior. Use cases include searching for specific Swift code patterns in files or snippets, such as identifying function calls or syntax structures.",
      "description_length": 394,
      "index": 160,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Omega.Text",
      "library": "comby",
      "description": "This module provides functions to match text templates against source code, supporting operations to find all matches or the first match with optional configuration and file context. It works with strings as input source and template, and returns structured match results with support for nested matching. It is used for language-specific pattern matching in code analysis tools, leveraging template-based queries to identify syntactic structures.",
      "description_length": 447,
      "index": 161,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Omega.Scala",
      "library": "comby",
      "description": "This module provides functions to find all or first matches of a template in Scala source code, supporting recursive matching and file-specific configurations. It operates on strings for templates and source code, returning lists of matches or error-handled single matches. Use cases include code analysis and transformation tasks where precise pattern matching in Scala is required.",
      "description_length": 383,
      "index": 162,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Omega.HCL",
      "library": "comby",
      "description": "This module provides functions to match HCL (HashiCorp Configuration Language) code against templates, supporting both full and first-match searches with configurable parameters. It operates on HCL source code strings and templates, returning structured match results. Use cases include finding specific configuration patterns in Terraform or HCL files for analysis or transformation tasks.",
      "description_length": 390,
      "index": 163,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Bash",
      "library": "comby",
      "description": "This module provides structured definitions for Bash language metadata and syntax elements. It includes specific data types like lists of file extensions and syntax constructs such as delimiters, string literals, and comment styles. It is used for tasks like file type detection, syntax parsing, and code transformation in Bash scripts.",
      "description_length": 336,
      "index": 164,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Scala",
      "library": "comby",
      "description": "This module provides direct access to Scala's language name and file extensions, and defines syntax elements like string delimiters, escape sequences, and comment styles. It works with scalar values and lists to represent language metadata and syntax configurations. Concrete use cases include language identification, parser configuration for string interpolation, and handling multi-line comments in code processing tools.",
      "description_length": 424,
      "index": 165,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Omega.Kotlin",
      "library": "comby",
      "description": "This module provides functions to find all or the first matches of a template in Kotlin source code, supporting recursive matching through a configuration flag. It operates on strings for both template and source code, returning lists of matches or individual match results. Use cases include code analysis and transformation tasks specific to Kotlin, such as identifying specific function calls or code patterns in Kotlin files.",
      "description_length": 429,
      "index": 166,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Omega.Move",
      "library": "comby",
      "description": "This module provides functions to find all or first matches of a template in a source string, supporting recursive matching when enabled. It works with strings as input and returns lists or individual match records. Use cases include identifying structured patterns in code, such as function calls or variable declarations, for transformations or analysis.",
      "description_length": 356,
      "index": 167,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Alpha.Paren",
      "library": "comby",
      "description": "This module implements template-based matching for structured text, specifically handling parenthetical and nested syntax patterns. It provides functions to find all matches or the first match of a template in a source string, supporting recursive matching when enabled. Typical use cases include parsing and transforming code snippets with nested expressions, such as arithmetic or function call structures.",
      "description_length": 408,
      "index": 168,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Languages.Kotlin",
      "library": "comby",
      "description": "This module provides direct access to Kotlin language metadata, such as its name and common file extensions like `.kt` and `.kts`. It includes syntax definitions for handling Kotlin-specific string literals, including raw strings and escaped sequences, along with comment structures. These features support accurate parsing, matching, and transformation of Kotlin code in tools like linters, formatters, and code analyzers.",
      "description_length": 423,
      "index": 169,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Omega.Tsx",
      "library": "comby",
      "description": "This module provides functions to find all or first matches of a template in a source string, supporting recursive matching on nested content. It works with strings as input sources and templates, returning lists of matches or individual match results. Use cases include searching for code patterns in TypeScript or JSX files, such as identifying function calls or specific syntax structures.",
      "description_length": 392,
      "index": 170,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Omega.Solidity",
      "library": "comby",
      "description": "This module provides functions to find all or the first matches of a template in Solidity source code, supporting recursive matching through a configuration flag. It works with strings for templates and source code, returning lists of matches or individual match results. It is used for analyzing or transforming Solidity code by identifying specific syntactic patterns.",
      "description_length": 370,
      "index": 171,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Alpha.Lisp",
      "library": "comby",
      "description": "This module implements template-based matching for Lisp-like syntax, supporting operations to find all or first matches of a template in a source string. It works with string inputs representing Lisp code and produces structured match results. Use cases include code analysis and transformation tasks specific to Lisp dialects, such as identifying function calls or rewriting expressions based on syntactic patterns.",
      "description_length": 416,
      "index": 172,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Language.Info",
      "library": "comby",
      "description": "This module defines operations for retrieving language-specific information, such as syntax rules and parsing behaviors, used during pattern matching. It works with abstract data types representing programming languages and their associated metadata. Concrete use cases include configuring matchers to handle different languages correctly, such as identifying comment syntax or operator precedence.",
      "description_length": 398,
      "index": 173,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.JSONC",
      "library": "comby",
      "description": "This module provides metadata and syntax definitions for working with JSONC files. It includes identifiers and file extensions for language recognition, and specifies syntax elements like delimiters, strings, and comments for accurate parsing and formatting. It is used in tools that require strict handling of JSONC, such as linters, parsers, and code formatters.",
      "description_length": 364,
      "index": 174,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Omega.Make",
      "library": "comby",
      "description": "This module implements template-based matching for structured text, providing operations to find all or first matches of a pattern within a source string. It works with string templates and source code, returning detailed match information such as positions and captured variables. Use cases include code analysis, refactoring tools, and structured search in files.",
      "description_length": 365,
      "index": 175,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Languages.Python",
      "library": "comby",
      "description": "This module provides access to Python language metadata and syntax configuration. It includes the language name, file extensions, string delimiters, escape handling, and comment styles. It is used to support accurate parsing, matching, and transformation of Python code in syntax-aware tools.",
      "description_length": 292,
      "index": 176,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Omega.Typescript",
      "library": "comby",
      "description": "This module provides functions to find all or the first matches of a template in TypeScript source code, supporting recursive matching through a configuration flag. It works with strings for both the template and source code, returning lists of matches or individual match results. Use cases include searching for specific code patterns in TypeScript files, such as identifying function calls or variable declarations, and performing structured code analysis.",
      "description_length": 459,
      "index": 177,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Omega.Python",
      "library": "comby",
      "description": "This module provides functions to find all or first matches of a template in Python source code, supporting recursive matching through a configuration flag. It operates on strings for both template and source code, returning lists of match results or individual match outcomes. Use cases include searching for specific code patterns in Python files, such as identifying function calls or syntax structures.",
      "description_length": 406,
      "index": 178,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Alpha.Generic",
      "library": "comby",
      "description": "This module provides functions to find all or the first matches of a template within a source string, supporting recursive matching when enabled. It operates on strings as input and returns structured match results, with optional configuration and positional control. Use cases include parsing and transforming code or structured text by identifying specific patterns in languages like C or Go, using templates to locate and extract relevant sections.",
      "description_length": 451,
      "index": 179,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.CSS",
      "library": "comby",
      "description": "This module provides language metadata and syntax definitions for working with CSS files. It includes operations to identify CSS by name and file extensions, and defines syntax elements like delimiters, string literals, and comment structures. Use it to enable CSS-specific processing in tools such as parsers, linters, or code transformers.",
      "description_length": 341,
      "index": 180,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Pascal",
      "library": "comby",
      "description": "This module provides metadata and syntax definitions for Pascal, including file extensions and language name in the `Info` submodule, and syntax elements like delimiters, string literals, and comments in the `Syntax` submodule. It works with configuration and parsing data structures to support code analysis, transformation, and language tooling. Concrete use cases include setting up Pascal-aware linters, parsers, or code generators that require precise language metadata and syntactic rules.",
      "description_length": 495,
      "index": 181,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Omega.R",
      "library": "comby",
      "description": "This module provides functions to find all or first matches of a template in a source string, supporting recursive matching through a configuration flag. It operates on strings for both template and source input, returning lists of matches or individual match results. The module also identifies the language it matches through a name and lists associated file extensions.",
      "description_length": 372,
      "index": 182,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Omega.Pascal",
      "library": "comby",
      "description": "This module implements template-based matching for Pascal language code, providing functions to find all matches or the first match of a given template in a source string. It operates on strings representing Pascal code and templates, returning structured match results with support for nested matching. Use cases include code analysis and transformation tasks where specific Pascal syntax patterns need to be identified, such as extracting function definitions or identifying code constructs for refactoring.",
      "description_length": 509,
      "index": 183,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Alpha.Java",
      "library": "comby",
      "description": "This module provides functions to find all or first matches of a template in Java source code, supporting recursive matching on nested structures. It operates on strings for both template and source input, returning lists of match results or individual match errors. Use cases include searching for specific code patterns in Java files, such as identifying method calls or variable declarations, based on a given template.",
      "description_length": 422,
      "index": 184,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Alpha.HCL",
      "library": "comby",
      "description": "This module provides functions to match HCL (HashiCorp Configuration Language) code against templates, supporting both full and first-match searches with configurable parameters. It operates on HCL source strings and templates, returning structured match results. Use cases include parsing and analyzing HCL configurations for specific patterns, such as extracting resource definitions or validating configuration structures.",
      "description_length": 425,
      "index": 185,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Reason",
      "library": "comby",
      "description": "This module provides metadata and syntax definitions for working with Reason source files. It includes file extensions for identification and handling, and specifies syntax elements like delimiters, string literals, and comments for parsing and pattern matching. Use it to build tools such as linters, formatters, or code analyzers that require accurate syntax recognition for ReasonML.",
      "description_length": 386,
      "index": 186,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.GraphQL",
      "library": "comby",
      "description": "This module provides metadata about the GraphQL language, including its name and common file extensions, along with syntax definitions for parsing and matching GraphQL code. It supports operations like identifying GraphQL files by extension and recognizing syntactic elements such as strings, comments, and delimiters. Concrete use cases include implementing linters, query validators, and automated refactoring tools tailored to GraphQL schemas and operations.",
      "description_length": 461,
      "index": 187,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Omega.Reason",
      "library": "comby",
      "description": "This module provides functions to find all or the first matches of a template within a source string, supporting nested matching and language-specific configurations. It operates on strings as input sources and templates, returning lists of match results or individual match outcomes. Use cases include pattern matching in code files for refactoring or analysis, where specific language extensions and configurations are required.",
      "description_length": 430,
      "index": 188,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Omega.Latex",
      "library": "comby",
      "description": "This module implements template-based matching for LaTeX code, providing functions to find all or the first match of a template within a source string. It works with strings as input and output, operating on LaTeX syntax trees through pattern matching. Use it to locate specific LaTeX constructs like equations, sections, or custom macros within larger documents.",
      "description_length": 363,
      "index": 189,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.R",
      "library": "comby",
      "description": "This module provides precise definitions for handling R language syntax and metadata. It includes specifications for parsing R code with support for custom delimiters, string literals, and comment styles, along with basic data structures for storing language names and file extensions. Use it to configure code analysis tools, matchers, or parsers that need to accurately recognize and process R source files based on their syntactic and structural properties.",
      "description_length": 460,
      "index": 190,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Omega.Julia",
      "library": "comby",
      "description": "This module provides functions to match Julia code against templates, returning all matches or the first match with optional offset. It operates on strings representing source code and templates, producing lists of match results or error-handled single matches. It is used for analyzing or transforming Julia code by structural pattern matching.",
      "description_length": 345,
      "index": 191,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Coq",
      "library": "comby",
      "description": "This module provides metadata about the Coq programming language, including its name and supported file extensions. It is used to identify and handle Coq source files in tools like parsers and language servers. The module directly exposes the language name as a string and a list of common file extensions associated with Coq.",
      "description_length": 326,
      "index": 192,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Latex",
      "library": "comby",
      "description": "This module provides metadata about the LaTeX language, including its name and common file extensions. It also defines syntax rules for parsing LaTeX documents, such as macro delimiters, string literals, and comment handling. These components enable tools like LaTeX macro extractors, syntax highlighters, and linters to accurately process and analyze LaTeX code.",
      "description_length": 363,
      "index": 193,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Julia",
      "library": "comby",
      "description": "This module provides direct access to the Julia language name and its file extensions for identification and processing of Julia source files. It defines syntax elements like delimiters, string literals, and comments for accurate parsing and transformation of Julia code. Use it to handle Julia-specific syntax patterns, such as recognizing raw strings or stripping comments during code analysis.",
      "description_length": 396,
      "index": 194,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.External.Default",
      "library": "comby",
      "description": "This module defines a default external handler used for processing match and substitution operations in Comby's pattern matching system. It works with structured data such as abstract syntax trees (ASTs) and string-based patterns, enabling concrete transformations over codebases. It is typically used during the execution phase of Comby rules to apply structural changes to matched code elements.",
      "description_length": 397,
      "index": 195,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Omega.Csharp",
      "library": "comby",
      "description": "This module implements template-based matching and searching for C# code. It provides functions to find all matches or the first occurrence of a template within a source string, supporting recursive matching when enabled. The module handles C# syntax and is used for tasks like code analysis, transformation, and querying specific code patterns.",
      "description_length": 345,
      "index": 196,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Omega.Dyck",
      "library": "comby",
      "description": "This module implements Dyck language-based matching for structured code patterns, supporting operations to find all or first matches of a template within a source string. It works with string inputs representing code templates and source code, returning lists of match results or individual match outcomes. Use cases include precise structural code queries where nested constructs must be matched correctly, such as identifying function calls or control structures in source code.",
      "description_length": 480,
      "index": 197,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Csharp",
      "library": "comby",
      "description": "This module provides metadata and syntax definitions for working with C# code. It includes file extension recognition and handles C#-specific syntax elements like string literals, comments, and delimiters. Use it to configure parsers, build refactoring tools, or implement syntax-aware code transformations.",
      "description_length": 307,
      "index": 198,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Ruby",
      "library": "comby",
      "description": "This module provides metadata and syntax definitions for the Ruby programming language. It includes concrete values like file extensions (e.g., `.rb`) and syntax elements such as string delimiters and comment markers. It supports use cases like language detection, code parsing, and refactoring tools that require precise Ruby syntax handling.",
      "description_length": 343,
      "index": 199,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Dart",
      "library": "comby",
      "description": "This module provides direct access to Dart language metadata, such as its name and common file extensions like `.dart`. It includes syntactic definitions for parsing Dart code, such as string literals, delimiters, and comments. Use it to configure tools that process or analyze Dart source files, like linters or code transformers.",
      "description_length": 331,
      "index": 200,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Omega.Elixir",
      "library": "comby",
      "description": "This module provides functions to find all or first matches of a template in Elixir source code, supporting recursive matching on nested structures. It operates on strings for both template and source input, returning lists of match results or individual match errors. Use cases include code analysis and transformation tasks specific to Elixir, such as identifying function calls or syntactic patterns in source files.",
      "description_length": 419,
      "index": 201,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Elixir",
      "library": "comby",
      "description": "This module provides direct access to Elixir language metadata, including its name and common file extensions like `.ex` and `.exs`. It also defines syntax patterns specific to Elixir, such as string delimiters, escape sequences, and comment formats. These components enable accurate parsing, matching, and processing of Elixir source files in tools like formatters, linters, or code analyzers.",
      "description_length": 394,
      "index": 202,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Languages.Nim",
      "library": "comby",
      "description": "This module provides metadata and syntax definitions for the Nim programming language. It includes file extensions for identifying Nim source files and syntactic patterns for parsing Nim code, such as string literals, delimiters, and comments. Use it to configure tools or analyze Nim source files based on language-specific structure.",
      "description_length": 335,
      "index": 203,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Alpha.Tsx",
      "library": "comby",
      "description": "This module implements template-based matching for TypeScript JSX (TSX) code, supporting operations to find all or the first match of a given template within a source string. It works with string inputs representing source code and templates, returning structured match results with optional recursive matching. Use cases include automated code transformation and static analysis tasks where precise syntactic matching is required in TSX files.",
      "description_length": 444,
      "index": 204,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Alpha.Php",
      "library": "comby",
      "description": "This module provides functions to find all or first matches of a template in PHP source code, supporting recursive matching on nested structures. It operates on strings for both template and source code, returning lists of match results or individual match errors. Use cases include searching for specific PHP syntax patterns, such as function calls or variable assignments, within larger codebases.",
      "description_length": 399,
      "index": 205,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Matlab",
      "library": "comby",
      "description": "This module provides direct access to MATLAB language metadata, including its name and common file extensions like `.m`. It defines syntax configurations specific to MATLAB, such as delimiters, string literals, and comment styles. These are used to support accurate parsing and analysis of MATLAB source code in tools like linters, formatters, or code transformers.",
      "description_length": 365,
      "index": 206,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Alpha.SQL",
      "library": "comby",
      "description": "This module implements SQL-specific pattern matching operations for finding and extracting structured elements in SQL code. It provides functions to find all matches or the first occurrence of a template in a source string, supporting recursive matching on nested structures. The module works with SQL syntax and is used for tasks like query analysis, schema validation, and automated rewriting of SQL statements.",
      "description_length": 413,
      "index": 207,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Alpha.Dhall",
      "library": "comby",
      "description": "This module provides functions to find all or first matches of a template in Dhall source code, supporting recursive matching and positional starting points. It works with strings for templates and source code, returning lists of matches or error-handled single matches. Use cases include searching for specific Dhall expressions or patterns within configuration files, with optional nested matching and offset control.",
      "description_length": 419,
      "index": 208,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Omega.Matlab",
      "library": "comby",
      "description": "This module provides functions to find all or the first match of a template in MATLAB source code, supporting recursive matching through a configuration flag. It operates on strings representing the template and source code, returning lists of match results or individual match outcomes. Use cases include searching for specific code patterns in MATLAB files, such as identifying function calls or code structures for refactoring.",
      "description_length": 430,
      "index": 209,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Dyck",
      "library": "comby",
      "description": "This module provides configurations for parsing languages with balanced parentheses structures, specifying delimiters, string literals, and comments. It works with syntax trees and pattern matching systems to enforce strict syntactic rules. Use cases include implementing parsers and validators for domain-specific languages requiring precise structural analysis.",
      "description_length": 363,
      "index": 210,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Omega.Ruby",
      "library": "comby",
      "description": "This module provides functions to find all or the first match of a template in Ruby source code, supporting recursive matching on nested structures. It operates on strings for both template and source input, returning lists or individual match results. Use cases include searching for specific Ruby code patterns in files or snippets, such as identifying method calls or syntactic constructs.",
      "description_length": 392,
      "index": 211,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.OCaml",
      "library": "comby",
      "description": "This module provides direct access to predefined metadata like OCaml's name and file extensions, and defines syntax elements such as string delimiters, escape sequences, and comment styles. It works with string literals, file extensions, and syntactic patterns specific to OCaml. Concrete use cases include identifying OCaml files by extension, parsing OCaml code, and supporting tools like linters or syntax highlighters.",
      "description_length": 422,
      "index": 212,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Omega.Dart",
      "library": "comby",
      "description": "This module provides functions to find all or the first matches of a template in a source string, supporting recursive matching and optional configuration. It works with strings as input and returns lists of matches or individual match results. Use cases include parsing and transforming code in languages like Dart, where specific syntactic patterns need to be identified and processed.",
      "description_length": 387,
      "index": 213,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Omega.Zig",
      "library": "comby",
      "description": "This module provides functions to find all or the first matches of a template within a source string, supporting recursive matching when enabled. It works with strings as input and returns lists of matches or individual match results, along with metadata like supported file extensions and language name. It is used for pattern matching in source code, particularly for identifying structural patterns in languages like Zig.",
      "description_length": 424,
      "index": 214,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Omega.Fsharp",
      "library": "comby",
      "description": "This module implements F#-specific pattern matching operations for source code analysis. It provides functions to find all or the first occurrence of a code template within a given source string, supporting recursive matching on nested structures. The module works with string-based templates and sources, returning structured match results with language-specific handling for F#.",
      "description_length": 380,
      "index": 215,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Alpha.JSON",
      "library": "comby",
      "description": "This module implements JSON template matching capabilities for structured source code analysis. It provides operations to find all or the first matching AST nodes between a JSON template and a source code string, supporting recursive matching when enabled. The module works with JSON-formatted abstract syntax trees and string-based source code inputs.",
      "description_length": 352,
      "index": 216,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Languages.Xml",
      "library": "comby",
      "description": "This module provides precise syntax definitions and metadata for XML processing, including delimiters, literals, and comment structures. It works with XML documents and fragments, supporting operations like parsing, transformation, and syntax-aware processing. Use it for handling XML-specific syntax features such as tags, attributes, and text content in structured document manipulation tasks.",
      "description_length": 395,
      "index": 217,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Languages.Fsharp",
      "library": "comby",
      "description": "This module provides metadata and syntax configurations specific to the F# language. It includes the language name, file extensions, delimiters, string literals, and comment kinds. Use it to accurately parse, analyze, or transform F# code based on its syntactic structure.",
      "description_length": 272,
      "index": 218,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Omega.C_nested_comments",
      "library": "comby",
      "description": "This module provides functions to match templates within C-style nested comments in source code. It supports finding all matches recursively or the first match starting at a specific position, operating on strings for both template and source input. Use cases include identifying and extracting patterns within C, C++, or similar language comments during code analysis or transformation tasks.",
      "description_length": 393,
      "index": 219,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Omega.OCaml",
      "library": "comby",
      "description": "This module provides functions to find all or the first matches of a template within a source string, supporting recursive matching on nested content. It operates on strings as input and returns structured match results, with support for configuration and positional control. Use cases include pattern-based code analysis and transformation tasks where precise matching in source code is required.",
      "description_length": 397,
      "index": 220,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Alpha.Solidity",
      "library": "comby",
      "description": "This module provides functions to find all or the first matches of a template in Solidity source code, supporting recursive matching on nested content. It works with strings for templates and source code, returning lists of matches or individual match results. Use cases include searching for specific code patterns in Solidity files, such as function definitions or variable declarations, with optional configuration and file context.",
      "description_length": 435,
      "index": 221,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Alpha.Rust",
      "library": "comby",
      "description": "This module implements Rust-specific pattern matching operations for source code analysis, supporting template-based matching with configurable recursion. It operates on string inputs representing source code and templates, producing lists of match results or individual match outcomes. Use cases include finding all instances of a code pattern in a Rust file or identifying the first occurrence starting at a specific position.",
      "description_length": 428,
      "index": 222,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Languages.Solidity",
      "library": "comby",
      "description": "This module provides metadata and syntax definitions for the Solidity programming language. It includes the language name, file extensions, string literals, delimiters, and comment styles. Use it to identify Solidity files by extension or process Solidity code with precise syntax handling.",
      "description_length": 290,
      "index": 223,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Alpha.Elm",
      "library": "comby",
      "description": "This module provides functions to find all or the first matches of a template in a source string, supporting recursive matching and optional configuration. It works with strings as input sources and templates, returning lists of matches or individual match results. Use cases include parsing and transforming code in the Elm programming language by identifying structural patterns in source text.",
      "description_length": 396,
      "index": 224,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.C_nested_comments",
      "library": "comby",
      "description": "This module handles parsing and syntax configuration for languages with nested comments, supporting precise manipulation of comment blocks and string literals. It works with syntax trees and string delimiters to enable tools like linters, formatters, or custom parsers that need to process or transform code with complex nesting structures. Concrete use cases include analyzing C-like code with embedded documentation or implementing syntax-aware code transformations.",
      "description_length": 468,
      "index": 225,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Alpha.Go",
      "library": "comby",
      "description": "This module implements a template-based matcher for the Go programming language, providing functions to find all or the first match of a template within a source string. It operates on strings using Go-specific parsing rules, supporting matches that can optionally recurse into previously matched content. Use cases include code analysis and transformation tasks where precise syntactic matching is required, such as identifying function calls or variable declarations in Go source code.",
      "description_length": 487,
      "index": 226,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Clojure",
      "library": "comby",
      "description": "This module provides metadata and syntax definitions for working with Clojure code. It includes file extensions for Clojure source files and specifies syntax elements like string delimiters, escape characters, and comment styles. Use it to identify Clojure files by extension or to enable accurate parsing and transformation of Clojure code in tools like linters or formatters.",
      "description_length": 377,
      "index": 227,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Alpha.Zig",
      "library": "comby",
      "description": "This module implements a template matcher for Zig source code, providing operations to find all or the first match of a template within a source string. It works with string inputs representing code templates and source files, returning structured match results. Use cases include pattern-based code analysis and transformation tasks specific to Zig, such as identifying function calls or variable declarations in Zig programs.",
      "description_length": 427,
      "index": 228,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Languages.Move",
      "library": "comby",
      "description": "This module provides metadata and syntax configurations specific to the Move programming language. It includes file extensions for language detection and defines parsing rules such as delimiters, string literals, and comments. These components support tools that perform pattern matching, transformation, and analysis of Move source code.",
      "description_length": 338,
      "index": 229,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Omega.Generic",
      "library": "comby",
      "description": "This module provides functions to find all or the first match of a template in a source string, supporting recursive matching on nested content. It works with strings as input and returns lists of matches or individual match results, along with metadata like the matcher name and supported file extensions. It is used to implement language-specific pattern matching for code transformation and analysis tasks.",
      "description_length": 409,
      "index": 230,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Jsx",
      "library": "comby",
      "description": "This module provides precise parsing and matching capabilities for JSX syntax elements, including delimiters, string literals, and comments. It works with source code structures to enable template-based code transformation and syntax-aware pattern matching. Concrete use cases include analyzing and transforming JSX files based on their structural elements.",
      "description_length": 357,
      "index": 231,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Alpha.Typescript",
      "library": "comby",
      "description": "This module provides functions to find all or first matches of a template in TypeScript source code, supporting recursive matching on nested content. It operates on strings for both template and source code, returning lists or individual match results with optional configuration and file context. Use cases include code analysis, refactoring tools, and static pattern detection in TypeScript files.",
      "description_length": 399,
      "index": 232,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Languages.Haskell",
      "library": "comby",
      "description": "This module provides concrete definitions for Haskell's file extensions and syntax elements. It includes data types for identifying Haskell source files and specifying syntactic constructs like comments, strings, and delimiters. Use it to build tools that require precise Haskell language handling, such as parsers, linters, or code transformation utilities.",
      "description_length": 358,
      "index": 233,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Fortran",
      "library": "comby",
      "description": "This module provides metadata and syntax definitions for Fortran, including language name, file extensions, string delimiters, and comment styles. It supports operations like identifying Fortran source files and configuring syntax-aware tools for parsing and transformation. Concrete use cases include setting up code matchers and enabling language-specific handling in transformation pipelines.",
      "description_length": 395,
      "index": 234,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Alpha.Erlang",
      "library": "comby",
      "description": "This module provides functions to match Erlang source code against templates, returning all matches or the first match with optional starting position. It operates on strings representing Erlang code and supports recursive matching when enabled. Use cases include code analysis and transformation tasks specific to Erlang, such as finding function calls or patterns in Erlang modules.",
      "description_length": 384,
      "index": 235,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Omega.Php",
      "library": "comby",
      "description": "This module provides functions to find all or the first matches of a template in PHP source code, supporting recursive matching on nested structures. It operates on strings representing templates and source code, returning lists of match results or individual match outcomes. Use cases include code analysis and transformation tasks where specific PHP syntax patterns need to be identified.",
      "description_length": 390,
      "index": 236,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Omega.SQL",
      "library": "comby",
      "description": "This module provides functions to match SQL templates against source code, returning all matches or the first match with optional offset. It operates on strings for both template and source input, and supports recursive matching through a configuration flag. The module identifies itself with a name and lists associated file extensions for SQL files.",
      "description_length": 351,
      "index": 237,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Alpha.R",
      "library": "comby",
      "description": "This module provides functions to find all or the first matches of a template in a source string, supporting nested matching and language-specific configurations. It works with strings as input and returns lists of matches or individual match results, along with metadata like supported file extensions and language name. It is used to implement template-based code matching and analysis for specific programming languages.",
      "description_length": 423,
      "index": 238,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Omega.Elm",
      "library": "comby",
      "description": "This module provides functions to find all or the first matches of a template in a source string, supporting recursive matching when enabled. It works with strings as input and returns lists of matches or individual match results. Use cases include pattern matching in code files where specific syntax structures need to be identified, such as finding function calls or variable declarations in Elm source code.",
      "description_length": 411,
      "index": 239,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Javascript",
      "library": "comby",
      "description": "This module provides operations for identifying JavaScript files by extension and defining JavaScript-specific syntax elements such as delimiters, string literals, and comments. It works with string and list data types to represent file extensions and syntactic patterns. Concrete use cases include configuring code analysis tools to recognize JavaScript files and parsing JavaScript code structures for transformation or inspection.",
      "description_length": 433,
      "index": 240,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Omega.Html",
      "library": "comby",
      "description": "This module provides functions to match HTML templates against source code, returning all matches or the first match with optional configuration and file context. It works with strings as input templates and sources, producing lists of match results or individual match outcomes. Use cases include extracting specific HTML patterns from web documents or identifying structural elements in HTML files for transformation.",
      "description_length": 419,
      "index": 241,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Text",
      "library": "comby",
      "description": "This module provides functions to define and configure text-based language metadata and syntax rules. It works with strings and lists to specify file extensions, delimiters, string literals, and comment styles. Use it to customize text processing for specific programming languages or domain-specific formats, such as configuring parsers or syntax highlighters.",
      "description_length": 361,
      "index": 242,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Omega.Bash",
      "library": "comby",
      "description": "This module provides functions to match templates against Bash source code, returning all matches or the first match based on provided configuration. It operates on strings representing templates and source code, and returns structured match results. It is used for analyzing or transforming Bash scripts by identifying specific syntactic patterns.",
      "description_length": 348,
      "index": 243,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Alpha.OCaml",
      "library": "comby",
      "description": "This module implements template-based matching for OCaml code, providing functions to find all matches or the first match of a given template within a source string. It operates on OCaml abstract syntax trees, supporting recursive matching when enabled, and is used for tasks like code transformation and static analysis. The module identifies matches with precise positional information, enabling targeted modifications in refactoring tools or linters.",
      "description_length": 453,
      "index": 244,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Alpha.Text",
      "library": "comby",
      "description": "This module implements text-based pattern matching for source code using a declarative template language. It provides functions to find all matches or the first match of a template in a source string, with support for recursive matching on results. The module works directly with string inputs and outputs structured match results, making it suitable for code analysis and transformation tasks.",
      "description_length": 394,
      "index": 245,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Omega.Javascript",
      "library": "comby",
      "description": "This module provides functions to find all or the first matches of a template in JavaScript source code, supporting recursive matching on nested structures. It operates on strings for both template and source code, returning lists or individual match results. Use cases include code analysis and transformation tasks where specific JavaScript patterns need to be identified.",
      "description_length": 374,
      "index": 246,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.C",
      "library": "comby",
      "description": "This module provides operations to retrieve metadata about the C programming language, such as its name and common file extensions, and defines syntax configurations for parsing C code, including string literals, comments, and delimiters. It works with string and list data types to represent and process C-specific syntax elements. Concrete use cases include language detection based on file extensions and configuring parsers to correctly handle C code structure.",
      "description_length": 465,
      "index": 247,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Alpha.Coq",
      "library": "comby",
      "description": "This module implements template-based matching for Coq code, providing functions to find all matches or the first match of a given template within a source string. It operates on Coq syntax trees, supporting recursive matching when enabled, and includes metadata like the language name and supported file extensions. It is used to perform structural searches in Coq files, enabling tasks like automated code transformation and static analysis.",
      "description_length": 443,
      "index": 248,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Omega.C",
      "library": "comby",
      "description": "This module provides functions to find all or the first matches of a template in C source code, supporting recursive matching through a configuration flag. It operates on strings for both template and source input, returning lists of match results or individual match results with optional positional shifting. Use cases include searching for specific code patterns in C files, such as function calls or variable declarations, while optionally controlling recursion behavior.",
      "description_length": 475,
      "index": 249,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Alpha.CSS",
      "library": "comby",
      "description": "This module implements CSS-specific pattern matching operations for source code analysis, supporting template-based matching with configurable recursion. It processes string templates against CSS source content, returning structured match results with positional information. Key use cases include finding style rule matches in CSS files for refactoring or static analysis tasks.",
      "description_length": 379,
      "index": 250,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Dhall",
      "library": "comby",
      "description": "This module provides metadata about the Dhall configuration language, including its name and file extensions. It supports operations to identify Dhall files based on extension or language name. Concrete use cases include tooling that needs to detect or categorize Dhall files during processing or analysis.",
      "description_length": 306,
      "index": 251,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Template.Make",
      "library": "comby",
      "description": "Parses string templates into structured representations and extracts variable syntax occurrences from strings. Works with `Comby.Matchers.Template.t` and `Comby.Matchers.Template.syntax` types. Used to process and analyze templates containing placeholders for substitution or pattern matching.",
      "description_length": 293,
      "index": 252,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Erlang",
      "library": "comby",
      "description": "This module provides metadata and syntax definitions for the Erlang language. It includes file extensions, language name, string literals, delimiters, and comment patterns. It supports tools that need to identify Erlang files or parse Erlang code accurately, such as linters, formatters, or source analysis utilities.",
      "description_length": 317,
      "index": 253,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.HCL",
      "library": "comby",
      "description": "This module provides operations for identifying HCL files via extensions and handling their syntax elements, such as delimiters, string literals, and comments. It works with string-based patterns and metadata structures to support parsing and transformation tasks. Concrete use cases include matching HCL configuration constructs and determining file types during infrastructure code analysis.",
      "description_length": 393,
      "index": 254,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Omega.Erlang",
      "library": "comby",
      "description": "This module provides functions to find all or the first structural matches of a template in Erlang source code, returning detailed match information. It operates on strings representing Erlang code and templates, with support for nested matching and positional starting points. Use cases include code analysis and transformation tasks specific to Erlang, such as identifying function calls or syntactic patterns in source files.",
      "description_length": 428,
      "index": 255,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Omega.Dhall",
      "library": "comby",
      "description": "This module provides functions to match templates against Dhall source code, returning all matches or the first match with optional offset. It operates on strings representing templates and source code, producing lists of match results or error-handled single matches. Use cases include finding configuration patterns or specific expressions in Dhall files during analysis or transformation tasks.",
      "description_length": 397,
      "index": 256,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Alpha.C_nested_comments",
      "library": "comby",
      "description": "This module provides functions to match templates within C source code, specifically handling nested comments. It operates on strings representing source code and templates, returning lists of matches or the first match based on configuration and starting position. Use cases include searching for patterns in C files while respecting comment boundaries, such as identifying specific function calls or code structures within commented-out sections.",
      "description_length": 448,
      "index": 257,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Alpha.Make",
      "library": "comby",
      "description": "This module implements template-based matching for structured text, providing operations to find all or the first match of a template within a source string. It works with string inputs and produces lists or individual `Comby.match'` values, which capture matched regions and their structure. It is used to perform precise pattern matching over code or structured documents, leveraging a configured matcher implementation.",
      "description_length": 422,
      "index": 258,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Tsx",
      "library": "comby",
      "description": "This module provides direct access to TSX language metadata, including file extensions and syntax configuration for JSX-like parsing. It defines delimiters for embedded expressions, string literals, and comment styles used in TSX. Concrete use cases include code analysis tools and transformers that need to accurately parse and match patterns in TypeScript files with React syntax.",
      "description_length": 382,
      "index": 259,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Alpha.Nim",
      "library": "comby",
      "description": "This module provides functions to find all or the first occurrences of a template in a source string, supporting recursive matching and language-specific configuration. It operates on strings as input and returns structured match results, with support for specifying file extensions and language names. Use cases include parsing and transforming code in the Nim language by matching patterns in source files.",
      "description_length": 408,
      "index": 260,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Alpha.Move",
      "library": "comby",
      "description": "This module provides functions to find all or first matches of a template in a source string, supporting recursive matching and optional configuration. It works with strings as input and outputs lists of matches or individual match results. Use cases include pattern matching in code files where specific syntax structures need to be identified, such as finding function calls or variable declarations in source code during refactoring.",
      "description_length": 436,
      "index": 261,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Alpha.Fortran",
      "library": "comby",
      "description": "This module implements template-based matching for Fortran code, supporting operations to find all or the first match of a given template within a source string. It works with Fortran syntax and leverages configuration options to control matching behavior, such as whether to recurse into matched content. Use cases include automated code analysis and transformation tasks specific to Fortran, such as identifying and rewriting specific language constructs in source files.",
      "description_length": 473,
      "index": 262,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Omega.Lisp",
      "library": "comby",
      "description": "This module provides functions to find all or the first matches of a template in a source string, supporting recursive matching when enabled. It works with strings as input and returns lists of matches or individual match results. Use cases include searching for patterns in Lisp code, such as identifying function definitions or expressions, while supporting language-specific configuration and file context.",
      "description_length": 409,
      "index": 263,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Alpha.Haskell",
      "library": "comby",
      "description": "This module implements template-based matching for Haskell code, providing functions to find all or the first match of a template within a source string. It operates on strings representing Haskell code and templates, returning structured match results with optional recursive matching. Use cases include code analysis and transformation tasks specific to Haskell, such as identifying function definitions or syntactic patterns in source files.",
      "description_length": 444,
      "index": 264,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Omega.GraphQL",
      "library": "comby",
      "description": "This module implements GraphQL query matching for source code analysis. It provides operations to find all matches or the first match of a template in a source string, supporting recursive matching through the `nested` flag. The module works with string-based templates and sources, returning match results as structured data. Use cases include static analysis and code transformation tasks for GraphQL APIs.",
      "description_length": 408,
      "index": 265,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Omega.CSS",
      "library": "comby",
      "description": "This module provides functions to match CSS templates against source code, returning all matches or the first match starting at a specified position. It works with strings as input sources and templates, and returns structured match results. It supports recursive matching on nested content and is used for analyzing or transforming CSS code through pattern matching.",
      "description_length": 367,
      "index": 266,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Alpha.Matlab",
      "library": "comby",
      "description": "This module implements template-based matching for MATLAB source code, supporting operations to find all or the first match of a given template within a source string. It works with strings as input and output, along with configuration options like file path, matching rules, and nested matching behavior. It is used for structural code analysis and transformation tasks specific to MATLAB files.",
      "description_length": 396,
      "index": 267,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Alpha.Clojure",
      "library": "comby",
      "description": "This module implements template-based matching for Clojure code, providing functions to find all matches or the first match of a template within a source string. It operates on strings representing Clojure syntax, supporting recursive matching when enabled, and returns structured match results. Use cases include code analysis, transformation, and refactoring tasks specific to Clojure.",
      "description_length": 387,
      "index": 268,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Omega.Go",
      "library": "comby",
      "description": "This module provides functions to find all or the first matches of a template in a source string, supporting recursive matching when enabled. It works with strings as input and returns lists of matches or individual match results, along with metadata like supported file extensions and language name. It is used for pattern matching in source code, particularly for Go, enabling precise matching and potential rewriting based on templates.",
      "description_length": 439,
      "index": 269,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Omega.Coq",
      "library": "comby",
      "description": "This module implements template-based matching for source code, providing functions to find all or the first match of a given template within a source string. It operates on strings representing code and templates, returning structured match results with support for nested matching. It is used for tasks like code analysis and transformation where specific syntactic patterns need to be identified in source files.",
      "description_length": 415,
      "index": 270,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Alpha.Fsharp",
      "library": "comby",
      "description": "This module implements F# language-specific pattern matching operations for source code analysis. It provides functions to find all or first matches of a template in a source string, with support for nested matching, and exposes metadata like the language name and file extensions. The module works directly with F# syntax trees to enable precise structural queries for tasks like code refactoring or static analysis.",
      "description_length": 417,
      "index": 271,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Omega.Java",
      "library": "comby",
      "description": "This module provides functions to find all or first matches of a template in Java source code, supporting recursive matching through a configuration flag. It operates on strings for both template and source input, returning lists of matches or individual match results with error handling. Use cases include searching for specific code patterns in Java files, such as identifying method calls or code structures, based on file extensions and configuration settings.",
      "description_length": 465,
      "index": 272,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Rust",
      "library": "comby",
      "description": "This module provides direct access to Rust language metadata, including its name and common file extensions like `.rs`. It defines syntax-specific configurations such as delimiters, string literals, and comment styles used for accurate parsing and transformation of Rust code. Concrete use cases include tooling support for code formatters, linters, and source analysis specific to Rust.",
      "description_length": 387,
      "index": 273,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Language.Syntax",
      "library": "comby",
      "description": "This module defines data structures and types that represent syntactic elements of programming languages, such as string literals, escape characters, and comment formats. It includes operations for converting these syntax definitions to and from JSON format, enabling configuration and interchange. Concrete use cases include specifying language-specific syntax rules for code matching and transformation tools.",
      "description_length": 411,
      "index": 274,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.JSON",
      "library": "comby",
      "description": "This module provides operations for identifying JSON files through extensions and defining syntax rules for parsing JSON content. It works with string lists for file extensions and syntax configurations like delimiters, string literals, and comment styles. Concrete use cases include setting up JSON-aware tooling and customizing parsers for different JSON dialects.",
      "description_length": 366,
      "index": 275,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Omega.Assembly",
      "library": "comby",
      "description": "This module performs structural matching of code templates against source code, returning detailed match information. It supports finding all matches or the first match at a given position, with optional recursive matching on results. The module works with string-based templates and source code, and provides metadata like language name and file extensions for integration with code analysis tools.",
      "description_length": 399,
      "index": 276,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Omega.Nim",
      "library": "comby",
      "description": "This module implements template-based matching for source code, providing functions to find all or the first match of a given template within a source string. It operates on strings representing code and templates, returning structured match results with support for nested matching. It is used for tasks like code transformation and pattern extraction in specific programming languages.",
      "description_length": 387,
      "index": 277,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Alpha.Dyck",
      "library": "comby",
      "description": "This module implements Dyck language matching for structured code patterns, supporting operations to find all or first matches of a template within a source string. It works with string-based templates and sources, returning lists or individual match records with positional and contextual details. It is used to identify nested or recursive language constructs in code, such as matching balanced parentheses or structured control flow blocks in specific programming languages.",
      "description_length": 477,
      "index": 278,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Match.Location",
      "library": "comby",
      "description": "This module defines a data structure for representing positions in text, with fields for byte offset, line number, and column number. It includes functions for equality checking, serialization to and from S-expressions and JSON, and a default value for initializing locations. This module is used to track and compare positions in source code during parsing or transformation tasks.",
      "description_length": 382,
      "index": 279,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Template",
      "library": "comby",
      "description": "This module represents and serializes template syntax for pattern matching, supporting structured placeholders with specific kinds like variable names, offsets, line/column positions, and casing transformations. It works with algebraic data types encoding template atoms as either holes with metadata or string constants, organized into lists representing full templates. Concrete use cases include parsing and manipulating code templates with precise positional and structural information during rewriting or analysis tasks.",
      "description_length": 525,
      "index": 280,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Metasyntax",
      "library": "comby",
      "description": "This module defines the syntax rules for recognizing and handling holes in pattern templates, including delimiters, reserved identifiers, and regex patterns. It works with strings and structured syntax definitions to specify how placeholders should be matched in text. Concrete use cases include configuring parsers to identify and process metavariables in code templates or structured documents.",
      "description_length": 396,
      "index": 281,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Languages",
      "library": "comby",
      "description": "The module defines language-specific metadata and syntax configurations\u2014such as delimiters, comment styles, and file extensions\u2014for a wide range of programming and markup languages including JSON, Rust, LaTeX, and SQL. It operates on string and list data types to enable precise parsing, analysis, and transformation of source code by tools like linters, formatters, and refactoring utilities. Specific use cases include identifying files by extension, extracting syntactic elements (e.g., strings, comments), and supporting language-aware code processing workflows.",
      "description_length": 566,
      "index": 282,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Language",
      "library": "comby",
      "description": "Defines language-specific syntax elements like string literals, escape sequences, and comments, with support for JSON serialization. Provides data structures and operations to configure and exchange syntax rules for code matching and transformation tasks. Used to specify how different programming languages should be parsed and processed in pattern matching workflows.",
      "description_length": 369,
      "index": 283,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Rule",
      "library": "comby",
      "description": "This module processes match rules defined as lists of expressions, supporting operations to create, serialize, and apply rules for pattern matching. It handles rule evaluation with options for nested matching, substitution behavior, and external handlers, returning results that indicate satisfaction and captured environments. Use cases include defining and applying structured rewrite rules over source code or text, with control over variable binding and template expansion during matching.",
      "description_length": 493,
      "index": 284,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Configuration",
      "library": "comby",
      "description": "This module defines configuration parameters that control matching behavior, such as substring matching, whitespace sensitivity, and newline handling. It works with the `t` type representing a configuration state and the `match_kind` type distinguishing between exact and fuzzy matching. Concrete use cases include customizing how patterns are matched in structured text, such as code or documents, when default behavior needs adjustment for specific parsing scenarios.",
      "description_length": 469,
      "index": 285,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Engine",
      "library": "comby",
      "description": "This module implements a matching engine for structural code patterns, providing functions to find and bind variables in source code trees. It operates on abstract syntax trees (ASTs) and pattern definitions, enabling precise code analysis and transformation tasks. Concrete use cases include code refactoring, static analysis, and automated code search with variable capture.",
      "description_length": 376,
      "index": 286,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Match.Range",
      "library": "comby",
      "description": "This module defines a range structure with start and end locations, providing equality checks, serialization to and from S-expressions and JSON, and a default value. It works with location data types to represent positional information in text processing tasks. Concrete use cases include tracking match positions in source code analysis and enabling precise range comparisons during parsing or transformation workflows.",
      "description_length": 420,
      "index": 287,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Match.Environment",
      "library": "comby",
      "description": "This module manages mappings of metavariables to values and their associated ranges within a match environment. It supports operations to add, update, and look up metavariables, as well as merge environments, compare them, and serialize to or from JSON. Use cases include tracking variable bindings during pattern matching and preserving positional information for code transformations.",
      "description_length": 386,
      "index": 288,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.External",
      "library": "comby",
      "description": "This module defines a handler for executing external match and substitution operations in Comby's pattern matching system. It works with structured data like abstract syntax trees (ASTs) and string-based patterns to perform precise code transformations. It is used during the execution phase of Comby rules to apply structural edits to matched code elements.",
      "description_length": 358,
      "index": 289,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Omega",
      "library": "comby",
      "description": "This module enables template-driven structural pattern matching across programming languages, markup formats, and domain-specific grammars, offering operations to locate hierarchical matches (`all`, `first`) in textual input while preserving nested structures. It supports recursive syntax analysis for languages like Lisp, JSON, and LaTeX, as well as code transformation tasks requiring precise pattern extraction and configurable matcher selection based on syntax or file extensions. Use cases include refactoring source code, validating nested data formats, and extracting structured metadata from domain-specific constructs.",
      "description_length": 628,
      "index": 290,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Rewrite",
      "library": "comby",
      "description": "This module handles template-based code rewriting using match environments. It provides `all` to apply a rewrite template across multiple matches in a source string, producing modified results with optional in-place substitution, and `substitute` to replace variables in a template string using a single match environment. It operates on match lists and environments from the `Comby` module, enabling concrete transformations like generating updated code snippets from matched patterns.",
      "description_length": 486,
      "index": 291,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Matcher",
      "library": "comby",
      "description": "This module implements pattern matching and substitution operations over abstract syntax trees (ASTs). It works with tree structures represented as algebraic data types, enabling precise traversal and transformation based on defined patterns. Concrete use cases include code refactoring tools and static analysis passes that require structural matching of program elements.",
      "description_length": 373,
      "index": 292,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Hole",
      "library": "comby",
      "description": "This module defines a type `sort` that represents different kinds of holes used in pattern matching, such as `Expression`, `Alphanum`, and `Regex`. Each variant specifies a particular matching behavior for placeholders in code transformation rules. It is used to control how fragments of code are matched and replaced in structured editing or refactoring tools.",
      "description_length": 361,
      "index": 293,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Specification",
      "library": "comby",
      "description": "This module defines a specification for matching and rewriting code patterns using templates and optional rules. It works with strings as match and rewrite templates, alongside optional rule applications. Use it to create structured match-rewrite operations for code transformations.",
      "description_length": 283,
      "index": 294,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Ast",
      "library": "comby",
      "description": "This module defines an abstract syntax tree (AST) for representing rules with atoms, logical expressions, and transformation operations. It supports data types like `atom`, `antecedent`, and `expression`, enabling structured pattern matching and rewriting logic. Concrete use cases include parsing and manipulating rule-based transformations, such as code refactoring or template-based text manipulation, where logical conditions and structured rewriting are required.",
      "description_length": 468,
      "index": 295,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Pipeline",
      "library": "comby",
      "description": "This module runs matchers and generates replacements for input sources like file paths or strings. It supports operations such as executing a matcher with customizable timeouts, metasyntax, and substitution behavior, returning matches or rewritten output. Use it to process code transformations with precise control over matching and rewriting parameters.",
      "description_length": 355,
      "index": 296,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Match",
      "library": "comby",
      "description": "This module processes pattern matches in source code, capturing matched text, associated ranges, and metavariable bindings. It supports precise text analysis and transformation tasks by providing structured match results with positional data. Key operations include match creation, offset conversion for line/column info, and formatted output in grep or JSON styles.",
      "description_length": 366,
      "index": 297,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Replacement",
      "library": "comby",
      "description": "This module represents the outcome of a rewrite operation, capturing the range of text replaced, the new content, and contextual matching information. It provides functions to serialize and deserialize replacement data to and from JSON, along with constructing JSON output that includes rewritten source and substitution details. It is used to record and communicate the specific changes made during source code transformations.",
      "description_length": 428,
      "index": 298,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers",
      "library": "comby",
      "description": "This module implements structural pattern matching and code transformation workflows using abstract syntax trees, templates, and rule-based specifications. It provides operations for parsing and applying match-rewrite rules with support for language-specific syntax, metavariables, and external handlers. Concrete use cases include automated code refactoring, static analysis of structured text, and template-driven rewriting of source code across multiple programming languages.",
      "description_length": 479,
      "index": 299,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby",
      "library": "comby",
      "description": "This module performs structural pattern matching and code transformations on source code using abstract syntax trees, templates, and rule-based specifications. It captures detailed match and replacement data, including ranges, metavariables, and rewritten content, supporting precise analysis and modification of code across multiple languages. Use it to automate refactoring, enforce coding standards, or extract structured data from source files.",
      "description_length": 448,
      "index": 300,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Patdiff_kernel.Format.Style.Set.Tree.Named",
      "library": "comby.patdiff_kernel",
      "description": "This module defines operations for comparing and validating named style sets used in diff formatting. It works with named tree structures that represent sets of formatting styles, such as prefixes and suffixes. It supports checking whether one style set is a subset of another and determining equality between two style sets.",
      "description_length": 325,
      "index": 301,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Patdiff_kernel.Format.Color.Set.Tree.Named",
      "library": "comby.patdiff_kernel",
      "description": "This module defines operations for comparing and validating named color sets used in diff formatting. It works with the `named` type representing structured color configurations. Concrete use cases include checking if one named color set is a subset of another and verifying equality between two named color sets.",
      "description_length": 313,
      "index": 302,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Patdiff_kernel.Format.Color.Map.Tree.Provide_of_sexp",
      "library": "comby.patdiff_kernel",
      "description": "This module provides a function `t_of_sexp` that constructs a `Patdiff_kernel.Format.Color.Map.Tree.t` from an S-expression, using a provided conversion function for the key type. It operates on S-expressions and produces a tree structure mapping keys (of type `'a__001_`) to formatting information. This supports parsing configuration or state data directly into a structured format used for diff rendering.",
      "description_length": 408,
      "index": 303,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Patdiff_kernel.Format.Style.Set.Tree.Provide_of_sexp",
      "library": "comby.patdiff_kernel",
      "description": "Converts S-expressions into styled tree structures for formatting diffs, specifically handling the internal representation of prefixes, suffixes, and styles. It operates on Sexp.t values and produces trees that represent structured formatting rules. This function is used when parsing configuration or input data that defines how diffs should be rendered with specific styles applied to different elements.",
      "description_length": 406,
      "index": 304,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Patdiff_kernel.Format.Color.Set.Tree.Provide_of_sexp",
      "library": "comby.patdiff_kernel",
      "description": "Converts S-expressions into colored diff format trees, specifically parsing input into structured format directives for terminal color rendering. Works with `Patdiff_kernel.Format.Color.Set.Tree.t` values, which represent hierarchical formatting rules with color annotations. Useful for deserializing configuration files or external representations of styled diff output into executable formatting instructions.",
      "description_length": 411,
      "index": 305,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Patdiff_kernel.Format.Style.Map.Tree.Provide_of_sexp",
      "library": "comby.patdiff_kernel",
      "description": "This module provides a function `t_of_sexp` that constructs a styled tree map from S-expression data, using a provided conversion function. It operates on S-expressions and produces values of a specific tree structure used for formatting diffs. A concrete use case is parsing configuration data for diff formatting styles from S-expressions into an internal tree representation.",
      "description_length": 378,
      "index": 306,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Patdiff_kernel.Format.Color.Set.Provide_hash",
      "library": "comby.patdiff_kernel",
      "description": "This module implements hash functions for sets of color formatting elements used in diff output. It provides `hash_fold_t` and `hash` operations to compute hash values for color sets. A concrete use case is enabling structural comparison of color configurations during diff generation.",
      "description_length": 285,
      "index": 307,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Patdiff_kernel.Format.Style.Map.Key",
      "library": "comby.patdiff_kernel",
      "description": "This module defines keys for a map based on formatting styles, supporting conversion to and from S-expressions and providing a comparator for ordered key operations. It works with `Patdiff_kernel.Format.Style.t` and leverages `Sexplib0__.Sexp.t` for serialization. Concrete use cases include managing and comparing different formatting styles within a diffing system.",
      "description_length": 367,
      "index": 308,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Patdiff_kernel.Format.Style.Map.Provide_bin_io",
      "library": "comby.patdiff_kernel",
      "description": "This module implements binary serialization and deserialization for maps that associate keys with formatting styles used in diff output. It supports reading and writing these maps in binary format, enabling efficient storage and transmission of style configurations. Concrete use cases include persisting diff formatting rules to disk or sending them over a network connection.",
      "description_length": 377,
      "index": 309,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Patdiff_kernel.Format.Color.Map.Provide_of_sexp",
      "library": "comby.patdiff_kernel",
      "description": "This module provides a function `t_of_sexp` that constructs a color map from S-expressions, using a provided conversion function for values. It operates on S-expressions and produces mappings from keys (defined by the parameter module `Key`) to formatted color values. A concrete use case is parsing color configuration data from files or external input into a structured format for diff rendering.",
      "description_length": 398,
      "index": 310,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Patdiff_kernel.Format.Color.Set.Named",
      "library": "comby.patdiff_kernel",
      "description": "This module defines operations for comparing and validating named color sets used in formatting diffs. It provides functions to check if one named color set is a subset of another and to test equality between two named color sets. These operations are used to ensure consistent and valid color configurations when applying styles to diff output.",
      "description_length": 345,
      "index": 311,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Patdiff_kernel.Format.Style.Set.Named",
      "library": "comby.patdiff_kernel",
      "description": "This module manages named sets of formatting styles, supporting operations to check if one named style set is a subset of another and to compare named style sets for equality. It works with the `Patdiff_kernel.Format.Style.Set.named` type, which represents predefined formatting configurations. Concrete use cases include validating that a requested style set is fully contained within a supported set and ensuring two style definitions are identical for consistent diff rendering.",
      "description_length": 481,
      "index": 312,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Patdiff_kernel.Format.Style.Set.Provide_of_sexp",
      "library": "comby.patdiff_kernel",
      "description": "Converts S-expressions into style sets for formatting diffs, specifically handling the parsing of valid styles used in diff output. Works with `Patdiff_kernel.Format.Style.Set.t` and `Elt`-defined elements representing individual styles. Useful for configuring diff formatting options from serialized S-expression data, such as reading configuration files or command-line arguments.",
      "description_length": 382,
      "index": 313,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Patdiff_kernel.Format.Style.Set.Elt",
      "library": "comby.patdiff_kernel",
      "description": "This module represents individual elements of a set used to manage formatting styles in a diffing context. It provides operations for converting values to and from S-expressions and defines a comparator for ordering elements. It is used to handle distinct style configurations when generating formatted diffs.",
      "description_length": 309,
      "index": 314,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Patdiff_kernel.Html_output.Private.Make.Rule",
      "library": "comby.patdiff_kernel",
      "description": "This module defines functions to generate styled HTML output for diff hunks using a customizable rule-based formatting system. It operates on diff data structures and applies styling based on whether the output is refined or not. It is used to produce visually distinct HTML representations of text differences in a structured and configurable way.",
      "description_length": 348,
      "index": 315,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Patdiff_kernel.Format.Color.Map.Key",
      "library": "comby.patdiff_kernel",
      "description": "This module defines a key type for maps where keys are values of type `Patdiff_kernel.Format.Color.t`. It includes functions for converting values to and from S-expressions and provides a comparator for ordering keys. It is used to enable map-based lookups and comparisons based on color formatting values in the diff output system.",
      "description_length": 332,
      "index": 316,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Patdiff_kernel.Format.Color.Map.Provide_bin_io",
      "library": "comby.patdiff_kernel",
      "description": "This module provides binary serialization and deserialization functions for maps with keys of type `Key` and values related to color formatting in a diffing context. It supports operations like `bin_write_t`, `bin_read_t`, and their variants, enabling efficient storage and transmission of color mapping data. Concrete use cases include persisting color configuration state or transmitting it across networked systems where structured color formatting data must be reliably encoded and decoded.",
      "description_length": 494,
      "index": 317,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Patdiff_kernel.Format.Color.Set.Elt",
      "library": "comby.patdiff_kernel",
      "description": "This module represents individual elements in a set of colors used for formatting diffs. It includes functions for converting values to and from S-expressions and provides a comparator for ordering elements. It is used when managing sets of distinct color styles for precise formatting control in diff output.",
      "description_length": 309,
      "index": 318,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Patdiff_kernel.Format.Style.Map.Provide_hash",
      "library": "comby.patdiff_kernel",
      "description": "This module provides a function `hash_fold_t` for computing hash values over maps with arbitrary keys and values of type `'a`. It supports hashing structured data stored in map containers where keys are defined by the `Key` module. A concrete use case includes generating consistent hash digests of formatted diff structures for comparison or caching.",
      "description_length": 351,
      "index": 319,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Patdiff_kernel.Format.Style.Map.Provide_of_sexp",
      "library": "comby.patdiff_kernel",
      "description": "This module provides a function `t_of_sexp` that constructs a map of formatting styles from S-expressions, using a provided conversion function for values. It operates on S-expressions and produces maps where keys are determined by the `Key` module and values represent formatting styles. A concrete use case is parsing configuration files that define how different parts of a diff should be styled during output.",
      "description_length": 413,
      "index": 320,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Patdiff_kernel.Format.Style.Set.Tree",
      "library": "comby.patdiff_kernel",
      "description": "This module implements ordered tree-based sets of style elements for diff formatting, supporting set-theoretic operations like union and intersection, structural transformations such as splitting and filtering, and ordered traversal with binary search capabilities. It operates on balanced trees of `Patdiff_kernel.Format.Style.Set.Elt.t` elements, enabling efficient membership checks, element selection, and conversion to/from lists, arrays, and S-expressions. Typical use cases include managing hierarchical style configurations, composing and decomposing style sets for differential rendering, and validating style transformations in test scenarios.",
      "description_length": 653,
      "index": 321,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Patdiff_kernel.Format.Color.Set.Provide_bin_io",
      "library": "comby.patdiff_kernel",
      "description": "This module implements binary serialization and deserialization for sets of color formatting elements used in diff output. It provides functions to compute binary size, read and write color sets, and defines the binary shape and type class instances. Concrete use cases include persisting color formatting configurations to disk or transmitting them over a network.",
      "description_length": 365,
      "index": 322,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Patdiff_kernel.Format.Color.Map.Provide_hash",
      "library": "comby.patdiff_kernel",
      "description": "This module provides a function `hash_fold_t` for computing hash values over a map structure that associates keys with color formatting data. It operates on maps where keys are of a specified type and values represent color formatting information used in diff rendering. A concrete use case is enabling efficient hashing of color configuration settings during the formatting phase of a diff computation.",
      "description_length": 403,
      "index": 323,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Patdiff_kernel.Format.Style.Map.Tree",
      "library": "comby.patdiff_kernel",
      "description": "This module implements tree-based maps keyed by `Patdiff_kernel.Format.Style.Map.Key.t`, enabling precise manipulation of ordered key-value associations through operations like insertion, deletion, range queries, and merging with custom logic. It provides robust traversal, transformation, and filtering capabilities\u2014supporting both key-aware and value-based predicates\u2014alongside balanced tree operations for efficient lookup, ranking, and subrange extraction. These tools are optimized for structured data management in scenarios requiring hierarchical organization, such as diff formatting rules with ordered style associations or hierarchical key-value mappings.",
      "description_length": 665,
      "index": 324,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Patdiff_kernel.Format.Color.Set.Provide_of_sexp",
      "library": "comby.patdiff_kernel",
      "description": "Converts S-expressions into color set values, specifically parsing and constructing `Patdiff_kernel.Format.Color.Set.t` instances from sexp input. It operates on the internal representation of color formatting rules used for diffs. This function is useful when loading color configuration from a file or serializing color settings in a structured format.",
      "description_length": 354,
      "index": 325,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Patdiff_kernel.Format.Style.Set.Provide_hash",
      "library": "comby.patdiff_kernel",
      "description": "This module provides hash and hash_fold functions for style sets, enabling efficient hashing of style configurations. It operates on `Patdiff_kernel.Format.Style.Set.t` values, which represent collections of formatting styles. Use this module to compute hash values for style sets when implementing caching or equality checks for diff formatting configurations.",
      "description_length": 361,
      "index": 326,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Patdiff_kernel.Format.Color.Map.Tree",
      "library": "comby.patdiff_kernel",
      "description": "This module provides operations for constructing, transforming, and querying ordered map trees and balanced trees keyed by color formatting specifications, supporting efficient insertion, deletion, iteration, folding, and merging with customizable conflict resolution. It works with immutable tree-based maps that associate `Patdiff_kernel.Format.Color.Map.Key.t` keys to arbitrary values, enabling precise manipulation of color-to-data mappings. Specific use cases include managing hierarchical color configurations for diffs, combining style definitions with error handling, and validating structural invariants during format transformations.",
      "description_length": 644,
      "index": 327,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Patdiff_kernel.Format.Style.Set.Provide_bin_io",
      "library": "comby.patdiff_kernel",
      "description": "This module implements binary serialization and deserialization for sets of formatting styles used in diff output. It provides functions to compute size, read, and write these sets in binary format, specifically handling the internal representation of style sets as defined in the parent module. It is used when persisting or transmitting formatted diff configurations efficiently.",
      "description_length": 381,
      "index": 328,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Patdiff_kernel.Format.Color.Set.Tree",
      "library": "comby.patdiff_kernel",
      "description": "This module enables efficient manipulation of ordered sets of color formatting rules using balanced tree structures. It provides set-theoretic operations (union, intersection, difference), ordered traversal, element selection, and serialization utilities for transforming and analyzing color configuration hierarchies used in diff rendering. The implementation supports structured input conversion from S-expressions and hash tables, with validation and QuickCheck integration for testing complex formatting rule compositions.",
      "description_length": 526,
      "index": 329,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Patdiff_kernel.Format.Color.Set",
      "library": "comby.patdiff_kernel",
      "description": "This module manages collections of color formatting elements, supporting set operations like union, intersection, and difference, along with element queries and ordered traversal via tree-based structures. It provides conversions between sets, lists, arrays, and serialized formats such as S-expressions and binary, facilitating efficient manipulation and storage of color configurations used in diff rendering.",
      "description_length": 411,
      "index": 330,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Patdiff_kernel.Format.Color.RGB6",
      "library": "comby.patdiff_kernel",
      "description": "This module defines operations for working with RGB6 color values, which represent colors using 6-bit red, green, and blue components. It includes functions to create color values with explicit bounds checking, compare colors, and support for generating, observing, and shrinking color values in property-based tests. The module also provides serialization and deserialization to and from S-expressions for persistent storage or configuration purposes.",
      "description_length": 452,
      "index": 331,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Patdiff_kernel.Format.Color.Map",
      "library": "comby.patdiff_kernel",
      "description": "This module provides a suite of operations for constructing, transforming, and querying immutable maps where keys represent color formatting specifications. It supports bulk updates, symmetric diffs, and custom merging logic while ensuring type-safe handling of key-value pairs through dedicated combinators for filtering, folding, and partitioning. The module is particularly suited for managing hierarchical color configuration data in diff rendering pipelines, enabling seamless serialization to S-expressions and binary formats for persistence or inter-process communication.",
      "description_length": 579,
      "index": 332,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Patdiff_kernel.Patdiff_core.Private.Make",
      "library": "comby.patdiff_kernel",
      "description": "This module implements core diffing logic for comparing and formatting text files. It provides functions to compute line-based diffs, refine diffs at the word level, and print or format the results using customizable rules and output styles. Concrete use cases include generating unified diffs between two versions of source code files or text documents.",
      "description_length": 354,
      "index": 333,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Patdiff_kernel.Configuration.Fields.Direct",
      "library": "comby.patdiff_kernel",
      "description": "This module provides operations to iterate over, fold, filter, and convert configuration fields of a diff tool into lists. It works directly with the configuration type and its individual fields, such as output format, diff rules, comparison tolerances, and display options. Concrete use cases include inspecting or transforming specific configuration values, checking conditions across settings, or collecting field values for serialization or analysis.",
      "description_length": 454,
      "index": 334,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Patdiff_kernel.Html_output.Without_mtime.Rule",
      "library": "comby.patdiff_kernel",
      "description": "This module defines how to format and apply styling rules to hunks of text differences when generating HTML output without modification times. It works with `Rule.t` values and string-based content, focusing on rendering styled hunks in a refined or unrefined form. Concrete use cases include generating color-coded HTML representations of text diffs with precise styling control per hunk.",
      "description_length": 389,
      "index": 335,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Patdiff_kernel.Format.Style.Map",
      "library": "comby.patdiff_kernel",
      "description": "This module provides ordered map operations for managing associations between formatting style keys (`Style.Map.Key.t`) and arbitrary values, optimized for structured diff rule organization and transformation. It supports construction from sequences, hashtables, and trees, with duplicate handling via folding or erroring, and enables queries, filtering, and key-dependent transformations. Key use cases include merging style configurations, validating diff formatting invariants, and serializing style maps via S-expressions or binary formats for persistent storage.",
      "description_length": 567,
      "index": 336,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Patdiff_kernel.Html_output.Private.Make",
      "library": "comby.patdiff_kernel",
      "description": "This module generates styled HTML output for diff hunks using a customizable rule-based system. It works with diff hunks, file names, and formatting rules to produce structured HTML representations of text differences. It is used to render visually distinct side-by-side or inline diff views with configurable styling for added, removed, or unchanged lines.",
      "description_length": 357,
      "index": 337,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Patdiff_kernel.Diff_input.Fields.Direct",
      "library": "comby.patdiff_kernel",
      "description": "This module provides operations to traverse, transform, and query fields of a `Patdiff_kernel.Diff_input` value, specifically handling `name` and `text` fields. It supports iteration, folding, filtering, mapping, and bulk field updates, working directly with string-valued fields within the input structure. Concrete use cases include modifying or analyzing the textual components of diff inputs, such as normalizing whitespace or extracting field values for reporting.",
      "description_length": 469,
      "index": 338,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Patdiff_kernel.Format.Color.Replace_polymorphic_compare",
      "library": "comby.patdiff_kernel",
      "description": "This module defines standard comparison operators and functions for the `Color.t` type, enabling direct value comparisons between color instances. It includes equality checks, ordering relations, and utilities to determine minimum and maximum values. These operations are essential for tasks like sorting color-coded diff elements or selecting a canonical color representation in formatting decisions.",
      "description_length": 401,
      "index": 339,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Patdiff_kernel.Format.Style.Replace_polymorphic_compare",
      "library": "comby.patdiff_kernel",
      "description": "This module replaces the polymorphic comparison operators for the `Style.t` type with type-specific comparisons, ensuring correct ordering based on the structure and attributes of formatting styles. It provides standard comparison functions like `=`, `<`, `>`, `compare`, and utilities like `min` and `max` tailored to `Style.t` values. Use this module when comparing or sorting formatting styles based on their defined precedence and attributes.",
      "description_length": 446,
      "index": 340,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Patdiff_kernel.Format.Rule.Affix",
      "library": "comby.patdiff_kernel",
      "description": "This module defines and constructs styled affixes (prefixes or suffixes) used in formatting rules for diffs. It supports creating affixes with associated styles and provides a blank affix value for default styling. Affixes are applied to strings during diff output generation to add contextual markers or styling.",
      "description_length": 313,
      "index": 341,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Patdiff_kernel.Format.Style.Set",
      "library": "comby.patdiff_kernel",
      "description": "This module offers set-theoretic operations like union, intersection, and difference alongside transformations such as mapping, filtering, and folding over ordered collections of style elements. It operates on sets structured as ordered trees, leveraging comparator witnesses to manage elements with precise ordering and validation, while integrating S-expression serialization for configuration persistence. Use cases include managing hierarchical style configurations, validating diff formatting rules, and converting structured data (lists, trees, hash sets) into serializable style sets for storage or transmission.",
      "description_length": 619,
      "index": 342,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Patdiff_kernel.Format.Color.Gray24",
      "library": "comby.patdiff_kernel",
      "description": "This module defines a grayscale color representation using a 24-bit depth, where each color is specified by an integer intensity level. It provides operations to construct a grayscale color with a given intensity, compare two grayscale colors, and serialize or deserialize them using S-expressions. A typical use case is in formatting terminal output with varying shades of gray for visual differentiation in diff displays.",
      "description_length": 423,
      "index": 343,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Patdiff_kernel.Ansi_output.Rule",
      "library": "comby.patdiff_kernel",
      "description": "Applies a formatting rule to a string, using ANSI escape codes to produce colored or styled output. It works with strings and formatting rules defined in the `Format.Rule` module, which specify how different parts of the string should be highlighted. This function is used to generate terminal-friendly diff output with customizable colors and styles for added, removed, or changed text regions.",
      "description_length": 395,
      "index": 344,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Patdiff_kernel.Format.Color",
      "library": "comby.patdiff_kernel",
      "description": "This module provides operations for representing terminal color values across multiple models, including named colors, RGB6, and Gray24, with support for bounded value validation, clamping, and interconversion between formats. It offers structured comparison logic, map/set manipulations for color keys, and utilities to construct or serialize color values while ensuring validity constraints. These capabilities enable precise color management in diff rendering pipelines and formatting workflows requiring robust color model handling.",
      "description_length": 536,
      "index": 345,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Patdiff_kernel.Format.Style",
      "library": "comby.patdiff_kernel",
      "description": "This module defines a type for text styling attributes (e.g., bold, color) used in diff rendering, supporting equality checks, comparisons, validation, and clamping to ensure style consistency. It provides ordered map and set operations for managing style collections, enabling efficient attribute-based comparisons and serialization. These capabilities facilitate precise formatting of diff outputs while maintaining testable and validated style representations.",
      "description_length": 463,
      "index": 346,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Patdiff_kernel.Format.Rule",
      "library": "comby.patdiff_kernel",
      "description": "This module defines formatting rules for diff output, combining styled prefixes, suffixes, and style lists. It supports creating and manipulating rules that are applied to strings during diff rendering, such as adding markers or color codes. Concrete use cases include defining rules for added or removed lines with specific visual styles and prefixes like \"+\" or \"-\".",
      "description_length": 368,
      "index": 347,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Patdiff_kernel.Ascii_output.Rule",
      "library": "comby.patdiff_kernel",
      "description": "Applies a formatting rule to a string, using a specified style and refinement flag to control output appearance. It processes plain text alongside structured format rules to generate styled terminal output. This function is used to render differences with customizable visual markers in command-line interfaces.",
      "description_length": 311,
      "index": 348,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Patdiff_kernel.Configuration.Private",
      "library": "comby.patdiff_kernel",
      "description": "This module includes a deprecated function `with_ext_cmp` that modifies a configuration by setting an external comparison command and a notification callback. It operates on the `Configuration.t` type, which represents settings for diffing operations. Use cases involve customizing diff behavior with external tools, though this function is unsafe and intended for removal.",
      "description_length": 373,
      "index": 349,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Patdiff_kernel.Format.Rules",
      "library": "comby.patdiff_kernel",
      "description": "This module defines a structured set of formatting rules used to control the visual representation of different elements in a diff output. It includes specific fields for styling lines, words, headers, and hunks in both unified and side-by-side diff formats. These rules are used to apply or strip styling during the rendering of diffs, based on configuration settings.",
      "description_length": 369,
      "index": 350,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Patdiff_kernel.Html_output.Without_mtime",
      "library": "comby.patdiff_kernel",
      "description": "This module generates HTML output for text diffs without including modification times, applying styling rules to hunks of differences. It works with file names, hunks, and formatting rules to produce color-coded, styled HTML representations of file changes. A concrete use case is rendering side-by-side HTML diff views with syntax highlighting and custom styling per hunk.",
      "description_length": 373,
      "index": 351,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Patdiff_kernel.Html_output.Private",
      "library": "comby.patdiff_kernel",
      "description": "This module generates styled HTML output for diff hunks using a customizable rule-based system. It works with diff hunks, file names, and formatting rules to produce structured HTML representations of text differences. It is used to render visually distinct side-by-side or inline diff views with configurable styling for added, removed, or unchanged lines.",
      "description_length": 357,
      "index": 352,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Patdiff_kernel.Configuration.Fields",
      "library": "comby.patdiff_kernel",
      "description": "This module defines read-only configuration fields with boolean, integer, string, and enum types to control diffing behaviors like masking unique elements, setting context lines, and adjusting formatting. It provides operations such as accessors, folding, and iteration to enable structured traversal and transformation of configuration values, supporting tasks like programmatically applying formatting rules or analyzing comparison tolerances.",
      "description_length": 445,
      "index": 353,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Patdiff_kernel.Diff_input.Fields",
      "library": "comby.patdiff_kernel",
      "description": "This module directly manipulates the `name` and `text` fields of a `Patdiff_kernel.Diff_input.t` structure, offering operations like mapping, folding, filtering, and bulk transformation. It supports concrete tasks such as normalizing input text, extracting field values for analysis, or updating field contents during diff processing. The functions work explicitly with string-valued fields, enabling precise transformations and queries on those values.",
      "description_length": 453,
      "index": 354,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Patdiff_kernel.Patdiff_core.Without_unix",
      "library": "comby.patdiff_kernel",
      "description": "This module computes and refines line-based diffs between arrays of strings, producing structured hunks that represent additions, deletions, and replacements. It supports configurable formatting, ANSI output iteration, and string serialization of diffs, working directly with file names, diff rules, and output settings. It is used to generate human-readable differences between text files, with control over context size, whitespace handling, and line splitting.",
      "description_length": 463,
      "index": 355,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Patdiff_kernel.Patdiff_core.Private",
      "library": "comby.patdiff_kernel",
      "description": "This module implements core diffing logic for comparing and formatting text files. It provides functions to compute line-based diffs, refine diffs at the word level, and print or format the results using customizable rules and output styles. Concrete use cases include generating unified diffs between two versions of source code files or text documents.",
      "description_length": 354,
      "index": 356,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Patdiff_kernel.Output",
      "library": "comby.patdiff_kernel",
      "description": "This module defines an algebraic data type with three variants\u2014`Ansi`, `Ascii`, and `Html`\u2014representing different output formats. It includes functions for comparing values, converting to and from S-expressions, and determining whether a format implies unrefined output. It is used to configure output behavior in diffing tools that need to support multiple rendering formats.",
      "description_length": 376,
      "index": 357,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Patdiff_kernel.Hunks",
      "library": "comby.patdiff_kernel",
      "description": "This module represents and processes hunks of text differences, typically used for displaying changes between two versions of a file. It provides operations to iterate over hunks and lines, allowing custom handling of hunk boundaries and individual lines. Concrete use cases include formatting and rendering diffs in tools like version control systems or code review interfaces.",
      "description_length": 378,
      "index": 358,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Patdiff_kernel.Ascii_output",
      "library": "comby.patdiff_kernel",
      "description": "This module generates styled ASCII output for displaying file differences in terminal interfaces. It applies formatting rules to hunks of text, using customizable styles and location markers to highlight changes between two files. The `print` function renders the final output using a provided printing function, while the `Rule` submodule processes individual formatting directives.",
      "description_length": 383,
      "index": 359,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Patdiff_kernel.File_name",
      "library": "comby.patdiff_kernel",
      "description": "This module represents file names with support for alternative display names and path manipulation. It provides operations to compare, append paths, and extract real or display names, handling cases where a file may not exist on disk. Concrete use cases include managing file paths in diff tools where display names differ from actual file system paths.",
      "description_length": 353,
      "index": 360,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Patdiff_kernel.Float_tolerance",
      "library": "comby.patdiff_kernel",
      "description": "This module adjusts diff hunks by converting changes in floating-point numbers within a specified percentage tolerance into context lines. It operates on hunks from a patience diff structure and modifies them based on numeric similarity and context line limits. Use it when comparing text files where small floating-point differences should be treated as unchanged.",
      "description_length": 365,
      "index": 361,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Patdiff_kernel.Comparison_result",
      "library": "comby.patdiff_kernel",
      "description": "This module represents the result of comparing two files in a diffing operation, distinguishing between binary equivalence, binary differences, and textual differences captured in hunks. It provides functions to generate a comparison outcome based on configuration and input files, and to check whether there are no differences. It is used to determine how two files differ and whether to display them as text or binary.",
      "description_length": 420,
      "index": 362,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Patdiff_kernel.Format",
      "library": "comby.patdiff_kernel",
      "description": "This module manages formatting for diff output, including colors, text styles, and formatting rules. It works with structured types for color models, style attributes, and rule-based formatting applied to diff elements. Concrete use cases include defining colored prefixes for added or removed lines, styling diff headers and hunks, and applying consistent formatting across side-by-side or unified diff views.",
      "description_length": 410,
      "index": 363,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Patdiff_kernel.Html_output",
      "library": "comby.patdiff_kernel",
      "description": "This module generates styled HTML representations of text diffs using customizable formatting rules, working with diff hunks, file names, and line changes. It supports rendering side-by-side or inline diff views with distinct styling for added, removed, and unchanged content. A specific use case is producing syntax-highlighted HTML diffs for version-controlled files without including modification timestamps.",
      "description_length": 411,
      "index": 364,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Patdiff_kernel.Should_keep_whitespace",
      "library": "comby.patdiff_kernel",
      "description": "Determines whether whitespace should be preserved in diff operations based on input characteristics, such as whether the input resembles Python code. It operates on file-line data pairs or structured diff inputs, analyzing content to detect whitespace sensitivity. Useful when generating diffs for languages where indentation affects semantics, ensuring accurate comparison and display.",
      "description_length": 386,
      "index": 365,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Patdiff_kernel.Patdiff_core",
      "library": "comby.patdiff_kernel",
      "description": "This module implements core diffing logic for comparing and formatting text files. It provides functions to compute line-based diffs, refine diffs at the word level, and print or format the results using customizable rules and output styles. Concrete use cases include generating unified diffs between two versions of source code files or text documents.",
      "description_length": 354,
      "index": 366,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Patdiff_kernel.Ansi_output",
      "library": "comby.patdiff_kernel",
      "description": "Applies ANSI escape codes to format strings according to specified styling rules, working with strings and `Format.Rules` to produce colored, styled terminal output. Used to render diffs with visual indicators for changes, such as additions, deletions, or modifications, using customizable styles for different parts of the output. Handles full diff rendering including headers, file names, and hunks, applying location-specific styling as needed.",
      "description_length": 447,
      "index": 367,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Patdiff_kernel.Configuration",
      "library": "comby.patdiff_kernel",
      "description": "This module provides operations to define, modify, and compare parameters that control diffing behavior, such as context size, line/word-matching thresholds, and output formatting rules. It works with structured configurations composed of boolean flags, numeric thresholds, and formatting directives, enabling precise customization of diff generation. Specific use cases include adjusting sensitivity for change detection, tuning output verbosity, and defining contextual boundaries for aligned differences.",
      "description_length": 507,
      "index": 368,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Patdiff_kernel.Diff_input",
      "library": "comby.patdiff_kernel",
      "description": "This module defines a simple data structure with `name` and `text` string fields, along with accessors to retrieve those values. It supports concrete operations like normalizing input text, extracting field values for analysis, or modifying content during diff processing. The Fields submodule enables direct manipulation of the fields through mapping, folding, and transformation functions.",
      "description_length": 391,
      "index": 369,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Patdiff_kernel.Is_binary",
      "library": "comby.patdiff_kernel",
      "description": "Detects whether a given string represents a binary file by analyzing its content. Uses heuristics to identify non-textual data patterns commonly found in binary formats. Useful for tools that need to skip or handle binary files differently during processing.",
      "description_length": 258,
      "index": 370,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Patdiff_kernel.Import",
      "library": "comby.patdiff_kernel",
      "description": "This module defines function composition operators `(>>)` and `(<<)` that combine two functions sequentially. It works with functions of any types `'a -> 'b` and `'b -> 'c`, producing a composed function `'a -> 'c`. These operators are useful for chaining transformations, such as processing data through multiple stages without intermediate variables.",
      "description_length": 352,
      "index": 371,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Patdiff_kernel",
      "library": "comby.patdiff_kernel",
      "description": "This module implements core diffing logic for comparing and formatting text files. It provides functions to compute line-based diffs, refine diffs at the word level, and print or format the results using customizable rules and output styles. Concrete use cases include generating unified diffs between two versions of source code files or text documents.",
      "description_length": 354,
      "index": 372,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Statistics.Time",
      "library": "comby.statistics",
      "description": "This module measures execution time of functions with high precision. It provides functions to start a timer, stop it to get elapsed time, and enforce a timeout on function calls. It works directly with floating-point timestamps and integers for timeout durations. Use it to benchmark code performance or enforce time limits on operations like file parsing or network requests.",
      "description_length": 377,
      "index": 373,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Statistics",
      "library": "comby.statistics",
      "description": "This module tracks and aggregates statistics for batch operations, such as counting files processed, lines of code analyzed, and matches found. It provides functions to serialize and deserialize statistics to and from JSON, merge two statistic records, and initialize an empty record. Use it to collect and combine metrics from parallel or sequential data processing tasks, such as static code analysis or log file scanning.",
      "description_length": 424,
      "index": 374,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Interactive.Diff",
      "library": "comby.interactive",
      "description": "This module compares arrays of strings using patience diff algorithm, producing structured hunks that represent differences. It applies styling to these hunks and converts them into formatted strings for display. It is used to generate human-readable diff outputs with customizable formatting and indentation.",
      "description_length": 309,
      "index": 375,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Interactive",
      "library": "comby.interactive",
      "description": "This module manages interactive editing and patch application workflows, providing screen clearing, diff rendering, and process error handling. It works with string arrays for diffing, custom input records for tracking file paths and rewritten content, and integrates with Lwt for asynchronous process management. Concrete use cases include displaying styled diffs, launching editors to modify code interactively, and applying or rejecting patches based on user input.",
      "description_length": 468,
      "index": 376,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Patdiff.Configuration.On_disk.V1",
      "library": "comby.patdiff",
      "description": "Handles parsing and serialization of version 1 on-disk configuration files. Works with `t` as the in-memory representation of configuration values. Used to load and write configuration settings from files in a structured format.",
      "description_length": 228,
      "index": 377,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Patdiff.Configuration.On_disk.V0",
      "library": "comby.patdiff",
      "description": "Handles parsing and conversion of on-disk configuration files for Patdiff from version 0 to version 1. Works with the `t` type representing the configuration structure specific to version 0. Used during configuration migration to ensure compatibility with newer versions of Patdiff's on-disk format.",
      "description_length": 299,
      "index": 378,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Patdiff.Configuration.On_disk",
      "library": "comby.patdiff",
      "description": "Handles parsing and serialization of on-disk configuration files for Patdiff, supporting both version 1 and legacy version 0 formats. Works directly with the `t` type, representing in-memory configuration values, and provides conversion to and from S-expressions. Used to load and persist configuration settings from disk, enabling backward compatibility and structured configuration management.",
      "description_length": 395,
      "index": 379,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Patdiff.Patdiff_core",
      "library": "comby.patdiff",
      "description": "This module computes and refines diffs between arrays of strings, producing structured hunks that describe changes. It supports configurable context sizes, whitespace handling, and line splitting, with operations to explode strings into tokens and print or format diffs. Typical use cases include generating human-readable differences between text files or code, with support for ANSI output and custom formatting rules.",
      "description_length": 420,
      "index": 380,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Patdiff.Configuration",
      "library": "comby.patdiff",
      "description": "This module provides operations to configure diff behavior through in-memory records and on-disk files, supporting customization of output parameters like context size, whitespace handling, and verbosity. It works with structured configuration values (`t` records) that extend a kernel type, offering functions to load, modify, and serialize these values while maintaining defaults. Use cases include tailoring diff displays for specific codebases, persisting user preferences across sessions, and programmatically adjusting comparison thresholds for semantic cleanup.",
      "description_length": 568,
      "index": 381,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Patdiff.Compare_core",
      "library": "comby.patdiff",
      "description": "This module compares files, directories, and strings, returning whether they are the same or different. It works with file paths, directory paths, and string-based inputs, supporting filtering for directory comparisons. Concrete use cases include checking if two source code files or directories have changed, or comparing text outputs with customizable formatting.",
      "description_length": 365,
      "index": 382,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Patdiff",
      "library": "comby.patdiff",
      "description": "This module performs text and file comparison operations, computing differences between strings, files, or directories with support for filtering and customizable formatting. It works with arrays of strings, file and directory paths, and structured configuration records to control diff behavior. Concrete use cases include comparing source code files with semantic whitespace handling, generating colored diff output for terminal display, and detecting changes between directory trees while excluding specific files or patterns.",
      "description_length": 529,
      "index": 383,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 387,
    "meaningful_modules": 384,
    "filtered_empty_modules": 3,
    "retention_rate": 0.9922480620155039
  },
  "statistics": {
    "max_description_length": 665,
    "min_description_length": 228,
    "avg_description_length": 388.8307291666667,
    "embedding_file_size_mb": 5.5644025802612305
  }
}