{
  "package": "comby",
  "embedding_model": "Qwen/Qwen3-Embedding-0.6B",
  "embedding_dimension": 1024,
  "total_modules": 451,
  "creation_timestamp": "2025-07-16T00:31:52.444520",
  "modules": [
    {
      "module_path": "Camlzip.Zlib",
      "library": "comby.camlzip",
      "description": "This module implements Zlib compression and decompression algorithms with support for CRC checksums. It operates on byte sequences and strings, providing low-level streaming functions for incremental data processing. Concrete use cases include compressing or decompressing data in chunks for network transmission or file storage, and verifying data integrity using CRC checks.",
      "description_length": 376,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Camlzip.Gzip",
      "library": "comby.camlzip",
      "description": "This module handles reading from and writing to gzip-compressed files using abstract channel types `in_channel` and `out_channel`. It supports operations like `input`, `output`, and their variants to process bytes, substrings, or full strings directly, with control over compression levels when writing. Concrete use cases include reading compressed log files incrementally, writing backups with adjustable compression, and streaming data to or from network sockets without requiring intermediate decompression.",
      "description_length": 511,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Camlzip.Zip",
      "library": "comby.camlzip",
      "description": "This module handles reading and writing ZIP archives, supporting operations like opening ZIP files, listing entries, extracting data, and creating new ZIP files with customizable entry metadata. It works with ZIP entries containing compressed or stored data, along with associated metadata such as filenames, timestamps, CRC checksums, and compression methods. Concrete use cases include extracting specific files from a ZIP archive, packaging directory contents into a compressed ZIP file, or modifying ZIP entries with custom comments and timestamps.",
      "description_length": 552,
      "index": 2,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Camlzip",
      "library": "comby.camlzip",
      "description": "This module provides compression, decompression, and archive management capabilities across multiple formats. It supports Zlib streams for incremental data processing with CRC checks, gzip file handling with channel-based I/O and compression control, and ZIP archive manipulation including entry extraction, creation, and metadata customization. You can use it to compress data for network transmission, read compressed logs incrementally, or package files into ZIP archives with custom timestamps and comments. Specific operations include streaming decompression with CRC verification, writing gzip-compressed backups, and modifying ZIP entries directly.",
      "description_length": 655,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Statistics.Time",
      "library": "comby.statistics",
      "description": "This module provides functions to measure execution time, including starting a timer, stopping it, and enforcing a time limit on function execution. It works with floating-point values to represent time intervals and supports timing operations on arbitrary functions. Concrete use cases include benchmarking code segments and preventing long-running computations by enforcing timeouts.",
      "description_length": 385,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Statistics",
      "library": "comby.statistics",
      "description": "This module aggregates statistical data from code analysis runs, tracking file counts, lines of code, match counts, and timing information. It supports merging statistics, serializing to JSON, and initializing empty records, enabling comprehensive metric collection during batch analysis. The timing submodule measures execution intervals, times function calls, and enforces timeouts, using floating-point values for precision. Together, they allow benchmarking code segments, enforcing time limits, and aggregating metrics across multiple analysis runs.",
      "description_length": 554,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Interactive.Diff",
      "library": "comby.interactive",
      "description": "This module computes and formats line-based differences between text inputs, producing structured hunks that represent additions, deletions, and unchanged sections. It works with arrays of strings and structured diff inputs, supporting operations like comparison, styling, and rendering of diffs. Concrete use cases include generating human-readable diff outputs for version-controlled files or displaying code changes in a terminal.",
      "description_length": 433,
      "index": 6,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Interactive",
      "library": "comby.interactive",
      "description": "This module orchestrates interactive code editing workflows by launching external editors, applying patches, and handling errors, while integrating structured diff generation and rendering from its child module. It operates on source code strings, file paths, and process statuses, offering precise control over code transformations and user-driven edits. The child module computes line-based diffs as structured hunks, enabling rich diff visualization and analysis in terminal interfaces. Together, they support tasks like editing code at specific lines, generating and applying patch hunks, and displaying styled diff outputs directly to users.",
      "description_length": 646,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Configuration.Command_configuration.Printer",
      "library": "comby.configuration",
      "description": "This module defines a function type that handles the output of match and replacement results by printing them. It works with `printable_result`, which includes file paths, matches, replacements, source content, and transformed results. It is used to display or log the outcome of matching or rewriting operations in a structured format.",
      "description_length": 336,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Configuration.Command_input",
      "library": "comby.configuration",
      "description": "Handles input sources for command configurations, supporting individual paths, string literals, and batch inputs from file lists or ZIP archives. It provides a unified interface to represent and display different input types, particularly distinguishing between single-source and batch inputs. This is useful for applications that process configuration data from mixed sources, such as reading from files, strings, or compressed archives.",
      "description_length": 438,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Configuration.External_semantic",
      "library": "comby.configuration",
      "description": "This module defines configuration settings and a function for generating hover information in LSIF (Language Server Index Format) data. It works with basic types like strings, integers, and optional values. The `lsif_hover` function is used to retrieve contextual documentation or metadata for a symbol at a specific position in a source file, supporting features like tooltips in IDEs.",
      "description_length": 386,
      "index": 10,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Configuration.Diff_configuration",
      "library": "comby.configuration",
      "description": "This module defines configurations for diffing operations, supporting plain, colored, HTML, default, and match-only output formats. It provides functions to generate preconfigured diff settings, customize context lines, and select output styles dynamically. Use cases include generating human-readable diffs in terminal or HTML formats, or extracting matching lines between input strings.",
      "description_length": 388,
      "index": 11,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Configuration.Ripgrep",
      "library": "comby.configuration",
      "description": "This module executes `ripgrep` commands with a given pattern and argument list, returning matching lines or an error. It operates on strings and lists, specifically handling command-line patterns and output parsing. Use it to search files or text content programmatically, such as validating log entries or extracting structured data from text sources.",
      "description_length": 352,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Configuration.Command_configuration",
      "library": "comby.configuration",
      "description": "This module processes command-line configurations for a code matching and rewriting tool, defining data types for user input options, output formatting, and execution modes. It supports interactive reviews, colorized output, and parallel processing, with key operations for parsing arguments, validating parameters, and setting up execution environments. The child module provides a function type to handle and print match and replacement results, working with `printable_result` to display file paths, matches, replacements, and transformed content. Together, they enable structured configuration and clear output for tasks like pattern matching and code transformation.",
      "description_length": 671,
      "index": 13,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Configuration",
      "library": "comby.configuration",
      "description": "This module manages diverse configuration inputs and processing workflows for code analysis tools. It supports input sources like files, strings, and archives, while providing structured settings for diffing, LSIF hover information, and command-line interfaces. Key operations include parsing and validating configurations, executing search commands with `ripgrep`, generating diff outputs in multiple formats, and retrieving symbol metadata. You can use it to build tools that analyze, transform, and display code with rich contextual information and customizable output.",
      "description_length": 572,
      "index": 14,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Pipeline",
      "library": "comby.pipeline",
      "description": "Handles pattern matching and transformation of source code through configurable specifications, supporting operations like finding matches or applying replacements. Works with abstract syntax trees and string-based source code inputs, using matcher modules to process structured data. Used to implement custom code analysis or refactoring tools that require precise syntactic transformations.",
      "description_length": 392,
      "index": 15,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Patdiff.Configuration.On_disk.V1",
      "library": "comby.patdiff",
      "description": "Handles parsing and serialization of version 1 on-disk configuration files. Works with `t` as the in-memory representation of config values and strings for file paths. Used to load and write configuration settings from files in a specific format.",
      "description_length": 246,
      "index": 16,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Patdiff.Configuration.On_disk.V0",
      "library": "comby.patdiff",
      "description": "This module defines the version 0 on-disk configuration format for Patdiff, including the structure and parsing logic for reading configuration from disk. It works with the `t` type representing the configuration data, and provides the `to_v1` function to migrate configurations to version 1. Concrete use cases include loading and upgrading Patdiff's configuration from a file during diff execution setup.",
      "description_length": 406,
      "index": 17,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Patdiff.Configuration.On_disk",
      "library": "comby.patdiff",
      "description": "This module manages on-disk configuration for diffing tools, supporting both reading and writing through versioned serialization formats. It directly handles S-expression-based configuration data, offering conversion between versions, while its child modules define specific structures for V0 and V1 formats. The V0 module supports loading legacy configurations and migrating them to V1, and the V1 module provides the current in-memory `t` representation for manipulation and persistence. Example usage includes reading a configuration file, upgrading it from V0 to V1, and writing back modified settings in the latest format.",
      "description_length": 627,
      "index": 18,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Patdiff.Patdiff_core",
      "library": "comby.patdiff",
      "description": "This module computes and refines diffs between arrays of strings, producing structured hunks that describe changes. It supports configurable context sizes, whitespace handling, and line refinement, with options to control output formatting and granularity. Use it to generate human-readable diffs, analyze text differences programmatically, or integrate into tools requiring precise textual change detection.",
      "description_length": 408,
      "index": 19,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Patdiff.Configuration",
      "library": "comby.patdiff",
      "description": "This module governs diff output behavior through configurable parameters like context size, whitespace handling, and formatting rules, while supporting persistent storage via on-disk configuration files. It provides operations to load, validate, and override settings, with versioned serialization handled through child modules defining V0 and V1 S-expression formats. Users can read legacy V0 configurations, migrate them to V1, modify settings in memory, and write back updated configurations in the latest format. Specific examples include customizing diff presentation by adjusting line thresholds or numeric tolerances and ensuring consistent configuration across sessions through disk persistence.",
      "description_length": 703,
      "index": 20,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Patdiff.Compare_core",
      "library": "comby.patdiff",
      "description": "This module compares files, directories, and strings, returning whether they are the same or different. It works with file paths, directory paths, and string contents, using configuration options to control comparison behavior. Concrete use cases include checking if two versions of a file or directory tree differ, or comparing string-based inputs with customizable formatting.",
      "description_length": 378,
      "index": 21,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Patdiff",
      "library": "comby.patdiff",
      "description": "This module provides tools for computing, comparing, and configuring textual differences with structured output. It supports diffing arrays of strings into hunks, comparing files and directories, and managing configuration through versioned serialization. Key data types include diffs, configurations, and comparison results, with operations to refine, format, and persist them. Examples include generating readable diffs with context control, validating file equality with custom settings, and migrating configuration files between versions.",
      "description_length": 542,
      "index": 22,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Solidity.Info",
      "library": "comby",
      "description": "This module defines metadata for the Solidity programming language, including its name and file extensions. It provides direct access to the language name as a string and a list of associated file extensions. This information is used to identify and handle Solidity source files in tooling contexts such as parsing and analysis.",
      "description_length": 328,
      "index": 23,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.JSON.Info",
      "library": "comby",
      "description": "This module defines metadata for the JSON language, including the language name and associated file extensions. It provides direct access to static information used for identifying and processing JSON files. Concrete use cases include determining file type based on extension and referencing the canonical name of the language during parsing or analysis tasks.",
      "description_length": 360,
      "index": 24,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Python.Info",
      "library": "comby",
      "description": "This module defines metadata for the Python language, including its name and file extensions. It provides direct access to the language name as a string and a list of associated file extensions. This information is used to identify and handle Python files in parsing and processing workflows.",
      "description_length": 292,
      "index": 25,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Csharp.Syntax",
      "library": "comby",
      "description": "This module defines syntax elements specific to C#, including user-defined delimiters for code boundaries, escapable and raw string literals, and comment styles. It works with string pairs for delimiters and string literal configurations, along with comment structures. It is used to parse and match C# code patterns in tools like code analyzers or refactoring utilities.",
      "description_length": 371,
      "index": 26,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Html.Info",
      "library": "comby",
      "description": "This module defines metadata for HTML language support, including the language name and file extensions. It provides the `name` value for identifying the language and `extensions` for recognizing associated file types. Use this module to integrate HTML language settings into file processing or syntax detection workflows.",
      "description_length": 322,
      "index": 27,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Julia.Info",
      "library": "comby",
      "description": "This module defines metadata for the Julia programming language, including its name and file extensions. It provides direct access to the language name as a string and a list of associated file extensions. This information is used for language identification and file handling in code processing tools.",
      "description_length": 302,
      "index": 28,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.JSONC.Info",
      "library": "comby",
      "description": "This module defines metadata for the JSONC language, including its name and file extensions. It provides direct access to the language identifier and a list of associated file extensions. Useful for tools that need to recognize or process JSONC files based on their extension or name.",
      "description_length": 284,
      "index": 29,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Languages.Jsx.Syntax",
      "library": "comby",
      "description": "This module defines syntax elements for JSX, including user-defined delimiters, escapable and raw string literals, and comment kinds. It provides precise parsing and matching capabilities for JSX structures in source code analysis. Use cases include template-based code transformation and syntactic pattern matching in JSX files.",
      "description_length": 329,
      "index": 30,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Reason.Syntax",
      "library": "comby",
      "description": "This module defines syntax elements for parsing and matching ReasonML code, including customizable delimiters, escapable and raw string literals, and comment styles. It provides concrete configurations for handling string enclosures, escape sequences, and comment blocks specific to the ReasonML language. Use this module to enable precise pattern matching and transformation of ReasonML source code.",
      "description_length": 400,
      "index": 31,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Tsx.Syntax",
      "library": "comby",
      "description": "This module defines syntax-specific configurations for parsing and matching in TSX code. It specifies delimiters, escapable and raw string literals, and comment styles unique to the language. These values guide accurate pattern recognition and transformation in TSX files during code analysis or refactoring tasks.",
      "description_length": 314,
      "index": 32,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Scala.Syntax",
      "library": "comby",
      "description": "This module defines syntax elements specific to Scala, including delimiters for code blocks, escapable and raw string literals, and comment styles. It provides precise configurations for parsing and matching Scala code patterns. Use this module to handle Scala-specific syntactic structures in code analysis or transformation tasks.",
      "description_length": 332,
      "index": 33,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.CSS.Syntax",
      "library": "comby",
      "description": "This module defines syntax elements for CSS, including user-defined delimiters, escapable and raw string literals, and comment styles. It provides precise parsing constructs for handling CSS-specific syntax features like quoted strings and comment blocks. Use this module to parse or manipulate CSS code with accurate syntactic rules, such as extracting values from declarations or processing embedded strings.",
      "description_length": 410,
      "index": 34,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Tsx.Info",
      "library": "comby",
      "description": "This module defines metadata for the TSX language, including its name and file extensions. It provides direct access to the language identifier and a list of associated file extensions. Useful for tooling that needs to recognize or process TSX files based on their extension or name.",
      "description_length": 283,
      "index": 35,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Solidity.Syntax",
      "library": "comby",
      "description": "This module defines syntax elements specific to Solidity, including user-defined delimiters, escapable and raw string literals, and comment kinds. It provides precise syntactic patterns for parsing and matching Solidity code structures. Use this module when implementing custom parsers or matchers that need to handle Solidity's unique syntax features like inline assembly blocks or ABI encoding expressions.",
      "description_length": 408,
      "index": 36,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.C.Syntax",
      "library": "comby",
      "description": "This module defines syntax elements for parsing and matching C code, including user-defined delimiters, escapable and raw string literals, and comment styles. It provides concrete configurations for handling C-specific syntax features like string escaping and comment delimiters. Use this module when implementing parsers or matchers that need to accurately recognize C language constructs in source code.",
      "description_length": 405,
      "index": 37,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Scala.Info",
      "library": "comby",
      "description": "This module defines metadata for the Scala programming language, including its name and file extensions. It provides concrete values for identifying Scala source files, such as the language name \"Scala\" and a list of extensions like `.scala`. This information is used in tooling that needs to recognize or process Scala files based on their extension or name.",
      "description_length": 359,
      "index": 38,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Languages.Erlang.Syntax",
      "library": "comby",
      "description": "This module defines syntax elements specific to Erlang, including user-defined delimiters, escapable and raw string literals, and comment kinds. It provides precise syntactic patterns for parsing and matching Erlang code structures. Use cases include implementing custom parsers, linters, or code transformation tools that require accurate Erlang syntax recognition.",
      "description_length": 366,
      "index": 39,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Languages.Dart.Syntax",
      "library": "comby",
      "description": "This module defines syntax elements specific to Dart, including user-defined delimiters, escapable and raw string literals, and comment kinds. It provides precise syntactic patterns for parsing and matching Dart code structures. Use cases include building custom linters, code transformers, or static analysis tools that require accurate Dart syntax recognition.",
      "description_length": 362,
      "index": 40,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Languages.HCL.Syntax",
      "library": "comby",
      "description": "This module defines syntax elements for HCL (HashiCorp Configuration Language), including user-defined delimiters, escapable and raw string literals, and comment kinds. It provides precise syntactic patterns used to parse and match HCL configurations. Use this module when implementing HCL-specific matching logic, such as in linters, formatters, or custom configuration analyzers.",
      "description_length": 381,
      "index": 41,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Languages.Latex.Syntax",
      "library": "comby",
      "description": "This module defines syntax elements for parsing and matching LaTeX documents. It specifies delimiters for macros, escapable and raw string literals, and comment styles. Concrete use cases include identifying LaTeX commands, handling special characters in strings, and stripping or processing comments in LaTeX source files.",
      "description_length": 323,
      "index": 42,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Matlab.Info",
      "library": "comby",
      "description": "This module defines metadata for the MATLAB programming language, including its name and file extensions. It provides the `name` and `extensions` values to identify and associate files with the MATLAB language. Use this module to retrieve the canonical name and supported file extensions for MATLAB in contexts like file parsing or language detection.",
      "description_length": 351,
      "index": 43,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Lisp.Info",
      "library": "comby",
      "description": "This module defines metadata for the Lisp programming language, including its name and file extensions. It provides direct access to the language name as a string and a list of associated file extensions. This information is used to identify and handle Lisp files in parsing and processing workflows.",
      "description_length": 300,
      "index": 44,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Languages.Swift.Info",
      "library": "comby",
      "description": "This module defines metadata for the Swift programming language, including its name and file extensions. It provides concrete values for identifying Swift source files, such as the language name \"Swift\" and a list of extensions like `.swift`. These values are used in tooling that needs to recognize or process Swift files, such as linters, formatters, or code analyzers.",
      "description_length": 371,
      "index": 45,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Generic.Info",
      "library": "comby",
      "description": "This module defines metadata for a generic programming language, including its name and associated file extensions. It provides direct access to the language's identifier and a list of its common file extensions. Useful for tools that need to recognize or process files based on language type, such as linters or syntax highlighters.",
      "description_length": 333,
      "index": 46,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Language.Info.S",
      "library": "comby",
      "description": "This module defines metadata for a programming language, including its name and associated file extensions. It works with basic string and list data types to store and retrieve this information. Concrete use cases include identifying language-specific files in a codebase or configuring tools based on file extension mappings.",
      "description_length": 326,
      "index": 47,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Zig.Info",
      "library": "comby",
      "description": "This module defines metadata for the Zig programming language, including its canonical name and file extensions. It provides direct access to the language's identifier and a list of associated file extensions. Use this module to retrieve Zig-specific naming and extension information for tooling or configuration purposes.",
      "description_length": 322,
      "index": 48,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Julia.Syntax",
      "library": "comby",
      "description": "This module defines syntax elements specific to the Julia programming language, including delimiters for string literals, escapable and raw string configurations, and comment styles. It provides precise syntax rules for parsing and matching Julia code patterns, such as handling triple-quoted strings and line/column comments. Use cases include building parsers, linters, or code transformation tools that require accurate Julia syntax recognition.",
      "description_length": 448,
      "index": 49,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Languages.JSON.Syntax",
      "library": "comby",
      "description": "This module defines syntax elements for parsing and matching JSON, including customizable delimiters, escapable and raw string literals, and comment styles. It works with data types like string pairs for delimiters, options for escapable literals, and lists of comment kinds. Concrete use cases include configuring parsers to handle JSON-specific syntax in source code analysis and transformation tools.",
      "description_length": 403,
      "index": 50,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.GraphQL.Syntax",
      "library": "comby",
      "description": "This module defines syntax elements for parsing and matching GraphQL code, including customizable delimiters for string literals, support for escapable and raw string literals, and specifications for comment handling. It works with string-based data structures and syntax trees to enable precise pattern matching in GraphQL documents. Concrete use cases include implementing linters, formatters, and transformation tools that require accurate parsing of GraphQL schemas and queries.",
      "description_length": 482,
      "index": 51,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Languages.Elm.Info",
      "library": "comby",
      "description": "This module defines metadata for the Elm programming language, including its name and file extensions. It provides direct access to the language name as a string and a list of associated file extensions. This information is used to identify and handle Elm source files in tooling that processes or analyzes code based on file type.",
      "description_length": 331,
      "index": 52,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Zig.Syntax",
      "library": "comby",
      "description": "This module defines syntax-specific configurations for parsing and matching Zig code. It specifies delimiters, escapable and raw string literals, and comment styles unique to Zig. These values guide pattern matching and transformation tools to accurately handle Zig's syntax in code analysis tasks.",
      "description_length": 298,
      "index": 53,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.C.Info",
      "library": "comby",
      "description": "This module defines metadata for the C programming language, including the language name and file extensions associated with C source files. It provides direct access to a list of common extensions used for C code, such as `.c` and `.h`. This information is useful for tools that need to identify or process C files based on their extension.",
      "description_length": 341,
      "index": 54,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Pascal.Info",
      "library": "comby",
      "description": "This module defines metadata for Pascal language support, including the language name and file extensions. It provides direct access to static information used for file recognition and configuration. Concrete use cases include determining valid Pascal file types and associating editor settings with Pascal files.",
      "description_length": 313,
      "index": 55,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Languages.Elm.Syntax",
      "library": "comby",
      "description": "This module defines syntax elements for parsing and matching Elm code, including user-defined delimiters, escapable and raw string literals, and comment styles. It provides precise specifications for identifying syntactic constructs in Elm source files. Use this module to configure parsers or matchers that need to handle Elm's specific syntax features accurately.",
      "description_length": 365,
      "index": 56,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Lisp.Syntax",
      "library": "comby",
      "description": "This module defines syntax elements for Lisp-like languages, including customizable delimiters for string literals, escapable and raw string formats, and comment styles. It supports parsing and matching code patterns by specifying how strings and comments are structured in Lisp dialects. Use this module to configure syntax rules when analyzing or transforming Lisp code with custom string and comment conventions.",
      "description_length": 415,
      "index": 57,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Clojure.Info",
      "library": "comby",
      "description": "This module defines metadata for the Clojure language, including its name and file extensions. It provides direct access to the language name as a string and a list of associated file extensions. Useful for tools that need to identify or process Clojure files based on naming conventions, such as syntax highlighters or linters.",
      "description_length": 328,
      "index": 58,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Languages.Fortran.Syntax",
      "library": "comby",
      "description": "This module defines syntax elements for Fortran, including user-defined delimiters, escapable and raw string literals, and comment styles. It supports parsing and matching Fortran code by specifying how strings and comments are structured in the language. Concrete use cases include configuring code transformation tools and writing precise code pattern matchers for Fortran source files.",
      "description_length": 388,
      "index": 59,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.R.Syntax",
      "library": "comby",
      "description": "This module defines syntax elements specific to the R programming language, including user-defined delimiters, escapable and raw string literals, and comment styles. It provides precise string patterns and configurations that match R's syntax rules for parsing and transformation tasks. Use this module when implementing R-specific code analysis, refactoring, or templating tools that require accurate syntax handling.",
      "description_length": 418,
      "index": 60,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Languages.Fsharp.Info",
      "library": "comby",
      "description": "This module defines metadata for the F# programming language, including its name and file extensions. It provides direct access to the language name as a string and a list of associated file extensions. This information is used for language identification and file handling in code processing tools.",
      "description_length": 299,
      "index": 61,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Reason.Info",
      "library": "comby",
      "description": "This module defines metadata for the Reason programming language, including its name and file extensions. It provides direct access to the language name as a string and a list of associated file extensions. This information is used to identify and handle Reason source files in tooling and processing pipelines.",
      "description_length": 311,
      "index": 62,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Javascript.Syntax",
      "library": "comby",
      "description": "This module defines syntax-specific configurations for JavaScript, including delimiters for string literals, escapable and raw string formats, and comment styles. It provides concrete values for handling JavaScript syntax elements like template literals, quoted strings, and comment blocks. Use this module to parse or transform JavaScript code with precise control over string and comment syntax.",
      "description_length": 397,
      "index": 63,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Languages.Elixir.Info",
      "library": "comby",
      "description": "This module defines metadata for the Elixir programming language, including its name and file extensions. It provides direct access to the language name as a string and a list of associated file extensions. This information is used for language identification and file handling in tooling that processes Elixir code.",
      "description_length": 316,
      "index": 64,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.CSS.Info",
      "library": "comby",
      "description": "This module defines metadata for CSS language support, including the language name and file extensions. It provides direct access to static information used for identifying and handling CSS files. Concrete use cases include configuring parsers or editors to recognize CSS syntax and file types.",
      "description_length": 294,
      "index": 65,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Java.Syntax",
      "library": "comby",
      "description": "This module defines syntax elements for parsing and matching Java code, including user-defined delimiters, escapable and raw string literals, and comment kinds. It provides precise specifications for identifying syntactic constructs in Java source files. Use this module to enable accurate pattern matching and transformation of Java code based on its structural features.",
      "description_length": 372,
      "index": 66,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Typescript.Info",
      "library": "comby",
      "description": "This module defines metadata for the TypeScript language, including the language name and file extensions. It provides direct access to the name as a string and the extensions as a list of strings. Concrete use cases include identifying TypeScript files by extension and referencing the language name in tooling or configuration contexts.",
      "description_length": 338,
      "index": 67,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Bash.Syntax",
      "library": "comby",
      "description": "This module defines syntax elements for parsing Bash scripts, including customizable delimiters, escapable and raw string literals, and comment styles. It supports concrete use cases like template matching and code transformation in Bash scripts by specifying how strings and comments are structured. The data types include lists of string pairs for delimiters and literals, and options for escapable string configurations.",
      "description_length": 423,
      "index": 68,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.R.Info",
      "library": "comby",
      "description": "This module defines metadata for a specific programming language, including its name and associated file extensions. It works with string and list data types to store and retrieve this information. Concrete use cases include identifying the language by name and determining file types based on extensions.",
      "description_length": 305,
      "index": 69,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Languages.Dhall.Info",
      "library": "comby",
      "description": "This module defines metadata for the Dhall configuration language, including its name and file extensions. It works with string and list data types to specify language identifiers and supported file suffixes. Concrete use cases include determining file association and language identification in code processing tools.",
      "description_length": 318,
      "index": 70,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Go.Syntax",
      "library": "comby",
      "description": "This module defines syntax-specific elements for parsing and matching Go code, including user-defined delimiters, escapable and raw string literals, and comment kinds. It provides precise syntactic patterns used in Go, such as backticks for raw strings and specific comment markers. These elements enable accurate pattern matching and transformation of Go source code in tools like code formatters or linters.",
      "description_length": 409,
      "index": 71,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Languages.Erlang.Info",
      "library": "comby",
      "description": "This module defines metadata for the Erlang language, including its name and file extensions. It provides direct access to a list of common file extensions associated with Erlang source files. Use this module when handling file type detection or language identification tasks specifically for Erlang.",
      "description_length": 300,
      "index": 72,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Php.Info",
      "library": "comby",
      "description": "This module defines metadata for the PHP language, including its name and file extensions. It provides direct access to the language name as a string and a list of associated file extensions. Useful for identifying PHP files by extension or referencing the language name in tooling integrations.",
      "description_length": 295,
      "index": 73,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Paren.Syntax",
      "library": "comby",
      "description": "This module defines syntax configurations for parenthetical languages, specifying delimiters, string literals, and comment styles. It provides concrete values for user-defined delimiters, escapable and raw string literals, and comment kinds. These configurations are used to parse and match code patterns in languages with parenthetical syntax.",
      "description_length": 344,
      "index": 74,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.SQL.Info",
      "library": "comby",
      "description": "This module defines metadata for SQL language support, including the language name and file extensions. It provides concrete values for identifying SQL files and handling their specific conventions. Useful for tools that process SQL files based on extension or need to reference the language name.",
      "description_length": 297,
      "index": 75,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Move.Info",
      "library": "comby",
      "description": "This module defines metadata for the Move programming language, including its name and file extensions. It provides direct access to the language's identifier and a list of associated file extensions. Use this module to retrieve Move-specific naming and extension information for tooling or configuration purposes.",
      "description_length": 314,
      "index": 76,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Languages.Java.Info",
      "library": "comby",
      "description": "This module defines metadata for the Java language, including the language name and file extensions associated with Java source files. It provides direct access to a string identifier and a list of filename extensions used to recognize Java code. This information supports tools that process or categorize Java files based on their extension and name.",
      "description_length": 351,
      "index": 77,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Jsx.Info",
      "library": "comby",
      "description": "This module defines metadata for the JSX language, including its name and file extensions. It provides direct access to the language identifier and a list of associated file extensions. Useful for tools that need to recognize or process JSX files based on their extension or name.",
      "description_length": 280,
      "index": 78,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.SQL.Syntax",
      "library": "comby",
      "description": "This module defines syntax elements for SQL, including user-defined delimiters, escapable and raw string literals, and comment styles. It provides concrete configurations for parsing and matching SQL code patterns. Use cases include implementing SQL-specific matchers for query analysis or transformation tools.",
      "description_length": 311,
      "index": 79,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Languages.Fortran.Info",
      "library": "comby",
      "description": "This module defines metadata for the Fortran language, including its name and file extensions. It provides direct access to a list of common file extensions associated with Fortran source files. Use this module when handling Fortran files in tools that require language-specific configuration or identification.",
      "description_length": 311,
      "index": 80,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Move.Syntax",
      "library": "comby",
      "description": "This module defines syntax elements for the Move programming language, including user-defined delimiters, escapable and raw string literals, and comment kinds. It provides precise syntactic patterns used for parsing and matching code structures in Move. These definitions support concrete tasks like code transformation, linting, and structural queries specific to Move.",
      "description_length": 370,
      "index": 81,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Languages.Csharp.Info",
      "library": "comby",
      "description": "This module defines metadata for the C# language, including the language name and file extensions associated with C# source files. It provides direct access to a list of common file extensions used in C# projects, such as `.cs`. Use this module when handling C# source files in tools that require language-specific configuration, like linters, formatters, or code analyzers.",
      "description_length": 374,
      "index": 82,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Html.Syntax",
      "library": "comby",
      "description": "This module defines syntax-specific configurations for parsing and matching HTML, including delimiters for embedded expressions, escapable and raw string literals, and comment structures. It supports precise pattern matching and transformation of HTML content by specifying how different syntactic elements are represented. Concrete use cases include templating systems, code refactoring tools, and static analysis for HTML-based documents.",
      "description_length": 440,
      "index": 83,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Coq.Info",
      "library": "comby",
      "description": "This module defines metadata for the Coq programming language, including its name and file extensions. It provides direct access to the language name as a string and a list of associated file extensions. This information is used for identifying and handling Coq source files in tooling contexts such as parsing and analysis.",
      "description_length": 324,
      "index": 84,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Generic.Syntax",
      "library": "comby",
      "description": "This module defines syntax configurations for parsing and matching code patterns, including delimiters for variables, escapable and raw string literals, and comment styles. It works with lists of string pairs for delimiters and literals, and predefined comment kinds. Concrete use cases include configuring pattern matchers to handle custom syntax in source code analysis tools.",
      "description_length": 378,
      "index": 85,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Nim.Syntax",
      "library": "comby",
      "description": "This module defines syntax elements for the Nim programming language, including user-defined delimiters, escapable and raw string literals, and comment styles. It provides precise specifications for parsing and matching Nim code patterns. Use cases include implementing custom syntax highlighters, linters, or code transformation tools tailored to Nim's unique syntax features.",
      "description_length": 377,
      "index": 86,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Kotlin.Info",
      "library": "comby",
      "description": "This module defines metadata for the Kotlin programming language, including its name and file extensions. It provides direct access to the language name as a string and a list of associated file extensions. This information is used for identifying and handling Kotlin files in code processing tools.",
      "description_length": 299,
      "index": 87,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Pascal.Syntax",
      "library": "comby",
      "description": "This module defines syntax elements for Pascal, including user-defined delimiters, escapable and raw string literals, and comment styles. It provides precise syntax configurations for parsing and matching Pascal code. Use this module to handle Pascal-specific syntactic constructs in code analysis or transformation tasks.",
      "description_length": 322,
      "index": 88,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Rust.Syntax",
      "library": "comby",
      "description": "This module defines syntax-specific configurations for parsing and matching Rust code. It specifies delimiters, escapable and raw string literals, and comment styles used in Rust. These values support precise pattern matching and transformation of Rust source code.",
      "description_length": 265,
      "index": 89,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Latex.Info",
      "library": "comby",
      "description": "This module defines metadata for the LaTeX language, including its name and file extensions. It provides the `name` value as a string and `extensions` as a list of strings representing associated file types. It is used to identify and handle LaTeX files in parsing and processing workflows.",
      "description_length": 290,
      "index": 90,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.OCaml.Info",
      "library": "comby",
      "description": "This module defines metadata for the OCaml language, including the language name and file extensions. It provides direct access to static information used for identifying and handling OCaml source files. Concrete use cases include configuring parsers or tools based on file extension or language name.",
      "description_length": 301,
      "index": 91,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Swift.Syntax",
      "library": "comby",
      "description": "This module defines syntax elements specific to Swift, including user-defined delimiters for string literals, escapable and raw string configurations, and comment kinds. It provides concrete syntax rules for parsing and matching Swift code patterns. Use cases include implementing custom string handling and comment recognition in Swift code analysis tools.",
      "description_length": 357,
      "index": 92,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Clojure.Syntax",
      "library": "comby",
      "description": "This module defines syntax elements for parsing and matching Clojure code, including customizable delimiters, escapable and raw string literals, and comment styles. It supports concrete use cases like pattern matching in Clojure source files, handling string interpolation, and identifying comment blocks for transformation or analysis tasks.",
      "description_length": 342,
      "index": 93,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Language.Syntax.S",
      "library": "comby",
      "description": "This module defines syntax elements for a matcher, including user-defined delimiters, escapable and raw string literals, and comment kinds. It works with strings, lists, and custom types for comments and string literals. Use this to configure language-specific syntax rules when parsing or matching code patterns.",
      "description_length": 313,
      "index": 94,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.JSONC.Syntax",
      "library": "comby",
      "description": "This module defines syntax elements for parsing and matching JSONC (JSON with comments), including customizable delimiters, escapable and raw string literals, and comment styles. It supports precise pattern matching and transformation of JSONC content by specifying how different syntactic constructs should be recognized. Concrete use cases include implementing custom JSONC parsers, linters, or code transformation tools that require accurate handling of JSONC syntax features.",
      "description_length": 479,
      "index": 95,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Haskell.Syntax",
      "library": "comby",
      "description": "This module defines syntax elements specific to Haskell, including user-defined delimiters, escapable and raw string literals, and comment kinds. It provides precise syntactic patterns for parsing and matching Haskell code structures. Use this module when implementing custom syntax analysis or transformation tools for Haskell, such as linters, formatters, or refactoring utilities.",
      "description_length": 383,
      "index": 96,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Python.Syntax",
      "library": "comby",
      "description": "This module defines syntax elements specific to Python, including user-defined delimiters for string literals, escapable and raw string configurations, and comment styles. It provides precise syntactic patterns for parsing and matching Python code structures. Use cases include implementing custom string handling and comment detection in Python code analysis tools.",
      "description_length": 366,
      "index": 97,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Dyck.Info",
      "library": "comby",
      "description": "This module defines metadata for a language called Dyck, including its name and associated file extensions. It provides direct access to the language's identifier and a list of its common file extensions. This information is used when parsing or analyzing Dyck language files, particularly for tooling that requires language-specific configuration.",
      "description_length": 348,
      "index": 98,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Bash.Info",
      "library": "comby",
      "description": "This module defines metadata for the Bash language, including its name and file extensions. It provides direct access to the language identifier and a list of associated file extensions. Use this module to retrieve Bash-specific naming and extension information for file processing or language detection tasks.",
      "description_length": 310,
      "index": 99,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Haskell.Info",
      "library": "comby",
      "description": "This module defines metadata for the Haskell programming language, including its name and file extensions. It provides direct access to a list of common file extensions associated with Haskell source files. This information is used for language identification and file handling in tooling that processes Haskell code.",
      "description_length": 317,
      "index": 100,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Languages.Dyck.Syntax",
      "library": "comby",
      "description": "This module defines syntax elements for matching and parsing Dyck-like languages, including user-defined delimiters, escapable and raw string literals, and comment styles. It works with tuples and lists of strings to represent opening and closing pairs, as well as optional and polymorphic variants for handling different literal and comment configurations. Concrete use cases include configuring parsers for domain-specific languages with balanced parentheses or nested structures.",
      "description_length": 482,
      "index": 101,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Languages.Assembly.Syntax",
      "library": "comby",
      "description": "This module defines syntax elements for parsing assembly code, including user-defined delimiters, escapable and raw string literals, and comment styles. It provides precise configurations for tokenizing and recognizing assembly language constructs. Use this module to customize syntax parsing for different assembly dialects or to extend support for new assemblers.",
      "description_length": 365,
      "index": 102,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Elixir.Syntax",
      "library": "comby",
      "description": "This module defines syntax elements specific to Elixir, including user-defined delimiters, escapable and raw string literals, and comment styles. It provides precise syntactic patterns used for parsing and matching Elixir code structures. Use this module to handle Elixir-specific syntax when analyzing or transforming code, such as identifying string boundaries or skipping comments.",
      "description_length": 384,
      "index": 103,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Languages.Kotlin.Syntax",
      "library": "comby",
      "description": "This module defines syntax elements specific to Kotlin, including delimiters for code boundaries, escapable and raw string literals, and comment styles. It provides precise string patterns and configurations that match Kotlin's syntactic conventions. These values are used to parse and manipulate Kotlin code in tools like formatters, linters, or code generators.",
      "description_length": 363,
      "index": 104,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Javascript.Info",
      "library": "comby",
      "description": "This module defines metadata for JavaScript, including the language name and file extensions. It provides direct access to the name as a string and extensions as a list of strings. Concrete use cases include identifying JavaScript files by extension and referencing the language name in tooling or configuration contexts.",
      "description_length": 321,
      "index": 105,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Languages.C_nested_comments.Syntax",
      "library": "comby",
      "description": "This module defines syntax configurations for handling nested comments, string literals, and delimiters in a language similar to C. It specifies pairs of delimiters for nested structures, escapable and raw string literal markers, and comment styles. Concrete use cases include parsing source code with nested comments and correctly identifying string boundaries in the presence of escape sequences or raw string indicators.",
      "description_length": 423,
      "index": 106,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.OCaml.Syntax",
      "library": "comby",
      "description": "This module defines syntax elements specific to OCaml, including user-defined delimiters, escapable and raw string literals, and comment styles. It provides precise syntactic patterns used for parsing and matching OCaml code structures. Use cases include implementing custom syntax extensions, analyzing OCaml source files, and supporting tools like linters or refactoring utilities.",
      "description_length": 383,
      "index": 107,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Languages.Ruby.Info",
      "library": "comby",
      "description": "This module defines metadata for the Ruby programming language, including its name and file extensions. It provides direct access to the language name as a string and a list of associated file extensions. This information is used for identifying and handling Ruby files in code processing tools.",
      "description_length": 295,
      "index": 108,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Go.Info",
      "library": "comby",
      "description": "This module defines metadata for the Go programming language, including its name and file extensions. It provides direct access to the language name as a string and a list of associated file extensions. This information is used to identify and process Go source files in tooling that requires language-specific configuration.",
      "description_length": 325,
      "index": 109,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Languages.Coq.Syntax",
      "library": "comby",
      "description": "This module defines syntax elements for parsing and matching Coq code, including user-defined delimiters, escapable and raw string literals, and comment styles. It provides concrete configurations for handling Coq-specific syntax constructs such as notations, strings with escapes, and various comment forms. Use this module to customize pattern matching and transformation tools for Coq source code, especially when dealing with custom syntax extensions or string encodings.",
      "description_length": 475,
      "index": 110,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Dhall.Syntax",
      "library": "comby",
      "description": "This module defines syntax elements for parsing and matching Dhall code, including user-defined delimiters, escapable and raw string literals, and comment styles. It provides precise specifications for how these syntactic constructs are represented in Dhall source code. Use cases include configuring parsers and matchers to accurately handle Dhall's syntax in tools like linters, formatters, or code analyzers.",
      "description_length": 411,
      "index": 111,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Fsharp.Syntax",
      "library": "comby",
      "description": "This module defines syntax elements for F# such as user-defined delimiters, escapable and raw string literals, and comment kinds. It provides concrete configurations for parsing and matching F# code patterns. Use this module to handle F#-specific syntactic structures in code analysis or transformation tasks.",
      "description_length": 309,
      "index": 112,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Text.Info",
      "library": "comby",
      "description": "This module defines metadata for text-based languages, including the language name and associated file extensions. It works with string and list data types to store and retrieve this information. Concrete use cases include identifying language-specific files and configuring text processing tools based on extension mappings.",
      "description_length": 325,
      "index": 113,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Languages.Rust.Info",
      "library": "comby",
      "description": "This module defines metadata for the Rust programming language, including its name and file extensions. It provides direct access to the language name as a string and a list of associated file extensions. This information is used to identify and handle Rust source files in tooling that processes or analyzes code based on file type.",
      "description_length": 333,
      "index": 114,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.GraphQL.Info",
      "library": "comby",
      "description": "This module defines metadata for the GraphQL language, including the name and file extensions associated with it. It provides direct access to static information used for identifying and handling GraphQL files. Concrete use cases include determining file type based on extension and referencing the language name in tooling or configuration contexts.",
      "description_length": 350,
      "index": 115,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Xml.Info",
      "library": "comby",
      "description": "This module defines metadata for XML files, including the language name and associated file extensions. It provides direct access to static information used for identifying and handling XML content. Concrete use cases include determining file type based on extension and labeling XML documents in processing pipelines.",
      "description_length": 318,
      "index": 116,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Xml.Syntax",
      "library": "comby",
      "description": "This module defines syntax elements for parsing and matching XML, including user-defined delimiters, escapable and raw string literals, and comment structures. It works with string pairs for delimiters and literals, and categorizes comment types specific to XML. Used to configure parsers for XML templates, enabling accurate handling of embedded expressions and comments in XML documents.",
      "description_length": 389,
      "index": 117,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Languages.Text.Syntax",
      "library": "comby",
      "description": "This module defines syntax elements for text-based languages, including user-defined delimiters, escapable and raw string literals, and comment styles. It provides concrete configurations for parsing and matching text patterns with specific lexical structures. Use cases include setting up custom syntax rules for text templating, string interpolation, or comment handling in source code analysis.",
      "description_length": 397,
      "index": 118,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Ruby.Syntax",
      "library": "comby",
      "description": "This module defines syntax elements specific to Ruby, including delimiters for string literals, escapable and raw string markers, and comment styles. It provides precise pattern-matching capabilities for parsing Ruby code by specifying how strings and comments are structured. Use cases include implementing custom syntax analyzers or transforming Ruby code based on its structural elements.",
      "description_length": 391,
      "index": 119,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Languages.Dart.Info",
      "library": "comby",
      "description": "This module defines metadata for the Dart programming language, including its name and file extensions. It provides the `name` value for identifying the language and `extensions` for recognizing Dart source files. Concrete use cases include configuring language-specific tools or editors to associate Dart code with its standard `.dart` extension.",
      "description_length": 347,
      "index": 120,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Matlab.Syntax",
      "library": "comby",
      "description": "This module defines syntax elements for parsing MATLAB code, including user-defined delimiters, escapable and raw string literals, and comment styles. It provides precise configurations for handling MATLAB-specific syntax features like string escaping and comment blocks. Use this module to enable accurate pattern matching and transformation of MATLAB code, particularly for tools that require detailed syntax awareness such as formatters, linters, or refactoring utilities.",
      "description_length": 475,
      "index": 121,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Assembly.Info",
      "library": "comby",
      "description": "This module defines metadata for an assembly language, including its name and associated file extensions. It works with string and list data types to store and retrieve language-specific identifiers. Concrete use cases include determining file type associations and language identification during parsing or toolchain integration.",
      "description_length": 330,
      "index": 122,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.C_nested_comments.Info",
      "library": "comby",
      "description": "This module defines metadata for a language variant that supports nested comments, including its name and associated file extensions. It is used to configure parsing or analysis tools that require language-specific settings. Concrete use cases include identifying files with nested comment syntax and enabling correct parsing of such files.",
      "description_length": 340,
      "index": 123,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Nim.Info",
      "library": "comby",
      "description": "This module defines metadata for the Nim programming language, including its name and file extensions. It provides direct access to the language name as a string and a list of associated file extensions. This information is used to identify and handle Nim source files in tooling contexts like syntax parsing or file type detection.",
      "description_length": 332,
      "index": 124,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Paren.Info",
      "library": "comby",
      "description": "This module defines metadata for a programming language, specifically its name and associated file extensions. It works with string and list data types to store and retrieve this information. Concrete use cases include identifying language-specific files based on extension or displaying the language name in tooling interfaces.",
      "description_length": 328,
      "index": 125,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.HCL.Info",
      "library": "comby",
      "description": "This module defines metadata for the HCL language, including its name and file extensions. It provides direct access to the language identifier and a list of associated file extensions. Useful for tools that need to recognize or process HCL files based on extension or name.",
      "description_length": 274,
      "index": 126,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Php.Syntax",
      "library": "comby",
      "description": "This module defines syntax elements specific to PHP, including user-defined delimiters for string literals, escapable and raw string configurations, and comment kinds. It provides precise syntactic patterns for parsing and matching PHP code structures. Use cases include implementing custom string handling and comment recognition in PHP code analysis tools.",
      "description_length": 358,
      "index": 127,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Typescript.Syntax",
      "library": "comby",
      "description": "This module defines syntax elements for TypeScript, including delimiters for templated strings, escapable and raw string literals, and comment styles. It provides precise syntactic patterns used to parse and match code structures in TypeScript source files. Use this module to handle string interpolation, escape sequences, and comment recognition in TypeScript code analysis or transformation tools.",
      "description_length": 400,
      "index": 128,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Omega.HCL",
      "library": "comby",
      "description": "This module provides functions to match HCL (HashiCorp Configuration Language) templates against source code, supporting both full and first-match scanning with configurable parameters. It operates on HCL syntax structures, handling nested matches recursively when enabled, and allows specifying start positions for match searches. Use cases include parsing and analyzing Terraform configurations or other infrastructure-as-code files written in HCL.",
      "description_length": 450,
      "index": 129,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Latex",
      "library": "comby",
      "description": "This module provides core components for working with LaTeX documents by defining syntax elements and language metadata. It includes delimiters for LaTeX macros, support for escapable and raw strings, and comment handling, enabling tasks like command recognition and string processing. The module also exposes metadata such as the language name and common file extensions for identification and integration into document processing pipelines. Example uses include parsing LaTeX source to extract commands, sanitizing strings, and determining file type based on extension.",
      "description_length": 571,
      "index": 130,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "Comby.Matchers.Omega.Make",
      "library": "comby",
      "description": "This module implements template-based matching for structured text, providing functions to find all or the first match of a template within a source string. It operates on strings using a specified configuration, optional file path, and rule, supporting recursive matching when enabled. Use cases include parsing and transforming code or structured data by identifying specific patterns within text.",
      "description_length": 399,
      "index": 131,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Omega.Pascal",
      "library": "comby",
      "description": "This module implements matching functionality for Pascal code using a custom template syntax. It provides operations to find all matches or the first match of a template in a source string, supporting recursive matching when enabled. The module works with string inputs and returns structured match results, handling Pascal-specific syntax and structure.",
      "description_length": 354,
      "index": 132,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Omega.Paren",
      "library": "comby",
      "description": "This module provides functions to match templates within source code, specifically supporting recursive and first-match searches. It operates on strings for both template and source inputs, returning lists of matches or individual match results. Use cases include finding all instances of a code pattern in a file or identifying the first occurrence starting from a specific position.",
      "description_length": 384,
      "index": 133,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Omega.Lisp",
      "library": "comby",
      "description": "This module provides functions to match templates against Lisp source code, returning all matches or the first match based on given configuration and file context. It operates on strings representing Lisp code and templates, producing lists of match results or error-handled single matches. Use cases include finding specific syntactic patterns in Lisp code for refactoring or analysis.",
      "description_length": 386,
      "index": 134,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Ruby",
      "library": "comby",
      "description": "This module provides essential metadata and syntax definitions for the Ruby programming language. It includes data types for representing file extensions, string delimiters, escape sequences, and comment styles, along with operations to identify and process Ruby source files. You can use it to detect Ruby files by extension, parse string literals with correct escaping, and analyze or transform Ruby code based on its syntactic structure. For example, it enables building tools that rewrite Ruby strings or extract comments accurately.",
      "description_length": 537,
      "index": 135,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Engine.S-Solidity",
      "library": "comby",
      "description": "This module provides functions to match and find patterns in Solidity source code using templates. It supports operations to find all matches recursively or the first match starting at a specific position, with configuration options for matching behavior. The module works with strings as input source and template code, returning structured match results. Use cases include automated code analysis and transformation tasks specific to Solidity smart contracts.",
      "description_length": 461,
      "index": 136,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Omega.Php",
      "library": "comby",
      "description": "This module provides functions to match PHP code patterns using templates, supporting both full and first-match searches with configurable parameters. It operates on PHP source code strings and leverages a configuration to control matching behavior, such as recursion. Use cases include code analysis, refactoring, and transformation tasks specific to PHP.",
      "description_length": 356,
      "index": 137,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Omega.Julia",
      "library": "comby",
      "description": "This module provides functions to match Julia code against templates, supporting both full and first-match scans with configurable nesting. It operates on strings representing source code and templates, returning structured match results. Use cases include code analysis and transformation tasks specific to Julia, such as finding function definitions or specific syntactic patterns in source files.",
      "description_length": 399,
      "index": 138,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Engine.S-Dyck",
      "library": "comby",
      "description": "This module implements a Dyck language matcher for structured text, providing `all` and `first` functions to find matches of a template within a source string, supporting nested matching when enabled. It works with strings as input and outputs lists or individual match records, with optional configuration and positional control. Use cases include parsing and transforming structured code fragments, such as matching balanced parentheses or nested expressions in a language-aware manner.",
      "description_length": 488,
      "index": 139,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Engine.S-Elm",
      "library": "comby",
      "description": "This module provides functions to match templates against source code, supporting both full and first-match searches with optional configuration and file context. It operates on strings representing templates and source code, returning lists of matches or individual match results. Use cases include finding all occurrences of a code pattern in a file or identifying the first match starting at a specific position.",
      "description_length": 415,
      "index": 140,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Engine.S-Nim",
      "library": "comby",
      "description": "This module implements matching operations for source code using a template-based engine. It provides functions to find all matches or the first match of a template in a source string, supporting nested matching when enabled. The module works with source code strings, templates, and configuration parameters, returning structured match results.",
      "description_length": 345,
      "index": 141,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Alpha.Lisp",
      "library": "comby",
      "description": "This module provides functions to match Lisp code patterns using a template against a source string, supporting both full and first-match searches with optional nested matching. It operates on strings representing Lisp code and templates, returning structured match results. Use cases include finding specific function calls, macros, or syntactic structures in Lisp codebases for analysis or transformation tasks.",
      "description_length": 413,
      "index": 142,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Engine.S-CSS",
      "library": "comby",
      "description": "This module provides functions to match CSS templates against source code, supporting both full and first-match searches with optional configuration and file context. It operates on strings representing CSS templates and source content, returning structured match results. Use cases include finding specific CSS patterns in stylesheets, such as locating all instances of a selector or identifying the first occurrence of a rule starting at a given position.",
      "description_length": 457,
      "index": 143,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Alpha.Rust",
      "library": "comby",
      "description": "This module implements Rust-specific pattern matching over source code using structural templates. It supports finding all matches or the first match of a template in a source string, with optional recursive matching on nested structures. The module works with string-based source code inputs and returns structured match results, enabling precise code analysis and transformation tasks.",
      "description_length": 387,
      "index": 144,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Swift",
      "library": "comby",
      "description": "This module provides metadata and syntax definitions for the Swift programming language. It includes data types for representing file extensions, string delimiters, and comment structures, along with operations to identify Swift source files and parse Swift code elements. For example, it enables tools to recognize `.swift` files, process string literals with custom delimiters, and distinguish between different comment styles in Swift code.",
      "description_length": 443,
      "index": 145,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Alpha.Make",
      "library": "comby",
      "description": "This module implements template-based matching for structured text, providing operations to find all matches or the first match of a template within a source string. It works with strings as input and produces lists of match results or individual match results with error handling. Use cases include parsing and transforming code or structured data using declarative templates.",
      "description_length": 377,
      "index": 146,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Alpha.Ruby",
      "library": "comby",
      "description": "This module provides functions to match Ruby code against templates, returning all matches or the first match with optional configuration and file context. It operates on Ruby source code strings and supports recursive matching when enabled. Use cases include code analysis and transformation tasks specific to Ruby, such as finding method calls or code patterns in Ruby files.",
      "description_length": 377,
      "index": 147,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Omega.Reason",
      "library": "comby",
      "description": "This module provides functions to find all or the first match of a template in a source string, supporting nested matching and language-specific configurations. It works with strings as input and returns lists of matches or error-handled single matches, along with metadata like file extensions and language name. It is used to implement language-specific pattern matching for code transformation tools, where templates define syntactic patterns to locate in source code.",
      "description_length": 471,
      "index": 148,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.C_nested_comments",
      "library": "comby",
      "description": "This module handles parsing and configuration for languages with nested comments and complex string literals. It defines delimiter pairs for nested structures, escapable and raw string markers, and comment syntax, along with metadata for language variants, including names and file extensions. Operations include identifying nested comment boundaries, parsing string literals with escapes or raw indicators, and associating file extensions with specific language configurations. For example, it can correctly parse a C-like source file containing nested `/* */` comments and distinguish raw string boundaries marked by `R\"()\"`.",
      "description_length": 627,
      "index": 149,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Languages.Xml",
      "library": "comby",
      "description": "This module handles XML metadata and syntax configuration, enabling identification of XML files through language names and extensions, and defining parsing rules for XML content. Key data types include language identifiers, file extensions, delimiter pairs, and comment structures, with operations for file type detection, parser configuration, and handling embedded expressions. It allows setting custom XML delimiters, defining comment syntax, and determining XML document type based on extension. For example, it can label XML files in a processing pipeline or configure a parser to correctly handle XML templates with embedded code.",
      "description_length": 636,
      "index": 150,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Omega.Kotlin",
      "library": "comby",
      "description": "This module provides functions to match code patterns in Kotlin source code using templates. It supports finding all matches, potentially with nested recursion, or locating the first match starting at a specified position. The module works with strings as input sources and templates, returning lists of matches or error-handled single matches.",
      "description_length": 344,
      "index": 151,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Metasyntax.Default",
      "library": "comby",
      "description": "This module defines the default metasyntax configuration for parsing and matching code patterns. It provides a list of hole syntax definitions, an identifier string, and a list of aliases used to represent placeholders and special constructs in pattern matching. It is used directly in code transformation and analysis tools that rely on structured syntax matching.",
      "description_length": 365,
      "index": 152,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Engine.S-C_nested_comments",
      "library": "comby",
      "description": "This module implements comment-aware template matching for source code, supporting nested matches within comments. It operates on strings representing source code and templates, producing lists of matches or individual match results. Use it to find code patterns while respecting language-specific comment syntax.",
      "description_length": 313,
      "index": 153,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Alpha.Javascript",
      "library": "comby",
      "description": "This module provides functions to match JavaScript code patterns using templates, supporting both full and first-match scans. It works with string-based source code and configuration parameters to identify matches, with support for recursive matching in nested structures. Use cases include finding specific function calls, variable declarations, or syntax patterns in JavaScript files for analysis or transformation tasks.",
      "description_length": 423,
      "index": 154,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Engine.S-Julia",
      "library": "comby",
      "description": "This module provides functions to find all or the first matches of a template in Julia source code, supporting nested matching when enabled. It operates on strings representing the template and source code, returning lists of match results or individual match outcomes. Use cases include pattern-based code analysis and transformation tasks specific to Julia syntax.",
      "description_length": 366,
      "index": 155,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Alpha.JSON",
      "library": "comby",
      "description": "This module provides functions to match JSON templates against source code, specifically `all` to find all matches recursively and `first` to locate the first match starting at a given position. It operates on strings representing JSON structures and returns match results in the form of `Comby.match'` lists or optional errors. Use cases include searching for specific JSON patterns in configuration files or validating JSON content structure.",
      "description_length": 444,
      "index": 156,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Alpha.Php",
      "library": "comby",
      "description": "This module provides functions to match PHP code patterns using templates, supporting both full and first-match scans with configurable starting positions. It operates on PHP source code strings and returns structured match results, with options to control matching behavior through configuration parameters. Use cases include code analysis, transformation, and refactoring tasks specific to PHP, such as identifying function calls or code structures in PHP files.",
      "description_length": 464,
      "index": 157,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Languages.JSONC",
      "library": "comby",
      "description": "This module provides metadata and syntax definitions for working with JSONC files, including language identifiers, file extensions, and customizable parsing rules. It supports operations like recognizing JSONC content by extension or name, defining delimiters, handling string literals, and specifying comment styles. Examples include building custom JSONC parsers, validating file formats, and transforming JSONC content with precise syntax control.",
      "description_length": 450,
      "index": 158,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Omega.Move",
      "library": "comby",
      "description": "This module provides functions to find all or the first match of a template in a source string, supporting nested matching and language-specific configurations. It works with strings as input for templates and sources, returning lists of matches or individual match results. Use cases include identifying specific code patterns in source files for refactoring or analysis, such as locating function calls or variable declarations in a given language.",
      "description_length": 450,
      "index": 159,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Alpha.Java",
      "library": "comby",
      "description": "This module provides functions to match Java code against templates, returning all matches or the first match found. It operates on Java source code strings and supports recursive matching when enabled. Use cases include code analysis and transformation tasks specific to Java, such as finding method invocations or class declarations.",
      "description_length": 335,
      "index": 160,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.JSON",
      "library": "comby",
      "description": "This module provides metadata and syntax definitions for working with JSON files, enabling identification through file extensions and configuration of parsing rules. It includes data types such as string pairs for delimiters, options for escapable literals, and lists of comment styles, supporting precise parsing and transformation. Examples include detecting JSON files by extension, customizing string literal handling, and configuring comment recognition in analysis tools.",
      "description_length": 477,
      "index": 161,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Python",
      "library": "comby",
      "description": "This module provides essential metadata and syntax definitions for working with Python code. It includes data types for representing language identifiers, file extensions, string delimiters, escape configurations, and comment styles. Operations allow querying file extensions, parsing string literals, and detecting comments based on Python-specific syntax rules. For example, it can identify `.py` files, handle triple-quoted strings, and distinguish single-line and multi-line comments during code analysis.",
      "description_length": 509,
      "index": 162,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Alpha.Csharp",
      "library": "comby",
      "description": "This module provides functions to match C# code patterns using templates, supporting both full and first-occurrence matching with configurable parameters. It operates on string-based source code and template inputs, returning structured match results. Use cases include code analysis, transformation, and querying within C# files using syntactic pattern matching.",
      "description_length": 363,
      "index": 163,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Paren",
      "library": "comby",
      "description": "This module combines syntax configuration and language metadata to support parsing and identifying parenthetical languages. It defines data types for delimiters, string literals, comments, and language properties like name and file extensions. Operations include creating custom syntax configurations, matching code patterns, and retrieving language information based on file extensions. For example, it can configure a Lisp-like syntax with specific parentheses and comments, or identify a file as belonging to a particular language based on its extension.",
      "description_length": 557,
      "index": 164,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Alpha.JSONC",
      "library": "comby",
      "description": "This module provides functions to match JSONC (JSON with comments) content using templates, supporting both full and first-match scans. It operates on strings for both source and template inputs, with options to control matching behavior like nesting and starting position. Use cases include parsing and transforming JSONC configurations or data files with structural queries.",
      "description_length": 376,
      "index": 165,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Engine.S-Move",
      "library": "comby",
      "description": "This module performs structural matching of code templates against source code, supporting both full and first-match scans with configurable nesting. It operates on strings representing code templates and source input, returning lists or individual match records with positional and contextual details. Use cases include finding all instances of a code pattern in a file or identifying the first occurrence starting at a specific offset for targeted transformations.",
      "description_length": 466,
      "index": 166,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Alpha.C",
      "library": "comby",
      "description": "This module provides functions to match and find patterns in C source code using templates. It supports operations to find all matches recursively or the first match starting at a specific position, working with strings as input source and template code. The module handles C language syntax and file extensions like `.c` and `.h`, enabling concrete use cases such as code refactoring and static analysis in C projects.",
      "description_length": 419,
      "index": 167,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Alpha.Jsx",
      "library": "comby",
      "description": "This module provides functions to match and find patterns in JSX source code using templates. It supports finding all matches recursively or the first match starting at a specific position, and it identifies the language name and supported file extensions. Use cases include analyzing or transforming JSX code by locating specific syntax structures within a given source.",
      "description_length": 371,
      "index": 168,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Engine.S-Csharp",
      "library": "comby",
      "description": "This module implements template-based matching for C# code, providing functions to find all matches or the first occurrence of a template within a source string. It operates on C# syntax trees, supporting nested matching when enabled, and returns detailed match information. Use cases include code analysis, refactoring tools, and static pattern detection in C# files.",
      "description_length": 368,
      "index": 169,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.HCL",
      "library": "comby",
      "description": "This module provides the core syntax definitions and language metadata for working with HCL configurations. It includes precise syntactic patterns for parsing and matching HCL elements such as delimiters, string literals, and comments, along with identifiers like the language name and common file extensions. These components support tasks like configuration analysis, file recognition, and custom tooling integration. For example, you can use the syntax patterns to build a linter that enforces HCL style rules or detect HCL files by their `.hcl` extension.",
      "description_length": 559,
      "index": 170,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Languages.SQL",
      "library": "comby",
      "description": "This module provides metadata and syntax configurations for SQL language processing. It includes data types for file extensions, delimiters, string literals, and comments, along with operations to identify SQL files and parse SQL code patterns. You can use it to build tools that analyze, transform, or match SQL queries based on file extension or syntax conventions. For example, it enables recognizing SQL files by `.sql` extension or parsing queries with user-defined delimiters and comment styles.",
      "description_length": 501,
      "index": 171,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Omega.Nim",
      "library": "comby",
      "description": "This module provides functions to match templates against source code in the Nim language, supporting both full and first-match searches with configurable nesting. It operates on strings for templates and source code, returning lists of matches or individual match results. Use cases include finding specific code patterns in Nim files for analysis or transformation tasks.",
      "description_length": 373,
      "index": 172,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Dart",
      "library": "comby",
      "description": "This module provides precise syntactic definitions and language metadata for working with Dart code. It includes patterns for parsing Dart-specific syntax elements like string literals, comments, and delimiters, along with identifiers such as the language name and `.dart` file extensions. Developers can use these components to build tools like linters, code analyzers, or editor integrations that require accurate Dart syntax handling and file recognition. For example, a linter could use the syntax patterns to detect malformed string escapes, or an editor could use the metadata to highlight `.dart` files correctly.",
      "description_length": 620,
      "index": 173,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Rust",
      "library": "comby",
      "description": "This module provides language-specific definitions and metadata for working with Rust code. It includes configurations for parsing Rust syntax, such as delimiters, string literals, and comments, along with identifiers like the language name and file extensions. These components enable accurate code analysis, transformation, and file handling for Rust source files. For example, it supports matching Rust patterns with proper syntax rules and identifying Rust files by `.rs` extensions.",
      "description_length": 487,
      "index": 174,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Omega.JSON",
      "library": "comby",
      "description": "This module provides functions to match JSON templates against source strings, supporting both full and first-match searches with optional configuration and file context. It operates on JSON data structures, returning lists of matches or individual match results. Use cases include parsing and transforming JSON content based on structural patterns, such as extracting specific fields or modifying nested objects.",
      "description_length": 413,
      "index": 175,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Erlang",
      "library": "comby",
      "description": "This module combines syntactic and metadata definitions for Erlang, enabling precise code analysis and file identification. It includes data types for delimiters, string literals, comments, and file extensions, along with operations to parse and match Erlang-specific syntax patterns. You can use it to build custom parsers, linters, or file type detectors tailored to Erlang. For example, identify Erlang source files by extension or validate and transform Erlang code using its specific syntax rules.",
      "description_length": 502,
      "index": 176,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Fortran",
      "library": "comby",
      "description": "This module provides core components for working with Fortran source files by defining syntax rules and language metadata. It includes support for parsing and matching Fortran code using custom delimiters, string literals, and comment styles, along with direct access to Fortran's file extensions and language name. You can use it to build code transformation tools, configure language-specific file handlers, or create precise pattern matchers for Fortran codebases. For example, it enables identifying Fortran files by extension or extracting and manipulating string content within Fortran source files.",
      "description_length": 605,
      "index": 177,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Julia",
      "library": "comby",
      "description": "This module provides essential metadata and syntax definitions for the Julia programming language. It includes data types for representing language name, file extensions, string delimiters, and comment styles, along with operations to access and match these elements. For example, it enables identifying Julia source files by extension, parsing string literals with correct escaping, and recognizing comment boundaries in Julia code.",
      "description_length": 433,
      "index": 178,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Tsx",
      "library": "comby",
      "description": "This module provides language-specific parsing rules and metadata for working with TSX code. It defines delimiters, string literals, comments, and file extensions to support accurate analysis, transformation, and recognition of TSX files. You can use it to identify valid TSX syntax elements, handle string escaping, and detect TSX files by extension or name. For example, it enables tools to correctly parse JSX-style tags and distinguish TSX from other languages based on its .tsx extension.",
      "description_length": 493,
      "index": 179,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Engine.S-Fsharp",
      "library": "comby",
      "description": "This module provides functions to find all or the first matches of a template in F# source code, supporting nested matching and starting position control. It operates on strings for both template and source code inputs, returning lists of matches or error-handled single matches. Use cases include syntax-based code transformation and targeted pattern extraction in F# files.",
      "description_length": 375,
      "index": 180,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Languages.Bash",
      "library": "comby",
      "description": "This module provides a structured representation of Bash script syntax and language metadata. It includes data types for defining delimiters, string literals, and escapable characters, along with operations for parsing and transforming Bash code. The module also exposes Bash-specific identifiers and file extensions for language detection and file processing. For example, it enables customizing string parsing rules or determining if a file is a Bash script based on its extension.",
      "description_length": 483,
      "index": 181,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Engine.S-Scala",
      "library": "comby",
      "description": "This module provides functions to find all or the first matches of a template in a source string, supporting nested matching and positional starting points. It works with strings as input and returns lists or optional match results, tailored for specific languages with associated file extensions. Concrete use cases include parsing and transforming code in a given language by identifying structural patterns through templates.",
      "description_length": 428,
      "index": 182,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Languages.Kotlin",
      "library": "comby",
      "description": "This module provides essential metadata and syntax definitions for the Kotlin language. It includes data types for representing language-specific elements such as file extensions, string literals, delimiters, and comments. Operations allow tools to identify Kotlin files, parse code structure, and handle string formatting. For example, it enables recognizing `.kt` files, distinguishing single-quoted and triple-quoted strings, and processing line and block comments correctly.",
      "description_length": 478,
      "index": 183,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Matcher.S",
      "library": "comby",
      "description": "This module provides functions to find all or the first match of a template in a source string, supporting nested matching and language-specific configurations. It works with strings as input and returns lists or individual match records, along with metadata like file extensions and language name. Use cases include parsing and transforming code in specific languages by matching structural patterns in source files.",
      "description_length": 417,
      "index": 184,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Pascal",
      "library": "comby",
      "description": "This module provides language metadata and syntax definitions for Pascal, enabling file recognition, configuration, and syntactic analysis. It includes data types for specifying extensions, string literals, delimiters, and comments, along with operations to query and apply these definitions. Use it to identify Pascal source files, parse Pascal code, or configure editors with language-specific settings. Example tasks include validating file extensions, extracting comments, or handling string syntax in code processing tools.",
      "description_length": 528,
      "index": 185,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Engine.S-Elixir",
      "library": "comby",
      "description": "This module provides functions to find all or the first matches of a template in Elixir source code, supporting nested matching through configuration. It operates on strings for both template and source input, returning lists of matches or individual match results. Use cases include pattern-based code analysis and transformation tasks specific to Elixir syntax.",
      "description_length": 363,
      "index": 186,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Omega.Typescript",
      "library": "comby",
      "description": "This module provides functions to match TypeScript code patterns using templates, supporting both full and first-match scans. It operates on strings representing source code and templates, returning structured match results. Use cases include code analysis, refactoring, and transformation tasks specific to TypeScript.",
      "description_length": 319,
      "index": 187,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Zig",
      "library": "comby",
      "description": "This module provides essential metadata and syntax configuration for the Zig programming language. It includes data types for representing Zig's canonical name, file extensions, string literals, and comment styles, along with operations to access and match these elements. Use it to integrate Zig-specific naming, file handling, and syntax parsing into tools like linters, formatters, or build systems. For example, retrieve Zig's file extensions or configure a parser to correctly handle Zig's comment syntax.",
      "description_length": 510,
      "index": 188,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Omega.Matlab",
      "library": "comby",
      "description": "This module provides functions to match templates against MATLAB source code, returning all matches or the first match based on provided configuration. It operates on strings representing source code and templates, and returns structured match results. Use cases include finding specific code patterns in MATLAB files for analysis or transformation tasks.",
      "description_length": 355,
      "index": 189,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Omega.Python",
      "library": "comby",
      "description": "This module provides functions to match Python code against templates, supporting both full and first-match searches with configurable parameters. It operates on strings representing source code and templates, returning structured match results. Use cases include code analysis and transformation tasks where precise syntactic matching is required.",
      "description_length": 348,
      "index": 190,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Alpha.Xml",
      "library": "comby",
      "description": "This module provides functions to match XML templates against source code, supporting both full and first-match searches with optional configuration and file context. It operates on strings representing XML structures and returns lists or individual match results. Use cases include parsing and analyzing XML-based languages or documents, such as HTML or configuration files, to extract specific patterns or validate structure.",
      "description_length": 427,
      "index": 191,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Solidity",
      "library": "comby",
      "description": "This module provides essential metadata and syntax definitions for working with the Solidity programming language. It includes data types representing language identifiers, file extensions, string literals, and comment structures, enabling accurate parsing and analysis of Solidity code. Operations allow tooling to recognize source files, extract syntax elements, and handle complex constructs like inline assembly and ABI encoding. For example, it can be used to implement a parser that correctly identifies Solidity-specific syntax or to configure an editor to recognize and highlight Solidity source files.",
      "description_length": 610,
      "index": 192,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Alpha.Kotlin",
      "library": "comby",
      "description": "This module provides functions to match and find occurrences of code templates within Kotlin source code, supporting recursive matching when enabled. It operates on strings representing source code and templates, returning structured match results. Use cases include code analysis, transformation, and refactoring tasks specific to Kotlin.",
      "description_length": 339,
      "index": 193,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Alpha.Tsx",
      "library": "comby",
      "description": "This module provides functions to match templates against TypeScript JSX (TSX) source code, returning all matches or the first match based on provided configuration. It operates on strings representing templates and source code, producing lists of match results or error-aware single matches. Use cases include searching for patterns in TSX files during code analysis or transformation tasks.",
      "description_length": 392,
      "index": 194,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Omega.Swift",
      "library": "comby",
      "description": "This module provides functions to match Swift code patterns using templates, supporting both full and first-match scans with configurable parameters. It operates on Swift source code strings and returns structured match results. Use cases include code analysis, transformation, and querying specific Swift syntax structures.",
      "description_length": 324,
      "index": 195,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Omega.Bash",
      "library": "comby",
      "description": "This module provides functions to match and find patterns in Bash source code using templates. It supports operations to find all matches recursively or the first match starting at a specific position, and it identifies the language name and associated file extensions. Use cases include analyzing or transforming Bash scripts by locating specific syntactic structures.",
      "description_length": 369,
      "index": 196,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Alpha.Latex",
      "library": "comby",
      "description": "This module provides functions to match LaTeX content using a template, supporting both full and first-occurrence searches within a source string. It operates on strings and returns structured match results, with options to control matching behavior such as nesting and starting position. It is suitable for tasks like parsing and transforming LaTeX documents based on specific patterns.",
      "description_length": 387,
      "index": 197,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Assembly",
      "library": "comby",
      "description": "This module provides configurations for parsing and identifying assembly languages, supporting customizable syntax elements like delimiters, string literals, and comments. It includes data types for representing language metadata such as names and file extensions, enabling dialect-specific parsing and toolchain integration. You can use it to define new assembly syntax rules, associate file types with languages, or extend parser support for different assemblers. For example, configure a parser to recognize a custom assembly dialect with specific comment markers or determine the language of a file based on its extension.",
      "description_length": 626,
      "index": 198,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Engine.S-Go",
      "library": "comby",
      "description": "This module implements matching operations for Go source code, providing functions to find all matches or the first match of a template within a source string. It operates on strings representing code and templates, returning structured match results with optional recursive matching on nested content. Use cases include code analysis and transformation tasks where precise syntactic matches are required in Go files.",
      "description_length": 417,
      "index": 199,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Engine.S-Kotlin",
      "library": "comby",
      "description": "This module provides functions to find all or the first matches of a template in Kotlin source code, supporting nested matching when enabled. It operates on strings representing the template and source code, returning lists of match results or individual match results with error handling. Use cases include code analysis and transformation tasks where specific Kotlin syntax patterns need to be identified.",
      "description_length": 407,
      "index": 200,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Alpha.C_nested_comments",
      "library": "comby",
      "description": "This module provides functions to match templates in C source code, specifically handling nested comments. It works with strings as input source code and templates, returning lists of matches or the first match found. Use cases include finding all instances of a code pattern in C files, or locating the first occurrence starting at a specific position.",
      "description_length": 353,
      "index": 201,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Alpha.Nim",
      "library": "comby",
      "description": "This module implements matching functionality for Nim source code, providing operations to find all matches or the first match of a template within a source string. It works with string-based templates and source code, returning lists of match results or error-aware single matches. Use cases include pattern-based code analysis and transformation tasks specific to Nim, such as identifying or rewriting code structures in Nim files.",
      "description_length": 433,
      "index": 202,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Engine.S-Matlab",
      "library": "comby",
      "description": "This module provides functions to find all or the first match of a template in a source string, supporting nested matching when enabled. It works with strings as input and returns lists of matches or individual match results, along with configuration options like file path and matching rules. It is used for pattern matching in source code, particularly for MATLAB files, enabling precise match location and analysis.",
      "description_length": 418,
      "index": 203,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Alpha.R",
      "library": "comby",
      "description": "This module provides functions to match templates against source code using a language-specific matcher. It supports finding all matches recursively or the first match starting at a specific position, and it identifies the language by name and supported file extensions. Use cases include parsing and transforming code in specific programming languages using pattern templates.",
      "description_length": 377,
      "index": 204,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Elm",
      "library": "comby",
      "description": "This module provides metadata and syntax definitions for working with the Elm programming language. It exposes the language name, file extensions, and syntactic elements such as string delimiters, escape sequences, and comment markers. These components enable accurate parsing, file identification, and syntax handling for Elm source code in tooling applications. For example, it allows a code processor to recognize Elm files by extension and correctly parse multiline comments or string literals.",
      "description_length": 498,
      "index": 205,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Alpha.Elm",
      "library": "comby",
      "description": "This module provides functions to match templates against Elm source code, returning all matches or the first match based on configuration and starting position. It operates on strings representing templates and source code, and it supports nested matching through a recursive descent approach. Use cases include finding specific syntactic patterns in Elm files for refactoring or static analysis tasks.",
      "description_length": 403,
      "index": 206,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Engine.S-Generic",
      "library": "comby",
      "description": "This module provides functions to find all matches or the first match of a template in a source string, supporting nested matching and positional starting points. It works with strings as input for templates and sources, and returns lists of matches or error-handled single matches. It is used for pattern matching in source code, particularly for languages with defined extensions, and includes metadata like matcher name and supported file extensions.",
      "description_length": 453,
      "index": 207,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Omega.Xml",
      "library": "comby",
      "description": "This module provides functions to match XML templates against source code, supporting both full and first-match scans with configurable starting positions. It operates on XML structures and works with strings as input templates and sources, returning lists of matches or individual match results. Use cases include parsing and analyzing XML-based languages, such as HTML or configuration files, to identify specific structural patterns for transformation or validation.",
      "description_length": 469,
      "index": 208,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Engine.S-Java",
      "library": "comby",
      "description": "This module provides functions to find all or the first matches of a template in Java source code, supporting nested matching when enabled. It operates on strings for both template and source input, returning lists or individual match results. Use cases include searching for specific code patterns in Java files, such as method calls or variable declarations, during analysis or refactoring tasks.",
      "description_length": 398,
      "index": 209,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Engine.S-Swift",
      "library": "comby",
      "description": "This module performs structural matching of code templates within Swift source code, providing precise pattern recognition based on syntactic rules. It supports finding all matches recursively or identifying the first match starting at a specified position, operating on strings for both template and source input. It is used for tasks like code analysis, refactoring, and transformation in Swift projects.",
      "description_length": 406,
      "index": 210,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Alpha.Html",
      "library": "comby",
      "description": "This module provides functions to match HTML templates against source code, with support for nested matching and finding first occurrences. It operates on strings representing HTML templates and source content, returning structured match results. Use cases include extracting or validating HTML structure, such as finding all table rows or specific tag sequences within a document.",
      "description_length": 381,
      "index": 211,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Metasyntax.S",
      "library": "comby",
      "description": "This module defines a parameterized matcher interface with operations to specify hole syntax, identifier patterns, and alias mappings. It works with lists of hole syntax configurations and alias definitions to customize pattern matching behavior. Concrete use cases include defining custom syntax rules for code transformation tools and specifying structured pattern-matching directives in parsing applications.",
      "description_length": 411,
      "index": 212,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Alpha.Haskell",
      "library": "comby",
      "description": "This module provides functions to match Haskell code snippets using a template, returning all matches or the first match found in a given source. It operates on strings representing Haskell code and templates, supporting nested matching when enabled. Use cases include finding specific function definitions, code patterns, or syntactic structures within Haskell files.",
      "description_length": 368,
      "index": 213,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Engine.S-Text",
      "library": "comby",
      "description": "This module performs structural text matching using templates and source code, supporting operations to find all matches or the first match at a specific position. It works with strings as input and produces lists of match results or individual match results with error handling. It is used for language-specific pattern matching in code analysis, leveraging configuration and rule parameters to tailor matching behavior.",
      "description_length": 421,
      "index": 214,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.C",
      "library": "comby",
      "description": "This module provides configurations and metadata for processing C source code, supporting accurate parsing and identification of C files. It includes syntax definitions for handling C-specific constructs like string literals, escape sequences, and comments, along with standard file extensions such as `.c` and `.h`. You can use it to build custom parsers or configure tools that recognize and process C code based on language rules and file types. For example, it enables defining delimiters for string parsing or identifying C source files in a build system.",
      "description_length": 560,
      "index": 215,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Omega.Go",
      "library": "comby",
      "description": "This module provides functions to find all or the first match of a template in a source string, supporting nested matching and language-specific configurations. It works with strings as input and returns structured match results, along with metadata like file extensions and matcher name. It is used to implement language-specific pattern matching for code transformation and analysis tasks.",
      "description_length": 391,
      "index": 216,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Alpha.Zig",
      "library": "comby",
      "description": "This module provides functions to match templates against source code in the Zig programming language. It supports finding all matches recursively or the first match starting at a specific position, using configuration options and file context. The module works with strings for templates and source code, returning lists of matches or error-handled single matches.",
      "description_length": 365,
      "index": 217,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Engine.S-Paren",
      "library": "comby",
      "description": "This module performs structural matching of code templates within source code, supporting nested matches through recursive traversal. It operates on strings representing code templates and source input, returning lists of match results with contextual details. It is used to identify specific syntactic patterns in code, such as finding all instances of a function call or expression structure in a given source file.",
      "description_length": 417,
      "index": 218,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Text",
      "library": "comby",
      "description": "This module organizes text language metadata and syntax configurations, enabling identification and processing of text files based on language-specific properties. It uses strings and lists to manage file extensions and language names, while supporting customizable delimiters, string literals, and comment styles for parsing. You can map extensions to languages, define how strings and comments are structured in different languages, and configure text processing tools for tasks like templating or source analysis. For example, it can associate `.ml` with OCaml and define its comment syntax for accurate parsing.",
      "description_length": 615,
      "index": 219,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Haskell",
      "library": "comby",
      "description": "This module provides syntactic and metadata support for working with Haskell code. It includes precise definitions for parsing Haskell's syntax elements\u2014such as delimiters, string literals, and comments\u2014as well as utilities to identify Haskell source files via common file extensions. You can use it to build tools like linters, formatters, or file processors that require accurate Haskell syntax handling and language identification. For example, it enables detecting Haskell files by extension or parsing multi-line comments for documentation extraction.",
      "description_length": 556,
      "index": 220,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Omega.Generic",
      "library": "comby",
      "description": "This module provides functions to find all or the first match of a template in a source string, supporting nested matching when enabled. It works with strings as input and returns lists of matches or individual match results, along with configuration options like file path and matching rules. It is used for pattern matching in source code, particularly for language-specific templates tied to file extensions.",
      "description_length": 411,
      "index": 221,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Nim",
      "library": "comby",
      "description": "This module combines syntax and metadata definitions for the Nim programming language. It includes data types for representing syntax elements such as delimiters, string literals, and comments, along with operations for parsing and matching Nim code patterns. The module also provides access to language metadata like the name and file extensions, enabling file type detection and tooling integration. Examples include building custom syntax highlighters, linters, or code transformation tools that process Nim source files based on their specific syntax and naming conventions.",
      "description_length": 578,
      "index": 222,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Engine.S-Zig",
      "library": "comby",
      "description": "This module provides functions to find all or the first matches of a template in a source string, supporting nested matching and positional shifting. It works with strings as input and outputs lists of matches or individual match results, along with metadata like name and file extensions. It is used to implement language-specific pattern matching for code transformation tools, targeting specific file types like Zig source files.",
      "description_length": 432,
      "index": 223,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.External.S",
      "library": "comby",
      "description": "This module defines an external matcher interface with a `handler` value that processes structured data inputs according to predefined matching rules. It operates on abstract syntax trees and pattern definitions, enabling precise code transformation and analysis tasks. Concrete use cases include implementing custom parsing and rewriting logic for domain-specific languages or code refactoring tools.",
      "description_length": 401,
      "index": 224,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Matlab",
      "library": "comby",
      "description": "This module provides essential metadata and syntax definitions for working with MATLAB code. It includes data types for representing MATLAB's language name, file extensions, string literals, delimiters, and comment structures. Operations allow querying file associations, parsing MATLAB syntax elements, and handling string escaping and comments accurately. For example, it enables tools like linters or formatters to correctly interpret and manipulate MATLAB source files based on their specific syntactic rules.",
      "description_length": 513,
      "index": 225,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Engine.S-Pascal",
      "library": "comby",
      "description": "This module implements matching operations for Pascal language code using a specific template syntax. It provides functions to find all matches or the first match of a template in a source string, supporting recursive matching when enabled. The module works with Pascal source code strings and handles language-specific syntax through its configuration.",
      "description_length": 353,
      "index": 226,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Omega.Javascript",
      "library": "comby",
      "description": "This module provides functions to match JavaScript code patterns using templates, supporting both full and first-match scans with configurable nesting. It operates on JavaScript source code strings and returns structured match results. Use cases include code analysis, refactoring tools, and static pattern detection in JavaScript files.",
      "description_length": 337,
      "index": 227,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Omega.Assembly",
      "library": "comby",
      "description": "This module provides functions to find all or the first match of a template in a source string, supporting nested matching and language-specific configurations. It works with strings as input for templates and sources, returning lists of matches or individual match results. Use cases include pattern matching in code files for languages like C or Go, where specific file extensions and configuration settings are required.",
      "description_length": 423,
      "index": 228,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Dhall",
      "library": "comby",
      "description": "This module provides metadata and syntax definitions for the Dhall configuration language. It includes data types for language identifiers, file extensions, delimiters, string literals, and comment styles, enabling precise parsing and processing of Dhall code. Operations allow tools to associate files with the Dhall language, parse custom delimiters, handle string escaping, and recognize comments. Examples include configuring a linter to correctly parse Dhall files or determining if a file path corresponds to the Dhall language.",
      "description_length": 534,
      "index": 229,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Languages.Elixir",
      "library": "comby",
      "description": "This module provides metadata and syntax definitions for the Elixir programming language. It includes data types for language name, file extensions, string literals, delimiters, and comments, along with operations to access and match these elements. You can use it to identify Elixir files by extension, parse string boundaries, or skip comments in Elixir code. For example, it enables tools to detect valid Elixir source files and correctly handle multiline strings or custom delimiters during code analysis.",
      "description_length": 509,
      "index": 230,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Omega.Elixir",
      "library": "comby",
      "description": "This module provides functions to match Elixir code patterns using templates, supporting both full and first-match scans with optional nested matching. It operates on Elixir source code strings and returns structured match results. Use cases include code analysis, refactoring tools, and static pattern detection in Elixir projects.",
      "description_length": 332,
      "index": 231,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Omega.Fsharp",
      "library": "comby",
      "description": "This module provides functions to find all or the first match of a template in F# source code, supporting recursive matching when enabled. It operates on strings for both template and source inputs, returning lists of match results or individual match errors. The module identifies as \"F#\" with associated file extensions and allows setting a rewrite template for future operations.",
      "description_length": 382,
      "index": 232,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Engine.S-Coq",
      "library": "comby",
      "description": "This module provides functions to match templates against source code, supporting both full and first-match searches with optional configuration and nested matching. It operates on strings representing templates and source code, returning lists of matches or individual match results. Use cases include finding all occurrences of a pattern in a file or identifying the first match starting at a specific position.",
      "description_length": 413,
      "index": 233,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Comby.Matchers.Engine.S-Php",
      "library": "comby",
      "description": "This module provides functions to match PHP code patterns using templates, supporting both full and first-match scans. It operates on PHP source code strings and returns structured match results with optional nested matching. Use cases include code analysis, refactoring, and transformation tasks specific to PHP.",
      "description_length": 313,
      "index": 234,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Engine.S-OCaml",
      "library": "comby",
      "description": "This module provides functions to find all or the first matches of a template in a source string, supporting nested matching and positional shifts. It works with strings as input and returns lists of matches or error-handled single matches, along with metadata like name and file extensions. It is used for pattern matching in source code, particularly for language-specific templates and transformations.",
      "description_length": 405,
      "index": 235,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Typescript",
      "library": "comby",
      "description": "This module provides metadata and syntax definitions for working with TypeScript source files. It includes data types for language identifiers, file extensions, string delimiters, escape sequences, and comment markers. Operations allow detecting TypeScript files by extension, parsing string literals, handling template interpolations, and recognizing comments. For example, it can identify `.ts` files, extract embedded expressions in template strings, or strip single-line and multi-line comments from code.",
      "description_length": 509,
      "index": 236,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Template.Make",
      "library": "comby",
      "description": "Parses string templates into structured representations and extracts variable names from template syntax. Works with strings and custom syntax definitions to identify placeholders. Useful for building templating engines or code generation tools where variable interpolation is required.",
      "description_length": 286,
      "index": 237,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Omega.Tsx",
      "library": "comby",
      "description": "This module provides functions to match templates against TypeScript JSX (TSX) source code, supporting both full and first-match scans with configurable nesting. It operates on strings representing templates and source code, returning structured match results. Use cases include code analysis and transformation tasks specific to TSX files, such as identifying React component patterns or extracting JSX structures.",
      "description_length": 415,
      "index": 238,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Language.Syntax",
      "library": "comby",
      "description": "This module organizes syntactic elements used for configuring code pattern matching, combining core types for string literals, escape characters, and comments with modular extensions for language-specific rules. It provides data types like `string_literal`, `comment_style`, and `delimiter` to represent and manipulate syntax structures, supporting operations to define escapable or raw strings and various comment formats. Child modules extend these definitions to handle matchers that adapt to different programming languages, enabling precise parsing and transformation of code based on their syntax conventions. For example, you can define a comment style for C that skips multiline comments or configure a delimiter for Go string literals to correctly parse embedded quotes.",
      "description_length": 779,
      "index": 239,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Alpha.Julia",
      "library": "comby",
      "description": "This module provides functions to match Julia code against templates, supporting both full and first-match searches with configurable parameters. It operates on strings representing source code and templates, returning structured match results. Use cases include finding specific code patterns in Julia files for analysis or transformation tasks.",
      "description_length": 346,
      "index": 240,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Alpha.Scala",
      "library": "comby",
      "description": "This module provides functions to match and find occurrences of code templates within Scala source code. It supports operations to find all matches, including nested matches, and to locate the first match starting at a specified position. The module works with string-based templates and source code, returning structured match results, and is used for tasks like code analysis and transformation in Scala projects.",
      "description_length": 415,
      "index": 241,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Engine.S-Html",
      "library": "comby",
      "description": "This module provides functions to match HTML templates against source code, returning all or the first match based on given configuration and rules. It operates on strings representing HTML templates and source content, producing a list or single match result with support for recursive matching. Use cases include identifying structural patterns in HTML for refactoring, analysis, or transformation tasks.",
      "description_length": 406,
      "index": 242,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Omega.SQL",
      "library": "comby",
      "description": "This module provides functions to match SQL code patterns using templates, supporting both full and first-match scans. It operates on SQL source code strings and returns structured match results with optional nested matching. Use cases include finding all instances of a query pattern in a SQL script or locating the first occurrence starting at a specific position.",
      "description_length": 366,
      "index": 243,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Engine.S-Haskell",
      "library": "comby",
      "description": "This module provides functions to find all or the first matches of a template in a source string, supporting nested matching and optional configuration. It works with strings as input for templates and source code, returning lists of matches or individual match results. Use cases include parsing and transforming code by identifying specific syntactic patterns in source files.",
      "description_length": 378,
      "index": 244,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Java",
      "library": "comby",
      "description": "This module provides precise syntactic definitions and metadata for working with Java code. It supports pattern matching and transformation through customizable delimiters, string literals, and comment handling, while also offering access to language identifiers and file extensions. Users can, for example, define custom string escapes to parse Java literals or match specific comment blocks for code analysis. The combination of syntax and metadata enables both structural manipulation and file-level recognition of Java source files.",
      "description_length": 536,
      "index": 245,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Alpha.Matlab",
      "library": "comby",
      "description": "This module provides functions to match templates against MATLAB source code, returning all matches or the first match based on provided configuration. It operates on strings representing source code and templates, and produces a list of match results or a single match result wrapped in an error-handling type. The module supports nested matching, allows specifying a starting position for matching, and includes metadata like the matcher name and associated file extensions.",
      "description_length": 476,
      "index": 246,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Move",
      "library": "comby",
      "description": "This module provides language-specific metadata and syntax definitions for Move, enabling tooling to identify the language and process its code structures accurately. It includes data types for file extensions, delimiters, string literals, and comments, along with operations to access and match these elements. You can use it to configure parsers, build linters, or implement code transformations tailored to Move's syntax. For example, retrieve valid Move file extensions or define patterns for parsing raw strings and comments.",
      "description_length": 530,
      "index": 247,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Omega.Fortran",
      "library": "comby",
      "description": "This module provides functions to match Fortran code against templates, supporting both full and first-match searches with configurable nesting. It operates on Fortran source strings and leverages a configuration to control matching behavior, returning structured match results. Use cases include analyzing or transforming Fortran code by identifying specific syntactic patterns, such as finding all occurrences of a subroutine or the first instance of a variable declaration starting from a given position.",
      "description_length": 507,
      "index": 248,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Alpha.Dart",
      "library": "comby",
      "description": "This module provides functions to match and find Dart language patterns in source code using templates. It supports finding all matches recursively or the first match starting at a specific position, and it identifies the language name and associated file extensions. Use cases include analyzing or transforming Dart code by locating specific syntactic structures defined in templates.",
      "description_length": 385,
      "index": 249,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Engine.S-Bash",
      "library": "comby",
      "description": "This module provides functions to match templates against Bash source code, returning all matches or the first match based on provided configuration. It operates on strings representing source code and templates, and returns structured match results. It is used for analyzing or transforming Bash scripts by identifying specific syntactic patterns.",
      "description_length": 348,
      "index": 250,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Language.Info",
      "library": "comby",
      "description": "This module provides operations for retrieving and configuring language-specific metadata, such as file extensions, delimiters, and syntax rules, using abstract data types that represent programming languages and their parsing configurations. It includes a child module that defines concrete language metadata, enabling identification of source files by extension and tool configuration based on language-specific properties. Main data types include representations of languages and their associated string and list-based metadata, supporting operations like file extension lookup and syntax rule application. Examples include configuring parsers to handle comments or string interpolation according to a language's rules and selecting appropriate parsing strategies based on file extensions.",
      "description_length": 792,
      "index": 251,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Alpha.GraphQL",
      "library": "comby",
      "description": "This module implements a GraphQL-aware matcher for the Comby structural code matching engine. It provides operations to find all matches or the first match of a template in a source string, with optional recursive matching on nested structures. The matcher works with GraphQL AST nodes and leverages language-specific parsing to enable precise structural queries in GraphQL code.",
      "description_length": 379,
      "index": 252,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Engine.S-Python",
      "library": "comby",
      "description": "This module provides functions to find all or the first matches of a template in Python source code, supporting recursive matching when nested. It operates on strings for both template and source code inputs, returning lists of matches or individual match results. Use cases include code analysis and transformation tasks where specific Python code patterns need to be identified.",
      "description_length": 380,
      "index": 253,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Alpha.Assembly",
      "library": "comby",
      "description": "This module implements template-based matching for structured text, providing operations to find all or the first match of a template within a source string. It works with strings as input and produces lists of match results containing detailed position and substitution data. Use cases include parsing and transforming code or structured documents using declarative templates with configurable matching behavior.",
      "description_length": 413,
      "index": 254,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Omega.Rust",
      "library": "comby",
      "description": "This module implements matching operations for source code using templates, specifically tailored for Rust syntax. It provides functions to find all matches or the first match of a template in a source string, supporting recursive matching when enabled. The module works with string-based templates and source code inputs, returning structured match results with metadata.",
      "description_length": 372,
      "index": 255,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Jsx",
      "library": "comby",
      "description": "This module handles the syntax and metadata of JSX, enabling precise parsing and recognition of JSX structures with customizable delimiters, string literals, and comments. It supports operations for analyzing and transforming JSX code based on file extensions or language identifiers. Examples include identifying JSX files by extension, parsing embedded expressions, and applying syntax transformations to JSX templates.",
      "description_length": 421,
      "index": 256,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Alpha.Pascal",
      "library": "comby",
      "description": "This module implements Pascal language-specific pattern matching over source code using structural templates. It provides operations to find all matches or the first match of a template in a given source string, with support for recursive matching on nested structures. The module works with string-based templates and source code, returning match results as structured data, and is used for tasks like code analysis and transformation in Pascal files.",
      "description_length": 452,
      "index": 257,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Engine.S-Dhall",
      "library": "comby",
      "description": "This module provides functions to match templates against source code in the Dhall language. It supports finding all matches, including nested ones, and locating the first match starting at a specified position. The module works with Dhall source strings and templates, returning structured match results. Use cases include code analysis and transformation tasks specific to Dhall configuration files.",
      "description_length": 401,
      "index": 258,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Omega.Dyck",
      "library": "comby",
      "description": "This module implements Dyck language matching for structured code patterns, supporting operations to find all or first matches of a template within a source string. It works with strings as input and outputs lists of match results or individual match results with error handling. Use cases include parsing nested expressions or identifying specific syntactic constructs in source code.",
      "description_length": 385,
      "index": 259,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Engine.S-Typescript",
      "library": "comby",
      "description": "This module provides functions to find all or the first matches of a template in TypeScript source code, supporting recursive matching when enabled. It operates on strings for both template and source code inputs, returning lists of matches or individual match results. Use cases include code analysis and transformation tasks where specific syntactic patterns need to be identified within TypeScript files.",
      "description_length": 407,
      "index": 260,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Alpha.Typescript",
      "library": "comby",
      "description": "This module provides functions to match TypeScript code patterns using templates, supporting both full and first-match scans of source code. It operates on strings representing source code and templates, returning structured match results with optional nested matching. Use cases include code analysis, transformation, and querying within TypeScript files.",
      "description_length": 356,
      "index": 261,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Omega.GraphQL",
      "library": "comby",
      "description": "This module provides functions to match GraphQL templates against source code, supporting both full and first-match scans with configurable parameters. It operates on strings for templates and source input, returning lists of matches or individual match results. Use cases include parsing and transforming GraphQL queries or validating schema structures within codebases.",
      "description_length": 371,
      "index": 262,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Coq",
      "library": "comby",
      "description": "This module provides metadata and syntax configurations for working with Coq source code. It exposes data types representing file extensions, string literals, comments, and custom delimiters, along with operations to query and match these elements. You can use it to identify Coq files, parse strings with escapes, and handle custom syntax like notations or user-defined delimiters in analysis tools. For example, it enables extracting Coq file extensions or configuring parsers to correctly interpret Coq comments and string encodings.",
      "description_length": 536,
      "index": 263,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.GraphQL",
      "library": "comby",
      "description": "This module provides precise parsing and metadata handling for GraphQL documents. It supports customizable string delimiters, escaped and raw literals, and comment processing, enabling tools like linters and formatters to analyze and transform GraphQL schemas and queries. It also includes static metadata such as language name and file extensions, useful for file type detection and configuration. For example, it can parse a GraphQL query with custom string syntax or identify a `.graphql` file based on its extension.",
      "description_length": 520,
      "index": 264,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Engine.S-R",
      "library": "comby",
      "description": "This module provides functions to match templates against source code, supporting both full and first-match scans with configurable parameters. It operates on strings for templates and source code, returning lists of matches or individual match results. Use cases include finding all occurrences of a pattern in a file or identifying the first match starting at a specific position.",
      "description_length": 382,
      "index": 265,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Omega.Coq",
      "library": "comby",
      "description": "This module provides functions to match templates against source code in the Coq language, supporting both full and first-match searches with configurable parameters. It operates on strings representing templates and source code, returning structured match results. Use cases include finding specific syntactic patterns in Coq files for analysis or transformation tasks.",
      "description_length": 370,
      "index": 266,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Alpha.Text",
      "library": "comby",
      "description": "This module implements text-based pattern matching for source code using a customizable template language. It provides operations to find all matches or the first match of a template in a given source string, supporting nested matching when enabled. The module works with raw text input and outputs structured match results, making it suitable for code analysis and transformation tasks.",
      "description_length": 387,
      "index": 267,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Engine.S-Ruby",
      "library": "comby",
      "description": "This module provides functions to find all or the first matches of a template in a Ruby source string, supporting nested matching when enabled. It operates on strings representing Ruby code and templates, returning lists of match results or individual match outcomes. Use cases include searching for specific Ruby code patterns in source files, such as identifying method calls or syntactic structures.",
      "description_length": 402,
      "index": 268,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Omega.Dhall",
      "library": "comby",
      "description": "This module provides functions to match Dhall language patterns in source code using templates. It supports finding all matches, including nested ones, or locating the first match starting at a specific position. The module works with Dhall's syntax and data structures, handling concrete use cases like identifying configuration patterns or extracting expressions in Dhall files.",
      "description_length": 380,
      "index": 269,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.OCaml",
      "library": "comby",
      "description": "This module provides essential metadata and syntax definitions for working with OCaml source files. It includes data types for language identification, such as file extensions and language name, along with syntax elements like delimiters, string literals, and comment markers. Operations allow tools to configure parsers, detect OCaml files, and analyze or transform code based on precise syntactic patterns. For example, it can be used to implement linters that recognize OCaml-specific syntax or to configure an editor's syntax highlighting rules.",
      "description_length": 549,
      "index": 270,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Omega.Csharp",
      "library": "comby",
      "description": "This module implements C#-specific pattern matching over source code using Comby's matching engine. It provides operations to find all matches or the first match of a template in a given source string, with support for recursive matching on nested structures. The module works with C# syntax trees and exposes match results as structured data, enabling precise code analysis and transformation tasks.",
      "description_length": 400,
      "index": 271,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Omega.Haskell",
      "library": "comby",
      "description": "This module provides functions to find all or the first match of a template in a source string, supporting nested matching and optional configuration. It works with strings as input and returns lists of matches or error-handled single matches. Use cases include parsing and transforming code by identifying structural patterns in source files.",
      "description_length": 343,
      "index": 272,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Engine.S-C",
      "library": "comby",
      "description": "This module implements matching operations for C-like syntax, providing functions to find all matches or the first match of a template in a source string. It works with string inputs representing code and templates, returning lists of match results or individual match outcomes. Use cases include pattern-based code analysis and transformation tasks specific to C syntax, such as identifying function calls or variable declarations.",
      "description_length": 432,
      "index": 273,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Omega.Scala",
      "library": "comby",
      "description": "This module provides functions to match Scala code against templates, supporting both full and first-match scans with configurable parameters. It operates on string-based source code and templates, returning structured match results with optional nested matching. Use cases include code analysis, transformation, and pattern extraction in Scala files using precise syntactic matching.",
      "description_length": 384,
      "index": 274,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Engine.S-Fortran",
      "library": "comby",
      "description": "This module provides functions to match templates against Fortran source code, returning lists of matches or the first match found. It operates on strings representing source code and templates, with support for nested matching and positional constraints. Use cases include parsing and transforming Fortran code by identifying specific syntactic patterns within source files.",
      "description_length": 375,
      "index": 275,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Scala",
      "library": "comby",
      "description": "This module provides precise definitions for Scala's syntax elements and file metadata to support code analysis and processing. It includes configurations for handling Scala-specific delimiters, string literals, and comments, along with identifiers such as the language name and file extensions like `.scala`. Main operations involve parsing Scala code structures and recognizing Scala source files based on extension or name. For example, it enables detecting valid Scala files in a build system or correctly parsing multi-line string literals in Scala code.",
      "description_length": 559,
      "index": 276,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Alpha.Reason",
      "library": "comby",
      "description": "This module provides functions to match templates against source code using a language-specific parser, returning all matches or the first match with optional configuration and file context. It operates on strings for both template and source inputs, producing lists of match results or error-handled single matches. Use cases include finding specific code patterns in source files, such as locating function calls or syntax structures in ReasonML code.",
      "description_length": 453,
      "index": 277,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Alpha.CSS",
      "library": "comby",
      "description": "This module provides functions to match CSS templates against source code, supporting both full and first-match searches with optional configuration and file context. It operates on strings representing CSS templates and source content, returning structured match results. Use cases include finding specific CSS patterns in stylesheets, such as locating all instances of a selector or identifying the first occurrence of a rule starting at a given position.",
      "description_length": 457,
      "index": 278,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Engine.S-Reason",
      "library": "comby",
      "description": "This module performs structural matching of code templates against source code, supporting both first-match and all-matches operations with optional nested matching. It works with strings representing code templates and source code, returning lists or individual match records. It is used to find syntactic matches in codebases, such as identifying specific function calls or patterns in source files.",
      "description_length": 401,
      "index": 279,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Engine.S-Jsx",
      "library": "comby",
      "description": "This module provides functions to find all or the first match of a template in a source string, supporting nested matching when enabled. It works with strings as input and returns lists or individual match records, with optional configuration and file context. Use cases include parsing and transforming code in specific languages by matching structural patterns in the source text.",
      "description_length": 382,
      "index": 280,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Alpha.Clojure",
      "library": "comby",
      "description": "This module provides functions to match Clojure code patterns using templates, supporting both full and first-match searches within source code. It operates on strings representing Clojure source code and templates, returning structured match results. Use cases include finding specific function calls, syntax patterns, or code structures in Clojure files for analysis or transformation tasks.",
      "description_length": 393,
      "index": 281,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Alpha.OCaml",
      "library": "comby",
      "description": "This module implements template-based matching and searching over OCaml source code using structural patterns. It supports finding all matches or the first match of a given template in a source string, with optional recursive matching on nested structures. Typical use cases include code analysis, refactoring, and transformation tasks where precise syntactic matching is required.",
      "description_length": 381,
      "index": 282,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Engine.S-Xml",
      "library": "comby",
      "description": "This module performs structural matching of code templates against source code, supporting nested matching when enabled. It works with strings representing code templates and source files, returning lists of matches or individual match results. It is used to find specific syntactic patterns in code, such as identifying function calls or variable declarations in a given source file.",
      "description_length": 384,
      "index": 283,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Javascript",
      "library": "comby",
      "description": "This module provides precise syntax and metadata configurations for JavaScript, enabling accurate parsing and transformation of code. It defines key data types for handling string literals, comments, and language identifiers, along with operations to access extensions and language names. Use it to manage JavaScript syntax elements like template literals and comments, or to integrate JavaScript identification into tools using its name and file extensions. For example, you can extract `.js` and `.jsx` extensions or process multiline comments with specific delimiters.",
      "description_length": 571,
      "index": 284,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Engine.S-GraphQL",
      "library": "comby",
      "description": "This module implements a matcher engine for GraphQL that supports finding all or the first matches of a template in a source string, with optional nested matching. It works with strings as input sources and templates, returning lists of matches or individual match results. Use cases include parsing and transforming GraphQL queries or schemas by identifying specific structural patterns within the source.",
      "description_length": 406,
      "index": 285,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Alpha.Move",
      "library": "comby",
      "description": "This module provides functions to find all or the first match of a template in a source string, supporting nested matching and positional shifting. It operates on strings with optional configuration, file path, and rule parameters, returning lists of matches or individual match results. Use cases include pattern-based code analysis and transformation tasks where specific syntactic structures need to be identified in source code.",
      "description_length": 432,
      "index": 286,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Engine.S-Rust",
      "library": "comby",
      "description": "This module implements matching operations for source code using templates, supporting nested matching and first-occurrence searches. It operates on strings representing source code and templates, producing lists of matches or individual match results. It is used for structural code queries and transformations where precise syntactic matching is required.",
      "description_length": 357,
      "index": 287,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Alpha.Dhall",
      "library": "comby",
      "description": "This module provides functions to match and find occurrences of a template within a source string, specifically tailored for the Dhall configuration language. It supports retrieving all matches, including nested ones, or finding the first match starting at a specified position. The module works with strings as input and outputs structured match results, enabling precise pattern detection in Dhall files.",
      "description_length": 406,
      "index": 288,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Clojure",
      "library": "comby",
      "description": "This module provides metadata and syntax definitions for working with Clojure code. It includes data types for representing language identifiers, file extensions, and syntax constructs such as delimiters, string literals, and comments. Operations allow querying file extensions, parsing Clojure syntax elements, and handling string and comment structures. For example, it enables tools to recognize Clojure files by extension, extract string contents while respecting escapes, or locate and process comment blocks in source code.",
      "description_length": 529,
      "index": 289,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.CSS",
      "library": "comby",
      "description": "This module provides precise parsing and metadata for CSS, enabling accurate manipulation of CSS syntax elements like strings, comments, and delimiters. It includes data types for representing CSS syntax structures and operations for parsing and extracting values from CSS code. Specific uses include processing embedded strings, handling comment blocks, and configuring tools to recognize CSS file types and language identifiers.",
      "description_length": 430,
      "index": 290,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Alpha.Swift",
      "library": "comby",
      "description": "This module provides functions to match Swift code against templates, supporting both full and first-match searches with optional configuration and nested matching. It operates on strings representing source code and templates, returning lists or individual match results. Use cases include finding specific Swift code patterns in source files, such as identifying function calls or structural elements, with support for recursive matching when needed.",
      "description_length": 452,
      "index": 291,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Omega.Solidity",
      "library": "comby",
      "description": "This module provides functions to match Solidity code patterns using templates, supporting both full and first-occurrence matching with configurable nesting. It operates on Solidity source code strings and returns structured match results. Use cases include static analysis and automated code transformation of Solidity smart contracts.",
      "description_length": 336,
      "index": 292,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Omega.Elm",
      "library": "comby",
      "description": "This module provides functions to match templates against Elm source code, supporting both full and first-match searches with configurable parameters. It operates on strings representing source code and templates, returning structured match results. Use cases include finding all instances of a code pattern recursively or locating the first occurrence starting from a specific position.",
      "description_length": 387,
      "index": 293,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Engine.S-JSON",
      "library": "comby",
      "description": "This module performs structural matching of code templates against source code, supporting nested matching when enabled. It operates on strings representing code templates and source input, returning lists of matches or individual match results. It is used for tasks like finding all occurrences of a specific code pattern in a file or identifying the first match starting at a given position.",
      "description_length": 393,
      "index": 294,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Engine.S",
      "library": "comby",
      "description": "This module provides syntax-directed parsing, pattern matching, and structural analysis capabilities tailored to programming languages and structured text formats like JSON, XML, and domain-specific dialects. It enables use cases such as code refactoring, semantic search, and format-constrained validation through language-specific matchers that can be dynamically selected by file extension or configured with custom syntax definitions and metasyntax rules.",
      "description_length": 459,
      "index": 295,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Engine.S-Lisp",
      "library": "comby",
      "description": "This module matches templates against source code using a nested or non-nested strategy, returning all matches or the first match with optional starting offset. It operates on strings for both template and source inputs, producing lists of matches or error-wrapped single matches. It also identifies the language by name and supported file extensions, primarily serving code analysis and transformation tasks in specific programming languages.",
      "description_length": 443,
      "index": 296,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Language.S-Syntax",
      "library": "comby",
      "description": "This module defines syntax elements for parsing and matching code patterns, including user-defined delimiters, escapable and raw string literals, and comment styles. It works with tuples, lists, and custom types like `comment_kind` to specify language-specific syntax rules. Concrete use cases include configuring pattern matchers for code transformation tools and static analysis engines.",
      "description_length": 389,
      "index": 297,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Alpha.Go",
      "library": "comby",
      "description": "This module implements Go language-specific pattern matching operations for source code analysis. It provides functions to find all or the first occurrence of a template in a source string, supporting recursive matching on nested structures when enabled. The module works with string-based templates and sources, returning lists or individual match records that capture matched content and positions.",
      "description_length": 400,
      "index": 298,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Reason",
      "library": "comby",
      "description": "This module provides the core syntactic and metadata definitions required to process ReasonML source code. It includes configurations for parsing elements such as string literals, escape sequences, comments, and delimiters, enabling accurate code transformation and pattern matching. The module also exposes metadata like the language name and file extensions for integration into tooling pipelines. For example, it allows tools to recognize `.re` and `.rei` files and correctly parse embedded ReasonML strings with custom delimiters or escaped characters.",
      "description_length": 556,
      "index": 299,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Omega.JSONC",
      "library": "comby",
      "description": "This module provides functions to match JSONC (JSON with comments) content using templates, supporting both full and first-match scans. It operates on JSONC strings and allows configuration of matching behavior through optional parameters. Use cases include extracting specific JSONC patterns from source text, such as finding all instances of a particular structure or locating the first occurrence starting at a given position.",
      "description_length": 429,
      "index": 300,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Omega.Ruby",
      "library": "comby",
      "description": "This module provides functions to find all or the first matches of a template in Ruby source code, supporting nested matching through a configuration. It works with strings for template and source code, returning lists or optional match results. Use cases include code analysis and transformation tasks where specific Ruby code patterns need to be identified.",
      "description_length": 359,
      "index": 301,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Omega.OCaml",
      "library": "comby",
      "description": "This module provides functions to match OCaml code patterns using templates, supporting both full and first-match searches with optional configuration and file context. It operates on OCaml source code strings and returns structured match results, with support for recursive matching when enabled. Use cases include code analysis, transformation, and querying specific syntactic patterns in OCaml files.",
      "description_length": 403,
      "index": 302,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Engine.S-Latex",
      "library": "comby",
      "description": "This module provides functions to match templates against LaTeX source code, supporting both full and first-match scans with configurable parameters. It operates on strings representing templates and source code, returning structured match results or errors. Use cases include parsing LaTeX documents for specific syntax patterns, extracting or transforming content based on template rules, and analyzing LaTeX files with customizable matching logic.",
      "description_length": 450,
      "index": 303,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Engine.S-HCL",
      "library": "comby",
      "description": "This module implements HCL (HashiCorp Configuration Language) template matching operations for parsing and querying HCL source code. It provides functions to find all matches or the first match of a template within a source string, supporting recursive matching when enabled. The module works directly with HCL syntax structures, returning match results as `Comby.match'` values. Use cases include static analysis, code transformation, and configuration file querying in infrastructure-as-code workflows.",
      "description_length": 504,
      "index": 304,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Omega.Html",
      "library": "comby",
      "description": "This module provides functions to match HTML content using templates, supporting both full and first-match searches with optional configuration and file context. It operates on strings representing HTML sources and templates, returning structured match results. Use cases include extracting elements, attributes, or patterns from HTML documents, such as finding all script tags or locating the first occurrence of a specific structure.",
      "description_length": 435,
      "index": 305,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Alpha.HCL",
      "library": "comby",
      "description": "This module provides functions to match HCL (HashiCorp Configuration Language) templates against source code, returning all matches or the first match found. It works with strings as input templates and source code, producing lists of match results or individual match outcomes. Use it to find specific HCL configuration patterns in files, such as identifying resource blocks or variable declarations.",
      "description_length": 401,
      "index": 306,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Omega.Text",
      "library": "comby",
      "description": "This module provides functions to match text templates against source code, supporting both full and first-match scans with configurable nesting. It operates on strings for templates and source code, returning lists of matches or individual match results. Use cases include finding all occurrences of a code pattern in a file or identifying the first instance of a template starting at a specific position.",
      "description_length": 406,
      "index": 307,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Omega.CSS",
      "library": "comby",
      "description": "This module provides functions to match CSS templates against source code, supporting both full and first-match searches with configurable parameters. It operates on string-based templates and sources, returning structured match results. Use cases include finding all instances of a CSS selector pattern in a stylesheet or locating the first occurrence of a specific CSS rule starting from a given position.",
      "description_length": 407,
      "index": 308,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Alpha.SQL",
      "library": "comby",
      "description": "This module provides functions to match SQL templates against source code, returning all matches or the first match with optional configuration and file context. It operates on strings representing SQL code and templates, producing lists of match results or error-handled single matches. Use cases include finding specific SQL query patterns in database code or validating SQL structure consistency across files.",
      "description_length": 412,
      "index": 309,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Omega.Latex",
      "library": "comby",
      "description": "This module provides functions to match LaTeX content using a template against a source string, supporting both full and first-match searches with optional nested matching. It operates on strings and returns structured match results, while also exposing metadata like supported file extensions and the matcher name. It is used for parsing and transforming LaTeX documents by identifying specific syntactic patterns.",
      "description_length": 415,
      "index": 310,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Lisp",
      "library": "comby",
      "description": "This module provides metadata and syntax configuration for Lisp-like languages, enabling identification of Lisp files through extensions and customization of string and comment syntax. Key data types include language name, file extensions, string delimiters, and comment markers, with operations to retrieve and configure these elements. It allows specifying custom string escape rules and comment styles for parsing or transforming Lisp code, and supports workflows that require recognizing Lisp files based on standard or user-defined extensions. For example, it can define a Lisp dialect using semicolon for line comments and parentheses for string delimiters, or identify `.lsp` files as Lisp source code.",
      "description_length": 709,
      "index": 311,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Omega.Erlang",
      "library": "comby",
      "description": "This module provides functions to match Erlang code against templates, supporting both full and first-match scans with configurable nesting. It operates on Erlang source code strings and uses a custom configuration and rule system to identify matches. Use cases include code analysis, refactoring, and transformation tasks specific to Erlang syntax.",
      "description_length": 349,
      "index": 312,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Omega.Clojure",
      "library": "comby",
      "description": "This module provides functions to match Clojure code patterns using templates, supporting both full and first-match scans with optional nested matching. It operates on Clojure source code strings and returns structured match results. Use cases include code analysis, transformation, and querying within Clojure files.",
      "description_length": 317,
      "index": 313,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Alpha.Fortran",
      "library": "comby",
      "description": "This module provides functions to match templates against Fortran source code, returning all matches or the first match based on configuration. It operates on strings representing source code and templates, producing lists of match results or error-wrapped single matches. Use cases include finding specific Fortran syntax patterns, such as variable declarations or subroutine calls, within larger codebases.",
      "description_length": 408,
      "index": 314,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Omega.R",
      "library": "comby",
      "description": "This module provides functions to match templates against source code, supporting both full and first-match searches with optional configuration and file context. It operates on strings for template and source code inputs, returning structured match results or errors. Use cases include finding all occurrences of a code pattern recursively or locating the first match at a specific position in a file.",
      "description_length": 402,
      "index": 315,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Alpha.Dyck",
      "library": "comby",
      "description": "This module provides functions to match templates in source code using a context-free grammar approach, specifically handling nested structures through recursive matching. It operates on strings representing source code and templates, returning lists of matches or individual match results. Use cases include finding all instances of a nested code pattern in a file or identifying the first occurrence starting at a specific position.",
      "description_length": 434,
      "index": 316,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Alpha.Fsharp",
      "library": "comby",
      "description": "This module provides functions to match F# code against templates, supporting both full and first-match searches with configurable parameters. It operates on F# source code strings and templates, handling nested matches when enabled. Use cases include finding specific code patterns in F# files for analysis or transformation tasks.",
      "description_length": 332,
      "index": 317,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Alpha.Solidity",
      "library": "comby",
      "description": "This module provides functions to match Solidity code patterns using templates, supporting both full and first-match scans with configurable nesting. It operates on Solidity source code strings and returns structured match results. Use cases include static analysis and automated code transformation of Solidity smart contracts.",
      "description_length": 328,
      "index": 318,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Omega.Jsx",
      "library": "comby",
      "description": "This module provides functions to match templates against JSX source code, supporting both full and first-match searches with optional configuration and file context. It operates on strings representing templates and source code, returning lists of matches or individual match results. Use cases include finding all instances of a JSX pattern in a file or identifying the first occurrence starting at a specific position.",
      "description_length": 421,
      "index": 319,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Alpha.Generic",
      "library": "comby",
      "description": "This module provides functions to match templates against source code, supporting both full and first-match searches with optional configuration and file context. It operates on strings for template and source input, returning lists or individual match records. Use cases include finding all occurrences of a code pattern in a file or identifying the first match starting at a specific position.",
      "description_length": 395,
      "index": 320,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Comby.Matchers.Languages.Fsharp",
      "library": "comby",
      "description": "This module provides metadata and syntax definitions for the F# programming language. It includes data types for language identification, such as the language name and file extensions, along with syntax elements like delimiters, string literals, and comments. Operations allow parsing, matching, and handling of F# code structures. For example, it enables identifying F# source files by extension and correctly parsing F#-specific syntax in code analysis tools.",
      "description_length": 461,
      "index": 321,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Omega.Java",
      "library": "comby",
      "description": "This module provides functions to match Java code against templates, supporting both full and first-match scans with configurable nesting. It operates on Java source code strings and leverages a matcher configuration to identify structural patterns. Use cases include code analysis, refactoring, and transformation tasks specific to Java syntax.",
      "description_length": 345,
      "index": 322,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Engine.S-Dart",
      "library": "comby",
      "description": "This module provides functions to find all or the first matches of a template in a source string, supporting nested matching and positional starting points. It works with strings as input and outputs lists of matches or individual match results. Use cases include pattern matching in code files where specific syntax structures need to be identified, such as finding all occurrences of a function call or variable declaration in a Dart source file.",
      "description_length": 448,
      "index": 323,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Language.S",
      "library": "comby",
      "description": "This module defines core components for parsing and matching code patterns in a specific programming language. It includes operations for constructing and manipulating abstract syntax trees (ASTs) and provides utilities for pattern matching against source code. Concrete use cases include implementing custom code transformations, linters, and refactoring tools that require precise syntactic analysis.",
      "description_length": 402,
      "index": 324,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Engine.S-Assembly",
      "library": "comby",
      "description": "This module performs structural matching of code templates against source code, supporting nested matching when enabled. It operates on strings representing code templates and source input, returning lists of matches or individual match results. It is used to find all or first occurrences of a template pattern in a given source, particularly for language-specific code transformations.",
      "description_length": 387,
      "index": 325,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Omega.C",
      "library": "comby",
      "description": "This module provides functions to match code templates against C source code, supporting both full and first-match searches with optional configuration and file context. It operates on strings representing code templates and source input, returning structured match results. Use cases include finding specific syntax patterns in C code, such as function calls or variable declarations, for analysis or transformation tasks.",
      "description_length": 423,
      "index": 326,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Omega.Dart",
      "library": "comby",
      "description": "This module provides functions to match templates against Dart source code, supporting both full and first-match scans with configurable parameters. It operates on strings for templates and source code, returning lists of matches or individual match results. Use cases include finding all instances of a Dart code pattern recursively or locating the first occurrence starting at a specific position.",
      "description_length": 399,
      "index": 327,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Languages.Generic",
      "library": "comby",
      "description": "This module combines language metadata and syntax configuration to support tools that analyze or process source code. It provides data types for representing programming languages with their extensions, along with syntax rules for parsing constructs like variables, strings, and comments. Operations include retrieving language identifiers, matching delimiters, and handling string literals with customizable escape behaviors. For example, a linter could use this to detect language-specific syntax patterns or validate file structure based on extension and syntax rules.",
      "description_length": 571,
      "index": 328,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Alpha.Bash",
      "library": "comby",
      "description": "This module provides functions to match templates against Bash source code, returning all matches or the first match based on given configuration and position. It operates on strings representing templates and source code, producing lists of match results or error-handled single matches. Use cases include searching for specific Bash code patterns in scripts, such as finding all function definitions or command sequences, with optional recursive matching.",
      "description_length": 457,
      "index": 329,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Engine.S-Clojure",
      "library": "comby",
      "description": "This module provides functions to find all or the first matches of a template in Clojure source code, supporting recursive matching when enabled. It operates on strings representing the template and source code, returning lists of match results or individual match outcomes. Use cases include code analysis and transformation tasks specific to Clojure, such as identifying function calls or syntactic patterns in source files.",
      "description_length": 426,
      "index": 330,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Engine.S-JSONC",
      "library": "comby",
      "description": "This module provides functions to find all or the first match of a template in a source string, supporting nested matching and optional configuration. It works with strings as input for templates and sources, returning lists of matches or error-handled single matches. Use cases include parsing and transforming structured text like JSON with comments, where precise template-based matching is required.",
      "description_length": 403,
      "index": 331,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.R",
      "library": "comby",
      "description": "This module combines language-specific syntax definitions and metadata to enable precise code processing and file identification. It includes data types for string patterns, delimiters, comments, and file extensions, along with operations to match, parse, and categorize code elements. You can use it to build tools that analyze, transform, or classify R code based on its syntax and file type. For example, it can identify R source files by extension and correctly parse raw strings or comments during code analysis.",
      "description_length": 517,
      "index": 332,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Php",
      "library": "comby",
      "description": "This module provides essential metadata and syntax definitions for working with PHP code. It includes data types for representing PHP's language name, file extensions, string delimiters, and comment styles, along with operations to access and match these elements. You can use it to identify PHP files by extension, parse string literals with correct escaping, and recognize PHP comment structures in code analysis tasks.",
      "description_length": 421,
      "index": 333,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Html",
      "library": "comby",
      "description": "This module integrates HTML language support by defining metadata and syntax configurations for parsing and manipulating HTML content. It includes data types for specifying language names, file extensions, delimiters, string literals, and comment structures, enabling precise syntactic analysis and transformation. Operations allow identifying HTML files, extracting embedded expressions, and handling escaped or raw content. Example uses include building templating engines, refactoring HTML code, and implementing static analysis tools for HTML documents.",
      "description_length": 557,
      "index": 334,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Engine.S-Make",
      "library": "comby",
      "description": "This module performs structural matching of code templates against source code, supporting both first-match and all-matches operations with optional recursive matching. It works with strings representing code templates and source input, producing lists of match results or individual match outcomes. Use cases include finding function calls, variable declarations, or specific syntactic patterns in codebases for refactoring or analysis.",
      "description_length": 437,
      "index": 335,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Csharp",
      "library": "comby",
      "description": "This module provides core components for working with C# syntax and language metadata. It includes support for parsing and matching C# code patterns using custom delimiters, string literals, and comment structures, along with access to common C# file extensions like `.cs`. You can use it to build tools such as linters, formatters, or refactoring utilities that require precise handling of C# source files. For example, it enables\u8bc6\u522b and processing of C# strings and comments in code analysis tasks.",
      "description_length": 499,
      "index": 336,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Omega.C_nested_comments",
      "library": "comby",
      "description": "This module provides functions to match templates in source code with support for nested comment syntax. It works with strings as input source code and templates, returning lists of matches or individual match results. Use cases include finding all instances of a code pattern within C-style nested comments or extracting specific structures from code files.",
      "description_length": 358,
      "index": 337,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Comby.Matchers.Alpha.Paren",
      "library": "comby",
      "description": "This module provides functions to match templates in source code using a language-specific matcher, supporting both full and first-match searches with optional configuration. It operates on strings for template and source input, returning structured match results or errors, and includes metadata like supported file extensions and language name. Use cases include finding all occurrences of a code pattern in a file, or locating the first match starting at a specific position for targeted transformations.",
      "description_length": 507,
      "index": 338,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.External.Default",
      "library": "comby",
      "description": "This module defines a default external handler used to process and match patterns in source code. It works with the `Comby.Matchers.External.t` type, which encapsulates matching logic for structural code queries. Concrete use cases include integrating with language parsers to enable precise code transformation and analysis tasks.",
      "description_length": 331,
      "index": 339,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Alpha.Coq",
      "library": "comby",
      "description": "This module provides functions to match and find patterns in source code written in the Coq language. It supports finding all matches recursively or the first match starting at a specific position, using templates and configuration options. The module works with Coq syntax and is used for tasks like code analysis and transformation.",
      "description_length": 334,
      "index": 340,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Omega.Zig",
      "library": "comby",
      "description": "This module provides functions to match templates against source code in a specific programming language, supporting both full and first-match scans with configurable parameters. It operates on strings for templates and source input, returning lists of matches or individual match results. Use cases include finding all occurrences of a code pattern in a file or identifying the first match starting at a specific position.",
      "description_length": 423,
      "index": 341,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Language.S-Info",
      "library": "comby",
      "description": "This module defines metadata for a programming language, including its name and associated file extensions. It works with basic string and list data types to store and retrieve this information. Concrete use cases include identifying language-specific files in a codebase or configuring tools based on file extension mappings.",
      "description_length": 326,
      "index": 342,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Engine.S-Javascript",
      "library": "comby",
      "description": "This module provides functions to find all or the first matches of a template in JavaScript source code, supporting nested matching when enabled. It operates on strings for both template and source code, returning lists or individual match records. Use it to locate specific syntactic patterns in JavaScript files, such as function calls or variable declarations, for analysis or transformation tasks.",
      "description_length": 401,
      "index": 343,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Engine.S-Erlang",
      "library": "comby",
      "description": "This module provides functions to match Erlang source code against templates, supporting both full and first-match scans with configurable nesting. It operates on strings representing source code and templates, returning structured match results. Use cases include code analysis and transformation tasks specific to Erlang, such as finding function calls or pattern-matching expressions in a codebase.",
      "description_length": 401,
      "index": 344,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Alpha.Python",
      "library": "comby",
      "description": "This module implements Python-specific pattern matching over source code using templates. It provides operations to find all matches or the first match of a template in a given source string, with support for recursive matching on nested structures. The module works with string-based templates and sources, returning structured match results, and is used for tasks like code analysis and transformation in Python.",
      "description_length": 414,
      "index": 345,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Go",
      "library": "comby",
      "description": "This module provides precise syntactic definitions and metadata for the Go programming language. It supports parsing and transformation of Go code with features like custom delimiters, string literals, and comment handling, while also exposing language identification through name and file extension data. Operations include pattern matching on Go syntax elements and retrieving language-specific metadata. For example, it enables tools to correctly parse raw strings using backticks or identify Go source files by their `.go` extension.",
      "description_length": 537,
      "index": 346,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Engine.S-Tsx",
      "library": "comby",
      "description": "This module provides functions to find all or the first matches of a template in a source string, supporting nested matching through a configuration. It works with strings for templates and sources, returning lists or results of matches. Use cases include searching for code patterns in files, such as identifying specific syntax structures in source code during analysis or transformation tasks.",
      "description_length": 396,
      "index": 347,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Alpha.Elixir",
      "library": "comby",
      "description": "This module provides functions to match Elixir code patterns using templates, supporting both full and first-match scans with configurable nesting. It operates on Elixir source code strings and returns structured match results, optionally constrained by file path or parsing rules. Use cases include code analysis, transformation, and querying specific Elixir syntax structures like function definitions or module attributes.",
      "description_length": 425,
      "index": 348,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Languages.Dyck",
      "library": "comby",
      "description": "This module provides a framework for defining and working with Dyck-like languages, focusing on syntax and metadata configuration. It supports custom delimiters, string literals, and comments through tuples, lists, and variants, enabling flexible parser setups for nested or balanced structures. You can specify opening and closing pairs, define escapable or raw strings, and associate file extensions with a language name. Example uses include configuring language tools for domain-specific formats with hierarchical syntax or custom bracketing rules.",
      "description_length": 552,
      "index": 349,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Alpha.Erlang",
      "library": "comby",
      "description": "This module provides functions to match Erlang code against templates, returning all matches or the first match found. It works with strings representing Erlang source code and templates, producing lists of match results or error-handled single matches. Use cases include searching for specific code patterns in Erlang files, such as finding function definitions or expressions that match a given structure.",
      "description_length": 407,
      "index": 350,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Engine.S-SQL",
      "library": "comby",
      "description": "This module provides functions to match SQL templates against source code, returning all matches or the first match based on configuration. It operates on strings representing SQL templates and source input, producing lists of match results or error-handled single matches. It supports nested matching and offset-based search initiation, tailored for SQL code analysis tasks like query pattern detection or transformation.",
      "description_length": 422,
      "index": 351,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Alpha",
      "library": "comby",
      "description": "This component enables syntax-aware parsing, structural matching, and transformation of context-sensitive data formats and programming languages. It operates on abstract syntax trees and token sequences, supporting precise manipulation of hierarchical and language-specific constructs for tasks like code refactoring, linting, and structured validation. The core functionality is extended through a family of language-specific modules that implement template-based matching for languages such as Lisp, Rust, JavaScript, Python, Java, and many others, as well as structured formats like JSON, XML, and CSS. Each module provides functions to match source code or structured text against templates, returning detailed match results that support both full and first-match scans, with optional recursive matching on nested structures.",
      "description_length": 829,
      "index": 352,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Ast",
      "library": "comby",
      "description": "This module defines an abstract syntax tree (AST) for representing rules with atoms, logical expressions, and transformation operations. It supports data types like `atom`, `antecedent`, `consequent`, and `expression`, enabling structured pattern matching and rewriting logic. Concrete use cases include parsing and manipulating rule-based transformations, such as code refactoring or template-based text manipulation, where logical conditions and structured edits are required.",
      "description_length": 478,
      "index": 353,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Template",
      "library": "comby",
      "description": "This module represents and manipulates template syntax for pattern matching, supporting conversions between S-expressions and structured data. It defines types for template atoms, including holes with metadata such as variable names, patterns, offsets, and transformations like casing or positional information. The module enables building and deconstructing templated strings with placeholders that can be filled or matched during code transformation tasks. A child module parses string templates into structured representations and extracts variable names, supporting custom syntax definitions for use in templating engines or code generation tools requiring variable interpolation.",
      "description_length": 684,
      "index": 354,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Match.Range",
      "library": "comby",
      "description": "This module defines a range structure with start and end locations, providing equality checks, serialization to and from S-expressions and JSON, and a default value. It works with location data types to represent positions in text, typically used for tracking matches in source code. Concrete use cases include storing and comparing the positions of matched patterns during code analysis or transformation tasks.",
      "description_length": 412,
      "index": 355,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Language",
      "library": "comby",
      "description": "This module establishes the foundation for defining and parsing language-specific syntax rules, integrating submodules that handle syntactic constructs, metadata, and parsing logic. It provides core types like `string_literal`, `comment_style`, and `delimiter`, along with operations to configure escapable strings, comment formats, and language-specific delimiters, enabling precise code pattern matching. Submodules extend these definitions to support AST manipulation, language metadata configuration, and file extension-based parsing strategies. Use it to build custom parsers, configure code analysis tools, or implement language-aware transformations for formats like JSON, HTML, or OCaml.",
      "description_length": 695,
      "index": 356,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Match.Environment",
      "library": "comby",
      "description": "This module manages mappings of metavariables to values and ranges, providing operations to add, update, and query these bindings. It supports data types like strings for variable names and values, ranges for positional information, and JSON for serialization. Concrete use cases include tracking variable substitutions during pattern matching and serializing match results for external processing.",
      "description_length": 398,
      "index": 357,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Matcher",
      "library": "comby",
      "description": "This module defines the interface for matcher implementations, specifying operations such as pattern matching and substitution over structured data. It works with abstract syntax trees and pattern representations to enable precise code transformation tasks. The child module provides functions to find all or the first match of a template in a source string, supporting nested matching and language-specific configurations. Use cases include parsing and transforming code in specific languages by matching structural patterns in source files, such as rewriting function calls or extracting metadata like file extensions and language names.",
      "description_length": 639,
      "index": 358,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Rewrite",
      "library": "comby",
      "description": "This module handles rewrite operations using match results, substituting variables in a template string based on match environments. It works with lists of match results and environment mappings to perform replacements. Concrete use cases include generating rewritten source code from match captures and applying transformation templates to matched patterns.",
      "description_length": 358,
      "index": 359,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Omega",
      "library": "comby",
      "description": "This module enables syntax-aware pattern matching and transformation across a wide range of structured and semi-structured formats, including programming languages, markup, and domain-specific syntaxes. It provides core operations for matching templates against source code or data, working with hierarchical representations and token streams to handle language-specific constructs such as indentation, nesting, and metasyntax. The module supports direct matching on strings with configurable rules, start positions, and nested matching, while its submodules offer language-specific implementations for HCL, JSON, Lisp, PHP, Pascal, Julia, Kotlin, Nim, TypeScript, Python, Swift, Bash, XML, Elixir, F#, TSX, SQL, Fortran, Rust, GraphQL, Coq, Dhall, C#, Scala, Solidity, Elm, JSONC, Ruby, OCaml, HTML, CSS, LaTeX, Erlang, Clojure, JSX, Java, C, Dart, and more. Examples include extracting function definitions in Python, rewriting infrastructure-as-code templates in HCL, transforming JSX structures in React code, or identifying query patterns in SQL scripts, all while preserving syntactic correctness and context.",
      "description_length": 1115,
      "index": 360,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Engine",
      "library": "comby",
      "description": "This module implements a structural pattern matching engine for abstract syntax trees, enabling precise identification and extraction of code patterns across multiple languages. It provides core data types for syntax nodes, patterns, and environments, with operations to apply templates to source code strings and yield structured match results, substitutions, and positional metadata. The engine supports both first-match and all-matches searches, optional nested matching, and language-specific extensions through submodules that target languages like Solidity, C#, Python, JavaScript, and more. Specific use cases include code transformation, syntactic querying, refactoring tools, and static analysis, with submodules offering tailored support for language-specific syntax and file contexts.",
      "description_length": 795,
      "index": 361,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Hole",
      "library": "comby",
      "description": "This module defines a `sort` type that classifies different kinds of holes used in pattern matching, each corresponding to specific matching behavior such as matching expressions, alphanumeric sequences, or regular expressions. It is used to specify how placeholders in a template should be matched against actual code during structural matching. Concrete use cases include parsing and transforming code by defining flexible, context-aware patterns.",
      "description_length": 449,
      "index": 362,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.Rule",
      "library": "comby",
      "description": "This module processes match rules defined as lists of abstract syntax expressions, supporting operations to create, serialize, and apply rules for pattern matching. It handles rule evaluation with options for nested matching, substitution behavior, and external handlers, producing results that indicate satisfaction and captured environments. Concrete use cases include defining and applying structured rewrite rules over source code, checking match conditions, and extracting matched environments for further processing.",
      "description_length": 522,
      "index": 363,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Match.Location",
      "library": "comby",
      "description": "This module defines a data structure for representing positions in text, with fields for byte offset, line, and column numbers. It provides functions for equality checking, serialization to and from S-expressions and JSON, and a default value. Concrete use cases include tracking positions in source code during parsing or transformation tasks.",
      "description_length": 344,
      "index": 364,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers.External",
      "library": "comby",
      "description": "This module provides an interface for integrating external matching tools into code transformation workflows, working with source code files through positional information like line and column numbers. It supports precise code analysis and rewriting by combining direct operations on source locations with structured data processing via child modules that handle abstract syntax trees and pattern definitions. The main data types include matchers that encapsulate logic for structural code queries and handlers that apply matching rules to inputs. You can use it to plug in regex engines or AST-based tools, enabling custom refactoring rules or domain-specific language transformations with accurate positioning and structural awareness.",
      "description_length": 737,
      "index": 365,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Metasyntax",
      "library": "comby",
      "description": "This module defines metasyntax for template matching, including hole syntax and replacement rules, and processes structured data like strings and identifiers to support pattern matching and substitution. It provides core data types for representing syntax templates and operations for applying replacement rules, while the child modules extend this functionality with a default configuration and a parameterized matcher interface. The default configuration module supplies predefined hole syntax and aliases used in code transformation tools, and the matcher interface enables custom syntax rules and alias mappings for structured pattern matching in parsing and code analysis applications. Example uses include parsing code templates with placeholders, transforming source code using regex patterns, and defining custom syntax directives for analysis tools.",
      "description_length": 858,
      "index": 366,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Languages",
      "library": "comby",
      "description": "This module enables language-specific parsing, pattern matching, and syntactic transformation across a wide range of programming languages and structured formats. It provides core abstractions for handling delimiters, string literals, comments, and file metadata, while supporting customizable syntax configurations for nested structures, raw strings, and escapable content. Direct operations allow language detection by extension or name, structured code manipulation, and domain-specific analysis using precise syntactic rules. Submodules extend this foundation to specific languages like OCaml, Python, JavaScript, and XML, enabling tasks such as comment extraction, string parsing, and file type recognition with language-specific accuracy.",
      "description_length": 744,
      "index": 367,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Specification",
      "library": "comby",
      "description": "This module defines a specification for matching and rewriting code patterns using templates and optional rules. It works with strings as match and rewrite templates, alongside optional rule applications. Use it to create structured match-rewrite operations for code transformations, such as refactoring or linting tasks.",
      "description_length": 321,
      "index": 368,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Matchers.Configuration",
      "library": "comby",
      "description": "This module defines configuration parameters that control matching behavior, such as substring matching, whitespace sensitivity, and newline handling. It works with the `t` type representing a configuration state and the `match_kind` type distinguishing between exact and fuzzy matching. Use this module to customize how patterns are matched in structured text, for example when handling indentation-sensitive languages or enabling partial matches in code transformations.",
      "description_length": 472,
      "index": 369,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Pipeline",
      "library": "comby",
      "description": "Handles executing matchers and rewriters on input sources like file paths or strings, producing matches or transformed output. Works with structured data types like `single_source`, `output`, and matcher modules to enable customizable pattern matching and code rewriting workflows. Useful for implementing tools that analyze or transform codebases using declarative specifications and custom substitution logic.",
      "description_length": 411,
      "index": 370,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Matchers",
      "library": "comby",
      "description": "This module enables structured pattern matching and code transformation through customizable metasyntax, working with rules, abstract syntax trees, and templated strings to support tasks like refactoring, linting, and code search. It provides core data types such as `rule`, `metasyntax`, `atom`, and `configuration`, along with operations for parsing, matching, and rewriting code based on templates with placeholders and logical expressions. Child modules extend this functionality with language-specific parsers, AST manipulation tools, and rewrite engines that support precise matching across a wide range of programming languages and structured formats. Examples include extracting function definitions in Python, rewriting HCL templates, transforming JSX in React code, or identifying SQL query patterns while preserving syntactic correctness.",
      "description_length": 849,
      "index": 371,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby.Replacement",
      "library": "comby",
      "description": "This module represents the output of a rewrite operation, capturing the range of text replaced, the new content, and contextual matching information. It provides functions to convert replacement results to and from JSON formats, supporting serialization and structured output. Use this module to handle and serialize the results of source code transformations, such as when generating patches or reporting changes in a structured format.",
      "description_length": 437,
      "index": 372,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby.Match",
      "library": "comby",
      "description": "This module captures structured match results from pattern matching in source code, providing data types to represent matched text, ranges, and environments mapping metavariables to values. It supports operations to create matches, convert offsets to line/column positions, and format matches as JSON or grep-like output. The range module tracks start and end locations with support for comparison and serialization, while the environment module manages metavariable bindings with string and range values. Together, they enable precise tracking and serialization of match positions and variable substitutions during code analysis or transformation tasks.",
      "description_length": 654,
      "index": 373,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby",
      "library": "comby",
      "description": "This module enables structural code analysis and transformation through pattern-based matching, supporting automated refactoring, linting, and code standard enforcement. It provides core types like `rule`, `metasyntax`, and `configuration` for defining patterns, alongside `match` and `rewrite` operations that work with structured inputs and outputs, including `single_source` and `output` modules for handling source code and transformation results. You can match function definitions in Python, rewrite JSX elements, or extract SQL patterns while preserving syntax, then serialize match positions, ranges, and substitutions to JSON for further processing or patch generation. Submodules handle language-specific parsing, AST manipulation, and result formatting, enabling precise and customizable code transformations across diverse codebases.",
      "description_length": 845,
      "index": 374,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Patdiff_kernel.Format.Color.Map.Tree.Provide_of_sexp",
      "library": "comby.patdiff_kernel",
      "description": "This module provides a function `t_of_sexp` that deserializes S-expressions into typed tree structures representing color mappings for formatting. It operates on S-expressions and constructs values of type `'a Patdiff_kernel.Format.Color.Map.Tree.t`, enabling structured parsing of configuration data. A concrete use case is interpreting color configuration files or strings into internal format trees used during diff rendering.",
      "description_length": 429,
      "index": 375,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Patdiff_kernel.Format.Style.Map.Tree.Provide_of_sexp",
      "library": "comby.patdiff_kernel",
      "description": "Converts S-expressions into styled tree structures using a key module, enabling parsing of nested format specifications. It operates on S-exps and produces trees that represent hierarchical formatting rules. This is used to build structured diff layouts from configuration files or input data.",
      "description_length": 293,
      "index": 376,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Patdiff_kernel.Format.Style.Set.Tree.Provide_of_sexp",
      "library": "comby.patdiff_kernel",
      "description": "Converts S-expressions into styled tree structures for formatting diffs, specifically handling the parsing of style configurations. It operates on S-expressions and produces trees representing formatted diff elements. This module is used during the initialization of style settings from configuration files or command-line arguments.",
      "description_length": 333,
      "index": 377,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Patdiff_kernel.Format.Color.Set.Tree.Provide_of_sexp",
      "library": "comby.patdiff_kernel",
      "description": "This module parses S-expressions into colored diff format trees, specifically converting input into a structured tree of formatting directives. It operates on S-exps and produces values of type `Patdiff_kernel.Format.Color.Set.Tree.t`, which represent styled diff output. A concrete use case is deserializing configuration or theme files that define how differences should be visually represented in a terminal.",
      "description_length": 411,
      "index": 378,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Patdiff_kernel.Format.Style.Set.Tree.Named",
      "library": "comby.patdiff_kernel",
      "description": "This module defines operations for comparing and validating named style sets used in diff formatting. It works with named tree structures that represent sets of formatting styles, such as prefixes and suffixes. Concrete use cases include checking whether one set of named styles is a subset of another and determining equality between two named style sets.",
      "description_length": 356,
      "index": 379,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Patdiff_kernel.Format.Color.Set.Tree.Named",
      "library": "comby.patdiff_kernel",
      "description": "This module defines operations for comparing and validating named color sets used in diff formatting. It works with the `named` type representing structured color configurations. Concrete use cases include checking if one named color set is a subset of another and verifying equality between two named color sets.",
      "description_length": 313,
      "index": 380,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Patdiff_kernel.Format.Color.Map.Tree",
      "library": "comby.patdiff_kernel",
      "description": "This module implements tree-based associative maps with ordered keys, enabling efficient key-value operations like insertion, lookup, and deletion, along with advanced transformations such as merging, range queries, and symmetric diff folding. It supports immutable tree structures keyed by `Color.Map.Key`, allowing ordered traversal, binary search, and rank-based queries, with utilities for validation, property testing, and S-expression serialization. The `t_of_sexp` function in its child module parses S-expressions into typed tree structures representing color mappings, enabling structured configuration parsing for diff rendering. Together, the module and its submodules facilitate complex map manipulations with strong ordering guarantees and error-resilient construction from external formats.",
      "description_length": 804,
      "index": 381,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Patdiff_kernel.Format.Style.Set.Elt",
      "library": "comby.patdiff_kernel",
      "description": "This module represents individual elements of a set used to manage formatting styles in the diffing process. It provides functions for converting values to and from S-expressions and defines a comparator for ordering elements. It is used when handling sets of formatting styles to ensure consistent comparison and serialization.",
      "description_length": 328,
      "index": 382,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Patdiff_kernel.Format.Style.Set.Provide_hash",
      "library": "comby.patdiff_kernel",
      "description": "This module provides hash and hash_fold functions for style sets, enabling efficient hashing of style configurations used in diff formatting. It operates on `Patdiff_kernel.Format.Style.Set.t` values, which represent collections of formatting styles. Concrete use cases include generating consistent hash values for style sets to support caching or comparison in diff rendering pipelines.",
      "description_length": 388,
      "index": 383,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Patdiff_kernel.Format.Color.Set.Named",
      "library": "comby.patdiff_kernel",
      "description": "This module defines operations for comparing and validating named color sets used in formatting diffs. It works with the `Patdiff_kernel.Format.Color.Set.named` type, representing predefined color configurations. Concrete use cases include checking if one color set is a subset of another or verifying equality between two named color sets.",
      "description_length": 340,
      "index": 384,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Patdiff_kernel.Format.Style.Set.Provide_bin_io",
      "library": "comby.patdiff_kernel",
      "description": "This module implements binary serialization and deserialization for sets of formatting styles used in diff output. It directly operates on `Patdiff_kernel.Format.Style.Set.t`, enabling efficient storage or transmission of style configurations. Concrete use cases include saving and loading style presets for consistent diff rendering across sessions or sharing configurations between processes.",
      "description_length": 394,
      "index": 385,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Patdiff_kernel.Format.Color.Map.Provide_of_sexp",
      "library": "comby.patdiff_kernel",
      "description": "This module defines a function `t_of_sexp` that parses S-expressions into color map values, mapping keys to formatted color representations. It works with S-expressions and color formatting structures to enable configuration-driven styling. Use this when loading color settings from a file or configuration that dictates how different elements should be displayed in a diff.",
      "description_length": 374,
      "index": 386,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Patdiff_kernel.Format.Style.Map.Tree",
      "library": "comby.patdiff_kernel",
      "description": "This module provides balanced tree-based maps with ordered keys and polymorphic values, supporting construction from collections, deduplication, and error-aware transformations. It enables advanced operations like custom merging, filtering, structural equality, and range queries, ideal for managing hierarchical formatting rules or analyzing ordered key-value relationships. The child module converts S-expressions into styled tree structures, allowing parsing of nested format specifications into hierarchical layouts for structured diff generation. Together, they support both direct manipulation of ordered maps and configuration-driven tree construction from symbolic input.",
      "description_length": 679,
      "index": 387,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Patdiff_kernel.Format.Style.Map.Provide_bin_io",
      "library": "comby.patdiff_kernel",
      "description": "This module provides binary serialization and deserialization functions for maps with keys of type `Key` and values related to formatting styles used in diff output. It supports operations like `bin_write_t`, `bin_read_t`, and size calculation for efficient binary encoding and decoding. Concrete use cases include persisting or transmitting diff formatting configurations across different runs or systems.",
      "description_length": 406,
      "index": 388,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Patdiff_kernel.Format.Color.Set.Tree",
      "library": "comby.patdiff_kernel",
      "description": "This module represents structured color sets as balanced trees, supporting efficient membership tests, unions, and ordered traversal over immutable sets of colors. It provides operations for filtering, splitting, and binary search on `Color.Set.Elt.t` values, along with transformations from lists, arrays, and hash-based structures. The `Patdiff_kernel.Format.Color.Set.Tree.t` type is used to model styled diff output, enabling structured aggregation and merging of color regions for terminal rendering. A companion module handles parsing S-expressions into these trees, while another supports comparison and validation of named color configurations, including subset and equality checks.",
      "description_length": 690,
      "index": 389,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Patdiff_kernel.Format.Color.Set.Provide_of_sexp",
      "library": "comby.patdiff_kernel",
      "description": "Converts S-expressions into color sets used for formatting diffs, specifically handling the parsing of valid styles into structured representations. It operates on S-expressions and produces values of type `Patdiff_kernel.Format.Color.Set.t`. This function is useful when loading color configurations from files or other serialized sources to apply consistent styling in diff output.",
      "description_length": 383,
      "index": 390,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Patdiff_kernel.Html_output.Private.Make.Rule",
      "library": "comby.patdiff_kernel",
      "description": "This module defines rules for styling and formatting hunks of text in an output document. It works with strings and formatting rules that specify how to transform or highlight parts of the text. Concrete use cases include applying syntax highlighting or indentation rules to code diffs.",
      "description_length": 286,
      "index": 391,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Patdiff_kernel.Format.Color.Map.Key",
      "library": "comby.patdiff_kernel",
      "description": "This module defines a key type for maps keyed by color values, supporting operations like conversion to and from S-expressions and comparison using a comparator. It works with `Patdiff_kernel.Format.Color.t` values, which represent formatting styles. It is used to associate and retrieve formatting rules based on color keys in diff rendering logic.",
      "description_length": 349,
      "index": 392,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Patdiff_kernel.Format.Color.Map.Provide_hash",
      "library": "comby.patdiff_kernel",
      "description": "This module provides a function `hash_fold_t` for computing hash values over a map structure that associates keys with color formatting data. It operates on maps where keys are of a specified type and values represent color formatting information used in diff rendering. A concrete use case is enabling efficient hashing of color-mapped formatting configurations during the generation of colored diffs.",
      "description_length": 402,
      "index": 393,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Patdiff_kernel.Format.Style.Set.Tree",
      "library": "comby.patdiff_kernel",
      "description": "This module manages ordered tree-based sets of style elements with efficient set operations, ordered traversal, and immutable transformations, enabling precise control over hierarchical formatting rules and priority-based style composition. It supports conversion from S-expressions into styled tree structures for diff formatting, and provides operations to compare and validate named style sets, such as checking subset and equality relations. Main data types include styled tree nodes and named style sets, with operations like union, intersection, difference, ordered traversal, and structural comparison. Example uses include initializing style configurations from external inputs, validating style set inclusions, and transforming style hierarchies in a deterministic manner.",
      "description_length": 781,
      "index": 394,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Patdiff_kernel.Format.Style.Set.Provide_of_sexp",
      "library": "comby.patdiff_kernel",
      "description": "Converts S-expressions into style sets for formatting diffs, specifically handling the parsing of style elements like prefixes and suffixes. It operates on `Ppx_sexp_conv_lib.Sexp.t` inputs and produces `Patdiff_kernel.Format.Style.Set.t` values. This function is used when loading style configurations from files or other S-expression-based sources to customize diff output formatting.",
      "description_length": 386,
      "index": 395,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Patdiff_kernel.Format.Color.Set.Provide_hash",
      "library": "comby.patdiff_kernel",
      "description": "This module provides hash functions for sets of color formatting elements used in diff output. It supports computing hash values and folding hash states for sets of type `Patdiff_kernel.Format.Color.Set.t`. A concrete use case is enabling structural comparison of color formatting configurations in diff rendering pipelines.",
      "description_length": 324,
      "index": 396,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Patdiff_kernel.Format.Color.Map.Provide_bin_io",
      "library": "comby.patdiff_kernel",
      "description": "This module provides binary serialization and deserialization functions for maps with keys of type `Key` and values related to color formatting configurations. It supports operations like `bin_write_t`, `bin_read_t`, and size calculation for efficient binary I/O handling. Concrete use cases include persisting or transmitting diff formatting rules, such as color mappings, across different runs or systems.",
      "description_length": 407,
      "index": 397,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Patdiff_kernel.Format.Style.Map.Provide_hash",
      "library": "comby.patdiff_kernel",
      "description": "This module provides a function `hash_fold_t` for computing hash values over maps with keys of type `Key` and values of type `'a`, using a provided hash state. It works with the `Patdiff_kernel.Format.Style.Map.t` data structure, which associates format styles to keys. A concrete use case is hashing style configurations to detect changes or enable efficient comparisons during diff generation.",
      "description_length": 395,
      "index": 398,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Patdiff_kernel.Format.Color.Set.Elt",
      "library": "comby.patdiff_kernel",
      "description": "This module represents individual elements in a set of formatting styles used for diffs, specifically handling color attributes. It provides functions for converting these color elements to and from S-expressions and defines a comparator for ordering them. It is used when managing sets of distinct color-based formatting rules in diff output.",
      "description_length": 343,
      "index": 399,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Patdiff_kernel.Format.Style.Map.Provide_of_sexp",
      "library": "comby.patdiff_kernel",
      "description": "This module provides a function `t_of_sexp` that constructs a style map from an S-expression, using a provided conversion function for the values. It operates on S-expressions and produces maps where keys are determined by the `Key` module and values follow the style format defined in `Patdiff_kernel.Format.Style`. A concrete use case is parsing style configurations from S-expression-based files to apply specific formatting rules during diff generation.",
      "description_length": 457,
      "index": 400,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Patdiff_kernel.Format.Style.Set.Named",
      "library": "comby.patdiff_kernel",
      "description": "This module defines and manipulates named style sets used to represent formatting rules in a diffing context. It provides operations to check if one style set is a subset of another and to compare style sets for equality. These functions are used to validate and enforce consistent formatting configurations when generating diffs.",
      "description_length": 330,
      "index": 401,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Patdiff_kernel.Format.Color.Set.Provide_bin_io",
      "library": "comby.patdiff_kernel",
      "description": "This module implements binary serialization and deserialization for a set of color formatting rules used in diff output rendering. It operates directly on the `Patdiff_kernel.Format.Color.Set.t` type, which represents collections of styling directives like foreground/background colors and text attributes. Concrete use cases include persisting configured color schemes to disk or transmitting them across a network for consistent diff visualization.",
      "description_length": 450,
      "index": 402,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Patdiff_kernel.Format.Style.Map.Key",
      "library": "comby.patdiff_kernel",
      "description": "This module defines keys for a map based on formatting styles, supporting operations to convert between S-expressions and style keys, and provides a comparator for ordering. It works with `Patdiff_kernel.Format.Style.t` and `Sexplib0__.Sexp.t` types. It is used to manage and compare formatting style keys in a structured way, particularly when serializing or deserializing style configurations.",
      "description_length": 395,
      "index": 403,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Patdiff_kernel.Format.Color.Gray24",
      "library": "comby.patdiff_kernel",
      "description": "This module defines a grayscale color representation using a single integer level between 0 and 24. It provides functions to create, compare, and serialize these grayscale values. This is useful for generating terminal output with varying shades of gray, such as in diff visualizations where subtle color distinctions improve readability.",
      "description_length": 338,
      "index": 404,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Patdiff_kernel.Format.Color.Set",
      "library": "comby.patdiff_kernel",
      "description": "This module manages immutable sets of color formatting elements ordered by comparators, supporting set-theoretic operations, element-wise transformations, and ordered traversals. It provides core types like `t` for sets and `Elt.t` for individual color elements, with operations for union, intersection, difference, filtering, and efficient membership tests. You can parse color sets from S-expressions, serialize them for storage or transmission, and compute hashes for structural comparison of styling configurations. Submodules handle structured representations as balanced trees, named color validation, and conversion to and from external formats, enabling use cases like merging hierarchical color rules, validating style subsets, and rendering styled diffs in terminals.",
      "description_length": 777,
      "index": 405,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Patdiff_kernel.Patdiff_core.Private.Make",
      "library": "comby.patdiff_kernel",
      "description": "This module computes and refines line-based diffs between arrays of strings, producing structured hunks that represent additions, removals, and changes. It supports advanced formatting through rules and output handlers, enabling precise control over display, including ANSI styling, line splitting, and hunk interleaving. It is used to implement tools that compare and display differences between text files or string sequences with customizable visual output.",
      "description_length": 460,
      "index": 406,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Patdiff_kernel.Format.Color.Replace_polymorphic_compare",
      "library": "comby.patdiff_kernel",
      "description": "This module replaces polymorphic comparison operators with type-specific comparisons for color values. It defines standard comparison operators like `<`, `>`, `=`, and `compare` that work directly on `Patdiff_kernel.Format.Color.t` values. These operations enable sorting, equality checks, and ordering of color values based on their internal representation.",
      "description_length": 358,
      "index": 407,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Patdiff_kernel.Html_output.Private.Make",
      "library": "comby.patdiff_kernel",
      "description": "This module generates HTML output for diff results by applying styling to strings and rendering lists of hunks. It works with file names, formatting rules, and hunk data structures to produce styled, human-readable HTML diffs. The child module defines rules for styling and formatting hunks of text in an output document, supporting transformations like syntax highlighting or indentation adjustments. Together, they enable generating web-based diff visualizations with customizable formatting and precise location styling.",
      "description_length": 523,
      "index": 408,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Patdiff_kernel.Html_output.Without_mtime.Rule",
      "library": "comby.patdiff_kernel",
      "description": "This module defines how to format and apply styling rules to hunks of text differences when generating HTML output without modification timestamps. It works with `Rule.t` values to determine the visual representation of changes, such as additions, deletions, or context lines. A concrete use case is rendering side-by-side or unified diff views in HTML with custom styling based on the difference type.",
      "description_length": 402,
      "index": 409,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Patdiff_kernel.Format.Color.Map",
      "library": "comby.patdiff_kernel",
      "description": "This module manages key-value associations with color-based keys, supporting operations like insertion, deletion, folding, and advanced transformations such as merging and symmetric difference computation. It provides tree-based ordered maps with efficient lookups, range queries, and rank-based operations, along with utilities for S-expression and binary serialization, hashing, and key comparison. Use it to build and manipulate structured color mappings for diff rendering, load color configurations from S-expressions, or persist formatting rules across sessions. Submodules handle key definition, tree validation, and serialization, enabling robust configuration parsing, hashing, and inter-process transmission of color-based formatting data.",
      "description_length": 749,
      "index": 410,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Patdiff_kernel.Format.Rule.Affix",
      "library": "comby.patdiff_kernel",
      "description": "This module defines and constructs styled affixes\u2014either prefixes or suffixes\u2014used in formatting differences. It provides a `create` function to build affixes with optional styles and a `blank` value representing an empty affix. These affixes are applied to strings during diff rendering to add contextual markers with specific styling.",
      "description_length": 336,
      "index": 411,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Patdiff_kernel.Diff_input.Fields.Direct",
      "library": "comby.patdiff_kernel",
      "description": "This module provides operations to iterate over, fold, map, and query specific fields (`name` and `text`) of `Patdiff_kernel.Diff_input.t` values. It supports transformations and inspections of these fields individually or in combination, enabling targeted manipulation of diff input data. Concrete use cases include extracting field values into lists, applying consistent modifications to fields, and checking predicates across fields.",
      "description_length": 436,
      "index": 412,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Patdiff_kernel.Format.Style.Set",
      "library": "comby.patdiff_kernel",
      "description": "This module manages sets of formatting styles with core set-theoretic operations\u2014union, intersection, difference\u2014and derived utilities for filtering, counting, and element extraction. It supports immutable transformations, ordered traversal, and structural comparison of style sets, enabling precise control over hierarchical and named formatting rules. Submodules handle S-expression conversion, hashing, and binary serialization for storage, transmission, and caching, while others support parsing from S-expressions, subset checks, and deterministic style hierarchy transformations. Examples include loading style presets, validating style inclusions, and generating consistent hashes for style configurations used in diff rendering pipelines.",
      "description_length": 746,
      "index": 413,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Patdiff_kernel.Format.Style.Map",
      "library": "comby.patdiff_kernel",
      "description": "This module manages maps that associate ordered keys with formatting style values, enabling creation from sequences and trees, key-based operations like merging and symmetric diffs, and value transformations with combinators. It supports bulk construction, ordered traversal, and serialization to S-expressions, with child modules providing balanced tree implementations, binary encoding, hashing, S-expression parsing, and key definitions for style-based maps. The tree module builds hierarchical layouts from symbolic input, the bin_io module persists configurations, the hash module enables efficient comparisons, the sexp module parses style rules from config files, and the key module defines ordered style keys for structured manipulation. Examples include converting S-expressions into styled diff layouts, hashing style maps to detect changes, and merging formatting rules with custom conflict resolution.",
      "description_length": 913,
      "index": 414,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Patdiff_kernel.Format.Style.Replace_polymorphic_compare",
      "library": "comby.patdiff_kernel",
      "description": "This module replaces polymorphic comparison operators for the `Style.t` type, ensuring consistent and well-defined ordering behavior. It provides standard comparison functions like `(=)`, `(<)`, `(>)`, `compare`, and utilities like `min` and `max` tailored specifically for comparing and ordering style values. These operations are used when determining precedence or equality of formatting styles during diff rendering.",
      "description_length": 420,
      "index": 415,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Patdiff_kernel.Configuration.Fields.Direct",
      "library": "comby.patdiff_kernel",
      "description": "This module provides operations to iterate over, fold, filter, and convert configuration fields of a diff tool's settings. It works directly with the `Configuration.t` type and its individual fields, such as output format, diffing rules, string comparison options, and display settings. Concrete use cases include inspecting or transforming specific configuration values, checking conditions across fields, and collecting field values into a list.",
      "description_length": 447,
      "index": 416,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Patdiff_kernel.Format.Color.RGB6",
      "library": "comby.patdiff_kernel",
      "description": "This module defines operations for working with RGB6 color values, which are represented as records with `r`, `g`, and `b` fields each ranging from 0 to 5. It includes functions to create color values, compare them, and support for QuickCheck-style testing and S-expression conversion. It is used to represent and manipulate terminal color codes in a structured way.",
      "description_length": 366,
      "index": 417,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Patdiff_kernel.Format.Color",
      "library": "comby.patdiff_kernel",
      "description": "This module handles terminal color representations with precise RGB6 and Gray24 models, offering safe construction, comparison, and serialization. It supports core operations like clamping, validation, and set and map structures for managing color values, enabling tasks such as diff visualization and structured terminal formatting. Child modules provide grayscale handling, ordered color sets, type-specific comparisons, associative color maps, and RGB6 manipulation, with concrete types like `Gray24.t`, `Rgb6.t`, `Set.t`, and `Map.t`. Examples include parsing color sets from S-expressions, merging color configurations, validating terminal styling rules, and rendering diffs with precise color distinctions using grayscale or RGB values.",
      "description_length": 742,
      "index": 418,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Patdiff_kernel.Configuration.Private",
      "library": "comby.patdiff_kernel",
      "description": "This module provides a function `with_ext_cmp` that modifies a configuration by setting an external comparison command and registering a notification callback. It works with the `Configuration.t` type, which represents settings for controlling diffing behavior. A concrete use case is integrating custom diff tools into a diffing pipeline while triggering side effects like logging or caching when the configuration changes.",
      "description_length": 424,
      "index": 419,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Patdiff_kernel.Configuration.Fields",
      "library": "comby.patdiff_kernel",
      "description": "This module organizes configuration parameters that govern diffing behavior, offering read-only access and traversal operations over fields like boolean flags, integer thresholds, and custom types such as `Location_style.t` and `Percent.t`. It supports structured inspection and transformation through functions like `fold`, `iter`, and `to_list`, enabling tasks like validating configuration constraints or customizing output formatting. Submodule operations allow filtering and converting individual fields within `Configuration.t`, such as adjusting diffing rules or extracting display settings. Specific uses include dynamically adapting diff sensitivity based on runtime input or generating reports from configuration state.",
      "description_length": 729,
      "index": 420,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Patdiff_kernel.Patdiff_core.Private",
      "library": "comby.patdiff_kernel",
      "description": "This module computes and refines line-based diffs between arrays of strings, producing structured hunks that represent additions, removals, and changes. It supports advanced formatting through rules and output handlers, enabling precise control over display, including ANSI styling, line splitting, and hunk interleaving. Use it to build tools that compare and visualize differences between text files or string sequences with customizable output. For example, you can generate colorized diffs or split large hunks into smaller, interleaved blocks for better readability.",
      "description_length": 571,
      "index": 421,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Patdiff_kernel.Output.S",
      "library": "comby.patdiff_kernel",
      "description": "This module applies styling to output strings and prints formatted hunks with specific rules. It works with hunks, file names, and formatting rules to generate styled output. Use it to render differences between files with customizable formatting and location styles.",
      "description_length": 267,
      "index": 422,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Patdiff_kernel.Ansi_output.Rule",
      "library": "comby.patdiff_kernel",
      "description": "Applies a formatting rule to a string, using ANSI escape codes to produce colored or styled output. It works with strings and formatting rules defined by the `Format.Rule` module, which specify how different parts of the text should be highlighted. This function is used to generate terminal-friendly diffs with syntax highlighting or other visual distinctions.",
      "description_length": 361,
      "index": 423,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Patdiff_kernel.Format.Rule",
      "library": "comby.patdiff_kernel",
      "description": "This module manages text formatting rules for diffs, combining styled prefixes and suffixes with a base style to control how differences are presented. It supports creating and manipulating rules that wrap strings with affixes\u2014such as colored markers or bold indicators\u2014during output generation. The core type represents a rule composed of a prefix, suffix, and style, while child modules handle affix construction and manipulation. For example, you can define a rule that adds a red \"-\" prefix to deleted lines or wraps changed text in bold styling.",
      "description_length": 550,
      "index": 424,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Patdiff_kernel.Output.S-Rule",
      "library": "comby.patdiff_kernel",
      "description": "Applies a formatting rule to a string, using a specified rule and a boolean flag to determine refinement. Works with strings and formatting rules defined in the `Patdiff_kernel.Format.Rule` module. Useful for transforming and refining text output based on structured formatting rules during diff generation or similar text-processing tasks.",
      "description_length": 340,
      "index": 425,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Patdiff_kernel.Html_output.Without_mtime",
      "library": "comby.patdiff_kernel",
      "description": "This module generates HTML representations of text differences using customizable styling rules applied to hunks of file changes. It processes file name pairs and structured diff hunks, allowing precise control over the visual formatting of additions, deletions, and context lines. The child module handles the application of `Rule.t`-based styling, enabling use cases like unified or side-by-side HTML diff views with custom themes. Together, they support rendering styled diffs without including modification timestamps.",
      "description_length": 522,
      "index": 426,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Patdiff_kernel.Diff_input.Fields",
      "library": "comby.patdiff_kernel",
      "description": "This module organizes and processes the `name` and `text` fields of diff input values, offering operations to fold, map, iterate, and convert these fields into lists. It enables targeted manipulation and analysis of individual or combined fields, supporting transformations and predicate checks across `name` and `text`. For example, it can extract all names into a list, apply a formatting function to each text field, or verify that all names match a given pattern. Submodules extend these capabilities with additional utilities for structured traversal and inspection of field data.",
      "description_length": 585,
      "index": 427,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Patdiff_kernel.Patdiff_core.Without_unix",
      "library": "comby.patdiff_kernel",
      "description": "This module computes and refines differences between arrays of strings, producing structured hunks that describe changes. It supports operations like splitting text into words or lines, applying formatting rules, and printing or converting diffs to strings. It is used to generate detailed, customizable textual diffs between two files or string sequences.",
      "description_length": 356,
      "index": 428,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Patdiff_kernel.Ascii_output.Rule",
      "library": "comby.patdiff_kernel",
      "description": "Applies a formatting rule to a string, using a specified rule type and refinement flag to determine the output style. It works with strings and formatting rules defined in the `Format.Rule` module, which specify how to present differences in text. This function is used to generate ASCII-based diff outputs with customizable formatting for added, removed, or unchanged lines.",
      "description_length": 375,
      "index": 429,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Patdiff_kernel.Format.Location_style",
      "library": "comby.patdiff_kernel",
      "description": "This module defines a variant type for location formatting styles and functions to process diff hunks with customizable line transformations. It operates on structured text representations like diff hunks and filename metadata, supporting use cases such as generating Omake-compatible error messages or canonicalized diff outputs. Key capabilities include style-based string serialization and contextual line processing rules for precise output control.",
      "description_length": 453,
      "index": 430,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Patdiff_kernel.Format.Style",
      "library": "comby.patdiff_kernel",
      "description": "This module defines a structured type `t` representing terminal text styling options like bold, underline, and colors, with operations for comparison, validation, and ordering. It includes submodules for managing style sets with set-theoretic operations, style maps with key-based associations and transformations, and a comparator module enforcing consistent ordering of style values. Use it to load and validate style presets, generate hashes for style configurations, merge formatting rules with custom logic, or determine style precedence during diff rendering. The module supports S-expression conversion, binary serialization, and integrates with Quickcheck for testing style manipulations.",
      "description_length": 696,
      "index": 431,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Patdiff_kernel.Patdiff_core.S",
      "library": "comby.patdiff_kernel",
      "description": "This module computes and refines line-based diffs between arrays of strings, producing structured hunks that represent additions, deletions, and changes. It supports detailed formatting control, ANSI iteration, and output customization, including unified line display and interleaving. Typical uses include generating human-readable file differences and processing string sequences with precise alignment and visual enhancements.",
      "description_length": 429,
      "index": 432,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Patdiff_kernel.Format.Rules",
      "library": "comby.patdiff_kernel",
      "description": "This module defines the formatting rules applied to different elements of a diff, such as lines, words, and headers, using the `Rule.t` type. It includes specific fields for same, previous, next, and unified line and word differences, as well as hunk and header formatting. These rules are used to customize the visual appearance of diffs, such as applying prefixes, suffixes, or styles, and can be modified or stripped for different output requirements.",
      "description_length": 454,
      "index": 433,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Patdiff_kernel.Html_output.Private",
      "library": "comby.patdiff_kernel",
      "description": "This module generates styled HTML diffs by applying formatting rules to text hunks and file metadata. It supports operations like syntax highlighting, indentation control, and hunk rendering to produce customizable, human-readable diff visualizations. Main data types include hunks, file names, and styling rules, which are combined to build structured HTML output. For example, it can transform a list of code changes into a color-coded, line-numbered HTML document suitable for web display.",
      "description_length": 492,
      "index": 434,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Patdiff_kernel.Is_binary",
      "library": "comby.patdiff_kernel",
      "description": "Detects whether a given string represents a binary file using heuristics such as the presence of null bytes or non-printable characters. Operates directly on string inputs to determine binary content. Useful for tools that need to filter or handle binary files differently during processing or diffing operations.",
      "description_length": 313,
      "index": 435,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Patdiff_kernel.Html_output",
      "library": "comby.patdiff_kernel",
      "description": "This module generates customizable HTML visualizations of text differences by applying styling rules to hunks of file changes, supporting both unified and side-by-side layouts. It processes structured diff data, including file names, line changes, and formatting directives, to produce human-readable HTML output with features like syntax highlighting and line numbering. The core operations combine `Rule.t`-based styling with text hunks to render color-coded additions, deletions, and context lines. For example, it can convert a list of code modifications into a styled HTML document suitable for web-based diff viewers.",
      "description_length": 623,
      "index": 436,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Patdiff_kernel.Comparison_result",
      "library": "comby.patdiff_kernel",
      "description": "This module represents the result of comparing two files in a diffing operation, distinguishing between binary equivalence, binary differences, and structured textual differences (hunks). It provides functions to generate comparison results based on configuration and input files, and to check whether there are any differences. Concrete use cases include determining if files are identical, identifying binary mismatches, or analyzing structured text differences in version control or file comparison tools.",
      "description_length": 508,
      "index": 437,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Patdiff_kernel.Patdiff_core",
      "library": "comby.patdiff_kernel",
      "description": "This module provides core types and utilities for computing and formatting differences between string sequences, with customizable thresholds and whitespace normalization. It supports line- and word-based diffing through structured hunks that represent additions, deletions, and changes, enabling precise control over output formatting, including ANSI styling and line splitting. Submodules refine these diffs with advanced display rules, interleaving, and conversion to various textual representations. Use it to build tools that generate colorized, human-readable diffs or process and visualize textual differences in files and string sequences.",
      "description_length": 647,
      "index": 438,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Patdiff_kernel.Float_tolerance",
      "library": "comby.patdiff_kernel",
      "description": "This module adjusts diff hunks by converting changes in floating-point numbers within a specified percentage tolerance into context lines. It operates on hunks representing textual differences and modifies them based on numeric similarity thresholds. Use it when comparing files where small floating-point differences should be treated as insignificant, such as in test output or configuration files.",
      "description_length": 400,
      "index": 439,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Patdiff_kernel.File_name",
      "library": "comby.patdiff_kernel",
      "description": "Handles file name representations with support for real and fake file names, providing operations to compare, display, and manipulate them. Works with a custom type `t` that distinguishes between actual file paths and alternative display names. Useful for tools that need to track both the source of a file and how it should be presented, such as in diffs or logging.",
      "description_length": 367,
      "index": 440,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Patdiff_kernel.Should_keep_whitespace",
      "library": "comby.patdiff_kernel",
      "description": "Determines whether whitespace should be preserved in diff comparisons based on input characteristics, such as whether the input resembles Python code. It provides two functions: `for_diff` takes structured diff inputs, while `for_diff_array` accepts file names and line arrays. This module is used to adjust diff behavior for languages where whitespace is semantically significant, ensuring accurate comparison and formatting.",
      "description_length": 426,
      "index": 441,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Patdiff_kernel.Diff_input",
      "library": "comby.patdiff_kernel",
      "description": "This module represents input data for a diff operation, pairing a name with its corresponding text content. It provides accessors to retrieve and manipulate these fields, enabling the definition of two text versions to compare. Its submodules offer operations like folding, mapping, and converting fields into lists, allowing tasks such as extracting all names, transforming text content, or validating name patterns. For example, it can format all text fields, check if names match a regex, or collect name-text pairs into structured data.",
      "description_length": 540,
      "index": 442,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Patdiff_kernel.Ansi_output",
      "library": "comby.patdiff_kernel",
      "description": "This module handles ANSI styling and formatted output for diffs, applying text styles to strings and printing structured diff hunks with customizable formatting rules. It supports operations like styling text with ANSI escape codes and rendering diff hunks with visual distinctions such as color and emphasis. The child module enhances this by applying formatting rules to strings, enabling syntax highlighting or custom visual cues in terminal output. Together, they allow precise control over terminal appearance when displaying diffs, file names, or structured text.",
      "description_length": 569,
      "index": 443,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Patdiff_kernel.Ascii_output",
      "library": "comby.patdiff_kernel",
      "description": "This module formats and prints diff hunks as ASCII text, applying customizable rules and location styles to generate readable textual diffs. It works with file names, diff rules, and hunks data structures, supporting operations like rendering side-by-side or unified diffs with custom headers and line numbering. The child module handles the application of formatting rules to strings, using rule types and refinement flags to control the presentation of added, removed, or unchanged lines. Together, they enable precise control over diff visualization in terminal environments.",
      "description_length": 578,
      "index": 444,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Patdiff_kernel.Hunks",
      "library": "comby.patdiff_kernel",
      "description": "Processes and manipulates diff hunks generated by a patience diff algorithm. It provides operations to iterate over hunks and individual lines, enabling custom processing of differences between two sequences. Useful for rendering diffs in a structured format or applying transformations to matched and mismatched line groups.",
      "description_length": 325,
      "index": 445,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Patdiff_kernel.Configuration",
      "library": "comby.patdiff_kernel",
      "description": "This module manages settings that control diff computation and display, offering operations to create, query, and validate configurations with structured parameters such as formatting directives, comparison rules, and output constraints. It supports direct manipulation of `Configuration.t` values, including functions like `fold`, `iter`, and `to_list` for inspecting and transforming individual fields such as `Location_style.t` and `Percent.t`, enabling dynamic adaptation of diffing behavior. A configuration can be extended with an external comparison command and change notification callback using `with_ext_cmp`, integrating custom diff tools and side effects like logging. Use cases include tailoring diff sensitivity for code review or numerical data comparison, generating configuration reports, and customizing output formatting based on structured settings.",
      "description_length": 869,
      "index": 446,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Patdiff_kernel.Output",
      "library": "comby.patdiff_kernel",
      "description": "This module configures output formats for diff results, supporting ANSI, ASCII, and HTML with comparison, serialization, and deserialization capabilities. It enables selection and processing of diff representations for command-line or web output, working with hunks, formatting rules, and structured text transformations. The styling submodule renders differences with customizable formatting for file names and hunks, while the formatting submodule applies and refines text output using specific rules. Example uses include generating colorized terminal diffs or exporting structured HTML comparisons with rule-based styling.",
      "description_length": 626,
      "index": 447,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Patdiff_kernel.Format",
      "library": "comby.patdiff_kernel",
      "description": "This module organizes the core components for defining and applying structured text formatting in diff output. It centers on terminal styling through types like `Style.t`, which captures attributes such as bold, underline, and color models including RGB6 and Gray24, and supports sets and maps for managing style combinations and comparisons. Formatting rules combine these styles with affixes to mark differences, enabling precise control over how elements like lines, words, and headers are rendered\u2014such as adding a red \"-\" prefix to deletions or wrapping changes in bold markers. It also supports location-based formatting styles and transformations for structured diff elements, allowing output customization for contexts like error messages or canonicalized diffs.",
      "description_length": 770,
      "index": 448,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Patdiff_kernel.Import",
      "library": "comby.patdiff_kernel",
      "description": "This module defines function composition operators `(>>)` and `(<<)` that combine two functions sequentially. It works with any functions where the output type of the first matches the input type of the second. These operators are useful for chaining transformations, such as processing data through multiple stages like parsing then validating input.",
      "description_length": 351,
      "index": 449,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Patdiff_kernel",
      "library": "comby.patdiff_kernel",
      "description": "This module suite performs structured diffing and comparison of text and binary files, producing customizable visualizations and output formats. Core data types include hunks for representing textual differences, `Rule.t` for styling, `Style.t` for terminal formatting, and `Configuration.t` for controlling diff behavior. Operations range from binary detection and whitespace handling to ANSI/HTML rendering, numeric tolerance adjustments, and function composition for transformation pipelines. Examples include generating colorized terminal diffs, filtering insignificant floating-point differences, or exporting structured HTML comparisons with syntax highlighting and custom layouts.",
      "description_length": 687,
      "index": 450,
      "embedding_norm": 0.9999999403953552
    }
  ],
  "filtering": {
    "total_modules_in_package": 452,
    "meaningful_modules": 451,
    "filtered_empty_modules": 1,
    "retention_rate": 0.9977876106194691
  },
  "statistics": {
    "max_description_length": 1115,
    "min_description_length": 246,
    "avg_description_length": 432.17738359201775,
    "embedding_file_size_mb": 1.639042854309082
  }
}