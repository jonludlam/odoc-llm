{
  "package": "liquid_parser",
  "embedding_model": "Qwen/Qwen3-Embedding-0.6B",
  "embedding_dimension": 1024,
  "total_modules": 11,
  "creation_timestamp": "2025-07-15T23:06:39.141930",
  "modules": [
    {
      "module_path": "Liquid_parser.Expression",
      "library": "liquid_parser",
      "description": "This module converts lexical values and tokens into expression structures, handling parsing of expressions and assignments from token lists. It operates on lex values, lex tokens, and abstract syntax trees (ASTs) defined in the Liquid syntax module. Concrete use cases include transforming raw template syntax into executable expressions and parsing variable assignments during template compilation.",
      "description_length": 399,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Liquid_parser.Parser_tools",
      "library": "liquid_parser",
      "description": "This module provides functions for parsing and transforming Liquid template syntax. It handles operations like scanning token lists until end-of-sequence, extracting variable contexts, and parsing body content from token streams. It works directly with Liquid syntax tokens and context structures, enabling precise manipulation of template elements during compilation.",
      "description_length": 368,
      "index": 1,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Liquid_parser.Keyword_lexer",
      "library": "liquid_parser",
      "description": "This module handles lexical analysis of keywords and block tokens in a string-based input. It provides operations to check if a string is an operator, tokenize keywords, convert strings to block tokens, and determine if a string represents a block token or whitespace. Concrete use cases include parsing templating syntax where specific keywords and block structures need to be identified from raw text.",
      "description_length": 403,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Liquid_parser.Lexer",
      "library": "liquid_parser",
      "description": "This module provides functions to tokenize Liquid template syntax, handling primitives like booleans, numbers, strings, identifiers, and delimiters. It processes strings into lexical tokens and supports operations for parsing inline and block-level Liquid structures. Use cases include parsing template expressions, extracting tokens from Liquid code, and building structured representations of Liquid templates for further processing.",
      "description_length": 435,
      "index": 3,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Liquid_parser.Theme",
      "library": "liquid_parser",
      "description": "This module provides functions to parse and render Liquid template syntax, handling forms, styles, and themes. It processes lists of lex tokens to produce abstract syntax trees (ASTs) and returns remaining tokens after parsing. It is used to interpret Liquid template directives in web development contexts, such as rendering dynamic content or processing template blocks.",
      "description_length": 372,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Liquid_parser.Parser",
      "library": "liquid_parser",
      "description": "This module implements parsing routines for Liquid template syntax, handling operations like parsing test expressions, cycles, loops, and assignments. It processes lists of lexical tokens into abstract syntax trees (ASTs) and supports partial parsing for specific Liquid constructs. Use cases include parsing Liquid templates into executable ASTs, validating token sequences, and extracting structured data from token streams.",
      "description_length": 426,
      "index": 5,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Liquid_parser.For",
      "library": "liquid_parser",
      "description": "This module handles parsing of loop-like structures in Liquid templates, specifically `for`, `tablerow`, and `paginate` blocks. It operates on lexed token streams, producing abstract syntax trees for these constructs. Concrete use cases include transforming Liquid template loops into executable AST nodes during the parsing phase.",
      "description_length": 331,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Liquid_parser.Bounds",
      "library": "liquid_parser",
      "description": "This module handles boundary detection and conflict resolution for token sequences in a parser. It defines bound structures using start and stop tokens, identifies conflicting token sequences, and partitions token lists into chunks based on detected bounds. It is used to manage nested or overlapping syntactic constructs in the parsing process.",
      "description_length": 345,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Liquid_parser.Test",
      "library": "liquid_parser",
      "description": "This module constructs and parses conditional logic from token streams using a series of combinator functions. It processes lexed tokens into structured conditions and combines them using logical operators, supporting the parsing of `if`, `when`, and chained conditional statements. Concrete use cases include transforming raw Liquid template syntax into executable condition trees during template compilation.",
      "description_length": 410,
      "index": 8,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Liquid_parser.Preprocessor",
      "library": "liquid_parser",
      "description": "This module handles text preprocessing for Liquid templates by providing regex utilities, comment removal, and raw block manipulation. It works with strings and Re2 regular expressions, offering operations like pattern removal, tag stripping, and EOF appending. Concrete use cases include cleaning template input by removing comments, extracting or skipping raw Liquid blocks, and preparing strings for further parsing.",
      "description_length": 419,
      "index": 9,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Liquid_parser",
      "library": "liquid_parser",
      "description": "This module suite transforms Liquid template syntax into executable abstract syntax trees by processing raw text through lexical analysis, tokenization, and structured parsing. It provides data types such as lex tokens, AST nodes, and bound structures, with operations to parse expressions, conditionals, loops, and variable assignments, along with utilities for text preprocessing and token stream manipulation. Examples include converting a `for` loop in a template into an AST node, extracting a variable assignment from a token list, or cleaning template input by stripping comments and raw blocks.",
      "description_length": 602,
      "index": 10,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 11,
    "meaningful_modules": 11,
    "filtered_empty_modules": 0,
    "retention_rate": 1.0
  },
  "statistics": {
    "max_description_length": 602,
    "min_description_length": 331,
    "avg_description_length": 410.0,
    "embedding_file_size_mb": 0.040383338928222656
  }
}