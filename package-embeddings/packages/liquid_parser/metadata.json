{
  "package": "liquid_parser",
  "embedding_model": "Qwen/Qwen3-Embedding-8B",
  "embedding_dimension": 4096,
  "total_modules": 11,
  "creation_timestamp": "2025-08-14T23:12:43.749087",
  "modules": [
    {
      "module_path": "Liquid_parser.Parser_tools",
      "library": "liquid_parser",
      "description": "This module provides functions for parsing and transforming Liquid template syntax. It handles operations like scanning token lists until end-of-stream, parsing variable contexts, and extracting body content from single tokens. These functions work directly with lexed token lists and context structures to support template compilation tasks such as variable resolution and block parsing.",
      "description_length": 388,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Liquid_parser.Parser",
      "library": "liquid_parser",
      "description": "This module implements parsing routines for Liquid template syntax, converting token lists into abstract syntax trees (ASTs) for specific Liquid constructs like `cycle`, `for`, `paginate`, and expressions. It provides functions to parse individual elements or full token streams, returning the resulting AST along with remaining tokens. Use cases include processing Liquid templates into executable syntax trees for rendering or analysis.",
      "description_length": 438,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Liquid_parser.Theme",
      "library": "liquid_parser",
      "description": "This module handles parsing of theme-related Liquid syntax elements, including render, form, style, and theme blocks. It processes lexed token streams to construct abstract syntax trees (ASTs) for these structures, returning the parsed AST along with remaining tokens. It is used during template compilation to interpret theme-specific directives embedded in Liquid templates.",
      "description_length": 376,
      "index": 2,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Liquid_parser.Bounds",
      "library": "liquid_parser",
      "description": "This module handles boundary detection and conflict resolution in token streams by defining bound finders that identify start and stop tokens, with optional conflict rules. It provides functions to create and manipulate boundary pairs, detect conflicts based on token positions, and split token lists into chunks using computed bounds. Use cases include parsing nested structures and managing token delimiters in templating or expression parsing workflows.",
      "description_length": 456,
      "index": 3,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Liquid_parser.Keyword_lexer",
      "library": "liquid_parser",
      "description": "This module handles lexical analysis of keywords and block tokens in a string-based input. It provides functions to identify operators, parse keywords into tokens, and determine whether strings represent block tokens or whitespace. Use cases include parsing template languages or domain-specific languages where keyword recognition and tokenization are required.",
      "description_length": 362,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Liquid_parser.Expression",
      "library": "liquid_parser",
      "description": "This module converts lexical values and tokens into abstract syntax expressions for a templating language. It includes functions to transform single or list lexical values into expressions, parse expressions from token lists, and handle assignments within expressions. Use cases include building and manipulating template logic from tokenized input during rendering.",
      "description_length": 366,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Liquid_parser.Lexer",
      "library": "liquid_parser",
      "description": "This module provides functions to tokenize and parse Liquid template syntax elements like numbers, strings, identifiers, and block structures. It processes strings into lexical tokens and handles complex tokenization tasks such as delimited strings, boolean values, and range expressions. Use cases include parsing Liquid templates into an abstract syntax tree and extracting expressions from template files.",
      "description_length": 408,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Liquid_parser.Test",
      "library": "liquid_parser",
      "description": "This module constructs conditional expressions from lexical tokens, combining them into structured logic for template parsing. It processes token lists into conditions using operators and combinators, supporting branching logic in template syntax. Used to parse `if`, `when`, and chained conditional statements into an abstract syntax tree.",
      "description_length": 340,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Liquid_parser.For",
      "library": "liquid_parser",
      "description": "This module handles parsing of loop-like structures in Liquid templates, specifically `for`, `tablerow`, and `paginate` blocks. It processes token lists to construct abstract syntax trees for these control structures, supporting iteration over collections and pagination of content. Use cases include transforming Liquid template loops into executable AST nodes during template compilation.",
      "description_length": 390,
      "index": 8,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Liquid_parser.Preprocessor",
      "library": "liquid_parser",
      "description": "This module handles text preprocessing for Liquid templates, providing operations to create regex patterns, remove content matching those patterns, and manipulate raw Liquid blocks. It works with strings and Re2 regex values, focusing on tasks like comment stripping, EOF appending, and raw tag trimming. Concrete use cases include sanitizing template input, extracting or excluding raw sections, and preparing strings for further parsing stages.",
      "description_length": 446,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Liquid_parser",
      "library": "liquid_parser",
      "description": "This module parses Liquid templates into executable abstract syntax trees by tokenizing input, resolving boundaries, and handling control structures. It processes strings into lexical tokens, extracts expressions, and builds AST nodes for loops, conditionals, and theme-specific blocks. Concrete use cases include compiling Liquid templates into renderable structures and analyzing template logic for static validation or transformation.",
      "description_length": 437,
      "index": 10,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 11,
    "meaningful_modules": 11,
    "filtered_empty_modules": 0,
    "retention_rate": 1.0
  },
  "statistics": {
    "max_description_length": 456,
    "min_description_length": 340,
    "avg_description_length": 400.6363636363636,
    "embedding_file_size_mb": 0.15981578826904297
  }
}