{
  "package": "psmt2-frontend",
  "embedding_model": "Qwen/Qwen3-Embedding-8B",
  "embedding_dimension": 4096,
  "total_modules": 15,
  "creation_timestamp": "2025-08-14T23:23:40.070760",
  "modules": [
    {
      "module_path": "Psmt2Frontend.Smtlib_typed_env.SMap",
      "library": "psmt2-frontend",
      "description": "This module implements a polymorphic map structure with string-based keys, enabling operations like insertion, deletion, merging, and ordered traversal through standard dictionary utilities. It provides functions for querying, transformation, and comparison of key-value pairs, along with conversions to and from sequences and lists, supporting both total and optional value handling. Such capabilities make it suitable for applications requiring efficient associative lookups and ordered data processing, such as configuration management, symbol table implementations, or structured key-value sequence manipulation.",
      "description_length": 616,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Psmt2Frontend.Smtlib_ty.IMap",
      "library": "psmt2-frontend",
      "description": "This module implements integer-keyed maps with arbitrary value types, supporting modification (addition, removal, updates), traversal (iteration, folding, binding extraction), and transformation (mapping, filtering, partitioning). It facilitates conversions between maps and sequences of key-value pairs, enabling bulk operations and ordered processing. Use cases include managing associative data with integer identifiers, processing SMT-LIB terms requiring ordered key-value associations, and efficiently accumulating values into lists under integer keys.",
      "description_length": 557,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Psmt2Frontend.Smtlib_ty",
      "library": "psmt2-frontend",
      "description": "This module manages type representations and manipulations for SMT-LIB terms, including type creation, substitution, unification, and inspection. It works with a custom type structure that includes type descriptors and identifiers, supporting operations like function return extraction, boolean and dummy type checks, and datatype name retrieval. Concrete use cases include type processing during SMT-LIB parsing, type inference, and transformation tasks in SMT solvers.",
      "description_length": 470,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Psmt2Frontend.Smtlib_lexer",
      "library": "psmt2-frontend",
      "description": "This module implements a lexer for SMT-LIB input, handling tokenization of SMT expressions. It processes character streams into structured tokens, tracks line breaks, and manages comments and keywords. Concrete use cases include parsing SMT assertions, declarations, and commands from text input.",
      "description_length": 296,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Psmt2Frontend.Smtlib_printer",
      "library": "psmt2-frontend",
      "description": "This module transforms structured SMT-LIB abstract syntax trees into human-readable string representations, focusing on elements like types, terms, declarations, and commands. It operates on data structures defined in `Smtlib_syntax` to serialize complex AST nodes\u2014such as variable bindings, propositional literals, and environment metadata\u2014into formatted output. The primary use cases include generating debug logs, producing SMT-LIB-compliant input files for solvers, and visualizing intermediate representations during formal verification tasks.",
      "description_length": 548,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Psmt2Frontend.Main",
      "library": "psmt2-frontend",
      "description": "Implements the entry point for launching the application, coordinating initialization and execution flow. Works with system-level interfaces and internal components to start the program. Use to bootstrap the environment and trigger core runtime processes.",
      "description_length": 255,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Psmt2Frontend.Smtlib_typed_logic",
      "library": "psmt2-frontend",
      "description": "This module defines typed logic theories for SMT-LIB, including built-in sorts, functions, and parameterized functions for theories like integers, real numbers, arrays, and bitvectors. It supports creating function definitions with type signatures and associations, and integrates logic definitions into an environment. Concrete use cases include setting up SMT solvers with specific theories and managing typed expressions in formal verification tasks.",
      "description_length": 453,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Psmt2Frontend.Smtlib_typing",
      "library": "psmt2-frontend",
      "description": "This module implements type checking and inference for SMT-LIB syntax trees, handling operations like type instantiation, unification, and pattern matching. It works with typed environments, type expressions, and SMT-LIB syntax nodes annotated with positional data. It is used to validate and assign types to terms, constants, identifiers, and commands in an SMT-LIB frontend, ensuring correctness during parsing and transformation.",
      "description_length": 432,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Psmt2Frontend.Smtlib_syntax",
      "library": "psmt2-frontend",
      "description": "This module defines the syntax tree for SMT-LIB commands and expressions, including constants, symbols, keywords, and a wide range of SMT solver commands such as assertions, declarations, definitions, and control operations. It works with data types like terms, sorts, symbols, and attributes, organizing them into structured command types for parsing and generating SMT-LIB input. Concrete use cases include building and manipulating SMT solver scripts, implementing SMT-LIB parsers, and interfacing with SMT solvers through standardized command sequences.",
      "description_length": 557,
      "index": 8,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Psmt2Frontend.Smtlib_error",
      "library": "psmt2-frontend",
      "description": "This module defines a comprehensive set of error types for handling various SMT-LIB parsing and typing issues, such as lexical, syntax, and type declaration errors. It provides functions to report errors with source locations, print detailed error messages, and raise or emit warnings based on error conditions. These operations are used during SMT-LIB input processing to ensure precise error detection and user feedback.",
      "description_length": 422,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Psmt2Frontend.Version",
      "library": "psmt2-frontend",
      "description": "Stores and provides access to the current version of the application as a string. Exposes a single value `version` that can be used to retrieve the version identifier. Useful for displaying version information in logs, error messages, or user-facing outputs.",
      "description_length": 258,
      "index": 10,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Psmt2Frontend.Smtlib_typed_env",
      "library": "psmt2-frontend",
      "description": "This module provides operations for managing SMT-LIB sorts, functions, and algebraic datatypes through a typed environment and string-keyed polymorphic maps. It supports parsing and type-checking workflows by enabling symbol table construction, sort/function definition registration, and datatype constructor manipulation. Key use cases include resolving identifiers during expression parsing, validating function type signatures, and binding algebraic datatypes with their associated constructors and sorts in SMT-LIB contexts.",
      "description_length": 528,
      "index": 11,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Psmt2Frontend.Smtlib_parser",
      "library": "psmt2-frontend",
      "description": "Parses SMT-LIB formatted input into abstract syntax trees representing terms and commands. It processes lexical tokens to build structured representations of SMT queries, logic directives, and solver interactions. Useful for reading and interpreting SMT-LIB scripts during automated reasoning tasks.",
      "description_length": 299,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Psmt2Frontend.Options",
      "library": "psmt2-frontend",
      "description": "This module provides functions to configure and query global solver settings that control behavior such as verbosity, assertion modes, logic-specific theories (e.g., QF, FP), and error formatting. It uses boolean, integer, and string values to manage these parameters, enabling customization for tasks like formal verification of software properties or hardware models where specific theories and diagnostic outputs are required.",
      "description_length": 429,
      "index": 13,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Psmt2Frontend",
      "library": "psmt2-frontend",
      "description": "This module implements core components for processing SMT-LIB input, including lexing, parsing, type checking, and error handling. It works with SMT-LIB syntax trees, typed environments, and solver configuration parameters to support tasks like formal verification and automated reasoning. Concrete use cases include parsing and type-checking SMT-LIB scripts, generating solver input files, and managing solver configurations for logic-specific theories.",
      "description_length": 454,
      "index": 14,
      "embedding_norm": 0.9999999403953552
    }
  ],
  "filtering": {
    "total_modules_in_package": 16,
    "meaningful_modules": 15,
    "filtered_empty_modules": 1,
    "retention_rate": 0.9375
  },
  "statistics": {
    "max_description_length": 616,
    "min_description_length": 255,
    "avg_description_length": 438.26666666666665,
    "embedding_file_size_mb": 0.21776294708251953
  }
}