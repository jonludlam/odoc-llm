{
  "package": "dedukti",
  "embedding_model": "Qwen/Qwen3-Embedding-8B",
  "embedding_dimension": 4096,
  "total_modules": 55,
  "creation_timestamp": "2025-08-15T15:51:06.079837",
  "modules": [
    {
      "module_path": "Kernel.Srcheck.SRChecker",
      "library": "dedukti.kernel",
      "description": "This module manages typing constraints for terms under abstractions, providing operations to check convertibility, extract substitutions, and optimize constraint sets. It works with terms, constraints, and extended substitutions from the `Kernel` module suite. It is used to validate type equality and infer substitutions when processing lambda terms in a typed rewriting system.",
      "description_length": 379,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kernel.Basic.NameSet",
      "library": "dedukti.kernel",
      "description": "This module supports creation, modification, and querying of ordered sets containing `Kernel.Basic.name` elements, leveraging a total ordering for deterministic behavior in operations like union, intersection, and sorted element traversal. It provides functional transformations (e.g., `map`, `filter`), bulk conversions to and from lists/sequences, and precise membership checks, making it suitable for managing unique identifiers, performing set algebra, or building data transformation pipelines with immutable collections.",
      "description_length": 526,
      "index": 1,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kernel.Typing.Default",
      "library": "dedukti.kernel",
      "description": "Implements default type inference and checking algorithms for terms in a given signature and context. It provides concrete implementations of the `infer`, `check`, `checking`, `inference`, and `check_rule` functions, operating on terms, types, and rules from the `Kernel` module suite. Used to validate type correctness of expressions and inference rules within a formal system.",
      "description_length": 378,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kernel.Typing.Make",
      "library": "dedukti.kernel",
      "description": "This module implements type inference and checking for terms within a given signature and context, providing functions to verify type correctness and deduce types. It operates on terms and types defined in `Kernel.Term` and `Kernel.Typing`, validating rules through type checking. Concrete use cases include verifying function application types, ensuring term consistency in logical frameworks, and validating inference rules within a formal system.",
      "description_length": 449,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kernel.Exsubst.ExSubst",
      "library": "dedukti.kernel",
      "description": "This module manages extended substitutions for de Bruijn-indexed variables in terms, primarily used during type inference to compute and apply most general unifiers. It supports operations to construct, apply, and compose substitutions, with specialized handling for nested lambda contexts and context-shifting scenarios. Concrete use cases include constraint-based type inference and type-preserving term transformations in lambda calculi.",
      "description_length": 440,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kernel.Basic.MidentSet",
      "library": "dedukti.kernel",
      "description": "This module provides standard set operations for managing ordered collections of `mident` elements, including creation, modification (union, intersection, difference), membership checks, and ordered traversal. It works with sets (`MidentSet.t`) and sequences (`Seq`) of `mident`, leveraging ordered comparisons for efficient querying and transformations. Specific use cases include maintaining sorted identifier collections, performing ordered set arithmetic, and converting between sets and sequences for iterative processing.",
      "description_length": 527,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kernel.Basic.LList",
      "library": "dedukti.kernel",
      "description": "This module implements a lightweight linked list structure with operations for construction, transformation, and element access. It supports constant-time head addition via `cons`, length calculation, conversion to and from standard lists and arrays, indexed access with `nth`, and mapping with optional index awareness. Use cases include efficient list processing where prepend operations and traversal are frequent, such as in parser combinators or stream processing.",
      "description_length": 469,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kernel.Reduction.Make",
      "library": "dedukti.kernel",
      "description": "Implements term reduction strategies and conversion testing for terms in a given signature. Provides functions to check convertibility, compute normal forms (weak head and strong), and handle rule constraints during term rewriting. Useful for verifying term equivalence and performing stepwise reductions in formal systems.",
      "description_length": 323,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kernel.Basic.Debug",
      "library": "dedukti.kernel",
      "description": "This module provides runtime debugging controls through flags that conditionally enable or disable diagnostic messages and code evaluation. It works with boolean flags associated with named debug channels, allowing selective output of formatted messages to standard error or execution of debug-only code blocks. Concrete use cases include tracing function calls, inspecting variable states, and logging warnings or notices during development without impacting production runs.",
      "description_length": 476,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kernel.Matching.Make",
      "library": "dedukti.kernel",
      "description": "Implements term matching with support for associative-commutative (AC) normalization and higher-order pattern matching. It operates on terms and matching problems using reduction strategies (`whnf`, `snf`) and convertibility checks to solve constraints during unification. Useful for implementing rewriting systems or logic engines where partial term matching under equational theories is required.",
      "description_length": 398,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kernel.Reduction.Default",
      "library": "dedukti.kernel",
      "description": "Implements default reduction strategies and conversion checks for terms in a signature. It supports weak head normal form computation, full strong normalization, and stepwise conversion testing between terms. Useful for evaluating term equivalence and applying reduction rules during type checking or proof validation.",
      "description_length": 318,
      "index": 10,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kernel.Basic.IdentSet",
      "library": "dedukti.kernel",
      "description": "This module implements ordered sets of identifiers (`mident`) with structural comparison, supporting standard set operations like union, intersection, and difference alongside ordered queries for min/max elements or ordered enumeration. It provides transformations through iteration, mapping, and filtering, along with sequence conversions that preserve sorted order during additions or construction. Typical use cases include managing identifier collections requiring consistent ordering, efficient membership checks, or ordered traversal in compiler or analysis tools.",
      "description_length": 570,
      "index": 11,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kernel.Matching",
      "library": "dedukti.kernel",
      "description": "Implements term matching with support for associative-commutative normalization and higher-order pattern matching. It operates on terms and matching problems using reduction strategies (`whnf`, `snf`) and convertibility checks to solve constraints during unification. Useful for implementing rewriting systems or logic engines where partial term matching under equational theories is required.",
      "description_length": 393,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kernel.Basic",
      "library": "dedukti.kernel",
      "description": "This module offers identifier management (`ident`, `mident`, `name`) with equality checks, ordered sets (`IdentSet`, `MidentSet`, `NameSet`), linked list transformations via `LList`, and source code location handling through `loc`. It provides compositional printers for structured data like tuples, lists, and options, enabling tasks such as variable binding analysis, source position tracking, and diagnostic output generation in compiler or interpreter workflows.",
      "description_length": 466,
      "index": 13,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kernel.Reduction",
      "library": "dedukti.kernel",
      "description": "Implements term reduction strategies and conversion testing for terms in a signature. It supports weak head normal form computation, full strong normalization, and stepwise conversion testing between terms. Useful for evaluating term equivalence and applying reduction rules during type checking or proof validation.",
      "description_length": 316,
      "index": 14,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kernel.Version",
      "library": "dedukti.kernel",
      "description": "Contains the current version of Dedukti as a string. Exposes the version number for runtime access and external reporting. Useful for debugging, logging, and ensuring compatibility with specific Dedukti releases.",
      "description_length": 212,
      "index": 15,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kernel.Subst",
      "library": "dedukti.kernel",
      "description": "This module manipulates terms using DeBruijn indices through operations like substitution, shifting, and unshifting. It supports concrete tasks such as replacing specific variables in a term, adjusting variable indices during lambda traversal, and checking variable occurrence. Use cases include implementing lambda calculus transformations, managing variable binding in compilers, and handling term rewriting systems.",
      "description_length": 418,
      "index": 16,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kernel.Term",
      "library": "dedukti.kernel",
      "description": "This module provides operations for constructing, comparing, and transforming lambda terms with support for variable binding, substitution, and algebraic reasoning (e.g., associativity, commutativity). It works with terms represented via de Bruijn indices and contexts that track variable mappings to terms or integers, enabling manipulation of untyped, partially typed, or fully typed lambda expressions. These capabilities are critical in formal systems like proof assistants or compilers where precise term management and syntactic transformations are required.",
      "description_length": 564,
      "index": 17,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kernel.Typing",
      "library": "dedukti.kernel",
      "description": "This module performs type inference and checking for terms in a formal system, implementing algorithms to validate type correctness and deduce types within a given context. It works with terms, types, and inference rules defined in related modules, handling operations like type conversion, context validation, and constraint resolution. Concrete use cases include verifying function application types, enforcing type consistency in logical expressions, and validating inference rules during proof construction.",
      "description_length": 511,
      "index": 18,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kernel.Rule",
      "library": "dedukti.kernel",
      "description": "This system provides mechanisms for defining and enforcing rewrite rules in a lambda calculus with pattern matching, operating on terms, patterns, identifiers, and arity contexts. It supports rule transformation, constraint",
      "description_length": 223,
      "index": 19,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kernel.Exsubst",
      "library": "dedukti.kernel",
      "description": "This module implements operations for managing extended substitutions over de Bruijn-indexed variables, including construction, application, and composition of substitutions. It handles context-shifting and nested lambda contexts, supporting type inference tasks such as unifier computation and term transformation. Used in constraint-based type systems and type-preserving compilation passes involving lambda terms.",
      "description_length": 416,
      "index": 20,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kernel.Confluence",
      "library": "dedukti.kernel",
      "description": "This module implements a confluence checker for term rewriting systems. It tracks constants and rewrite rules, then analyzes their interactions to detect overlaps and critical pairs. Use it to verify that a set of rewrite rules will always produce the same result regardless of application order.",
      "description_length": 296,
      "index": 21,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kernel.Dtree",
      "library": "dedukti.kernel",
      "description": "This module implements decision trees for pattern matching compilation, handling operations like case analysis, variable binding, and constraint checking during matching. It works with algebraic data types representing terms, patterns, and metavariables, along with structured matching problems involving equational and AC-matching constraints. Concrete use cases include compiling rewrite rules into efficient matching code and validating term structures against patterns in a reduction engine.",
      "description_length": 495,
      "index": 22,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kernel.Srcheck",
      "library": "dedukti.kernel",
      "description": "This module includes a debug flag and a reference for controlling substitution-reduction steps during type checking. It provides the `SRChecker` module to manage typing constraints under abstractions, supporting convertibility checks and substitution extraction. It operates on terms, constraints, and substitutions, specifically validating type equality and inferring substitutions when processing lambda terms in typed rewriting systems.",
      "description_length": 439,
      "index": 23,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kernel.Signature",
      "library": "dedukti.kernel",
      "description": "This module provides operations for managing module signatures, symbol declarations, and rewrite rules, with a focus on algebraic properties, staticity, injectivity, and module confluence. It operates on data structures such as module identifiers, algebraic terms, decision trees, and symbol metadata (including scope, type, and resolution constraints), enabling tasks like type checking, symbol resolution, and rule traversal in a global environment. Specific use cases include enforcing module consistency, resolving symbol dependencies, and maintaining rewrite rule integrity during compilation or program analysis.",
      "description_length": 618,
      "index": 24,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kernel.Ac",
      "library": "dedukti.kernel",
      "description": "This module handles associative-commutative (AC) term manipulations, providing functions to flatten and unflatten terms under a given AC operator. It works with algebraic terms and identifiers combining a name and algebra, supporting operations like equality checks, pretty-printing, and restructuring nested AC terms. Concrete use cases include normalizing expressions involving AC operators such as addition or multiplication, simplifying term comparisons, and rebuilding structured terms from flattened lists.",
      "description_length": 512,
      "index": 25,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kernel",
      "library": "dedukti.kernel",
      "description": "This module organizes core components for term manipulation, rewriting, and type checking in a formal system. It includes submodules for handling associative-commutative terms, decision trees for pattern matching, extended substitutions, term reduction, and confluence analysis, all working with algebraic terms, de Bruijn-indexed variables, and structured contexts. Use cases include building and validating rewrite systems, implementing type-preserving transformations, and performing precise term analysis in proof assistants or compilers.",
      "description_length": 542,
      "index": 26,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Parsers.Parser",
      "library": "dedukti.parsers",
      "description": "This module provides functions to create and manage input sources for parsing, including reading from files, standard input, and strings. It supports parsing streams that yield entries one at a time, with utilities to process entries lazily or collect them into a list. Use cases include parsing command-line input, reading structured data from files, and handling multi-identifier input sources with associated metadata.",
      "description_length": 421,
      "index": 27,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Parsers.Scoping",
      "library": "dedukti.parsers",
      "description": "Performs scope resolution for terms and inference rules, converting preterms into fully scoped terms and partially typed rules. Works with module identifiers, typed contexts, preterms, and rule structures. Used during the transition from parsed, unscoped terms to typed terms ready for type checking.",
      "description_length": 300,
      "index": 28,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Parsers.Menhir_parser",
      "library": "dedukti.parsers",
      "description": "Parses a single line of input into an abstract syntax tree using a Menhir-generated parser. It operates on lexing buffers and token streams to produce structured entries for further processing. This module is used to parse individual lines of a document into semantic units during the loading phase of document processing.",
      "description_length": 322,
      "index": 29,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Parsers.Entry",
      "library": "dedukti.parsers",
      "description": "This module defines data structures and operations for representing and manipulating entries in a formal logic or type-checking system. It includes variants for declarations, definitions, reduction rules, evaluations, tests, type inference, and printing commands, each carrying relevant metadata and terms. Use cases include parsing and processing logical statements, executing reduction rules, performing type checking, and generating output for interactive theorem proving or compiler toolchains.",
      "description_length": 498,
      "index": 30,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Parsers.Tokens",
      "library": "dedukti.parsers",
      "description": "This module defines a rich set of lexical tokens used in parsing a domain-specific language, including keywords, identifiers, operators, and punctuation, each annotated with location information or string values. It supports precise tokenization of input by distinguishing between different syntactic elements like definitions, checks, assertions, and structural symbols. Concrete use cases include feeding the parser with structured tokens during the lexing phase of a compiler or interpreter.",
      "description_length": 494,
      "index": 31,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Parsers.Preterm",
      "library": "dedukti.parsers",
      "description": "This module represents unscoped terms and patterns during parsing, using algebraic data types like `preterm`, `prepattern`, and `prule` to capture syntactic structures before variable binding is resolved. It provides printers like `pp_preterm` and transformations like `clean_pre_pattern` to manipulate and inspect these unscoped representations. Concrete use cases include parsing user input into an abstract syntax tree and preparing terms for later scoping and type checking.",
      "description_length": 478,
      "index": 32,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Parsers.Lexer",
      "library": "dedukti.parsers",
      "description": "This module implements a lexer for parsing source code, converting character streams into tokens for further processing. It handles lexical analysis tasks like tracking source locations, parsing strings, identifiers, and comments, and reporting errors with precise positions. Key data structures include lexing buffers, token streams, and location information used during parsing.",
      "description_length": 380,
      "index": 33,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Parsers",
      "library": "dedukti.parsers",
      "description": "This module implements a complete parsing pipeline for a domain-specific language, starting with lexical analysis and ending with scope resolution. It processes character streams into structured entries through tokenization, line-wise parsing, and unscoped term manipulation. The pipeline supports concrete use cases such as loading and evaluating logical statements, executing reduction rules, and preparing terms for type checking in an interactive theorem prover or compiler toolchain.",
      "description_length": 488,
      "index": 34,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api.Processor.Registration",
      "library": "dedukti.api",
      "description": "This module associates processors with their corresponding modules, ensuring type-safe registration and equality checks. It works with processor types and modules that implement the `Api.Processor.S` signature. Use it to register a processor along with its equality function and retrieve the associated module when needed.",
      "description_length": 322,
      "index": 35,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Api.Processor.MakeDependencies",
      "library": "dedukti.api",
      "description": "Processes entries to build dependency data within a given environment. It handles individual entries and aggregates results into a dependency structure. Useful for analyzing relationships between entries in a processing pipeline.",
      "description_length": 229,
      "index": 36,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api.Processor.T",
      "library": "dedukti.api",
      "description": "This module processes input data and files using parameterized processors, applying optional hooks before and after execution. It supports operations for handling individual inputs, processing lists of files, and folding over file results with custom functions. Concrete use cases include parsing and transforming file contents, validating structured data, and aggregating results from multiple files.",
      "description_length": 401,
      "index": 37,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Api.Meta.LF",
      "library": "dedukti.api",
      "description": "This module reifies terms by prefixing them with their constructors, using a specified signature and context when safety checks are enabled. It encodes and decodes terms and rules, ensuring type correctness when required. Concrete use cases include preparing terms for safe serialization or transformation within a structured logical framework.",
      "description_length": 344,
      "index": 38,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api.Processor.MakeSignatureBuilder",
      "library": "dedukti.api",
      "description": "Builds a signature by processing entries in an environment. It accumulates data into a signature type through entry handling and provides the final result. Useful for constructing cryptographic signatures or structured data from sequential entry processing.",
      "description_length": 257,
      "index": 39,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api.Meta.MetaConfiguration",
      "library": "dedukti.api",
      "description": "Processes meta rewrite-rules from files, transforming and applying them within a given environment. It operates on `Parsers.Entry.entry` inputs and updates the environment with processed rule data. Useful for configuring and managing rule-based transformations in a structured parsing workflow.",
      "description_length": 294,
      "index": 40,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api.Processor.MakeTypeChecker",
      "library": "dedukti.api",
      "description": "This module processes entries within a given environment, using the `handle_entry` function to analyze or transform each entry. It accumulates no data, as indicated by the `t = unit` type, and returns no result beyond side effects. A concrete use case is validating entry structures during a parsing phase, where each entry is checked against schema rules stored in the environment.",
      "description_length": 382,
      "index": 41,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api.Meta.APP",
      "library": "dedukti.api",
      "description": "This module implements term and rule encoding/decoding operations for product types, working with identifiers, signatures, and typed contexts. It provides functions to transform terms and rules while optionally ensuring type safety through signature and context validation. Concrete use cases include preparing terms for serialization or communication between different logical frameworks with type-preserving guarantees.",
      "description_length": 421,
      "index": 42,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Api.Meta.PROD",
      "library": "dedukti.api",
      "description": "This module implements a shallow encoding for product types, supporting term and rule transformations. It provides functions to encode and decode terms, along with safe type checking when enabled, operating on standard kernel terms and rules. It is used to manipulate and rewrite product structures within a given signature and context.",
      "description_length": 336,
      "index": 43,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api.Pp.Default",
      "library": "dedukti.api",
      "description": "This module defines default pretty-printing functions for core data structures used in the system, including identifiers, terms, patterns, rules, and contexts. It provides formatters for displaying lists with custom separators, typed and untyped rules, reduction configurations, and parser entries. These functions are used to generate human-readable representations of internal data during debugging, logging, or user-facing output in command-line tools and IDE integrations.",
      "description_length": 476,
      "index": 44,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Api.Processor.MakeEntryPrinter",
      "library": "dedukti.api",
      "description": "This module processes entries using an environment parameter, providing `handle_entry` to compute and store data from each entry. It works with environments (`Api.Env.t`) and entry data structures (`Parsers.Entry.entry`). A concrete use case is accumulating entry-specific results during a processing pipeline.",
      "description_length": 310,
      "index": 45,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api.Pp.Make",
      "library": "dedukti.api",
      "description": "This module implements printers for various abstract syntax tree components and contextual data using a provided separator and element printer. It supports structured pretty-printing of identifiers, terms, patterns, rules, and contexts, along with configuration and entry types. Concrete use cases include formatting typed rules for display, converting reduction configurations to readable strings, and printing pattern-matching constructs with custom separators.",
      "description_length": 463,
      "index": 46,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api.Processor",
      "library": "dedukti.api",
      "description": "This module processes structured input streams and files using environment-parameterized operations, supporting actions like type checking, signature building, dependency analysis, and entry transformation. It works with input streams (`Parsers.Parser.input`), file paths, and environment (`Api.Env.t`) and entry (`Parsers.Entry.entry`) structures, enabling concrete tasks such as validating entry schemas, aggregating dependencies across files, or constructing cryptographic signatures. Key operations include `handle_input` for single inputs, `handle_files` for batch file processing, and `fold_files` for accumulating results across multiple files, with optional before/after hooks for instrumentation or error handling.",
      "description_length": 723,
      "index": 47,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api.Files",
      "library": "dedukti.api",
      "description": "Handles file path management and module-to-file resolution for a modular system. It supports operations to add and retrieve load paths, locate object files and `.dk` files for specific modules, and map inputs to filenames. Used during module loading and compilation to resolve file dependencies and paths.",
      "description_length": 305,
      "index": 48,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api.Pp",
      "library": "dedukti.api",
      "description": "This module implements configurable pretty-printing for abstract syntax trees and contextual data structures, supporting identifiers, terms, patterns, rules, and contexts. It allows custom separators and formatting through the `Make` functor, while `Default` provides standard formatters for debugging, logging, and user-facing output. Concrete use cases include displaying typed rules with custom separators, converting reduction configurations to strings, and printing pattern-matching constructs in command-line tools or IDEs.",
      "description_length": 529,
      "index": 49,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api.Meta",
      "library": "dedukti.api",
      "description": "This module provides functions to reify and manipulate Dedukti terms using customizable encodings, supporting operations like term normalization, rule application, and type-safe transformations. It works with Dedukti terms, rules, signatures, and parsing entries, enabling concrete use cases such as serializing terms, rewriting products, and integrating structured logical transformations. Key operations include configuring meta-processing with custom rules, encoding terms for safe transformation, and applying reification strategies defined by user-provided modules.",
      "description_length": 570,
      "index": 50,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api.Errors",
      "library": "dedukti.api",
      "description": "Handles error reporting and exception handling with support for colored output. Provides functions to print formatted success or error messages, exit with specific codes, and register custom exception handlers. Works with error codes, location data, and formatted messages, making it suitable for reporting type-checking or runtime errors in a compiler pipeline.",
      "description_length": 362,
      "index": 51,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api.Dep",
      "library": "dedukti.api",
      "description": "Handles dependencies between Dedukti files by computing and managing module and name-level dependencies. It provides operations to compute dependencies for entries, retrieve dependency data, and perform topological sorting and transitive closure on dependencies. This module is used when processing Dedukti modules to ensure correct ordering and resolution of imports and references.",
      "description_length": 383,
      "index": 52,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api.Env",
      "library": "dedukti.api",
      "description": "This module provides operations for managing environments that encapsulate module state, including initializing environments, querying symbol metadata (types, injectivity, decision trees), configuring reduction strategies, and importing modules. It works with environments (`Api.Env.t`), terms (`Kernel.Term.term`), types, and reduction configurations to support tasks like type inference, term reduction, convertibility testing, and rewrite rule management. These capabilities are used in proof assistants or type-checking systems for tasks such as term manipulation, environment debugging, and ensuring correctness during program analysis.",
      "description_length": 641,
      "index": 53,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api",
      "library": "dedukti.api",
      "description": "This module organizes submodules for handling dependencies, environments, errors, file paths, term reification, pretty-printing, and input processing in a Dedukti-based system. It supports operations such as topological sorting of module dependencies, type-checking with configurable environments, structured error reporting, file resolution, term transformations, and batch processing of inputs. Concrete use cases include compiling Dedukti files with correct import ordering, validating cryptographic signatures, and implementing command-line tools with rich formatting and error diagnostics.",
      "description_length": 594,
      "index": 54,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 56,
    "meaningful_modules": 55,
    "filtered_empty_modules": 1,
    "retention_rate": 0.9821428571428571
  },
  "statistics": {
    "max_description_length": 723,
    "min_description_length": 212,
    "avg_description_length": 425.4,
    "embedding_file_size_mb": 0.7975339889526367
  }
}