{
  "package": "dedukti",
  "embedding_model": "Qwen/Qwen3-Embedding-0.6B",
  "embedding_dimension": 1024,
  "total_modules": 67,
  "creation_timestamp": "2025-07-15T23:17:30.175879",
  "modules": [
    {
      "module_path": "Kernel.Typing.S",
      "library": "dedukti.kernel",
      "description": "Implements type inference and checking for terms within a given signature and context. It provides operations to infer types for terms, verify that terms conform to specified types, and validate the typing of rules. These functions operate on terms and rules defined in the `Kernel.Term` and `Kernel.Rule` modules, using a well-formed signature and context to ensure correctness. Useful for implementing type-safe transformations and validations in a core type system.",
      "description_length": 468,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kernel.Basic.NameSet",
      "library": "dedukti.kernel",
      "description": "This module offers operations for constructing, modifying, and analyzing ordered collections of names, including union, intersection, element removal, and cardinality checks, alongside predicates for subset relationships and disjointness. It manipulates abstract sets structured by a comparator function, enabling transformations like mapping, filtering, and folding, while supporting conversions to ordered sequences, lists, and bidirectional iteration. Such functionality suits scenarios requiring ordered data management, such as sorted identifier tracking, set algebra in symbolic computation, or efficient membership testing in structured datasets.",
      "description_length": 653,
      "index": 1,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kernel.Matching.Make",
      "library": "dedukti.kernel",
      "description": "Implements term matching with support for associative-commutative (AC) and higher-order pattern matching. Uses reduction strategies to normalize terms and a convertibility test to determine equivalence during matching. Solves matching problems by converting stack positions to lazy terms using provided functions.",
      "description_length": 313,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kernel.Basic.Debug",
      "library": "dedukti.kernel",
      "description": "This module provides runtime debugging controls through flags that conditionally enable or disable error messages. It works with the `flag` type, which represents individual debug settings that can be toggled. Concrete use cases include selectively printing diagnostic messages to standard error using `debug` or executing debug-only code blocks with `debug_eval`.",
      "description_length": 364,
      "index": 3,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kernel.Reduction.S",
      "library": "dedukti.kernel",
      "description": "Implements term reduction strategies and conversion checking for terms in a given signature. It supports weak head normal form computation, full strong normalization, and configurable reduction steps. Used to verify convertibility of terms, check rule constraints, and generate conversion obligations during term rewriting.",
      "description_length": 323,
      "index": 4,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kernel.Typing.Default",
      "library": "dedukti.kernel",
      "description": "Implements default type inference and checking algorithms for terms in a given signature and context. It provides concrete implementations of `infer`, `check`, and related operations that determine or validate the types of terms, ensuring they conform to the rules defined in the signature. Used to enforce type correctness during term evaluation or transformation, such as verifying function applications or rule instantiations.",
      "description_length": 429,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kernel.Matching.Reducer",
      "library": "dedukti.kernel",
      "description": "Implements term reduction strategies for matching, including normalization and head-normal form computation. Operates on terms and signatures to support matching algorithms by applying rewrite rules and checking convertibility. Used to simplify terms during pattern matching and rule application in term rewriting systems.",
      "description_length": 322,
      "index": 6,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kernel.Matching.Matcher",
      "library": "dedukti.kernel",
      "description": "Implements term matching operations using rule-based pattern solving. Works with lazy terms, pre-matching problems, and signature definitions. Used to resolve matching constraints during term rewriting or proof search by converting position-based stacks into concrete terms.",
      "description_length": 274,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kernel.Basic.LList",
      "library": "dedukti.kernel",
      "description": "This module implements a lightweight linked list structure with operations for construction, transformation, and inspection. It supports constant-time head addition via `cons`, length calculation, mapping with and without indices, and safe element access by index. Use cases include efficient list processing where immutability and structural sharing are beneficial, such as in recursive algorithms or persistent data structures.",
      "description_length": 429,
      "index": 8,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kernel.Typing.Make",
      "library": "dedukti.kernel",
      "description": "This module implements type inference and checking algorithms for terms in a given signature and context. It provides functions to infer a type for a term, verify that a term matches a specified type, and validate typing rules. These operations are used to ensure correctness during term manipulation and rule application in formal systems.",
      "description_length": 340,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kernel.Srcheck.SRChecker",
      "library": "dedukti.kernel",
      "description": "This module manages typing constraints for left-hand sides of rewrite rules, providing operations to create, manipulate, and query constraint sets. It supports constraint checking up to a given depth of term abstractions and optimizes constraints under the assumption of well-typedness. Use cases include verifying convertibility of terms under constraints and extracting substitutions or unsatisfiability witnesses during type checking of rewrite rules.",
      "description_length": 454,
      "index": 10,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kernel.Basic.MidentSet",
      "library": "dedukti.kernel",
      "description": "This module implements ordered, immutable sets of identifiers (`mident`) with efficient membership checks and standard set algebra (union, intersection, difference). It supports ordered traversal (via `min_elt`, `max_elt`, and sorted sequences), transformations (filtering, mapping, partitioning), and conversions to/from lists and sequences. The ordered nature enables use cases like maintaining sorted identifier collections, incremental set construction from sequences, and algorithms requiring monotonic predicate checks or ordered iteration.",
      "description_length": 546,
      "index": 11,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kernel.Basic.IdentSet",
      "library": "dedukti.kernel",
      "description": "This module offers ordered set operations for managing collections of identifiers with efficient membership checks, union/intersection/difference calculations, and ordered traversal. It works with balanced tree-based sets of `mident` elements, supporting transformations to and from sequences, range-base",
      "description_length": 304,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kernel.Exsubst.ExSubst",
      "library": "dedukti.kernel",
      "description": "This module manages extended substitutions for de Bruijn-indexed variables in terms, primarily used during type inference to compute and apply most general unifiers. It supports operations to construct, apply, and manipulate substitutions, including handling variable capture and context shifts. Concrete use cases include inferring type substitutions from constraints on the left-hand side of a rule and applying those substitutions to the right-hand side before typechecking.",
      "description_length": 477,
      "index": 13,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kernel.Reduction.ConvChecker",
      "library": "dedukti.kernel",
      "description": "Implements conversion checking for terms in a given signature, providing precise validation of term equivalence under reduction rules. Works with terms and signatures to verify convertibility, handling constraints from pattern-matching rules by reducing them to term equality checks. Used during rule application to ensure that matched terms satisfy required constraints, enabling correct rewriting in the context of term rewriting systems.",
      "description_length": 440,
      "index": 14,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kernel.Reduction.Default",
      "library": "dedukti.kernel",
      "description": "Implements default reduction strategies and conversion checks for terms in a signature. It supports weak head normal form computation, full strong normalization, and step-wise conversion testing with constraint handling. Useful for evaluating term equivalence and applying reduction rules during type checking or proof processing.",
      "description_length": 330,
      "index": 15,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kernel.Reduction.Make",
      "library": "dedukti.kernel",
      "description": "Implements term reduction strategies and conversion testing for terms in a signature. Provides functions to check convertibility, perform reduction steps, and compute normal forms. Useful for verifying term equivalence and applying rewrite rules under specific constraints.",
      "description_length": 273,
      "index": 16,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kernel.Version",
      "library": "dedukti.kernel",
      "description": "Contains the current version of the Dedukti system as a string. Exposes a single value `version` for runtime access to the version identifier. Useful for logging, debugging, or feature compatibility checks within Dedukti-based tools.",
      "description_length": 233,
      "index": 17,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kernel.Ac",
      "library": "dedukti.kernel",
      "description": "This module provides operations for flattening and unflattening terms under associative-commutative (AC) operators, working with algebraic terms and identifiers paired with algebraic structures. It includes functions to decompose AC terms into lists of subterms and reconstruct terms from such lists, using a specified AC operator. Concrete use cases include normalizing expressions involving AC operations like addition or multiplication, simplifying term manipulation in proof automation or symbolic computation tasks.",
      "description_length": 520,
      "index": 18,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kernel.Basic",
      "library": "dedukti.kernel",
      "description": "This module establishes core abstractions for symbolic identifiers, structured printing, and set operations, forming the basis for compiler-related tasks like name management and syntactic transformation. It provides data types like `ident`, `mident`, and `name` for representing symbolic entities, alongside set structures such as `MidentSet` and `IdentSet` for efficient membership and ordered traversal, with operations including union, intersection, and mapping. The module supports list manipulation, option handling, and customizable printers for tuples and nested data, enabling tasks like parsing, pretty-printing, and debug-controlled execution via runtime flags. Submodules enhance these capabilities with ordered list processing, selective diagnostics, and efficient set algebra, applicable in scenarios ranging from sorted identifier tracking to persistent data manipulation and symbolic computation.",
      "description_length": 912,
      "index": 19,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kernel.Term",
      "library": "dedukti.kernel",
      "description": "This module provides operations for constructing, comparing, and transforming lambda calculus terms with support for de Bruijn indices, alpha equivalence checks, and algebraic annotations. It works with a variant type for terms featuring constructors like kinds, types, constants, and abstractions, alongside contexts modeled as variable-to-term or variable-type mappings. These capabilities are critical in systems requiring precise term manipulation, such as theorem provers, compilers, or interpreters for typed lambda calculi.",
      "description_length": 530,
      "index": 20,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kernel.Matching",
      "library": "dedukti.kernel",
      "description": "This module implements a matching solver for terms, centered around the `solve_miller` function that resolves Miller variable matching problems of the form `X x1 ... xn = t`, with support for higher-order patterns and customizable term representations via the `Make` functor. It integrates term reduction strategies, convertibility checks, and rule-based solving from its submodules to handle normalization, AC-matching, and stack-based term construction during matching. The `miller_var` type represents variables in matching problems, while operations like rewrite rule application and head-normal form computation enable concrete use cases such as theorem proving and logic programming. Examples include solving higher-order unification constraints and simplifying terms in rewriting systems using customizable matching engines.",
      "description_length": 831,
      "index": 21,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kernel.Exsubst",
      "library": "dedukti.kernel",
      "description": "This module handles extended substitutions for de Bruijn-indexed variables in terms, primarily used during type inference to compute and apply most general unifiers. It provides data types for substitutions and contexts, along with operations to construct, apply, and manipulate substitutions while managing variable capture and context shifts. Specific examples include inferring type substitutions from constraints on the left-hand side of a rule and applying those substitutions to the right-hand side before typechecking.",
      "description_length": 525,
      "index": 22,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kernel.Rule",
      "library": "dedukti.kernel",
      "description": "This module supports operations for defining and validating rewrite rules in a lambda calculus extended with patterns, focusing on pattern matching, variable binding, and constraint generation. It works with terms, patterns, and typing contexts to enforce structural properties like arity and linearity, while providing pretty-printing for rule representations and intermediate forms. These capabilities are used to ensure correctness of rule transformations in term rewriting systems or logic programming frameworks.",
      "description_length": 517,
      "index": 23,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kernel.Reduction",
      "library": "dedukti.kernel",
      "description": "This module orchestrates term reduction and conversion testing within a formal logic system, combining core reduction strategies with specialized submodules for conversion checking and normalization. It supports key operations like applying rewrite rules, logging reduction steps, and verifying term convertibility, with configuration options for step limits, reduction targets (e.g., weak head normal form), and reduction strategies (e.g., by-name or by-value). The submodules refine these capabilities by implementing precise conversion validation, constraint handling during rule application, and default strategies for normalization and step-wise testing. Together, they enable concrete use cases such as checking rule constraints, generating conversion obligations, and evaluating term equivalence during type checking or proof processing.",
      "description_length": 844,
      "index": 24,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kernel.Confluence",
      "library": "dedukti.kernel",
      "description": "This module implements a confluence checker for term rewriting systems. It provides operations to add constants, rules, and run confluence checks, raising specific error types when confluence is violated or uncertain. Use it to verify that a set of rewrite rules converges to a common form under different reduction paths.",
      "description_length": 322,
      "index": 25,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kernel.Dtree",
      "library": "dedukti.kernel",
      "description": "This module implements decision trees for efficient pattern matching in term rewriting systems, handling operations like case analysis, variable binding, and constraint checking during matching. It works with algebraic data types representing terms, patterns, and metavariables, along with structured matching problems involving first-order variables, AC symbols, and lambda terms. Concrete use cases include compiling rewrite rules into optimized decision trees for fast matching, managing arity and symbol mismatches during pattern unification, and supporting efficient traversal of term structures in reduction engines.",
      "description_length": 622,
      "index": 26,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kernel.Srcheck",
      "library": "dedukti.kernel",
      "description": "This module configures substitution and reduction steps during type checking and includes a debugging flag for controlling output related to type preservation checks. It provides the `SRChecker` module, which verifies that rewriting rules maintain correct typing through substitution and reduction, ensuring type safety in transformation rules within a compiler or proof assistant. The child module manages typing constraints for left-hand sides of rewrite rules, supporting constraint creation, manipulation, and depth-limited checking, with optimizations assuming well-typedness. Together, they enable precise verification of term convertibility, extraction of substitutions, and detection of unsatisfiable constraints during type checking.",
      "description_length": 742,
      "index": 27,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kernel.Subst",
      "library": "dedukti.kernel",
      "description": "This module implements substitution and index manipulation operations for terms using DeBruijn indices. It provides functions to apply substitutions under lambda abstractions, shift and unshift indices, perform parallel substitution, replace specific variables, and check variable occurrence. These operations are essential for managing bound and free variables during term transformation, such as in lambda calculus evaluation or type checking.",
      "description_length": 445,
      "index": 28,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kernel.Typing",
      "library": "dedukti.kernel",
      "description": "This module provides type checking and inference for a dependently typed language, ensuring term correctness during compilation and enforcing type safety in pattern matching and lambda expressions. It supports operations like type inference, convertibility validation, and context management, with features for handling polymorphism, constraints, and bound variables. Submodules implement concrete algorithms for type inference and checking, providing functions such as `infer` and `check` to validate term types against a signature and context. These are used to verify function applications, rule instantiations, and type-safe transformations in formal systems.",
      "description_length": 663,
      "index": 29,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kernel",
      "library": "dedukti.kernel",
      "description": "This module provides foundational components for building and manipulating formal terms, types, and rewrite systems in a dependently typed setting. Key data types include terms with de Bruijn indices, symbolic identifiers, patterns, and substitutions, with operations for reduction, conversion, type inference, and AC-normalization. It enables concrete tasks such as solving higher-order matching problems, verifying confluence of rewrite rules, normalizing lambda terms, and managing type-safe substitutions during compilation or proof checking. Examples include flattening associative-commutative expressions, validating pattern-based rewrite rules, and inferring type constraints for polymorphic functions.",
      "description_length": 709,
      "index": 30,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api.Processor.MakeSignatureBuilder",
      "library": "dedukti.api",
      "description": "Builds a signature by processing entries in an environment. It accumulates data through the `handle_entry` function and retrieves the final result with `get_data`. This module is used to construct a signature incrementally from parsed entries.",
      "description_length": 243,
      "index": 31,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api.Processor.MakeTypeChecker",
      "library": "dedukti.api",
      "description": "This module processes entries within a given environment, using the associated `E` module to compute and store data. It provides `handle_entry` to process individual entries and `get_data` to retrieve the computed result. Useful for analyzing or validating structured data like configuration files or source code during static analysis.",
      "description_length": 336,
      "index": 32,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Api.Processor.MakeDependencies",
      "library": "dedukti.api",
      "description": "Processes entries within a given environment, computing and returning dependency data. Handles each entry through `handle_entry`, which updates internal state, and retrieves the resulting data via `get_data`. Designed for dependency resolution tasks during processing passes over structured input.",
      "description_length": 297,
      "index": 33,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Api.Meta.MetaConfiguration",
      "library": "dedukti.api",
      "description": "Processes files containing meta rewrite rules by parsing and applying them within a given environment. It operates on environments and entries, extracting and returning partially typed rewrite rules. Used to configure and manipulate rule-based transformations in code processing pipelines.",
      "description_length": 289,
      "index": 34,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api.Meta.PROD",
      "library": "dedukti.api",
      "description": "This module implements a shallow encoding for product types, supporting term and rule transformations. It provides functions to encode and decode terms, along with retrieving declarations and signature information. It is used to manipulate terms and rules in a way that preserves their structure while adapting them to a specific encoding.",
      "description_length": 339,
      "index": 35,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api.Processor.MakeEntryPrinter",
      "library": "dedukti.api",
      "description": "Processes entries by printing them in a structured format. Works with environment and entry data types. Useful for logging or debugging processed entries in their context.",
      "description_length": 171,
      "index": 36,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api.Meta.ENCODING",
      "library": "dedukti.api",
      "description": "This module defines a reified encoding for terms and rules, including functions to encode and decode terms and encode rules. It operates on terms and rules from the `Kernel` module, using a signature and context for type-safe encoding. Concrete use cases include transforming and validating formal logic expressions during compilation or analysis.",
      "description_length": 347,
      "index": 37,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api.Pp.Default",
      "library": "dedukti.api",
      "description": "Implements default pretty-printing strategies for core language constructs using separators and structured formatting. Handles identifiers, terms, patterns, rules, contexts, and configuration values with consistent visual representations. Useful for debugging evaluators, displaying program structures in tooling, or logging reductions and rule applications.",
      "description_length": 358,
      "index": 38,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api.Processor.Interface",
      "library": "dedukti.api",
      "description": "This module defines the interface for processing entries using a parameterized environment, providing operations to handle input streams, process files, and fold over file contents. It works with parsers, hooks for pre- and post-processing actions, and typed processors that transform data. Concrete use cases include parsing and analyzing structured logs, applying transformations to file-based datasets, and aggregating results across multiple files with customizable behavior before and after processing each file.",
      "description_length": 517,
      "index": 39,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Api.Processor.Registration",
      "library": "dedukti.api",
      "description": "This module associates processors with their corresponding modules by registering them with a type equality function. It ensures that each processor is linked to a unique module implementation, using the provided equality check to validate type consistency. Use this when defining and registering custom processors that must conform to specific type requirements.",
      "description_length": 363,
      "index": 40,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api.Pp.Sig",
      "library": "dedukti.api",
      "description": "This module defines the interface for pretty-printing functions, including operations to format and output structured data such as expressions, types, and modules. It works with data types like `Kernel.Basic.mident`, `Parsetree` structures, and other compiler intermediate representations. Concrete use cases include generating human-readable output for debugging, pretty-printing OCaml source code, and formatting error messages.",
      "description_length": 430,
      "index": 41,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api.Processor.S",
      "library": "dedukti.api",
      "description": "This module defines a processor that handles individual entries within a given environment and stores the resulting data. It provides functions to process entries and retrieve the computed data, working with environments and entry structures. Concrete use cases include parsing and analyzing log entries or configuration data incrementally.",
      "description_length": 340,
      "index": 42,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api.Pp.Printer",
      "library": "dedukti.api",
      "description": "This module implements printers for various syntax and semantic structures used in the system, including identifiers, terms, patterns, rules, and contexts. It provides functions to format and output these structures as strings, with support for custom separators and element printers, such as `print_list` for structured collections. These printers are used to display parsed entries, reduction configurations, and error contexts in a human-readable form during debugging, logging, or interactive sessions.",
      "description_length": 506,
      "index": 43,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api.Processor.CustomEnv-HName",
      "library": "dedukti.api",
      "description": "This module provides imperative hash table operations for typed keys (`HName.key`) and generic values, supporting creation, insertion, lookup, bulk modifications from sequences, in-place filtering, and statistics tracking. It operates on `HName.t` hash tables, enabling efficient data manipulation for scenarios like environment-aware symbol resolution, dynamic configuration updates, and runtime statistics aggregation. The ability to transform hash tables using sequences makes it particularly suited for processing workflows requiring batched key-value adjustments or iterative data analysis.",
      "description_length": 595,
      "index": 44,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api.Meta.LF",
      "library": "dedukti.api",
      "description": "This module reifies terms by prefixing them with their constructors, using a specified signature and context for encoding. It provides functions to encode and decode terms and rules, ensuring type safety when enabled. Use cases include preparing terms for serialization or transformation while preserving their structural identity.",
      "description_length": 331,
      "index": 45,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api.Processor.CustomEnv",
      "library": "dedukti.api",
      "description": "This module provides operations for managing module contexts and type-checking environments, including initializing environments from inputs, inspecting symbol properties (e.g., injectivity, static status), and manipulating reduction engines, printers, and rewrite rules. It works with environments (`t`), module identifiers, signatures, terms, and types from the `Kernel` module, supporting tasks like type inference, term reduction, and convertibility testing. Specific use cases include processing entries in dynamic environments, formalizing type systems with safety guarantees, and optimizing reductions through symbol analysis or exporting environments for serialization.",
      "description_length": 677,
      "index": 46,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Api.Env.HName",
      "library": "dedukti.api",
      "description": "This module implements a hash table (`HName.t`) mapping keys of type `Kernel.Basic.name` to arbitrary values, supporting imperative modifications (e.g., adding, replacing, or removing entries) and functional transformations via folding or iteration. It includes operations for batch construction from sequences of key-value pairs, statistical reporting, and converting tables to sequential representations. Typical applications involve managing mutable state with efficient key-based access or processing collections of named values in bulk operations.",
      "description_length": 552,
      "index": 47,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api.Processor.T",
      "library": "dedukti.api",
      "description": "Implements processing logic for parsing and transforming input data from files or direct input sources. It supports sequential processing of entries with optional pre- and post-processing hooks, and accumulates results using a custom folder function. Designed for use with parser modules that conform to the `Api.Processor.S` signature, it enables structured data extraction and aggregation from file-based or in-memory inputs.",
      "description_length": 427,
      "index": 48,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Api.Pp.Make",
      "library": "dedukti.api",
      "description": "This module implements printers for various abstract syntax tree components and contextual data used in formal logic or programming language processing. It provides functions to format identifiers, terms, rules, reduction configurations, and parsing entries, using customizable separators and element printers. Concrete use cases include generating readable representations of typed contexts for debugging, pretty-printing reduction rules for user output, or serializing AST nodes for logging and error reporting.",
      "description_length": 513,
      "index": 49,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api.Meta.APP",
      "library": "dedukti.api",
      "description": "This module implements term and rule encoding/decoding operations for product applications, working with kernel terms, signatures, and rules. It provides functions to encode terms with optional signature and context, decode terms, and encode rules, all respecting a safe flag that enforces type checking. Concrete use cases include preparing terms for serialization, transforming rules under a given signature, and managing application-specific term representations.",
      "description_length": 466,
      "index": 50,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api.Files",
      "library": "dedukti.api",
      "description": "This module manages file paths and module resolution for a compiler or interpreter. It provides functions to locate object files and source files based on module identifiers, handle load paths, and resolve module names to file paths. Concrete use cases include loading compiled modules, finding source files for parsing, and handling module resolution errors during compilation.",
      "description_length": 378,
      "index": 51,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api.Env",
      "library": "dedukti.api",
      "description": "This module manages environments for formal verification workflows, combining metadata storage, symbol tables, and reduction engines with operations for type inference, term reduction, and module imports. It provides a core environment type along with a hash table implementation (`HName.t`) for efficient, mutable storage and functional transformation of named values. Users can perform imperative updates like adding or removing entries, apply bulk operations via folding or sequence conversion, and integrate symbol tables with kernel-level term processing for proof construction and type analysis. Example uses include tracking variable bindings during type-checking and processing named definitions in bulk for program analysis.",
      "description_length": 733,
      "index": 52,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api.Processor",
      "library": "dedukti.api",
      "description": "This module processes Dedukti input streams and files using predefined or custom processors, supporting operations like type checking, signature building, pretty printing, dependency computation, and top-level evaluation. It works with data types such as `input`, `Env.t`, `Entry.entry`, and `processor_error`, enabling tasks like applying a type checker to a file, computing dependencies of an input stream, or defining a custom processor that accumulates results from entries. Submodules handle signature construction, dependency tracking, data analysis, and pretty printing, while others support environment management, typed processing, and imperative hash table operations for efficient data manipulation. Specific use cases include parsing and analyzing structured logs, validating configuration files, incrementally building signatures, and aggregating results across multiple files with custom pre- and post-processing logic.",
      "description_length": 933,
      "index": 53,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api.Pp",
      "library": "dedukti.api",
      "description": "This module provides pretty-printing functionality for terms, rules, and related structures, with configurable output options like debug formatting and module name inclusion. It supports customizable printing through functors and includes submodules that implement default strategies, formatting interfaces, and printers for syntax and AST components. Users can print structured data such as expressions, contexts, and configurations, using utilities like `print_list` with custom separators. Examples include displaying reduction steps, logging rule applications, and generating readable output for debugging or user-facing tools.",
      "description_length": 631,
      "index": 54,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Api.Meta",
      "library": "dedukti.api",
      "description": "This module orchestrates meta-level term rewriting in Dedukti by combining configuration, rule application, and term encoding strategies. It exposes core operations for defining and executing rewrite rules, interacting with environments, and transforming terms through various encodings. Data types include Dedukti terms, rewrite rules, environments, and signatures, manipulated via functions for normalization, encoding, decoding, and reification. Submodules handle rule parsing from files, shallow and reified product encodings, constructor-prefixing, and application-specific transformations, enabling tasks like rule-based compilation, term serialization, and type-safe logic validation.",
      "description_length": 691,
      "index": 55,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api.Dep",
      "library": "dedukti.api",
      "description": "Handles dependencies between Dedukti files by computing and managing module and name-level dependencies. It provides operations to compute dependencies for entries, retrieve dependency data, and perform topological sorting and transitive closure on dependency graphs. Works with Dedukti modules, names, and entries to support tasks like dependency resolution and file loading order determination.",
      "description_length": 396,
      "index": 56,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api.Errors",
      "library": "dedukti.api",
      "description": "Handles error reporting and exception management with formatted output. Defines error codes, messages, and handlers for converting exceptions into structured error data. Used to print colored success or error messages, handle system errors, and register custom exception handlers that include location and term information.",
      "description_length": 323,
      "index": 57,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api",
      "library": "dedukti.api",
      "description": "This module coordinates compiler and formal verification workflows by integrating file resolution, environment management, term processing, and error handling. It supports key data types like environments (`Env.t`), Dedukti terms, entries, and dependencies, enabling operations such as module resolution, type inference, term rewriting, and dependency tracking. Users can load and process files with custom pipelines, execute rewrite rules, analyze dependencies, and report structured errors with contextual information. Example tasks include type-checking a Dedukti file, normalizing terms under custom encodings, and building dependency-ordered compilation sequences.",
      "description_length": 669,
      "index": 58,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Parsers.Tokens",
      "library": "dedukti.parsers",
      "description": "This module defines a rich set of lexical tokens used in parsing a domain-specific language, including keywords, identifiers, operators, and punctuation, each annotated with location or string data. It supports precise token representation for parsing logic, handling constructs like definitions, assertions, type annotations, and module references. Concrete use cases include lexing input files into structured tokens for subsequent syntax analysis and error reporting based on token locations.",
      "description_length": 495,
      "index": 59,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Parsers.Lexer",
      "library": "dedukti.parsers",
      "description": "This module implements a lexer for parsing source code, converting input streams into structured tokens. It processes `lexbuf` inputs to identify and return specific token types, handling identifiers, strings, and comments with associated location tracking. Functions like `token` and `comment` parse input, while `fail` and `prerr_loc` manage error reporting with precise source locations.",
      "description_length": 390,
      "index": 60,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Parsers.Menhir_parser",
      "library": "dedukti.parsers",
      "description": "Parses a single line of input into an abstract syntax tree using a Menhir-generated parser. It operates on lexing buffers and token streams, producing structured entries for further processing. This module is used to parse individual lines of a formal language into semantic units for evaluation or compilation.",
      "description_length": 311,
      "index": 61,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Parsers.Preterm",
      "library": "dedukti.parsers",
      "description": "This module represents unscoped terms and patterns during parsing, using algebraic data types like `preterm`, `prepattern`, and `prule` to capture syntactic constructs such as applications, lambdas, and pattern matching rules. It includes pretty-printing functions for these structures and utilities like `clean_pre_pattern` to manipulate patterns. Concrete use cases include building and transforming abstract syntax trees before scope resolution and handling pattern-based function definitions.",
      "description_length": 496,
      "index": 62,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Parsers.Parser",
      "library": "dedukti.parsers",
      "description": "This module provides functions to create and manage input sources for parsing, supporting operations like reading entries from files, standard input, or strings. It handles data types such as `input` for source abstraction and `stream` for sequential parsing, along with utilities to retrieve metadata, close resources, and parse content either lazily or fully into a list. Concrete use cases include parsing command-line input interactively, processing configuration files, and transforming structured text into entry objects for further processing.",
      "description_length": 550,
      "index": 63,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Parsers.Entry",
      "library": "dedukti.parsers",
      "description": "This module defines data structures and operations for parsing and handling various kinds of entries in a formal system, such as declarations, definitions, reduction rules, evaluation commands, and tests. It works with terms, locations, identifiers, and configuration settings, supporting concrete tasks like type checking, term conversion, and rule application. Use cases include processing input files, executing interactive commands, and managing symbol definitions and evaluations.",
      "description_length": 485,
      "index": 64,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Parsers.Scoping",
      "library": "dedukti.parsers",
      "description": "This module handles the scoping of terms and rules within a given context, translating preterms into fully typed terms and partially typed rules. It operates on module identifiers, typed contexts, preterms, and prules, resolving references and ensuring correct binding. It is used during the parsing phase to transform unscoped syntactic constructs into well-scoped, typed representations for further processing.",
      "description_length": 412,
      "index": 65,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Parsers",
      "library": "dedukti.parsers",
      "description": "This module processes source code through lexing, parsing, and scoping stages to produce structured representations of a formal language. It defines tokens, lexing functions, and parsers that transform input into abstract syntax trees, while supporting error reporting with location tracking. Key data types include tokens, preterms, entries, and scoped terms, with operations for lexing, parsing, pretty-printing, and scope resolution. Examples include converting a string into a typed term, parsing a file into a list of entries, or transforming a line of input into an executable command.",
      "description_length": 591,
      "index": 66,
      "embedding_norm": 0.9999999403953552
    }
  ],
  "filtering": {
    "total_modules_in_package": 68,
    "meaningful_modules": 67,
    "filtered_empty_modules": 1,
    "retention_rate": 0.9852941176470589
  },
  "statistics": {
    "max_description_length": 933,
    "min_description_length": 171,
    "avg_description_length": 473.65671641791045,
    "embedding_file_size_mb": 0.24377727508544922
  }
}