{
  "package": "dedukti",
  "embedding_model": "BAAI/bge-base-en-v1.5",
  "embedding_dimension": 1024,
  "total_modules": 62,
  "creation_timestamp": "2025-06-18T16:45:27.077286",
  "modules": [
    {
      "module_path": "Api.Processor.MakeSignatureBuilder.HName",
      "description": "The module offers operations for inserting, removing, and querying key-value pairs in a hash table, along with iteration and transformation capabilities. It works with a key type of `Kernel.Basic.name` and generic value type `'a`, enabling dynamic mapping management. Specific use cases include building or updating in-place key-value stores from sequences, such as populating configuration data or processing structured datasets.",
      "description_length": 430,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api.Processor.MakeEntryPrinter.HName",
      "description": "This module offers operations for manipulating associative data structures, including hash table management (insertion, deletion, lookup) and sequence-based key-value store creation/modification. It works with hash tables parameterized by type `'a` and named key-value sequences using a `key` type derived from `Kernel.Basic.name`. Use cases include dynamic data indexing and configuration management, where efficient lookups and updates are critical.",
      "description_length": 451,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api.Processor.MakeTypeChecker.HName",
      "description": "This module offers operations for manipulating hash tables and key-value mappings, including insertion, deletion, lookup, and sequence-based updates. It works with generic hash table structures and a specialized key-value map where keys are of type `Kernel.Basic.name` and values are polymorphic. Use cases include dynamic data management, such as maintaining symbol tables or configuration settings that require efficient key-based access and in-place modifications.",
      "description_length": 467,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api.Processor.MakeDependencies.HName",
      "description": "This module offers hash table operations for inserting, deleting, and querying key-value pairs, along with sequence-based manipulation of a named-value store where keys are `Kernel.Basic.name` and values are generic. It supports in-place updates via functions like `replace_seq` and construction from sequences using `of_seq`, making it suitable for managing symbolic configurations or dynamic data mappings. The design emphasizes efficient traversal and transformation of structured data through iterative and functional patterns.",
      "description_length": 531,
      "index": 3,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Api.Env.HName",
      "description": "This module offers hash table operations for inserting, deleting, and querying key-value pairs, along with sequence-based transformations and statistical analysis. It works with key-value mappings where keys are of type `Kernel.Basic.name` and values are generic (`'a`), supporting in-place updates via sequences. Use cases include dynamic data management, such as symbol tables or configuration systems, where efficient key-based access and batch modifications are required.",
      "description_length": 475,
      "index": 4,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Api.Meta.PROD",
      "description": "Provides functions to encode and decode terms and rules using a shallow product encoding, with optional type checking. Operates on terms, rules, and signatures from the Kernel module. Used to transform terms and rules during preprocessing, ensuring compatibility with type-checked encodings.",
      "description_length": 291,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api.Meta.LF",
      "description": "Encodes and decodes terms and rules by prefixing them with constructor information, using a typed context and signature for type safety. Operates on terms and rules from the Kernel module, ensuring consistency during transformation. Used to serialize and deserialize logical expressions with explicit constructor tagging.",
      "description_length": 321,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api.Meta.APP",
      "description": "Provides functions to encode and decode terms and rules using a typed context and signature, with optional type checking. Operates on kernel terms, rules, and entries defined in the basic module. Used to transform and validate data structures during encoding processes.",
      "description_length": 269,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api.Meta.MetaConfiguration",
      "description": "Processes entries from rewrite-rule files, applying them to an environment and accumulating partially typed rules. Operates on environment contexts and lists of partially typed rules. Used to build a rule set for subsequent processing stages.",
      "description_length": 242,
      "index": 8,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Api.Pp.Make",
      "description": "Provides functions to retrieve and manipulate module identifiers and their associated names. Operates on kernel module structures and basic identifier types. Used to dynamically access module names during code generation and output formatting.",
      "description_length": 243,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api.Pp.Default",
      "description": "Prints various core language constructs including lists, identifiers, terms, rules, and contexts using specified formatting functions. Operates on types like `Kernel.Basic.printer`, `Kernel.Term.term`, `Kernel.Rule.rule`, and `Parsers.Entry.entry`. Used to generate human-readable representations of abstract syntax trees and inference contexts during debugging or output generation.",
      "description_length": 383,
      "index": 10,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Api.Processor.Registration",
      "description": "Registers a processor with an equality check and a module implementing a specific interface, ensuring type consistency during registration. Works with type-level equality constraints and modules conforming to a defined signature. Used to dynamically bind processors to type-safe implementations in a validation system.",
      "description_length": 318,
      "index": 11,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api.Processor.T",
      "description": "Processes input data using a specified processor, executing pre- and post-processing hooks. Operates on file lists and input streams, returning aggregated results. Applies a folding function across files to accumulate a final value.",
      "description_length": 232,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api.Processor.MakeTypeChecker",
      "description": "Manages dynamic data structures with efficient key-based access, supporting insertion, deletion, and lookup operations on hash tables and specialized maps. Key types include `Kernel.Basic.name`, with values that can be of any type, enabling flexible data handling. It facilitates tasks like maintaining symbol tables or configuration settings during type checking. Operations allow for in-place modifications and sequence-based updates to ensure consistency in dynamic environments.",
      "description_length": 482,
      "index": 13,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api.Processor.MakeSignatureBuilder",
      "description": "manages dynamic key-value mappings using `Kernel.Basic.name` as keys and arbitrary values, supporting insertion, deletion, querying, and transformation. It enables efficient data manipulation through hash table operations, allowing for in-place updates and structured data processing. Examples include constructing configuration tables from input streams or maintaining runtime state during term evaluation. The module provides a flexible interface for managing associative data within a typechecked environment.",
      "description_length": 512,
      "index": 14,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api.Processor.MakeEntryPrinter",
      "description": "manages associative data structures with hash tables and key-value sequences, enabling efficient data manipulation and retrieval. It supports operations like insertion, deletion, and lookup on hash tables of type `'a` and sequences keyed by `key` derived from `Kernel.Basic.name`. Users can build dynamic indexes or manage configurations with fast access and modification. For example, it allows adding a new term to a hash table or updating a sequence entry based on a named key.",
      "description_length": 480,
      "index": 15,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api.Processor.MakeDependencies",
      "description": "manages symbolic configurations and dynamic data mappings through hash tables and sequence-based stores, with keys of type `Kernel.Basic.name` and values of arbitrary type. It enables efficient insertion, deletion, querying, and in-place modification of data, as well as construction from sequences. Operations like `replace_seq` allow updating named-value pairs directly, while `of_seq` builds stores from iterable sources. This supports tasks such as maintaining context-sensitive environments or transforming structured data during typechecking and reduction.",
      "description_length": 562,
      "index": 16,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api.Processor.HName",
      "description": "This module offers operations for managing hash tables with key-value pairs, including insertion, deletion, lookup, and iteration, alongside sequence-based construction and modification. It works with a key-value mapping structure where keys are of type `Kernel.Basic.name` and values are polymorphic (`'a`), enabling efficient updates via sequences. Specific use cases include building mappings from sequential data and dynamically replacing entries while preserving existing associations.",
      "description_length": 490,
      "index": 17,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kernel.Exsubst.ExSubst",
      "description": "Provides functions to manage substitutions for variables in terms, including adding mappings, applying substitutions under lambda abstractions, and modifying substitutions to be idempotent. Operates on terms and integer variable indices, with specialized application functions for different contexts. Used to infer and apply type substitutions during rule processing in type inference systems.",
      "description_length": 393,
      "index": 18,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kernel.Matching.Make",
      "description": "Processes term normalization and conversion using a given signature. Operates on terms and signatures, applying strategies to reduce terms to their normal forms. Validates term convertibility and enforces constraints during rule application.",
      "description_length": 241,
      "index": 19,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kernel.Srcheck.SRChecker",
      "description": "Checks for term convertibility and constraint satisfaction, performs reduction steps, and computes normal forms. Operates on terms, signatures, and reduction configurations. Used to verify term equivalence in type theories and ensure rule constraints are met during term rewriting.",
      "description_length": 281,
      "index": 20,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kernel.Basic.MidentSet",
      "description": "The module provides set operations such as union, intersection, and difference, along with traversal, transformation, and predicate-based querying, working with ordered collections of elements like identifiers (`mident`). It supports building and modifying sets from sequences, iterating in reverse, and performing logical checks like disjointness, making it suitable for managing structured data or symbolic computations. Operations emphasize efficient manipulation of ordered structures, enabling tasks like filtering, partitioning, and cardinality analysis.",
      "description_length": 560,
      "index": 21,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kernel.Basic.IdentSet",
      "description": "This module provides standard set operations such as adding, removing, and combining elements, along with querying and transforming sets using predicates, mapping, and filtering. It works with ordered sets of a generic type `elt` and specialized `mident` elements, supporting sequence-based construction and iteration. Use cases include managing ordered collections, symbolic processing, and efficient data transformations where maintaining element order or converting between sets and lists is required.",
      "description_length": 504,
      "index": 22,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kernel.Basic.NameSet",
      "description": "This module offers set operations such as union, intersection, and difference, along with queries for cardinality, min, max, and membership, operating on ordered collections of elements. It supports traversal, transformation, and predicate-based filtering of elements, enabling tasks like ordered iteration, reverse traversal, and sequence-based set construction. Specific use cases include managing name-based data structures with ordered insertion and efficient set-theoretic manipulations.",
      "description_length": 492,
      "index": 23,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kernel.Basic.LList",
      "description": "Creates and manipulates linked lists with operations like adding elements, checking length, and converting to and from lists. Works with the `'a t` type, representing a custom linked list structure. Supports transforming elements with mappings and accessing specific indices directly.",
      "description_length": 284,
      "index": 24,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kernel.Basic.Debug",
      "description": "Provides functions to manage and control debug output through flags, including creating flags with messages, enabling/disabling them, and conditionally executing code or printing messages. Works with a `flag` type that tracks activation state and associated error messages. Used to selectively display warnings, notices, or evaluate code blocks during debugging sessions.",
      "description_length": 371,
      "index": 25,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kernel.Reduction.Make",
      "description": "Handles term convertibility checks and constraint validation within a signature. Operates on terms, rules, and convertibility tests to determine equality under substitution. Used to verify term equivalence during type checking and rule application.",
      "description_length": 248,
      "index": 26,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kernel.Reduction.Default",
      "description": "Provides functions to check term convertibility, enforce constraints, generate reduction steps, and compute normal forms. Operates on terms, signatures, and reduction configurations. Used to verify term equivalence, validate rule constraints, and simplify terms under specific reduction strategies.",
      "description_length": 298,
      "index": 27,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kernel.Typing.Make",
      "description": "Checks for term convertibility and constraint satisfaction, performs reduction steps, and computes normal forms. Operates on terms, signatures, and reduction configurations. Used to verify term equivalence, validate rule constraints, and simplify terms to their normal forms during formal verification processes.",
      "description_length": 312,
      "index": 28,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kernel.Typing.Default",
      "description": "Provides type inference and checking for terms and rules using a signature and context. Operates on terms, types, and rules with specific checks for well-formedness and type consistency. Used to validate logical rules and derive types in a formal system.",
      "description_length": 254,
      "index": 29,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api.Dep",
      "description": "Handles dependency tracking between Dedukti modules by computing and managing module and constant dependencies. Operates on module identifiers, file paths, and data structures storing dependency relationships. Computes transitive closures, performs topological sorting of files, and retrieves computed data for specific module names.",
      "description_length": 333,
      "index": 30,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api.Env",
      "description": "provides a hash table interface for managing key-value pairs with efficient lookups, insertions, and deletions, using `Kernel.Basic.name` as keys and generic values. It supports sequence-based operations for bulk updates and statistical computations, enabling dynamic data handling in contexts like symbol tables or configuration management. Operations include inserting, removing, and querying entries, as well as transforming data through sequences. Examples include maintaining a runtime environment for term substitutions or tracking variable bindings during type checking.",
      "description_length": 577,
      "index": 31,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Api.Errors",
      "description": "Provides functions to print success and failure messages, handle system errors, and manage exception-based error reporting. Works with error codes, location data, and custom error messages. Used to output structured error information with context, including module names and file locations, and to terminate execution with specific exit codes.",
      "description_length": 343,
      "index": 32,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api.Files",
      "description": "Provides functions to manage and query a load path, retrieve object file paths based on module identifiers, and locate `.dk` files within specified directories. Operates on strings, module identifiers, and lists of paths. Used to resolve module file locations during compilation and to handle module-specific file searches.",
      "description_length": 323,
      "index": 33,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api.Meta",
      "description": "Provides functions to encode and decode terms and rules based on a signature, with optional type checking. Operates on kernel terms, rules, and entries, using a module identifier and a safety flag. Used to transform terms and rules during serialization or deserialization processes.",
      "description_length": 282,
      "index": 34,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api.Pp",
      "description": "Prints various language-specific data structures including lists, identifiers, terms, rules, and contexts with customizable separators. Operates on types like `Kernel.Basic.ident`, `Kernel.Term.term`, `Kernel.Rule.rule`, and `Kernel.Signature.staticity`. Used to generate human-readable representations for debugging and logging in a formal verification system.",
      "description_length": 361,
      "index": 35,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api.Processor",
      "description": "Handles processing of entry data within a given environment, updating internal state based on input. Works with environment records and a custom data type representing processed results. Used to aggregate and transform input entries into structured output for further analysis.",
      "description_length": 277,
      "index": 36,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Parsers.Entry",
      "description": "Provides functions to convert between terms, check typability, declare symbols, define opaque or asserted entries, and manage reduction rules. Works with loc, printer, and custom types like is_opaque, is_assertion, and test. Handles evaluation, testing, type inference, and printing of entries with specific flags and commands.",
      "description_length": 327,
      "index": 37,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Parsers.Lexer",
      "description": "Provides functions to extract and report lexical positions, handle token recognition, and process identifiers, strings, and comments from input. Operates on Lexing.lexbuf, Buffer.t, and custom location types. Used to parse and annotate source code elements during lexical analysis.",
      "description_length": 281,
      "index": 38,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Parsers.Menhir_parser",
      "description": "Parses input using a given lexer to generate a structured representation of a program, incorporating line numbers and module identifiers. Operates on lexing buffers and token streams derived from the Tokens module. Used to process source code entries and produce abstract syntax trees for further analysis.",
      "description_length": 306,
      "index": 39,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Parsers.Parser",
      "description": "Provides functions to create and manage input sources from files, standard input, and strings, and to parse these into a stream of entries. Works with custom types `input` and `stream`, enabling processing of structured data. Used to read and process entries from a file or user input, applying actions or collecting results as a list.",
      "description_length": 335,
      "index": 40,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Parsers.Preterm",
      "description": "Handles printing and manipulation of unscoped logical terms and patterns, including pretty-printing functions for preterms, prepatterns, and declarations. Operates on structured data like preterms, prepatterns, and context lists containing unscoped declarations. Used to format and clean patterns prior to scoping in formal logic systems.",
      "description_length": 338,
      "index": 41,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Parsers.Scoping",
      "description": "Handles the transformation of preterms and prules into fully scoped terms and rules, using a given identifier and context. Operates on types such as `Kernel.Term.typed_context`, `Preterm.preterm`, and `Preterm.prule`. Used to resolve variable references and ensure correct binding in logical expressions.",
      "description_length": 304,
      "index": 42,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Parsers.Tokens",
      "description": "Provides functions to parse, compare, and transform tokens, including checking for keyword status and extracting associated values. Works with a discriminated union type representing lexical elements such as identifiers, operators, and literals. Used to process input streams during compiler front-end stages, enabling accurate syntax analysis.",
      "description_length": 344,
      "index": 43,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kernel.Ac",
      "description": "Provides operations for manipulating associative and commutative (AC) terms, including checking identity equality between AC identifiers, pretty-printing identifiers, and flattening or unflattening terms based on a specified AC operator. Works with ac_ident, which consists of a name and an algebraic structure, and Term.term for representing logical expressions. Used to transform terms into canonical forms for equivalence checking, such as decomposing a term into a list of subterms or reconstructing a term from a list of flattened components.",
      "description_length": 547,
      "index": 44,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kernel.Basic",
      "description": "Combines set operations like union, intersection, and difference with ordered traversal, transformation, and predicate-based queries, working with `mident` and generic `elt` types. Supports linked list manipulation through `t` type operations, including element access, mapping, and conversion to standard lists. Includes debug flag management for conditional execution and message output. Enables structured data handling, symbolic computation, and controlled debugging workflows.",
      "description_length": 481,
      "index": 45,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kernel.Confluence",
      "description": "Checks for confluence in a set of rewrite rules by analyzing critical pairs and ensuring no conflicting reductions. It works with rule information, constants, and debug flags to validate term rewriting systems. Used to verify consistency in algebraic specifications during formal verification processes.",
      "description_length": 303,
      "index": 46,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kernel.Dtree",
      "description": "The module provides operations for constructing and navigating decision trees tailored to term matching, including AC-symbol handling, depth-sensitive constraints, and case-based branching. It works with structures like variable indices, AC symbols, matching problems, and term positions, enabling precise manipulation of rewrite rules and symbolic term analysis. Key use cases involve equational problem solving, pattern matching with nested abstractions, and efficient traversal of structured term representations.",
      "description_length": 516,
      "index": 47,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kernel.Exsubst",
      "description": "Manages variable substitutions in terms, supporting addition of mappings, application under lambda abstractions, and idempotent modification. Operates on terms and integer variable indices, with context-specific application functions. Enables precise control over substitution scope and behavior during type inference. For example, it can replace variables in a term while preserving binding structure or ensure substitutions do not alter already substituted variables.",
      "description_length": 469,
      "index": 48,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kernel.Matching",
      "description": "Processes term normalization and conversion checks using a given signature. Operates on terms and signatures to compute simplified normal forms and determine convertibility. Validates term equivalence under constraints and rules in logical or symbolic computation contexts.",
      "description_length": 273,
      "index": 49,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kernel.Reduction",
      "description": "Provides functions to check convertibility between terms, validate constraints, generate conversion obligations, reduce terms, and compute weak and strong normal forms. Operates on terms, signatures, and rules, with specific handling of Pi, Lam, App, and constant structures. Used to verify term equivalence, enforce rule constraints, and simplify terms according to reduction strategies.",
      "description_length": 388,
      "index": 50,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kernel.Rule",
      "description": "The module provides functions for processing rewrite rules, handling terms, arities, and metadata through operations like validation, conversion between representations, and property checks (e.g., arity, linearity). It works with structured rule definitions, enabling tasks such as type constraint enforcement and error detection during rule manipulation. Specific use cases include ensuring context correctness in rule transformations and inspecting metadata for debugging or optimization.",
      "description_length": 490,
      "index": 51,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kernel.Signature",
      "description": "The module provides operations to manipulate global environments for modules, including creating, querying, and modifying signatures with a focus on symbol declarations, type checking, and rule management. It works with signature type `t`, module identifiers, names, locations, terms, and `Basic.mident`/`Basic.ident` to enable symbolic data traversal and environment transformations. Specific use cases include analyzing symbol properties, enforcing type constraints, and managing module imports/exports during compilation.",
      "description_length": 524,
      "index": 52,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kernel.Srcheck",
      "description": "performs term conversion checks, constraint validation, and reduction operations, supporting normal form computation. It handles terms, signatures, and reduction settings, enabling verification of equivalence and rule compliance. Users can evaluate term transformations and ensure logical consistency in rewriting systems. Examples include checking if two terms are convertible under a given signature or reducing a term to its normal form.",
      "description_length": 440,
      "index": 53,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kernel.Subst",
      "description": "Applies substitutions to terms using DeBruijn indices, adjusting for local bindings and shifting indices during substitution. Operates on terms with embedded DeBruijn indices and substitution mappings that track variable locations. Replaces specific free variables in a term while managing index shifts to avoid conflicts.",
      "description_length": 322,
      "index": 54,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kernel.Term",
      "description": "The module offers functions for constructing, inspecting, and transforming lambda terms, including creating abstractions, applications, and managing variable bindings, alongside operations for context-aware renaming and subterm extraction. It works with term structures, positions, contexts, and typed environments to support tasks like term comparison, pretty-printing, and semantic analysis. Use cases include formal verification, type-checking, and manipulation of lambda calculus expressions in compiler or theorem-proving settings.",
      "description_length": 536,
      "index": 55,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kernel.Typing",
      "description": "Provides type inference and checking for terms and rules using a signature and context. Operates on terms, typed contexts, and rules with associated substitutions. Used to validate term types in isolation or within a context, and to ensure rules are correctly typed.",
      "description_length": 266,
      "index": 56,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kernel.Version",
      "description": "Returns the current version of Dedukti as a string. Works with the version string generated during build. Used to display or log the exact version of the running Dedukti instance.",
      "description_length": 179,
      "index": 57,
      "embedding_norm": 1.0
    },
    {
      "module_path": "dedukti",
      "description": "Provides functions for parsing and manipulating lambda expressions, along with tools for type checking and normalization. Works with abstract syntax trees and term representations in a pure lambda calculus format. Used to integrate custom proof rules into Dedukti's verification process.",
      "description_length": 287,
      "index": 58,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api",
      "description": "manages module dependencies, error reporting, and data manipulation through specialized interfaces, enabling efficient module resolution, term serialization, and structured output generation. It includes a hash table for dynamic key-value management, a dependency tracker for topological sorting, and utilities for error handling and file path resolution. Operations include inserting and querying entries, computing transitive dependencies, and printing debuggable representations of formal structures. Examples include tracking variable bindings during type checking, resolving module files during compilation, and generating human-readable term outputs for verification tasks.",
      "description_length": 679,
      "index": 59,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Parsers",
      "description": "manages the full lifecycle of parsing and processing logical expressions, from lexical analysis to abstract syntax tree generation and term scoping. it handles location tracking, token recognition, term conversion, type checking, and pretty-printing, using types like loc, preterm, prule, and context lists. it enables tasks such as parsing source code with line numbers, resolving variable bindings, and generating scoped logical terms. examples include extracting lexical positions, transforming unscoped patterns, and generating structured program representations.",
      "description_length": 567,
      "index": 60,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kernel",
      "description": "Manages term manipulation, rewriting, and type checking through a suite of interrelated operations. It handles AC term normalization, set-like structures, confluence checks, decision trees, substitutions, normalization, convertibility, rule processing, environments, and lambda calculus constructs, using types like ac_ident, mident, term, and signature. It enables tasks such as verifying term equivalence, applying substitutions while preserving binding structure, checking confluence in rewrite systems, and constructing decision trees for term matching. Examples include reducing terms to normal forms, validating rule consistency, and managing variable substitutions in lambda expressions.",
      "description_length": 694,
      "index": 61,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 62,
    "meaningful_modules": 62,
    "filtered_empty_modules": 0,
    "retention_rate": 1.0
  },
  "statistics": {
    "max_description_length": 694,
    "min_description_length": 179,
    "avg_description_length": 388.85483870967744,
    "embedding_file_size_mb": 0.2257251739501953
  }
}