{
  "package": "guile",
  "embedding_model": "Qwen/Qwen3-Embedding-8B",
  "embedding_dimension": 4096,
  "total_modules": 16,
  "creation_timestamp": "2025-08-14T23:25:10.203790",
  "modules": [
    {
      "module_path": "Guile.Number.Float",
      "library": "guile.guile",
      "description": "This module handles numeric operations specific to floating-point and rational numbers in the Guile runtime. It provides predicates to test number classifications, functions to extract components of rational values, and conversions between Guile and OCaml float representations. Use cases include numeric validation, rational decomposition, and handling special floating-point values like infinity and NaN.",
      "description_length": 406,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Guile.Number.Complex",
      "library": "guile.guile",
      "description": "This module provides two functions for testing whether a value is a complex number. It operates on the `Guile.scm` type, which represents Scheme values. The `complex_p` function returns a Scheme boolean indicating if the input is a complex number, while `is_complex` returns a native OCaml boolean. These functions are useful in contexts where type checking of numerical values is required, such as in numerical computations or when validating input in Scheme extensions.",
      "description_length": 471,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Guile.Pair",
      "library": "guile.guile",
      "description": "This module implements standard Scheme pair operations for constructing and manipulating cons cells. It provides functions like `cons`, `car`, `cdr`, and derived accessors such as `cadr` and `cdar`, along with in-place mutation via `set_car` and `set_cdr`. These operations work directly on the `Guile.scm` type, enabling list construction, traversal, and modification typical in Scheme interoperability and AST manipulation.",
      "description_length": 425,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Guile.Functions",
      "library": "guile.guile",
      "description": "This module directly maps OCaml functions of arity 1 to 10 into a Guile Scheme environment, allowing them to be called from Scheme code. It operates on `Guile.scm` values, which represent Scheme objects, and supports optional parameters for optimization and argument handling. Concrete use cases include embedding domain-specific logic written in OCaml into a Scheme interpreter or extending a Scheme-based application with typed, compiled OCaml functionality.",
      "description_length": 460,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Guile.Sexp",
      "library": "guile.guile",
      "description": "Converts s-expressions between OCaml and Guile Scheme representations. Works with `Sexplib.Sexp.t` and `Guile.scm` types. Enables direct interoperability between OCaml code using sexps and Guile-based Scheme code.",
      "description_length": 213,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Guile.Module",
      "library": "guile.guile",
      "description": "This module provides operations for managing Scheme modules, including resolving, defining, and using modules, as well as defining and exporting variables within them. It works with module names as strings and Scheme values (`Guile.scm`), supporting dynamic module loading and scoped execution. Concrete use cases include dynamically loading libraries, setting up module interfaces, and manipulating module bindings at runtime.",
      "description_length": 427,
      "index": 5,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Guile.String",
      "library": "guile.guile",
      "description": "This module provides functions to validate, construct, and manipulate Guile strings, including checking if a value is a string or empty, converting between OCaml and Guile string representations, and retrieving string lengths. It works directly with Guile's `scm` type for string values and OCaml's `string` and `char list` types. Concrete use cases include encoding OCaml strings for Guile API calls, validating input in Guile extensions, and extracting string data from Guile values in embedded scripting scenarios.",
      "description_length": 517,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Guile.Char",
      "library": "guile.guile",
      "description": "This module provides direct predicates for character classification and conversion between OCaml and Guile char representations. It operates on `Guile.scm` values and `char` types, offering checks for character properties like alphabetic, numeric, whitespace, and case status. Use cases include validating character input in Guile extensions, filtering characters in string processing, and bridging OCaml and Guile code for character handling.",
      "description_length": 443,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Guile.Bool",
      "library": "guile.guile",
      "description": "This module provides direct manipulation of boolean values between OCaml and Guile representations. It includes conversion functions between OCaml's `bool` and Guile's `scm` boolean values, checks whether a value is a boolean, and performs logical negation. Use cases include integrating OCaml logic with Guile-based scripting where boolean state needs to be consistently interpreted across both systems.",
      "description_length": 404,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Guile.Error",
      "library": "guile.guile",
      "description": "This module provides functions for throwing and catching Scheme errors within OCaml code. It works with Scheme values (`Guile.scm`) and strings, allowing errors to be tagged and associated with function names. Use it to signal exceptional conditions in Scheme from OCaml or to handle Scheme errors programmatically during execution.",
      "description_length": 332,
      "index": 9,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Guile.Symbol",
      "library": "guile.guile",
      "description": "This module provides operations for creating, converting, and checking symbols in Guile. It supports converting strings to symbols and vice versa, generating fresh symbols, and checking whether a value is a symbol. Concrete use cases include symbol manipulation when interfacing with Guile's runtime, such as creating unique identifiers or converting OCaml strings for use in Scheme expressions.",
      "description_length": 395,
      "index": 10,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Guile.List",
      "library": "guile.guile",
      "description": "This module provides functions to convert between OCaml and Guile list representations and check if a Guile list is empty. It operates on Guile's `scm` type and OCaml lists of arbitrary element types. Use cases include extracting OCaml lists from Guile input and constructing Guile lists from OCaml data for interoperability.",
      "description_length": 325,
      "index": 11,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Guile.Number",
      "library": "guile.guile",
      "description": "This module provides type-checking predicates and bidirectional conversion functions between Guile's numeric representations and OCaml's primitive types (e.g., int, long, char, and their variants). It operates on Guile's `scm` values, supporting operations like exactness checks, numeric classification, and conversions for integers, floating-point, and complex numbers. Use cases include numerical interoperability in mixed-language systems, such as validating Guile input values before OCaml computation or marshaling results back to Guile's runtime.",
      "description_length": 552,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Guile",
      "library": "guile.guile",
      "description": "This module facilitates Scheme-OCaml interoperability through value conversion, expression evaluation, and dynamic module management. It operates on Guile's `scm` values, s-expressions, and module bindings to enable embedding Scheme scripting in OCaml programs, marshaling data between languages, and runtime manipulation of Scheme environments. Specific capabilities include type coercion (booleans, numbers, lists), error handling, and reflective module operations for extending or querying Scheme contexts programmatically.",
      "description_length": 526,
      "index": 13,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bindings.Stubs",
      "library": "bindings",
      "description": "This module defines constants representing specific Scheme values, such as boolean false and true, end-of-list, and undefined, using the `T.Intptr.t` type. It provides direct access to these predefined Scheme values for use in OCaml code that interfaces with Scheme. Concrete use cases include initializing variables with known Scheme values and comparing against these constants in FFI (Foreign Function Interface) code.",
      "description_length": 421,
      "index": 14,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Bindings",
      "library": "bindings",
      "description": "This module defines constants representing specific Scheme values, such as boolean false, true, end-of-list, and undefined, using the `T.Intptr.t` type. It provides direct access to these predefined values for initializing variables and performing comparisons in OCaml code that interfaces with Scheme. Concrete use cases include working with FFI code where direct interaction with Scheme runtime values is required.",
      "description_length": 416,
      "index": 15,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 16,
    "meaningful_modules": 16,
    "filtered_empty_modules": 0,
    "retention_rate": 1.0
  },
  "statistics": {
    "max_description_length": 552,
    "min_description_length": 213,
    "avg_description_length": 420.8125,
    "embedding_file_size_mb": 0.23235225677490234
  }
}