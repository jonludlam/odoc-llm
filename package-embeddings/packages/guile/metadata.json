{
  "package": "guile",
  "embedding_model": "Qwen/Qwen3-Embedding-0.6B",
  "embedding_dimension": 1024,
  "total_modules": 16,
  "creation_timestamp": "2025-07-15T23:09:06.203744",
  "modules": [
    {
      "module_path": "Bindings.Stubs",
      "library": "bindings",
      "description": "This module defines constants representing fundamental values in the Scheme runtime, such as boolean false, boolean true, end-of-list, and undefined. It operates on `T.Intptr.t` values, which are used to interface directly with Scheme objects at the C FFI boundary. These constants are used to construct and compare primitive Scheme values in generated OCaml bindings for Scheme libraries.",
      "description_length": 389,
      "index": 0,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Bindings",
      "library": "bindings",
      "description": "This module provides direct access to fundamental Scheme runtime values through constants like boolean true/false, end-of-list, and undefined, all represented as `T.Intptr.t` for efficient C FFI interaction. It enables construction and comparison of primitive Scheme values within OCaml code. For example, it allows checking if a Scheme value is undefined or building boolean expressions directly compatible with Scheme libraries.",
      "description_length": 430,
      "index": 1,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "Guile.Number.Complex",
      "library": "guile.guile",
      "description": "This module provides two functions for checking whether a given value is a complex number. It operates on the `Guile.scm` type, which represents Scheme values. Concrete use cases include validating input in numerical processing routines or ensuring type correctness in mathematical computations involving complex numbers.",
      "description_length": 321,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Guile.Number.Float",
      "library": "guile.guile",
      "description": "This module provides direct operations for working with floating-point numbers and rational values in the Guile Scheme environment. It includes predicates for testing numeric properties like real, rational, infinite, or NaN values, along with functions to extract numerators and denominators, convert between OCaml and Guile float representations, and generate special values like infinity or NaN. Concrete use cases include numeric validation, rational number manipulation, and handling floating-point edge cases in Scheme extensions.",
      "description_length": 535,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Guile.Number",
      "library": "guile.guile",
      "description": "This module enables seamless type-checking and conversion of numeric values between Guile and OCaml, supporting integers, floats, complex numbers, and character types. It ensures precise handling of exact and inexact numbers, and facilitates interoperability in mixed-language numerical computing. The complex number submodule validates complex types on `Guile.scm` values, while the float and rational submodule offers predicates, conversions, and special value handling for floating-point and rational numbers. Examples include validating input for numerical routines, converting OCaml `float` to Guile representations, and generating NaN or infinity values for Scheme extensions.",
      "description_length": 682,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Guile.Sexp",
      "library": "guile.guile",
      "description": "This module converts s-expressions between OCaml and Guile representations. It provides `to_raw` to transform an OCaml s-expression into a Guile scheme value and `from_raw` to extract a Guile scheme value back into an OCaml s-expression. These functions enable direct data interchange between OCaml code using `Sexplib.Sexp` and Guile-based Scheme code.",
      "description_length": 353,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Guile.Char",
      "library": "guile.guile",
      "description": "This module provides direct predicates for character classification, including checks for alphabetic, numeric, whitespace, and case-specific characters, along with conversions between OCaml and Guile char representations. It operates on `Guile.scm` values and `char` types, enabling precise type and category checks for character data. Concrete use cases include validating input characters in parsers, filtering text based on character properties, and bridging character data between OCaml and Guile.",
      "description_length": 501,
      "index": 6,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Guile.Bool",
      "library": "guile.guile",
      "description": "This module provides direct conversions between OCaml and Guile boolean values, along with predicates and logical operations. It works with the `Guile.scm` type representing Scheme values and OCaml's built-in `bool` type. Concrete use cases include embedding boolean logic in Scheme code from OCaml and validating boolean inputs in mixed-language interfaces.",
      "description_length": 358,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Guile.Symbol",
      "library": "guile.guile",
      "description": "This module provides operations for creating, converting, and checking symbols. It works with Guile's `scm` type for symbol representation and strings for conversion to and from symbols. Concrete use cases include generating unique symbols with `gensym`, converting strings to symbols with `to_raw`, and checking symbol types with `symbol_p` and `is_symbol`.",
      "description_length": 358,
      "index": 8,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Guile.Functions",
      "library": "guile.guile",
      "description": "This module defines functions to expose OCaml functions of arity 1 to 10 to a Guile Scheme context, allowing them to be called from Scheme code. Each function takes a name, optional flags, and the OCaml function to register, handling the necessary interface conversion. It works directly with the `Guile.scm` type, which represents Scheme values in OCaml. Use this module to embed OCaml logic into a Scheme interpreter, such as adding custom primitives or extending a Scheme-based configuration system with OCaml implementations.",
      "description_length": 529,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Guile.Error",
      "library": "guile.guile",
      "description": "This module handles error signaling and exception catching in Guile Scheme. It provides `error` to throw a Scheme error with a custom message and optional tag or function name, and `catch` to handle exceptions of a specific tag by running a handler on the error key and arguments. Use it to integrate OCaml-raised errors into Guile's exception system or to safely execute Scheme code that may fail.",
      "description_length": 398,
      "index": 10,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Guile.String",
      "library": "guile.guile",
      "description": "This module provides direct operations for creating, inspecting, and converting Guile strings. It supports checking whether a value is a string, determining if it is empty, getting its length, constructing strings from character lists, and converting between Guile and OCaml string representations. These functions are useful when interfacing OCaml code with Guile Scheme, particularly for handling string inputs and outputs in a mixed-language environment.",
      "description_length": 457,
      "index": 11,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Guile.List",
      "library": "guile.guile",
      "description": "This module provides direct conversions between OCaml lists and Guile lists, using element-wise transformation functions. It supports checking if a Guile value is an empty list, extracting OCaml lists from Guile lists, and encoding OCaml lists into Guile lists. Concrete use cases include interfacing OCaml data structures with Guile-based systems, such as embedding Scheme scripts that return or consume list data.",
      "description_length": 415,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Guile.Pair",
      "library": "guile.guile",
      "description": "This module implements standard Scheme pair operations like `cons`, `car`, and `cdr`, along with derived accessors such as `cadr` and `cdar`, all working on the `Guile.scm` type. It supports construction, deconstruction, and mutation of cons cells, enabling list manipulation and traversal. Use cases include building and processing linked lists, trees, and other recursive data structures directly compatible with Scheme's native pair semantics.",
      "description_length": 446,
      "index": 13,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Guile.Module",
      "library": "guile.guile",
      "description": "This module supports dynamic module resolution, variable definition, and symbol lookup within a Scheme-like environment. It provides operations to define and manipulate modules, bind variables in the current module, and access exported symbols from other modules. Concrete use cases include embedding domain-specific languages, dynamically loading and linking Scheme modules, and exposing OCaml values to Scheme code.",
      "description_length": 417,
      "index": 14,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Guile",
      "library": "guile.guile",
      "description": "This module embeds a Scheme interpreter into OCaml applications, enabling bidirectional communication through data type conversions, function exposure, and error handling. It directly supports evaluation of Scheme code, continuation control, and module management, while child modules handle type-specific operations: numerical values are converted and checked for precision, s-expressions are encoded and decoded between OCaml and Scheme, characters and booleans are classified and converted, symbols are generated and validated, OCaml functions are exposed to Scheme, and Scheme lists and pairs are constructed and deconstructed. Examples include evaluating Scheme scripts from OCaml, converting Scheme lists into OCaml lists for typed processing, and registering OCaml functions to extend Scheme-based configuration systems. Error signaling and module manipulation further support robust integration of Scheme logic into OCaml workflows.",
      "description_length": 940,
      "index": 15,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 16,
    "meaningful_modules": 16,
    "filtered_empty_modules": 0,
    "retention_rate": 1.0
  },
  "statistics": {
    "max_description_length": 940,
    "min_description_length": 321,
    "avg_description_length": 470.5625,
    "embedding_file_size_mb": 0.058531761169433594
  }
}