{
  "package": "ocplib-endian",
  "embedding_model": "Qwen/Qwen3-Embedding-8B",
  "embedding_dimension": 4096,
  "total_modules": 21,
  "creation_timestamp": "2025-08-15T12:18:43.300532",
  "modules": [
    {
      "module_path": "EndianBytes.NativeEndian",
      "library": "ocplib-endian",
      "description": "This module provides direct byte-level access for reading and writing integer and floating-point values in machine endianness. It operates on `Stdlib.Bytes.t` buffers, supporting precise manipulation of 8-bit to 64-bit values, including signed and unsigned integers and IEEE 754 floats. Concrete use cases include binary file parsing, network protocol decoding, and low-level memory manipulation where data representation must match the host system's endianness.",
      "description_length": 462,
      "index": 0,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "EndianBytes.LittleEndian_unsafe",
      "library": "ocplib-endian",
      "description": "This module directly reads from and writes to byte buffers using little-endian encoding, handling values such as 8-bit, 16-bit, 32-bit, and 64-bit integers, floats, and chars. It operates on `Stdlib.Bytes.t`, allowing precise memory manipulation at specific offsets without bounds checking. Use it for low-level data parsing, binary file manipulation, or network protocol implementation where performance and exact byte control are critical.",
      "description_length": 441,
      "index": 1,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "EndianBytes.BigEndian_unsafe",
      "library": "ocplib-endian",
      "description": "This module provides direct, unchecked reading and writing of binary data in big-endian format to byte buffers. It supports individual bytes, signed and unsigned 8, 16, 32, and 64-bit integers, and 32/64-bit floats, using precise offsets. Use cases include low-level data serialization, network protocol parsing, and binary file manipulation where performance and exact byte layout are critical.",
      "description_length": 395,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "EndianBytes.LittleEndian",
      "library": "ocplib-endian",
      "description": "This module provides direct read and write operations for integer and floating-point values in little-endian format on `Bytes.t` buffers. It supports 8, 16, 32, and 64-bit signed and unsigned integers, as well as 32 and 64-bit floats, using precise offset-based access. Use this module when parsing or constructing binary data such as file formats, network protocols, or memory-mapped structures that require little-endian encoding.",
      "description_length": 432,
      "index": 3,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "EndianString.NativeEndian_unsafe",
      "library": "ocplib-endian",
      "description": "This module provides direct, unchecked access to read 8-, 16-, 32-, and 64-bit integer and floating-point values from strings using the machine's native endianness. It supports reading values at specific byte offsets, interpreting bytes as signed or unsigned integers and floats, with no bounds or overflow checks. These functions are suitable for low-level data parsing, such as decoding binary file formats or network protocols, where performance and direct memory access are critical.",
      "description_length": 487,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "EndianString.BigEndian_unsafe",
      "library": "ocplib-endian",
      "description": "This module provides direct, unchecked access to read 8-, 16-, 32-, and 64-bit integer and floating-point values from strings using big-endian byte order. It supports reading numeric types like `int`, `int32`, `int64`, `float`, and `char` at specified byte offsets. These functions are suitable for low-level data parsing, such as decoding binary file formats or network protocols where byte layout is known and performance is critical.",
      "description_length": 436,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "EndianBytes.BigEndian",
      "library": "ocplib-endian",
      "description": "This module provides direct read and write operations for binary data in big-endian format on `Bytes.t` buffers. It handles integral types of specific sizes (8, 16, 32, and 64 bits), floating-point numbers, and characters, with explicit signed and unsigned interpretations. Use this module when parsing or constructing binary protocols, file formats, or network data where byte order must be consistent and predictable.",
      "description_length": 419,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "EndianString.NativeEndian",
      "library": "ocplib-endian",
      "description": "This module provides functions to read binary data from strings using the machine's native endianness, supporting 8-bit, 16-bit, 32-bit, and 64-bit integers as well as 32-bit floats and 64-bit doubles. It operates directly on strings and byte sequences, allowing precise offset-based access for parsing binary formats like file headers or network protocols. The deprecated write functions are provided for backward compatibility but should be replaced with their `endianBytes` equivalents for new code.",
      "description_length": 502,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "EndianString.LittleEndian_unsafe",
      "library": "ocplib-endian",
      "description": "This module directly reads 8, 16, 32, and 64-bit integer and floating-point values from a string using little-endian byte order, with unchecked memory access. It supports both signed and unsigned integer reads and provides direct conversion to OCaml base types like int, int32, int64, and float. Concrete use cases include binary file parsing, network protocol decoding, and low-level data format manipulation where performance and direct memory interpretation are critical.",
      "description_length": 474,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "EndianString.LittleEndian",
      "library": "ocplib-endian",
      "description": "This module provides functions to read 8-, 16-, 32-, and 64-bit integers and floating-point numbers from strings using little-endian byte order. It supports both signed and unsigned integer interpretations, returning values as standard OCaml types like `int`, `int32`, `int64`, and `float`. These operations are useful when parsing binary data formats such as file headers, network protocols, or serialized structures that follow little-endian encoding.",
      "description_length": 453,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "EndianString.BigEndian",
      "library": "ocplib-endian",
      "description": "This module provides direct, unchecked access to binary data in strings using big-endian byte order. It supports reading 8-bit, 16-bit, 32-bit, and 64-bit integers (signed and unsigned), floats, and chars from specific offsets. Use cases include parsing binary file formats, network protocols, or memory-mapped data where byte layout is critical and performance matters.",
      "description_length": 370,
      "index": 10,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "EndianBytes.NativeEndian_unsafe",
      "library": "ocplib-endian",
      "description": "This module provides direct, unchecked access to read and write binary data in memory buffers according to the machine's native endianness. It operates on `Bytes.t` values, allowing precise manipulation of 8-bit, 16-bit, 32-bit, and 64-bit integer and floating-point values at specific byte offsets. These functions are used for low-level data serialization, memory-mapped I/O, and binary protocol parsing where performance and exact control over data layout are critical.",
      "description_length": 472,
      "index": 11,
      "embedding_norm": 1.0
    },
    {
      "module_path": "EndianBytes",
      "library": "ocplib-endian",
      "description": "This module defines a set of submodules for reading from and writing to byte buffers with explicit endianness control. Each submodule targets a specific byte order (big-endian, little-endian, or native) and offers both safe and unchecked variants for handling 8-, 16-, 32-, and 64-bit integers (signed and unsigned), 32- and 64-bit floats, and raw bytes at precise offsets. These modules are used for binary file parsing, network protocol implementation, and low-level memory manipulation where exact data layout and performance are essential.",
      "description_length": 543,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "EndianString",
      "library": "ocplib-endian",
      "description": "This module provides direct access to binary data in strings using specific endianness, allowing reading of 8-, 16-, 32-, and 64-bit integers (signed and unsigned), floats, and chars from precise byte offsets. It includes variants for big-endian, little-endian, and native-endian byte orderings, with both safe and unchecked access modes. Use cases include parsing binary file formats, decoding network protocols, and handling memory-mapped data where exact byte interpretation and performance are essential.",
      "description_length": 508,
      "index": 13,
      "embedding_norm": 1.0
    },
    {
      "module_path": "EndianBigstring.NativeEndian_unsafe",
      "library": "ocplib-endian.bigstring",
      "description": "This module directly reads from and writes to bigstrings using the machine's native endianness, offering precise control over binary data interpretation. It supports operations on 8-, 16-, 32-, and 64-bit integers (signed and unsigned), floats, and chars, with no bounds checking. It is suitable for low-level data parsing and serialization where performance and direct memory access are critical, such as network protocol decoding or binary file manipulation.",
      "description_length": 460,
      "index": 14,
      "embedding_norm": 1.0
    },
    {
      "module_path": "EndianBigstring.BigEndian_unsafe",
      "library": "ocplib-endian.bigstring",
      "description": "This module directly reads and writes primitive values in big-endian format to a bigstring buffer, supporting operations for 8-bit, 16-bit, 32-bit, and 64-bit integers (signed and unsigned), floats, and chars. It works with `bigstring` data structures, using integer offsets to access specific memory locations. Concrete use cases include binary protocol parsing, low-level data serialization, and direct memory manipulation for performance-sensitive applications.",
      "description_length": 464,
      "index": 15,
      "embedding_norm": 1.0
    },
    {
      "module_path": "EndianBigstring.LittleEndian",
      "library": "ocplib-endian.bigstring",
      "description": "This module reads and writes primitive numeric and character data types in little-endian byte order directly to and from bigstrings. It supports operations for 8-bit, 16-bit, 32-bit, and 64-bit integers (signed and unsigned), floats, and chars, using specific offsets within the bigstring. Concrete use cases include binary file parsing, network protocol implementation, and low-level data serialization where byte order matters.",
      "description_length": 429,
      "index": 16,
      "embedding_norm": 1.0
    },
    {
      "module_path": "EndianBigstring.NativeEndian",
      "library": "ocplib-endian.bigstring",
      "description": "This module directly reads from and writes to bigstrings using the machine's native endianness, supporting operations for 8-bit, 16-bit, 32-bit, and 64-bit integers (signed and unsigned), floats, and chars. It works specifically with `EndianBigstring.bigstring`, which is a packed, mutable byte buffer. These functions are used when parsing or constructing binary data formats such as network protocols, file formats, or low-level data structures that require precise control over memory layout.",
      "description_length": 495,
      "index": 17,
      "embedding_norm": 1.0
    },
    {
      "module_path": "EndianBigstring.BigEndian",
      "library": "ocplib-endian.bigstring",
      "description": "This module directly reads and writes primitive numeric types and characters to and from bigstrings using big-endian byte order. It operates on 8-bit, 16-bit, 32-bit, and 64-bit integers (signed and unsigned), floats, and doubles, with specific functions for each type. Concrete use cases include parsing binary network protocols, handling file formats like WAV or PNG, and working with low-level memory buffers where byte order matters.",
      "description_length": 437,
      "index": 18,
      "embedding_norm": 1.0
    },
    {
      "module_path": "EndianBigstring.LittleEndian_unsafe",
      "library": "ocplib-endian.bigstring",
      "description": "This module directly reads and writes primitive numeric types and characters to and from bigstrings using little-endian byte order, without bounds checking. It operates on `EndianBigstring.bigstring` and supports types like `char`, `int`, `int32`, `int64`, `float`, and `double`. Use cases include low-level binary protocol parsing, memory-mapped file access, and performance-sensitive serialization tasks where safety checks are omitted for speed.",
      "description_length": 448,
      "index": 19,
      "embedding_norm": 1.0
    },
    {
      "module_path": "EndianBigstring",
      "library": "ocplib-endian.bigstring",
      "description": "This module provides direct read and write operations for primitive data types (8-bit to 64-bit integers, floats, doubles, and chars) in bigstrings, supporting big-endian, little-endian, and native-endian byte orders with and without bounds checking. It works specifically with the `bigstring` type, which is a mutable, packed byte buffer. Concrete use cases include parsing and constructing binary file formats (like WAV or PNG), implementing network protocols, and handling memory-mapped I/O where precise control over byte layout and performance are essential.",
      "description_length": 563,
      "index": 20,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 21,
    "meaningful_modules": 21,
    "filtered_empty_modules": 0,
    "retention_rate": 1.0
  },
  "statistics": {
    "max_description_length": 563,
    "min_description_length": 370,
    "avg_description_length": 461.42857142857144,
    "embedding_file_size_mb": 0.30480098724365234
  }
}