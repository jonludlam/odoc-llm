{
  "package": "ocplib-endian",
  "embedding_model": "Qwen/Qwen3-Embedding-0.6B",
  "embedding_dimension": 1024,
  "total_modules": 24,
  "creation_timestamp": "2025-07-15T23:11:18.156018",
  "modules": [
    {
      "module_path": "EndianString.NativeEndian",
      "library": "ocplib-endian",
      "description": "This module provides direct access to binary data in strings using the machine's native endianness, with functions to read 8, 16, 32, and 64-bit integers (signed and unsigned), floats, and chars at specific byte offsets. It supports parsing binary file formats, network protocols, or low-level data structures by extracting primitive values from raw memory buffers. The deprecated write functions offer in-place mutation of byte buffers but are superseded by the `endianBytes` module.",
      "description_length": 484,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "EndianBytes.NativeEndian_unsafe",
      "library": "ocplib-endian",
      "description": "This module provides direct, unchecked access to read and write binary data in memory buffers according to the machine's native endianness. It operates on `Stdlib.Bytes.t` values, interpreting byte sequences as integers of various widths (8, 16, 32, 64 bits) and floating-point numbers (32 and 64 bits). These functions are suitable for low-level data manipulation, such as parsing binary file formats or network protocols where performance and exact control over binary representation are required.",
      "description_length": 499,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "EndianBytes.EndianBytesSig",
      "library": "ocplib-endian",
      "description": "This module provides functions to read and write specific numeric and character data types from or to a `Bytes.t` buffer using big-endian byte order. It supports operations for 8-bit, 16-bit, 32-bit, and 64-bit integers (both signed and unsigned), as well as 32-bit floats and 64-bit doubles, with direct memory manipulation. Concrete use cases include parsing binary file formats, network protocol implementations, and low-level data serialization where byte-level control is required.",
      "description_length": 486,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "EndianBytes.NativeEndian",
      "library": "ocplib-endian",
      "description": "This module provides direct byte-level access to `Bytes.t` buffers using the machine's native endianness. It supports reading and writing integers of specific bit widths (8, 16, 32, 64 bits), floats, doubles, and chars at arbitrary offsets. Use cases include binary file parsing, network protocol implementation, and low-level memory manipulation where exact control over byte layout is required.",
      "description_length": 396,
      "index": 3,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "EndianString.EndianStringSig",
      "library": "ocplib-endian",
      "description": "This module provides functions to read 8, 16, 32, and 64-bit integers and floating-point numbers from strings using big-endian byte order. It supports both signed and unsigned integer reads, as well as char extraction, at specified byte offsets. These operations are useful for parsing binary data formats such as network protocols or file formats that require strict byte-level interpretation.",
      "description_length": 394,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "EndianString.BigEndian_unsafe",
      "library": "ocplib-endian",
      "description": "This module provides direct, unchecked access to read 8-, 16-, 32-, and 64-bit integer values, floating-point numbers, and characters from strings using big-endian byte order. It operates on standard OCaml strings and bytes, allowing precise manipulation of binary data at specific offsets. These functions are suitable for low-level parsing of binary formats like network protocols or file headers where performance and exact byte interpretation are critical.",
      "description_length": 460,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "EndianString.LittleEndian",
      "library": "ocplib-endian",
      "description": "This module provides functions to read 16-bit, 32-bit, and 64-bit integers, floating-point numbers, and characters from strings using little-endian byte order. It supports both signed and unsigned integer interpretations, returning values of types int, int32, int64, and float. These operations are useful for parsing binary data formats such as file headers, network protocols, or memory-mapped structures that use little-endian encoding.",
      "description_length": 439,
      "index": 6,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "EndianString.NativeEndian_unsafe",
      "library": "ocplib-endian",
      "description": "This module provides direct access to binary data in strings using the native endianness of the machine. It includes functions to read 8-bit, 16-bit, 32-bit, and 64-bit integers (signed and unsigned) as well as float and double values from a given offset in a string. These operations are typically used for low-level data parsing, such as interpreting binary file formats or network protocols.",
      "description_length": 394,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "EndianBytes.LittleEndian",
      "library": "ocplib-endian",
      "description": "This module provides functions to read and write binary data in little-endian format from and to `Bytes.t` buffers. It supports reading and writing integers of various sizes (8-bit to 64-bit), floating-point numbers (`float` and `double`), and characters at specific byte offsets. Use cases include parsing binary file formats, network protocols, and low-level data serialization where byte order matters.",
      "description_length": 405,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "EndianBytes.LittleEndian_unsafe",
      "library": "ocplib-endian",
      "description": "This module provides direct, unchecked access to read and write integer and floating-point values in little-endian format from byte buffers. It operates on `Stdlib.Bytes.t` buffers, using offsets to access specific positions, and supports data types such as 8-bit, 16-bit, 32-bit, and 64-bit integers (signed and unsigned), floats, and doubles. Use cases include low-level binary data parsing, network protocol implementation, and file format manipulation where performance and precise memory control are critical.",
      "description_length": 514,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "EndianBytes.BigEndian",
      "library": "ocplib-endian",
      "description": "This module provides functions to read and write binary data in big-endian format within a `Bytes.t` buffer. It supports direct manipulation of 8-bit, 16-bit, 32-bit, and 64-bit integers (both signed and unsigned), as well as 32-bit floats and 64-bit doubles, using specific offsets. These operations are useful for low-level data parsing, network protocol implementation, and binary file format handling where byte order matters.",
      "description_length": 430,
      "index": 10,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "EndianString.BigEndian",
      "library": "ocplib-endian",
      "description": "This module provides direct, unchecked access to binary data in strings using big-endian byte order. It includes functions to read 8-bit, 16-bit, 32-bit, and 64-bit integers, both signed and unsigned, as well as 32-bit and 64-bit floating-point numbers. These operations are useful for parsing binary protocols, file formats, or network data where byte-level precision is required.",
      "description_length": 381,
      "index": 11,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "EndianString.LittleEndian_unsafe",
      "library": "ocplib-endian",
      "description": "This module provides direct, unchecked access to read 8-, 16-, 32-, and 64-bit integer and floating-point values from strings using little-endian byte order. It supports reading numeric types like `int`, `int32`, `int64`, `float`, and `double` from binary data buffers, assuming the caller ensures valid offsets and buffer sizes. These functions are suitable for low-level binary parsing tasks such as decoding file formats or network protocols where performance and precise memory layout are critical.",
      "description_length": 502,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "EndianBytes.BigEndian_unsafe",
      "library": "ocplib-endian",
      "description": "This module provides direct, unchecked big-endian reading and writing of binary data to byte buffers. It operates on `Stdlib.Bytes.t` buffers, allowing precise access to 8-bit, 16-bit, 32-bit, and 64-bit integer and floating-point values at specific offsets. Use cases include low-level data parsing, binary file manipulation, network protocol decoding, and direct memory access where performance and exact byte layout matter.",
      "description_length": 426,
      "index": 13,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "EndianBytes",
      "library": "ocplib-endian",
      "description": "This module enables efficient manipulation of binary data in byte buffers with precise control over endianness, offering functions to read and write integers and floating-point values at arbitrary offsets. It provides submodules for native-endian, big-endian, and little-endian operations, each supporting 8-, 16-, 32-, and 64-bit integers (signed and unsigned), 32- and 64-bit floats, and direct character access. For example, you can parse a binary file header by reading a 32-bit integer in big-endian format or decode a network packet by extracting a little-endian 64-bit value. The module also includes both safe and unchecked variants for performance-sensitive contexts, making it suitable for tasks like implementing custom binary protocols or working with memory-mapped files.",
      "description_length": 784,
      "index": 14,
      "embedding_norm": 1.0
    },
    {
      "module_path": "EndianString",
      "library": "ocplib-endian",
      "description": "This module enables reading and writing multi-byte values such as integers and floats to strings with explicit endianness control, supporting big-endian, little-endian, and native-endian formats. It includes operations for both safe and unsafe packing and unpacking of binary data, allowing precise interpretation of raw memory buffers at specific byte offsets. Submodules specialize in direct, unchecked access to binary data using specific endianness, enabling efficient parsing of binary file formats, network protocols, and memory-mapped structures. For example, you can extract a 32-bit signed integer from a big-endian buffer, read a float from a native-endian string, or decode a little-endian 64-bit value from a binary header.",
      "description_length": 735,
      "index": 15,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "EndianBigstring.NativeEndian",
      "library": "ocplib-endian.bigstring",
      "description": "This module provides direct access to binary data stored in bigstrings using the machine's native endianness, allowing efficient reading and writing of 8-bit, 16-bit, 32-bit, and 64-bit integer and floating-point values at specific byte offsets. It supports both signed and unsigned integer interpretations and includes functions for converting between float representations and their bit patterns. Use cases include low-level data parsing, binary file manipulation, and network protocol implementation where precise control over memory layout is required.",
      "description_length": 556,
      "index": 16,
      "embedding_norm": 1.0
    },
    {
      "module_path": "EndianBigstring.EndianBigstringSig",
      "library": "ocplib-endian.bigstring",
      "description": "This module provides functions to read and write binary data in big-endian format from and to bigstrings. It supports operations on integers of various bit widths (8, 16, 32, 64), floating-point numbers (32 and 64 bits), and characters, with precise control over memory layout. It is used for low-level data manipulation, such as parsing network protocols or binary file formats.",
      "description_length": 379,
      "index": 17,
      "embedding_norm": 1.0
    },
    {
      "module_path": "EndianBigstring.LittleEndian",
      "library": "ocplib-endian.bigstring",
      "description": "This module provides functions to read and write binary data in little-endian format from and to bigstrings. It supports operations for extracting or storing integers of various sizes (8-bit to 64-bit), floating-point numbers, and characters at specific byte offsets. Use cases include parsing binary file formats, network protocols, or low-level data serialization where byte order matters.",
      "description_length": 391,
      "index": 18,
      "embedding_norm": 1.0
    },
    {
      "module_path": "EndianBigstring.LittleEndian_unsafe",
      "library": "ocplib-endian.bigstring",
      "description": "This module provides direct, unchecked access to read and write integer and floating-point values in little-endian format from a bigstring buffer. It operates on 8-bit, 16-bit, 32-bit, and 64-bit integers, as well as 32-bit floats and 64-bit doubles, using specified byte offsets. Concrete use cases include low-level binary protocol parsing, memory-mapped file manipulation, and performance-sensitive serialization/deserialization tasks where safety checks are omitted for speed.",
      "description_length": 480,
      "index": 19,
      "embedding_norm": 1.0
    },
    {
      "module_path": "EndianBigstring.NativeEndian_unsafe",
      "library": "ocplib-endian.bigstring",
      "description": "This module provides direct, unchecked access to read and write binary data in bigstrings using the machine's native endianness. It supports operations for handling integers of various bit widths (8 to 64 bits), floating-point numbers (32 and 64 bits), and characters at specific byte offsets. These functions are used when implementing low-level binary protocols, memory-mapped I/O, or performance-sensitive serialization logic.",
      "description_length": 429,
      "index": 20,
      "embedding_norm": 1.0
    },
    {
      "module_path": "EndianBigstring.BigEndian_unsafe",
      "library": "ocplib-endian.bigstring",
      "description": "This module provides direct, unchecked access to read and write integer and floating-point values in big-endian format from a bigstring buffer. It supports operations for 8-bit, 16-bit, 32-bit, and 64-bit integers, both signed and unsigned, as well as 32-bit float and 64-bit double values. Use cases include low-level binary protocol parsing, memory-mapped file access, and performance-critical serialization where safety checks are unnecessary or already handled.",
      "description_length": 465,
      "index": 21,
      "embedding_norm": 1.0
    },
    {
      "module_path": "EndianBigstring.BigEndian",
      "library": "ocplib-endian.bigstring",
      "description": "This module provides direct, unchecked big-endian reading and writing of integral and floating-point values to and from bigstrings. It operates on `EndianBigstring.bigstring` and supports precise access to 8-bit, 16-bit, 32-bit, and 64-bit values, both signed and unsigned, as well as `float` values via their bit representations. It is suitable for low-level data parsing and serialization, such as decoding binary file formats or network protocols where byte layout is critical.",
      "description_length": 480,
      "index": 22,
      "embedding_norm": 1.0
    },
    {
      "module_path": "EndianBigstring",
      "library": "ocplib-endian.bigstring",
      "description": "This module enables reading and writing multi-byte values such as integers and floats to bigstrings with explicit endianness control, offering both safe and unsafe variants for performance. It includes submodules for native-endian, big-endian, and little-endian operations, each supporting 8-bit to 64-bit integers and 32/64-bit floats with precise offset-based access. You can parse binary protocols, manipulate file formats, or serialize data with exact memory layout control, using functions like `get_int32` or `set_float64` at specific byte positions. The module supports both checked and unchecked variants, allowing trade-offs between safety and speed in low-level data processing tasks.",
      "description_length": 694,
      "index": 23,
      "embedding_norm": 0.9999998807907104
    }
  ],
  "filtering": {
    "total_modules_in_package": 24,
    "meaningful_modules": 24,
    "filtered_empty_modules": 0,
    "retention_rate": 1.0
  },
  "statistics": {
    "max_description_length": 784,
    "min_description_length": 379,
    "avg_description_length": 483.4583333333333,
    "embedding_file_size_mb": 0.0876150131225586
  }
}