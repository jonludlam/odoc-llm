{
  "package": "iri",
  "embedding_model": "Qwen/Qwen3-Embedding-8B",
  "embedding_dimension": 4096,
  "total_modules": 7,
  "creation_timestamp": "2025-08-14T23:02:47.302691",
  "modules": [
    {
      "module_path": "Iri.KV",
      "library": "iri",
      "description": "This module implements a map data structure with ordered keys, offering operations for associative updates, ordered traversal, merging, filtering,",
      "description_length": 146,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Iri.Map",
      "library": "iri",
      "description": "This module implements ordered associative collections mapping `Iri.t` keys to arbitrary values, supporting efficient insertion, lookup, and transformation operations. It provides ordered traversal, filtering, and combination of maps using key-based comparisons, along with utilities to convert between maps and sequences or lists while preserving key order. Typical applications include managing hierarchical key-value relationships, merging configuration data, or processing ordered datasets where precise key ordering and efficient range operations are critical.",
      "description_length": 565,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Iri_types.KV",
      "library": "iri",
      "description": "This module implements a string-keyed polymorphic map with ordered traversal, supporting operations like merging, filtering, and transformation while preserving key sequence. It emphasizes ordered manipulation through range-based queries, bidirectional iteration, and conditional searches, with utilities to convert between maps and ordered key-value sequences. Use cases include maintaining structured metadata, processing ordered key-value streams, and implementing dictionary-like configurations with strict sequence requirements.",
      "description_length": 533,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Iri.Set",
      "library": "iri",
      "description": "This module offers ordered set operations for managing collections of `Iri.t` values, supporting element insertion/removal, membership checks, and ordered traversal. It provides transformations like mapping, filtering, and folding, along with structural comparisons and conversions to lists or sequences for efficient iteration. Typical use cases include maintaining sorted unique identifier sets, performing set algebra, and processing elements in ascending or descending order through sequence-based workflows.",
      "description_length": 512,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Iri_types",
      "library": "iri",
      "description": "This library provides operations for parsing, constructing, and normalizing Internationalized Resource Identifiers (IRIs) with support for component manipulation, percent-encoding, and Unicode normalization. It works with structured representations of IRIs, including optional scheme, path, query, and fragment components, and uses ordered key-value maps for handling query parameters with rich traversal capabilities. Typical use cases include validating and transforming IRIs for web services, encoding/decoding URL components, and normalizing paths or hostnames according to standard semantics.",
      "description_length": 597,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Iri",
      "library": "iri",
      "description": "The module provides operations for constructing, normalizing, and resolving hierarchical identifiers with support for encoded/decoded string representations, including path hierarchies, key-value query pairs, and fragment components. It works with structured types like `path`, `query_kv`, and collections such as sets and maps to manage IRI relationships, enabling customizable equality checks and comparison logic. This is particularly useful in web applications for URL routing, HTTP API client libraries requiring normalized endpoint handling, or data processing pipelines that need to resolve relative references against base identifiers.",
      "description_length": 643,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Iri_lexer",
      "library": "iri",
      "description": "This module parses IRI (Internationalized Resource Identifier) and HTTP link headers from lexing buffers, producing structured values while tracking source positions for error reporting. It handles lexical analysis with position tracking using `Sedlexing` and `Lexing.position`, and reports errors with precise locations. Concrete use cases include parsing IRIs with optional percent-decoding and extracting link headers from HTTP messages.",
      "description_length": 440,
      "index": 6,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 7,
    "meaningful_modules": 7,
    "filtered_empty_modules": 0,
    "retention_rate": 1.0
  },
  "statistics": {
    "max_description_length": 643,
    "min_description_length": 146,
    "avg_description_length": 490.85714285714283,
    "embedding_file_size_mb": 0.10184001922607422
  }
}