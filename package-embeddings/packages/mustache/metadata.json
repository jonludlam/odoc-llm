{
  "package": "mustache",
  "embedding_model": "Qwen/Qwen3-Embedding-0.6B",
  "embedding_dimension": 1024,
  "total_modules": 8,
  "creation_timestamp": "2025-07-15T23:06:01.220933",
  "modules": [
    {
      "module_path": "Mustache.With_locations.Infix",
      "library": "mustache",
      "description": "This module provides an infix operator `(^)` for concatenating two mustache template pieces that include source-file locations. It constructs a concatenated template node with a dummy location, intended for use when the exact source position is not critical. Use this operator to build larger templates from smaller components while preserving structure and location tracking.",
      "description_length": 376,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mustache_types.Ast",
      "library": "mustache",
      "description": "Represents the abstract syntax tree for Mustache templates, including source location and node descriptions. It defines the structure of parsed Mustache expressions, such as variables, sections, and text. Used during template parsing and rendering to traverse and evaluate Mustache constructs.",
      "description_length": 293,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mustache.Json",
      "library": "mustache",
      "description": "This module provides functions to convert JSON data into the mustache template format and render templates using JSON values. It supports operations for mapping JSON objects and arrays to mustache contexts, enabling dynamic template rendering from structured data. Concrete use cases include generating HTML pages or configuration files from JSON inputs.",
      "description_length": 354,
      "index": 2,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Mustache.With_locations",
      "library": "mustache",
      "description": "This module extends the Mustache template system with source location tracking, enabling precise error reporting and debugging during parsing, rendering, and template construction. It introduces a location-annotated template type and builder primitives like `raw`, `section`, and `concat` to assemble templates while preserving positional context. The child module adds the `(^)` operator for convenient concatenation of template fragments, useful when exact source positions are not required. Together, they support workflows like partial expansion, JSON-driven text generation, and structured template assembly with robust location handling.",
      "description_length": 643,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mustache.Infix",
      "library": "mustache",
      "description": "This module defines the `(^)` operator for concatenating two Mustache template fragments into a single template. It operates directly on values of type `Mustache.t`, enabling seamless composition of template parts. Use this operator to build complex templates incrementally from smaller, reusable components.",
      "description_length": 308,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mustache_parser",
      "library": "mustache",
      "description": "Parses Mustache template syntax into an abstract syntax tree using a lexer function. It processes tokens like sections, variables, partials, and comments to construct the tree. Useful for implementing Mustache templating engines or custom template processors.",
      "description_length": 259,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mustache",
      "library": "mustache",
      "description": "This module enables the creation and rendering of Mustache templates using JSON data, supporting dynamic content generation with conditionals, partials, and HTML escaping. It operates on a template abstract syntax tree and JSON values, offering functions to parse, transform, and render templates while tracking source locations for precise error handling. You can build HTML pages or text documents from structured data, compose templates incrementally using the `(^)` operator, and manage reusable fragments through partials resolution. The module also provides utilities for mapping JSON objects and arrays to Mustache contexts, along with location-aware template construction primitives for advanced template assembly.",
      "description_length": 722,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mustache_lexer",
      "library": "mustache",
      "description": "This module processes Mustache template syntax by tokenizing input buffers and handling whitespace, identifiers, partial names, and comments. It parses mustache tags, splits identifiers into segments, and validates expected versus actual mustache delimiters. Key operations include lexing mustache tokens, managing standalone tags, and extracting strings from nested structures.",
      "description_length": 378,
      "index": 7,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 9,
    "meaningful_modules": 8,
    "filtered_empty_modules": 1,
    "retention_rate": 0.8888888888888888
  },
  "statistics": {
    "max_description_length": 722,
    "min_description_length": 259,
    "avg_description_length": 416.625,
    "embedding_file_size_mb": 0.02944660186767578
  }
}