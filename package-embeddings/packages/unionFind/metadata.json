{
  "package": "unionFind",
  "embedding_model": "Qwen/Qwen3-Embedding-8B",
  "embedding_dimension": 4096,
  "total_modules": 7,
  "creation_timestamp": "2025-08-14T23:05:14.947390",
  "modules": [
    {
      "module_path": "UnionFind.StoreMap.Make",
      "library": "unionFind",
      "description": "This module implements persistent stores for union-find using immutable integer maps, enabling efficient reference management. It supports creating stores, allocating and accessing references, and comparing references for equality. Use it when you need a union-find structure with constant-time store copying and reference operations backed by immutable maps.",
      "description_length": 359,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "UnionFind.StoreMap",
      "library": "unionFind",
      "description": "This module implements persistent stores for union-find using immutable integer maps, enabling efficient reference management. It supports creating stores, allocating and accessing references, and comparing references for equality. Use it when you need a union-find structure with constant-time store copying and reference operations backed by immutable maps.",
      "description_length": 359,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "UnionFind.StoreRef",
      "library": "unionFind",
      "description": "This module implements a mutable store for managing references with support for creating, reading, writing, and comparing references within a union-find structure. It works with disjoint set forests that use path compression and rank-based linking to efficiently manage equivalence classes. Concrete use cases include dynamic connectivity tracking and equivalence class merging in algorithms like Kruskal's minimum spanning tree.",
      "description_length": 429,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "UnionFind.Make",
      "library": "unionFind",
      "description": "This module implements a union-find data structure with path compression and union by rank, using a customizable store for managing references. It supports operations like `make` to create references, `get` and `set` for reading and writing values, `union` and `merge` to combine equivalence classes, and `find` to locate class representatives. It is suitable for applications requiring efficient partitioning and merging of elements, such as graph connectivity analysis or type inference systems.",
      "description_length": 497,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "UnionFind.StoreTransactionalRef",
      "library": "unionFind",
      "description": "This module implements mutable stores with transactional references for managing dynamic, versioned state within a union-find structure. It supports creating and manipulating references with atomic transactions that can be committed or rolled back, enabling backtracking over mutable state changes. Concrete use cases include implementing backtracking algorithms like SAT solvers or version control systems where state snapshots and rollbacks are essential.",
      "description_length": 457,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "UnionFind.StoreVector",
      "library": "unionFind",
      "description": "This module implements mutable stores using extensible arrays, supporting reference creation, reading, writing, and equality checks. It works with references (`rref`) and generic values of type `'a`, enabling efficient per-reference updates and copies that preserve reference validity. Concrete use cases include managing dynamic collections of values with fast access and mutation, such as tracking evolving disjoint sets in union-find operations.",
      "description_length": 448,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "UnionFind",
      "library": "unionFind",
      "description": "This module implements a union-find data structure with path compression and union by rank. It supports creating mutable references, merging equivalence classes with customizable value combination, and finding canonical representatives for efficient equivalence checks. Concrete use cases include Kruskal's algorithm for minimum spanning trees and type unification in compilers.",
      "description_length": 378,
      "index": 6,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 7,
    "meaningful_modules": 7,
    "filtered_empty_modules": 0,
    "retention_rate": 1.0
  },
  "statistics": {
    "max_description_length": 497,
    "min_description_length": 359,
    "avg_description_length": 418.14285714285717,
    "embedding_file_size_mb": 0.0875387191772461
  }
}