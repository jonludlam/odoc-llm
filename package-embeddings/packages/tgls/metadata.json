{
  "package": "tgls",
  "embedding_model": "Qwen/Qwen3-Embedding-0.6B",
  "embedding_dimension": 1024,
  "total_modules": 8,
  "creation_timestamp": "2025-07-15T23:08:51.655094",
  "modules": [
    {
      "module_path": "Tgles2.Gl",
      "library": "tgls.tgles2",
      "description": "This module facilitates low-level graphics programming by managing GPU resources such as buffers, textures, framebuffers, and shaders, alongside configuring rendering states like blending, depth testing, and culling. It operates on data structures including bigarrays for efficient memory transfer, enumerants defining GPU parameters (e.g., texture filtering modes, primitive types), and identifiers for shader programs or buffer objects. Specific use cases include initializing rendering pipelines on embedded systems, implementing custom shaders with attribute/uniform handling, and fine-grained control over rasterization states for applications requiring real-time 2D/3D graphics.",
      "description_length": 684,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Tgles2",
      "library": "tgls.tgles2",
      "description": "This module enables low-level graphics programming by managing GPU resources such as buffers, textures, framebuffers, and shaders, while providing control over rendering states like blending, depth testing, and culling. It operates on bigarrays for efficient memory transfer, enumerants for GPU parameters, and identifiers for shader programs and buffer objects. You can use it to set up rendering pipelines on embedded systems, implement custom shaders with attribute and uniform handling, and configure rasterization states for real-time 2D or 3D graphics. Examples include loading vertex data into GPU buffers, compiling and linking shaders, and setting texture sampling parameters for efficient rendering.",
      "description_length": 709,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Tgles3.Gl",
      "library": "tgls.tgles3",
      "description": "This module provides low-level graphics operations for rendering pipeline control (e.g., drawing primitives, configuring blending/depth tests), GPU resource management (buffers, textures, shaders, framebuffers), and state introspection (querying limits, metadata, debug info). It works with OpenGL object IDs, bigarrays for bulk data transfer, enums/bitfields for state configuration, and synchronization primitives. These functions are used for developing high-performance 3D graphics applications, implementing custom rendering engines, or optimizing GPU-bound workflows requiring direct hardware access.",
      "description_length": 606,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Tgles3",
      "library": "tgls.tgles3",
      "description": "This module enables direct control of OpenGL ES 3.x rendering pipelines, supporting operations such as drawing primitives, managing GPU resources like buffers and textures, and configuring state through enums and bitfields. It provides low-level access to GPU object IDs, bigarrays for efficient data transfer, and synchronization mechanisms. You can use it to build custom 3D rendering engines, optimize graphics performance, or query GPU capabilities for debugging and introspection. Example tasks include setting up framebuffers for offscreen rendering, uploading texture data, or configuring depth testing for complex scenes.",
      "description_length": 629,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Tgl4.Gl",
      "library": "tgls.tgl4",
      "description": "This module provides low-level access to OpenGL 4.x graphics operations, focusing on GPU resource management, rendering state configuration, and shader programming. It works with OpenGL objects such as programs, shaders, buffers, textures, framebuffers, and vertex arrays, using types like enums, bitfields, bigarrays, and numeric types to manipulate GPU memory and state. Key use cases include setting up rendering pipelines, managing texture and buffer data transfers, configuring blending and depth testing, and handling shader uniforms and vertex attributes for high-performance graphics applications.",
      "description_length": 605,
      "index": 4,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Tgl4",
      "library": "tgls.tgl4",
      "description": "This module provides direct access to OpenGL 4.x graphics functionality, enabling low-level control over GPU resources and rendering pipelines. It supports operations on core OpenGL objects like shaders, programs, buffers, textures, and framebuffers, using enums, bitfields, and bigarrays for efficient GPU memory and state manipulation. You can use it to configure rendering states such as blending and depth testing, manage shader uniforms and vertex attributes, and transfer data between CPU and GPU for high-performance graphics applications. Example tasks include setting up shader-based rendering pipelines, uploading texture data, and rendering complex 3D scenes with custom vertex and fragment processing.",
      "description_length": 713,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Tgl3.Gl",
      "library": "tgls.tgl3",
      "description": "This module provides low-level OpenGL 3.x operations for graphics state management, resource binding, and rendering control in OCaml. It works with OpenGL object IDs (textures, buffers, shaders, framebuffers), bigarrays for GPU data transfer, enums for configuration parameters, and sync primitives for GPU-CPU synchronization. Specific use cases include setting up rendering pipelines, managing texture and buffer resources, configuring shader programs, and implementing efficient GPU data workflows through direct OpenGL API bindings.",
      "description_length": 536,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Tgl3",
      "library": "tgls.tgl3",
      "description": "This module provides direct access to OpenGL 3.x functionality, enabling low-level control over graphics state, resource binding, and rendering operations. It supports working with textures, buffers, shaders, and framebuffers using OpenGL object IDs, along with efficient data transfer via bigarrays and synchronization primitives. You can use it to configure rendering pipelines, manage GPU resources, and implement custom graphics workflows with direct OpenGL API calls. Example tasks include compiling and linking shader programs, uploading texture data, setting up vertex buffer objects, and synchronizing CPU-GPU operations.",
      "description_length": 629,
      "index": 7,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 8,
    "meaningful_modules": 8,
    "filtered_empty_modules": 0,
    "retention_rate": 1.0
  },
  "statistics": {
    "max_description_length": 713,
    "min_description_length": 536,
    "avg_description_length": 638.875,
    "embedding_file_size_mb": 0.029473304748535156
  }
}