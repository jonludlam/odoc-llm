{
  "package": "graphql-cohttp",
  "embedding_model": "Qwen/Qwen3-Embedding-0.6B",
  "embedding_dimension": 1024,
  "total_modules": 16,
  "creation_timestamp": "2025-07-15T23:09:04.800909",
  "modules": [
    {
      "module_path": "Graphql_websocket.Connection.S",
      "library": "graphql-cohttp",
      "description": "This module implements a connection handler for GraphQL over WebSocket, providing functions to create, manage, and communicate over a WebSocket connection using GraphQL frames. It works with `Cohttp.Request.t`, `Cohttp.Response.t`, `Graphql_websocket.Frame.t`, and standard IO channels. Concrete use cases include upgrading an HTTP request to a WebSocket connection, sending and receiving GraphQL operation frames, and handling bidirectional communication with a GraphQL server over WebSocket.",
      "description_length": 493,
      "index": 0,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Graphql_websocket.Frame.Opcode",
      "library": "graphql-cohttp",
      "description": "This module defines and manipulates WebSocket frame opcodes, including standard types like text, binary, close, ping, and pong, as well as control and non-control extensions. It provides conversions to string and pretty-printing for debugging and protocol inspection. Concrete use cases include handling WebSocket message types and managing frame metadata during connection negotiation or data transmission.",
      "description_length": 407,
      "index": 1,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Graphql_websocket.Connection.Make",
      "library": "graphql-cohttp",
      "description": "This module implements a GraphQL WebSocket connection handler with operations to send and receive WebSocket frames, using a provided IO module for input/output. It works with `Graphql_websocket.Frame.t`, `Cohttp.Request.t`, and `Cohttp.Response.t` to manage the lifecycle and data exchange of a WebSocket connection. Concrete use cases include handling GraphQL subscriptions over WebSocket, managing connection upgrades, and processing incoming and outgoing messages in a server or client implementation.",
      "description_length": 504,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Graphql_websocket.Connection.S-IO",
      "library": "graphql-cohttp",
      "description": "This module defines low-level IO operations for handling input and output over a connection, including reading lines or raw data from an input channel and writing or flushing data to an output channel. It works with connection types `ic` and `oc` to represent input and output channels, and uses `IO.t` for asynchronous operations. Concrete use cases include implementing custom network protocols, handling WebSocket message framing, and streaming data over persistent connections.",
      "description_length": 481,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Graphql_cohttp.S-IO",
      "library": "graphql-cohttp",
      "description": "This module implements asynchronous IO operations for handling GraphQL over HTTP. It provides functions for reading from and writing to input/output channels, including line-based reading, buffered reads, and synchronous writes with flushing. Concrete use cases include parsing HTTP requests line-by-line, streaming request bodies, and sending formatted GraphQL responses over network connections.",
      "description_length": 397,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Graphql_cohttp.HttpBody",
      "library": "graphql-cohttp",
      "description": "This module handles the conversion between HTTP body content and GraphQL operations. It provides functions to serialize a GraphQL body to a string and parse a string into a GraphQL body. Useful for processing incoming GraphQL queries or formatting outgoing responses over HTTP.",
      "description_length": 277,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Websocket_handler.Make",
      "library": "graphql-cohttp",
      "description": "Implements WebSocket message parsing and response generation for GraphQL subscriptions. Handles incoming frames by validating client messages, managing subscription lifecycle events, and executing queries through a provided resolver function. Works directly with WebSocket connections, JSON payloads, and GraphQL AST values to enable real-time data streaming over WebSocket connections.",
      "description_length": 386,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Graphql_websocket.Connection",
      "library": "graphql-cohttp",
      "description": "This module manages WebSocket connections for real-time GraphQL communication in both client and server contexts, supporting connection setup, message serialization, and bidirectional data exchange. It works with `Cohttp.Request.t`, `Cohttp.Response.t`, `Graphql_websocket.Frame.t`, and IO channels to handle tasks like upgrading HTTP connections, sending GraphQL operation frames, and maintaining persistent WebSocket links. Submodules provide low-level IO primitives for reading and writing raw data, enabling custom protocol implementations and streaming behaviors over established connections. Example uses include implementing GraphQL subscriptions, handling WebSocket upgrades in a server, or maintaining a live client connection to a GraphQL backend.",
      "description_length": 757,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Assets.Internal",
      "library": "graphql-cohttp",
      "description": "This module provides direct access to embedded asset data through predefined constants and functions for processing file content. It includes a fixed string value representing a specific asset, a function to split file content into chunks, and a list of file paths. Concrete use cases include retrieving embedded configuration data, parsing files into manageable segments, and accessing predefined file lists for internal resources.",
      "description_length": 432,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Graphql_cohttp.S",
      "library": "graphql-cohttp",
      "description": "This module handles GraphQL request execution and response generation using Cohttp. It provides `execute_request` to process incoming requests with a schema and context, returning a response action that either streams or sends a complete response. The `make_callback` function creates a server callback for handling GraphQL queries with custom context initialization.",
      "description_length": 367,
      "index": 9,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Graphql_websocket.Frame",
      "library": "graphql-cohttp",
      "description": "This module constructs and manipulates WebSocket frames for GraphQL over WebSocket communication, supporting operations to create frames with specific opcodes, extension data, and payloads. It includes functions to generate close frames with status codes and works directly with string-based payloads and integer-based extensions. The opcode submodule defines standard frame types like text, binary, close, ping, and pong, offering conversions to strings and utilities for debugging and protocol inspection. Use cases include managing message types during data transmission and handling connection lifecycle events like closing or pinging.",
      "description_length": 639,
      "index": 10,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Graphql_cohttp.Make",
      "library": "graphql-cohttp",
      "description": "This module implements a GraphQL HTTP server with support for executing GraphQL queries over HTTP. It handles parsing incoming HTTP requests, validating and executing GraphQL operations against a provided schema, and generating appropriate HTTP responses. Concrete use cases include building GraphQL APIs with Cohttp as the HTTP server backend.",
      "description_length": 344,
      "index": 11,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Graphql_cohttp",
      "library": "graphql-cohttp",
      "description": "This module sends GraphQL queries over HTTP, handling requests and responses with support for headers and cookies. It works with standard GraphQL strings and Cohttp types, enabling direct interaction with GraphQL APIs. The child modules handle IO operations, body serialization, request execution, and server setup. You can read HTTP requests line-by-line, convert GraphQL bodies to strings, execute queries against a schema, and build a GraphQL HTTP server.",
      "description_length": 458,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Assets",
      "library": "graphql-cohttp",
      "description": "This module manages file-based asset operations, offering functions to list available files and read their contents, with support for handling optional string results and string lists. It includes embedded asset data through predefined constants and processing functions, such as splitting file content into chunks and accessing fixed file paths. You can use it to load and parse configuration files or templates from a predefined directory, or retrieve and process internal resources stored as embedded data. Specific operations include reading a file into a string, splitting content into lines or blocks, and accessing a predefined list of asset paths for internal use.",
      "description_length": 672,
      "index": 13,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Graphql_websocket",
      "library": "graphql-cohttp",
      "description": "This module enables real-time GraphQL communication over WebSocket by managing connections and framing protocols for bidirectional data exchange. It provides core data types such as `Graphql_websocket.Frame.t` for message framing and integrates with `Cohttp` types for handling WebSocket upgrades and IO channels for streaming. Operations include sending GraphQL operation frames, handling connection lifecycle events, and working with opcode types like text, binary, close, and ping. Example uses include implementing GraphQL subscriptions, managing WebSocket upgrades on the server, and maintaining live client connections with ping/pong health checks.",
      "description_length": 654,
      "index": 14,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Websocket_handler",
      "library": "graphql-cohttp",
      "description": "This module handles WebSocket connections for GraphQL subscriptions by parsing incoming messages, validating client requests, and managing subscription lifecycles. It processes JSON payloads and GraphQL AST values to execute queries via a resolver function and generate appropriate responses. Key operations include accepting connections, handling subscription start/stop events, and streaming real-time data updates. For example, it can accept a new WebSocket connection, parse a subscription query, execute it with variables, and push incremental results to the client as events occur.",
      "description_length": 587,
      "index": 15,
      "embedding_norm": 0.9999999403953552
    }
  ],
  "filtering": {
    "total_modules_in_package": 16,
    "meaningful_modules": 16,
    "filtered_empty_modules": 0,
    "retention_rate": 1.0
  },
  "statistics": {
    "max_description_length": 757,
    "min_description_length": 277,
    "avg_description_length": 490.9375,
    "embedding_file_size_mb": 0.05855751037597656
  }
}