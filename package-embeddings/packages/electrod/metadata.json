{
  "package": "electrod",
  "embedding_model": "BAAI/bge-base-en-v1.5",
  "embedding_dimension": 1024,
  "total_modules": 72,
  "creation_timestamp": "2025-06-18T16:47:10.459034",
  "modules": [
    {
      "module_path": "Libelectrod.Intf.Print.Mixin",
      "description": "Provides pretty-printing for values of type `t` using the Fmtc formatting library. Operates on a single abstract type `t` representing some structured data. Used to generate human-readable representations during debugging or logging.",
      "description_length": 233,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Solver.LTL_from_Atomic.Infix",
      "description": "Provides atomic update operations for a stateful data structure, including lazy evaluation combinators for conditional and sequential updates. Works with a custom type `t` representing mutable state, supporting lazy transformations and chaining. Used to implement reactive updates in event-driven systems and manage state transitions with delayed execution.",
      "description_length": 357,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Msg.LoggingSetup.M",
      "description": "Provides logging functions for different severity levels, including error, warning, info, and debug, with support for formatted messages and error handling. Works with log levels, formatted message builders, and result types to handle success and error cases. Used to generate structured logs, handle failures gracefully, and inject custom error messages during result processing.",
      "description_length": 380,
      "index": 2,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libelectrod.Smv.Make_SMV_LTL.Infix",
      "description": "Provides atomic update operations for a stateful data structure, including lazy evaluation combinators for conditional and sequential updates. Works with a custom type `t` representing mutable state, supporting lazy transformations and chaining. Used to implement reactive updates in event-driven systems and manage state transitions with delayed evaluation.",
      "description_length": 358,
      "index": 3,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libelectrod.Smv.Make_SMV_file_format.Atomic",
      "description": "Provides operations to create and compare atomic propositions, including string-based comparison, equality checks, and hashing. Works with domain-specific types such as Domain.t, Name.t, and Tuple.t, and supports splitting atoms into their constituent parts. Used to parse and manipulate atomic expressions in logical or symbolic computation contexts.",
      "description_length": 351,
      "index": 4,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libelectrod.Smv.Make_SMV_file_format.Infix",
      "description": "Provides atomic update operations for a stateful data structure, including lazy evaluation combinators for conditional and sequential updates. Works with a custom type `t` representing mutable state, enabling chained transformations. Used to implement reactive updates in event-driven systems and manage state transitions with lazy dependencies.",
      "description_length": 345,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Elo_to_ltl1.Make.Atomic",
      "description": "Provides operations to create and compare atomic propositions, including string-based comparison, equality checks, and hashing. Works with domain, name, and tuple structures to represent and manipulate atomic entities. Used to parse and decompose atomic strings into their constituent parts, and to determine properties like constancy and partiality.",
      "description_length": 350,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Elo_to_ltl1.Make.Infix",
      "description": "Provides atomic update operations for a stateful data structure, including lazy evaluation combinators for conditional and sequential updates. Works with a custom type `t` representing mutable state, supporting lazy transformations and chaining. Used to implement reactive updates in event-driven systems and manage state transitions with delayed execution.",
      "description_length": 357,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Elo_to_smv1.SMV_LTL.Atomic",
      "description": "Provides operations to create and compare atomic expressions, check their properties, and split them into name and tuple components. Works with domain-specific types including domains, names, and tuples, and supports pretty-printing. Used to parse and analyze symbolic logic expressions in formal verification contexts.",
      "description_length": 319,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Elo_to_smv1.SMV_LTL.Infix",
      "description": "Provides atomic update operations for a stateful data structure, including lazy evaluation combinators for conditional and sequential updates. Works with a custom type `t` representing mutable state, supporting lazy transformations and chaining. Used to implement reactive updates in event-driven systems and manage state transitions with delayed execution.",
      "description_length": 357,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Elo_to_model1.Make.Atomic",
      "description": "Provides operations to create and compare atomic propositions, including string-based comparison, equality checks, and hashing. Works with domain, name, and tuple structures to represent and manipulate atomic entities. Used to parse and decompose atomic strings into their constituent parts and to determine properties like constancy and partiality.",
      "description_length": 349,
      "index": 10,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Elo_to_model1.Make.Infix",
      "description": "Provides atomic update operations for a stateful data structure, including lazy evaluation combinators for conditional and sequential updates. Works with a custom type `t` representing mutable state. Used to implement reactive data flows where state transitions depend on lazy evaluations of conditions or transformations.",
      "description_length": 322,
      "index": 11,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Intf.Print",
      "description": "Prints values of type `t` using a formatted output function and converts them to string representations. It supports custom formatting through the `Fmtc` module and is used to generate human-readable output for debugging or logging. This module is essential when integrating type-specific display logic into applications that require structured text output.",
      "description_length": 357,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Tuple.Set",
      "description": "This module offers standard set operations like membership checks, union, intersection, and difference, along with higher-order functions for iteration and transformation, working with sets of a generic type `elt`. It supports constructing sets from iterables, extracting elements via predicates, and converting sets to lists or strings, enabling tasks such as data filtering, aggregation, and serialization. Operations also include cardinality checks and ordered element traversal, suitable for scenarios requiring efficient set manipulation and query.",
      "description_length": 553,
      "index": 13,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Solver.LTL_from_Atomic",
      "description": "Provides operations to create and compare atomic propositions, including string-based comparison and hashing. Works with domain-specific types such as Name.t and Tuple.t, and supports splitting atomic representations into their constituent parts. Used to parse and analyze atomic propositions in formal verification contexts.",
      "description_length": 325,
      "index": 14,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Msg.LoggingSetup",
      "description": "defines logging functions for error, warning, info, and debug levels, supporting formatted messages and result-based error handling. It includes log level configuration, message formatting utilities, and mechanisms to inject custom error messages during processing. Users can generate structured logs, manage failure cases, and customize output based on severity. Examples include logging an error with a formatted message or handling a result by emitting an info log on success.",
      "description_length": 479,
      "index": 15,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libelectrod.Msg.Extract",
      "description": "Extracts lines from a string based on location information and splits strings into parts at a specified index. It operates on strings, locations, and tuples containing strings and lists of strings. Used to parse and segment source code or text data for analysis or transformation.",
      "description_length": 280,
      "index": 16,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Msg.Fatal",
      "description": "This module provides error handling and validation operations, focusing on reporting issues during parsing or type-checking and validating logical constraints. It works with identifiers, locations, parsed data structures, and strings to generate contextual error messages or validation outcomes. Use cases include diagnosing parser errors with positional context and ensuring semantic consistency in structured data.",
      "description_length": 416,
      "index": 17,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libelectrod.Msg.Warn",
      "description": "Provides functions to handle atom duplication, scope declaration checks, element duplication with precision, disjunction with single variables, and detection of spurious variables. Operates on types such as Atom.t, Raw_ident.t, and Fmtc.t. Used to enforce constraints during parsing and type checking in a compiler or static analysis tool.",
      "description_length": 339,
      "index": 18,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Smv.Make_SMV_LTL",
      "description": "Provides operations to create and compare atomic propositions, including string-based comparison and hashing. Works with domain-specific types representing names and tuples, supporting checks for constants and partial relations. Used to parse and analyze structured string representations of propositions and manage their internal state.",
      "description_length": 337,
      "index": 19,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Smv.Make_SMV_file_format",
      "description": "creates and manipulates atomic propositions and stateful updates, combining string-based comparisons, equality checks, and lazy evaluation for conditional state changes. It handles domain-specific types like Domain.t, Name.t, and Tuple.t, and supports splitting atoms and chaining state transformations. Users can parse logical expressions, compare atomic elements, and implement reactive state updates with lazy dependencies. Examples include analyzing symbolic expressions and managing dynamic state transitions in event-driven applications.",
      "description_length": 543,
      "index": 20,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Smv_trace_parser.Make",
      "description": "Provides operations for managing named configurations and their associated tuples, using an associative list mapping names to sets of tuples. Works with `Name.t` for identifiers and `Tuple_set.t` for grouped data structures. Used to define and retrieve build parameters in a structured, lookup-based manner.",
      "description_length": 307,
      "index": 21,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Fmtc.Dump",
      "description": "Formats OCaml values with structured, syntax-aware representations. Handles signals, Unicode characters, strings, pairs, options, results, lists, arrays, sequences, hash tables, queues, stacks, and custom record fields. Used to generate readable, consistent dumps of complex data structures for debugging or logging.",
      "description_length": 316,
      "index": 22,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Elo_to_ltl1.Make",
      "description": "Calculates bounds for an expression based on a given stack of values. It processes pairs of expressions and stacks, returning computed bounds structures. Used to analyze electrical circuit expressions during constraint propagation.",
      "description_length": 231,
      "index": 23,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Elo_to_smv1.SMV_atom",
      "description": "Provides operations to create and compare atomic propositions, including string-based comparison and hashing. Works with domain-specific types such as Domain.t, Name.t, and Tuple.t, and supports parsing from strings. Used to decompose atoms into their constituent name and tuple, and to determine properties like constness and partiality.",
      "description_length": 338,
      "index": 24,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Elo_to_smv1.SMV_LTL",
      "description": "manages symbolic logic expressions and state transitions through atomic operations, combining parsing, comparison, and transformation capabilities. It handles domain-specific types like domains, names, and tuples, along with a mutable state type `t` that supports lazy evaluation and sequencing. Users can construct and analyze logical atoms, split them into components, and apply conditional or sequential state updates. Examples include parsing logical formulas, checking atomic properties, and implementing delayed state changes in reactive systems.",
      "description_length": 552,
      "index": 25,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libelectrod.Elo_to_smv1.SMV_file_format",
      "description": "Generates and processes SMV model files using LTL formulas for initial states, invariants, transitions, and properties. Operates on iterated tuples of strings and LTL expressions, along with Elo.t for symbolic representations. Used to construct models for model checking, analyze verification outcomes, and pretty-print structured SMV content.",
      "description_length": 343,
      "index": 26,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Elo_to_smv1.Elo_to_SMV_LTL",
      "description": "Processes an expression and a stack to compute bounds for an expression, using a specific transformation logic. It operates on tuples containing an Elo expression and a stack structure from the Elo module. This function is used to analyze constraints in formal verification contexts, particularly when translating expressions into SMV-LTL representations.",
      "description_length": 355,
      "index": 27,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Elo_to_smv1.Elo_to_SMV_model",
      "description": "Converts Elo formulas and symmetry information into SMV_LTL formulas, handling both single states and temporal symmetries. Processes lists of formulas to separate invariants and non-invariants, and dualizes logical expressions for model checking. Works with Elo formulas, symmetry data, and SMV_LTL structures to generate model files.",
      "description_length": 334,
      "index": 28,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Elo_to_model1.Make",
      "description": "Creates a model from Elo, initial states, invariants, transitions, and a property, using specific LTL formulas and atomic propositions. Processes and analyzes model behavior by running a solver, generating output, and interpreting traces with an Electrod model. Formats model details for human-readable display with customizable margins.",
      "description_length": 337,
      "index": 29,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Name.Map",
      "description": "The module offers operations to manipulate ordered maps with key-value pairs, including adding/removing keys, merging, filtering, folding, and comparing maps, alongside transformations and ordered traversal. It handles duplicate keys by merging values via custom functions and supports sequences, lists, and iterators for efficient data processing, making it suitable for tasks like data aggregation, structured data manipulation, and ordered collection analysis.",
      "description_length": 463,
      "index": 30,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Solver.Atomic",
      "description": "Provides operations to create and compare atomic propositions, including string-based comparison, equality checks, and hashing. Works with domain, name, and tuple structures to represent and manipulate atomic entities. Used to parse and decompose atomic strings into their component parts, and to determine properties like constancy and partiality.",
      "description_length": 348,
      "index": 31,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libelectrod.Solver.Infix",
      "description": "Provides atomic update operations for a stateful data structure, including lazy evaluation combinators for conditional and sequential updates. Works with a custom type `t` representing mutable state. Enables efficient state transitions in event-driven or reactive programming scenarios.",
      "description_length": 286,
      "index": 32,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Ast",
      "description": "The module offers operations for substitution, pretty-printing, and traversal of logical formulas and expressions within a typed abstract syntax tree (AST), working with types such as `var`, `ident`, `goal`, `exp`, `fml`, and `iexp` to handle both propositional and integer-based constructs. It enables deep modifications of structured data through visitor patterns and renaming environments, supporting tasks like formal verification or theorem proving where precise manipulation of logical expressions is required.",
      "description_length": 516,
      "index": 33,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Atom",
      "description": "Creates atoms from strings or raw identifiers, with support for location tracking. Provides printing, hashing, comparison, and string conversion for atom values. Used to represent unique, immutable identifiers in parsing and abstract syntax tree construction.",
      "description_length": 259,
      "index": 34,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libelectrod.Domain",
      "description": "Provides operations to manage a mapping of relation names to their definitions, including adding, checking, and retrieving associations. Works with types like Name.t, Relation.t, Tuple_set.t, and association lists. Used to update domains based on instance data, generate atom sets, and perform renaming operations.",
      "description_length": 314,
      "index": 35,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Elo_to_ltl1",
      "description": "Converts expressions into bound structures using a stack-based approach, enabling analysis of electrical circuit constraints. Processes pairs of expressions and value stacks to compute lower and upper bounds. Supports detailed evaluation during constraint propagation by tracking variable ranges. Provides precise numerical limits for expressions under varying input conditions.",
      "description_length": 378,
      "index": 36,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Elo_to_ltl_intf",
      "description": "Converts an Elo formula into a string representation and an LTL formula, using a specific mapping from Elo's atomic propositions. Operates on Elo's formula type and custom atomic proposition type to generate LTL expressions. Used to translate temporal logic specifications from one formalism to another for verification tasks.",
      "description_length": 326,
      "index": 37,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libelectrod.Elo_to_model1",
      "description": "Converts Electrod models into a solver-compatible format by integrating Elo data with system behavior definitions. It supports constructing models using LTL formulas, atomic propositions, and trace analysis through a solver. Key operations include model creation, behavior simulation, and trace interpretation. Users can generate human-readable outputs with adjustable formatting options.",
      "description_length": 388,
      "index": 38,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Elo_to_smv1",
      "description": "combines atomic proposition handling, logical expression management, SMV model generation, constraint analysis, and formula conversion into a unified transformation pipeline. It works with types like Domain.t, Name.t, Tuple.t, and Elo.t, enabling operations such as parsing, comparison, decomposition, and state transition modeling. Users can generate SMV files with LTL properties, analyze expression bounds, and convert Elo formulas into checkable model representations. Examples include constructing reactive system models, verifying invariants, and translating symmetry-aware logical expressions.",
      "description_length": 600,
      "index": 39,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libelectrod.Exp_bounds",
      "description": "Computes must, may, and sup bounds for expressions using a domain and substitution tuples. Operates on expressions (Elo.exp) and lists of tuples (Tuple.t list). Used to analyze query expressions in database optimization contexts.",
      "description_length": 229,
      "index": 40,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libelectrod.Fmtc",
      "description": "Formats OCaml values with structured, syntax-aware representations, supporting signals, Unicode, strings, options, lists, and custom records. It provides dump and pretty-printing functions for complex data structures, enabling consistent formatting for debugging or logging. Operations include rendering values with precise control over layout and representation. Examples include dumping a list of options or formatting a custom record with nested fields.",
      "description_length": 456,
      "index": 41,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Instance",
      "description": "Manages a collection of named tuple sets, allowing addition, lookup, and renaming of bindings. Operates on `Name.t` keys and `Tuple_set.t` values, supporting conversion to lists and maps. Used to track fixed relational data during query processing or translation phases.",
      "description_length": 270,
      "index": 42,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Intf",
      "description": "Compares values of type t using a lexicographical ordering function and checks for equality between two t values. Works exclusively with the abstract type t, ensuring consistent comparison semantics. Used to implement custom ordering in sorted data structures and to validate identity in equality-sensitive operations.",
      "description_length": 318,
      "index": 43,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Invar_computation",
      "description": "Provides functions to manipulate and analyze invariant formulas in the Elo logic, including adding or removing top-level always operators. Works with Elo.fml and goal_color types to represent and classify formulas. Used to preprocess formulas for invariant checking and to determine formula properties during verification processes.",
      "description_length": 332,
      "index": 44,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Location",
      "description": "Provides operations to create and manipulate file location data, including extracting line and column numbers from start and end positions, merging locations, and converting to string representations. Works with Lexing.position data and a polymorphic located type that associates values with location information. Used to track source code ranges during parsing and error reporting.",
      "description_length": 382,
      "index": 45,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Msg",
      "description": "provides error reporting, logging, string manipulation, and validation capabilities for structured data processing. It supports formatted logging at various severity levels, line extraction from strings, and error generation with contextual information. Operations include parsing source code segments, handling atom and identifier constraints, and managing result-based error flows. Users can log structured messages, validate semantic rules, and extract text fragments for analysis.",
      "description_length": 484,
      "index": 46,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libelectrod.Name",
      "description": "manipulates ordered maps with key-value pairs, supporting addition, removal, merging, filtering, folding, and comparison, with custom handling of duplicates and support for sequences, lists, and iterators. it enables structured data manipulation, aggregation, and ordered traversal, allowing operations like combining maps with custom merge functions or extracting filtered subsets. examples include aggregating data from multiple sources or processing large datasets in a memory-efficient manner. the core data type is an ordered map, with operations that transform, analyze, and combine its contents.",
      "description_length": 602,
      "index": 47,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Outcome",
      "description": "Represents a result trace or absence, with operations to construct traces from state transitions and valuation data, and to check for loop presence. Works with valuation maps, state lists, and time spans to model system behavior. Used to track execution paths in verification tools and analyze loop conditions in state transitions.",
      "description_length": 331,
      "index": 48,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Parser",
      "description": "Parses input streams into structured data by recognizing tokens and organizing them into lists of raw elements, declarations, and paragraphs. It processes lexing buffers and token streams to construct hierarchical representations of problem definitions. Used to convert raw text input into a format suitable for further analysis or transformation.",
      "description_length": 347,
      "index": 49,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libelectrod.Parser_main",
      "description": "Processes input files or strings into a structured abstract syntax tree (AST) using defined parsing rules. Operates on raw string inputs and produces a typed AST representation. Used to convert user-provided problem descriptions into an internal format for further analysis or transformation.",
      "description_length": 292,
      "index": 50,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Raw",
      "description": "The module provides functions for constructing and manipulating abstract syntax tree (AST) elements, such as intervals, tuples, bounds, and scopes, which are used in formal specifications. It operates on identifiers, structured data like lists and pairs, and internal AST types to represent parsed domain-specific language components. These operations support tasks like constraint modeling and formal verification, where hierarchical data structures and symbolic representations are critical.",
      "description_length": 493,
      "index": 51,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Raw_ident",
      "description": "Creates identifiers with associated source positions, providing access to their base names and locations. Works with string-based names and lexical positions to track identifier origins. Used to represent and compare identifiers in parsed code structures.",
      "description_length": 255,
      "index": 52,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Raw_to_ast",
      "description": "Transfo applies a series of transformations to convert raw problem representations into structured ASTs with proper domain constraints. It operates on raw_problem records and Ast.t nodes, ensuring semantic consistency. This is used to validate and restructure input from external sources before further processing.",
      "description_length": 314,
      "index": 53,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libelectrod.Relation",
      "description": "Constructs and manipulates relational data structures with specific operations like arity retrieval, name extraction, and scope handling. Works with named relations, variable relations, and tuple sets to represent logical constraints and dependencies. Used to rename atoms and names in relations, and to serialize or display relation details for analysis.",
      "description_length": 355,
      "index": 54,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libelectrod.Scanner",
      "description": "Handles lexical scanning for OCaml code, processing input buffers to identify tokens such as identifiers, keywords, and punctuation. Operates on `Lexing.lexbuf` and returns `Parser.token` values, supporting nested comment handling and line-based scanning. Processes source files and inline strings, distinguishing between code and comments during parsing.",
      "description_length": 355,
      "index": 55,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Scope",
      "description": "Provides operations to create and manipulate relation scopes, including exact, partial, and total functions, and to compute bounds and inclusions. Works with tuple sets and relation types to represent and query relational constraints. Used to determine if a tuple set falls within a scope, infer relation arity, and generate human-readable representations.",
      "description_length": 356,
      "index": 56,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libelectrod.Scripts",
      "description": "Provides default script templates for model checking tools, including BMC-specific variants. Works with string data to generate preconfigured input scripts. Used to initialize verification processes with standardized command sequences for formal verification workflows.",
      "description_length": 269,
      "index": 57,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Shortnames",
      "description": "Generates compact representations of AST elements by replacing long identifiers with short, unique names based on a boolean flag. Operates on abstract syntax trees (Ast.t) and modifies node names during traversal. Used to minimize file size in code generation workflows by substituting verbose names with abbreviated forms.",
      "description_length": 323,
      "index": 58,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Smv",
      "description": "manages the creation, comparison, and manipulation of atomic propositions and stateful updates, using domain-specific types such as Domain.t, Name.t, and Tuple.t. It supports string-based comparisons, hashing, equality checks, and lazy evaluation for conditional state changes, enabling the parsing of logical expressions and dynamic state transitions. Operations include analyzing symbolic expressions, splitting atoms, and chaining transformations, with applications in event-driven systems and symbolic logic. Examples include managing reactive updates and evaluating partial relations within structured SMV file representations.",
      "description_length": 632,
      "index": 59,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Smv_trace_parser",
      "description": "Manages named configurations and their associated tuples through an associative list, enabling structured parameter storage and retrieval. It supports operations on `Name.t` identifiers and `Tuple_set.t` data groups, allowing for efficient configuration lookups and modifications. Users can define custom build parameters, query existing configurations, and manipulate tuple sets within a named context. This enables dynamic configuration handling in systems requiring parameterized execution paths.",
      "description_length": 499,
      "index": 60,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Smv_trace_scanner",
      "description": "Scans SMV trace files, parsing tokens such as variable assignments and state transitions using custom lexical analysis tables. It processes input through a lexer that returns parsed values like name-tuple pairs or tokens representing program states. The module supports direct lexical scanning and recursive parsing of trace data.",
      "description_length": 330,
      "index": 61,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Smv_trace_tokens",
      "description": "Provides functions to parse, filter, and analyze sequences of trace tokens, including extracting event timestamps and identifying state transitions. Works with a custom token type representing discrete events in a system trace. Used to process simulation logs for debugging and verification tasks.",
      "description_length": 297,
      "index": 62,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Solver",
      "description": "Provides operations to create and compare atomic propositions for LTL, including string-based comparison, hashing, and checking properties like constness or partiality. Works with domain-specific types such as Domain.t, Name.t, and Tuple.t to represent and manipulate logical atoms. Used to parse and analyze logical expressions by splitting strings into their component parts or extracting domain information.",
      "description_length": 410,
      "index": 63,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Symbol",
      "description": "Creates and manipulates hash-consed string representations, ensuring unique instances for identical values. Provides comparison, hashing, and string conversion operations for efficient equality checks and storage. Used to represent identifiers or tokens in parsers and compilers where uniqueness and performance are critical.",
      "description_length": 325,
      "index": 64,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Symmetry",
      "description": "Provides operations to construct, traverse, and modify symmetries based on name-tuple pairs. Works with lists of name-tuple associations and associative mappings for renaming atoms. Used to enforce consistent ordering in relational data during transformation pipelines.",
      "description_length": 269,
      "index": 65,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Transfo",
      "description": "Constructs and composes type-safe transformations between specific input and output types, allowing for named, reusable function mappings. Executes transformations by applying their underlying functions to input values, and manages collections of transformations with named lookups. Supports chaining of transformations and provides a default fallback in lists.",
      "description_length": 361,
      "index": 66,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Tuple",
      "description": "Provides set operations on tuples of atoms, including membership, union, intersection, and difference, with support for higher-order functions to process and transform elements. It handles generic element types, allowing construction from iterables, filtering via predicates, and conversion to lists or strings. Operations include cardinality checks and ordered traversal, enabling efficient data manipulation and serialization. Examples include filtering unique elements, combining sets, and generating string representations of tuple collections.",
      "description_length": 548,
      "index": 67,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Tuple_set",
      "description": "This module provides set-theoretic operations like union, intersection, and difference, along with relational manipulations such as join, projection, and transitive closure, tailored for structured data. It works with sets of tuples having consistent arity, enabling transformations like filtering, mapping, and renaming to support complex data processing. Use cases include database-like query operations, relational algebra implementations, and data normalization tasks requiring tuple-level precision.",
      "description_length": 504,
      "index": 68,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Var",
      "description": "Creates unique variable identifiers with optional location and separator settings, and supports comparison, formatting, and string conversion. Operates on a custom type `t` representing variable identifiers. Used to generate distinct variable names during formula manipulation or code generation.",
      "description_length": 296,
      "index": 69,
      "embedding_norm": 1.0
    },
    {
      "module_path": "electrod",
      "description": "Generates and translates logical models combining relational first-order logic and linear temporal logic into input formats for model-checking tools. Processes bounded domains and unbounded time structures to enable verification of complex system behaviors. Used to validate safety and liveness properties in formal analysis workflows.",
      "description_length": 335,
      "index": 70,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod",
      "description": "Provides a comprehensive framework for handling logical expressions, relational data, and abstract syntax trees through a unified set of operations. It manages types like `var`, `exp`, `fml`, `atom`, `Domain.t`, and `Tuple_set.t`, enabling tasks such as formula substitution, constraint analysis, and AST transformation. Examples include converting Elo formulas to LTL, generating SMV models, and analyzing expression bounds. It supports structured data manipulation, error reporting, and pretty-printing, facilitating formal verification and system modeling workflows.",
      "description_length": 569,
      "index": 71,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 89,
    "meaningful_modules": 72,
    "filtered_empty_modules": 17,
    "retention_rate": 0.8089887640449438
  },
  "statistics": {
    "max_description_length": 632,
    "min_description_length": 229,
    "avg_description_length": 372.72222222222223,
    "embedding_file_size_mb": 0.2548084259033203
  }
}