{
  "package": "electrod",
  "embedding_model": "Qwen/Qwen3-Embedding-0.6B",
  "embedding_dimension": 1024,
  "total_modules": 75,
  "creation_timestamp": "2025-07-15T23:18:14.693337",
  "modules": [
    {
      "module_path": "Libelectrod.Elo_to_smv1.SMV_LTL.Atomic",
      "library": "electrod.libelectrod",
      "description": "This module handles atomic propositions in the transformation of Electrod models to SMV models, providing operations to construct, compare, and deconstruct atomic terms. It works with domain values, names, and tuples to represent and manipulate atomic expressions used in model conversion. Functions like `make`, `split`, and `is_const` support precise mapping of Electrod atoms to SMV representations, ensuring correct encoding of model elements.",
      "description_length": 447,
      "index": 0,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libelectrod.Intf.Print.S",
      "library": "electrod.libelectrod",
      "description": "This module provides pretty-printing and string conversion for a type `t`. It includes functions `pp` for formatted output using the `Libelectrod.Fmtc` formatting combinators and `to_string` for direct string representation. Useful for debugging and logging structured values in a human-readable form.",
      "description_length": 301,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Intf.Print.Mixin",
      "library": "electrod.libelectrod",
      "description": "This module provides functions for converting values of type `M.t` to human-readable string representations. It includes `pp` for pretty-printing with formatting and `to_string` for direct conversion. Useful for debugging or logging structured data like expressions or configurations.",
      "description_length": 284,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Smv.Make_SMV_LTL.Infix",
      "library": "electrod.libelectrod",
      "description": "This module provides infix operators for constructing LTL formulas, including negation, lazy disjunction, lazy conjunction, implication, and biconditional. It operates on LTL formula terms represented by the type `t`, supporting the creation of complex temporal logic expressions from simpler components. These operators enable direct and readable composition of LTL properties for use in formal verification tasks such as model checking.",
      "description_length": 438,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Solver.LTL_from_Atomic.Infix",
      "library": "electrod.libelectrod",
      "description": "This module defines infix operators for constructing and manipulating LTL (Linear Temporal Logic) formulas from atomic propositions. It supports logical operations such as negation (`!!`), disjunction (`+||`), conjunction (`+&&`), implication (`@=>`), and bi-implication (`@<=>`), with lazy evaluation for right-hand side operands. These operations enable concise expression of temporal properties in model-checking tasks, such as specifying system behaviors over time in verification workflows.",
      "description_length": 495,
      "index": 4,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libelectrod.Elo_to_smv1.SMV_LTL.Infix",
      "library": "electrod.libelectrod",
      "description": "This module defines infix operators for constructing LTL formulas over SMV models, including logical negation `!!`, disjunction `+||`, conjunction `+&&`, implication `@=>`, and equivalence `@<=>`. It operates on values of type `SMV_LTL.t`, representing temporal logic expressions. These operators enable concise composition of LTL properties directly within SMV model transformations.",
      "description_length": 384,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Elo_to_smv1.Elo_to_SMV_model",
      "library": "electrod.libelectrod",
      "description": "This module transforms Electrod models into SMV models using LTL formulas and enumerations. It provides functions to convert symmetries into LTL formulas, split and dualize formulas, and generate SMV files. It operates on Electrod models, symmetries, and LTL formulas, targeting model checking tasks in formal verification.",
      "description_length": 323,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Elo_to_smv1.SMV_LTL",
      "library": "electrod.libelectrod",
      "description": "This module enables the construction and manipulation of SMV-LTL formulas through a domain-specific language integrating temporal logic and arithmetic operations. It supports temporal operators like `until`, `since`, and `eventually`, along with combinators such as `plus` and `count`, operating over a custom type for temporal expressions with lazy evaluation and iterators. The module facilitates model checking and translation of high-level specifications into SMV-compatible formalisms, leveraging enumerated types and transformations from Electrod models. Infix operators from the child module allow concise LTL formula composition, while atomic proposition handling ensures precise model conversion through functions like `make`, `split`, and `is_const`.",
      "description_length": 760,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Intf.COMPARE",
      "library": "electrod.libelectrod",
      "description": "Implements comparison logic for a specific type `t`, providing `compare` and `equal` functions. Used to define total ordering and equality checks directly on values of type `t`. Enables sorting, set operations, and key-based lookups in data structures like maps and sets.",
      "description_length": 271,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Solver.LTL-Infix",
      "library": "electrod.libelectrod",
      "description": "This module defines infix operators for constructing and manipulating LTL (Linear Temporal Logic) formulas. It provides logical negation `!!`, disjunction `+||`, conjunction `+&&`, implication `@=>`, and equivalence `@<=>` operations over values of type `t`, which represent LTL expressions. These operators enable concise, readable specification of temporal logic constraints directly within OCaml code, particularly when building model-checking queries or system properties.",
      "description_length": 476,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Msg.Extract",
      "library": "electrod.libelectrod",
      "description": "This module extracts source code fragments from a given location, splitting them into lines and formatting them for display, such as in error messages. It supports colored output through its `pp` function and can split strings at a specified position for highlighting specific parts of the source. Use cases include rendering contextual error snippets with context lines and a focused region, improving readability in diagnostic output.",
      "description_length": 436,
      "index": 10,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Msg.LoggingSetup",
      "library": "electrod.libelectrod",
      "description": "Sets up logging sources and leverages the `Logs` library to define typed logging functions (`debug`, `info`, `err`, `warn`) scoped to the `Libelectrod.Msg` module. It provides utilities like `kmsg` for conditional logging based on level and `on_error`/`on_error_msg` to handle and log result values with customizable output and error levels. This module is used to emit structured logs and handle error results with contextual messages in the `electrod` library.",
      "description_length": 462,
      "index": 11,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Msg.Fatal",
      "library": "electrod.libelectrod",
      "description": "This module provides functions to generate fatal error messages for critical semantic, syntactic, and solver-related issues encountered during formal verification. It operates on data structures like lexing buffers, identifiers, expressions, and atoms, using continuation-passing style to propagate errors with contextual information. These mechanisms are essential for halting execution when unrecoverable problems arise during parsing, type checking, or constraint solving in domain-specific workflows.",
      "description_length": 504,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Elo_to_smv1.SMV_file_format",
      "library": "electrod.libelectrod",
      "description": "This module defines the structure and operations for representing SMV models derived from Electrod specifications, including fields for initialization, invariants, transitions, and properties expressed in LTL. It works with Electrod models and LTL formulas, organizing them into named components for SMV output. It supports pretty-printing and analysis execution, enabling model checking workflows with specific SMV backend requirements.",
      "description_length": 437,
      "index": 13,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Elo_to_smv1.Elo_to_SMV_LTL",
      "library": "electrod.libelectrod",
      "description": "Transforms Electrod models into SMV models using enumerations, supporting LTL formula conversion. It processes atomic propositions, temporal logic expressions, and goals, generating SMV-compatible output. Used to encode Electrod specifications into SMV for model checking.",
      "description_length": 272,
      "index": 14,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Solver.ATOMIC_PROPOSITION",
      "library": "electrod.libelectrod",
      "description": "This module defines an abstract type for atomic propositions in linear temporal logic (LTL), supporting operations to construct, compare, and inspect propositions based on domain, name, and tuple values. It provides functions to check if a proposition is constant or partial, determine domain arity, and convert propositions to and from string representations. Use cases include modeling state conditions in model-checking and manipulating LTL formulas with precise atomic proposition handling.",
      "description_length": 494,
      "index": 15,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Elo_to_model1.Make",
      "library": "electrod.libelectrod",
      "description": "Implements conversion of Electrod symmetries and formulas into LTL expressions and solver-ready models. It processes Electrod's symmetry structures into state-specific or temporal LTL formulas, splits formulas into invariant and non-invariant components, and constructs solver models from Electrod input. Used to encode system symmetries into temporal logic constraints and generate verification models for bounded model checking.",
      "description_length": 430,
      "index": 16,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Solver.LTL-Atomic",
      "library": "electrod.libelectrod",
      "description": "This module represents atomic propositions in LTL formulas, providing operations to construct, compare, and inspect atoms based on their name, tuple, and domain. It supports data types such as strings, tuples, and domain-specific identifiers, with functions to split atoms into their components or check properties like constness and enumerability. Concrete use cases include parsing and manipulating atomic propositions during model checking, and extracting symbolic information from atom strings for analysis.",
      "description_length": 511,
      "index": 17,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libelectrod.Smv.Make_SMV_LTL",
      "library": "electrod.libelectrod",
      "description": "This module implements Linear Temporal Logic (LTL) over user-defined atomic propositions, providing temporal modalities like `X`, `U`, `G`, and derived constructs such as `since` and `triggered`, along with boolean and arithmetic operations. Formulas are represented as typed values with lazy evaluation, enabling efficient construction and manipulation of expressions for formal verification. The child module enhances formula composition with infix operators for negation, conjunction, disjunction, and implication, supporting readable expression of complex temporal properties. Together, they facilitate generating SMV-compatible constraints and pretty-printing formulas for model checking workflows.",
      "description_length": 703,
      "index": 18,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libelectrod.Solver.LTL_from_Atomic",
      "library": "electrod.libelectrod",
      "description": "This module builds an LTL implementation from atomic propositions, enabling the construction and manipulation of temporal formulas using logical connectives, temporal operators like `next`, `always`, and `until`, and arithmetic comparisons. It provides core data types for formulas and terms, with operations to combine, simplify, and evaluate expressions symbolically. The `Infix` submodule introduces intuitive operators such as `+&&` and `@=>` for compact formula syntax, supporting lazy evaluation in logical compositions. Examples include specifying system invariants with `always`, defining temporal sequences via `until`, and integrating with model-checkers to validate dynamic behavior against formal properties.",
      "description_length": 720,
      "index": 19,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Elo_to_ltl1.Make",
      "library": "electrod.libelectrod",
      "description": "This module converts Electrod specifications to LTL formulas, handling translation of expressions and formulas while managing tuple eligibility and domain constraints. It operates on Electrod's intermediate representation, including types like `TS.t`, `G.exp`, and `Elo.fml`, and produces LTL formulas and comments. Concrete use cases include compiling Electrod models into LTL for model checking and generating temporal logic constraints from system specifications.",
      "description_length": 466,
      "index": 20,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libelectrod.Solver.MODEL",
      "library": "electrod.libelectrod",
      "description": "This module defines a model structure for LTL-based verification, including initialization, invariant, and transition constraints. It supports creating and analyzing models with specific solver scripts, producing outcomes that capture verification results or errors. The model is used to generate temporary files for solver execution and interprets traces back into the original domain.",
      "description_length": 386,
      "index": 21,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libelectrod.Name.Map",
      "library": "electrod.libelectrod",
      "description": "This module implements associative maps with efficient key-based operations over ordered names, supporting insertion, deletion, and lookup alongside set-theoretic transformations like merging and filtering. It works with key-value pairs where keys are totally ordered `Libelectrod.Name.t` instances, enabling ordered traversal, extremal value retrieval, and value mapping with custom combinators. Typical applications include managing relational metadata, symbolic mappings requiring ordered iteration, and conflict-free value aggregation during key collisions.",
      "description_length": 561,
      "index": 22,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libelectrod.Elo_to_ltl_intf.S",
      "library": "electrod.libelectrod",
      "description": "This module implements a converter from Elo models to LTL formulas, providing the function `convert` that takes an Elo model and a formula, returning a string identifier paired with the corresponding LTL formula. It operates on the abstract types `atomic` and `ltl`, which represent atomic propositions and LTL expressions, respectively. A concrete use case is translating formal specifications expressed in an Elo model into LTL for use in model checking or verification workflows.",
      "description_length": 482,
      "index": 23,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Elo_to_smv1.SMV_atom",
      "library": "electrod.libelectrod",
      "description": "This module represents atomic propositions in SMV models derived from Electrod, supporting operations to construct, compare, and deconstruct atoms based on their name and tuple components. It provides functionality to check properties like constness, partiality, and enumerability, and includes utilities to convert atoms to strings or parse strings back into atom components. Use cases include generating SMV variable names from Electrod relations and handling atomic conditions in model transformations.",
      "description_length": 505,
      "index": 24,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Smv_trace_parser.Make",
      "library": "electrod.libelectrod",
      "description": "Parses SMV trace files into state sequences using a lexer function. It processes input through a Lexing.lexbuf to produce outcome states. This module is used to extract state transitions from model checker traces for analysis or visualization.",
      "description_length": 243,
      "index": 25,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Msg.Warn",
      "library": "electrod.libelectrod",
      "description": "This module defines warning messages for specific modeling issues in a formal specification system. It includes operations to report warnings about duplicate atoms in universes, empty scope declarations, duplicate elements in sets, disjunctions with a single variable, and spurious variables in expressions. These functions help catch logical inconsistencies and modeling mistakes during analysis or compilation of formal models.",
      "description_length": 429,
      "index": 26,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Smv.Make_SMV_file_format",
      "library": "electrod.libelectrod",
      "description": "This module generates and analyzes SMV file formats from Electrod models, translating LTL formulas into model constraints. It constructs SMV models using components like initial conditions, invariants, transitions, and properties, all expressed in LTL. The resulting models can be analyzed with an external solver, producing outcomes that are interpreted back into the Electrod domain.",
      "description_length": 385,
      "index": 27,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Intf.Print",
      "library": "electrod.libelectrod",
      "description": "This module handles string conversion and pretty-printing for interface descriptions, working with abstract syntax trees to produce human-readable output for debugging and documentation. It provides core operations like `pp` and `to_string` for types `t` and `M.t`, enabling formatted display and logging of structured values such as expressions and configurations. Submodules extend these capabilities to specific data types, ensuring consistent and readable output across different components. Example uses include pretty-printing interface signatures and converting complex values to strings for inspection.",
      "description_length": 610,
      "index": 28,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libelectrod.Solver.LTL",
      "library": "electrod.libelectrod",
      "description": "This module provides operations for constructing and manipulating Linear Temporal Logic (LTL) formulas extended with arithmetic and counting capabilities, including temporal operators (e.g., `X`, `F`, `",
      "description_length": 202,
      "index": 29,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Fmtc.Dump",
      "library": "electrod.libelectrod",
      "description": "This module provides formatters for inspecting OCaml values with minimal configuration, using default box structures and OCaml-like syntax. It supports standard types like lists, arrays, options, results, and records, along with custom formatting for fields and structured data. Use cases include debugging and logging structured data such as signal numbers, Unicode characters, and complex nested values.",
      "description_length": 405,
      "index": 30,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Smv_trace_parser",
      "library": "electrod.libelectrod",
      "description": "This module parses SMV trace files into sequences of states using a lexer, processing input through a `Lexing.lexbuf` to extract state transitions. It enables analysis or visualization of model checker traces by converting raw input into structured state data. Key operations include reading traces and transforming them into accessible state representations. For example, it can convert a model checker's output into a list of states for further processing or display.",
      "description_length": 469,
      "index": 31,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Symmetry",
      "library": "electrod.libelectrod",
      "description": "This module represents and manipulates symmetries as ordered relations between named tuples. It supports constructing symmetries from pairs of named tuples, folding over symmetry elements, and renaming atoms and names within symmetries. It is used to model structural equivalences in formal systems where relation ordering and renaming must be tracked precisely.",
      "description_length": 362,
      "index": 32,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libelectrod.Parser",
      "library": "electrod.libelectrod",
      "description": "This module defines a token type representing lexical elements of a formal specification language and provides a `parse_problem` function that processes lexed input into structured components of a problem, including urelements, declarations, and paragraphs. It operates on lexbuf input from the standard library and constructs raw abstract syntax trees for further processing. Concrete use cases include parsing input files or strings containing logical formulas and system constraints into a structured format for analysis or transformation.",
      "description_length": 542,
      "index": 33,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Parser_main",
      "library": "electrod.libelectrod",
      "description": "This module provides functions to parse input files or strings into a raw abstract syntax tree (AST) representation of a problem. It operates on string inputs and returns structured data of type `Libelectrod.Raw.raw_problem`. Use this module when you need to directly convert source code or configuration files into an intermediate form for further processing or analysis.",
      "description_length": 372,
      "index": 34,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libelectrod.Intf",
      "library": "electrod.libelectrod",
      "description": "This module provides foundational traits and mixins for implementing comparison and printing behaviors across diverse data structures. It defines core interfaces like `COMPARE` for total ordering and equality checks, and includes a `Print` submodule with operations such as `pp` and `to_string` for generating readable string representations. These tools enable sorting, set operations, and structured logging, supporting concrete use cases like defining comparison logic for custom types and pretty-printing abstract syntax trees or configuration values. Submodules extend these capabilities to specific data types, ensuring consistent behavior and output formatting across components.",
      "description_length": 686,
      "index": 35,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libelectrod.Location",
      "library": "electrod.libelectrod",
      "description": "This module represents and manipulates source code locations using line and column numbers, derived from Lexing.position values. It provides functions to construct, merge, and format locations, as well as extract line and column information for error reporting or source tracking. Concrete use cases include attaching positional data to abstract syntax tree nodes and printing diagnostic messages with precise file coordinates.",
      "description_length": 427,
      "index": 36,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libelectrod.Gen_goal",
      "library": "electrod.libelectrod",
      "description": "This module provides logical, temporal, and relational operations for constructing and manipulating abstract syntax trees parameterized by variable and label types, including primitives for expressions (e.g., constants, quantifiers, conditionals) and formulas (e.g., connectives, temporal operators). It supports domain-specific constraint specification through binding comprehensions, relational algebra operations, and polymorphic syntax tree transformations, with utilities for metadata extraction and human-readable formatting. Key use cases include formal verification, logical reasoning, and program analysis workflows requiring pre-inference AST manipulation.",
      "description_length": 666,
      "index": 37,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Elo_to_model1",
      "library": "electrod.libelectrod",
      "description": "This module converts Electrod models into solver-ready representations by translating symmetries and formulas into LTL expressions. It processes symmetry structures into state-specific or temporal LTL formulas, splits formulas into invariant and non-invariant parts, and constructs models suitable for bounded model checking. It enables encoding system symmetries as temporal constraints and generates verification models from Electrod input. For example, it can transform a symmetry over a set of states into an LTL invariant or split a temporal formula for incremental solving.",
      "description_length": 579,
      "index": 38,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Symbol",
      "library": "electrod.libelectrod",
      "description": "This module implements hash-consed symbols, providing efficient creation, comparison, and string conversion operations. It works with a private symbol type that ensures unique representation of strings through hash-consing. Concrete use cases include managing identifiers in compilers or symbolic representations where fast equality and lookup are critical.",
      "description_length": 357,
      "index": 39,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Msg",
      "library": "electrod.libelectrod",
      "description": "This module manages error handling and logging across a formal verification system, combining message generation, structured logging, and source rendering to produce informative diagnostics. It supports operations for emitting fatal errors, warnings, and debug logs, using message codes, log levels, and source locations to format output with context, including colored snippets and focused highlights. Submodules handle source fragment extraction, typed logging integration, semantic error propagation, and model-specific warnings, enabling use cases such as reporting parse errors with source context, logging solver failures, and flagging modeling inconsistencies in formal specifications.",
      "description_length": 692,
      "index": 40,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Exp_bounds",
      "library": "electrod.libelectrod",
      "description": "Computes must, may, and sup bounds for expressions in the abstract syntax tree, using a domain and substitution. Works with expressions, domains, and tuple sets to determine precise value constraints. Useful for static analysis tasks like determining possible values of variables under specific substitutions.",
      "description_length": 309,
      "index": 41,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Solver",
      "library": "electrod.libelectrod",
      "description": "This module abstracts LTL formulas and models for use with external model-checkers, offering core types for atomic propositions, logical expressions, and script handling. It supports construction and manipulation of temporal logic constraints through infix operators, proposition inspection, and model definitions that include invariants and transitions. Users can define properties like \"always (p @=> X q)\" using atomic propositions built from domains and names, then integrate with solvers via inline or file-based scripts. Submodules enhance this functionality with arithmetic extensions, formula simplification, and trace interpretation for verification workflows.",
      "description_length": 669,
      "index": 42,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Tuple_set",
      "library": "electrod.libelectrod",
      "description": "Supports set operations, transformations, and relational algebra on sets of tuples with fixed arity, including union, intersection, projection, transposition, and transitive closure. Enforces consistent tuple lengths within sets while enabling joins, filtering, and structural conversions. Applicable to data manipulation workflows, graph processing, and structured data serialization.",
      "description_length": 385,
      "index": 43,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Smv_trace_scanner",
      "library": "electrod.libelectrod",
      "description": "This module implements a lexer for parsing SMV trace files, primarily handling tokenization of input buffers using a custom lexing function. It processes strings into tokens representing variable names and tuple values, supporting the extraction of structured data from SMV traces. It is used to parse counterexample traces generated by model checkers like NuSMV for formal verification workflows.",
      "description_length": 397,
      "index": 44,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libelectrod.Invar_computation",
      "library": "electrod.libelectrod",
      "description": "This module classifies formulas into categories such as invariants, initial conditions, and transitions using the `goal_color` type. It provides operations to modify and analyze formula structure, including adding or removing top-level temporal operators. These functions are used during formula processing to determine how to handle different types of logical expressions in verification tasks.",
      "description_length": 395,
      "index": 45,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libelectrod.Smv",
      "library": "electrod.libelectrod",
      "description": "This module generates SMV models for formal verification, combining logical formula construction with file generation and analysis. It supports LTL over custom atomic propositions, offering temporal operators like `X`, `U`, and `G`, along with boolean and arithmetic operations, enabling precise specification of properties such as safety and liveness. The system translates these formulas into SMV constraints, building complete models with initial states, transitions, and invariants for analysis in tools like nuXmv. Users can export models, run bounded model checking, and interpret verification results directly within the workflow.",
      "description_length": 637,
      "index": 46,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Ast",
      "library": "electrod.libelectrod",
      "description": "This module provides utilities for constructing, transforming, and rendering abstract syntax trees representing logical and arithmetic expressions. It operates on algebraic data types encoding expressions (`exp`), formulas (`fml`), bindings, and primitives, supporting operations like variable substitution, renaming, and structural traversal via visitor patterns. These capabilities are used in formal verification workflows to manipulate quantified formulas, temporal logic operators, and set-based expressions during proof construction or model analysis.",
      "description_length": 557,
      "index": 47,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Name",
      "library": "electrod.libelectrod",
      "description": "This module manages named entities like relation names with typed values for reserved identifiers such as `univ` and `iden`, offering operations to create, compare, and format them. It supports mapping over ordered name keys and integrates with its child module that implements associative maps for efficient key-based insertion, deletion, and lookup. The combined functionality enables ordered traversal, merging, and filtering of key-value pairs, ideal for symbolic identifier management in formal logic or relational computations. Example uses include tracking relational metadata and aggregating values under name-based keys with custom merge strategies.",
      "description_length": 658,
      "index": 48,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Raw_to_ast",
      "library": "electrod.libelectrod",
      "description": "Converts raw abstract syntax trees into refined ASTs that conform to the Elo specification. Processes `Libelectrod.Raw.raw_problem` values into fully resolved `Libelectrod.Ast.t` structures. Used during parsing to ensure syntactic correctness and domain consistency of Electrod problems.",
      "description_length": 287,
      "index": 49,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Transfo",
      "library": "electrod.libelectrod",
      "description": "This module defines transformations as named functions converting values from one type to another. It supports composing transformations sequentially, retrieving them by name from lists, and handling identity transformations. Use cases include managing chains of data conversion routines, such as parsing and formatting operations, where individual steps must be referenced by name or composed dynamically.",
      "description_length": 406,
      "index": 50,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Elo_to_ltl_intf",
      "library": "electrod.libelectrod",
      "description": "This module defines an abstract interface for converting Elo models into LTL formulas, enabling formal verification tasks such as model checking. It includes operations to map state transitions and temporal properties from Elo into their LTL equivalents, working with abstract types representing Elo models and LTL formulas. The child module provides a concrete implementation with the `convert` function, which translates an Elo model and formula into a string-identified LTL expression, using the `atomic` and `ltl` types. This allows users to perform tasks like translating formal specifications into LTL for verification workflows.",
      "description_length": 635,
      "index": 51,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Scope",
      "library": "electrod.libelectrod",
      "description": "This module defines and manipulates relation scopes, which represent sets of tuples with optional lower and upper bounds. It supports operations to construct exact or inexact scopes, query inclusion, and retrieve must/may sets, working with tuple sets and relations that enforce domain arity constraints. Concrete use cases include modeling partial or total functions with specific domains and ranges, checking if a given tuple set fits within a scope, and renaming atoms within scopes.",
      "description_length": 486,
      "index": 52,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libelectrod.Elo_to_ltl1",
      "library": "electrod.libelectrod",
      "description": "This module converts symbolic execution traces into LTL formulas using lists of tuples as stack elements, ensuring unique variable substitutions and proper LTL formatting for model checking. It translates Electrod specifications by handling expressions, formulas, tuple eligibility, and domain constraints, operating on types like `TS.t`, `G.exp`, and `Elo.fml` to produce LTL formulas and comments. The conversion process supports compiling Electrod models into LTL for system verification and generating temporal constraints from high-level specifications. It integrates with LTL implementations to enable trace analysis and logical formula translation in model checking workflows.",
      "description_length": 683,
      "index": 53,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libelectrod.Outcome",
      "library": "electrod.libelectrod",
      "description": "This module represents and manipulates result traces for logical analysis, handling both the presence and absence of solutions. It defines states and valuations to model system behavior over time, supporting operations to construct and inspect traces with or without loops, and to format output in different representations. Concrete use cases include capturing SAT/UNSAT results from model checking, building state sequences with lasso structures, and printing analysis outcomes in XML or plain text.",
      "description_length": 501,
      "index": 54,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Ast_to_elo",
      "library": "electrod.libelectrod",
      "description": "This module converts abstract syntax trees (AST) from the `Libelectrod` library into a lower-level intermediate representation (E). It handles expressions, formulas, blocks, and goals, translating constructs like quantifiers, logical and arithmetic operators, and variable bindings. Use cases include compiling high-level specifications into a form suitable for analysis or code generation.",
      "description_length": 390,
      "index": 55,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Raw_ident",
      "library": "electrod.libelectrod",
      "description": "This module represents identifiers in raw abstract syntax trees, combining a string name with source code location information. It provides functions to create identifiers from lexing positions, access their name and location, compare names for equality, and format them for debugging. Concrete use cases include tracking variable names and their positions during parsing and error reporting in a compiler or interpreter.",
      "description_length": 421,
      "index": 56,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Instance",
      "library": "electrod.libelectrod",
      "description": "This module manages a mapping from names to fixed tuple sets, supporting operations to add, query, and transform these associations. It works with names, tuple sets, and maps, and allows renaming atoms and names within the structure. Use cases include representing static relational data and enabling transformations for translation or analysis tasks.",
      "description_length": 351,
      "index": 57,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Domain",
      "library": "electrod.libelectrod",
      "description": "This module manages a mapping of relation names to their declarations, supporting operations to add, query, and transform relations. It works with relation names, tuple sets, and domain structures to represent and manipulate relational domains. Concrete use cases include tracking relation arities, renaming atoms and relations, and synchronizing domains with instance data.",
      "description_length": 374,
      "index": 58,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Raw",
      "library": "electrod.libelectrod",
      "description": "This module defines low-level abstract syntax tree (AST) structures produced by the Electrod parser, including types for goals, blocks, problems, and paragraphs. It provides constructors for building raw expressions, bounds, scopes, and declarations, along with accessors like `decl_id` to extract identifier information. Concrete use cases include direct manipulation of parsed Electrod source code structures for analysis, transformation, or code generation tasks.",
      "description_length": 466,
      "index": 59,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Simplify2",
      "library": "electrod.libelectrod",
      "description": "This module transforms qualified relations into formulas using cardinality arguments, operating on abstract syntax trees. It provides a transformation function `transfo` and a `run` function to apply simplifications. Use it after arity checks to eliminate qualified relations in favor of cardinality-based expressions.",
      "description_length": 318,
      "index": 60,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Var",
      "library": "electrod.libelectrod",
      "description": "This module generates unique variable identifiers for use in symbolic formulas, ensuring freshness across different stages of processing. It supports operations to create, copy, and compare variables, as well as formatting and converting them to strings. Concrete use cases include managing variable naming in logical expressions and avoiding name collisions during formula transformations.",
      "description_length": 390,
      "index": 61,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Elo_to_smv1",
      "library": "electrod.libelectrod",
      "description": "This module transforms Electrod models into SMV models using enumerations and LTL formulas, converting symmetries and temporal expressions into SMV-compatible output for model checking. It provides core operations to process atomic propositions, split and dualize formulas, and generate structured SMV models with initialization, transitions, and LTL properties. The module includes a domain-specific language for building SMV-LTL formulas with temporal operators like `until` and `eventually`, along with arithmetic combinators such as `plus` and `count`. It supports pretty-printing, formula analysis, and direct model encoding, enabling verification workflows with tools like NuSMV through precise atomic proposition handling and enumerated type transformations.",
      "description_length": 765,
      "index": 62,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Fmtc",
      "library": "electrod.libelectrod",
      "description": "This module provides composable formatting combinators for structured data pretty-printing, with fine-grained control over layout, delimiters, and separators. It supports built-in types, result types, and low-level data like bytes and hex dumps, enabling use cases such as error messages, structured logging, and styled text output. A child module specializes in inspecting OCaml values with OCaml-like syntax, offering ready-to-use formatters for lists, records, and nested data, ideal for debugging and logging complex structures. Together, they allow both high-level composition and direct formatting of values with minimal setup.",
      "description_length": 633,
      "index": 63,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Scripts",
      "library": "electrod.libelectrod",
      "description": "Contains predefined script templates for interacting with nuXmv and nuSMV model checkers. Provides strings representing default verification scripts, including BMC (bounded model checking) variants. Useful for automating model checking workflows without manually writing script files.",
      "description_length": 284,
      "index": 64,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Tuple",
      "library": "electrod.libelectrod",
      "description": "This module provides tools for constructing, transforming, and manipulating tuples of atoms, with support for concatenation, splitting, renaming elements, and restructuring nested data through transposition and flattening. It includes a set module for managing collections of tuples, enabling efficient membership checks, uniqueness enforcement, and set operations. You can build a tuple from atoms, split it into components, rename elements dynamically, or transpose nested tuple structures for reorganization. The combination of direct tuple operations and set-based processing supports data transformation pipelines and iterative algorithms over structured atom sequences.",
      "description_length": 675,
      "index": 65,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libelectrod.Scanner",
      "library": "electrod.libelectrod",
      "description": "This module implements a lexer for parsing input text, providing entry points for scanning tokens, handling line and block comments, and managing lexing states. It operates on `Lexing.lexbuf` input buffers and returns tokens consumed by a parser, tracking positions and nested comment levels. Concrete use cases include reading source code from a string or buffer, skipping comments, and correctly reporting line numbers and positions during parsing.",
      "description_length": 450,
      "index": 66,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libelectrod.Relation",
      "library": "electrod.libelectrod",
      "description": "This module defines a type `t` representing relations, which can be either constants or variables with associated arity, scope, and optional fby scope. It provides operations to construct, compare, and inspect relations, including checking if a relation is a set, retrieving its name or scope, and renaming atoms or names within it. Concrete use cases include modeling logical relations in a solver, tracking variable dependencies with scopes, and serializing relation data for debugging or output.",
      "description_length": 498,
      "index": 67,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Elo",
      "library": "electrod.libelectrod",
      "description": "This module supports the creation and manipulation of logical formulas, temporal operators, and relational expressions over domains, instances, and symmetries, using structured types like goals, expressions, and bindings. It enables formal verification tasks such as model checking and temporal property specification, with integrated tools for constructing typed expressions, applying quantifiers or comparisons, and generating formatted output for debugging and documentation. Key operations include logical composition (e.g., conjunction, implication), relational transformations (e.g., union, transitive closure), and domain-specific integer or temporal expressions, all paired with pretty-printing functions for syntax trees.",
      "description_length": 730,
      "index": 68,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "Libelectrod.Smv_trace_tokens",
      "library": "electrod.libelectrod",
      "description": "This module defines a set of token types used to represent elements of an SMV trace, including boolean values, state markers, loop indicators, equality symbols, and atomic propositions composed of named tuples. It provides constructors and pattern-matching capabilities for parsing and analyzing SMV trace files. Concrete use cases include building lexers for model checker outputs and processing counterexample traces in formal verification workflows.",
      "description_length": 452,
      "index": 69,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Gen_goal_recursor",
      "library": "electrod.libelectrod",
      "description": "Handles recursive traversal and transformation of generic goal structures, specifically supporting the conversion of goals into linear temporal logic (LTL) formulas. Works with abstract syntax trees representing goals, enabling structured manipulation and analysis. Useful for implementing custom goal transformations or analyses that require deep access to goal structure.",
      "description_length": 373,
      "index": 70,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Shortnames",
      "library": "electrod.libelectrod",
      "description": "Transforms abstract syntax trees by renaming elements such as sets, relations, and atoms to shorter names. This reduces the size of generated output files. Useful when minimizing file size is a priority, such as in large-scale code generation or serialization.",
      "description_length": 260,
      "index": 71,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libelectrod.Simplify1",
      "library": "electrod.libelectrod",
      "description": "Simplifies Electrod models by generating fresh variables, creating associations between variables and expressions, and transforming formulas. It operates on abstract syntax trees (ASTs) and works with variables, expressions, and logical formulas. This module is used to reduce complex models into simpler forms, particularly after arity checking, by replacing or restructuring components like variable bindings and subformulas.",
      "description_length": 427,
      "index": 72,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Atom",
      "library": "electrod.libelectrod",
      "description": "This module represents atoms, or urelements, as a concrete data type `t` with operations for creation, comparison, and conversion. It supports creating atoms from strings or raw identifiers, and provides hashing, string conversion, and structured printing, including for lists of atoms. Use cases include modeling unique identifiers with optional source locations and managing symbolic names in formal systems.",
      "description_length": 410,
      "index": 73,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod",
      "library": "electrod.libelectrod",
      "description": "This module processes formal specifications and model checker outputs through a suite of tools for parsing, transforming, and analyzing logical and temporal structures. It centers around data types like `raw_problem`, `ast`, `symmetry`, `formula`, `trace`, and `LTL`, with operations for parsing SMV traces, constructing and manipulating logical expressions, managing symbol tables, and converting models into solver-ready formats. Users can parse an SMV trace into a sequence of states, transform an Electrod model into an LTL formula for verification, or simplify a logical expression by renaming variables and resolving symmetries.",
      "description_length": 634,
      "index": 74,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 89,
    "meaningful_modules": 75,
    "filtered_empty_modules": 14,
    "retention_rate": 0.8426966292134831
  },
  "statistics": {
    "max_description_length": 765,
    "min_description_length": 202,
    "avg_description_length": 470.4,
    "embedding_file_size_mb": 0.27285194396972656
  }
}