{
  "package": "electrod",
  "embedding_model": "Qwen/Qwen3-Embedding-8B",
  "embedding_dimension": 4096,
  "total_modules": 67,
  "creation_timestamp": "2025-08-15T15:18:58.567444",
  "modules": [
    {
      "module_path": "Libelectrod.Smv.Make_SMV_LTL.Infix",
      "library": "electrod.libelectrod",
      "description": "This module provides infix operators for constructing LTL formulas, including negation, disjunction, conjunction, implication, and equivalence. It operates on values of type `t`, representing atomic propositions or formulas in LTL. These operators enable concise expression of temporal logic constraints when generating SMV files for model checking.",
      "description_length": 349,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Elo_to_smv1.SMV_LTL.Atomic",
      "library": "electrod.libelectrod",
      "description": "This module represents atomic propositions in SMV/LTL formulas, constructed from domain elements, names, and tuples. It provides operations to create, compare, and deconstruct atoms, including checks for constancy, partiality, and arity. These atoms are used to encode Electrod model variables into SMV identifiers with tuple parameters for state encoding.",
      "description_length": 356,
      "index": 1,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libelectrod.Solver.LTL_from_Atomic.Infix",
      "library": "electrod.libelectrod",
      "description": "This module defines infix operators for constructing and manipulating LTL (Linear Temporal Logic) formulas from atomic propositions. It provides logical connectives such as negation (`!!`), disjunction (`+||`), conjunction (`+&&`), implication (`@=>`), and equivalence (`@<=>`) with lazy evaluation for some operands. These operations are used to build complex temporal logic expressions over a type `t` representing atomic propositions, enabling direct specification of temporal properties in model-checking tasks.",
      "description_length": 515,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Elo_to_smv1.SMV_LTL.Infix",
      "library": "electrod.libelectrod",
      "description": "This module defines infix operators for constructing LTL formulas over SMV models, including negation (`!!`), disjunction (`+||`), conjunction (`+&&`), implication (`@=>`), and equivalence (`@<=>`). It operates on values of type `SMV_LTL.t`, representing temporal logic expressions, and uses lazy evaluation for right-hand side operands where applicable. These operators enable concise expression of temporal properties during the translation of Electrod models to SMV for formal verification.",
      "description_length": 493,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Intf.Print.Mixin",
      "library": "electrod.libelectrod",
      "description": "This module provides a pretty-printing function `pp` and a `to_string` conversion for values of type `M.t`. It works directly with the data type exposed by the parameter module `M`. Use this to generate human-readable string representations of structured values from `M`, especially for debugging or logging specific data types like expressions or configurations.",
      "description_length": 363,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Msg.Extract",
      "library": "electrod.libelectrod",
      "description": "Extracts source code fragments from a file or string based on a given location, splitting the content into before, current, and after lines. Works with strings and location data to provide context around errors, suitable for generating detailed error messages with code snippets. Uses a formatter to display the extracted code with color support for improved readability in diagnostics.",
      "description_length": 386,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Elo_to_ltl1.Make",
      "library": "electrod.libelectrod",
      "description": "This module converts electrod specifications to LTL formulas, handling translation of expressions and formulas while managing domain and codomain constraints. It processes transition systems and goals to generate LTL representations, supporting tasks like computing transition system lengths and iterating over expression squares. Concrete use cases include formal verification of distributed protocols and model checking against temporal logic properties.",
      "description_length": 456,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Elo_to_smv1.Elo_to_SMV_model",
      "library": "electrod.libelectrod",
      "description": "This module transforms Electrod models into SMV models using LTL formulas and enumerations. It provides functions to convert symmetric and temporal expressions into LTL, split and dualize formulas, and generate SMV output with optional symmetry handling. It operates on Electrod formulas and symmetry structures, targeting SMV model generation for formal verification tasks.",
      "description_length": 374,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Smv_trace_parser.Make",
      "library": "electrod.libelectrod",
      "description": "Parses SMV trace files into state sequences using a lexer function. It processes input through a Lexing.lexbuf to extract tokens representing states, transitions, and variable assignments. This module is used to analyze model checker outputs by converting raw traces into structured state lists for further processing or visualization.",
      "description_length": 335,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Elo_to_model1.Make",
      "library": "electrod.libelectrod",
      "description": "This module converts Electrod models into LTL formulas with specific temporal and state-based symmetry encodings. It processes symmetries into LTL formulas under different conditions, splits and dualizes formulas based on invariance properties, and integrates comments into formula lists. It operates on Electrod models, symmetries, and LTL formulas, producing solver-compatible models as output.",
      "description_length": 396,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Name.Map",
      "library": "electrod.libelectrod",
      "description": "This module provides functional map operations for ordered key-value stores using `Libelectrod.Name.t` as keys, supporting safe and unsafe value access, ordered traversal, and transformations like `map`, `filter`, and `fold`. It handles maps with arbitrary value types, offering utilities for merging with customizable conflict resolution, converting from sequences/lists, and ordered key-based operations such as min/max retrieval and predicate-driven searches. Typical use cases include managing relational data structures, ordered key processing for deterministic traversal, and merging heterogeneous key-value collections with explicit conflict handling.",
      "description_length": 658,
      "index": 10,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libelectrod.Elo_to_smv1.SMV_atom",
      "library": "electrod.libelectrod",
      "description": "This module represents atomic propositions in SMV models derived from Electrod, supporting operations to construct, compare, and deconstruct atoms into their name and tuple components. It provides functionality to check properties like constness, partiality, and enumerability, and includes hashing and string-based comparison. Use cases include translating Electrod relations into SMV atoms, analyzing their structure, and generating SMV code fragments from them.",
      "description_length": 464,
      "index": 11,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Elo_to_smv1.SMV_file_format",
      "library": "electrod.libelectrod",
      "description": "Handles the formatting and printing of SMV model files derived from Electrod specifications. It manages the structure of SMV files with sections for initialization, invariants, transitions, and properties, each represented as LTL formulas. This module is used to generate readable SMV output for model checking tools like NuSMV, supporting optional BMC analysis and file persistence.",
      "description_length": 383,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Smv.Make_SMV_LTL",
      "library": "electrod.libelectrod",
      "description": "This module provides operations to construct and manipulate typed Linear Temporal Logic (LTL) formulas with temporal operators (e.g., `X`, `G`, `F`, `U`) and arithmetic expressions over terms. It works with LTL formulas of type `t`, atomic propositions from an external module, and numeric values via arithmetic operations like `plus`, `minus`, and comparisons. These capabilities are used to formalize temporal properties and numeric constraints for SMV model checking, enabling integration with solvers through human-readable formula serialization that captures variables and temporal structure.",
      "description_length": 597,
      "index": 13,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Msg.Warn",
      "library": "electrod.libelectrod",
      "description": "This module defines functions for emitting warnings related to duplicate atoms, empty scopes, duplicate elements in collections, disjunctions with only one variable, and spurious variables in logical expressions. It operates on data types such as `Libelectrod.Atom.t`, `Libelectrod.Raw_ident.t`, and formatted value types using `Libelectrod.Fmtc.t`. These warnings help catch modeling inconsistencies in formal verification tasks, such as unintended identifier reuse or malformed constraints.",
      "description_length": 492,
      "index": 14,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Elo_to_smv1.Elo_to_SMV_LTL",
      "library": "electrod.libelectrod",
      "description": "This module converts Electrod formulas into SMV-LTL representations, handling atomic propositions and temporal logic transformations. It processes Electrod expressions and goals, using helper functions like `eligible_pairs` and `compute_domain_codomain` to map relations and constraints. Concrete use cases include translating Electrod models into SMV for formal verification tasks such as model checking.",
      "description_length": 405,
      "index": 15,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libelectrod.Tuple.Set",
      "library": "electrod.libelectrod",
      "description": "This module provides set algebra operations (union, intersection, difference), predicate-based filtering, and ordered traversal over collections of tuples, with support for safe element retrieval and structural analysis. It works with sets of ordered elements, enabling conversions to and from lists, sequences, and iterators while offering utilities like cardinality tracking and custom formatting. These capabilities are particularly useful for tasks like processing ordered datasets, integrating with serialization pipelines, or implementing algorithms requiring precise set manipulations.",
      "description_length": 592,
      "index": 16,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Msg.Fatal",
      "library": "electrod.libelectrod",
      "description": "This module provides functions to handle fatal errors during parsing, type checking, and semantic analysis in a DSL, including lexical/syntax issues, identifier misuse, and solver-related failures. It operates on identifiers, expressions, parsing contexts, strings, optional strings, and raw identifiers, generating structured error messages with contextual details for scenarios like scope violations, incorrect symmetry definitions, and invalid multiplicity constraints. The errors are reported via callbacks that produce results after handling, ensuring precise diagnostic output for critical issues.",
      "description_length": 603,
      "index": 17,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Solver.LTL_from_Atomic",
      "library": "electrod.libelectrod",
      "description": "This module enables the construction and manipulation of Linear Temporal Logic (LTL) formulas from atomic propositions through logical connectives (e.g., `and`, `implies`) and temporal operators (e.g., `next`, `until`, `since`), including historical and triggered variants. It operates on a symbolic formula type `t` that represents LTL expressions as hierarchical compositions of atomic terms, boolean operations, and temporal semantics. Designed for symbolic model-checking workflows, it supports tasks like formal verification of temporal properties, declarative specification of system behaviors, and pretty-printing of formulas for debugging, with infix operators enabling concise expression syntax.",
      "description_length": 704,
      "index": 18,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Smv.Make_SMV_file_format",
      "library": "electrod.libelectrod",
      "description": "This module constructs and analyzes SMV models from Electrod specifications, translating them into files consumable by model checkers. It supports creating SMV representations with initial conditions, invariants, transitions, and properties, and runs verification tools against them. It outputs analysis results, including errors or traces, based on the provided Electrod model and solver configuration.",
      "description_length": 403,
      "index": 19,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libelectrod.Elo_to_smv1.SMV_LTL",
      "library": "electrod.libelectrod",
      "description": "This module suite enables constructing and transforming Linear Temporal Logic (LTL) formulas with logical connectives (conjunction, implication), temporal operators (next, until, since, always), and arithmetic operations (addition, comparison, counting) over terms. It operates on specialized types representing LTL expressions (`t`) and terms, supporting lazy evaluation and syntactic sugar for infix notation. These capabilities are used to translate Electrod models into SMV-compatible verification conditions, generate temporal logic constraints for model checking, and produce human-readable LTL representations with variable tracking for debugging.",
      "description_length": 654,
      "index": 20,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Fmtc.Dump",
      "library": "electrod.libelectrod",
      "description": "This module defines formatters for inspecting OCaml values using predefined formatting rules that align with OCaml syntax. It supports standard types like `option`, `result`, `list`, `array`, `hashtbl`, `queue`, and `stack`, as well as record-like structures through `field` and `record`. Use cases include debugging and logging structured data with human-readable representations.",
      "description_length": 381,
      "index": 21,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libelectrod.Intf.Print",
      "library": "electrod.libelectrod",
      "description": "This module implements pretty-printing and string conversion for structured values from a parameter module `M`. It provides `pp` for formatting and `to_string` for direct conversion, targeting data types like expressions or configurations. Useful for debugging or logging specific structured data.",
      "description_length": 297,
      "index": 22,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Msg.LoggingSetup",
      "library": "electrod.libelectrod",
      "description": "Initializes and configures logging for the Electrod library using the `Logs` module. It defines specific logging functions (`debug`, `info`, `err`, `warn`) and utilities like `on_error` and `on_error_msg` to handle and format error results. This module is used to emit structured logs and handle errors with custom formatting and severity levels during library execution.",
      "description_length": 371,
      "index": 23,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Elo_to_model1",
      "library": "electrod.libelectrod",
      "description": "Converts Electrod models into a format suitable for solver input, handling the translation of model components like variables and constraints. Operates on Electrod's abstract syntax tree and produces a simplified intermediate representation used by the solver. Useful for integrating Electrod-based specifications with constraint-solving workflows.",
      "description_length": 348,
      "index": 24,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Location",
      "library": "electrod.libelectrod",
      "description": "This module represents and manipulates source code locations using line and column numbers, built from Lexing.position values. It provides functions to construct, merge, and format locations, as well as extract line and column data. Use cases include tracking identifier positions in a parser or reporting error spans in a compiler frontend.",
      "description_length": 341,
      "index": 25,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Gen_goal_recursor",
      "library": "electrod.libelectrod",
      "description": "Traverses and transforms generic goal structures by recursively applying functions to their components. Works with abstract syntax trees representing logical goals, particularly those used in formal verification contexts. Enables systematic rewriting or analysis of goal expressions for tasks like LTL conversion.",
      "description_length": 313,
      "index": 26,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libelectrod.Intf",
      "library": "electrod.libelectrod",
      "description": "This module includes a `Print` submodule that implements pretty-printing and string conversion for structured data types such as expressions or configurations. It provides the `pp` function for formatting and `to_string` for direct conversion, specifically targeting data types from a parameter module `M`. These operations are particularly useful for debugging or logging structured values in a readable format.",
      "description_length": 412,
      "index": 27,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libelectrod.Ast",
      "library": "electrod.libelectrod",
      "description": "The module provides operations for constructing, transforming, and analyzing abstract syntax trees through substitution, renaming, equality checks, and pretty-printing of logical and arithmetic constructs. It works with structured data involving variables, identifiers, expressions, formulas, bindings, and goals, which encapsulate domains, instances, and symmetry information. These utilities are used for manipulating relational expressions, normalizing logic formulae, and generating human-readable representations during compilation or analysis tasks.",
      "description_length": 555,
      "index": 28,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Var",
      "library": "electrod.libelectrod",
      "description": "This module generates and manages fresh variable identifiers with support for custom separators and source locations. It provides operations to create fresh variables from strings or raw identifiers, compare and check equality between variables, and format or convert variables to strings. Concrete use cases include generating unique variable names during formula transformations and tracking variable origins in parsing or compilation stages.",
      "description_length": 444,
      "index": 29,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libelectrod.Ast_to_elo",
      "library": "electrod.libelectrod",
      "description": "This module translates abstract syntax trees from the `Libelectrod` library into a lower-level intermediate representation used for further processing or execution. It handles expressions, logical formulas, quantifiers, operators, and variable bindings, converting them from their parsed forms into simplified structures defined in the `E` module. Concrete use cases include compiling high-level logic expressions into a format suitable for model checking or symbolic evaluation.",
      "description_length": 479,
      "index": 30,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Elo_to_ltl1",
      "library": "electrod.libelectrod",
      "description": "This module converts electrod specifications to LTL formulas, translating expressions and formulas while enforcing domain and codomain constraints. It processes transition systems and goals to produce LTL representations, supporting tasks such as computing transition system lengths and iterating over expression squares. Use cases include formal verification of distributed protocols and model checking against temporal logic properties.",
      "description_length": 438,
      "index": 31,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Scope",
      "library": "electrod.libelectrod",
      "description": "This module defines operations for managing relation scopes, including constructing exact or inexact scopes using tuple sets and functions with domain arities. It provides functions to check inclusion, equality, and partiality, as well as to retrieve bounds (inf, sup, must, may) and inferred arity. Use cases include representing and manipulating scoped relations in a formal verification or constraint-solving context.",
      "description_length": 420,
      "index": 32,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Simplify1",
      "library": "electrod.libelectrod",
      "description": "Simplifies Electrod models by creating fresh variables, generating associated expression lists, and transforming formulas. It operates on Electrod AST structures, variable lists, and logical expressions, producing updated variable mappings and simplified logical constraints. Used during model preprocessing to eliminate redundancies and prepare for further analysis steps.",
      "description_length": 373,
      "index": 33,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Parser",
      "library": "electrod.libelectrod",
      "description": "This module defines a token type representing lexical elements of a formal specification language and provides a `parse_problem` function that processes lexed input into structured components of a problem, including urelements, declarations, and paragraphs. It operates on lex buffers and uses a custom token stream to build abstract syntax representations. Concrete use cases include parsing input files or strings containing logical formulas, temporal operators, and system constraints into an intermediate representation for further analysis or verification.",
      "description_length": 561,
      "index": 34,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Smv",
      "library": "electrod.libelectrod",
      "description": "This module generates SMV files and associated scripts for model checking, supporting both nuXmv and nuSMV solvers. It provides default script templates for bounded and unbounded model checking and includes submodules for constructing LTL formulas with temporal and arithmetic operators, as well as for translating Electrod specifications into SMV models with initial states, transitions, and properties. It is used to serialize formal specifications into solver-ready SMV files and to execute model checking workflows with error trace generation.",
      "description_length": 547,
      "index": 35,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Elo_to_ltl_intf",
      "library": "electrod.libelectrod",
      "description": "This module defines an abstract interface for converting Elo models into LTL (Linear Temporal Logic) formulas. It includes operations to map state transitions and temporal properties from an Elo model into corresponding LTL expressions. It is used when implementing model checkers or translators that require expressing system behaviors in temporal logic.",
      "description_length": 355,
      "index": 36,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Msg",
      "library": "electrod.libelectrod",
      "description": "Handles error messaging, logging, and source code extraction for diagnostics. Provides structured error and warning handling with contextual details for critical issues and modeling inconsistencies. Supports logging configuration, source fragment extraction, and formatted error codes for precise diagnostic output in formal verification tasks.",
      "description_length": 344,
      "index": 37,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Raw_ident",
      "library": "electrod.libelectrod",
      "description": "This module represents identifiers in raw abstract syntax trees, combining a string name with location information from the parser. It provides functions to create identifiers with source positions, access their name and location, and compare or print them. Concrete use cases include tracking variable names and their positions in parsed code for error reporting or analysis.",
      "description_length": 376,
      "index": 38,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Smv_trace_parser",
      "library": "electrod.libelectrod",
      "description": "Parses SMV trace files into structured sequences of states and transitions by processing input through a lexer buffer. It extracts tokens representing variable assignments and state changes, organizing them into a list-based structure for analysis. Used to transform raw model checker output into a navigable state list for debugging or visualization tools.",
      "description_length": 357,
      "index": 39,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Gen_goal",
      "library": "electrod.libelectrod",
      "description": "This module provides functions for constructing and manipulating logical, relational, and arithmetic expressions in abstract syntax trees (ASTs), including quantifiers, temporal operators (e.g., \"until,\" \"always\"), and structured operations like bindings, conditionals, and closures. It operates on polymorphic expression (`exp`, `fml`, `iexp`) and primitive syntax types (`prim_exp`, `prim_iexp`), supporting both concrete and abstract representations prior to De Bruijn index inference. Key use cases include pre-inference processing of goal specifications with logical connectives, comparison operators, and pretty-printing of formatted output for debugging or structured display.",
      "description_length": 683,
      "index": 40,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Scripts",
      "library": "electrod.libelectrod",
      "description": "This module provides predefined script strings for interacting with nuXmv and nuSMV model checkers, specifically for generating default command sequences. It includes scripts for both standard and bounded model checking (BMC) workflows. These constants are used directly in tool integrations to automate model verification tasks without requiring manual script construction.",
      "description_length": 374,
      "index": 41,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Symmetry",
      "library": "electrod.libelectrod",
      "description": "This module defines and manipulates symmetries as ordered relations between named tuples. It supports constructing symmetries from pairs of named tuples, folding over symmetry elements, and renaming atoms and names within symmetries. It is used to represent and transform structural equivalences in symbolic models.",
      "description_length": 315,
      "index": 42,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libelectrod.Smv_trace_tokens",
      "library": "electrod.libelectrod",
      "description": "This module defines a set of token types used to represent elements of an SMV trace, including boolean values, state markers, loop indicators, equality, and atomic propositions composed of names and tuples. It provides functions for parsing and manipulating these tokens, enabling analysis of model checker output. Concrete use cases include extracting state transitions, detecting loops, and evaluating atomic conditions in formal verification workflows.",
      "description_length": 455,
      "index": 43,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Simplify2",
      "library": "electrod.libelectrod",
      "description": "This module transforms logical expressions by replacing qualified relations with equivalent formulas based on cardinality constraints. It operates on abstract syntax trees representing logical goals and expressions, using variable binding and cardinality reasoning. It is used to simplify complex relational expressions into forms that can be more efficiently evaluated or analyzed.",
      "description_length": 382,
      "index": 44,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Symbol",
      "library": "electrod.libelectrod",
      "description": "This module implements hash-consed symbols, providing efficient creation, comparison, and string conversion operations. It works with a private symbol type that ensures canonical representation of strings. Useful for scenarios requiring fast equality checks and memory-efficient string interning, such as compiler symbol tables or identifier management in formal verification tools.",
      "description_length": 382,
      "index": 45,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Instance",
      "library": "electrod.libelectrod",
      "description": "This module manages a mapping from names to fixed tuple sets, supporting operations to add, query, and transform associations. It works with names, tuple sets, and atom mappings, enabling instance manipulation for formal modeling tasks. Use it to construct and modify relational instances in a scoped environment, such as during translation or evaluation of logical expressions.",
      "description_length": 378,
      "index": 46,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Elo_to_smv1",
      "library": "electrod.libelectrod",
      "description": "This module transforms Electrod models into SMV models using enumerations where possible. It includes submodules for handling atomic propositions, LTL formulas, file formatting, and translation logic. Key operations include converting Electrod expressions into SMV-LTL, generating SMV file structures, and producing model checking output for tools like NuSMV.",
      "description_length": 359,
      "index": 47,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libelectrod.Name",
      "library": "electrod.libelectrod",
      "description": "This module implements typed names used to identify entities like relations, with operations for creating named values from strings or raw identifiers, comparing and hashing names, and converting to strings or formatted output. It defines specific reserved names like `univ` and `iden`, and provides equality and ordering functions for name manipulation. Concrete use cases include managing symbolic identifiers in relational algebra computations and ensuring consistent name handling in data structure construction and comparison.",
      "description_length": 531,
      "index": 48,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Raw",
      "library": "electrod.libelectrod",
      "description": "This module defines low-level abstract syntax tree (AST) structures produced by the Electrod parser, including types for goals, blocks, problems, and paragraphs. It provides constructors for building raw expressions, bounds, scopes, and declarations, along with accessors like `decl_id` to retrieve identifiers from declarations. Concrete use cases include parsing and manipulating Electrod source files into structured ASTs for further analysis or transformation.",
      "description_length": 464,
      "index": 49,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Relation",
      "library": "electrod.libelectrod",
      "description": "This module defines and manipulates relations, which can be either constant or variable, with a fixed arity and scope. It provides operations to construct, compare, and inspect relations, including checking if a relation is a set, retrieving its name and scope, and renaming atoms or names within the relation. Concrete use cases include modeling logical relations in formal verification, tracking variable dependencies with optional `fby` scopes, and serializing relations for debugging or output.",
      "description_length": 498,
      "index": 50,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Scanner",
      "library": "electrod.libelectrod",
      "description": "This module implements a lexer for parsing input into tokens, handling both standard input and string-based sources. It processes character streams using lexing tables and recursive lexing functions to identify tokens, while managing line comments and nested comments during lexical analysis. Concrete use cases include reading and tokenizing source code files or string inputs for further parsing by a compiler or interpreter.",
      "description_length": 427,
      "index": 51,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Atom",
      "library": "electrod.libelectrod",
      "description": "This module represents atoms, or urelements, as opaque values with associated names and optional locations. It provides operations to create atoms from strings or raw identifiers, compare and hash them, and convert them to strings or formatted output. Use cases include representing unique identifiers in symbolic computations and tracking source locations during parsing or analysis.",
      "description_length": 384,
      "index": 52,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libelectrod.Elo",
      "library": "electrod.libelectrod",
      "description": "This module provides operations for constructing temporal logic expressions, relational algebra, and arithmetic manipulations over symbolic representations. It works with typed expressions (`exp`, `iexp`) and formulas (`fml`) to model constraints, quantify variables, and define logical or temporal relationships (e.g., *eventually*, *always*). The design supports formal verification tasks, such as specifying system invariants or temporal properties, and enables modeling relational data with operations like transitive closure, cardinality constraints, or set comparisons.",
      "description_length": 575,
      "index": 53,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libelectrod.Tuple",
      "library": "electrod.libelectrod",
      "description": "This module provides functions for constructing and manipulating tuples of atoms through operations like concatenation, splitting, element extraction, and uniqueness checks, alongside set algebra (union, intersection) for ordered tuple collections. It operates on tuples of `Libelectrod.Atom.t` and supports conversions to lists, sequences, and custom-formatted strings, with the `Set` submodule enabling ordered traversal and cardinality tracking. These capabilities are ideal for structured data serialization, combinatorial analysis, and managing tuple-based relationships requiring precise set operations or hierarchical transformations.",
      "description_length": 641,
      "index": 54,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Smv_trace_scanner",
      "library": "electrod.libelectrod",
      "description": "This module implements a lexer for parsing SMV trace files, primarily handling tokenization of input buffers. It processes strings into tokens representing names and tuples, using a lexical analysis engine. The module is used to extract structured data from SMV traces, such as variable assignments and state transitions, for further processing in model checking workflows.",
      "description_length": 373,
      "index": 55,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Transfo",
      "library": "electrod.libelectrod",
      "description": "This module defines transformations as named functions converting values from one type to another. It supports composing transformations left-to-right, retrieving transformations by name, and defining lists of transformations with a default. Use it to build, name, and chain input-output transformations, or select specific ones from a list by name.",
      "description_length": 349,
      "index": 56,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Solver",
      "library": "electrod.libelectrod",
      "description": "This module enables the construction and manipulation of Linear Temporal Logic (LTL) formulas from atomic propositions using logical connectives and temporal operators such as `next`, `until`, and `since`. It works with a symbolic formula type `t` that represents LTL expressions hierarchically, supporting formal verification tasks and declarative specification of system behaviors. Concrete use cases include verifying temporal properties in model-checking workflows and generating readable LTL expressions for debugging.",
      "description_length": 523,
      "index": 57,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Shortnames",
      "library": "electrod.libelectrod",
      "description": "Transforms abstract syntax trees by renaming sets, relations, and atoms to shorter names, reducing the size of generated output. Works directly with boolean flags and AST structures from the Libelectrod module. Useful when minimizing file size is a priority, such as in serialization or storage-constrained environments.",
      "description_length": 320,
      "index": 58,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Invar_computation",
      "library": "electrod.libelectrod",
      "description": "This module sorts formulas into categories like invariants, initial conditions, and transitions using the `goal_color` type. It provides operations to modify and classify formulas, such as adding or removing top-level always operators and determining formula color. It is used to process and categorize temporal logic formulas in verification tasks.",
      "description_length": 349,
      "index": 59,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Raw_to_ast",
      "library": "electrod.libelectrod",
      "description": "Converts raw abstract syntax trees into refined ASTs that conform to the Elo specification. Processes `Libelectrod.Raw.raw_problem` values into fully resolved `Libelectrod.Ast.t` structures. Used during parsing to ensure input matches the expected internal representation for further analysis.",
      "description_length": 293,
      "index": 60,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Domain",
      "library": "electrod.libelectrod",
      "description": "This module manages relation declarations, providing operations to add, check, and retrieve relations by name, along with access to their associated tuple sets. It supports transformations like renaming atoms and relations, updating relations from an instance, and extracting metadata such as arities and \"must\" sets. Concrete use cases include building and modifying relational domains for formal verification tasks, where precise control over relation scopes and mappings is required.",
      "description_length": 486,
      "index": 61,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Outcome",
      "library": "electrod.libelectrod",
      "description": "This module represents and manipulates result traces for analysis outcomes, particularly handling the presence or absence of a trace, trace construction with valuations and states, and time tracking for conversion and analysis phases. It works with valuations as association lists of names to tuple sets, states that can be plain or loop states, and optional lists of states representing traces. Concrete use cases include constructing a trace from a valuation and transition data, checking for loops in a trace, and formatting outcome data in XML, plain, or chronological formats.",
      "description_length": 581,
      "index": 62,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libelectrod.Exp_bounds",
      "library": "electrod.libelectrod",
      "description": "Computes must, may, and sup bounds for expressions in the abstract syntax tree, using a domain and substitution. Works with expressions, domains, and tuple sets to determine precise and approximate value ranges. Useful for static analysis tasks like identifying possible and necessary values in a database query.",
      "description_length": 312,
      "index": 63,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Parser_main",
      "library": "electrod.libelectrod",
      "description": "Parses input files or strings into a raw abstract syntax tree (AST) using the defined grammar. Works directly with strings and file paths, producing a `raw_problem` structure that represents the unprocessed syntax of the input. Useful for loading and initial processing of source code into a structured format for further analysis or transformation.",
      "description_length": 349,
      "index": 64,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libelectrod.Tuple_set",
      "library": "electrod.libelectrod",
      "description": "This module supports set operations like union, intersection, and product, alongside advanced manipulations such as joins, transitive closures, and diagonal extraction, with transformations including filtering, mapping, and renaming. It operates on sets of tuples with uniform arity, enabling conversions to lists, iterators, and customizable string formats. Applications include relational data processing, graph traversal, and structured data analysis.",
      "description_length": 454,
      "index": 65,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libelectrod",
      "library": "electrod.libelectrod",
      "description": "This module provides operations for parsing, transforming, and analyzing formal specifications in relational logic and temporal frameworks, supporting tasks like substitution, renaming, bound computation, and translation to intermediate representations (e.g., LTL, SMV). It operates on abstract syntax trees, atoms, identifiers, tuples, and symbolic variables, while integrating with model checkers and trace-processing tools. Key use cases include formal verification pipelines, symbolic reasoning for temporal properties, and automated analysis of relational models with symmetry reductions or scope-based simplifications.",
      "description_length": 624,
      "index": 66,
      "embedding_norm": 0.9999999403953552
    }
  ],
  "filtering": {
    "total_modules_in_package": 81,
    "meaningful_modules": 67,
    "filtered_empty_modules": 14,
    "retention_rate": 0.8271604938271605
  },
  "statistics": {
    "max_description_length": 704,
    "min_description_length": 293,
    "avg_description_length": 441.05970149253733,
    "embedding_file_size_mb": 0.971318244934082
  }
}