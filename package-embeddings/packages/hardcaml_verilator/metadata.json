{
  "package": "hardcaml_verilator",
  "embedding_model": "Qwen/Qwen3-Embedding-8B",
  "embedding_dimension": 4096,
  "total_modules": 9,
  "creation_timestamp": "2025-08-14T23:07:33.462644",
  "modules": [
    {
      "module_path": "Hardcaml_verilator.With_interface",
      "library": "hardcaml_verilator",
      "description": "This module compiles a Hardcaml circuit to a Verilator-based shared library and provides simulation bindings. It generates Verilog, wraps and compiles the Verilator output, and dynamically loads the resulting shared object to create a cyclesim instance with direct access to simulation state. Use it to accelerate simulation of large Hardcaml designs with Verilator while retaining interface-level compatibility with standard Hardcaml testbenches.",
      "description_length": 447,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_verilator.Output_split",
      "library": "hardcaml_verilator",
      "description": "This module configures and manages output splitting options for Verilator simulations, specifically controlling how large Verilog files are split into smaller files and functions during generation. It works with simulation configuration data types to optimize compilation and simulation performance for large circuits. Use this module to adjust splitting parameters when generating Verilator-based simulators for designs with thousands of lines of Verilog.",
      "description_length": 456,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_verilator.Optimization_level",
      "library": "hardcaml_verilator",
      "description": "This module defines optimization levels for Verilator compilation in Hardcaml simulations, supporting options O0 through O3. It provides functions to convert these levels to strings, S-expressions, and command-line flags, as well as to retrieve corresponding Verilator command-line options. Use cases include selecting and passing optimization settings when generating Verilator-based simulation libraries.",
      "description_length": 406,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_verilator.Simulation_backend",
      "library": "hardcaml_verilator",
      "description": "This module selects between Hardcaml's native simulation and the Verilator-accelerated simulation backend. It works with the `t` type, which is a variant representing either simulation mode, and supports serialization via S-expressions and bin-IO for use in command-line tools and persistent storage. It is used to configure simulation behavior at runtime, enabling performance-sensitive simulations to use Verilator while retaining Hardcaml as a fallback.",
      "description_length": 456,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_verilator.Cache",
      "library": "hardcaml_verilator",
      "description": "This module defines caching strategies for Verilator simulation artifacts using three modes: no caching, hashed caching with a directory, and explicit file-based caching. It serializes and deserializes cache configurations using S-expressions and binary protocols, supporting efficient storage and retrieval of simulation state. Concrete use cases include reducing recompilation overhead during iterative design changes and persisting simulation setups across runs.",
      "description_length": 465,
      "index": 4,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_verilator.Config",
      "library": "hardcaml_verilator",
      "description": "This module defines configuration options for compiling Verilator-based simulations, including parameters for optimization levels, thread usage during compilation and runtime, and output splitting strategies. It provides functions to construct compilation and linking commands tailored to the configuration, along with predefined settings for common use cases like small C-file splitting and environment-driven parallelism. These configurations directly influence the generation and performance of the shared libraries used in cycle-accurate simulations.",
      "description_length": 554,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_verilator.Threads",
      "library": "hardcaml_verilator",
      "description": "This module manages thread-unsafe simulation contexts for Verilator-generated code, allowing configuration of thread safety via command-line flags. It provides functions to create and manipulate integer and string representations of simulation instances, along with S-expression serialization. Use this when controlling Verilator simulation behavior in environments where thread safety is optional or explicitly disabled for performance.",
      "description_length": 437,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_verilator.Verilator_version",
      "library": "hardcaml_verilator",
      "description": "This module defines and manipulates Verilator version types, supporting conversion between integer representations, string formatting, and command-line argument parsing. It works with a sum type `t` representing Verilator versions (V4, V5) and integrates with serialization and command-line interfaces. Concrete use cases include selecting Verilator version at runtime and logging or comparing version-specific behavior during simulation setup.",
      "description_length": 444,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_verilator",
      "library": "hardcaml_verilator",
      "description": "This module compiles Hardcaml circuits to Verilator-generated C++ simulations, providing input/output port access, evaluation, and completion functions. It works with circuit descriptions, signal types, and mutable bit vectors to enable cycle-accurate simulation with configurable optimization, threading, and output splitting. Concrete use cases include accelerating simulation of large Verilog designs, managing thread-unsafe contexts for performance, and persisting compiled simulation artifacts across runs.",
      "description_length": 511,
      "index": 8,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 9,
    "meaningful_modules": 9,
    "filtered_empty_modules": 0,
    "retention_rate": 1.0
  },
  "statistics": {
    "max_description_length": 554,
    "min_description_length": 406,
    "avg_description_length": 464.0,
    "embedding_file_size_mb": 0.1308584213256836
  }
}