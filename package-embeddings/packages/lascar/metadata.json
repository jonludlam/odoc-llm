{
  "package": "lascar",
  "embedding_model": "Qwen/Qwen3-Embedding-8B",
  "embedding_dimension": 4096,
  "total_modules": 387,
  "creation_timestamp": "2025-08-18T19:49:48.773704",
  "modules": [
    {
      "module_path": "Lascar.Dfa.Product.NFA.LTSA.States.Elt",
      "library": "lascar",
      "description": "This module represents individual states in a non-deterministic finite automaton (NFA) with labeled transitions (LTSA) and provides operations to compare and display those states. It works directly with the `t` type, which identifies unique states within the automaton. Concrete use cases include tracking state identities during product automaton construction and enabling ordered collections of states for algorithms requiring state enumeration or comparison.",
      "description_length": 461,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Dfa.Make.NFA.LTSA.States.Elt",
      "library": "lascar",
      "description": "This module represents individual states in a labeled transition system automaton (LTSA) used within a deterministic finite automaton (DFA). It provides operations for comparing states structurally and converting them to string representations. It is used to define and manipulate the states of an automaton in a way that supports deterministic transitions based on symbols.",
      "description_length": 374,
      "index": 1,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lascar.Conv.ToDfa.NFA.LTSA.States.Elt",
      "library": "lascar",
      "description": "This module defines operations for comparing and converting state elements of a labeled transition system's states. It works with the `t` type representing individual states, providing a total ordering via `compare` and string representation via `to_string`. These functions support determinization processes by enabling state identity checks and debugging output.",
      "description_length": 364,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Nfa.Make.LTSA.States.Elt",
      "library": "lascar",
      "description": "This module represents individual states in a non-deterministic finite automaton (NFA) structure. It provides operations for comparing state identities and converting them to string representations. These states are used to define the nodes in an LTSA-based NFA, where transitions between states are labeled with symbols.",
      "description_length": 321,
      "index": 3,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lascar.Conv.ToDfa.NFA.LTSA.Attr",
      "library": "lascar",
      "description": "This module defines attributes for states in a non-deterministic finite automaton (NFA) during the determinization process. It includes a `to_string` function for converting attribute values to string representations, used to display or log state properties. These attributes are specifically tied to labeled transition system representations, supporting the conversion of NFA structures into deterministic finite automata (DFA).",
      "description_length": 429,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Conv.ToDfa.NFA.LTSA.Label",
      "library": "lascar",
      "description": "This module defines a concrete label type used in representing transitions within a labeled transition system, specifically tailored for use in the determinization of NFAs to DFAs. It includes operations for comparing labels using a total order and converting labels to strings, which are essential for managing and identifying transitions during the conversion process. These capabilities support tasks such as state expansion and transition table construction in automata theory applications.",
      "description_length": 494,
      "index": 5,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lascar.Dfa.Make.NFA.LTSA.States",
      "library": "lascar",
      "description": "This module offers operations for manipulating ordered sets of automaton states, supporting transformations like union, intersection, and power set generation. It works with a set type (`t`) that maintains elements in a sorted order using a comparator, enabling efficient membership checks, extremal value access, and sequence-based iteration. These capabilities are critical for tasks like subset construction in DFA creation, state minimization, or reachability analysis within labeled transition systems.",
      "description_length": 507,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Dfa.Make.NFA.LTSA.Tree",
      "library": "lascar",
      "description": "This module represents trees used to model state transitions in automata, providing operations to fold over tree nodes and visualize trees using Graphviz. It works with nodes representing automaton states and edges labeled with transition symbols, structured as a recursive tree type. Use cases include visualizing the structure of non-deterministic finite automata (NFA) trees and performing aggregations over tree nodes during automaton analysis or transformation.",
      "description_length": 466,
      "index": 7,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lascar.Dfa.Product.NFA.States.Elt",
      "library": "lascar",
      "description": "This module represents individual states in a non-deterministic finite automaton (NFA) and provides a total ordering function for comparing states. It includes operations to convert a state to a string representation and ensures states can be consistently ordered for use in set-like structures. Concrete use cases include tracking and comparing states during NFA construction and product operations.",
      "description_length": 400,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Dfa.Product.NFA.LTSA.Label",
      "library": "lascar",
      "description": "This module defines operations for comparing and converting label values to strings. It works with the label type from the `NFA.LTSA` module, which represents transition labels in a finite automaton. Concrete use cases include ordering labels for set or map operations and generating string representations for debugging or output.",
      "description_length": 331,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Conv.ToDfa.NFA.States.Elt",
      "library": "lascar",
      "description": "This module defines operations for comparing and converting NFA state elements. It provides a total ordering function for state elements and a string conversion function. These are used during determinization to manage state equivalence and representation in the resulting DFA.",
      "description_length": 277,
      "index": 10,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Nfa.Product.LTSA.States.Elt",
      "library": "lascar",
      "description": "This module represents individual states in the product of two NFAs, providing a total ordering and string conversion for state elements. It works directly with the `LTSA.States.Elt.t` type, which encodes state information from the underlying automata. It is used to uniquely identify and compare states in the resulting product automaton during NFA composition operations.",
      "description_length": 373,
      "index": 11,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Dfa.Make.LTSA.States.Elt",
      "library": "lascar",
      "description": "This module represents individual states in a deterministic finite automaton (DFA) structure. It provides a total ordering function for comparing state elements and a conversion function to string for state representation. These operations support the management and manipulation of DFA states, particularly in ensuring uniqueness and ordered processing during transitions.",
      "description_length": 373,
      "index": 12,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lascar.Dfa.Product.NFA.LTSA.Tree",
      "library": "lascar",
      "description": "This module represents trees used to model the structure of Non-deterministic Finite Automata (NFA) in the context of computing products of automata. It provides operations to fold over tree nodes, and to visualize trees using Graphviz through functions that generate `.dot` files and open them. The primary data structures are trees composed of nodes and edges, where each node corresponds to an NFA state and edges represent transitions labeled by symbols.",
      "description_length": 458,
      "index": 13,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Lts.Product.Repr.States.Elt",
      "library": "lascar",
      "description": "This module represents individual states in a labeled transition system derived from the product of two other systems. It provides operations for comparing states structurally and converting them to string representations. The module works directly with the `t` type, which corresponds to elements of the product state space, enabling precise state manipulation and identification in product LTS computations.",
      "description_length": 409,
      "index": 14,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Conv.ToDfa.NFA.LTSA.State",
      "library": "lascar",
      "description": "This module defines operations for comparing and converting NFA states to strings. It works with the `NFA.LTSA.state` type, providing a total ordering function for state comparison and a string conversion function. These functions are used during NFA-to-DFA conversion to manage and represent states uniquely.",
      "description_length": 309,
      "index": 15,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Conv.ToLts.Repr.States.Elt",
      "library": "lascar",
      "description": "This module represents states in a converted labeled transition system where state attributes are removed. It provides a total ordering function for comparing state elements and a string conversion function for state representation. These operations support efficient state manipulation and debugging in the context of LTS transformations.",
      "description_length": 339,
      "index": 16,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Dfa.Product.NFA.LTSA.Attrs",
      "library": "lascar",
      "description": "This module provides map-like operations for managing attributes associated with NFA states, using `NFA.LTSA.state` as keys and arbitrary data as values. It supports insertion, deletion, filtering, merging, and ordered traversal (via functions like `min`, `max`, and `split`), while enforcing total ordering on keys. These capabilities are particularly useful for tracking state annotations or metadata during automata operations like product computation, where transformations of state attributes must align with deterministic transition constraints.",
      "description_length": 551,
      "index": 17,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Moore.Make.M.States.Elt",
      "library": "lascar",
      "description": "This module represents individual states in a Moore machine, providing a typed element structure with a total ordering and string conversion. It works with the state elements of a Moore machine, typically used to define and compare distinct states within the machine's logic. Concrete use cases include identifying unique states during machine transitions and serializing states for logging or debugging purposes.",
      "description_length": 413,
      "index": 18,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Conv.ToDfa.NFA.LTSA.Attrs",
      "library": "lascar",
      "description": "This module provides a persistent map interface for managing associations between NFA states and arbitrary data, featuring creation, modification, and combination operations optimized through structural sharing to ensure immutability. It supports ordered key-value manipulations, including predicate-based queries, ordered iteration, and bidirectional conversions with sequences, leveraging `Ord.compare` for key ordering. These capabilities are primarily used during NFA-to-DFA determinization to track and transform per-state attributes like transition labels or metadata.",
      "description_length": 574,
      "index": 19,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Dfa.Product.NFA.LTSA.State",
      "library": "lascar",
      "description": "This module represents states in a non-deterministic finite automaton (NFA) and provides operations for comparing and converting states to string representations. It works directly with the `NFA.LTSA.state` type, which is used to model individual states in an automaton structure. Concrete use cases include managing state identities during automaton construction, enabling ordered collections of states, and facilitating debugging through string serialization.",
      "description_length": 461,
      "index": 20,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Dfa.Product.LTSA.States.Elt",
      "library": "lascar",
      "description": "This module represents individual states in a deterministic finite automaton (DFA) product construction. It provides comparison and string conversion operations for state elements, enabling ordered processing and debugging output. These functions are essential when combining two DFAs over the same symbol set, particularly for tracking unique state pairs during product automaton creation.",
      "description_length": 390,
      "index": 21,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Mealy.Make.M.States.Elt",
      "library": "lascar",
      "description": "This module represents individual states in a Mealy machine, providing a comparable and serializable state element. It supports operations for comparing states and converting them to string representations. It is used to manage distinct states during the execution or analysis of Mealy machines, such as in model checking or state traversal tasks.",
      "description_length": 347,
      "index": 22,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Conv.ToMoore.M.States.Elt",
      "library": "lascar",
      "description": "This module defines operations for comparing and converting state elements during the transformation of a Mealy machine into a Moore machine. It works with the state elements of the target Moore machine, providing a total ordering function and a string conversion function. These functions are used to uniquely identify and order states when constructing the new Moore machine's state space.",
      "description_length": 391,
      "index": 23,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lascar.Dfa.Make.NFA.LTSA.State",
      "library": "lascar",
      "description": "This module represents states in a labeled transition system automaton (LTSA) used for modeling non-deterministic finite automata (NFA). It provides operations for comparing states and converting them to string representations, facilitating state management and debugging. The module works directly with state identifiers, supporting the construction and manipulation of automata where each state can have multiple transitions for the same input symbol.",
      "description_length": 453,
      "index": 24,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Lts.Make.Repr.States.Elt",
      "library": "lascar",
      "description": "This module represents individual states in a labeled transition system, providing a total ordering function for state comparison and a string conversion function for state identifiers. It works with state identifiers of type `Repr.States.elt`, which are used to uniquely identify states in the transition system. Concrete use cases include comparing and displaying state identifiers during traversal or analysis of the system's structure.",
      "description_length": 439,
      "index": 25,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lascar.Dfa.Make.NFA.LTSA.Attrs",
      "library": "lascar",
      "description": "This module provides map algebra and ordered traversal operations for state attribute mappings in finite automata, where keys are state identifiers and values are polymorphic. It supports efficient attribute management through pure functional transformations, predicate-based queries, and ordered iteration over maps structured as `NFA.LTSA.Attrs.t`. Typical use cases include tracking state properties during automaton construction, merging transition attributes, or filtering states based on runtime conditions.",
      "description_length": 513,
      "index": 26,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Conv.ToMealy.M.States.Elt",
      "library": "lascar",
      "description": "This module defines operations for comparing and converting state elements when transforming a Moore machine into a Mealy machine. It works directly with the state elements of the source Moore machine. Concrete use cases include ensuring a total ordering for state comparison and generating string representations of states during conversion.",
      "description_length": 342,
      "index": 27,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Dfa.Product.NFA.LTSA.Attr",
      "library": "lascar",
      "description": "This module represents attributes for states in a non-deterministic finite automaton (NFA) with labeled transitions and state attributes (LTSA). It provides a concrete type `t` for state attributes and a `to_string` function to convert these attributes to string representations. It is used to attach and display metadata such as state labels or properties in automata operations.",
      "description_length": 380,
      "index": 28,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Conv.Fsm.M.States.Elt",
      "library": "lascar",
      "description": "This module represents individual states within a finite state machine, providing a comparable and serializable state element. It supports operations to compare states for ordering and convert them to string representations. It is used when manipulating or analyzing FSM states directly, such as in state traversal, equivalence checking, or logging state transitions.",
      "description_length": 367,
      "index": 29,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Dfa.Product.NFA.LTSA.States",
      "library": "lascar",
      "description": "This module provides a functional set API for manipulating ordered collections of NFA states from labeled transition systems, supporting operations like union, intersection, filtering, and ordered traversal. It works with `NFA.LTSA.States.t` sets containing `NFA.LTSA.state` elements, emphasizing efficient transformations and order-preserving iteration. These capabilities are particularly useful for automaton product construction, state space exploration, and operations requiring precise control over state set ordering and membership queries.",
      "description_length": 547,
      "index": 30,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Fsm.Make.M.States.Elt",
      "library": "lascar",
      "description": "This module represents individual states within a finite state machine, providing a typed element structure for state management. It includes operations for comparing state elements to enforce ordering and converting states to string representations. These capabilities are essential for implementing state transitions and debugging state machine behavior in applications like protocol parsing or workflow engines.",
      "description_length": 414,
      "index": 31,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Dfa.Make.NFA.LTSA.Label",
      "library": "lascar",
      "description": "This module defines a label type used in non-deterministic finite automata (NFA) transitions, specifically within the `Lascar.Dfa.Make` functor's context. It provides a total ordering function for comparing labels and a conversion function to string representations. These operations support the creation and manipulation of DFA structures where labels represent input symbols guiding state transitions.",
      "description_length": 403,
      "index": 32,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Dfa.Make.NFA.States.Elt",
      "library": "lascar",
      "description": "This module represents individual states in a non-deterministic finite automaton (NFA) structure, providing operations for comparing and converting states to string representations. It works with state identifiers that are elements of a set structure, supporting the creation and manipulation of NFA states. Concrete use cases include managing unique state identifiers during NFA construction and enabling ordered comparisons for deterministic transitions.",
      "description_length": 456,
      "index": 33,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lascar.Lts.Product3.Repr.States.Elt",
      "library": "lascar",
      "description": "This module represents states in a product of three labeled transition systems, where each state is a tuple of three individual states. It provides a total ordering and string conversion for these composite states. Useful for tracking combined system configurations in model checking or state exploration tasks.",
      "description_length": 311,
      "index": 34,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Dfa.Make.NFA.LTSA.Attr",
      "library": "lascar",
      "description": "This module represents attributes associated with states or transitions in a labeled transition system automaton (LTSA), specifically used within a non-deterministic finite automaton (NFA) structure. It provides a `to_string` function for converting attribute values to string representations, enabling direct inspection or logging of attribute data. Concrete use cases include tracking metadata such as acceptance conditions, labels, or annotations during automaton manipulation or visualization tasks.",
      "description_length": 503,
      "index": 35,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Conv.ToDfa.NFA.LTSA.Tree",
      "library": "lascar",
      "description": "This module represents and manipulates trees derived from NFA LTSAs, supporting operations like folding over nodes and visualizing trees using Graphviz. It works with labeled transition trees where nodes correspond to NFA states and edges represent transitions. Concrete use cases include converting NFA structures to DFA by analyzing tree paths and debugging automata transformations through visual output.",
      "description_length": 407,
      "index": 36,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Conv.ToDfa.LTSA.States.Elt",
      "library": "lascar",
      "description": "This module defines operations for comparing and converting elements of a set representing states in a labeled transition system. It provides a total ordering function for state elements and a string conversion function. These functions are used to manage and manipulate state representations during the determinization of automata.",
      "description_length": 332,
      "index": 37,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Conv.ToDfa.LTSA.States",
      "library": "lascar",
      "description": "This module provides a set abstraction for managing finite collections of labeled transition system states, offering standard operations like membership testing, union, intersection, and difference alongside ordered traversal, filtering, and functional transformations. It works with immutable sets of `LTSA.state` elements, supporting efficient state manipulation during automata determinization through features like power set computation, reverse iteration, and comparison-aware string conversion. Key use cases include tracking state subsets during NFA-to-DFA conversion and enabling precise state-set analysis via deterministic traversal and partitioning.",
      "description_length": 660,
      "index": 38,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lascar.Lts.Product3.Repr.Tree",
      "library": "lascar",
      "description": "This module represents trees used to model the product of three labeled transition systems, where each node has a `unit`-typed attribute and edges carry labels. It provides operations to fold over all nodes in a tree and to visualize trees using Graphviz, with customizable output options. Use cases include analyzing combined system behaviors and debugging structural properties of product transition systems.",
      "description_length": 410,
      "index": 39,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lascar.Moore.Make.States.Elt",
      "library": "lascar",
      "description": "This module represents individual states in a Moore machine, providing a comparable and printable state element. It defines a total ordering function for state comparison and a string conversion function for state representation. This module is used to identify and distinguish states within a Moore machine's state transition system.",
      "description_length": 334,
      "index": 40,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Lts.Product.Repr.Attrs",
      "library": "lascar",
      "description": "This module offers map-like operations for managing state-attribute associations in labeled transition systems, where keys are states and values are arbitrary data. It provides ordered key-based transformations, including querying (min/max/by predicate), merging, and sequence conversion, while ensuring functional persistence. These capabilities are particularly useful for tracking and manipulating state metadata during LTS product computations or behavioral analysis.",
      "description_length": 471,
      "index": 41,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Conv.Fsm.M.Tree",
      "library": "lascar",
      "description": "This module represents and manipulates trees derived from finite state machines, where each node corresponds to a state and edges represent transitions labeled by actions. It provides operations to fold over the nodes of a tree and to visualize trees using Graphviz, including writing `.dot` files and rendering them. Use cases include analyzing FSM structures, generating visual representations of state transitions, and debugging complex state hierarchies.",
      "description_length": 458,
      "index": 42,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Moore.Make.M.Attr",
      "library": "lascar",
      "description": "This module defines attributes for states in a Moore machine, including operations to convert attribute values to strings. It works with the attribute type `M.Attr.t` associated with Moore machine states. Concrete use cases include labeling states with metadata and enabling string-based inspection or logging of state attributes.",
      "description_length": 330,
      "index": 43,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Mealy.Make.M.Label",
      "library": "lascar",
      "description": "This module represents labels of transitions in a Mealy machine, where each label is a pair of boolean valuations for input and output variables. It supports comparison and string conversion operations for these labels. It is used to distinguish and display transitions based on their input-output behavior in the machine.",
      "description_length": 322,
      "index": 44,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Dfa.Product.NFA.LTSA",
      "library": "lascar",
      "description": "This module provides operations for constructing, analyzing, and visualizing non-deterministic finite automata (NFAs) with labeled transitions and state attributes. It supports querying reachability, modifying transitions and states, and transforming automata through mappings and folds over structures like state sets, attribute dictionaries, and execution trees. Key use cases include formal verification tasks, product automaton composition, and generating graphical representations (DOT/TeX) with custom styling for analysis or documentation.",
      "description_length": 546,
      "index": 45,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Conv.ToDfa.LTSA.Label",
      "library": "lascar",
      "description": "This module defines a total ordering and string representation for transition labels in a labeled transition system. It works directly with the `LTSA.label` type, enabling deterministic comparisons and conversions to strings. These operations support the determinization process when converting non-deterministic finite automata to deterministic ones.",
      "description_length": 351,
      "index": 46,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Dfa.Product.NFA.Tree",
      "library": "lascar",
      "description": "This module represents trees used to model the structure of Non-Deterministic Finite Automata (NFAs), with nodes corresponding to NFA states and edges labeled by transition symbols. It provides operations to fold over tree nodes and visualize trees using Graphviz, including customizable output styling. Concrete use cases include analyzing NFA transition structures and debugging automata behavior through visual representation.",
      "description_length": 429,
      "index": 47,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Lts.Product3.Repr.State",
      "library": "lascar",
      "description": "This module represents states in a labeled transition system product of three components, where each state has a unit attribute. It provides a total ordering function for comparing states and converting them to string representations. These operations support state management and debugging in LTS product computations.",
      "description_length": 319,
      "index": 48,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lascar.Dfa.Product.States.Elt",
      "library": "lascar",
      "description": "This module represents individual states in the product of two DFAs, where each state is an element of a set with a total ordering and string representation. It provides `compare` for ordering states and `to_string` for converting them to strings. These operations support constructing and manipulating product automata, such as tracking combined states during intersection or synchronization of two DFAs.",
      "description_length": 405,
      "index": 49,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Conv.ToMoore.States.Elt",
      "library": "lascar",
      "description": "This module defines operations for comparing and converting state elements during the transformation of a Mealy machine into a Moore machine. It provides a total ordering function and a string conversion function for state elements. These functions are used to uniquely identify and order states in the resulting Moore machine.",
      "description_length": 327,
      "index": 50,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Nfa.Make.LTSA.Tree",
      "library": "lascar",
      "description": "This module represents and manipulates trees within a Non-deterministic Finite Automaton (NFA) structure, specifically handling transitions between states using labeled edges. It provides operations to fold over tree nodes and visualize trees using Graphviz, with support for custom styling and output control. Use cases include analyzing automaton structures, debugging state transitions, and generating visual representations of NFA trees for verification tasks.",
      "description_length": 464,
      "index": 51,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Lts.Make.Repr.Tree",
      "library": "lascar",
      "description": "This module represents labeled transition systems as trees, where each node corresponds to a state and edges represent transitions labeled with actions. It provides operations to fold over all nodes in the tree and to visualize the tree structure using Graphviz, either by generating a `.dot` file or directly opening it for viewing. Use cases include inspecting the structure of a transition system during debugging or generating visual representations of state spaces for analysis.",
      "description_length": 483,
      "index": 52,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Lts.Product.Repr.Tree",
      "library": "lascar",
      "description": "This module represents trees used to model the product of labeled transition systems, where each node corresponds to a state and edges represent transitions labeled by actions. It provides operations to fold over tree nodes, visualize trees using Graphviz, and output tree structures in DOT format for debugging or analysis. Concrete use cases include visualizing the state space of composed systems and traversing product transition trees to analyze reachability or behavior combinations.",
      "description_length": 489,
      "index": 53,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Dfa.Make.NFA.Symbols",
      "library": "lascar",
      "description": "This module provides a suite of **set-theoretic operations** for managing ordered collections of symbols, typically characters or tokens, used in automata transitions. It operates on two core types: `elt`, representing individual symbols, and `t`, an ordered set structure (maintained via a comparator) for efficient membership checks, union/intersection operations, and ordered traversal. These capabilities are critical for tasks like symbol set manipulation during NFA-to-DFA conversion, transition relation analysis, and state minimization, where precise control over symbol sets ensures correctness and performance.",
      "description_length": 620,
      "index": 54,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Dfa.Make.NFA.Label",
      "library": "lascar",
      "description": "This module defines the label type used for transitions in a non-deterministic finite automaton (NFA), including operations for comparison and string representation. It works with the `NFA.Label.t` type, which corresponds to the symbol type of the NFA. Concrete use cases include comparing transition labels to ensure correct ordering in sets and maps, and converting labels to strings for display or logging purposes.",
      "description_length": 418,
      "index": 55,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lascar.Lts.Product.Repr.State",
      "library": "lascar",
      "description": "This module represents states in a labeled transition system product, providing a unique identifier for each state through a total ordering function and string conversion. It works with the `Repr.State.t` type, which encodes product states with unit attributes. Concrete use cases include managing state identities in product LTS constructions and enabling efficient state comparisons during model checking or system composition.",
      "description_length": 429,
      "index": 56,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Conv.ToMealy.M.States",
      "library": "lascar",
      "description": "This module provides a rich set of **ordered set operations** for managing state elements during Moore-to-Mealy machine conversion, including membership checks, union/intersection/difference, predicate-based filtering, and ordered traversal. It works with `M.States.t` sets containing elements of type `M.state` (representing machine states) and supports transformations like power set generation, sequence conversion, and string representation. These operations are particularly useful for tasks like state space exploration, transition relation manipulation, and deterministic state processing in automata conversion workflows.",
      "description_length": 629,
      "index": 57,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Dfa.Product.LTSA.Label",
      "library": "lascar",
      "description": "This module defines operations for comparing and converting label values to strings. It works with the `LTSA.label` type, providing a total ordering via `compare` and readable string representations via `to_string`. These functions are used when managing state transitions and labels in deterministic finite automata constructions.",
      "description_length": 331,
      "index": 58,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Nfa.Product.LTSA.States",
      "library": "lascar",
      "description": "This module provides efficient set-theoretic operations for manipulating collections of product states in composed NFAs, including union, intersection, difference, filtering, and power set generation. It works with ordered state elements represented as `LTSA.States.t` sets, where elements conform to the `Elt` module's ordering for deterministic comparisons. These operations are particularly useful in automata composition analysis, reachability computations, and algorithms requiring precise tracking of state combinations across multiple NFAs.",
      "description_length": 547,
      "index": 59,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Conv.ToDfa.NFA.Tree",
      "library": "lascar",
      "description": "This module represents and manipulates non-deterministic finite automaton (NFA) trees used during the determinization process. It provides operations to fold over tree nodes and visualize trees using Graphviz, specifically handling tree structures composed of NFA states and transitions. Concrete use cases include inspecting intermediate NFA tree structures during conversion to a deterministic automaton and debugging automaton transformations through visual output.",
      "description_length": 468,
      "index": 60,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Moore.Make.M.Label",
      "library": "lascar",
      "description": "This module defines the label type and operations for states in a Moore machine. It includes functions for comparing labels to maintain a total order and converting labels to strings for display or serialization. These capabilities are essential for implementing and debugging Moore machines where states are distinguished by labeled transitions.",
      "description_length": 346,
      "index": 61,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Conv.ToDfa.NFA.LTSA",
      "library": "lascar",
      "description": "This module provides operations for querying, transforming, and visualizing labeled transition systems (LTS) during NFA-to-DFA conversion. It works with NFA.LTSA structures, which model states, labels, and attributes alongside transition graphs, supporting tasks like determinization, reachability analysis, and attribute propagation. Specific capabilities include state/transition modification, tree unwinding, unreachable state cleanup, and generating graphical representations for formal verification workflows.",
      "description_length": 514,
      "index": 62,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Conv.ToDfa.States.Elt",
      "library": "lascar",
      "description": "This module represents individual states in a deterministic finite automaton (DFA) during the conversion from a non-deterministic finite automaton (NFA). It provides a total ordering function for comparing state elements and a string conversion function for state representation. These operations support set-based manipulations of DFA states, particularly when tracking reachable states and generating state identifiers during determinization.",
      "description_length": 444,
      "index": 63,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lascar.Conv.ToLts.Repr.States",
      "library": "lascar",
      "description": "This module provides operations for managing ordered, persistent sets of LTS states (with unit-valued attributes), supporting transformations like union, intersection, and mapping, as well as queries for membership, cardinality, and extremal elements. It works with set structures (`Repr.States.t`) that maintain deterministic order and optimize equality checks, enabling efficient workflows in LTS state-space manipulations such as subset construction, transition pruning, or reachability analysis. Key features include power set computation, bidirectional iteration, and state labeling via the `Elt` module, which ensures consistent ordering and string representations for deterministic processing in LTS conversions.",
      "description_length": 719,
      "index": 64,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Lts.Make.Repr.Label",
      "library": "lascar",
      "description": "This module defines operations for comparing and converting transition labels to strings in a Labeled Transition System. It works with the `Repr.label` type, which represents the labels on transitions within the system. Concrete use cases include ordering labels for deterministic processing and generating string representations for logging or visualization purposes.",
      "description_length": 368,
      "index": 65,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Lts.Product3.Repr.Attrs",
      "library": "lascar",
      "description": "This module implements an ordered key-value map where keys are states from a product LTS representation and values are arbitrary typed attributes. It provides standard map operations like insertion, filtering, and merging, along with ordered traversal and bulk transformations, leveraging physical equality for efficient structural sharing. The functionality is particularly useful for tracking and manipulating state metadata (e.g., labels, annotations) in product LTS constructions while maintaining ordered access and compositional invariants.",
      "description_length": 546,
      "index": 66,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lascar.Conv.ToDfa.LTSA.Attr",
      "library": "lascar",
      "description": "Performs attribute transformation during conversion of non-deterministic finite automata to deterministic finite automata. Works with labeled transition system attributes to enable state determinization. Converts attribute values to strings for representation in deterministic transitions.",
      "description_length": 289,
      "index": 67,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Dfa.Make.NFA.State",
      "library": "lascar",
      "description": "This module represents states in a non-deterministic finite automaton (NFA), providing operations for comparing and converting state identifiers to strings. It works with state identifiers that are totally ordered and support string representation. Concrete use cases include managing state transitions and tracking state sets during NFA construction and manipulation.",
      "description_length": 368,
      "index": 68,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Conv.ToLts.Repr.Tree",
      "library": "lascar",
      "description": "This module represents a tree structure for labeled transition systems where state attributes are removed, using variants `Empty` and `Node` to model hierarchical transitions. It provides `fold` to aggregate node values and `dot_output` and `dot_view` to visualize the tree in Graphviz format. It is used to analyze and debug transition system structures by converting them into visualizable tree forms.",
      "description_length": 403,
      "index": 69,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Lts.Product3.Repr.Label",
      "library": "lascar",
      "description": "This module defines the label type and operations for a labeled transition system's edge labels. It provides a total ordering function for comparing labels and a conversion function to string representations. These functions support efficient label manipulation and debugging in transition system product computations.",
      "description_length": 318,
      "index": 70,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Lts.Make.Repr.Attrs",
      "library": "lascar",
      "description": "This module provides map-based operations for managing state attributes in a labeled transition system, supporting key-value manipulations (insertion, deletion, transformation) where keys are states (`Repr.state`) and values have a generic type `'a`. It leverages ordered keys via `Ord.compare` to enable efficient querying (e.g., min/max, predicate-based searches) and structural conversions from sequences of key-value pairs. Specific use cases include tracking dynamic state properties, composing attribute transformations during LTS transitions, and extracting subsets of attributes for analysis or serialization.",
      "description_length": 617,
      "index": 71,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Conv.ToDfa.LTSA.State",
      "library": "lascar",
      "description": "This module represents states in a labeled transition system (LTS) during the conversion from NFA to DFA. It provides a total ordering function for state comparison and a string conversion function for state representation. These operations support determinization by enabling state set management and identification during the conversion process.",
      "description_length": 347,
      "index": 72,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Moore.Make.M.Attrs",
      "library": "lascar",
      "description": "This module provides operations to create, modify, and combine maps that use Moore machine states as ordered keys with polymorphic values. It supports querying by key ranges, splitting maps, converting sequences to maps, and transformations with or without key dependencies\u2014enabling tasks like managing state attributes, merging state-based data, or processing sequential state-value inputs into structured representations.",
      "description_length": 423,
      "index": 73,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Dfa.Product.LTSA.Attrs",
      "library": "lascar",
      "description": "This module provides map-like operations for managing state attributes in deterministic finite automaton products, emphasizing ordered key-based access and functional transformations. It works with maps where keys are LTSA states ordered via comparison functions and values hold arbitrary data, supporting efficient insertion, deletion, merging, and traversal. These operations are used to manipulate and query state attributes during product construction, such as combining attributes from component automata or extracting specific state information through ordered traversal and key-based queries.",
      "description_length": 599,
      "index": 74,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Dfa.Product.NFA.Symbols",
      "library": "lascar",
      "description": "This module provides ordered set operations for manipulating NFA symbol collections, including union, intersection, difference, and ordered traversal. It works with `NFA.Symbols.t` sets, which store symbols in a sorted structure using `Ord.compare`, enabling deterministic iteration, extremal element queries, and sequence-based construction. These operations are particularly useful for building transition symbol sets in NFA products and handling ordered symbol sequences during automaton composition or analysis tasks.",
      "description_length": 521,
      "index": 75,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lascar.Dfa.Make.LTSA.Tree",
      "library": "lascar",
      "description": "This module represents and manipulates trees used to model deterministic finite automata (DFA) structures. It provides operations for folding over tree nodes, visualizing trees using Graphviz, and writing tree structures to `.dot` files. The module works directly with tree data structures composed of nodes and labeled edges, specifically tailored for representing state transitions in automata.",
      "description_length": 396,
      "index": 76,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Moore.Make.M.States",
      "library": "lascar",
      "description": "This module provides set-theoretic operations and transformations for managing collections of Moore machine states, including union, intersection, difference, filtering, partitioning, and ordered traversal. It works with finite, totally ordered sets of states (`M.States.t`) that support comparison, string conversion, and efficient iteration via functional combinators. These operations are particularly useful in formal verification tasks requiring precise state-space manipulation, such as equivalence checking, reachability analysis, or generating power sets for behavioral refinement workflows.",
      "description_length": 599,
      "index": 77,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Conv.ToMealy.M.Tree",
      "library": "lascar",
      "description": "This module defines a tree structure with nodes and labeled edges, supporting transformations and visualizations of Moore-to-Mealy machine conversions. It provides `fold` for aggregating node values and `dot_output`/`dot_view` for generating and displaying Graphviz representations. Concrete use cases include analyzing state transitions and debugging machine conversions through visual tree outputs.",
      "description_length": 400,
      "index": 78,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Mealy.Make.M.State",
      "library": "lascar",
      "description": "Implements operations for managing and comparing states within a Mealy machine, including a total ordering function and string representation. Works directly with the state type of the machine, enabling identification and traversal based on state values. Useful for tracking transitions and ensuring deterministic behavior in state-dependent computations.",
      "description_length": 355,
      "index": 79,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lascar.Dfa.Product.NFA.Symbol",
      "library": "lascar",
      "description": "This module defines the symbol type used in non-deterministic finite automata (NFA) and provides operations for comparing symbols, converting them to strings, and representing the empty (epsilon) symbol. It works directly with the `NFA.symbol` type, which represents input symbols in automata transitions. Concrete use cases include labeling transitions in NFA structures and enabling comparison-based logic during automaton manipulation, such as product construction or transition table management.",
      "description_length": 499,
      "index": 80,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Lts.Product.Repr.States",
      "library": "lascar",
      "description": "This module provides set-theoretic operations\u2014union, intersection, difference, and subset checks\u2014alongside transformation functions like filtering, mapping, and partitioning on ordered collections of product states (`Repr.States.t`). These operations emphasize efficient, order-preserving iteration and structural sharing, specifically handling sets of states derived from the product of two labeled transition systems. They are tailored for tasks like state-space exploration in formal verification, where precise manipulation of product states and their attributes is critical for model checking and concurrency analysis.",
      "description_length": 623,
      "index": 81,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Lts.Make.Repr.States",
      "library": "lascar",
      "description": "This module provides set operations and utility functions for managing ordered collections of labeled transition system states, including union, intersection, filtering, and power set generation. The operations work on a concrete set type maintained with element ordering via `Ord.compare`, enabling efficient state space exploration and analysis. It supports tasks like model checking, transition system verification, and formal analysis of state-based systems.",
      "description_length": 462,
      "index": 82,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Mealy.Make.States.Elt",
      "library": "lascar",
      "description": "This module represents elements of the state space in a Mealy machine, where each state is uniquely identified and ordered. It provides a total ordering function for comparing states and a string conversion function for state representation. These operations support state management and debugging in Mealy machine implementations.",
      "description_length": 331,
      "index": 83,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Dfa.Make.NFA.Attrs",
      "library": "lascar",
      "description": "This module provides map-like operations for managing state attributes in finite automata, focusing on key-value pairs where keys are ordered NFA states and values represent associated data. It supports transformations, queries, and conversions (e.g., from sequences) over these maps, ensuring ordered traversal and precise state metadata manipulation. Typical use cases include tracking state properties like acceptance flags or transition counts during automaton analysis or optimization tasks.",
      "description_length": 496,
      "index": 84,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Conv.ToMoore.M.States",
      "library": "lascar",
      "description": "This module provides set-theoretic operations for managing collections of states during Mealy-to-Moore machine conversion, including transformations like power set computation, filtering, and ordered element extraction. It works with immutable sets of states (`M.States.t`) that maintain ordering via comparison functions, supporting both standard set manipulations and specialized workflows for state equivalence analysis. Key use cases include tracking state transitions during machine conversion, computing reachable states, and generating string representations for debugging or formal verification tasks.",
      "description_length": 609,
      "index": 85,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Conv.Fsm.States.Elt",
      "library": "lascar",
      "description": "This module represents individual states within a finite state machine, providing a comparable and serializable state element. It supports operations to compare states for ordering and convert them to string representations. It is used to identify and manipulate distinct states during FSM transformations, such as state renaming or equivalence checking.",
      "description_length": 354,
      "index": 86,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Dfa.Make.NFA.LTSA",
      "library": "lascar",
      "description": "This module provides operations for modeling and manipulating non-deterministic finite automata (NFA) as labeled transition systems (LTSA), focusing on structural analysis, transformation, and visualization. It works with states, labels, transitions, and attributes, organized using sets, maps, and trees to support efficient membership checks, reachability analysis, and attribute-driven operations. Key use cases include constructing NFAs with custom attributes, pruning unreachable states, computing transitive closures, and generating styled visualizations in formats like `.dot` and `.tex` for analysis or documentation.",
      "description_length": 625,
      "index": 87,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lascar.Lts.Make.Repr.State",
      "library": "lascar",
      "description": "This module represents states in a labeled transition system, providing a total ordering and string conversion for state identifiers. It works with the underlying state type from `Lascar.Lts.Make.Repr`, treating state attributes as unit. Concrete use cases include managing state identities in transition systems, enabling comparisons for set or map operations, and generating string representations for debugging or output.",
      "description_length": 424,
      "index": 88,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Dfa.Make.NFA.Tree",
      "library": "lascar",
      "description": "This module represents non-deterministic finite automata (NFA) trees, providing operations to fold over nodes and visualize trees using Graphviz. It works with states and symbols from the NFA module, structured as trees with nodes and labeled edges. Use cases include analyzing state transitions and generating visual representations of automata trees for debugging or documentation.",
      "description_length": 383,
      "index": 89,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lascar.Conv.ToMoore.M.Tree",
      "library": "lascar",
      "description": "This module implements tree transformations during the conversion of Mealy machines to Moore machines, operating on tree structures defined by `M.Tree`. It provides `fold` for aggregating node values through a combining function, and `dot_output` / `dot_view` for visualizing trees using Graphviz. These functions are used to process and inspect the hierarchical state structure of the resulting Moore machine.",
      "description_length": 410,
      "index": 90,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Mealy.Make.M.Tree",
      "library": "lascar",
      "description": "This module implements tree structures for representing Mealy machine transitions, where each node corresponds to a machine state and edges carry input-output label pairs. It provides operations to fold over tree nodes and visualize trees using Graphviz, with customizable output formatting. Use cases include analyzing state transitions in hardware models or protocol implementations, and debugging machine behavior through graphical representations.",
      "description_length": 451,
      "index": 91,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Dfa.Make.NFA.States",
      "library": "lascar",
      "description": "This module provides set-theoretic operations (union, intersection, difference, subset checks) and transformations (filtering, partitioning, power set generation) for managing ordered collections of state identifiers in automata processing. It operates on immutable sets of comparable elements ordered via `Ord.compare`, supporting efficient membership queries, ordered traversal, and structural manipulations. These operations are critical for tasks like subset construction in NFA-to-DFA conversion, state equivalence verification, and ordered state set analysis during automaton composition or minimization.",
      "description_length": 610,
      "index": 92,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Dfa.Product.LTSA.State",
      "library": "lascar",
      "description": "This module represents states in a deterministic finite automaton (DFA) product construction. It provides `compare` for ordering states and `to_string` for string representation. Used to manage state equivalence and labeling during DFA product computations.",
      "description_length": 257,
      "index": 93,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Ltsa.Product3.States.Elt",
      "library": "lascar",
      "description": "This module represents elements of the product state space formed by combining three Labeled Transition Systems with State Attributes. It provides comparison and string conversion operations for product states, enabling ordered storage and readable debugging output. It is used to manage composite states during model checking or state-space exploration tasks.",
      "description_length": 360,
      "index": 94,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Conv.ToDfa.LTSA.Attrs",
      "library": "lascar",
      "description": "This module provides map-like operations for managing state-keyed attribute mappings during deterministic automaton construction, focusing on insertion, transformation, and query of arbitrary state metadata. It works with ordered key-value structures (`LTSA.Attrs.t`) where keys are `LTSA.state` values and values hold arbitrary data, leveraging `Ord.compare` for key ordering. These functions are specifically used to track and manipulate state properties during NFA-to-DFA conversion, such as merging transitions or propagating annotations through map folds and sequence-based initialization.",
      "description_length": 594,
      "index": 95,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Moore.Make.M.State",
      "library": "lascar",
      "description": "This module represents states in a Moore machine, providing operations to compare and convert states to strings. It works with a single abstract state type, supporting total ordering and string representation. Concrete use cases include managing state transitions and identifying states uniquely during machine execution.",
      "description_length": 321,
      "index": 96,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Lts.Product.Repr.Label",
      "library": "lascar",
      "description": "This module defines the label type and operations for a labeled transition system's edge labels. It provides a total ordering function for comparing labels and a conversion function to string representations. These functions support operations that require label comparison and display, such as state traversal and product construction.",
      "description_length": 336,
      "index": 97,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Nfa.Product.LTSA.Attr",
      "library": "lascar",
      "description": "This module defines attributes for labeled transition system states in the context of NFA products. It provides a `to_string` function for converting attribute values to string representations, supporting state attribute inspection and debugging. It works directly with the `LTSA.attr` type, which represents state attributes in the underlying transition system.",
      "description_length": 362,
      "index": 98,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Fsm.Make.M.Tree",
      "library": "lascar",
      "description": "This module represents and manipulates finite state machines as trees, where each node corresponds to a state and edges represent transitions labeled by actions. It provides operations to fold over all nodes in the tree and to visualize the tree structure using Graphviz, with customizable output options. Use cases include analyzing state transitions in protocol implementations and debugging FSM behavior through visual representation.",
      "description_length": 437,
      "index": 99,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Mealy.Make.M.Attrs",
      "library": "lascar",
      "description": "This module provides ordered map operations for associating Mealy machine states with arbitrary data, supporting insertion, deletion, lookup, and merging alongside advanced queries like key-range splitting, predicate-based filtering, and ordered traversal. It relies on state keys ordered via `Ord.compare` and handles transformations of attribute values with or without key context. Typical use cases include tracking state-specific metadata during machine analysis, merging attributes during composition, or converting sequences of state-annotated data into structured maps for efficient querying.",
      "description_length": 599,
      "index": 100,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Dfa.Product.LTSA.Attr",
      "library": "lascar",
      "description": "This module defines attributes for states in a deterministic finite automaton (DFA) product construction. It provides a `to_string` function to convert attribute values to strings, enabling clear representation of state properties during product operations. It is used to track and display metadata such as state identifiers or acceptance status when combining DFAs.",
      "description_length": 366,
      "index": 101,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lascar.Conv.ToDfa.NFA.Symbol",
      "library": "lascar",
      "description": "This module defines the symbol type used in the NFA to DFA conversion process, including operations for comparison, string representation, and access to the epsilon symbol. It works directly with the `NFA.Symbol.t` type, which represents transition labels in the automaton. Concrete use cases include determining symbol equality and ordering during state transitions, converting symbols to strings for debugging, and handling epsilon transitions during determinization.",
      "description_length": 469,
      "index": 102,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Conv.ToDfa.NFA.Attrs",
      "library": "lascar",
      "description": "This module provides a persistent map interface for managing key-value associations with `NFA.state` keys, supporting ordered traversal, functional transformations, and precise state attribute manipulation. It includes operations for constructing, querying, and combining maps with ordered key-based logic, such as merging, filtering, and sequence conversions, while preserving deterministic behavior during NFA-to-DFA conversion. These tools are specifically used to handle state attribute propagation and transition aggregation in automaton determinization processes.",
      "description_length": 569,
      "index": 103,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Nfa.Product.LTSA.Tree",
      "library": "lascar",
      "description": "This module represents trees derived from the product of two non-deterministic finite automata (NFAs) sharing the same symbol set. It provides operations to fold over tree nodes, output tree structures in DOT format, and visualize them using Graphviz. These capabilities support concrete tasks such as analyzing combined state transitions and debugging automata behavior through graphical representations.",
      "description_length": 405,
      "index": 104,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Fsm.Make.M.Attr",
      "library": "lascar",
      "description": "This module defines attributes associated with states in a finite state machine, including operations to convert attribute values to string representations. It works with the attribute type defined in the host module `M`, which typically includes state labels or metadata. Concrete use cases include attaching symbolic names or semantic properties to states for analysis, logging, or visualization purposes.",
      "description_length": 407,
      "index": 105,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Dfa.Product.LTSA.Tree",
      "library": "lascar",
      "description": "This module represents and manipulates tree structures derived from deterministic finite automata (DFA) products, using nodes and edges defined by the LTSA module. It provides operations for folding over tree nodes and visualizing trees using Graphviz, with support for custom styling and output paths. Concrete use cases include analyzing state transitions in automata products and generating visual diagnostics for tree-based automata structures.",
      "description_length": 448,
      "index": 106,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Conv.ToMoore.M.Attrs",
      "library": "lascar",
      "description": "This module provides a suite of functional map operations tailored for managing state attribute mappings during Mealy-to-Moore machine conversion. It works with `'a M.Attrs.t` maps using `M.state` keys, supporting ordered traversal, key-based queries (like min/max extraction), and transformations (including merging and predicate-based filtering). These operations enable precise manipulation of state-labeled data, such as aggregating transitions or normalizing attributes during the conversion process.",
      "description_length": 505,
      "index": 107,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Conv.ToMoore.M.Attr",
      "library": "lascar",
      "description": "This module implements the conversion of Mealy machine attributes to Moore machine attributes by providing a `to_string` function for attribute representation. It operates on the `M.Attr.t` type, which represents the attributes associated with states or transitions in a Moore machine. A concrete use case is enabling consistent string serialization of machine attributes during the conversion process from Mealy to Moore machines.",
      "description_length": 431,
      "index": 108,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Mealy.Make.M.Attr",
      "library": "lascar",
      "description": "This module provides operations to manipulate attributes of transitions in a Mealy machine, specifically handling boolean valuations of input and output variables. It includes functions like `to_string` for converting attribute values into string representations. Use cases include inspecting or logging transition behavior based on input-output conditions during machine execution.",
      "description_length": 382,
      "index": 109,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Nfa.Product.States.Elt",
      "library": "lascar",
      "description": "This module represents individual states in the product of two NFAs, supporting comparison and string conversion operations. It works with state elements that are ordered and printable, enabling precise state tracking and debugging. Concrete use cases include constructing and analyzing combined automata states during NFA product computations.",
      "description_length": 344,
      "index": 110,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Dfa.Make.States.Elt",
      "library": "lascar",
      "description": "This module represents individual states within a deterministic finite automaton (DFA). It provides operations for comparing states and converting them to strings, working directly with state identifiers as defined by the `States` module. It is used to uniquely identify and manipulate DFA states during automaton construction and traversal.",
      "description_length": 341,
      "index": 111,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lascar.Ltsa.IProduct3.States.Elt",
      "library": "lascar",
      "description": "This module represents elements of the state space in a product of three labeled transition systems with attributes. It provides comparison and string conversion operations for states, enabling ordered processing and debugging output. It is used to manipulate and analyze combined system states in formal verification tasks.",
      "description_length": 324,
      "index": 112,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lascar.Dfa.Make.NFA.Attr",
      "library": "lascar",
      "description": "This module defines attributes for states in a non-deterministic finite automaton (NFA), where each state is associated with a boolean value indicating acceptance status. It provides functions to create, modify, and query state attributes, specifically tailored for use in constructing and analyzing automata with binary state properties. A concrete use case is tracking final versus non-final states during automaton minimization or equivalence checking.",
      "description_length": 455,
      "index": 113,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Conv.ToMealy.M.State",
      "library": "lascar",
      "description": "This module defines the state representation and operations for converting a Moore machine to a Mealy machine. It includes functions for comparing states and converting state values to strings, working directly with the state type of the machine. It is used to facilitate state manipulation and ensure consistent ordering and string representation during the conversion process.",
      "description_length": 378,
      "index": 114,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Nfa.Make.States.Elt",
      "library": "lascar",
      "description": "This module represents individual states within a non-deterministic finite automaton. It provides operations for comparing and converting state identifiers to strings. It works directly with the state type defined in the parent NFA structure, enabling concrete manipulation of state elements in automata transitions and evaluations.",
      "description_length": 332,
      "index": 115,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lascar.Dfa.Product.NFA.State",
      "library": "lascar",
      "description": "This module represents states of a non-deterministic finite automaton (NFA) used in product operations over shared symbol sets. It provides `compare` for total ordering of states and `to_string` for string representation, enabling set operations and debugging. These functions directly support manipulation and analysis of NFA states during product automaton construction and traversal.",
      "description_length": 386,
      "index": 116,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lascar.Conv.Fsm.M.State",
      "library": "lascar",
      "description": "This module defines operations for comparing and converting state identifiers in a finite state machine. It works with the `M.State.t` type, providing a total ordering function for states and a string representation. These functions enable state manipulation in transformation processes, such as sorting or displaying states during FSM analysis or conversion tasks.",
      "description_length": 365,
      "index": 117,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lascar.Fsm.Make.M.State",
      "library": "lascar",
      "description": "Implements a finite state machine state with a total ordering function for state comparison and a string conversion function. Works directly with the state type defined in the parent FSM module. Used to define and manipulate individual states within a finite state machine, enabling state transitions and equality checks.",
      "description_length": 321,
      "index": 118,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Nfa.Make.LTSA.States",
      "library": "lascar",
      "description": "This module provides a rich set of **ordered set operations** for managing collections of NFA states (`LTSA.state`), including set algebra (union, intersection, difference), element-wise transformations (`map`, `filter_map`), subset queries, and ordered traversal mechanisms (forward/reverse iteration, range queries). It works with the `LTSA.States.t` structure, an ordered set container for state identifiers, and emphasizes precise manipulation of state sets in automata algorithms like subset construction or reachability analysis. Specific capabilities like power set generation, extremal element extraction, and sequence-based conversions support tasks requiring hierarchical state exploration or symbolic representation in formal verification workflows.",
      "description_length": 760,
      "index": 119,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lascar.Conv.ToMoore.M.State",
      "library": "lascar",
      "description": "This module defines the state representation for the target Moore machine during conversion from a Mealy machine. It includes operations for comparing states structurally and converting them to string representations. It is used internally to manage state equivalence and labeling during the transformation process.",
      "description_length": 315,
      "index": 120,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Dfa.Make.LTSA.States",
      "library": "lascar",
      "description": "This module provides functional set operations for managing ordered collections of deterministic finite automaton states, supporting transformations like filtering, partitioning, and power set generation. It operates on a structured set type representing state collections with ordering guarantees, enabling efficient element selection (min/max), predicate-based searches, and conversions to sequences or lists. These operations are particularly useful for automata algorithms requiring precise state set manipulation, such as transition validation, subset construction, or reachability analysis.",
      "description_length": 596,
      "index": 121,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lascar.Nfa.Make.LTSA.Label",
      "library": "lascar",
      "description": "This module defines operations for comparing and converting label values to strings in a labeled transition system. It works with the label type `t` as defined by the LTSA structure, which represents transition labels in an NFA. Concrete use cases include ordering labels for deterministic traversal and generating string representations for debugging or output.",
      "description_length": 362,
      "index": 122,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Dfa.Make.LTSA.Attr",
      "library": "lascar",
      "description": "This module defines attributes for states in a deterministic finite automaton (DFA), including operations to create, manipulate, and convert attribute values to strings. It works with the `LTSA.attr` type, which represents state attributes such as labels or metadata. Concrete use cases include attaching display names or semantic information to DFA states for analysis or visualization.",
      "description_length": 387,
      "index": 123,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Conv.ToMealy.M.Attr",
      "library": "lascar",
      "description": "Handles attribute transformations during the conversion of Moore machines to Mealy machines. Provides a `to_string` function to serialize attribute values, specifically working with the `M.Attr.t` type. Useful for debugging or logging attribute states during machine conversion.",
      "description_length": 278,
      "index": 124,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Conv.ToDfa.NFA.State",
      "library": "lascar",
      "description": "This module represents states in a non-deterministic finite automaton (NFA) during the determinization process. It provides a total ordering function for comparing states and a string conversion function for state representation. These operations support the conversion of NFA states into a deterministic finite automaton (DFA) by enabling set operations and state labeling.",
      "description_length": 374,
      "index": 125,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Fsm.Make.M.States",
      "library": "lascar",
      "description": "This module specializes in managing finite state machine states as ordered sets, offering functional set operations including union, intersection, and difference, alongside ordered transformations like filtering, partitioning, and element selection. It supports conversion to and from lists and sequences, facilitates mapping over elements, and generates power sets or string representations for analysis. These capabilities are particularly suited for tasks such as verifying state invariants, exploring reachable states, or manipulating hierarchical state structures in a functional manner.",
      "description_length": 592,
      "index": 126,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Nfa.Product.LTSA.Label",
      "library": "lascar",
      "description": "This module defines operations for comparing and converting to strings the label type used in the product of two NFAs. It works directly with the `LTSA.label` type, providing a total ordering function and a string representation. These functions enable efficient label manipulation when computing and analyzing NFA products, such as in state exploration or equivalence checking.",
      "description_length": 378,
      "index": 127,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Conv.ToLts.Repr.Label",
      "library": "lascar",
      "description": "This module defines the label type and operations for a labeled transition system where state attributes are trivial (`unit`). It includes functions for comparing labels and converting them to strings, ensuring a total order and readable representation. These labels are used to represent transitions in a simplified LTS structure derived from a more complex input format.",
      "description_length": 372,
      "index": 128,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Conv.Fsm.M.States",
      "library": "lascar",
      "description": "This module supports manipulation of FSM state sets through standard set operations, working with ordered collections of states represented as `M.States.t`. It provides functions for transformation (mapping, filtering, partitioning), structural queries (cardinality, min/max elements), safe and unsafe element access, and conversions to sequences, lists, or string representations. These capabilities are particularly useful for analyzing state transitions, managing state subsets during FSM transformations, and generating human-readable or serializable forms of state sets.",
      "description_length": 575,
      "index": 129,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Dfa.Make.LTSA.Label",
      "library": "lascar",
      "description": "This module defines operations for comparing and converting label values to strings. It works with the `LTSA.label` type, which represents labels in a deterministic finite automaton. Concrete use cases include ordering labels for transition sorting and generating string representations for debugging or output.",
      "description_length": 311,
      "index": 130,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Conv.ToDfa.LTSA.Tree",
      "library": "lascar",
      "description": "This module implements tree-based operations for representing and visualizing labeled transition systems during deterministic finite automaton conversion. It provides `fold` for aggregating node values, `dot_output` for exporting tree structures to Graphviz format, and `dot_view` for immediate visualization. These functions operate directly on the `t` tree structure composed of `LTSA.state` nodes and `LTSA.label` edges, enabling inspection and analysis of conversion intermediates.",
      "description_length": 485,
      "index": 131,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Conv.Fsm.M.Attrs",
      "library": "lascar",
      "description": "This module manipulates finite maps over FSM state attributes, using `M.state` as ordered keys to support insertion, deletion, merging, and transformations like `map` or `filter`. It emphasizes functional persistence and ordered traversal via a comparator, with utilities for sequence-based construction (`of_seq`) and key-based queries. These operations are ideal for modifying or analyzing state metadata during FSM transformations, such as consolidating attributes or partitioning states by property.",
      "description_length": 503,
      "index": 132,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Ltsa.Product.States.Elt",
      "library": "lascar",
      "description": "This module represents individual states in a product of two Labeled Transition Systems with State Attributes (LTSA). It provides a concrete data type for state elements, along with comparison and string conversion operations. It is used to manage and manipulate combined states when computing external products of LTSAs, enabling precise state identification and ordering.",
      "description_length": 373,
      "index": 133,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lascar.Dfa.Product.NFA.Attrs",
      "library": "lascar",
      "description": "This module provides ordered map-like operations for managing state attributes in NFAs, where keys are `NFA.state` values and values hold arbitrary metadata. It supports transformations, queries, and merges over these maps, enabling use cases like tracking state properties (e.g., acceptance flags, transition metadata) and combining attributes during NFA product computations. Key features include ordered traversal, predicate-based filtering, and sequence conversions for structured attribute manipulation.",
      "description_length": 508,
      "index": 134,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lascar.Conv.ToLts.Repr.Attr",
      "library": "lascar",
      "description": "This module defines the attribute type used in the intermediate representation during conversion from `Ltsa` to `Lts`, where state attributes are stripped and represented as `unit`. It includes a `to_string` function for converting attribute values to strings, primarily used for debugging or logging during the conversion process. The module ensures consistent handling of state attributes when transforming labeled transition systems.",
      "description_length": 436,
      "index": 135,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Conv.ToDfa.NFA.Symbols",
      "library": "lascar",
      "description": "This module supports functional manipulation of ordered symbol sets used in automata conversion tasks, offering operations like union, intersection, and ordered traversal. It works with persistent `NFA.Symbols.t` sets containing elements of type `NFA.Symbols.elt`, leveraging their ordered structure for deterministic processing. These functions are critical for determinization workflows, such as aggregating transition labels or analyzing symbol coverage when converting NFA states to deterministic equivalents.",
      "description_length": 513,
      "index": 136,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Conv.ToMealy.M.Attrs",
      "library": "lascar",
      "description": "This module provides map manipulation and transformation operations for state-indexed attributes during the conversion of Moore machines to Mealy machines. It works with ordered maps parameterized over `M.state` keys and arbitrary value types, supporting persistent updates through functions like `add`, `update`, and `merge`, as well as iteration and inspection via `fold` and `cardinal`. These operations are used to track and transform state-based metadata, such as labels or transition properties, while preserving immutability during the conversion process.",
      "description_length": 562,
      "index": 137,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Dfa.Product.NFA.Label",
      "library": "lascar",
      "description": "This module defines the label type used for transitions in a non-deterministic finite automaton (NFA), along with comparison and string conversion operations. It ensures a total ordering of labels via the `compare` function, enabling efficient state transition management. These labels represent input symbols and are essential for constructing and manipulating NFA-based automata models.",
      "description_length": 388,
      "index": 138,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lascar.Ltsa.IProduct.States.Elt",
      "library": "lascar",
      "description": "This module represents elements of the state space resulting from the internal product of two labeled transition systems with state attributes. It provides a total ordering function for comparing state elements and a string conversion function for representation. These operations support concrete use cases such as state enumeration, comparison-based algorithms, and debugging output generation.",
      "description_length": 396,
      "index": 139,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lascar.Dfa.Make.NFA.Symbol",
      "library": "lascar",
      "description": "This module defines the symbol type used in non-deterministic finite automata (NFA), including operations for comparison, string representation, and a special epsilon symbol. It works with the NFA's transition logic, enabling symbol handling during automaton construction and execution. Concrete use cases include representing input characters, managing epsilon transitions, and ensuring consistent symbol ordering for deterministic conversion.",
      "description_length": 444,
      "index": 140,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Conv.ToMealy.M.Label",
      "library": "lascar",
      "description": "This module defines a total ordering and string conversion for Mealy machine labels derived from a Moore machine. It operates specifically on the label type `M.Label.t`, enabling comparison and readable representation of transition labels. These functions are essential for maintaining label consistency during the conversion from Moore to Mealy machines.",
      "description_length": 355,
      "index": 141,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Fsm.Make.M.Label",
      "library": "lascar",
      "description": "This module defines the label type for transitions in a finite state machine, along with a total ordering and string conversion for labels. It works directly with the label type from the `M` module, enabling comparison and display of transition labels. Concrete use cases include identifying and sorting transitions based on their labels during FSM construction or analysis.",
      "description_length": 374,
      "index": 142,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Conv.Fsm.M.Label",
      "library": "lascar",
      "description": "This module defines a total ordering and string conversion for transition labels in a finite state machine. It works directly with the label type of the machine, enabling comparison and readable representation of labels. These operations support tasks like label normalization, deterministic traversal, and logging of transitions.",
      "description_length": 330,
      "index": 143,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Conv.ToLts.Repr.Attrs",
      "library": "lascar",
      "description": "This module provides finite map operations for associating states with arbitrary values, supporting ordered key-based transformations and safe access patterns. It works with map-like structures over `Repr.state` keys, leveraging key ordering for range operations and sequence conversions. Specific use cases include attribute management during LTS(A) to LTS conversion and handling state-labeled data transformations with precise key-value manipulation.",
      "description_length": 453,
      "index": 144,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lascar.Dfa.Make.LTSA.Attrs",
      "library": "lascar",
      "description": "This module supports functional manipulation of ordered key-value maps (`LTSA.Attrs.t`) with keys derived from LTSA state identifiers and arbitrary value types. It provides operations for safe querying (e.g., min/max access, split-by-key), transformation (mapping, filtering, merging), and sequence conversion, leveraging structural sharing to optimize immutability. These maps are particularly useful for managing state attributes in deterministic finite automata where ordered key access or efficient incremental updates are required, such as tracking transition metadata or state properties.",
      "description_length": 594,
      "index": 145,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Conv.ToDfa.NFA.States",
      "library": "lascar",
      "description": "This module provides operations for managing ordered sets of NFA states, supporting set-theoretic manipulations (union, intersection, difference, membership checks), element selection (min, max, arbitrary), and structural transformations (filtering, partitioning, power set construction). It works with `NFA.States.t` sets, leveraging a total ordering for deterministic processing, and includes utilities for converting between sets, lists, and sequences. These capabilities are essential for tracking state subsets during NFA-to-DFA conversion, enabling precise subset construction and transition relation computation.",
      "description_length": 619,
      "index": 146,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Nfa.Product.LTSA.Attrs",
      "library": "lascar",
      "description": "This module provides ordered finite map operations for managing state attributes in automata products, supporting key-based transformations and ordered traversals. It works with polymorphic maps associating `LTSA.state` keys to arbitrary values, leveraging a fixed key ordering for efficient attribute manipulation during automata composition. These operations are specifically used to handle state metadata when computing intersections or products of NFAs, enabling precise attribute propagation and querying across combined automata structures.",
      "description_length": 546,
      "index": 147,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lascar.Conv.ToDfa.NFA.Attr",
      "library": "lascar",
      "description": "Handles conversion of NFA attributes to string representations during determinization. Works directly with `NFA.Attr.t`, which is a boolean type. Used to label DFA states with strings derived from NFA transitions in the conversion process.",
      "description_length": 239,
      "index": 148,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Lts.Product3.Repr.States",
      "library": "lascar",
      "description": "This module supports set operations and transformations on composite states formed from the product of three labeled transition systems, handling 3-tuples of individual states as elements. It provides efficient set manipulation primitives like union, intersection, and filtering, along with ordered iteration, cardinality queries, and conversions to lists/sequences, all maintaining a strict ordering via `Ord.compare`. These capabilities are particularly useful for state space exploration tasks in formal verification, where tracking combinations of concurrent system states across multiple LTS components is required.",
      "description_length": 620,
      "index": 149,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Nfa.Make.LTSA.Attrs",
      "library": "lascar",
      "description": "This module provides a suite of functional, persistent map operations for managing state attributes in a labeled transition system, where keys are states ordered by a comparator and values are arbitrary data. It supports creation from sequences, ordered traversal, key-based queries (min/max/choose), value transformations, and merging of attribute maps. These operations are particularly useful for tasks like tracking state metadata in automata processing, aggregating transitions, or implementing analysis algorithms that require ordered state attribute manipulation.",
      "description_length": 570,
      "index": 150,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lascar.Mealy.Make.M.States",
      "library": "lascar",
      "description": "This module provides comprehensive set-theoretic operations and transformations for analyzing collections of Mealy machine states, including union, intersection, filtering, and ordered element access. It works with `M.States.t` sets containing comparable `M.state` elements, leveraging ordered set semantics via `Ord.compare` for correctness. These functions are particularly useful in formal verification tasks like state-space exploration, invariant checking, and model refinement workflows.",
      "description_length": 493,
      "index": 151,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Dfa.Product.LTSA.States",
      "library": "lascar",
      "description": "This module provides a rich set of operations for manipulating ordered sets of automaton states, including union, intersection, difference, filtering, and power set computation. It works with `LTSA.States.t` sets containing `LTSA.state` elements, leveraging their ordered structure for efficient iteration, predicate-based queries, and deterministic processing. These operations are critical for constructing and analyzing product automata, particularly during state space exploration and debugging of deterministic finite automata interactions.",
      "description_length": 545,
      "index": 152,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Lts.Make.Repr.Attr",
      "library": "lascar",
      "description": "This module defines the type `t` for state attributes in a labeled transition system where attributes are represented as strings. It provides a conversion function `to_string` for transforming attribute values into their string representations. This is used to handle state annotations in transition systems where attributes are not needed for computation but serve as metadata or labels.",
      "description_length": 388,
      "index": 153,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Lts.Product.Repr.Attr",
      "library": "lascar",
      "description": "This module defines the attribute type and conversion to string for states in a labeled transition system where attributes are units. It provides the `to_string` function to represent unit attributes as strings. Use this module when you need to serialize or display state attributes in a product LTS computation.",
      "description_length": 312,
      "index": 154,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lascar.Nfa.Product.LTSA.State",
      "library": "lascar",
      "description": "This module represents states in the product of two NFAs, supporting comparisons and string conversions for state identification. It works with labeled transition systems where states are combined across automata using a product construction. Concrete use cases include modeling joint behavior of concurrent finite automata and analyzing combined state spaces for verification tasks.",
      "description_length": 383,
      "index": 155,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Fsm.Make.States.Elt",
      "library": "lascar",
      "description": "This module represents individual states within a finite state machine, providing a typed element structure for state management. It includes operations for comparing states and converting them to string representations. It is used to define and manipulate distinct state values within a state machine's transition logic.",
      "description_length": 321,
      "index": 156,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Conv.ToMealy.States.Elt",
      "library": "lascar",
      "description": "This module defines the data type and operations for elements representing states in the conversion of Moore machines to Mealy machines. It includes a total ordering function for state comparison and a string conversion function for state representation. These are used to manage and manipulate state identifiers during the machine conversion process.",
      "description_length": 351,
      "index": 157,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Ltsa.Make.States.Elt",
      "library": "lascar",
      "description": "This module represents individual states in a Labeled Transition System with State Attributes. It provides operations for comparing states and converting them to strings, working with the state type defined in `States.elt`. It is used to manage and manipulate state elements within the LTS, ensuring ordering and string representation for identification and comparison in transition logic.",
      "description_length": 389,
      "index": 158,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Conv.FromLts.States.Elt",
      "library": "lascar",
      "description": "This module defines operations for comparing and converting state elements when transforming a Labeled Transition System (LTS) into an attributed LTS (LTSA). It provides a total ordering function `compare` and a string conversion function `to_string` for state elements. These functions are used to handle state identity and labeling during the conversion process.",
      "description_length": 364,
      "index": 159,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Dfa.Make.LTSA.State",
      "library": "lascar",
      "description": "This module represents and manipulates states within a deterministic finite automaton (DFA). It provides operations for comparing states using a total ordering and converting states to string representations. These functions are used to manage state identities during DFA construction and transitions, ensuring correct state handling and ordering.",
      "description_length": 347,
      "index": 160,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lascar.Nfa.Make.LTSA.Attr",
      "library": "lascar",
      "description": "This module represents attributes associated with transitions in a non-deterministic finite automaton. It defines the data type for transition labels and includes a function to convert these labels to strings. It is used to manipulate and display the symbolic annotations on transitions within the automaton structure.",
      "description_length": 318,
      "index": 161,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Dfa.Product.NFA.States",
      "library": "lascar",
      "description": "This module provides functional set operations and transformations for managing ordered collections of NFA states, supporting tasks like union, intersection, filtering, and power set computation. It works with immutable sets of states (`NFA.States.t`) and their individual elements (`NFA.States.elt`), leveraging ordered traversal and predicate-based manipulation for deterministic state transitions. Key use cases include handling state combinations during product constructions, performing efficient membership checks, and generating sequences or string representations for state sets in automata analysis.",
      "description_length": 608,
      "index": 162,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Conv.ToLts.Repr.State",
      "library": "lascar",
      "description": "This module represents states in a labeled transition system after conversion to a form with unit-typed attributes. It provides a total ordering function for state comparison and a string conversion function for state representation. These operations support state manipulation and inspection in transition system transformations where attribute data is discarded.",
      "description_length": 364,
      "index": 163,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Dfa.Product.NFA.Attr",
      "library": "lascar",
      "description": "This module implements operations for computing and manipulating the product of two non-deterministic finite automata (NFAs) that share the same input symbol set. It works with NFA data structures that include state attributes of type `bool`, and it provides functions to combine transitions and states based on their symbols and attribute values. A concrete use case is verifying the intersection of two regular languages by constructing their product automaton and checking reachability of accepting states.",
      "description_length": 509,
      "index": 164,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Nfa.Make.LTSA.State",
      "library": "lascar",
      "description": "This module represents states in a non-deterministic finite automaton (NFA) as labeled transition system states, providing comparison and string conversion operations. It works with state identifiers as abstract data types, supporting structural equality and ordering. Concrete use cases include tracking and comparing NFA states during automaton construction, traversal, or minimization.",
      "description_length": 388,
      "index": 165,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Conv.ToMoore.M.Label",
      "library": "lascar",
      "description": "This module defines a total ordering and string representation for the label type used in the conversion of Mealy machines to Moore machines. It ensures labels can be compared and displayed consistently during the transformation process. Concrete use cases include enabling efficient label-based state merging and ensuring determinism in the resulting Moore machine.",
      "description_length": 366,
      "index": 166,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lascar.Lts.Product3.Repr.Attr",
      "library": "lascar",
      "description": "This module defines the attribute type and conversion function for a product of three labeled transition systems. It specifies how state attributes are represented and rendered as strings. It is used to manage and display attributes in composite transition systems derived from three input systems.",
      "description_length": 298,
      "index": 167,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Conv.Fsm.M.Attr",
      "library": "lascar",
      "description": "This module defines attributes associated with finite state machine (FSM) states or transitions, primarily working with the `M.attr` type. It includes operations to convert these attributes to string representations, enabling visualization or logging. Concrete use cases include debugging FSM transformations and generating human-readable output for state or transition metadata.",
      "description_length": 379,
      "index": 168,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Moore.Make.M.Tree",
      "library": "lascar",
      "description": "This module implements tree-based Moore machines with operations to fold over nodes and visualize trees using Graphviz. It works with trees composed of nodes and labeled edges, structured as either empty or a node with a list of subtrees and associated edge labels. Use cases include modeling state transitions with hierarchical structures and visualizing the tree's structure for debugging or documentation purposes.",
      "description_length": 417,
      "index": 169,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Conv.ToDfa.NFA.Label",
      "library": "lascar",
      "description": "This module defines the label type and operations used in the conversion of non-deterministic finite automata (NFA) to deterministic finite automata (DFA). It provides a total ordering function and a string conversion function for NFA labels, enabling efficient comparison and representation during determinization. These functions are essential for tracking and merging states with equivalent label transitions in the resulting DFA.",
      "description_length": 433,
      "index": 170,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Conv.ToMoore.Attr",
      "library": "lascar",
      "description": "Performs attribute conversion during the transformation of Mealy machines to Moore machines. It maps Mealy machine outputs to corresponding Moore machine attributes using a bijective value type. This module ensures output values are correctly associated with states in the resulting Moore machine.",
      "description_length": 297,
      "index": 171,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Dfa.Product.NFA",
      "library": "lascar",
      "description": "This module provides operations for constructing and analyzing product automata through reachability checks, attribute manipulation, and structural transformations. It works with non-deterministic finite automata (NFAs) that share a common symbol set, using states, transitions, and attribute maps to model and traverse their graph structures. Specific use cases include formal verification tasks like intersection analysis and system behavior modeling, where combining automata or visualizing execution paths is required.",
      "description_length": 522,
      "index": 172,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lascar.Ltsa.Make.State",
      "library": "lascar",
      "description": "This module represents states in a labeled transition system with attributes. It defines operations for comparing and converting states to strings, working with a type `t` that models individual states. Concrete use cases include managing state identities in model checking algorithms and enabling state-based analysis in formal verification tasks.",
      "description_length": 348,
      "index": 173,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Conv.ToLts.Repr",
      "library": "lascar",
      "description": "This module provides operations to convert labeled transition systems with state attributes (LTS(A)) into simplified LTS structures by discarding state attributes, manipulate transitions and states through graph-like operations (e.g., adding/removing states, computing predecessors/successors, reachability checks), and generate visualizations (e.g., `.dot`, `.tex`). It works with LTS representations where state attributes are unit-typed, using modules for state sets, transition maps, and execution trees to support tasks like model simplification, structural analysis, and visualization. Specific use cases include stripping attributes during conversion, pruning unreachable states, and producing graphical representations of system behavior.",
      "description_length": 746,
      "index": 174,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lascar.Ltsa.Make.States",
      "library": "lascar",
      "description": "This module provides set-theoretic operations, ordered traversal, and transformation utilities for managing collections of states in a labeled transition system with attributes. It supports creation, modification, and analysis of state sets through functions like union, filtering, and predicate-based iteration, all operating on ordered elements within the `States.t` structure. These capabilities enable tasks such as state space exploration, attribute-driven subset selection, and efficient reachability analysis in formal verification workflows.",
      "description_length": 549,
      "index": 175,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Fsm.Make.Attr",
      "library": "lascar",
      "description": "This module defines attributes for finite state machines using integer valuations. It provides operations to create, manipulate, and convert attribute values to strings. Concrete use cases include labeling transitions or states with numeric metadata for analysis or serialization.",
      "description_length": 280,
      "index": 176,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Nfa.Make.Symbol",
      "library": "lascar",
      "description": "This module defines the symbol type and operations for an NFA, including a total ordering function for symbols, a string conversion function, and a distinguished epsilon symbol. It works with the symbol type used in transitions of the NFA. Concrete use cases include representing input characters, managing epsilon transitions, and enabling ordered comparisons for efficient automaton operations.",
      "description_length": 396,
      "index": 177,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Ltsa.Product.States",
      "library": "lascar",
      "description": "This module provides set operations for managing product states derived from two Labeled Transition Systems with State Attributes, including union, intersection, difference, and transformations via filtering, mapping, and partitioning. It works with ordered state sets (`States.t`) and supports conversions to lists, sequences, and string representations, while enabling queries for extremal elements or predicate-based membership. Key use cases include analyzing combined state transitions, computing power sets for verification tasks, and extracting subsets of states with specific attributes for further processing.",
      "description_length": 618,
      "index": 178,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Dfa.Product.Attr",
      "library": "lascar",
      "description": "Implements attribute handling for product DFAs, where each state pair is associated with a boolean value indicating combined acceptance status. Provides functions to retrieve and display these boolean attributes, which represent the intersection of acceptance conditions from the two input DFAs. Used to determine final states in the product automaton by combining the acceptance criteria of two DFAs.",
      "description_length": 401,
      "index": 179,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lascar.Nfa.Product.States",
      "library": "lascar",
      "description": "This module provides a suite of operations for managing sets of combined NFA states arising from product automata, supporting standard set manipulations (union, intersection, difference), ordered element traversal, and transformation utilities. It works with a concrete set type built from `Stdlib.Set.Make`, where elements represent individual states in a product NFA, and includes functions for power set computation, predicate-based filtering, and conversion to sequences or strings. These tools are particularly useful for tasks like constructing product automata transitions, analyzing reachable states, or implementing algorithms that require tracking combinations of states across two NFAs.",
      "description_length": 697,
      "index": 180,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Lts.Make.Repr",
      "library": "lascar",
      "description": "This module implements labeled transition systems with unit-typed state attributes, offering operations to construct, analyze, and visualize state machines. It includes data structures for states, transitions, and their relationships, enabling reachability checks, graph traversal, and transformations like pruning unreachable nodes or generating DOT/LaTeX visualizations. Use cases include modeling system behaviors, verifying properties such as accessibility, and documenting state machine structures through graphical outputs.",
      "description_length": 529,
      "index": 181,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lascar.Lts.Product3.Label",
      "library": "lascar",
      "description": "This module defines the label type and operations for a labeled transition system, including a total ordering function for comparing labels and a conversion to string for display. It works directly with the `label` type, providing necessary functionality for managing transitions in a product of three LTS. Concrete use cases include synchronizing transitions across multiple systems and comparing or displaying transition labels in formal verification tasks.",
      "description_length": 459,
      "index": 182,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Mealy.Make.M",
      "library": "lascar",
      "description": "This module provides operations for constructing and analyzing labeled transition systems with input-output labeled transitions, supporting structural queries (state reachability, transition navigation), attribute manipulation, and hierarchical data organization via sets, maps, and trees. It works with states, transitions, and attributes annotated with boolean valuations, enabling tasks like formal verification of system behavior, model transformation through state graph modifications, and automated generation of visualizations for analysis workflows. Specific capabilities include traversing execution paths, mapping state properties, and exporting models to graphical formats like `.dot` for documentation or debugging.",
      "description_length": 727,
      "index": 183,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lascar.Ltsa.IProduct3.Label",
      "library": "lascar",
      "description": "This module defines the label type and operations for comparing and converting labels to strings. It supports the internal product computation of three LTSA by providing necessary label handling functionality. Use cases include managing transition labels during LTSA composition and generating string representations for analysis or debugging.",
      "description_length": 343,
      "index": 184,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Fsm.Make.M",
      "library": "lascar",
      "description": "This module provides operations for analyzing, transforming, and visualizing labeled transition systems through state and transition manipulation, attribute access, and structural queries. It works with finite state machines composed of states, transitions, initial states, and associated attributes, organized into sets and tree-based representations. Specific use cases include reachability analysis, FSM simplification via unreachable state removal, execution tree unwinding, and generating graphical visualizations with customizable formatting.",
      "description_length": 548,
      "index": 185,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Moore.Make.Tree",
      "library": "lascar",
      "description": "This module implements tree-based Moore machines with nodes representing states and edges labeled with boolean values. It provides operations to fold over all nodes and visualize trees using Graphviz, with customizable output styles. Use cases include modeling state transitions in formal verification and generating visual representations of state machines for analysis.",
      "description_length": 371,
      "index": 186,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Moore.Make.Label",
      "library": "lascar",
      "description": "This module defines the label type and operations for Moore machines, including a total ordering function for labels and a string conversion function. It works with the label type `Label.t` used in Moore machine transitions and states. Concrete use cases include comparing labels to maintain ordered sets and converting labels to strings for display or logging.",
      "description_length": 361,
      "index": 187,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Dfa.Make.Label",
      "library": "lascar",
      "description": "This module defines the label type and operations for transitions in a deterministic finite automaton. It includes functions for comparing labels and converting them to strings, ensuring a total order for correct transition handling. It is used to manage symbol-based transitions within the DFA structure.",
      "description_length": 305,
      "index": 188,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lascar.Lts.IProduct.States",
      "library": "lascar",
      "description": "This module provides a rich set of **ordered set operations** for managing collections of states in labeled transition systems, including transformations like union, intersection, and mapping, as well as queries for membership, ordering, and extremal elements. It operates on a concrete set type built from `Stdlib.Set.Make`, with elements ordered via `Ord.compare`, and supports conversions to/from lists and sequences for iterative processing. These operations are particularly useful for tasks like merging state spaces during LTS synchronization or analyzing reachable states through efficient set-theoretic computations.",
      "description_length": 625,
      "index": 189,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lascar.Ltsa.Product.Tree",
      "library": "lascar",
      "description": "This module represents trees for modeling state transitions in LTSA systems, with nodes as states and edges as labeled transitions. It supports operations like folding over nodes and visualizing trees using Graphviz, enabling concrete use cases such as analyzing hierarchical state structures and generating visual diagnostics of transition trees. The tree structure is used to represent product combinations of LTSA models, facilitating exploration and debugging of complex state spaces.",
      "description_length": 488,
      "index": 190,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Nfa.Product.Label",
      "library": "lascar",
      "description": "This module defines the label type and operations used in the product of two NFAs. It provides a total ordering function for comparing labels and a string conversion function for debugging or output. These functions are essential for constructing and manipulating the combined transition system of two NFAs over a shared symbol set.",
      "description_length": 332,
      "index": 191,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lascar.Ltsa.Make.Attrs",
      "library": "lascar",
      "description": "This module implements finite maps with ordered state keys and polymorphic values, enabling efficient dictionary operations like insertion, deletion, and lookup, as well as ordered transformations, filtering, and sequence conversions. It supports deterministic traversal and manipulation of state-attribute associations through key ordering constraints, with utilities for bulk operations and custom equality checks. Such structures are particularly useful for modeling state attributes in labeled transition systems where ordered key handling ensures consistent analysis.",
      "description_length": 572,
      "index": 192,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Mealy.Make.States",
      "library": "lascar",
      "description": "This module offers a functional set interface for managing collections of Mealy machine states with ordered elements, supporting operations like union, intersection, filtering, and folding. It works with `States.t` sets backed by an ordered element module (`Elt`), enabling efficient membership checks, ordered traversal, and transformations to sequences or strings. Typical use cases include tracking reachable states, partitioning state spaces for minimization, and extracting subsets matching specific transition criteria in formal verification workflows.",
      "description_length": 558,
      "index": 193,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lascar.Dfa.Make.Attr",
      "library": "lascar",
      "description": "This module defines attributes for states in a deterministic finite automaton (DFA), where each state is associated with a boolean value indicating acceptance status. It provides functions to create, query, and convert these attributes to strings. Use cases include labeling states as accepting or non-accepting during DFA construction and displaying state properties in debugging or visualization tools.",
      "description_length": 404,
      "index": 194,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lascar.Moore.Make.M",
      "library": "lascar",
      "description": "This module provides operations for constructing, analyzing, and transforming labeled transition systems with attributes, emphasizing state management, transition navigation, and attribute manipulation. It operates on abstract representations of states, labels, attributes, and transitions, enabling tasks like reachability analysis, model simplification via pruning of unreachable states, and generating graphical visualizations (e.g., `.dot` or `.tex` formats) for system inspection and debugging.",
      "description_length": 499,
      "index": 195,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Lts.Product.Repr",
      "library": "lascar",
      "description": "This module provides operations for constructing, modifying, and analyzing labeled transition systems (LTS) with unit-typed state attributes, emphasizing product constructions and structural transformations. It works with sets of states, tree-based visualizations, and mappings for labels and attributes, enabling use cases like modeling concurrent systems through product LTS and generating customizable `.dot` or `.tex` diagrams for analysis. Key functionalities include transition navigation, state property checks (e.g., reachability), and iterative transformations to refine or unwind transition graphs.",
      "description_length": 608,
      "index": 196,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Ltsa.IProduct3.Attr",
      "library": "lascar",
      "description": "This module defines the attribute type and string conversion for the internal product of three LTSA. It supports combining state attributes across three systems using a specific product flavor. The `to_string` function provides a textual representation of the resulting product attributes.",
      "description_length": 289,
      "index": 197,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lascar.Fsm.Make.States",
      "library": "lascar",
      "description": "This module provides functional set operations and transformations for managing finite collections of ordered states, supporting union, intersection, difference, and subset checks alongside filtering, partitioning, and predicate-based queries. It works with abstract state sets ordered via a comparison function, enabling operations like mapping over elements, generating power sets, converting to and from sequences, and extracting extrema or specific elements. These utilities are used for tasks such as state traversal, hierarchical set manipulation, and analysis within finite state machine workflows.",
      "description_length": 605,
      "index": 198,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Lts.IProduct.Label",
      "library": "lascar",
      "description": "This module defines the label type and operations for comparing and converting labels to strings in the context of internal product computations of labeled transition systems. It supports the combination of two LTS by providing a structured way to handle label interactions through ordering and string representation. Concrete use cases include synchronizing transitions based on label equality and displaying labels for analysis or debugging purposes.",
      "description_length": 452,
      "index": 199,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lascar.Conv.ToDfa.Attr",
      "library": "lascar",
      "description": "Handles attribute conversion during NFA-to-DFA transformation, specializing in boolean attributes. Converts boolean states to string representations, typically used for labeling deterministic states in the resulting DFA. Useful when determinizing automata with binary state markers, such as acceptance or rejection flags.",
      "description_length": 321,
      "index": 200,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Mealy.Make.Attr",
      "library": "lascar",
      "description": "This module implements attribute transformations for Mealy machines, focusing on operations that manipulate input-output boolean valuations. It works with transition labels composed of input and output attributes, enabling filtering, mapping, and composition of these attributes. Concrete use cases include refining machine transitions based on specific input-output conditions and extracting subsets of attributes for analysis or transformation.",
      "description_length": 446,
      "index": 201,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lascar.Ltsa.Make.Tree",
      "library": "lascar",
      "description": "Implements operations for constructing and visualizing trees representing Labeled Transition Systems with State Attributes (LTSA). It supports folding over tree nodes to aggregate values and rendering trees in DOT format for visualization. Useful for model checking and state exploration tasks where hierarchical state transitions need graphical representation.",
      "description_length": 361,
      "index": 202,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Conv.Fsm.States",
      "library": "lascar",
      "description": "This module provides finite set operations for FSM states, supporting functional manipulation through union, intersection, difference, filtering, and ordered traversal. It works with immutable sets of comparable, serializable state elements, enabling use cases like extracting subsets, generating power sets, or converting state collections to sequences for analysis and transformation workflows. Key features include safe option-based element access, partitioning, and structural inspection tailored for finite state machine processing.",
      "description_length": 537,
      "index": 203,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Dfa.Make.Symbols",
      "library": "lascar",
      "description": "This module provides set-theoretic operations and ordered set manipulation functions for managing collections of deterministic finite automaton symbols. It works with `Symbols.t` sets built from ordered elements (`Symbols.elt`), supporting transformations like union, intersection, filtering, and conversions to/from sequences or lists. These operations are particularly useful for tasks requiring precise symbol set analysis, such as automaton optimization, transition relation construction, or formal language processing workflows involving ordered symbol comparisons.",
      "description_length": 570,
      "index": 204,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lascar.Ltsa.IProduct3.State",
      "library": "lascar",
      "description": "This module represents states in a product of three labeled transition systems with attributes. It defines a type `t` for states and provides comparison and string conversion operations. It is used to manage state identities and ordering in combined transition system analyses.",
      "description_length": 277,
      "index": 205,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Lts.Product3.State",
      "library": "lascar",
      "description": "This module represents states in the product of three labeled transition systems, where each state is a tuple of three individual states. It provides a total ordering function for comparing product states and a string conversion function for debugging or logging purposes. The module is used to model combined system states in formal verification tasks, such as analyzing concurrent or interacting components.",
      "description_length": 409,
      "index": 206,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Ltsa.IProduct.Attr",
      "library": "lascar",
      "description": "This module defines attributes for states in a labeled transition system, including a `to_string` function for converting attributes to string representations. It works with state attribute data types used in LTSA models. Concrete use cases include tracking and displaying properties such as state labels, invariants, or metadata during model analysis or verification.",
      "description_length": 368,
      "index": 207,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Nfa.Make.Attr",
      "library": "lascar",
      "description": "This module implements attribute handling for states in a non-deterministic finite automaton. It provides functions to convert attribute values to strings and manage boolean state attributes. It is used to track properties such as acceptance states in automata operations.",
      "description_length": 272,
      "index": 208,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Ltsa.IProduct3.States",
      "library": "lascar",
      "description": "This module provides a functional interface for managing ordered sets of composite states arising from the product of three labeled transition systems with attributes. It supports standard set operations like union, intersection, and difference, along with ordered transformations such as filtering, partitioning, and bounded iteration over state combinations. These capabilities are particularly useful for analyzing state space intersections, extracting extremal states, or debugging product system behaviors through structured string representations.",
      "description_length": 553,
      "index": 209,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lascar.Dfa.Make.Symbol",
      "library": "lascar",
      "description": "This module defines the symbol type and operations used in a deterministic finite automaton, including comparison, string conversion, and the epsilon symbol. It provides the necessary functionality to represent and manipulate transition symbols within a DFA, ensuring they can be ordered and displayed. Concrete use cases include defining input symbols for automaton transitions and handling special epsilon moves in state transitions.",
      "description_length": 435,
      "index": 210,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Ltsa.Product3.Attr",
      "library": "lascar",
      "description": "Handles attribute manipulation for states in labeled transition systems by providing a type `t` for attribute values and a `to_string` function for serialization. Works directly with state attribute data in the context of LTSA models. Useful for converting state attributes to string representations during model analysis or output generation.",
      "description_length": 343,
      "index": 211,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Ltsa.Make.Label",
      "library": "lascar",
      "description": "This module defines the label type and operations for comparing and converting labels to strings. It works with the label data type used in the Labeled Transition System with Attributes, enabling ordering and string representation of transition labels. Concrete use cases include managing label equality, sorting transitions by label, and generating readable label output for analysis or logging.",
      "description_length": 396,
      "index": 212,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Dfa.Make.Attrs",
      "library": "lascar",
      "description": "This module provides a suite of map-based utilities for managing state-attribute associations in a deterministic finite automaton, supporting ordered keys (via a comparator) and arbitrary value types. It enables functional transformations, structural sharing, and ordered traversal of state-keyed data, with operations like folding, filtering, and merging, as well as ordered queries (e.g., min/max bindings) and sequence-based construction. These tools are particularly useful for attaching metadata to automaton states, enforcing attribute consistency during transitions, or analyzing state properties in a structured, immutable manner.",
      "description_length": 638,
      "index": 213,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Dfa.Product.States",
      "library": "lascar",
      "description": "This module offers functions for managing sets of composite states in product automata, supporting operations like union, intersection, power set generation, and ordered traversal. It works with structured state elements combining two distinct automata, represented through ordered, string-convertible types that enable precise state set manipulation. These capabilities are particularly useful for automata composition tasks, verification workflows, and scenarios requiring analysis of combined state spaces.",
      "description_length": 509,
      "index": 214,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lascar.Nfa.Product.Attrs",
      "library": "lascar",
      "description": "This module provides map-based operations for managing state-associated attributes in NFA products, supporting functional transformations like merging, filtering, and ordered traversal. It operates on key-value structures (`Attrs.t`) with ordered `state` keys and generic values, enabling use cases such as combining attributes during NFA product construction or analyzing state properties in sorted order. Specific operations include constructing maps from sequences, querying min/max elements, and splitting maps based on key ranges.",
      "description_length": 535,
      "index": 215,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Moore.Make.Attrs",
      "library": "lascar",
      "description": "This module provides map-like operations for managing persistent, ordered key-value associations where keys are states ordered via a comparator. It supports functional transformations, ordered traversal, and conditional filtering of maps, along with conversions to and from sequences. These operations are particularly useful for managing state attributes in Moore machines, enabling efficient lookups, ordered state analysis, and attribute-driven state machine transformations.",
      "description_length": 478,
      "index": 216,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lascar.Conv.FromLts.Tree",
      "library": "lascar",
      "description": "This module represents labeled transition systems as trees with nodes and edges, supporting operations to fold over tree nodes and visualize trees using Graphviz. It defines a tree structure where each node can have multiple labeled subtrees, and provides functions to output or display tree structures in `.dot` format. Use cases include visualizing state transitions in formal verification or parsing hierarchical data structures into labeled trees for analysis.",
      "description_length": 464,
      "index": 217,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Conv.Fsm.Tree",
      "library": "lascar",
      "description": "This module represents and manipulates finite state machine (FSM) transition trees, where each node corresponds to a state and edges represent transitions. It provides `fold` to accumulate values over all nodes and `dot_output` / `dot_view` to visualize the tree structure using Graphviz. Use cases include analyzing FSM structures, generating visual representations of state transitions, and debugging FSM transformations.",
      "description_length": 423,
      "index": 218,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lascar.Conv.ToMealy.M",
      "library": "lascar",
      "description": "This module facilitates the conversion of Moore machines into equivalent Mealy machines by manipulating states, transitions, and attributes through ordered sets, maps, and trees. It supports querying structural properties (e.g., reachability, initial states), transforming labeled transition systems via functional or imperative operations, and generating visualizations in `.dot` or `.tex` formats. Key use cases include model translation, formal verification tasks like state exploration, and automated documentation of automata behavior.",
      "description_length": 540,
      "index": 219,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Conv.ToMealy.Tree",
      "library": "lascar",
      "description": "This module represents trees used to model state transitions during the conversion of Moore machines to Mealy machines. It provides operations to fold over tree nodes and visualize trees using Graphviz, specifically tailored for analyzing and debugging the structure of converted transition systems. The tree structure captures hierarchical relationships between states and transitions, enabling precise control over the conversion process.",
      "description_length": 440,
      "index": 220,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lascar.Ltsa.IProduct3.Attrs",
      "library": "lascar",
      "description": "This module enables efficient manipulation of state-attribute maps with ordered keys through operations like merging, filtering, and ordered traversal. It works with finite maps where keys are states and values are polymorphic, supporting transformations from sequences and maintaining key order via comparison-based sorting. These capabilities are particularly useful for handling attribute-rich state transitions that require ordered processing or combining multiple attribute sets with precise key handling.",
      "description_length": 510,
      "index": 221,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lascar.Lts.IProduct.State",
      "library": "lascar",
      "description": "This module represents states in a labeled transition system product, providing comparison and string conversion operations. It defines a type `t` for state values and includes functions to establish a total order between states and to convert them to string representations. These operations support state management in product constructions of transition systems, particularly for model-checking and system verification tasks.",
      "description_length": 428,
      "index": 222,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Ltsa.Product3.States",
      "library": "lascar",
      "description": "This module provides efficient, immutable set operations for managing composite states formed from the product of three labeled transition systems with state attributes. It supports standard set manipulations like union, intersection, difference, and filtering, along with element selection and transformation functions tailored for ordered state representations. These operations are particularly useful in verification tasks where state spaces combine behaviors across multiple interacting systems, enabling precise analysis of complex state transitions and attribute interactions.",
      "description_length": 583,
      "index": 223,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Conv.ToDfa.NFA",
      "library": "lascar",
      "description": "This module provides operations for transforming and analyzing labeled transition systems during NFA-to-DFA determinization, focusing on subset construction, transition aggregation, and reachability analysis. It works with state-labeled automata structures that include explicit transition graphs, attribute mappings, and symbolic alphabets, using ordered sets and tree representations to manage state collections and transitions. Specific capabilities include automaton visualization (DOT/TeX), cycle detection, string acceptance checking, and structural modifications for formal verification tasks like protocol modeling and system behavior analysis.",
      "description_length": 652,
      "index": 224,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Lts.Product3.Repr",
      "library": "lascar",
      "description": "This component provides foundational tools for constructing and analyzing labeled transition systems derived from three-component products, focusing on state and transition manipulation with unit-valued attributes. It supports formal verification workflows through operations like state reachability checks, transitive closure calculations, and transition graph transformations, while also enabling visualization via graph exports. The design emphasizes efficient handling of product state spaces using specialized data structures for states, labels, transitions, and tree-based representations.",
      "description_length": 595,
      "index": 225,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Nfa.Product.State",
      "library": "lascar",
      "description": "This module represents states in the product of two NFAs, supporting comparisons and string conversions. It defines a type `t` for state identifiers and provides `compare` for ordering and `to_string` for debugging. Used internally during product automaton construction to manage combined state spaces of paired NFAs.",
      "description_length": 317,
      "index": 226,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Nfa.Product.LTSA",
      "library": "lascar",
      "description": "This module provides operations to construct and analyze products of non-deterministic finite automata (NFAs) with shared symbol sets, focusing on state and transition manipulation, attribute management, and graph traversal. It works with labeled transition systems (LTSA) represented as `LTSA.t`, which encapsulates states, transitions, initial states, and attributes, while supporting set operations, ordered maps, and tree structures. Specific use cases include verifying reachability properties, transforming automata through state mapping or pruning, and generating visualizations in formats like `.dot` and `.tex` for formal verification workflows.",
      "description_length": 654,
      "index": 227,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lascar.Dfa.Make.State",
      "library": "lascar",
      "description": "This module represents and manipulates individual states within a deterministic finite automaton. It provides operations to compare states for ordering and convert them to string representations. It works directly with the `state` type, enabling concrete identification and handling of DFA states in transitions and automaton construction.",
      "description_length": 339,
      "index": 228,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lascar.Nfa.Product.Tree",
      "library": "lascar",
      "description": "This module implements tree structures to represent product NFA states, with operations to fold over nodes and visualize trees using Graphviz. It works with nodes and edges corresponding to NFA states and transition symbols, organizing them in a tree hierarchy. Use cases include constructing and visualizing the state space of NFA products, such as for model checking or automata-based verification tasks.",
      "description_length": 406,
      "index": 229,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Conv.ToDfa.Symbol",
      "library": "lascar",
      "description": "This module defines operations for working with symbols in a deterministic finite automaton (DFA) conversion process. It provides a total ordering function for symbols, a string representation function, and a distinguished epsilon symbol representing the empty transition. These functions are used during DFA determinization to manage and compare transition labels derived from an NFA.",
      "description_length": 385,
      "index": 230,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Moore.Make.State",
      "library": "lascar",
      "description": "This module represents states in a Moore machine, providing operations to compare and convert states to strings. It works with a user-defined state type that must support a total ordering and string representation. Use this module to manage state transitions and representations in formal verification or automaton-based computations.",
      "description_length": 334,
      "index": 231,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lascar.Ltsa.IProduct.Label",
      "library": "lascar",
      "description": "This module defines operations for comparing and converting label values to strings. It works with the label type used in Labeled Transition Systems with State Attributes. Concrete use cases include ordering labels for state transitions and generating string representations for debugging or output.",
      "description_length": 299,
      "index": 232,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Mealy.Make.State",
      "library": "lascar",
      "description": "Implements state management for Mealy machines with operations to compare and convert states to strings. Works with state data types representing machine configurations. Used to define transitions and outputs based on current state and input valuations.",
      "description_length": 253,
      "index": 233,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lascar.Ltsa.Product.Attrs",
      "library": "lascar",
      "description": "This module provides map-like operations for managing state attribute mappings in LTSA structures, supporting insertion, removal, value transformations, and key-based queries. It operates on ordered maps with `state` keys and polymorphic values, enabling efficient iteration, filtering, and conversion from sequences. These capabilities are particularly useful when composing product LTSAs, where attribute maps from distinct systems must be merged, compared, or processed while preserving key ordering and structural integrity.",
      "description_length": 528,
      "index": 234,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Fsm.Make.Label",
      "library": "lascar",
      "description": "This module defines the structure and operations for labels used in finite state machines, including a total ordering function and string conversion. It works with the `Label.t` type, which represents individual labels, and supports comparison and serialization. Concrete use cases include labeling transitions in state machines and ensuring consistent ordering for deterministic behavior.",
      "description_length": 389,
      "index": 235,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Conv.ToMoore.State",
      "library": "lascar",
      "description": "This module defines the state structure and operations used in the conversion of Mealy machines to Moore machines. It provides a total ordering function for state comparison and a string conversion function for state representation. These are essential for managing state equivalence and labeling during the conversion process.",
      "description_length": 327,
      "index": 236,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Conv.ToMealy.Attrs",
      "library": "lascar",
      "description": "This module provides map-based operations for managing state-attribute associations during Moore-to-Mealy machine conversion, supporting insertion, deletion, filtering, and functional transformations over a key-value structure with ordered `Attrs.key` (state) identifiers. It works with immutable maps that enforce key ordering via `Ord.compare`, enabling efficient lookups, ordered traversals, and conversions to/from sequences, while handling missing values through `option` types. Specific use cases include merging Moore machine state attributes into Mealy transition outputs and transforming attribute mappings during intermediate conversion steps.",
      "description_length": 653,
      "index": 237,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Nfa.Product.Attr",
      "library": "lascar",
      "description": "Implements attribute handling for product NFA states, where each state pair is annotated with a boolean flag. Provides `to_string` for converting boolean attributes to string representations. Useful for tracking state properties like acceptance during product automaton construction.",
      "description_length": 283,
      "index": 238,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Lts.IProduct3.Label",
      "library": "lascar",
      "description": "This module defines the label type and operations for comparing and converting labels to strings in the context of a labeled transition system product. It supports the internal product of three LTS by providing necessary ordering and string representation for labels. Use cases include managing label equivalence and ordering during transition composition and state exploration.",
      "description_length": 378,
      "index": 239,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Conv.Fsm.M",
      "library": "lascar",
      "description": "This module provides operations for constructing, modifying, and analyzing labeled transition systems (LTSA) through state and transition management, reachability checks, attribute mapping, and execution tree unwinding. It works with states, labels, attributes, transitions, and hierarchical structures to support tasks like model validation, transformation workflows, and visualization generation in `.dot` or `.tex` formats for documentation or debugging.",
      "description_length": 457,
      "index": 240,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Conv.FromLts.State",
      "library": "lascar",
      "description": "This module defines operations for comparing and converting state identifiers in a labeled transition system. It provides a total ordering function and string conversion for state values. These functions support tasks like state enumeration, sorting, and debugging output generation.",
      "description_length": 283,
      "index": 241,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Conv.Fsm.Attr",
      "library": "lascar",
      "description": "This module defines attributes for finite state machine transitions, mapping states to string representations. It supports conversion of state values to strings using customizable formatting rules. Useful for serializing FSMs to text-based formats or generating human-readable transition tables.",
      "description_length": 295,
      "index": 242,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lascar.Conv.ToMealy.Attr",
      "library": "lascar",
      "description": "Performs attribute conversion during the transformation of Moore machines to Mealy machines. Works directly with `Attr.t` values, using the `to_string` function to handle attribute serialization. Useful for preserving and translating state labels when converting between machine types.",
      "description_length": 285,
      "index": 243,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Conv.FromLts.States",
      "library": "lascar",
      "description": "This module supports transformations, ordered iteration, and set-theoretic operations on immutable, ordered collections of state values within a Labeled Transition System. It provides utilities for filtering, partitioning, and converting state sets to sequences or lists, leveraging a total ordering of elements via `Ord.compare`. These operations are particularly useful when converting LTS structures to LTSA by enriching states with unit attributes or analyzing transitions through power set computations.",
      "description_length": 508,
      "index": 244,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Nfa.Make.State",
      "library": "lascar",
      "description": "This module represents and manipulates individual states within a non-deterministic finite automaton. It defines operations for comparing states and converting them to string representations. It is used to manage state identifiers during automaton construction and traversal, such as tracking transitions or serializing automaton structure for debugging.",
      "description_length": 354,
      "index": 245,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lascar.Conv.ToMoore.Attrs",
      "library": "lascar",
      "description": "This module provides map-like operations for managing state-attribute associations, emphasizing functional updates, ordered key traversal, and conversion from sequences. It works with key-value structures where keys are states ordered via a comparator, supporting transformations, predicate-based queries, and merging of attribute mappings. These capabilities are specifically used during Mealy-to-Moore machine conversion to track and manipulate state-specific attributes while preserving ordering constraints.",
      "description_length": 511,
      "index": 246,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Ltsa.Product.State",
      "library": "lascar",
      "description": "This module represents states in the product of two labeled transition systems with attributes. It defines a concrete type for product states and provides a total ordering and string conversion for them. It is used to construct and manipulate combined states when computing the external product of LTSA models, such as for modeling interacting state machines or composed systems.",
      "description_length": 379,
      "index": 247,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Nfa.Make.States",
      "library": "lascar",
      "description": "This module provides a functional set-theoretic interface for managing collections of NFA states, supporting operations like union, intersection, filtering, and power set generation. It works with ordered state sets (`States.t`) derived from the NFA's state identifiers, leveraging a total ordering for efficient manipulation and traversal. Key use cases include state set transformations during automaton transitions, subset-based algorithms (e.g., DFA conversion), and ordered state enumeration for analysis or serialization.",
      "description_length": 527,
      "index": 248,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Ltsa.Product3.Label",
      "library": "lascar",
      "description": "This module defines the label type and operations for comparing and converting labels to strings in the context of a product of three labeled transition systems. It supports the construction and manipulation of composite system labels by providing a total order and string representation. Concrete use cases include managing action labels during the synchronization of three concurrent state machines.",
      "description_length": 401,
      "index": 249,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Conv.ToDfa.Label",
      "library": "lascar",
      "description": "This module defines the label structure used during NFA-to-DFA conversion, providing a total ordering and string representation for symbols. It works with the `symbol` type, ensuring labels can be compared and displayed. Concrete use cases include managing transition labels in deterministic finite automata generated from nondeterministic ones.",
      "description_length": 345,
      "index": 250,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Mealy.Make.Attrs",
      "library": "lascar",
      "description": "This module provides map-like operations for managing polymorphic state-keyed key-value mappings, supporting creation, modification, and ordered traversal with combinators like `merge`, `union`, and `filter_map`. It works with persistent maps (`Attrs.t`) where keys are ordered using `Ord.compare` and values are arbitrary types, enabling efficient querying and transformation of state attributes in Mealy machines. Specific use cases include tracking state-dependent metadata, combining attribute sets with ordered key constraints, and processing sequences of state bindings into structured mappings.",
      "description_length": 601,
      "index": 251,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Conv.Fsm.Label",
      "library": "lascar",
      "description": "This module defines the structure and operations for handling transition labels in finite state machines. It includes functions for comparing labels to establish a total order and converting labels to strings for representation purposes. It directly supports transformations and analysis of FSM transitions by enabling label-based decision logic and ordered processing.",
      "description_length": 369,
      "index": 252,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lascar.Conv.FromLts.Attr",
      "library": "lascar",
      "description": "This module defines the attribute type and conversion logic for translating labeled transition systems into attributed labeled transition systems. It provides the `to_string` function to serialize attribute values, specifically working with the `attr` type derived from the `Lascar.Conv.FromLts` context. It is used when converting LTS models to include unit state attributes for compatibility with analysis tools requiring attribute annotations.",
      "description_length": 446,
      "index": 253,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Conv.ToLts.Label",
      "library": "lascar",
      "description": "This module defines operations for comparing and converting label values to strings. It works directly with the `label` type, providing a total ordering function and a string conversion function. These functions are used to facilitate label manipulation during the conversion of labeled transition systems.",
      "description_length": 306,
      "index": 254,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Nfa.Product.Symbol",
      "library": "lascar",
      "description": "This module defines the symbol type and operations used in the product of two NFAs. It includes a total ordering function for symbols, a string conversion function, and the epsilon symbol representing empty transitions. It is used to synchronize transitions between two NFAs during product construction, ensuring consistent symbol handling.",
      "description_length": 340,
      "index": 255,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Conv.ToMealy.State",
      "library": "lascar",
      "description": "This module defines the state representation and operations used in the conversion of Moore machines to Mealy machines. It includes a total ordering function for states, enabling efficient comparison and sorting, and a string conversion function for state representation. These are specifically used during the transformation process to ensure state equivalence and proper mapping between machine types.",
      "description_length": 403,
      "index": 256,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Lts.Make.State",
      "library": "lascar",
      "description": "This module represents and manipulates states in a Labeled Transition System. It provides operations for comparing states using a total order and converting states to string representations. It is used to define the behavior of state identifiers within the LTS framework, enabling state-based computations and analyses.",
      "description_length": 319,
      "index": 257,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Lts.Product.States",
      "library": "lascar",
      "description": "This module provides ordered set operations for manipulating collections of states from labeled transition systems, supporting union, intersection, difference, and predicate-based filtering while preserving order constraints. It works with a concrete set type whose elements are ordered via a comparator, enabling safe transformations like mapping, folding, and extremal element selection. Typical use cases include combining state sets from product LTS constructions, analyzing reachable states via sequence iteration, and partitioning state spaces for verification tasks.",
      "description_length": 573,
      "index": 258,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Ltsa.IProduct.States",
      "library": "lascar",
      "description": "This module provides operations for managing and transforming state sets in labeled transition systems with attributes, supporting standard set-theoretic operations, ordered traversal, and product-specific manipulations like reverse iteration and power set construction. It works with state element sets, sequences, and ordered collections, offering utilities for filtering, partitioning, and converting between data representations. These capabilities are particularly useful in formal verification scenarios requiring precise state space exploration or composition of system behaviors.",
      "description_length": 587,
      "index": 259,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lascar.Lts.Product.Label",
      "library": "lascar",
      "description": "This module defines operations for comparing and converting label values to strings in the context of labeled transition systems. It works with a type `t` representing labels on transitions. Concrete use cases include ordering labels for deterministic product computations and generating string representations for debugging or output.",
      "description_length": 335,
      "index": 260,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Ltsa.IProduct.Tree",
      "library": "lascar",
      "description": "This module represents trees for modeling state transitions in labeled transition systems with attributes. It provides operations to fold over tree nodes, generate DOT visualizations, and display them using Graphviz. These trees are used to construct and visualize hierarchical state structures in system modeling tasks.",
      "description_length": 320,
      "index": 261,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lascar.Nfa.Make.Tree",
      "library": "lascar",
      "description": "This module implements a tree-based representation of NFAs, where nodes correspond to states and edges are labeled with symbols. It provides operations to fold over the tree structure and visualize the automaton using Graphviz. Use cases include constructing and rendering hierarchical NFAs for pattern matching or parsing tasks.",
      "description_length": 329,
      "index": 262,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Ltsa.Product3.Tree",
      "library": "lascar",
      "description": "This module represents trees as labeled transition systems where nodes correspond to states and edges represent transitions. It provides operations to fold over tree nodes and visualize trees using Graphviz, with customizable output styles. Use cases include analyzing hierarchical state structures and generating visual representations of transition trees for debugging or documentation.",
      "description_length": 388,
      "index": 263,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lascar.Dfa.Product.Label",
      "library": "lascar",
      "description": "This module defines a type `t` representing transition labels in a deterministic finite automaton (DFA), along with a total ordering function `compare` for label comparison and `to_string` for label conversion to strings. It is used to manage and manipulate the symbols that drive transitions between states in a DFA. The module ensures that labels can be consistently ordered and displayed, which is essential for operations like transition lookup and state product computation.",
      "description_length": 479,
      "index": 264,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lascar.Nfa.Make.LTSA",
      "library": "lascar",
      "description": "This module provides operations for constructing, analyzing, and transforming labeled transition systems with attributes, focusing on state reachability checks, transition navigation (via successors/predecessors), attribute manipulation, and functional transformations of states, labels, and transitions. It operates on LTSA structures representing state machines with labeled transitions, initial states, and associated metadata. Specific use cases include automata-based modeling, formal verification tasks like reachability analysis, and generating visualizations (e.g., `.dot` graphs or LaTeX output) for debugging or documentation.",
      "description_length": 636,
      "index": 265,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Conv.ToDfa.Tree",
      "library": "lascar",
      "description": "This module implements a tree structure for representing state transitions during NFA-to-DFA conversion. It provides operations to fold over tree nodes and visualize trees using Graphviz. The tree structure captures states as nodes and symbols as edges, with functions to output or display the tree in `.dot` format for debugging or analysis purposes.",
      "description_length": 351,
      "index": 266,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Mealy.Make.Tree",
      "library": "lascar",
      "description": "This module implements tree structures for Mealy machines, providing operations to fold over nodes and visualize trees using Graphviz. It works with nodes representing machine states and edges as transitions with input-output valuations. Use cases include analyzing state transitions and generating visual representations of Mealy machine behavior.",
      "description_length": 348,
      "index": 267,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Nfa.Product.Symbols",
      "library": "lascar",
      "description": "This module provides ordered set operations for manipulating symbol collections in NFA product computations, supporting transformative operations like union and intersection alongside ordered iteration, filtering, and membership queries. It works with a set type implemented via `Stdlib.Set.Make`, where elements are symbols ordered by a comparator, and ensures correctness through order-aware functions like min/max extraction and sorted sequence conversions. Specific use cases include tracking transition labels across automata products, partitioning symbol sets for state synchronization, and ordered traversal of symbols during automaton composition.",
      "description_length": 655,
      "index": 268,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Nfa.Make.Attrs",
      "library": "lascar",
      "description": "This module provides functional map operations for managing state attributes in non-deterministic finite automata, including insertion, deletion, filtering, and ordered traversal. It operates on maps with ordered `state` keys and arbitrary value types `'a`, supporting key-based queries (e.g., min/max retrieval, range splits), safe and unsafe lookups, and transformations like merging or sequence conversion. These",
      "description_length": 415,
      "index": 269,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Ltsa.Make.Attr",
      "library": "lascar",
      "description": "This module defines operations for managing state attributes in a labeled transition system, including creating, updating, and converting attributes to strings. It works with the attribute type `Attr.t` and integrates with transition systems represented as graphs. Concrete use cases include tracking state metadata such as permissions, labels, or runtime information during model checking or state exploration.",
      "description_length": 411,
      "index": 270,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Moore.Make.States",
      "library": "lascar",
      "description": "This module provides **set-theoretic operations** and **ordered set management** for collections of comparable, printable state elements in a Moore machine. It works with an ordered set type (`t`) whose elements (`state`) support total ordering, structural sharing, and string representation, leveraging a comparison function from `Ord` and utilities from `Elt`. Specific use cases include efficiently manipulating state subsets during machine transitions, analyzing reachable states via power set operations, and debugging via ordered traversal or string serialization.",
      "description_length": 570,
      "index": 271,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Conv.ToDfa.LTSA",
      "library": "lascar",
      "description": "This module specializes in determinizing non-deterministic finite automata (NFA) into equivalent deterministic finite automata (DFA) through precise state-set manipulation and transition tracking. It operates on labeled transition systems (`LTSA.t`) with ordered states, labels, and attributes, supporting use cases like formal verification, model checking, and generating visualizations of automata structures via `.dot` or `.tex` outputs.",
      "description_length": 440,
      "index": 272,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Conv.ToLts.States",
      "library": "lascar",
      "description": "This module supports manipulation of finite state sets through operations like union, filtering, and ordered iteration, leveraging a comparator-based ordered structure for element arrangement. It works with sets of `state` values represented as `States.t`, built using `Stdlib.Set.Make`, enabling efficient membership checks, transformations, and sequence-driven traversals. These tools are particularly useful for tasks requiring ordered state processing, such as LTS conversion workflows or state space analysis where attribute-free state tracking is needed.",
      "description_length": 560,
      "index": 273,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Conv.FromLts.Attrs",
      "library": "lascar",
      "description": "This module provides map operations for managing state attributes with ordered keys, enabling functional transformations like insertion, deletion, predicate-based filtering, and sequence conversion. It works with maps (`Attrs.t`) that associate `Attrs.key` identifiers to arbitrary data, leveraging persistent structures for efficient immutability and ordered traversal. These operations are specifically used to attach unit state attributes during the conversion of Labeled Transition Systems (Lts) into attributed Ltsa representations.",
      "description_length": 537,
      "index": 274,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Lts.IProduct3.States",
      "library": "lascar",
      "description": "This module supports set operations for managing and querying collections of states within a labeled transition system product. It works with ordered state sets derived from a comparator, offering conversions to and from lists and sequences, along with ordered iteration and pivot-based partitioning. These capabilities are particularly useful for analyzing reachable states, transitions, or invariant properties in scenarios requiring ordered traversal or combinatorial state-space exploration.",
      "description_length": 495,
      "index": 275,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Conv.FromLts.Label",
      "library": "lascar",
      "description": "This module defines operations for comparing and converting label values to strings. It works directly with the `label` type, providing a total ordering function and a string conversion function. These functions are used to facilitate label handling during the conversion of labeled transition systems to attributed labeled transition systems.",
      "description_length": 343,
      "index": 276,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Lts.IProduct3.State",
      "library": "lascar",
      "description": "This module represents states in the internal product of three labeled transition systems. It provides a total ordering function for comparing states and a string conversion function for state representation. It is used to manage and manipulate combined states in product LTS computations.",
      "description_length": 289,
      "index": 277,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Nfa.Make.Label",
      "library": "lascar",
      "description": "This module defines the label structure for transitions in a non-deterministic finite automaton, including a total ordering function and string conversion. It operates on a type `t` representing symbols used in transitions, enabling comparison and display of these symbols. Concrete use cases include labeling transitions between states in an NFA and facilitating operations like union, intersection, or complementation of automata based on symbol relationships.",
      "description_length": 462,
      "index": 278,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Dfa.Product.Attrs",
      "library": "lascar",
      "description": "This module provides ordered finite map operations for managing polymorphic state-keyed attributes, emphasizing deterministic state-based manipulation. It supports ordered traversal, merging, and transformation of key-value pairs using comparison-based logic, with specialized functions for constructing maps from attribute-value sequences. These operations are particularly suited for tracking and combining state properties in automata product computations, such as filtering state pairs by attribute constraints or aggregating values across product transitions.",
      "description_length": 564,
      "index": 279,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Dfa.Make.Tree",
      "library": "lascar",
      "description": "This module implements a tree-based representation of deterministic finite automata (DFA) using a recursive tree structure with nodes and edges. It provides operations to fold over the tree nodes and visualize the tree structure using Graphviz. The module is used to construct and inspect hierarchical DFA models, particularly for representing state transitions in a tree form.",
      "description_length": 377,
      "index": 280,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Conv.ToDfa.States",
      "library": "lascar",
      "description": "This module provides set-theoretic operations for managing subsets of NFA states during deterministic automaton construction, including union, intersection, filtering, and power set generation. It manipulates ordered collections of state elements using a comparison-based total order, supporting transformations like predicate-driven partitioning and sequence-based iteration. These operations facilitate critical DFA conversion tasks such as subset state construction, transition relation computation, and acceptance condition propagation through precise set manipulation primitives.",
      "description_length": 584,
      "index": 281,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lascar.Dfa.Make.LTSA",
      "library": "lascar",
      "description": "This module provides operations for constructing and analyzing labeled transition systems with attributes (LTSA), focusing on deterministic finite automata (DFA) semantics. It works with states, labels, transitions, and attributes, supporting set/map-based manipulations, structural queries (reachability, predecessors), and tree-based visualizations. Key use cases include automata analysis, model checking, and generating graphical representations of state machines for verification or documentation.",
      "description_length": 502,
      "index": 282,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Ltsa.IProduct3.Tree",
      "library": "lascar",
      "description": "This module represents trees for modeling hierarchical state transitions in labeled transition systems with three-way product combinations. It supports operations to fold over tree nodes, visualize trees using Graphviz, and output tree structures in DOT format for debugging or analysis. The tree structure is used to track composite states and transitions in formal verification scenarios involving three concurrent system components.",
      "description_length": 435,
      "index": 283,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Nfa.Make.Symbols",
      "library": "lascar",
      "description": "This module provides a set algebra for symbol elements, supporting operations like union, intersection, and mapping, along with order-aware functions for finding extremal elements and converting sets to ordered sequences. It operates on `Symbols.t` sets\u2014persistent structures built using a comparator\u2014and their interactions with sequences via `Stdlib.Seq.t`. These tools are essential for automata processing tasks such as managing transition labels, performing ordered state exploration, and efficiently combining or partitioning symbol sets during analysis.",
      "description_length": 559,
      "index": 284,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Ltsa.Product.Attr",
      "library": "lascar",
      "description": "This module defines the attribute type and string conversion for state attributes in labeled transition systems. It supports the representation and serialization of state attributes used in LTSA models. Concrete use cases include tracking and displaying properties such as state labels or metadata during model analysis or verification.",
      "description_length": 336,
      "index": 285,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Lts.Make.States",
      "library": "lascar",
      "description": "This module provides a functional set abstraction for managing collections of states in labeled transition systems, supporting operations like membership testing, insertion, union, intersection, and ordered traversal. It works with sets of state identifiers (represented as `States.t`, an ordered set type derived from `Stdlib.Set.Make`) and sequences (`Stdlib.Seq.t`), enabling transformations such as filtering, mapping, and conversion between these structures. Specific use cases include state space analysis, verification algorithms requiring set-based reasoning, and ordered processing of states for tasks like reachability computation or extremal state detection.",
      "description_length": 669,
      "index": 286,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lascar.Dfa.Make.NFA",
      "library": "lascar",
      "description": "This module provides operations for constructing, analyzing, and transforming non-deterministic finite automata (NFA), including reachability checks, transition manipulation, and graph traversal. It works with states, transitions, and attributes, supporting tasks like cycle detection, pruning unreachable states, and generating visualizations via DOT or LaTeX. Use cases include automaton analysis, structural transformation, and documentation through labeled transition system representations.",
      "description_length": 495,
      "index": 287,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Mealy.Make.Label",
      "library": "lascar",
      "description": "This module defines operations for comparing and converting transition labels to strings in a Mealy machine. It works with boolean valuations of input and output variables represented as Label.t. Use this module to uniquely order and display transitions based on their input-output behavior.",
      "description_length": 291,
      "index": 288,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Conv.Fsm.Attrs",
      "library": "lascar",
      "description": "This module provides map-based operations for managing key-value pairs where keys are states from finite state machines (FSMs) and values are arbitrary data. It supports associative operations like insertion, removal, and querying, along with ordered traversal, merging, and transformation of these attribute maps. These capabilities are particularly useful for tasks such as annotating FSM states with metadata, transforming state attributes during model analysis, or aggregating properties across state transitions.",
      "description_length": 517,
      "index": 289,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Ltsa.IProduct.State",
      "library": "lascar",
      "description": "This module defines the state type and operations for representing states in a labeled transition system with attributes. It includes functions for comparing states and converting them to strings, enabling ordered collections and readable debugging. These states are used to model system configurations in formal verification tasks, such as model checking or behavioral analysis.",
      "description_length": 379,
      "index": 290,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Conv.ToDfa.Symbols",
      "library": "lascar",
      "description": "This module provides ordered set operations and sequence conversions for symbol collections, enabling efficient membership checks, set algebra, and ordered traversal. It works with finite sets (`t`) of symbols and their sequences, leveraging a total ordering for deterministic processing. These operations are particularly useful in determinisation workflows where ordered symbol handling is required for constructing or analyzing transition systems.",
      "description_length": 450,
      "index": 291,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Conv.ToMoore.Label",
      "library": "lascar",
      "description": "This module defines label conversion logic for transforming Mealy machine outputs into Moore machine states. It operates on label values represented as `Lascar.Moore.BVal.t` and provides comparison and string conversion operations. The module is used to ensure labels are uniquely mapped to Moore machine states during the conversion process.",
      "description_length": 342,
      "index": 292,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Fsm.Make.State",
      "library": "lascar",
      "description": "This module represents states in a finite state machine, providing operations to compare and convert states to strings. It works with a state type that supports a total ordering and string representation. Concrete use cases include managing state transitions and identifying states within a state machine.",
      "description_length": 305,
      "index": 293,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Moore.Make.Attr",
      "library": "lascar",
      "description": "This module defines attributes for Moore machine states, mapping each state to a value of type `t` and enabling transformations based on state output. It supports operations to get, set, and modify attribute values for specific states, as well as compose attributes across transitions. Concrete use cases include tracking output values associated with states in a Moore machine, such as encoding digital circuit outputs or state-dependent behaviors in formal verification.",
      "description_length": 472,
      "index": 294,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Ltsa.Product3.Attrs",
      "library": "lascar",
      "description": "This module provides map-like operations for managing state attribute bindings in labeled transition systems, focusing on creation, modification, and transformation of ordered key-value maps where keys represent states and values hold arbitrary data. It works with polymorphic maps structured as `Attrs.t`, leveraging ordered keys for efficient iteration, comparison, and bulk updates from sequences of key-value pairs. These operations are particularly useful in scenarios requiring precise attribute management during composition or analysis of state transitions, such as merging or filtering attributes across product systems.",
      "description_length": 629,
      "index": 295,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Conv.ToDfa.Attrs",
      "library": "lascar",
      "description": "This module provides a collection of operations to manage state-associated attributes during NFA-to-DFA conversion, offering key-value manipulation (insertion, lookup, conditional updates), ordered traversal, and functional transformations. It operates on a typed map structure (`'a Attrs.t`) where keys are states and values represent arbitrary attributes, enabling efficient handling of state metadata like transition properties or equivalence classes. Specific use cases include merging attributes during state determinization, filtering states based on dynamic conditions, and mapping over ordered state sequences to propagate properties across the resulting DFA.",
      "description_length": 667,
      "index": 296,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Dfa.Product.Tree",
      "library": "lascar",
      "description": "Computes and manipulates tree structures representing the product of two DFAs, using nodes and edges derived from their shared symbol set. Provides `fold` for aggregating node values across the tree and `dot_output`/`dot_view` for visualizing the tree structure. Useful for analyzing combined state transitions in DFAs, such as verifying intersection properties or generating graphical representations of merged automata.",
      "description_length": 421,
      "index": 297,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Dfa.Product.Symbol",
      "library": "lascar",
      "description": "This module defines the symbol type used in deterministic finite automata, including operations for comparison, string conversion, and handling of the empty symbol. It provides a total ordering function for symbols, a string representation function, and a value representing epsilon transitions. Concrete use cases include defining transition labels in DFAs and comparing symbols during automaton construction or product operations.",
      "description_length": 432,
      "index": 298,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Dfa.Product.LTSA",
      "library": "lascar",
      "description": "This module provides operations for constructing and analyzing products of deterministic finite automata through labeled transition systems with attributes (LTSA), enabling reachability analysis, transition graph manipulation, and state attribute transformations. It works with state-labeled transition graphs that combine multiple DFAs, supporting set-based operations on states, hierarchical attribute mapping, and tree-like structure unwinding. Key use cases include formal verification of system properties via product automata, protocol analysis through composed state spaces, and generating visualizations of complex transition systems using customizable graph layouts.",
      "description_length": 675,
      "index": 299,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Lts.Product.State",
      "library": "lascar",
      "description": "This module represents states in the product of two labeled transition systems, supporting comparisons and string conversions. It defines a type `t` for product states and provides `compare` to establish a total order between states, ensuring consistent ordering for operations like set or map manipulations. The `to_string` function allows for human-readable representations of product states, useful for debugging and logging.",
      "description_length": 428,
      "index": 300,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Lts.Product3.States",
      "library": "lascar",
      "description": "This module provides ordered set operations for managing collections of states in labeled transition systems, supporting efficient filtering, partitioning, and transformation using total ordering. It works with a concrete set type (`t`) whose elements represent states, enabling ordered traversal, sequence integration, and conversion between lists/sequences while preserving uniqueness. These operations are particularly useful for analyzing state spaces in product LTS scenarios, where ordered iteration, extremal element selection, or sequence-driven state aggregation are required.",
      "description_length": 585,
      "index": 301,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Dfa.Product.State",
      "library": "lascar",
      "description": "This module represents states in the product of two DFAs, supporting comparisons and string conversions. It defines a total ordering for state elements and provides a way to uniquely identify and display states. It is used when computing and manipulating the combined states of two DFAs over the same symbol set.",
      "description_length": 312,
      "index": 302,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lascar.Conv.ToMealy.Label",
      "library": "lascar",
      "description": "This module defines the labeling mechanism for transitions when converting a Moore machine to a Mealy machine. It provides a total ordering function and a string conversion function for label values, ensuring consistent comparison and representation. These operations are essential for constructing and manipulating Mealy machine transitions based on output-labeled states from the original Moore machine.",
      "description_length": 405,
      "index": 303,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lascar.Conv.ToLts.State",
      "library": "lascar",
      "description": "This module defines the state type and operations for comparing and converting states to strings in the context of labeled transition system conversions. It provides a total ordering function for states and a string representation function, both essential for managing state identifiers during transitions. These functions are used specifically when converting an `Ltsa` to an `Lts` to handle and normalize state representations without attributes.",
      "description_length": 448,
      "index": 304,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Lts.Make.Label",
      "library": "lascar",
      "description": "This module defines operations for comparing and converting label values to strings. It works with the label type used in labeled transition systems. Concrete use cases include ordering labels for deterministic transitions and generating string representations for logging or debugging.",
      "description_length": 286,
      "index": 305,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lascar.Fsm.Make.Tree",
      "library": "lascar",
      "description": "Implements tree-based finite state machines with nodes representing states and edges representing transitions. Provides functions to fold over nodes, output state machine diagrams in Graphviz format, and visualize them directly. Useful for modeling and analyzing state transitions in systems like protocol implementations or control logic.",
      "description_length": 339,
      "index": 306,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Conv.ToDfa.State",
      "library": "lascar",
      "description": "This module defines the state representation and operations used during the conversion of an NFA to a DFA. It includes functions for comparing states and converting them to string form, enabling deterministic state tracking and identification. It works directly with the `state` type, supporting the determinization process by managing state equivalence and ordering.",
      "description_length": 367,
      "index": 307,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Ltsa.Product3.State",
      "library": "lascar",
      "description": "This module represents states in the external product of three LTSA structures, providing comparison and string conversion operations. It defines a type `t` for product states and ensures a total order via the `compare` function, enabling use in ordered collections. The `to_string` function supports debugging by converting product states to string representations.",
      "description_length": 366,
      "index": 308,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Dfa.Make.States",
      "library": "lascar",
      "description": "This module offers set-theoretic operations for managing collections of deterministic finite automaton states, including union, intersection, difference, and subset checks, alongside utilities for filtering, partitioning, and extracting extremal elements. It works with immutable sets of states ordered via a comparator, supporting transformations like mapping, reverse iteration, and power set generation. Specific use cases include analyzing state transitions, optimizing automaton structures through subset construction, and integrating with external components via conversions to lists and sequences.",
      "description_length": 604,
      "index": 309,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Fsm.Make.Attrs",
      "library": "lascar",
      "description": "This module offers map manipulation operations for state-keyed data, supporting functional updates (insertion, deletion, merging) and ordered traversal over `'a Attrs.t` structures, which map `state` keys to arbitrary values. It enables efficient querying, transformation, and construction of attribute maps using ordered key comparisons, with use cases in managing state metadata or transition data in finite state machines.",
      "description_length": 425,
      "index": 310,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Ltsa.Product.Label",
      "library": "lascar",
      "description": "This module defines operations for comparing and converting label values to strings. It works with the label type used in Labeled Transition Systems with State Attributes. Concrete use cases include ordering labels for deterministic processing and serializing them for output or debugging.",
      "description_length": 289,
      "index": 311,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lascar.Ltsa.IProduct.Attrs",
      "library": "lascar",
      "description": "This module provides operations for managing ordered key-value maps with generic attribute values, emphasizing structural transformations and ordered traversal. It supports map manipulation through insertion, deletion, filtering, and semantic-preserving updates, along with ordered queries for min/max elements and range-based splits. These operations are designed for state attribute aggregation and merging during labeled transition system composition, enabling precise handling of attribute conflicts or combinations in product states.",
      "description_length": 538,
      "index": 312,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Conv.Fsm.State",
      "library": "lascar",
      "description": "This module defines operations for comparing and converting state identifiers in a finite state machine. It provides a total ordering function for states using a structural comparison and a string conversion function for state representation. These functions support tasks like state enumeration, sorting, and debugging output generation.",
      "description_length": 338,
      "index": 313,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Conv.ToMoore.Tree",
      "library": "lascar",
      "description": "This module represents trees used to model state transitions during the conversion of Mealy machines to Moore machines. It provides operations to fold over tree nodes, generate DOT visualizations, and display trees using Graphviz. The tree structure captures states as nodes and transitions as edges labeled with Boolean values.",
      "description_length": 328,
      "index": 314,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Ltsa.IProduct3",
      "library": "lascar",
      "description": "This module enables the composition and analysis of concurrent systems through synchronized product operations on three labeled transition systems with attributes. It manages complex state interactions by combining states, transitions, and attributes across systems using customizable synchronization rules, while providing tools for extracting composite transitions and generating structured representations. Key applications include formal verification of distributed protocols and model-checking tasks requiring precise state-space exploration with attribute-preserving compositions.",
      "description_length": 586,
      "index": 315,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Mealy.Transition",
      "library": "lascar",
      "description": "This module represents transitions in Mealy machines as pairs of boolean valuations for inputs and outputs. It includes functions to compare transitions and convert them to string representations. It is used to model state transitions in systems where each transition is defined by a specific input-output behavior.",
      "description_length": 315,
      "index": 316,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Valuation.Bool",
      "library": "lascar",
      "description": "This module manages boolean valuations represented as lists of (name, value) pairs. It supports operations to add, remove, and check the presence of named boolean values, ensuring completeness against a given list of names. Use cases include validating and manipulating boolean assignments for logical variables in formal verification tasks.",
      "description_length": 341,
      "index": 317,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Conv.ToMoore",
      "library": "lascar",
      "description": "This module transforms Mealy machines into Moore machines by restructuring states to encapsulate output behavior, using state-valued transitions and attribute mappings. It operates on labeled transition systems with typed states, transitions, and attributes, enabling structural analysis through reachability checks, predecessor/successor queries, and tree unwinding. Key applications include simplifying output determinism for verification tasks, pruning unreachable states, and generating visualizations in graph or LaTeX formats for formal method workflows.",
      "description_length": 560,
      "index": 318,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Fsm.Action",
      "library": "lascar",
      "description": "This module defines actions that assign values to identifiers within a finite state machine, using expressions from the `Lascar.Fsm_expr` module. It supports parsing actions from strings and converting them to string representations, enabling serialization and deserialization of state machine transitions. Use cases include defining and persisting state transitions that update variables based on expressions.",
      "description_length": 410,
      "index": 319,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Dfa.Product",
      "library": "lascar",
      "description": "This module enables the construction and manipulation of composite automata formed from two deterministic finite automata (DFAs) sharing a common symbol set. It manages structured state pairs, transitions, and boolean attributes to support tasks like intersection analysis, formal verification, and reachability tracking, while providing tools for visualization and structural transformations such as trimming unreachable states or converting to graphical formats like DOT. Key operations include state and transition membership checks, predecessor/successor traversal, and attribute tracking to analyze deterministic state-space interactions.",
      "description_length": 643,
      "index": 320,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lascar.Lts.Product3",
      "library": "lascar",
      "description": "This module combines three labeled transition systems into composite models with tuple-based states and labels, supporting operations to compute synchronized, asynchronous, and free product constructions. It manages transitions and state relationships through validation, reachability analysis, and iterative transformations, while enabling formal verification tasks like pruning unreachable states or generating graphical representations. The design facilitates modeling concurrent systems with customizable synchronization constraints, such as protocol verification or distributed system analysis.",
      "description_length": 599,
      "index": 321,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Nfa.Trans",
      "library": "lascar",
      "description": "Converts an NFA by transforming its states and symbols using provided functions. Works with any NFA representation that has state and symbol types conforming to the input and output modules. Useful for adapting NFAs between different state/symbol implementations, such as renumbering states or changing symbol encodings.",
      "description_length": 320,
      "index": 322,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Ltsa.Product",
      "library": "lascar",
      "description": "This module provides operations to compute external products of labeled transition systems with state attributes, combining their states into pairs and synchronizing transitions according to specified policies like synchronous or asynchronous composition. It operates on pairs of LTSA instances, preserving their state attributes, labels, and hierarchical structures while enabling analysis of interacting systems. Use cases include verifying concurrent system behaviors, protocol interactions, and hierarchical state machine compositions through combined transition semantics.",
      "description_length": 577,
      "index": 323,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Ltsa.IProduct",
      "library": "lascar",
      "description": "This module provides operations for constructing, querying, and transforming labeled transition systems with state attributes through product operations, transition management, and attribute manipulation. It works with structured state-transition graphs composed of states, labels, attributes, and directed transitions, supporting formal verification tasks like reachability analysis and system composition. Specific capabilities include synchronized/asynchronous product construction, execution tree unwinding, and DOT visualization for modeling concurrent systems or verifying behavioral properties.",
      "description_length": 601,
      "index": 324,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Dfa.Trans",
      "library": "lascar",
      "description": "Converts a deterministic finite automaton between different state and symbol representations using mapping functions. It takes a DFA implemented with one set of state and symbol types and transforms it into another DFA using different types for states and symbols. This is useful when adapting a DFA to work with externally defined state or symbol types, such as converting internal numeric identifiers to string-based labels for output or interfacing with other systems.",
      "description_length": 471,
      "index": 325,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Lts.Trans",
      "library": "lascar",
      "description": "Converts labeled transition systems by transforming state identifiers and transition labels using provided functions. Works with LTS structures that have distinct state and label implementations. Useful for adapting transition system representations between different state or label types, such as mapping integer states to string-based identifiers while preserving structure.",
      "description_length": 376,
      "index": 326,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lascar.Fsm.Transition",
      "library": "lascar",
      "description": "Handles transitions between states in a finite state machine by encoding conditions and actions as lists. Provides comparison, string conversion, and parsing operations for transition values. Useful for defining and serializing state transitions with associated guards and effects.",
      "description_length": 281,
      "index": 327,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Ltsa.Trans",
      "library": "lascar",
      "description": "Performs structural transformations between two Labeled Transition Systems with State Attributes using provided mappings for states, labels, and attributes. It converts a system defined over one set of state, label, and attribute types into another system with different state, label, and attribute types. Useful when translating or adapting models between different representations, such as simplifying state encodings or retagging transitions for compatibility.",
      "description_length": 463,
      "index": 328,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lascar.Conv.ToDfa",
      "library": "lascar",
      "description": "This module provides functions to determinize non-deterministic automata through subset construction, handling state set transformations, attribute propagation, and transition tree unwinding. It operates on labeled transition systems with explicit states, symbols, and attributes, producing deterministic automata structures amenable to formal verification. Key applications include pruning unreachable states, generating DOT visualizations, and enabling reachability analysis through set-theoretic operations.",
      "description_length": 510,
      "index": 329,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lascar.Fsm.Condition",
      "library": "lascar",
      "description": "This module defines operations for parsing, serializing, and evaluating conditions in a finite state machine. It works with strings and environment data to represent and assess conditions. Concrete use cases include converting condition strings to structured data, formatting conditions as strings, and determining condition truth values during state transitions.",
      "description_length": 363,
      "index": 330,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Nfa.Product",
      "library": "lascar",
      "description": "This module provides operations to compute the product of two non-deterministic finite automata (NFAs) over a shared symbol set by combining their states, transitions, and attributes into a single NFA structure. It works with labeled transition systems (LTSA) where states are represented as pairs from the original NFAs, transitions synchronize on common symbols, and attributes are merged or transformed to preserve properties like acceptance conditions. Specific use cases include formal verification tasks, such as checking intersection properties of automata, and analyzing system behaviors through synchronized state exploration or visualization of composite transitions.",
      "description_length": 677,
      "index": 331,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Builtins.Int",
      "library": "lascar",
      "description": "Implements comparison and string conversion for integers. Provides `compare` for total ordering and `to_string` for textual representation. Used in sorting integer values or displaying them in logs and error messages.",
      "description_length": 217,
      "index": 332,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Conv.Fsm",
      "library": "lascar",
      "description": "This module provides operations for structural manipulation, reachability analysis, and hierarchical state traversal of finite state machines with attributed transitions and labeled states. It supports transformations like defactorization of states based on variable valuations, attribute-preserving modifications, and bidirectional navigation through predecessor/successor relationships. Key applications include model simplification, execution tree unwinding, and generating visualizations in DOT or LaTeX formats for formal verification workflows.",
      "description_length": 550,
      "index": 333,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Moore.BVal",
      "library": "lascar",
      "description": "This module represents valuations of boolean variables in Moore machines, providing operations to construct, modify, and query variable-value mappings. It supports data structures like lists of name-value pairs, with functions to add, remove, check existence, and retrieve values associated with variable names. Concrete use cases include validating complete assignments of boolean variables against a given list of expected names and maintaining consistent variable valuations during state transitions in a Moore machine.",
      "description_length": 522,
      "index": 334,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lascar.Moore.Make",
      "library": "lascar",
      "description": "This module supports querying, transformation, and visualization of labeled transition systems with attributes (LTSA), focusing on operations like reachability analysis, attribute mapping, and symbolic state manipulation. It works with ordered states, transitions labeled by actions, and attribute maps that drive model simplification or annotation, using tree structures for hierarchical representation. Typical use cases include formal verification of state machine behavior, debugging through `.dot`/`.tex` visualizations, and attribute-guided refinement of LTS models.",
      "description_length": 572,
      "index": 335,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lascar.Valuation.Int",
      "library": "lascar",
      "description": "This module implements a valuation system for integer values associated with string names, providing operations to add, remove, and check the presence of named values. It supports creating and manipulating lists of name-value pairs, ensuring completeness and consistency with respect to a given list of names. Use cases include managing variable assignments in symbolic computations or tracking named counters in algorithm state.",
      "description_length": 429,
      "index": 336,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Ltsa.Product3",
      "library": "lascar",
      "description": "This module enables the computation of synchronized compositions of three labeled transition systems with state attributes, combining their states and transitions into a unified system where actions are coordinated across all components. It operates on composite data structures representing product states, synchronized labels, and merged attributes, using sets, maps, and trees to manage relationships between elements. The functionality is particularly useful for modeling concurrent systems where coordinated behavior analysis, such as protocol verification or interaction modeling, is required.",
      "description_length": 599,
      "index": 337,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Fsm.Make",
      "library": "lascar",
      "description": "The module enables structural analysis, transformation, and visualization of finite state machines modeled as labeled transition systems. It operates on states, transitions, labels, and attributes, offering reachability checks, traversal operations, and attribute manipulation, alongside utilities for generating graphical representations in DOT or TeX formats. These capabilities support tasks like system modeling, execution path unwinding, and customizable visual debugging of state machine behavior.",
      "description_length": 503,
      "index": 338,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Lts.IProduct",
      "library": "lascar",
      "description": "This module supports operations for creating and managing products of labeled transition systems (LTS) through structured state and label synchronization, including synchronized, asynchronous, and free composition modes. It works with LTS components like states, transitions, and labels, leveraging ordered sets for efficient manipulation and conversion utilities for visualization or analysis. Specific use cases include formal verification workflows where composite system behaviors are analyzed by combining LTS models with varying interaction semantics.",
      "description_length": 557,
      "index": 339,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Builtins.Bool",
      "library": "lascar",
      "description": "Implements comparison and string conversion for boolean values. Works directly with the `bool` type, providing `compare` for ordering and `to_string` for textual representation. Useful in contexts requiring boolean value serialization or ordered comparisons, such as configuration parsing or state logging.",
      "description_length": 306,
      "index": 340,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Lts.Product",
      "library": "lascar",
      "description": "This module provides functions to compute and manipulate product labeled transition systems by combining states and labels as pairs from two component systems. It supports operations like state and transition comparison, synchronization strategies (synchronized, asynchronous, etc.), and traversal of composed structures. These capabilities are used to model interacting state-based systems with varying composition semantics, such as concurrent processes or hierarchical state machines.",
      "description_length": 487,
      "index": 341,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Conv.ToLts",
      "library": "lascar",
      "description": "This module transforms labeled transition systems with state attributes (Ltsa) into simplified LTS structures by stripping attributes while preserving transitions and structural relationships. It offers operations for reachability analysis, set-theoretic manipulations of states/transitions, and bidirectional traversal (predecessors/successors), alongside visualization tools for generating annotated graph representations (.dot, .tex) with customizable styling. These features enable formal verification workflows where simplified models are required for analysis, visualization, or integration with tools that operate on attribute-free LTS formats.",
      "description_length": 651,
      "index": 342,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Nfa.Make",
      "library": "lascar",
      "description": "This module provides operations for constructing, analyzing, and transforming automata through state and transition manipulation, reachability checks, and attribute management. It works with labeled transition systems composed of ordered states, symbols, and transitions, supporting operations like cycle detection, acceptance testing, and visualization via DOT or LaTeX. Specific use cases include formal verification tasks, automaton minimization, and generating graphical representations of execution paths or hierarchical state structures.",
      "description_length": 543,
      "index": 343,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Conv.ToMealy",
      "library": "lascar",
      "description": "This module provides operations to convert Moore machines into Mealy machines by redefining state transitions and output mappings, while supporting structural analysis, transformation, and visualization. It works with state machines composed of labeled states, attributed transitions, and tree-based hierarchies, using sets and maps to manage state and attribute collections. Specific use cases include formal verification of state machine equivalence, protocol modeling with explicit transition outputs, and generating visual representations via `.dot` or `.tex` exports.",
      "description_length": 572,
      "index": 344,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Lts.IProduct3",
      "library": "lascar",
      "description": "This module provides operations to construct and analyze composite labeled transition systems through product operations like free, synchronized, and asynchronous products, enabling modeling of concurrent systems with varying synchronization semantics. It works with states, transitions, and labels organized into ordered sets, supporting reachability analysis, traversal of predecessors/successors, and transformations like label mapping or unreachable state removal. Specific use cases include formal verification of interacting state machines, generating visualizations via DOT/TeX exports, and combining multiple LTS instances under customizable composition rules.",
      "description_length": 668,
      "index": 345,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Dfa.Make",
      "library": "lascar",
      "description": "This module provides operations for constructing and manipulating deterministic finite automata through state and transition management, attribute mapping, and reachability analysis. It works with states, symbols, transitions, and attributes, supporting tasks like structural transformations, cycle detection, and conversion to non-deterministic automata. Use cases include formal language processing, model analysis, and generating visual representations via DOT format.",
      "description_length": 471,
      "index": 346,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lascar.Conv.FromLts",
      "library": "lascar",
      "description": "This module converts labeled transition systems (LTS) into attributed LTS (LTSA) by enriching states with unit attributes, enabling analysis of state properties like reachability and initiality. It provides operations to manipulate transitions and attributes, map state data using ordered keys, and visualize hierarchical structures via tree-based renderings in DOT or TeX formats. Key use cases include model transformation, graph traversal, and generating structured visualizations of state machines.",
      "description_length": 502,
      "index": 347,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Builtins.String",
      "library": "lascar",
      "description": "This module implements operations for comparing and converting string values. It provides a total ordering function for strings and a function to convert string values to their string representation. It is used in contexts requiring lexicographical ordering and string serialization.",
      "description_length": 283,
      "index": 348,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Ltsa.Make",
      "library": "lascar",
      "description": "This module provides operations for constructing, modifying, and analyzing Labeled Transition Systems with State Attributes, including state and transition management, attribute handling, and reachability checks. It supports functional iteration and mapping over states, transitions, labels, and attributes, enabling formal verification tasks like model checking, visualization in DOT/LaTeX formats, execution tree unwinding, and removal of unreachable states through traversal of state relations and transitions.",
      "description_length": 513,
      "index": 349,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Valuation.Make",
      "library": "lascar",
      "description": "This module implements a valuation structure as a list of name-value pairs, using a specified value type. It supports operations to add, remove, and check existence of bindings, as well as validating that a valuation matches a required set of names. It is used to manage variable assignments in contexts requiring strict validation, such as configuration loading or symbolic computation.",
      "description_length": 387,
      "index": 350,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Mealy.Make",
      "library": "lascar",
      "description": "This module provides operations for constructing, transforming, and analyzing labeled transition systems with boolean-annotated states and transitions. It supports state and transition manipulation, reachability analysis, attribute transformations, and visualization through graph exports, targeting formal verification and model exploration workflows. Core data structures include states, transitions labeled with input/output valuations, and associated attributes, organized into sets and maps for efficient iteration and modification.",
      "description_length": 537,
      "index": 351,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Lts.Make",
      "library": "lascar",
      "description": "This module supports construction, modification, and analysis of Labeled Transition Systems through operations like state/transition addition, membership checks, and predecessor/successor queries. It works with states, labels, and transitions structured as triples `(state * label * state)`, along with initial transitions `(label * state)`, organized within a core LTS type. Key use cases include model verification workflows requiring traversal (iter/fold), transformation (label mapping, unreachable state removal), and visualization via `.dot`/`.tex` exports for formal analysis or documentation.",
      "description_length": 600,
      "index": 352,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Moore",
      "library": "lascar",
      "description": "Handles boolean variable valuations and labeled transition systems with attributes for Moore machines. Uses lists of name-value pairs for variable mappings and tree structures for state representation. Enables validation of variable assignments, reachability analysis, and model visualization in formal verification workflows.",
      "description_length": 326,
      "index": 353,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Conv",
      "library": "lascar",
      "description": "This module includes functors for converting and transforming labeled transition systems and finite state machines. It supports operations such as determinization, attribute manipulation, and conversion between Moore and Mealy machines, with a focus on structural analysis, reachability, and visualization. Use cases include formal verification workflows, model transformations, and generating structured visualizations of state machines in formats like DOT and TeX.",
      "description_length": 466,
      "index": 354,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Lts",
      "library": "lascar",
      "description": "This module implements operations for constructing and manipulating labeled transition systems (LTS), including state transitions, label assignments, and initial state definitions. It works with states represented as elements of a set, labels as actions, and relations as transitions between states. Concrete use cases include modeling system behaviors for verification, defining automata for protocol analysis, and representing stateful computations in formal methods.",
      "description_length": 469,
      "index": 355,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Dfa",
      "library": "lascar",
      "description": "Implements deterministic finite automata with state transitions enforced to have at most one symbol per state. Provides functions to create, modify, and evaluate DFAs over specific input alphabets. Useful for parsing regular languages and validating input formats such as identifiers or tokens.",
      "description_length": 294,
      "index": 356,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Ltsa",
      "library": "lascar",
      "description": "This module implements labeled transition systems with state attributes, supporting operations to define states, transitions, and attribute manipulations. It works with states `Q`, labels `L`, attributes `A`, initial states `I`, attribute assignments `a`, and transition relations `R`. Concrete use cases include modeling stateful systems with attributed nodes and visualizing transitions using graph layouts like circular or layered diagrams.",
      "description_length": 443,
      "index": 357,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lascar.Builtins",
      "library": "lascar",
      "description": "This module includes pre-defined implementations for basic data types, offering comparison and string conversion operations. It supports concrete use cases like sorting integers, serializing booleans for configuration, and lexicographical ordering of strings. Each submodule directly works with its corresponding OCaml primitive type.",
      "description_length": 334,
      "index": 358,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Fsm_expr",
      "library": "lascar",
      "description": "This module represents and evaluates simple integer expressions used in finite state machines. It supports constants, variables, and binary operations over integers, with functions to parse expressions from strings, evaluate them in an environment, and tokenize input. Concrete use cases include defining transition conditions and output expressions in FSMs using variables and arithmetic operations.",
      "description_length": 400,
      "index": 359,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Fsm",
      "library": "lascar",
      "description": "This module implements finite state machines as labeled transition systems with support for conditions, actions, and transitions. It provides operations for evaluating state-dependent conditions, performing variable assignments, and structuring transitions with guards and effects. Concrete use cases include modeling system behaviors with conditional transitions, executing state changes based on environment data, and generating visual representations of state machines for analysis.",
      "description_length": 485,
      "index": 360,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Mealy",
      "library": "lascar",
      "description": "This module implements Mealy machines using transitions labeled with boolean input-output valuations. It provides operations for constructing and manipulating labeled transition systems, including reachability analysis, attribute transformation, and graph export. It works with states, transitions, and boolean-annotated attributes, targeting formal verification and model exploration workflows.",
      "description_length": 395,
      "index": 361,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Valuation",
      "library": "lascar",
      "description": "This module manages collections of named value bindings with support for adding, removing, and validating associations. It works with string names paired with values of a specified type, such as booleans or integers. It is used to enforce complete and consistent variable assignments in symbolic computation and formal verification tasks.",
      "description_length": 338,
      "index": 362,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar.Nfa",
      "library": "lascar",
      "description": "This module implements non-deterministic finite automata using labeled transition systems. It supports operations such as state transitions, acceptance checking, and epsilon closure computation. The automata operate on symbols and states defined by the `SYMBOL` and `T` module types, enabling use cases like pattern matching and lexical analysis.",
      "description_length": 346,
      "index": 363,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lascar",
      "library": "lascar",
      "description": "This module provides operations for working with labeled transition systems, finite automata, and state machines, including construction, transformation, and analysis functionalities. It supports data types such as states, transitions, labels, and attributes, with concrete use cases in formal verification, model-based design, and system behavior representation. Specific functions include determinization of automata, evaluation of transition conditions, conversion between machine types, and exporting models to visualization formats.",
      "description_length": 537,
      "index": 364,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Utils.SetExt.Product.Elt",
      "library": "lascar.utils",
      "description": "This module defines the element type and operations for a set product, including comparison and string conversion functions. It works with elements of a type that supports total ordering and string representation. Concrete use cases include creating and manipulating sets of structured data like pairs of integers or custom records with defined equality and ordering.",
      "description_length": 367,
      "index": 365,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Utils.SetExt.Make.Elt",
      "library": "lascar.utils",
      "description": "This module defines the element type and comparison logic for constructing sets with ordered elements. It includes operations to compare and convert elements to strings, enabling set operations like union, intersection, and difference. It is used to define custom element types for sets where ordering and string representation are required, such as managing sets of integers, strings, or custom records with a defined order.",
      "description_length": 425,
      "index": 366,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Utils.OrderedTypeExt.Either",
      "library": "lascar.utils",
      "description": "This module represents values as pairs of optional elements from two distinct ordered types, enabling comparisons and string representations for combined ordered structures. It supports creating and comparing these pairs, where each component is drawn from a separate ordered type. Useful for tracking dual-state values that require lexicographic ordering, such as versioned identifiers with separate numeric and string components.",
      "description_length": 431,
      "index": 367,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Utils.OrderedTypeExt.Triplet",
      "library": "lascar.utils",
      "description": "This module defines a triplet type composed of three ordered elements, providing lexicographical comparison and string representation. It supports creating and comparing triplets where each component type is equipped with a total order. Useful for representing and comparing composite keys or multi-field identifiers in sets or maps.",
      "description_length": 333,
      "index": 368,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Utils.Tree.Make",
      "library": "lascar.utils",
      "description": "Implements n-ary trees with labeled edges and nodes, supporting operations to fold over node values and visualize trees using Graphviz. It works with abstract node and edge types provided by the parameter module A, organizing them into a tree structure that can be traversed or rendered. Concrete use cases include building and visualizing parse trees, directory structures, or hierarchical data with custom node and edge attributes.",
      "description_length": 433,
      "index": 369,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Utils.SetExt.Make",
      "library": "lascar.utils",
      "description": "This module provides extended set operations for totally ordered, stringable elements, including standard algebra (union, intersection, difference), ordered iteration, power set generation, and sequence conversions. It works with sets (`t`) containing elements (`elt`) from a comparable, string-convertible type, supporting transformations, filtering, and efficient ordered searches. Use cases include handling hierarchical set structures, ordered traversal for serialization, and algorithms requiring physical equality preservation or power set enumeration.",
      "description_length": 558,
      "index": 370,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Utils.SetExt.Product",
      "library": "lascar.utils",
      "description": "This module implements product set operations for Cartesian products of ordered elements, supporting standard set manipulations like union, intersection, and difference alongside ordered traversals, element selection, and transformation functions. It operates on pairs of elements from two distinct ordered set types, leveraging their comparison and ordering properties to enable structured queries and set decomposition. Typical applications include combinatorial analysis of paired data, ordered pair filtering, and algorithms requiring product space partitioning with efficient membership checks.",
      "description_length": 599,
      "index": 371,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Utils.OrderedTypeExt.Either3",
      "library": "lascar.utils",
      "description": "This module implements a total ordering and string representation for a 3-tuple of optional values, where each component type is drawn from the parameter modules M1, M2, and M3. It supports direct comparison of these tuples using a lexicographic ordering based on the underlying component types. It is useful for representing and comparing heterogeneous optional keys in sets or maps.",
      "description_length": 384,
      "index": 372,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Utils.Stringable.Triplet",
      "library": "lascar.utils",
      "description": "This module implements a tuple-like structure of three elements, each from distinct modules M1, M2, and M3, that can be converted to a string representation. It provides a `to_string` function for serializing the triplet and a `mk` function to construct instances. Concrete use cases include grouping related values (e.g., a key, value, and timestamp) for logging or transmission where each component is independently stringable.",
      "description_length": 429,
      "index": 373,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Utils.Stringable.Pair",
      "library": "lascar.utils",
      "description": "This module pairs two string-convertible values and provides a `to_string` function to combine their string representations. It works with any two modules that support string conversion through the `Utils.Stringable` interface. Use this to create composite string identifiers or formatted output from two related values.",
      "description_length": 320,
      "index": 374,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Utils.OrderedTypeExt.Pair",
      "library": "lascar.utils",
      "description": "This module defines a product type with a lexicographical ordering based on two component modules. It provides a `compare` function that orders pairs by comparing the first element, then the second if the first is equal, and a `to_string` function for string representation. It is used to create ordered pairs of values from two ordered types, suitable for use in sets or maps requiring total ordering.",
      "description_length": 402,
      "index": 375,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Utils.FilenameExt",
      "library": "lascar.utils",
      "description": "This module extends filename handling with operations to split, modify, and replace file suffixes. It works with string representations of filenames and file extensions. Concrete use cases include renaming files with new extensions, appending text before an extension, or separating a filename from its extension for processing.",
      "description_length": 328,
      "index": 376,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Utils.SetExt",
      "library": "lascar.utils",
      "description": "This module implements extended set operations for totally ordered, stringable elements, including union, intersection, difference, power set generation, and ordered iteration. It works with sets of elements that support comparison and string conversion, enabling transformations, filtering, and efficient ordered traversal. Concrete use cases include managing hierarchical set structures, serializing sets via ordered traversal, and implementing algorithms that require power set enumeration or physical equality preservation.",
      "description_length": 527,
      "index": 377,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Utils.ListExt",
      "library": "lascar.utils",
      "description": "This module offers advanced list manipulation capabilities, including indexed folds, combinatorial operations like Cartesian products and power set generation, and enhanced transformations such as element-wise processing with custom logic. It operates on lists, association lists, and streams, enabling tasks like merging heterogeneous collections, parsing structured data, and scattering elements into arrays using dynamic index mappings. Specific use cases include custom key-value merging, partitioning paired data, and generating combinatorial sequences with tailored comparison or ordering rules.",
      "description_length": 601,
      "index": 378,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Utils.Option",
      "library": "lascar.utils",
      "description": "This module provides transformations and side-effect operations for `'a option` values. It includes mapping a function over an option, applying an effect if a value exists, and converting an option to a string representation. It is used to handle optional data in parsing, logging, or UI rendering contexts where absence must be gracefully managed.",
      "description_length": 348,
      "index": 379,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Utils.StringExt",
      "library": "lascar.utils",
      "description": "This module extends string manipulation capabilities with functions to check if a string starts with an uppercase letter, split a string into individual characters, escape or remove specific characters within a string, and concatenate a list of strings with a separator. It operates directly on the `string` and `string list` types. These functions are useful for tasks like preparing strings for HTML output, parsing input, or formatting text for display.",
      "description_length": 456,
      "index": 380,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Utils.Dot",
      "library": "lascar.utils",
      "description": "This module defines types for customizing the visual layout of `.dot` output files used in graph visualization. It includes variants for specifying graph rendering modes such as subgraph inclusion and directional layout (top-down or left-right), along with a record type for defining node appearance through shape and style attributes. These types are used to generate `.dot` files that control how graphs are rendered by tools like Graphviz.",
      "description_length": 442,
      "index": 381,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Utils.Misc",
      "library": "lascar.utils",
      "description": "This module implements logarithmic calculations, time retrieval, comparison operations, fixed-point iteration, and file appending. It operates on basic types like integers, strings, and generic values for comparisons. Concrete use cases include computing log base 2 of integers, appending logs to files, and finding stable results through iterative functions.",
      "description_length": 359,
      "index": 382,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Utils.Tree",
      "library": "lascar.utils",
      "description": "Implements n-ary trees with labeled nodes and edges, providing operations to fold over node values and generate Graphviz visualizations. Works with custom node and edge types defined through a parameter module, organizing them into a hierarchical structure. Useful for constructing and rendering parse trees, directory structures, or hierarchical data with custom attributes.",
      "description_length": 375,
      "index": 383,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Utils.Stringable",
      "library": "lascar.utils",
      "description": "This module defines a polymorphic interface for types that can be converted to strings, primarily used for consistent string representation of values. It includes a function `to_string` that performs the conversion, and is implemented by concrete modules like `Int`, `Bool`, and `List`. Use this module to standardize string output across different data types, such as printing values for logging or serialization.",
      "description_length": 414,
      "index": 384,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Utils.OrderedTypeExt",
      "library": "lascar.utils",
      "description": "This module extends the functionality of ordered types by providing additional operations for comparing and ordering values. It works with any data type that implements a total ordering, such as integers, strings, or custom types with a defined comparison function. Concrete use cases include implementing custom comparison logic for sets and maps, sorting heterogeneous collections, and deriving lexicographic orderings for composite types.",
      "description_length": 441,
      "index": 385,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Utils",
      "library": "lascar.utils",
      "description": "This module organizes a collection of specialized submodules for handling filenames, strings, lists, sets, and graph visualization. Each submodule targets specific tasks such as generating `.dot` files for Graphviz, manipulating file extensions, performing advanced list and set operations, and customizing string representations. Use cases include data parsing, hierarchical tree rendering, log file management, and structured text manipulation.",
      "description_length": 446,
      "index": 386,
      "embedding_norm": 0.9999999403953552
    }
  ],
  "filtering": {
    "total_modules_in_package": 393,
    "meaningful_modules": 387,
    "filtered_empty_modules": 6,
    "retention_rate": 0.9847328244274809
  },
  "statistics": {
    "max_description_length": 760,
    "min_description_length": 217,
    "avg_description_length": 441.92248062015506,
    "embedding_file_size_mb": 5.607724189758301
  }
}