{
  "package": "smtlib-utils",
  "embedding_model": "Qwen/Qwen3-Embedding-0.6B",
  "embedding_dimension": 1024,
  "total_modules": 7,
  "creation_timestamp": "2025-07-15T23:06:10.602475",
  "modules": [
    {
      "module_path": "Smtlib_utils.V_2_6.Lexer.A",
      "library": "smtlib-utils",
      "description": "This module provides utilities for constructing and manipulating SMT-LIB 2.6 expressions, supporting logical formulas, arithmetic and bitvector operations, quantifiers, function definitions, and solver interaction commands like assertions or configuration directives. It operates on algebraic data types representing SMT terms (`term`), types (`ty`), and statements (`statement`), along with structured constructs for declarations, conditionals, and pattern matching. It is used to build abstract syntax trees for SMT scripts, handle parsing errors during expression construction, and format SMT expressions for debugging or solver communication.",
      "description_length": 646,
      "index": 0,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Smtlib_utils.V_2_6.Loc",
      "library": "smtlib-utils",
      "description": "This module handles source code location tracking with precise file, line, and column information. It provides functions to create and manipulate location values from strings, position pairs, or lexing buffers, and supports pretty-printing and string conversion. Typical use cases include error reporting with accurate source positions and integrating parser-generated locations into diagnostic tools.",
      "description_length": 401,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Smtlib_utils.V_2_6.Ast",
      "library": "smtlib-utils",
      "description": "This module provides facilities for building and manipulating SMT-LIB 2.6 abstract syntax trees, focusing on logical and arithmetic expressions, function definitions, and solver commands. It operates on structured representations of terms, types, quantifiers, and statements, enabling precise construction of formulas, variable bindings, and solver interactions. Use cases include generating SMT expressions for verification tasks, modeling constraints with bitvectors or arithmetic, and emitting commands for solvers like Z3 or CVC4.",
      "description_length": 534,
      "index": 2,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Smtlib_utils.V_2_6.Lexer",
      "library": "smtlib-utils",
      "description": "This module processes SMT-LIB v2.6 input by lexing raw text into structured tokens, tracking line numbers and handling low-level parsing tasks. It works with `Lexing.lexbuf` to generate tokens consumed by the parser, enabling the construction of SMT expressions and commands. The child module builds on this by defining core data types like `term`, `ty`, and `statement`, and provides operations for creating and manipulating SMT expressions, including logical formulas, arithmetic, and solver commands. Together, they support tasks such as parsing SMT scripts into ASTs, handling parsing errors, and formatting expressions for debugging or solver interaction.",
      "description_length": 660,
      "index": 3,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Smtlib_utils.V_2_6.Parser",
      "library": "smtlib-utils",
      "description": "This module provides functions to parse SMT-LIB version 2.6 syntax into abstract syntax trees, handling tokens like identifiers, keywords, and literals. It includes parsers for types, terms, and statements, producing structured data used for further processing or analysis. Concrete use cases include reading SMT-LIB input files, processing SMT queries, and building tools that consume SMT-LIB scripts for verification tasks.",
      "description_length": 425,
      "index": 4,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Smtlib_utils.V_2_6",
      "library": "smtlib-utils",
      "description": "This module parses SMT-LIB 2.6 input from various sources into abstract syntax trees, supporting error handling and multiple entry points for files, strings, and lex buffers. It includes data types like `term`, `ty`, and `statement` for representing SMT expressions, along with operations to construct and manipulate logical and arithmetic formulas, function definitions, and solver commands. Submodules track source locations for precise error reporting, lex input into tokens, and define AST structures used in verification tasks. Examples include parsing an SMT script into a list of statements, generating solver commands dynamically, or analyzing expressions with custom logic.",
      "description_length": 682,
      "index": 5,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Smtlib_utils",
      "library": "smtlib-utils",
      "description": "This module parses SMT-LIB 2.6 input from files, strings, or lex buffers into structured abstract syntax trees, handling errors and tracking source locations. It defines core data types like `term`, `ty`, and `statement` to represent and manipulate logical expressions, arithmetic formulas, function definitions, and solver commands. It supports tasks such as parsing SMT scripts, dynamically generating solver queries, or analyzing and transforming expressions with custom logic. Example uses include extracting assertions from a script or building SMT terms programmatically for verification tasks.",
      "description_length": 600,
      "index": 6,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 7,
    "meaningful_modules": 7,
    "filtered_empty_modules": 0,
    "retention_rate": 1.0
  },
  "statistics": {
    "max_description_length": 682,
    "min_description_length": 401,
    "avg_description_length": 564.0,
    "embedding_file_size_mb": 0.025873184204101562
  }
}