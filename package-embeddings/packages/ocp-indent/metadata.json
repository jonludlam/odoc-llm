{
  "package": "ocp-indent",
  "embedding_model": "Qwen/Qwen3-Embedding-8B",
  "embedding_dimension": 4096,
  "total_modules": 14,
  "creation_timestamp": "2025-08-14T23:22:20.087704",
  "modules": [
    {
      "module_path": "IndentExtend",
      "library": "ocp-indent.lexer",
      "description": "This module manages lexer extensions for indentation-sensitive parsing, allowing registration of keyword-token pairs and custom lexers. It works with lexbuf streams and token definitions to support context-specific indentation rules. Use it to implement language extensions that require custom indentation handling, such as domain-specific languages or enhanced syntax blocks.",
      "description_length": 376,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Approx_tokens",
      "library": "ocp-indent.lexer",
      "description": "This module defines a comprehensive set of lexical token types representing OCaml source code elements, including keywords, operators, literals, and punctuation. It provides a `to_string` function to convert each token variant to its corresponding string representation. Concrete use cases include lexing OCaml code, generating readable token output for debugging, and supporting parser development by identifying and handling specific syntactic constructs.",
      "description_length": 457,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Approx_lexer",
      "library": "ocp-indent.lexer",
      "description": "This module supports tokenization, comment handling, and recursive lexing of complex constructs like quotations and verbatim sections, operating on `Lexing.lexbuf` and character streams. It processes lexical tokens (e.g., identifiers, integers, operators) while managing states for nested comments, string buffering, and positional metadata. Key use cases include parsing OCaml source code with precise location tracking for error reporting or AST generation, and handling embedded syntax extensions through customizable lexing rules.",
      "description_length": 534,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "IndentConfig",
      "library": "ocp-indent.lib",
      "description": "This module manages indentation settings for code formatting, providing operations to load, save, and update configurations from files or strings. It works with a record type `t` storing integer and boolean options for indentation levels and styles, along with a custom `man_block` type for documentation formatting. Concrete use cases include reading `.ocp-indent` files to apply project-specific indentation rules, modifying settings via environment variables, and exporting current configurations to disk.",
      "description_length": 508,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "IndentBlock",
      "library": "ocp-indent.lib",
      "description": "This module manages indentation blocks for tracking and adjusting code indentation levels during parsing. It provides operations to shift, set, and reverse indentation, as well as query current indentation, padding, and original column positions. Use cases include handling nested code structures, aligning sub-blocks, and determining correct indentation for empty lines or during partial parsing.",
      "description_length": 397,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "IndentPrinter",
      "library": "ocp-indent.lib",
      "description": "This module manages formatted output generation with indentation control, using a custom type `output_elt` to represent newline, indentation, whitespace, and text elements. It processes streams of tokens (`Nstream.t`) within an indentation context (`IndentBlock.t`) to produce properly indented output. Concrete use cases include generating source code, pretty-printing structured data, and formatting configuration files.",
      "description_length": 422,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "IndentLoader",
      "library": "ocp-indent.dynlink",
      "description": "Loads modules or packages dynamically using Dynlink, enabling runtime extension of the program. Accepts a list of module or package references to link, with an optional debug flag to trace the loading process. Useful for plugin systems or modular applications that need to load components on demand.",
      "description_length": 299,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Compat.String",
      "library": "ocp-indent.utils",
      "description": "This module offers string creation, character-level manipulation (including mapping, trimming, and escaping), and low-level binary parsing via integer extraction and hashing. It works with strings and bytes, supports ASCII, UTF-8, and UTF-16 encodings, and is used for text processing, binary data decoding, and string validation tasks.",
      "description_length": 336,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Pos.Position",
      "library": "ocp-indent.utils",
      "description": "This module represents and manipulates lexer positions, tracking location information during lexical analysis. It provides operations to retrieve the column offset of a position, convert a position to a string, and obtain an initial zero position. Concrete use cases include error reporting with precise source location and tracking input progress in custom lexers.",
      "description_length": 365,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Pos.Region",
      "library": "ocp-indent.utils",
      "description": "This module represents and manipulates text regions defined by start and end positions, typically used during lexing to track source code spans. It supports operations to create regions, query their boundaries (lines, columns, character offsets), compute lengths, shift regions, and access predefined empty regions. Concrete use cases include error reporting with precise source locations and tracking token spans in a lexer.",
      "description_length": 425,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Compat",
      "library": "ocp-indent.utils",
      "description": "This module defines function composition and application operators for pipeline-style programming. It works directly with functions and values of arbitrary types. Use it to streamline control flow in data transformation chains or callback-heavy code.",
      "description_length": 250,
      "index": 10,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Nstream",
      "library": "ocp-indent.utils",
      "description": "This module implements a stream with efficient n-lookup, providing operations to create streams from strings or input channels and retrieve tokens incrementally. It works with a custom token type that includes positional information, a lexer token, newline count, and string fragments. Concrete use cases include parsing source code with precise error locations and incremental token processing in lexers or parsers.",
      "description_length": 416,
      "index": 11,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Pos",
      "library": "ocp-indent.utils",
      "description": "This module handles lexer positions and text regions for tracking source code locations during lexical analysis. It provides functions to manipulate positions (e.g., retrieve column offsets, create initial positions) and regions (e.g., define spans, compute lengths, shift boundaries). Use cases include precise error reporting and token span tracking in custom lexers.",
      "description_length": 369,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Util",
      "library": "ocp-indent.utils",
      "description": "This module combines functions for string manipulation and function composition. It provides tools to split strings by characters or sets of characters, check string prefixes and escape endings, count leading spaces, and shorten strings to a given length. Additionally, it supports composing functions using `compose` and the `@*` operator, along with retrieving default values for optional inputs.",
      "description_length": 398,
      "index": 13,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 14,
    "meaningful_modules": 14,
    "filtered_empty_modules": 0,
    "retention_rate": 1.0
  },
  "statistics": {
    "max_description_length": 534,
    "min_description_length": 250,
    "avg_description_length": 396.57142857142856,
    "embedding_file_size_mb": 0.20331668853759766
  }
}