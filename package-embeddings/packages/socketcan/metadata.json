{
  "package": "socketcan",
  "embedding_model": "BAAI/bge-base-en-v1.5",
  "embedding_dimension": 1024,
  "total_modules": 9,
  "creation_timestamp": "2025-06-18T16:31:59.558489",
  "modules": [
    {
      "module_path": "Socketcan.Id",
      "description": "Creates and manipulates CAN identifiers, supporting both 11-bit standard (SFF) and 29-bit extended (EFF) frame formats. Provides conversion between integer values and identifier types, with operations to enforce format specificity. Used to ensure correct CAN frame identification in embedded systems communication.",
      "description_length": 314,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Socketcan.Frame",
      "description": "The module offers functions to construct, modify, and analyze CAN frames, handling operations like setting/retrieving identifiers, payloads, timestamps, and flags (e.g., RTR, error), along with format conversions between standard and extended CAN. It works with structured data representing frame details, ensuring validation and proper manipulation. Use cases include real-time vehicle diagnostics, industrial control systems, and embedded applications requiring precise CAN message handling.",
      "description_length": 493,
      "index": 1,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Socketcan.Mask",
      "description": "Provides functions to create and manipulate CAN identifier masks for standard (11-bit) and extended (29-bit) frame formats. Works with integer values and a custom type `t` representing mask configurations. Used to filter CAN messages by applying specific bitmasks to identifiers.",
      "description_length": 279,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Socketcan.Filter",
      "description": "Filters incoming CAN data based on ID, frame type, and masking. Operates on CAN identifiers, frame types, and custom masks to select specific messages. Used to isolate certain message types or IDs in real-time network communication.",
      "description_length": 232,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Socketcan.Error",
      "description": "Parses CAN frames to extract error information, returning error types and statuses or empty lists if none are present. Converts error types and statuses to human-readable strings for logging or display. Used to interpret and report errors from CAN network communications.",
      "description_length": 271,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Socketcan.Socket",
      "description": "Creates and manages CAN socket connections, allowing for sending and receiving CAN frames, applying receive filters, and setting error flags. Operates on socket handles and CAN frame data structures. Used to interface with CAN bus hardware for real-time message processing and diagnostics.",
      "description_length": 289,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Socketcan.BCM",
      "description": "Manages CAN message broadcasting through kernel-level sockets, enabling periodic transmission without user-space intervention. It handles operations involving CAN frame configurations, timers, and interface descriptors. The module works with CAN interface names, opcode and flag lists, timer values, and CAN frame data.",
      "description_length": 319,
      "index": 6,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "socketcan",
      "description": "Provides functions to send and receive CAN frames over a socket interface, with support for setting socket options and handling error conditions. Operates on raw CAN frame data structures and socket file descriptors. Used for real-time vehicle diagnostics and industrial control system communication.",
      "description_length": 300,
      "index": 7,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Socketcan",
      "description": "handles CAN identifier creation, frame manipulation, masking, filtering, error parsing, socket management, and message broadcasting. It uses types like identifiers, frames, masks, and socket handles to enable precise control over CAN communication. Operations include setting identifiers, applying masks, filtering messages, extracting errors, and managing socket connections. It supports real-time diagnostics, message filtering, and reliable broadcasting in embedded and vehicle systems.",
      "description_length": 489,
      "index": 8,
      "embedding_norm": 0.9999999403953552
    }
  ],
  "filtering": {
    "total_modules_in_package": 9,
    "meaningful_modules": 9,
    "filtered_empty_modules": 0,
    "retention_rate": 1.0
  },
  "statistics": {
    "max_description_length": 493,
    "min_description_length": 232,
    "avg_description_length": 331.77777777777777,
    "embedding_file_size_mb": 0.03314781188964844
  }
}