{
  "package": "socketcan",
  "embedding_model": "Qwen/Qwen3-Embedding-8B",
  "embedding_dimension": 4096,
  "total_modules": 8,
  "creation_timestamp": "2025-08-14T23:09:41.033094",
  "modules": [
    {
      "module_path": "Socketcan.Frame",
      "library": "socketcan",
      "description": "This module provides functions to construct, manipulate, and analyze raw CAN message frames, supporting operations like setting identifiers (standard/extended format), managing payload data, and handling flags for remote transmission (RTR), error states, and frame type (SFF/EFF). It operates on binary frame representations with strict validation for payload length and identifier constraints, while also enabling timestamp attachment for precise timing analysis. Typical use cases include low-level automotive network communication, diagnostics over CAN buses, and real-time data processing where frame metadata like extended identifiers or error flags must be explicitly managed.",
      "description_length": 682,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Socketcan.Id",
      "library": "socketcan",
      "description": "This module handles creation, transformation, and inspection of CAN identifiers for both standard (11-bit) and extended (29-bit) frame formats. It provides functions to construct identifiers from integers, convert between formats, and check the current format of an identifier. Use cases include preparing CAN message identifiers for transmission or parsing received identifiers to determine their format.",
      "description_length": 405,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Socketcan.Error",
      "library": "socketcan",
      "description": "This module defines error codes and status flags specific to CAN bus communication errors, including transmission timeouts, arbitration loss, controller faults, protocol violations, and transceiver issues. It provides functions to parse error information from a CAN frame and convert error codes to human-readable strings. Use cases include diagnosing CAN bus failures, monitoring error counters, and logging communication issues in embedded systems.",
      "description_length": 450,
      "index": 2,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Socketcan.Filter",
      "library": "socketcan",
      "description": "This module defines filters for incoming CAN messages, allowing precise control over which frames are received based on identifier, mask, and frame type. It supports filtering by standard/extended identifiers, remote frames, and error frames, using configurable match and mask conditions. Concrete use cases include selectively receiving messages from specific CAN nodes or message types, such as ignoring remote frames or isolating extended identifier traffic.",
      "description_length": 461,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Socketcan.BCM",
      "library": "socketcan",
      "description": "This module supports configuring and managing broadcast connections for CAN messages in kernel space, enabling periodic transmission and reception filtering. It works with CAN interfaces, message frames, identifiers, and timers to set up rules for automated message handling. Concrete use cases include scheduling periodic CAN frame transmissions and setting up filters to react to specific incoming frames automatically.",
      "description_length": 421,
      "index": 4,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Socketcan.Mask",
      "library": "socketcan",
      "description": "This module defines and manipulates CAN identifier masks for filtering messages. It supports creating 11-bit (SFF) and 29-bit (EFF) masks from integer values and converting masks back to integers. It is used to configure acceptance filters in SocketCAN by specifying which bits of a CAN identifier must match.",
      "description_length": 309,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Socketcan.Socket",
      "library": "socketcan",
      "description": "This module implements direct interaction with Linux SocketCAN interfaces, providing functions to open, close, and manage CAN sockets for message transmission and reception. It works with CAN frame and filter data structures to enable precise message handling, such as applying receive filters and error flag settings. Concrete use cases include real-time CAN bus communication in automotive or industrial control systems where specific message IDs need to be sent or selectively received.",
      "description_length": 489,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Socketcan",
      "library": "socketcan",
      "description": "This module provides low-level access to Linux SocketCAN for direct CAN bus communication, supporting operations like message transmission, reception, filtering, and error handling. It works with CAN identifiers, frames, masks, and socket configurations to enable precise control over automotive and industrial network interfaces. Concrete use cases include sending and receiving CAN frames with specific identifiers, configuring acceptance filters, diagnosing bus errors, and scheduling periodic message transmissions.",
      "description_length": 519,
      "index": 7,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 8,
    "meaningful_modules": 8,
    "filtered_empty_modules": 0,
    "retention_rate": 1.0
  },
  "statistics": {
    "max_description_length": 682,
    "min_description_length": 309,
    "avg_description_length": 467.0,
    "embedding_file_size_mb": 0.11625003814697266
  }
}