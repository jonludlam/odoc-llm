{
  "package": "rfsm",
  "embedding_model": "Qwen/Qwen3-Embedding-8B",
  "embedding_dimension": 4096,
  "total_modules": 110,
  "creation_timestamp": "2025-08-15T17:58:23.436651",
  "modules": [
    {
      "module_path": "Rfsm.Host.Make.Dynamic.EvSeq.Evset.Event.Syntax.Types",
      "library": "rfsm",
      "description": "This module defines and manipulates type values for event-based computations, supporting construction of function types and type inspection. It works with a `typ` data type representing types in a guest language, including event and boolean types. Concrete use cases include building function types from argument and return types, checking if a type is an event or boolean type, and printing type representations in a readable format.",
      "description_length": 434,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Host.Make.Dynamic.EvSeq.Evset.Event.Syntax",
      "library": "rfsm",
      "description": "This module provides type inspection, expression substitution, and syntax transformation capabilities for event-driven systems, operating on annotated type expressions, lvalues, and declarations. It supports structured manipulation of hierarchical names, VCD trace representation, and environment-aware preprocessing to enable tasks like variable extraction and type-driven code generation. Key mechanisms include type checking predicates, substitution functions, and pretty-printing utilities that maintain context through type environments during expression normalization.",
      "description_length": 574,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Host.Make.Dynamic.EvSeq.Evset.Event.Value",
      "library": "rfsm",
      "description": "This module implements concrete value representations for event-driven finite state machine simulations, handling typed values with support for VCD trace generation and structured value decomposition. It operates on scalar and composite data types like booleans, integers, and records, mapping them to VCD-compatible types and values through `vcd_type` and `vcd_value`. The module is used to serialize state values into VCD format for waveform visualization and simulation debugging.",
      "description_length": 483,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Dynamic.Make.EvSeq.Evset.Event.Syntax.Types",
      "library": "rfsm",
      "description": "This module defines operations for constructing and inspecting types in a functional event-based language. It supports creating function types with `mk_type_fun` and checking type properties like `is_event_type` and `is_bool_type`. The module also provides `pp_typ` for printing type representations, with optional abbreviation control.",
      "description_length": 336,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Host.Make.Static.Syntax.Guest.Types",
      "library": "rfsm",
      "description": "This module defines and manipulates type values for a guest language, including constructing function types and checking for specific primitive types like boolean and event types. It supports creating function types from argument and return type lists and provides predicates to identify built-in types. The module is used to represent and pretty-print guest language types during static analysis or compilation phases.",
      "description_length": 419,
      "index": 4,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rfsm.Host.Make.Dynamic.Eval.Syntax.Types",
      "library": "rfsm",
      "description": "This module defines and manipulates type values for a guest language within a host language implementation. It supports constructing function types with `mk_type_fun`, representing undefined types with `no_type`, and inspecting types with predicates like `is_event_type` and `is_bool_type`. It also provides pretty-printing functionality via `pp_typ` for readable type representation, useful in debugging and error reporting scenarios.",
      "description_length": 435,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Host.Make.Dynamic.EvSeq.Evset.Event",
      "library": "rfsm",
      "description": "This module represents events in a dynamic finite state machine, supporting event classification, comparison, and pretty-printing. It works with events as pure signals, state transitions, or value assignments to lvalues using guest language syntax and values. It is used to model and manipulate state machine behaviors during simulation, including tracking variable updates and state changes for debugging or trace generation.",
      "description_length": 426,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Dynamic.Make.EvSeq.Evset.Event.Value",
      "library": "rfsm",
      "description": "This module defines operations for handling event values with support for VCD (Value Change Dump) output generation. It provides functions to retrieve VCD type and value encodings, flatten structured values into qualified scalar components, and print values. The module works with event values and types, specifically supporting VCD-related transformations for simulation data export.",
      "description_length": 384,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Host.Make.Ctask.G.Syntax.Types",
      "library": "rfsm",
      "description": "This module defines and manipulates type values for a guest language's syntax, supporting construction of function types and inspection of type properties such as whether a type is an event or boolean. It works directly with the `typ` type, which represents type expressions in the guest language. Concrete use cases include building function types from argument and return types, checking if a type corresponds to an event or boolean, and printing type representations in a readable format, optionally abbreviated.",
      "description_length": 515,
      "index": 8,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rfsm.Host.Make.Vhdl.G.Syntax.Types",
      "library": "rfsm",
      "description": "This module defines and manipulates type representations for a VHDL guest language within a host language implementation. It provides constructors for function types and a special undefined type, along with inspectors to identify event and boolean types. These operations support type checking and generation in VHDL code synthesis tasks.",
      "description_length": 338,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Host.Make.Typing.HostSyntax.Guest.Types",
      "library": "rfsm",
      "description": "This module defines and manipulates type values for a guest language within a host language implementation. It provides constructors for creating function types and a distinguished undefined type, along with inspectors to check for specific primitive types like boolean and event types. The module also includes a function to print type representations, supporting both full and abbreviated forms for readability.",
      "description_length": 413,
      "index": 10,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Host.Make.Systemc.G.Syntax.Types",
      "library": "rfsm",
      "description": "This module defines and manipulates type representations for a guest language within a host language implementation. It supports constructing function types from argument and return types, checking for specific primitive types like event and boolean, and printing type representations in a readable format. It is used to model and analyze SystemC-based type systems during compilation or static analysis.",
      "description_length": 404,
      "index": 11,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Host.Make.Dynamic.EvSeq.Evset",
      "library": "rfsm",
      "description": "This module represents sets of events occurring at a specific point in time within a dynamic finite state machine. It provides operations to construct, combine, and query event sets, including adding events, computing unions, and partitioning based on event properties. It works with a list of events and a date value, enabling precise modeling of event sequences during simulation for analysis and debugging.",
      "description_length": 409,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Host.Make.Vhdl.G.Syntax",
      "library": "rfsm",
      "description": "This module provides utilities for manipulating VHDL abstract syntax trees, including type inspection, expression and type pretty-printing, variable extraction from expressions and lvalues, and lvalue construction. It operates on VHDL types, expressions, and lvalues, augmented with substitution environments and type environments for transformations. These tools support tasks like code synthesis, type-directed preprocessing, and variable tracking in embedded VHDL representations.",
      "description_length": 483,
      "index": 13,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Host.Make.Vhdl.G.Static",
      "library": "rfsm",
      "description": "This module evaluates expressions and functions in a guest language to produce static values, specifically handling cases where functions are not supported by returning undefined results. It operates on expression and value types defined by the guest language, such as literals and function bodies with argument lists. Concrete use cases include static compilation of expressions and partial evaluation of functions during code generation.",
      "description_length": 439,
      "index": 14,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rfsm.Host.Make.Static.Syntax.Guest",
      "library": "rfsm",
      "description": "This module provides utilities for type analysis, syntax manipulation, and substitution operations on guest language constructs. It works with annotated type expressions, lvalues, expressions, and identifiers to support tasks like static type checking, variable dependency extraction, and VCD trace representation. These tools enable compilation pipelines, environment-driven expression preprocessing, and formal verification workflows requiring precise type-aware transformations.",
      "description_length": 481,
      "index": 15,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Systemc.Make.G.Syntax.Types",
      "library": "rfsm",
      "description": "This module defines and manipulates type values used to represent function and event types in a guest language. It supports constructing function types from argument and return types, checking if a type is an event or boolean type, and printing types in a readable format. Concrete use cases include type checking and code generation for function declarations and event handling in embedded systems.",
      "description_length": 399,
      "index": 16,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rfsm.Host.Make.Dynamic.Eval.Value",
      "library": "rfsm",
      "description": "This module defines operations for handling dynamic values in a guest language implementation, including converting values to VCD types and encodings, flattening structured values for VCD dumping, and printing values. It works with guest language values and types, producing VCD-specific representations where applicable. Concrete use cases include serializing boolean, numeric, and record values into VCD format for simulation tracing and debugging.",
      "description_length": 450,
      "index": 17,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Host.Make.Ctask.G.Syntax",
      "library": "rfsm",
      "description": "This module supports type inspection, substitution, and formatting operations on annotated syntax trees, focusing on type expressions, declarations, and l-values. It provides utilities for type validation (e.g., checking boolean or event types), variable extraction from expressions and l-values, and environment-driven preprocessing of code structures. These capabilities are particularly useful for tasks like type-directed code analysis, variable dependency tracking, and preparing guest language syntax for compilation or transformation pipelines.",
      "description_length": 551,
      "index": 18,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rfsm.Dynamic.Make.EvSeq.Evset.Event",
      "library": "rfsm",
      "description": "This module represents events in a dynamic finite state machine, supporting operations to construct, compare, and pretty-print events such as pure events, state transitions, and value assignments. It works with event types including identifiers, l-values, and VCD-compatible values, enabling simulation trace generation and analysis. Concrete use cases include modeling state machine transitions, capturing value updates for simulation dumps, and generating human-readable event logs.",
      "description_length": 484,
      "index": 19,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Vhdl.Make.G.Syntax.Types",
      "library": "rfsm",
      "description": "This module defines and manipulates type values for a guest language's syntax, supporting operations to construct function types, inspect type properties like boolean or event types, and print type representations. It works with a concrete `typ` type that represents the various data types in the guest language's type system. Use cases include building and analyzing types during the parsing or transformation of guest language expressions.",
      "description_length": 441,
      "index": 20,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Ctask.Make.G.Syntax.Types",
      "library": "rfsm",
      "description": "This module defines and manipulates type values used to represent the types of expressions and functions in a guest language. It supports constructing function types from argument and return types, checking if a type corresponds to an event or boolean, and printing types in either full or abbreviated form. Concrete use cases include type checking expressions, representing function signatures, and generating readable type output during debugging or error reporting.",
      "description_length": 468,
      "index": 21,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Host.Make.Systemc.G.Syntax",
      "library": "rfsm",
      "description": "This module supports type inspection, construction, and transformation for a SystemC-embedded DSL, focusing on operations like type validation (e.g., checking boolean or event types), expression and lvalue manipulation, and environment-aware preprocessing. It works with annotated type expressions, lvalues, and declarations to enable static analysis, code generation, and simulation trace formatting (e.g., VCD output). Specific applications include preprocessing expressions for type-dependent transformations and extracting variables for analysis or simulation visualization.",
      "description_length": 578,
      "index": 22,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rfsm.Host.Make.Systemc.G.Static",
      "library": "rfsm",
      "description": "This module evaluates SystemC expressions and functions in a static context, handling literals and function definitions where supported. It operates on `expr` and `value` types, enabling static analysis of expressions that do not depend on runtime state. Concrete use cases include constant folding and early evaluation of function bodies during compilation.",
      "description_length": 358,
      "index": 23,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Host.Make.Dynamic.Eval.Syntax",
      "library": "rfsm",
      "description": "This module provides operations for type manipulation, expression substitution, and preprocessing in a dynamic evaluation context. It works with type expressions, declarations, l-values, and expressions, supporting tasks like type inspection (e.g., detecting boolean/event types), alias declaration construction, and name substitution under type environments. Specific use cases include dynamic evaluation of embedded guest language code, VCD trace generation for l-values, and type-directed preprocessing of expressions.",
      "description_length": 521,
      "index": 24,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Host.Make.Typing.HostSyntax.Guest",
      "library": "rfsm",
      "description": "This module provides type manipulation, substitution, and preprocessing operations for guest language syntax trees, working with expressions (`expr`), type declarations (`type_decl`), and left-values (`lval`). It supports tasks like VCD trace generation through lvalue normalization and symbolic evaluation via environment-guided expression transformations, leveraging typed syntax representations for correctness during host language implementation. Key utilities include type inspection, variable extraction, and scoped formatting for debugging or intermediate representation purposes.",
      "description_length": 587,
      "index": 25,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rfsm.Host.Make.Dynamic.Eval",
      "library": "rfsm",
      "description": "This module evaluates guest language expressions in a dynamic environment, supporting type-directed execution and VCD trace generation. It provides operations to evaluate expressions to values or booleans, update environments with l-value bindings, and print environment contents. Concrete use cases include dynamic execution of embedded guest code, condition checking in simulations, and debugging via environment inspection.",
      "description_length": 426,
      "index": 26,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Host.Make.Static.Syntax",
      "library": "rfsm",
      "description": "This module provides operations for static analysis, transformation, and structured representation of formal models in a guest language, focusing on type-aware program composition, model substitution, and normalization. It operates on static syntax trees and guest language components like expressions, transitions, and type declarations, enabling tasks such as model refinement and symbolic manipulation. Specific use cases include programmatically constructing guest programs, normalizing model parameters, and generating human-readable representations of formal models for debugging or documentation.",
      "description_length": 603,
      "index": 27,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Dynamic.Make.EvSeq.Evset",
      "library": "rfsm",
      "description": "This module represents timed event sets in a dynamic finite state machine, providing operations to construct, manipulate, and query collections of events occurring at a specific date. It supports concrete operations such as adding individual events, computing unions, partitioning based on event properties, and pretty-printing for logging or trace analysis. Use cases include tracking simultaneous state transitions and value changes at a given simulation time, merging event sets from parallel state machines, and generating structured simulation output for debugging or VCD generation.",
      "description_length": 588,
      "index": 28,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Host.Make.Ctask.G",
      "library": "rfsm",
      "description": "This module implements type-aware C code generation by processing annotated syntax trees. It provides functions to format typed symbols, type expressions, declarations, and expressions into their corresponding C syntax, enabling direct translation of guest language constructs to valid C code. Key use cases include compiling guest language programs to C implementations and generating C headers from type declarations.",
      "description_length": 419,
      "index": 29,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Host.Make.Static.Typing",
      "library": "rfsm",
      "description": "This module implements static typing for guest language programs within a host language framework. It processes program syntax trees to infer types, producing structured typed programs that include typed models and instances. It is used to validate and transform untyped guest programs into typed forms for further compilation or analysis steps.",
      "description_length": 345,
      "index": 30,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Host.Make.Dynamic.EvSeq",
      "library": "rfsm",
      "description": "This module manages sequences of event sets for dynamic finite state machines, supporting operations to merge, construct, and format event timelines. It works with lists of event sets paired with time values, enabling precise simulation of event-driven behavior. Concrete use cases include modeling periodic and sporadic event patterns, such as scheduling signals or state transitions in reactive systems.",
      "description_length": 405,
      "index": 31,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Systemc.Make.G.Static",
      "library": "rfsm",
      "description": "This module evaluates expressions and functions in a static context, producing corresponding values. It supports evaluating literals and function expressions with a list of arguments, returning their static result. Use it to resolve constant expressions or function closures during compilation, when symbolic computation is needed without runtime execution.",
      "description_length": 357,
      "index": 32,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rfsm.Host.Make.Systemc.G",
      "library": "rfsm",
      "description": "This module provides functions to pretty-print SystemC declarations, expressions, and values, operating directly on `expr`, `lval`, `type_expr`, and `value` types. It supports concrete use cases such as generating SystemC code from internal DSL representations, formatting simulation traces, and printing typed symbols for header file declarations. The module enables direct translation of internal structures into valid SystemC syntax for both interface (`.h`) and implementation (`.cpp`) files.",
      "description_length": 496,
      "index": 33,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Systemc.Make.G.Syntax",
      "library": "rfsm",
      "description": "This module offers operations to construct, analyze, and format type expressions, expressions, and l-values, with a focus on type validation (e.g., checking boolean or event types), variable extraction from expressions/l-values, and generating structured output for code generation or trace visualization. It supports substitution mappings and preprocessing transformations that manipulate identifiers and types within environment contexts, enabling scoped identifier resolution and type-driven adjustments. These capabilities are particularly used in embedded system modeling to synthesize code, produce simulation traces, and enforce correct handling of hierarchical or scoped identifiers during compilation.",
      "description_length": 710,
      "index": 34,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Host.Make.Static.Value",
      "library": "rfsm",
      "description": "This module implements value handling for a guest language's static types, providing default value generation, VCD type and value translation, and structured value flattening for signal dumping. It operates on static values and types, decomposing records and scalars into VCD-compatible representations. Concrete use cases include initializing values for simulation, converting values to VCD signals, and pretty-printing values during debugging.",
      "description_length": 445,
      "index": 35,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rfsm.Vhdl.Make.G.Syntax",
      "library": "rfsm",
      "description": "This module provides operations for constructing, transforming, and analyzing annotated syntax trees, including type expressions, declarations, and expressions. It supports identifier substitution under mappings, type checking (e.g., validating boolean or event types), variable extraction from expressions, and pretty-printing with scope information. These capabilities are used in tasks like type analysis, code transformation pipelines, and generating structured VHDL output for compiler or interpreter implementations.",
      "description_length": 522,
      "index": 36,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Vhdl.Make.G.Static",
      "library": "rfsm",
      "description": "This module evaluates expressions and functions in a static context, handling cases where evaluation is possible at compile time. It operates on expression and value types specific to the guest language's static semantics. Use it to resolve constant expressions or function literals during compilation, particularly in contexts like VHDL code generation where static values are required for synthesis.",
      "description_length": 401,
      "index": 37,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Host.Make.Typing.HostSyntax",
      "library": "rfsm",
      "description": "This module provides type and expression manipulation operations, substitution, normalization, and pretty-printing utilities for a guest language embedded within a host implementation. It operates on expressions, types, program components, and scoped identifiers, with specialized support for formal state machine models, including actions, transitions, and states. These capabilities enable tasks like model and type declarations, condition processing, and generating human-readable output for debugging, logging, or code generation workflows.",
      "description_length": 544,
      "index": 38,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Host.Make.Vhdl.G",
      "library": "rfsm",
      "description": "This module generates VHDL code from guest language constructs by translating types, expressions, and values into their VHDL equivalents. It provides functions to print VHDL type declarations, expressions, lvalues, and values, along with support for shared variable type checks and type-directed function generation in entity and architecture definitions. It directly handles VHDL abstract syntax trees and operates on guest language types and values augmented with environment data for transformations.",
      "description_length": 503,
      "index": 39,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Ctask.Make.G.Syntax",
      "library": "rfsm",
      "description": "This module offers operations for constructing, analyzing, and transforming type expressions, expressions, and l-values in a guest language syntax. It provides utilities for type checking (e.g., verifying boolean or event types), variable extraction from expressions/l-values, identifier substitution under scoped environments, and syntactic manipulations like name normalization, specifically supporting VCD trace generation and type-driven preprocessing workflows.",
      "description_length": 466,
      "index": 40,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Host.Make.Vhdl",
      "library": "rfsm",
      "description": "Translates guest language types and expressions into VHDL code, generating type declarations, expressions, lvalues, and values. Operates on guest language constructs augmented with environment data to produce VHDL abstract syntax trees. Outputs VHDL files to a specified directory, supporting type-directed function generation and shared variable checks within entity and architecture definitions.",
      "description_length": 397,
      "index": 41,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Dynamic.Make.EvSeq",
      "library": "rfsm",
      "description": "This module implements sequences of timed event sets for dynamic finite state machines, with support for merging, periodic and sporadic event generation, and value change tracking. It operates on lists of event sets, where each event set corresponds to a specific point in time, and provides functions to construct and combine these sequences. Concrete use cases include modeling timed signal transitions in digital circuits, coordinating events in discrete-event simulations, and generating structured output for trace analysis or VCD files.",
      "description_length": 542,
      "index": 42,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Depg.G.V",
      "library": "rfsm",
      "description": "This module represents vertices in a graph where each vertex is labeled with a simple identifier. It provides operations to create vertices from labels and to access the label of a vertex. The module supports comparison, hashing, and equality checks for vertices, enabling efficient use in data structures like sets and maps.",
      "description_length": 325,
      "index": 43,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rfsm.Host.Make.Static",
      "library": "rfsm",
      "description": "This module assembles and represents fully-constructed guest language models with normalized syntax, typing, and value environments. It processes `fsm` structures, `ctx`, and typed programs to build and inspect complete formal models, supporting operations like model validation, signal reader/writer tracking, and hierarchical composition. Concrete use cases include constructing executable FSM models from parsed programs, analyzing signal dependencies for simulation, and pretty-printing structured models for verification or code generation.",
      "description_length": 545,
      "index": 44,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rfsm.Vhdl.Make.G",
      "library": "rfsm",
      "description": "This module converts annotated syntax trees into VHDL representations, handling type declarations, expressions, and values. It provides functions for mapping types to VHDL equivalents, validating shared variable types, and pretty-printing VHDL code for both interface and implementation layers. It is used to generate synthesizable VHDL code from internal language constructs during compilation.",
      "description_length": 395,
      "index": 45,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Depg.G.E",
      "library": "rfsm",
      "description": "This module represents directed edges between named vertices in a graph, where edges carry no additional data beyond source and destination. It provides functions to create edges, retrieve source and destination vertices, and compare edges. Concrete use cases include modeling transitions in finite state machines and dependencies between named nodes in a directed graph.",
      "description_length": 371,
      "index": 46,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Host.Make.Typing",
      "library": "rfsm",
      "description": "This module implements type checking and environment management for state machine models in the host language. It provides functions to create and manipulate typing environments, type entire programs, and pretty-print environments and typed programs. Key operations include `mk_env` for initializing empty environments, `type_program` for inferring types of guest language programs, and formatting utilities for debugging state machine models and their type information.",
      "description_length": 470,
      "index": 47,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Depg.G.Mark",
      "library": "rfsm",
      "description": "This module manages integer markers associated with vertices in a graph where vertices are simple names. It provides operations to set, get, and clear these markers, enabling tracking or labeling of vertices with numerical values. Concrete use cases include annotating nodes with visitation counts, priority levels, or state indicators during graph traversal or analysis.",
      "description_length": 371,
      "index": 48,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Ctask.Make.G",
      "library": "rfsm",
      "description": "This module provides functions to pretty-print type expressions, expressions, and type declarations in C syntax. It operates on guest language constructs such as identifiers, type expressions, and expressions, producing C-compatible string representations suitable for code generation or debugging. Concrete use cases include generating C declarations for variables, printing complex types for VCD trace handling, and formatting expressions for type-driven preprocessing.",
      "description_length": 471,
      "index": 49,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Systemc.Make.G",
      "library": "rfsm",
      "description": "This module evaluates expressions and type declarations in a static context, producing SystemC-compatible representations for embedded system modeling. It supports type validation, expression analysis, and code generation through structured formatting functions that output SystemC declarations and implementations. Concrete use cases include synthesizing SystemC code from high-level type and expression trees and generating simulation traces with correctly scoped identifiers and typed symbols.",
      "description_length": 496,
      "index": 50,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rfsm.Host.Make.Dynamic",
      "library": "rfsm",
      "description": "This module dynamically executes guest language programs in an environment that evolves over time, producing event sequences that represent the program's behavior. It supports evaluating expressions to values or booleans, updating environments with l-value assignments, and generating VCD traces for simulation and debugging. Concrete use cases include simulating reactive systems with time-varying state and generating event timelines for verification.",
      "description_length": 453,
      "index": 51,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Host.Make.Ctask",
      "library": "rfsm",
      "description": "This module implements type-aware C code generation by processing annotated syntax trees. It provides functions to format typed symbols, type expressions, declarations, and expressions into their corresponding C syntax. Use cases include compiling guest language programs to C implementations and generating C headers from type declarations.",
      "description_length": 341,
      "index": 52,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rfsm.Host.Make.Vcd",
      "library": "rfsm",
      "description": "Generates Value Change Dump (VCD) files from simulation sequences, capturing signal transitions over time. Works with sequences of timestamped events and signal values. Used to visualize digital circuit behavior in tools that support VCD playback.",
      "description_length": 247,
      "index": 53,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Host.Make.Dot",
      "library": "rfsm",
      "description": "Generates DOT files representing finite state machines from static guest language specifications. It writes graph visualizations to disk, using the guest language's structure to define nodes and transitions. This module is used to produce diagrams for analysis or documentation during compilation phases.",
      "description_length": 304,
      "index": 54,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rfsm.Host.Make.Systemc",
      "library": "rfsm",
      "description": "This module implements host language bindings for SystemC by transforming guest language expressions and types into SystemC syntax. It operates on `expr`, `lval`, `type_expr`, and `value` to generate code for simulation traces, header declarations, and implementation files. Concrete use cases include translating internal DSL constructs to SystemC interfaces and emitting typed symbol definitions for simulation and synthesis.",
      "description_length": 427,
      "index": 55,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Vhdl.Make",
      "library": "rfsm",
      "description": "This module generates VHDL code from annotated syntax trees, converting types and expressions into synthesizable VHDL representations. It validates shared variable types and maps internal constructs to VHDL equivalents, handling both interface and implementation layers. Used during compilation to produce hardware descriptions from internal language constructs.",
      "description_length": 362,
      "index": 56,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Event.Make",
      "library": "rfsm",
      "description": "This module defines event types for state machine transitions, including pure events, variable updates, and state moves. It provides comparison, pretty-printing, and type-checking operations for these events. Use it to model and manipulate state machine behaviors with precise event tracking.",
      "description_length": 292,
      "index": 57,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Syntax.Make",
      "library": "rfsm",
      "description": "This module provides operations for combining programs, substituting model inputs/outputs and parameters, normalizing models, and pretty-printing components of a finite state machine (FSM) abstract syntax tree (AST). It manipulates AST elements like actions, transitions, states, and models, enabling use cases such as debugging, code generation, and program analysis in a guest language environment.",
      "description_length": 400,
      "index": 58,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Host.Make",
      "library": "rfsm",
      "description": "This module builds a host language implementation from a guest language definition, providing type checking, model construction, simulation, and code generation. It works with state machine models, typed programs, environments, and simulation traces, supporting concrete tasks like generating DOT visualizations, compiling to C or SystemC, and producing VCD traces for simulation. Key operations include type inference, model elaboration, dynamic execution, and syntax translation for verification and implementation workflows.",
      "description_length": 527,
      "index": 59,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Ext.File",
      "library": "rfsm",
      "description": "This module handles file operations including directory validation, file opening and closing, and content copying with string substitution. It works with file paths, input/output channels, and format formatters. It is used for tasks like generating configuration files from templates by replacing placeholders with actual values.",
      "description_length": 329,
      "index": 60,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rfsm.Vcd.Make",
      "library": "rfsm",
      "description": "This module writes event sequences to a Value Change Dump (VCD) file for waveform visualization. It takes a sequence of events from the `EvSeq` module and outputs them in VCD format, suitable for tools like GTKWave. The `output` function writes the sequence to a specified file, converting event timestamps and values into the appropriate VCD representation.",
      "description_length": 358,
      "index": 61,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Ext.Option",
      "library": "rfsm",
      "description": "This module provides a function for pretty-printing optional values. It works with the standard `option` type and allows custom formatting of both `Some` and `None` cases. A concrete use case is formatting optional fields in data structures for logging or user-facing output.",
      "description_length": 275,
      "index": 62,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Evseq.Make",
      "library": "rfsm",
      "description": "This module implements operations for constructing and combining event sequences, represented as lists of event sets. It provides functions to create periodic, sporadic, or value-changing events tied to identifiers, and supports merging sequences using concatenation or union. These operations are used to model timed event streams in reactive systems, such as scheduling signals or tracking input changes over time.",
      "description_length": 416,
      "index": 63,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Ext.Base",
      "library": "rfsm",
      "description": "Implements mathematical exponentiation for base 2, logical negation of predicates, tuple element swapping, and deep value copying. Operates on integers, boolean functions, pairs, and arbitrary values. Useful for bit manipulation, predicate inversion, data structure transformation, and state duplication.",
      "description_length": 304,
      "index": 64,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Ext.Format",
      "library": "rfsm",
      "description": "This module provides functions for formatting output with precise control over spacing and line breaks. It works with OCaml's `Format.formatter` type to enable custom pretty-printing of values. Concrete use cases include generating well-formatted log messages, structured output for debugging, and aligning text in command-line interfaces.",
      "description_length": 339,
      "index": 65,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Typing.Make",
      "library": "rfsm",
      "description": "This module enforces type safety in finite state machines by validating and annotating components like actions, transitions, and guards using a guest-host integrated typing environment. It operates on type-annotated abstract syntax trees and models to ensure correctness across expressions, function declarations, and global environments,",
      "description_length": 338,
      "index": 66,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Dynamic.Make",
      "library": "rfsm",
      "description": "Implements timed event sequence generation and manipulation for dynamic finite state machines. It works with lists of event sets indexed by time, providing functions to merge sequences, generate periodic and sporadic events, and track value changes. Used to model signal transitions in digital circuits, coordinate discrete-event simulations, and produce structured traces for analysis or VCD output.",
      "description_length": 400,
      "index": 67,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Ctask.Make",
      "library": "rfsm",
      "description": "This module generates C-compatible string representations of guest language constructs, including type expressions, expressions, and type declarations. It supports operations for pretty-printing identifiers and structuring code output, primarily used in code generation pipelines and debugging tools. Concrete use cases include emitting C declarations for variables, formatting types for VCD trace handling, and preparing expressions for type-driven preprocessing.",
      "description_length": 464,
      "index": 68,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rfsm.Depg.G",
      "library": "rfsm",
      "description": "This module provides directed graph operations with labeled vertices and unweighted edges, supporting vertex/edge creation, structural modifications, and traversal queries for predecessors and successors. It works with a graph type storing named vertices and unweighted edges, augmented by a marking system for integer-based vertex annotations. Designed for finite state machine modeling and dependency graph analysis, it enables state tracking through markers while allowing transformations like edge addition, vertex removal, and property-based filtering.",
      "description_length": 557,
      "index": 69,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rfsm.Ext.List",
      "library": "rfsm",
      "description": "This module provides operations for list manipulation, including computing cartesian products, modifying association lists, and scattering elements based on a function. It supports standard list types and association lists, with functions for adding, replacing, and printing elements in various formats. Concrete use cases include transforming and formatting lists of structured data, managing key-value mappings with list values, and generating readable output for debugging or logging.",
      "description_length": 487,
      "index": 70,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rfsm.Systemc.Make",
      "library": "rfsm",
      "description": "This module evaluates expressions and type declarations in a static context, producing SystemC-compatible representations for embedded system modeling. It supports type validation, expression analysis, and code generation through structured formatting functions that output SystemC declarations and implementations. Concrete use cases include synthesizing SystemC code from high-level type and expression trees and generating simulation traces with correctly scoped identifiers and typed symbols.",
      "description_length": 496,
      "index": 71,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rfsm.Depg.TS",
      "library": "rfsm",
      "description": "This module performs topological sorting on directed graphs, mapping vertex names to descriptors and managing dependencies. It provides `fold` and `iter` functions to traverse graph vertices in topological order. Use it to resolve dependencies in build systems or schedule tasks with precedence constraints.",
      "description_length": 307,
      "index": 72,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Evset.Make",
      "library": "rfsm",
      "description": "This module implements an event set data structure that stores a collection of events with a timestamp. It supports operations to create, merge, and filter event sets, as well as query their contents and structure. Use it to manage and manipulate time-stamped event data, such as logging systems or event sourcing architectures.",
      "description_length": 328,
      "index": 73,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rfsm.Depg.M",
      "library": "rfsm",
      "description": "This module offers associative map operations for managing key-value associations where keys are identifiers and values are arbitrary data or lists, supporting insertion, deletion, merging, and traversal. It works with graph structures where vertices correspond to named keys, enabling transformations, filtering, and equality checks over these mappings, while also handling conversions between maps and key-value sequences. It is particularly useful for dependency resolution, configuration management, or data pipeline scenarios requiring structured key-based access and bulk data manipulation.",
      "description_length": 596,
      "index": 74,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rfsm.Dot.Make",
      "library": "rfsm",
      "description": "Generates static graph representations in DOT format for visualization. It operates on `Static.t` data structures, which model finite state machines. Use it to export state machine diagrams to files for debugging or documentation.",
      "description_length": 230,
      "index": 75,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Cmodel.Make",
      "library": "rfsm",
      "description": "This module defines and manipulates finite state machine models with typed states, transitions, and variables. It supports parsing and pretty-printing of state machine components such as inputs, outputs, and internal variables, along with constructing state machine instances from syntax trees. It is used to model and analyze state machines with typed expressions and structured transitions.",
      "description_length": 392,
      "index": 76,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Compiler.Make",
      "library": "rfsm",
      "description": "Builds a compiler structure from a language definition, lexer, and parser. It coordinates parsing and lexing stages to process input according to the defined language. Useful for implementing domain-specific language compilers with custom syntax and semantics.",
      "description_length": 260,
      "index": 77,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Static.Make",
      "library": "rfsm",
      "description": "This module builds and prints a static representation of finite state machines (FSMs) with typed contexts, global variables, functions, and dependencies. It processes typed and syntax-level programs to construct structured FSMs, track input/output/shared variables with their readers and writers, and define user types and constants. Use it to analyze or generate code from FSM-based models with precise type and dependency information.",
      "description_length": 436,
      "index": 78,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rfsm.Depg.Make",
      "library": "rfsm",
      "description": "Implements dependency-aware topological sorting of nodes within a given context. Uses node and context types from the N module to resolve dependencies and order nodes accordingly. Useful for scheduling tasks or processing elements in a directed acyclic graph where dependencies must be respected.",
      "description_length": 296,
      "index": 79,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Cmodel",
      "library": "rfsm",
      "description": "This module defines and manipulates finite state machine models with typed states, transitions, and variables. It supports parsing and pretty-printing of state machine components such as inputs, outputs, and internal variables, along with constructing state machine instances from syntax trees. It is used to model and analyze state machines with typed expressions and structured transitions.",
      "description_length": 392,
      "index": 80,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Vhdl_types",
      "library": "rfsm",
      "description": "This module defines data types and operations for representing and printing VHDL type declarations. It includes types for common VHDL types like `std_logic`, `unsigned`, `signed`, `integer`, `real`, `boolean`, and structured types like arrays, enums, and records. The module supports concrete use cases such as generating VHDL code from internal type representations and configuring type output formats through a mutable configuration object.",
      "description_length": 442,
      "index": 81,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Annot",
      "library": "rfsm",
      "description": "This module creates and transforms annotated values with location and type information. It supports constructing values paired with source locations and types, and mapping functions over the value and type while preserving location. Used to track source positions and types during parsing and analysis of formal models.",
      "description_length": 319,
      "index": 82,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Bits",
      "library": "rfsm",
      "description": "This module provides precise bit-level manipulation of integers, including extracting and setting specific bit ranges. It operates on integers and uses strings to represent bit-level encodings. It is useful for low-level systems programming tasks such as encoding instruction sets, handling hardware registers, or implementing binary protocols.",
      "description_length": 344,
      "index": 83,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rfsm.Misc",
      "library": "rfsm",
      "description": "This module defines the action semantics for state machines as either Sequential or Synchronous. It includes functions for handling errors and warnings during execution, such as raising fatal errors, issuing warnings, and marking unimplemented features. These operations are used to manage control flow and error handling in state machine implementations.",
      "description_length": 355,
      "index": 84,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Vcd_types",
      "library": "rfsm",
      "description": "This module defines types for representing Value Change Dump (VCD) data, including signal types like integers, booleans, and floats, along with their string and formatted representations. It supports operations to register and pretty-print VCD signals, which associate identifiers with types and single-character VCD identifiers. Use cases include generating and manipulating VCD files for digital signal simulation and trace visualization.",
      "description_length": 440,
      "index": 85,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Host",
      "library": "rfsm",
      "description": "This module implements a host language for building and analyzing state machine models with typed programs and environments. It provides operations for type inference, model elaboration, simulation, and code generation, supporting tasks like DOT visualization, C/SystemC compilation, and VCD trace generation. It works directly with state machines, typed expressions, execution traces, and syntax trees to enable verification and implementation workflows.",
      "description_length": 455,
      "index": 86,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Vhdl",
      "library": "rfsm",
      "description": "This module generates VHDL code for finite state machines, supporting simulation with VCD or GHW waveform dumps. It defines configuration parameters for naming conventions, time units, reset signals, and trace options, and works with state machine descriptions to produce testbenches and synthesizable VHDL. Concrete use cases include generating simulation testbenches for FPGA development and exporting state machines for hardware synthesis.",
      "description_length": 442,
      "index": 87,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Event",
      "library": "rfsm",
      "description": "This module defines operations for handling events in a finite state machine, including creating, dispatching, and matching events against transitions. It works with event types that carry payloads, enabling state transitions based on event type and data. Concrete use cases include modeling user inputs, system signals, or asynchronous messages that trigger state changes.",
      "description_length": 373,
      "index": 88,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rfsm.Systemc",
      "library": "rfsm",
      "description": "This module provides functions to configure and generate SystemC code from state machine models. It defines a configuration structure with mutable fields for setting library names, file prefixes, simulation parameters, and tracing options. Concrete use cases include customizing output file names, specifying simulation time units and stop times, and enabling trace generation for state variables during simulation.",
      "description_length": 415,
      "index": 89,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Evseq",
      "library": "rfsm",
      "description": "This module implements operations for constructing and combining event sequences, represented as lists of event sets. It provides functions to create periodic, sporadic, or value-changing events tied to identifiers, and supports merging sequences using concatenation or union. These operations are used to model timed event streams in reactive systems, such as scheduling signals or tracking input changes over time.",
      "description_length": 416,
      "index": 90,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Dynamic",
      "library": "rfsm",
      "description": "Implements dynamic semantics for simulating programs based on a formal specification. It maintains a mutable configuration (`cfg`) with active semantics and verbosity settings, and defines a module type `DYNAMIC` that structures the interface for execution behavior. This module is used to control and customize the runtime interpretation of program models during simulation.",
      "description_length": 375,
      "index": 91,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rfsm.Evset",
      "library": "rfsm",
      "description": "This module implements an event set data structure that stores events with a timestamp. It supports creation, merging, filtering, and querying of event sets. Use it for managing time-stamped event data in logging systems or event sourcing architectures.",
      "description_length": 253,
      "index": 92,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Compiler",
      "library": "rfsm",
      "description": "This module implements a command-line compiler for processing input files using a parser and lexer. It defines module types for the parser and lexer interfaces, which are used to specify the required functions for tokenizing and parsing input. Concrete use cases include compiling domain-specific languages or structured data formats from text files.",
      "description_length": 350,
      "index": 93,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Logfile",
      "library": "rfsm",
      "description": "This module manages the logging of compiler output to a file. It provides operations to start and stop logging, write strings to the log, and control the output channel. Concrete use cases include capturing compiler diagnostics and runtime messages for debugging or auditing purposes.",
      "description_length": 284,
      "index": 94,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Env",
      "library": "rfsm",
      "description": "This module implements a map-like environment structure keyed by `Rfsm.Ident.t` identifiers, supporting operations such as adding, updating, and looking up bindings, as well as traversing and transforming environments. It provides functions to construct environments from binding lists, query membership, merge environments, and filter or map over bindings. Use cases include managing variable scopes in interpreters, tracking state in reactive systems, and handling configuration mappings where identifier-based access is required.",
      "description_length": 532,
      "index": 95,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Depg",
      "library": "rfsm",
      "description": "This module manages dependency graphs using directed graphs with labeled vertices and unweighted edges, supporting operations like edge addition, vertex removal, and topological sorting. It works with graph structures augmented by markers and maps to track and resolve dependencies between named entities. Concrete use cases include task scheduling with precedence constraints, dependency resolution in build systems, and state tracking in finite state machines.",
      "description_length": 462,
      "index": 96,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Vcd",
      "library": "rfsm",
      "description": "This module writes event sequences to a Value Change Dump (VCD) file for waveform visualization. It takes a sequence of events from the `EvSeq` module and outputs them in VCD format, suitable for tools like GTKWave. The `output` function writes the sequence to a specified file, converting event timestamps and values into the appropriate VCD representation.",
      "description_length": 358,
      "index": 97,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Subst",
      "library": "rfsm",
      "description": "This module implements substitution mappings from identifiers to arbitrary values, supporting application of substitutions to identifiers and pretty-printing of substitutions. It works with identifier-keyed dictionaries where identifiers are of type `Rfsm.Ident.t`. Use cases include managing variable bindings during symbolic evaluation or transforming expressions with named variables.",
      "description_length": 387,
      "index": 98,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rfsm.Dot",
      "library": "rfsm",
      "description": "Generates static graph representations in DOT format for visualization. It operates on `Static.t` data structures, which model finite state machines. Use it to export state machine diagrams to files for debugging or documentation.",
      "description_length": 230,
      "index": 99,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Ext",
      "library": "rfsm",
      "description": "This module extends standard library components with specialized operations for data manipulation and formatting. It includes functions for mathematical operations on integers, custom text layout with format specifiers, advanced list transformations, handling optional values with custom formatting, and file management with template substitution. These features support tasks like bit manipulation, structured logging, association list processing, and dynamic file generation.",
      "description_length": 477,
      "index": 100,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rfsm.Ctask",
      "library": "rfsm",
      "description": "This module defines a configuration structure `cfg` for managing state variables, received events, and global data in a state machine context. It provides a shared backend interface for implementing state machine logic with mutable model visibility settings. Concrete use cases include configuring and controlling the behavior of state machines in reactive systems.",
      "description_length": 365,
      "index": 101,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Static",
      "library": "rfsm",
      "description": "Performs static elaboration of a typed program, resolving type information and generating an optimized intermediate representation. Works with typed abstract syntax trees and module type declarations. Used to prepare programs for further compilation stages by ensuring type correctness and expanding type abbreviations.",
      "description_length": 319,
      "index": 102,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Syntax",
      "library": "rfsm",
      "description": "This module provides operations for combining programs, substituting model inputs, outputs, and parameters, normalizing models, and pretty-printing FSM AST components. It works with abstract syntax tree elements such as actions, transitions, states, and models. Use cases include debugging, code generation, and program analysis in a guest language environment.",
      "description_length": 361,
      "index": 103,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rfsm.Version",
      "library": "rfsm",
      "description": "Holds the version string of the compiler. Provides direct access to the current version information as a string. Useful for logging, diagnostics, and version checks during compilation or runtime.",
      "description_length": 195,
      "index": 104,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rfsm.Ident",
      "library": "rfsm",
      "description": "This module manages identifiers with local or global scope, providing operations to create, modify, and print them. It supports concrete use cases like generating globally unique names with `mk_global`, restricting names to local scope with `mk_local`, and transforming identifier strings with `upd_id`. Functions like `pp_qual` ensure proper name qualification during output, while `compare` enables identifier ordering for collection types.",
      "description_length": 442,
      "index": 105,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rfsm.Typing",
      "library": "rfsm",
      "description": "Implements type inference and checking for expressions and statements in the host language. Works with abstract syntax trees and type environments to validate type correctness during compilation. Ensures variables are used consistently with their declared types and enforces type constraints on operations.",
      "description_length": 306,
      "index": 106,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Location",
      "library": "rfsm",
      "description": "This module represents and manipulates source code locations with precise file, start, and end positions. It provides functions to create locations from lexing positions, retrieve the current location during parsing, format and print location information, and access input sources like filenames and lex buffers. It is used to track and report precise error positions in source files during parsing or compilation tasks.",
      "description_length": 420,
      "index": 107,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Options",
      "library": "rfsm",
      "description": "This module provides functions to configure compiler behavior through mutation of global state, including setting output formats, boolean flags, and simulation parameters. It operates on a `target` type with variants like Dot, Sim, and CTask, mutable configuration values for output directories and function names, and command-line option specifications. These functions enable use cases such as selecting output formats (SystemC, VHDL), activating debugging outputs (type environment dumps), and tuning simulation settings (trace levels, VCD size).",
      "description_length": 549,
      "index": 108,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Guest",
      "library": "rfsm",
      "description": "This module defines the core interfaces and structures required to implement a guest language, including type systems, syntax, evaluation, and error handling. It works with abstract data types representing language values, expressions, and static analysis results. Concrete use cases include building domain-specific languages with strict typing, evaluating expressions in a controlled environment, and generating code in formats like SystemC or VHDL.",
      "description_length": 451,
      "index": 109,
      "embedding_norm": 0.9999999403953552
    }
  ],
  "filtering": {
    "total_modules_in_package": 112,
    "meaningful_modules": 110,
    "filtered_empty_modules": 2,
    "retention_rate": 0.9821428571428571
  },
  "statistics": {
    "max_description_length": 710,
    "min_description_length": 195,
    "avg_description_length": 417.2090909090909,
    "embedding_file_size_mb": 1.5947380065917969
  }
}