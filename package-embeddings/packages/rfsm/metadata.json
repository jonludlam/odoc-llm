{
  "package": "rfsm",
  "embedding_model": "Qwen/Qwen3-Embedding-0.6B",
  "embedding_dimension": 1024,
  "total_modules": 303,
  "creation_timestamp": "2025-07-16T00:05:18.422450",
  "modules": [
    {
      "module_path": "Rfsm.Host.Make.Dynamic.EvSeq.Evset.Event.Syntax.Types",
      "library": "rfsm",
      "description": "This module defines and manipulates type values for a guest language embedded within a host language implementation. It supports constructing function types from argument and return types, and checking if a type corresponds to an event or boolean. These operations are used to enforce type constraints when building and validating event-driven expressions in the guest language.",
      "description_length": 378,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Host.Make.Dynamic.EvSeq.Evset.Event.Syntax",
      "library": "rfsm",
      "description": "This module provides core type definitions and operations for representing and manipulating types in a guest language, including the construction of function types from argument and return types. It includes checks to determine if a type represents an event or boolean, ensuring type correctness in event-driven expressions. Submodules extend this functionality with additional type manipulations and validations specific to the guest language's syntax. For example, it supports building a function type from `(int -> event)` and verifying that a given type is an event type.",
      "description_length": 575,
      "index": 1,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rfsm.Host.Make.Dynamic.EvSeq.Evset.Event.Value",
      "library": "rfsm",
      "description": "This module defines operations for handling event values in a dynamic event sequence system. It supports creating default values for types, converting values to VCD-compatible types and encodings, and flattening structured values into scalar components for VCD output. It works with event values and structured types such as records, and is used to generate VCD signals for simulation tracing.",
      "description_length": 393,
      "index": 2,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rfsm.Dynamic.Make.EvSeq.Evset.Event.Syntax.Types",
      "library": "rfsm",
      "description": "This module defines and manipulates type values for a guest language, supporting operations to construct function types and inspect type properties such as whether a type is an event or boolean. It works with a concrete `typ` type representing guest language types, including base types and function types. Use cases include type checking and pretty-printing type expressions in a domain-specific language embedded in OCaml.",
      "description_length": 424,
      "index": 3,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rfsm.Host.Make.Dynamic.Eval.Syntax.Types",
      "library": "rfsm",
      "description": "This module defines and manipulates type values for a dynamically evaluated functional language embedded within a host language. It supports constructing function types from argument and return types, checking for specific primitive types like events and booleans, and pretty-printing types in either full or abbreviated form. Typical use cases include type checking expressions during evaluation and displaying type information in error messages or debugging output.",
      "description_length": 467,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Dynamic.Make.EvSeq.Evset.Event.Syntax",
      "library": "rfsm",
      "description": "This module provides core operations for analyzing and transforming expressions and l-values, with support for type checking, substitution, and scoped variable management. It works with types like `typ` for representing guest language types, enabling tasks such as function type construction and type property inspection. Submodules extend this functionality to handle domain-specific modeling, static analysis, and simulation of reactive systems using event sequences and VCD traces. Examples include transforming type expressions, extracting variables from syntax trees, and applying identifier replacements during preprocessing.",
      "description_length": 631,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Host.Make.Vhdl.G.Syntax.Types",
      "library": "rfsm",
      "description": "This module defines and manipulates type representations for a guest VHDL language implementation. It provides constructors for function types and special undefined types, along with inspectors to check for event and boolean types. The module is used to build and query typed expressions in VHDL frontends, supporting type-aware transformations and analyses.",
      "description_length": 358,
      "index": 6,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rfsm.Host.Make.Dynamic.EvSeq.Evset.Event",
      "library": "rfsm",
      "description": "This module models events in a dynamic finite state machine, supporting pure events, transitions, and variable assignments, with operations to classify, compare, and format events. It integrates type handling from its submodules to ensure correctness when building and inspecting event-driven expressions, such as constructing a function type `(int -> event)` and validating event types. The value-handling submodule enables VCD-compatible signal generation by converting and flattening event values, including structured types like records, into scalar components. Together, these components allow manipulation and tracing of event sequences during simulation.",
      "description_length": 661,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Host.Make.Systemc.G.Syntax.Types",
      "library": "rfsm",
      "description": "This module defines and manipulates type representations for a guest language in a SystemC embedding. It supports constructing function types, inspecting event and boolean types, and printing type information with optional abbreviation. These operations are used to model and process SystemC-like type semantics within a higher-level host language framework.",
      "description_length": 358,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Host.Make.Typing.HostSyntax.Guest.Types",
      "library": "rfsm",
      "description": "This module defines and manipulates type values for a guest language within a host language implementation. It provides constructors for function types and a distinguished undefined type, along with predicates to check for specific built-in types such as event and boolean. The module also includes a function to print type representations, supporting both full and abbreviated forms.",
      "description_length": 384,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Dynamic.Make.EvSeq.Evset.Event.Value",
      "library": "rfsm",
      "description": "This module defines operations for handling event values with support for VCD serialization and structured value decomposition. It provides functions to retrieve default values for types, convert values to VCD types and encodings, flatten structured values into scalar components for VCD output, and print values. The module works with scalar and structured value types, specifically tailored for use in VCD generation and simulation trace workflows.",
      "description_length": 450,
      "index": 10,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Host.Make.Ctask.G.Syntax.Types",
      "library": "rfsm",
      "description": "This module defines and manipulates type values for a guest language's syntax, supporting construction of function types and inspection of built-in types such as events and booleans. It works directly with the `typ` type, which represents type expressions in the guest language. Concrete use cases include building function types from argument and return types, checking if a type is an event or boolean, and printing type representations in a readable format.",
      "description_length": 460,
      "index": 11,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Host.Make.Static.Syntax.Guest.Types",
      "library": "rfsm",
      "description": "This module defines and manipulates guest language types within a host language implementation. It provides constructors for function types and a distinguished undefined type, along with inspectors to identify boolean and event types. The module supports pretty-printing of types, optionally in abbreviated form, for use in code generation and type debugging tasks.",
      "description_length": 365,
      "index": 12,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rfsm.Host.Make.Systemc.G.Syntax",
      "library": "rfsm",
      "description": "This module provides utilities for analyzing and transforming SystemC abstract syntax trees, with core operations for type checking, variable extraction, and syntax rewriting. It handles expressions, l-values, and type declarations, supporting tasks like trace generation and macro expansion, while its child module defines and processes type representations for embedded SystemC semantics. Specific uses include static analysis passes, simulation instrumentation, and constructing function and event types during code generation. Together, they enable deep manipulation of SystemC syntax and type information within a host language environment.",
      "description_length": 645,
      "index": 13,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Host.Make.Vhdl.G.Static",
      "library": "rfsm",
      "description": "This module evaluates expressions and functions in a guest language's static context, producing corresponding values. It handles expressions composed of literals, constants, and potentially functions, depending on guest language support. Use it to resolve compile-time constants or evaluate simple embedded expressions without runtime dependencies.",
      "description_length": 348,
      "index": 14,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Systemc.Make.G.Syntax.Types",
      "library": "rfsm",
      "description": "This module defines and manipulates type values used to represent function and primitive types in a guest language. It supports constructing function types from argument and return types, inspecting type properties such as whether a type is an event or boolean, and printing types in a readable format. Concrete use cases include type checking expressions, generating type signatures, and debugging type information during compilation or analysis.",
      "description_length": 447,
      "index": 15,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Host.Make.Dynamic.Eval.Value",
      "library": "rfsm",
      "description": "This module defines operations for handling dynamic values in a guest language implementation, providing functions to convert values to VCD-compatible types and encodings, and to flatten structured values into scalar components for waveform dumping. It works with values of type `t` and their corresponding types `typ`, supporting VCD type mapping, value extraction, and hierarchical decomposition. Concrete use cases include generating VCD output for simulation traces by converting guest language values into VCD representations and flattening compound structures for signal visualization.",
      "description_length": 591,
      "index": 16,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Host.Make.Vhdl.G.Syntax",
      "library": "rfsm",
      "description": "This module provides utilities for analyzing and transforming VHDL abstract syntax trees, with a focus on type manipulation, expression processing, and name resolution. It includes core operations for extracting variables, querying type properties such as array or boolean checks, and generating hierarchical signal paths for VCD tracing. The associated type module defines and manipulates type representations, offering constructors for function and undefined types along with inspectors for event and boolean types. Together, they support tasks like syntax formatting, identifier substitution, and preprocessing parameterized expressions for hardware compilation.",
      "description_length": 665,
      "index": 17,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rfsm.Ctask.Make.G.Syntax.Types",
      "library": "rfsm",
      "description": "This module defines and manipulates type values used to represent function signatures and primitive types in a guest language. It supports constructing function types from argument and return types, checking for specific primitive types like events or booleans, and printing types in a readable format. Concrete use cases include type checking function declarations and formatting type information for error messages or debugging.",
      "description_length": 430,
      "index": 18,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rfsm.Host.Make.Dynamic.Eval.Syntax",
      "library": "rfsm",
      "description": "This module provides core utilities for inspecting types, traversing abstract syntax trees, and manipulating l-values in embedded functional languages. It supports dynamic evaluation workflows through operations like runtime identifier substitution, environment-driven rewriting, and variable reference analysis, while its child module handles type construction, checking, and pretty-printing for primitives like events and booleans. Use cases include evaluating expressions with type-directed preprocessing, generating VCD traces from ASTs, and displaying type information during error reporting or debugging. Together, they enable robust analysis and transformation of embedded language code at runtime.",
      "description_length": 705,
      "index": 19,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Vhdl.Make.G.Syntax.Types",
      "library": "rfsm",
      "description": "This module defines and manipulates type values used in a guest language's syntax tree. It supports constructing function types, inspecting type properties such as whether a type is an event or boolean, and printing type representations in a readable format. Concrete use cases include type checking expressions, generating type annotations, and debugging type information during compilation or analysis tasks.",
      "description_length": 410,
      "index": 20,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Host.Make.Typing.HostSyntax.Guest",
      "library": "rfsm",
      "description": "This module enables type inspection, substitution, and preprocessing of expressions and type constructs, working with data structures like type expressions, declarations, and l-values to support type checking, code generation, and trace outputs such as VCD files. It includes operations for environment-driven transformations through identifier substitution and type-directed rewrites. The module defines core type values, including function types and an undefined type, with predicates for built-in types like event and boolean, and supports printing type representations in full or abbreviated form. Example uses include rewriting expressions based on type information and generating traceable output from typed intermediate representations.",
      "description_length": 743,
      "index": 21,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Host.Make.Systemc.G.Static",
      "library": "rfsm",
      "description": "This module provides static evaluation of expressions and function creation in a guest language context. It operates on expression and value types, supporting concrete use cases like compile-time constant evaluation and function closure generation. Key functions include `eval` for static expression evaluation and `eval_fn` for creating function values from argument lists and bodies.",
      "description_length": 385,
      "index": 22,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Host.Make.Ctask.G.Syntax",
      "library": "rfsm",
      "description": "This module handles type inspection, syntax manipulation, and preprocessing for expressions and l-values in a typed intermediate representation. It supports operations like identifier substitution, type-directed rewriting, and pretty-printing, working with core data types such as `typ`, declarations, and scoped identifiers. The child module focuses on defining and inspecting guest language types, enabling construction of function types, recognition of built-in types like events and booleans, and readable type printing. Together, they facilitate tasks like VCD trace generation and managing scoped variables during host-guest language interactions.",
      "description_length": 653,
      "index": 23,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Host.Make.Dynamic.EvSeq.Evset",
      "library": "rfsm",
      "description": "This module manages sets of events associated with specific dates, supporting creation, modification, and querying through operations like adding events and computing unions or partitions. Its child module models events as part of a dynamic finite state machine, enabling the definition of transitions, variable assignments, and event classification, with support for type-safe expressions and signal generation. The value-handling submodule converts structured event data into scalar components, facilitating VCD-compatible tracing and simulation. Together, these components allow precise modeling and manipulation of event sequences in time-based systems, such as simulating state transitions triggered by timestamped events.",
      "description_length": 727,
      "index": 24,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rfsm.Dynamic.Make.EvSeq.Evset.Event",
      "library": "rfsm",
      "description": "This module models events in a state machine, supporting pure events, assignments, and transitions, with utilities to classify, compare, and pretty-print them. It integrates expression analysis and type handling through its submodules, enabling type inspection, variable extraction, and transformation of expressions and l-values. Another submodule supports VCD serialization, allowing structured values to be decomposed, converted, and printed for simulation trace workflows. Together, these components enable modeling, transformation, and simulation of reactive systems with typed event sequences and trace generation.",
      "description_length": 620,
      "index": 25,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rfsm.Host.Make.Static.Syntax.Guest",
      "library": "rfsm",
      "description": "This module provides utilities for manipulating type expressions, declarations, and expressions in a guest language, supporting substitution over identifiers and parameters, type-directed preprocessing, variable extraction, VCD trace generation, and scoped name mangling. It works with core data types like type expressions, declarations, and l-values, enabling operations such as type-preserving transformations and scoped variable management. The child module defines guest language types including function and undefined types, with inspectors for boolean and event types, and supports pretty-printing for code generation and debugging. Together, they allow implementing type checkers, transformation passes, and debugging tools with precise control over syntax and type scoping.",
      "description_length": 782,
      "index": 26,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Host.Make.Typing.HostSyntax",
      "library": "rfsm",
      "description": "This module defines the core syntax and typing system for a host language, providing operations for manipulating types, expressions, and declarations within abstract syntax trees. It supports model substitution, normalization, and structural printing, enabling tasks like code generation, debugging, and transformation of typed intermediate representations. Key data types include type expressions, function types, and l-values, with operations for environment-driven substitution, type-directed rewriting, and trace output generation such as VCD files. Example uses include rewriting expressions based on type information and producing formatted type representations for debugging or code emission.",
      "description_length": 699,
      "index": 27,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rfsm.Host.Make.Vhdl.G",
      "library": "rfsm",
      "description": "This module generates VHDL code from guest language types and expressions, handling type declarations, value formatting, and variable constraints while producing synthesizable output for entities and architectures. It evaluates compile-time expressions and transforms VHDL syntax trees, supporting type analysis, expression processing, and hierarchical signal path generation for VCD tracing. Key operations include translating guest language values into VHDL literals, resolving static expressions, and manipulating type representations with constructors for arrays, functions, and undefined types. Examples include converting a guest language integer constant into a VHDL `unsigned` literal, extracting signal names from an architecture for simulation, or preprocessing a parameterized expression into a hardware-friendly form.",
      "description_length": 829,
      "index": 28,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rfsm.Systemc.Make.G.Syntax",
      "library": "rfsm",
      "description": "This module provides tools for analyzing and transforming abstract syntax trees in a domain-specific language embedded within OCaml, with support for type-directed manipulations, identifier substitution, and scoped naming. Its core functionality works with structured representations of types, expressions, and l-values, enabling tasks like generating VCD traces for hardware simulation or implementing type-safe code transformations. The child module handles construction and inspection of guest language types, including function types and primitive type properties, supporting operations such as type checking, signature generation, and readable type output. Together, they allow developers to build, analyze, and transform embedded DSLs with rich syntactic and semantic tooling.",
      "description_length": 782,
      "index": 29,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Host.Make.Ctask.G",
      "library": "rfsm",
      "description": "This module provides pretty-printing functions for Ctask syntax elements, generating valid C code fragments from high-level Rfsm constructs. It operates on syntax trees and type representations, supporting data types such as `typ`, declarations, and scoped identifiers. The module enables identifier substitution, type-directed rewriting, and readable type printing, while its child module extends type inspection and preprocessing for expressions and l-values. Together, they support tasks like VCD trace generation and managing scoped variables during host-guest language interactions.",
      "description_length": 587,
      "index": 30,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Host.Make.Static.Value",
      "library": "rfsm",
      "description": "This module implements value handling for a guest language's static types, providing conversions to VCD format and pretty-printing. It supports structured and scalar values, with operations to decompose records into scalar components qualified by a base identifier. Key use cases include generating VCD output for simulation traces and displaying default values for types during debugging or initialization.",
      "description_length": 407,
      "index": 31,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Ctask.Make.G.Syntax",
      "library": "rfsm",
      "description": "This module handles the construction, transformation, and analysis of syntax elements such as expressions, l-values, and type expressions in a guest language. It supports identifier substitution, environment-dependent preprocessing, variable extraction, and type checks\u2014like verifying boolean types\u2014used in code generation and static analysis. Its type manipulation submodule enables building and inspecting function and primitive types, supporting tasks like type checking function declarations and formatting types for error messages. Together, these capabilities facilitate tasks ranging from VCD trace generation to debugging and compiler pipeline stages.",
      "description_length": 659,
      "index": 32,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Vhdl.Make.G.Syntax",
      "library": "rfsm",
      "description": "This module provides tools for building, analyzing, and transforming VHDL-like syntax structures, including type expressions, l-values, and declarations. It includes operations for type checking, variable extraction, and name manipulation, working with environments to support identifier substitution and preprocessing. The child module focuses on type values, enabling construction of function types, inspection of type properties like event or boolean flags, and readable type printing. Together, they support tasks such as generating VCD traces, resolving type-driven expressions, and debugging type information during compilation.",
      "description_length": 634,
      "index": 33,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rfsm.Host.Make.Dynamic.Eval",
      "library": "rfsm",
      "description": "This module evaluates expressions and manages environments for a dynamically scoped guest language, supporting mutable state and runtime variable binding through `eval_expr`, `eval_bool`, `mk_env`, and `upd_env`. Its child modules handle value conversion for VCD output and AST traversal for type inspection and l-value manipulation, enabling simulation trace generation and type-directed expression evaluation. The core functionality works with dynamic values of type `t` and their types `typ`, allowing VCD-compatible encoding, hierarchical flattening, and runtime identifier resolution. Examples include executing guest language code with mutable environments, converting structured values into scalar signals for waveform visualization, and analyzing expression types during evaluation.",
      "description_length": 790,
      "index": 34,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Dynamic.Make.EvSeq.Evset",
      "library": "rfsm",
      "description": "This module manages collections of events tied to specific dates, supporting creation, combination, and manipulation of event sets through operations like union, partitioning, and emptiness checks. It models events as state machine transitions, including pure events, assignments, and typed expressions, with utilities for classification, comparison, and pretty-printing. Submodules enable expression analysis, variable extraction, and VCD serialization for simulation trace workflows. Examples include tracking system logs, scheduling tasks, and generating structured simulation traces for reactive systems.",
      "description_length": 608,
      "index": 35,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Host.Make.Systemc.G",
      "library": "rfsm",
      "description": "This module generates SystemC code from guest language constructs, offering functions to emit SystemC syntax for types, expressions, l-values, and values. It operates on core data types like `type_expr`, `type_decl`, `expr`, `lval`, and `value`, enabling tasks such as printing type declarations to headers and expressions to implementation files. Its first child module enables analysis and transformation of SystemC ASTs, supporting type checking, macro expansion, and trace generation. The second child module evaluates expressions and creates functions statically, handling compile-time constants and closures.",
      "description_length": 614,
      "index": 36,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Systemc.Make.G.Static",
      "library": "rfsm",
      "description": "This module evaluates expressions and functions in a guest language, supporting static analysis of code where expressions can be resolved to values without runtime execution. It works with abstract data types `expr` and `value`, representing expressions and their computed results. Concrete use cases include compiling or optimizing guest language code by resolving constants and simple functions at compile time.",
      "description_length": 413,
      "index": 37,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Vhdl.Make.G.Static",
      "library": "rfsm",
      "description": "This module provides static evaluation of expressions into values, supporting function evaluation with `eval_fn` for argument binding and `eval` for direct expression evaluation. It operates on `expr` and `value` types, handling cases where expressions cannot be statically resolved by raising `Non_static_value`. Concrete use cases include compile-time constant evaluation and partial function application in guest languages that support static contexts.",
      "description_length": 455,
      "index": 38,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Host.Make.Dynamic.EvSeq",
      "library": "rfsm",
      "description": "This module orchestrates event sequence manipulation for dynamic guest language execution, combining time-based event streams, merging sequences from multiple sources, and generating periodic or sporadic events. It operates on lists of event sets indexed by identifiers, with core data types representing timestamps, event classifications, and value-labeled transitions. Child modules refine this foundation by managing event sets at specific dates, modeling dynamic finite state machines with typed expressions, and converting structured event data into scalar traces for simulation. Examples include defining input traces for testing, simulating state transitions triggered by timestamped events, and generating VCD-compatible signal logs from event sequences.",
      "description_length": 762,
      "index": 39,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Host.Make.Static.Syntax",
      "library": "rfsm",
      "description": "This module provides syntax tree manipulation, substitution, and normalization operations for guest language programs embedded in a host language, working with abstract syntax representations of programs, models, states, transitions, and expressions. It includes utilities for querying state I/O, formatting structured data, and rendering syntax elements in human-readable form, supporting program transformation, model optimization, and debugging. The child module extends this functionality with type-specific operations, including substitution over identifiers and parameters, scoped name mangling, and type-directed preprocessing, working with type expressions, declarations, and l-values. Together, they enable type-preserving transformations, trace generation, and scoped variable management, supporting tasks like type checking, code generation, and debugging with precise control over syntax and typing.",
      "description_length": 911,
      "index": 40,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Host.Make.Static.Typing",
      "library": "rfsm",
      "description": "This module performs static typing of guest language programs within a host language context. It processes `HostSyntax.program` values, producing `typed_program` structures that include typed models and instance bindings. Key operations include environment initialization, program typing, and pretty-printing of environments and typed programs.",
      "description_length": 344,
      "index": 41,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Depg.G.V",
      "library": "rfsm",
      "description": "This module implements vertex values for dependency graphs where vertices are labeled with simple identifiers. It provides operations to create vertices from labels, retrieve their labels, and compare or hash vertices based on their labels. Useful for managing named nodes in static analysis or build system dependency tracking.",
      "description_length": 328,
      "index": 42,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Host.Make.Dot",
      "library": "rfsm",
      "description": "Generates Dot-formatted string representations of static structures, such as state machines or transitions, for visualization. Uses the `Static.t` type to capture precomputed state and outputs lines suitable for rendering with Graphviz. Useful for debugging or documenting guest language semantics through graphical output.",
      "description_length": 323,
      "index": 43,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Host.Make.Dynamic",
      "library": "rfsm",
      "description": "This module enables dynamic evaluation of reactive programs through event-driven execution, combining expression evaluation with event sequence processing to simulate systems with evolving state. It provides core data types `t` and `typ` for dynamic values and their types, along with operations like `eval_expr`, `eval_bool`, and `upd_env` for evaluating and modifying guest language expressions and environments. Event handling is managed through timestamped event streams, with functions to merge, generate, and process events for simulating inputs, state transitions, and output traces. Examples include executing mutable guest code, converting structured values into scalar signals, and generating VCD logs from event sequences.",
      "description_length": 733,
      "index": 44,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Vhdl.Make.G",
      "library": "rfsm",
      "description": "This module translates OCaml types and expressions into VHDL representations, supporting type checking, VHDL type mapping, and pretty-printing for hardware synthesis and simulation. It includes a submodule for constructing and analyzing VHDL-like syntax structures, enabling type inspection, variable extraction, and environment-based transformations, useful for generating VCD traces and resolving type-driven expressions. Another submodule provides static evaluation of expressions via `eval` and `eval_fn`, handling constant folding and partial application, with support for detecting non-static values. Together, these components allow tasks like converting OCaml type definitions into synthesizable VHDL, evaluating expressions at compile time, and debugging type information during translation.",
      "description_length": 800,
      "index": 45,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Host.Make.Static",
      "library": "rfsm",
      "description": "This module implements a host language for a static guest language, enabling the construction, transformation, and type-checking of programs represented as finite state machines with structured contexts. It supports core operations on programs, models, and typed expressions, working with data types such as `program`, `typed_program`, and `context`, while child modules handle value representation, syntax manipulation, and static typing. The value module converts structured and scalar values to VCD format and decomposes records into scalar components, useful for simulation trace generation and debugging. The syntax module provides AST manipulation, substitution, and normalization, while the typing module processes untyped programs into fully typed structures, supporting end-to-end compilation and analysis workflows.",
      "description_length": 825,
      "index": 46,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Host.Make.Systemc",
      "library": "rfsm",
      "description": "This module compiles a guest language description into SystemC code, generating modules, ports, and signals while supporting customizable output paths. It processes core data types such as `type_expr`, `expr`, and `lval` to emit SystemC syntax, enabling tasks like writing type declarations to headers or expressions to implementation files. Its submodules analyze and transform SystemC ASTs for type checking and macro expansion, and evaluate expressions statically to build functions and handle constants. Specific uses include generating traceable signal assignments and compiling guest language closures into SystemC method processes.",
      "description_length": 638,
      "index": 47,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rfsm.Dynamic.Make.EvSeq",
      "library": "rfsm",
      "description": "This module orchestrates event sequence manipulation for timed automata simulations, combining temporal operations like merging, periodic definition, and sporadic event specification with structured event set management. It models events as timestamped state transitions, supporting union, partitioning, and emptiness checks, while enabling classification, comparison, and trace serialization through submodules. Concrete uses include scheduling clock-driven transitions, capturing system logs with precise timing, and generating simulation traces for reactive systems. Key data types include event sets, timestamped expressions, and state-change triggers, manipulated through combinators and analysis utilities.",
      "description_length": 712,
      "index": 48,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Ctask.Make.G",
      "library": "rfsm",
      "description": "This module generates C code from high-level representations by transforming abstract syntax trees that model C expressions, types, and declarations. It supports operations such as pretty-printing type expressions, formatting function signatures, and translating complex types into compilable C syntax. The child module enriches this process by enabling type manipulation, identifier substitution, and environment-aware preprocessing, which are used for tasks like static analysis, VCD trace generation, and debugging. Together, they allow translating typed variables and expressions into C code, verifying type correctness in declarations, and preparing intermediate representations for compilation or diagnostic output.",
      "description_length": 721,
      "index": 49,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rfsm.Host.Make.Vhdl",
      "library": "rfsm",
      "description": "This module translates guest language descriptions of finite state machines into synthesizable VHDL code, operating on `Static.t` structures to generate entities and architectures. It handles type declarations, expression evaluation, and signal path generation, supporting arrays, functions, and undefined types through dedicated constructors. Key operations include converting guest language values into VHDL literals, resolving static expressions, and producing hardware-friendly forms for synthesis. Examples include transforming an integer constant into a VHDL `unsigned` literal, extracting signal names for simulation, and preprocessing parameterized expressions into synthesizable code.",
      "description_length": 693,
      "index": 50,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Host.Make.Vcd",
      "library": "rfsm",
      "description": "Implements value change dump (VCD) output generation for guest language sequences. Provides the `output` function to write VCD data to a file, using a guest-defined sequence type `seq`. Useful for exporting simulation traces to VCD format for external analysis or visualization.",
      "description_length": 278,
      "index": 51,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Host.Make.Ctask",
      "library": "rfsm",
      "description": "This module coordinates task execution between host and guest languages, using typed directories to manage guest operations and static configurations to produce output lists. It schedules tasks and aggregates results for language integrations, while its submodules generate C code from Rfsm constructs, transform syntax trees, and handle type-directed rewriting. Key data types include `typ`, declarations, and scoped identifiers, with operations for substitution, type inspection, and expression preprocessing. Examples include producing VCD traces, managing scoped variables, and translating high-level constructs into executable C fragments.",
      "description_length": 644,
      "index": 52,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Systemc.Make.G",
      "library": "rfsm",
      "description": "This module generates SystemC code from internal representations of types and expressions, producing declarations and implementations for headers and source files. It builds on syntactic and semantic tools from its submodules to analyze and manipulate abstract syntax trees, supporting type-directed transformations, identifier substitution, and scoped naming. Developers can emit SystemC interfaces, compile guest language expressions into constants, and generate readable type signatures or VCD traces for simulation. Core data types include structured representations of types, expressions, and values, enabling both code generation and static analysis tasks.",
      "description_length": 662,
      "index": 53,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Depg.G.Mark",
      "library": "rfsm",
      "description": "Tracks integer markers on graph vertices, providing direct access to vertex states via `get` and `set`. Uses standard graph and vertex types from the parent module. Useful for algorithms requiring per-vertex state tracking, such as coloring or traversal markers.",
      "description_length": 262,
      "index": 54,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Host.Make.Typing",
      "library": "rfsm",
      "description": "This module provides type checking and environment management for guest language programs, working with structured representations that include models and identifier-instance pairs. It constructs and prints typing environments, types programs, and formats results, while integrating core syntax and typing operations from its child module for manipulating type expressions, function types, and l-values. You can use it to perform environment-driven type substitution, normalize expressions, generate trace outputs like VCD files, and produce structured type representations for debugging or code generation.",
      "description_length": 607,
      "index": 55,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rfsm.Depg.G.E",
      "library": "rfsm",
      "description": "This module represents directed edges in a graph where vertices are simple names. It provides operations to create edges with source and destination vertices, retrieve edge labels (which are always unit), and compare edges. Concrete use cases include building and manipulating dependency graphs where edges indicate relationships between named nodes.",
      "description_length": 350,
      "index": 56,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rfsm.Evseq.EVSEQ-Evset",
      "library": "rfsm",
      "description": "This module manages sequences of events associated with a specific date, providing operations to create, modify, and query event sets. It supports key functions like adding events, merging event sets, filtering via partitioning, and pretty-printing for debugging. Concrete use cases include tracking time-stamped events in a state machine or processing batches of events occurring at the same logical time.",
      "description_length": 406,
      "index": 57,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "Rfsm.Static.T-Value",
      "library": "rfsm",
      "description": "This module defines a type `t` representing values and provides operations to convert and decompose values into VCD-compatible types and scalar components. It includes functions to retrieve default values for types, map values to VCD types and encodings, and flatten structured values into qualified scalar pairs for VCD output. It supports use cases like generating VCD traces from structured data in simulation environments.",
      "description_length": 426,
      "index": 58,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rfsm.Host.T-Typing-HostSyntax",
      "library": "rfsm",
      "description": "This module provides operations for constructing and transforming typed intermediate program representations, including model substitution, normalization, and pretty-printing of structured components. It works with formal state machine elements like actions, transitions, and states, alongside types, expressions, and program structures defined in the host syntax. These capabilities support use cases in formal verification, compiler toolchains, and program analysis where structured manipulation and human-readable rendering of state machine models are required.",
      "description_length": 564,
      "index": 59,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Host.T-Typing-HostSyntax-Guest-Types",
      "library": "rfsm",
      "description": "This module defines and manipulates type values for a guest language embedded within a host syntax. It supports constructing function types from argument and return types, inspecting types to determine if they represent events or booleans, and printing types in a readable format. Concrete use cases include type checking and inference in a guest language interpreter or compiler.",
      "description_length": 380,
      "index": 60,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Guest.CTASK",
      "library": "rfsm",
      "description": "This module provides functions to pretty-print C declarations and expressions from an abstract syntax tree. It handles typed symbols, type expressions, type declarations, and expressions, converting them into their corresponding C syntax. Use cases include generating C code from a higher-level representation during compilation or translation tasks.",
      "description_length": 350,
      "index": 61,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Evset.Make",
      "library": "rfsm",
      "description": "This module implements an event set data structure that stores a collection of events with a timestamp. It supports operations to create, merge, and filter event sets, as well as query their contents and metadata. Use it to manage time-stamped event logs, track state changes in reactive systems, or aggregate events from distributed sources.",
      "description_length": 342,
      "index": 62,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rfsm.Dynamic.DYNAMIC-EvSeq-Evset",
      "library": "rfsm",
      "description": "This module manages collections of events associated with specific dates, providing operations to create, combine, and manipulate event sets. It supports concrete operations like adding individual events, computing unions, and partitioning event sets based on predicates. Use cases include tracking time-stamped events, merging event streams, and filtering events for processing or analysis.",
      "description_length": 391,
      "index": 63,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Systemc.SYSTEMC-Static-Typing",
      "library": "rfsm",
      "description": "This module implements static typing for SystemC programs by analyzing and transforming untyped program structures into explicitly typed representations. It processes program models and instance declarations, ensuring type consistency across components and interfaces. Concrete use cases include type-checking SystemC models during compilation and generating typed program representations for further analysis or code generation.",
      "description_length": 429,
      "index": 64,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rfsm.Host.T-Guest-Typing",
      "library": "rfsm",
      "description": "This module defines operations for managing a typing environment and performing type checking in a guest language. It supports creating and extending typing environments with variables and parameters, looking up variable types, and unifying types during type checking. It works with identifiers, type expressions, and expressions in the guest language's syntax, producing typed representations used for static analysis and type inference. Concrete use cases include type-checking expressions and declarations, managing scoped variable bindings, and enforcing type consistency during program analysis.",
      "description_length": 600,
      "index": 65,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Host.T-Static-Syntax-Guest-Types",
      "library": "rfsm",
      "description": "This module defines and manipulates guest language types, including function types, event types, and boolean types. It provides constructors for building function types from argument and return types, inspectors to check for specific built-in types, and a formatter to print type representations. Concrete use cases include type checking and type representation in a host language embedding a guest language with first-class functions and events.",
      "description_length": 446,
      "index": 66,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "Rfsm.Guest.VHDL-Syntax",
      "library": "rfsm",
      "description": "This module provides operations for constructing, inspecting, and printing VHDL-like syntax elements, including type expressions, declarations, expressions, and l-values. It includes utilities for checking type properties (e.g., boolean detection), generating scoped identifiers, extracting variables, and performing substitutions using environments and parameter mappings to handle type-dependent transformations. These capabilities support code generation, VCD trace output, and preprocessing of parameterized VHDL constructs.",
      "description_length": 528,
      "index": 67,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Vhdl.VHDL-Static-Value",
      "library": "rfsm",
      "description": "This module defines operations for working with static values in a hardware description context. It provides functions to determine default values for types, convert static values to VCD-compatible types and values, and flatten structured values into scalar components for VCD dumping. The module handles scalar and structured values such as booleans, integers, and records, enabling precise representation and transformation for simulation and analysis tasks.",
      "description_length": 460,
      "index": 68,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rfsm.Syntax.SYNTAX-Guest-Types",
      "library": "rfsm",
      "description": "This module defines and manipulates type representations in a guest language, supporting construction of function types and inspection of type properties such as whether a type is an event or boolean. It works with a concrete `typ` type that represents various language types, including special values like `no_type` for undefined types. Use cases include type checking, function signature generation, and readable type output in language processing tools.",
      "description_length": 456,
      "index": 69,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Guest.TYPING",
      "library": "rfsm",
      "description": "This module implements a type-checking system for a functional language, providing functions to manage typing environments, infer and check expression types, and unify types during compilation. It operates on syntax trees and type expressions defined in the `Syntax` submodule, producing and comparing types represented in the `Types` submodule. Concrete use cases include type-checking variable bindings, expressions, and type declarations during the compilation of a model specification.",
      "description_length": 489,
      "index": 70,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Host.T-Dot",
      "library": "rfsm",
      "description": "This module handles the generation of static output files in a specified directory, using a structured data format. It provides the `output_static` function, which takes a directory path, a name, and a `Static.t` value to produce a list of output lines written to a file. Concrete use cases include exporting configuration data or static assets during a build process.",
      "description_length": 368,
      "index": 71,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Syntax.SYNTAX-Guest",
      "library": "rfsm",
      "description": "This module provides type analysis, syntax construction, and transformation capabilities for an embedded domain-specific language within a finite state machine framework. It operates on hierarchical type expressions, declarations, and l-values with support for scoped identifier resolution and VCD trace generation through specialized naming conventions. Key use cases include type-aware preprocessing of expressions, environment-driven substitution, and generating human-readable representations for formal verification workflows.",
      "description_length": 531,
      "index": 72,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Guest.SYNTAX-Types",
      "library": "rfsm",
      "description": "This module defines and manipulates type values used to represent the types of expressions and functions in a guest language. It includes constructors for creating function types and a special undefined type, along with inspectors to check for specific primitive types like events and booleans. The module also provides a function to print types in either full or abbreviated form, suitable for displaying type information in error messages or debugging output.",
      "description_length": 461,
      "index": 73,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rfsm.Evset.T-Event-Syntax-Types",
      "library": "rfsm",
      "description": "This module defines and manipulates type representations for event-based systems, supporting operations to construct function types and inspect type properties such as whether a type is an event or boolean. It works with a custom `typ` type that encodes the structure of types in a guest language, including base types and function types. Concrete use cases include type checking event handlers, generating type representations for code generation, and validating type constraints in domain-specific language constructs.",
      "description_length": 520,
      "index": 74,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Guest.TYPING-Syntax-Types",
      "library": "rfsm",
      "description": "This module defines and manipulates type values used to represent the type of expressions in a guest language. It provides constructors for creating function types and a special undefined type, inspectors to check for specific primitive types like events and booleans, and a function to print types in a readable format. It is used during type checking or inference to ensure expressions are well-typed and to report type information in a human-readable way.",
      "description_length": 458,
      "index": 75,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rfsm.Evset.T",
      "library": "rfsm",
      "description": "This module manages a set of events associated with a specific date, providing operations to create, combine, and manipulate event sets. It supports concrete operations like adding events, computing unions, and partitioning based on event properties, all tied to a specific point in time. Use cases include tracking and processing event-based data at discrete dates, such as scheduling or logging systems.",
      "description_length": 405,
      "index": 76,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Host.T-Syntax-Guest-Types",
      "library": "rfsm",
      "description": "This module defines and manipulates guest language type representations, supporting function type construction, type inspection, and formatted printing. It works with a polymorphic type `typ` that represents guest language types, including primitive types like events and booleans. Concrete use cases include building function types from argument and return types, checking if a type is an event or boolean, and printing types in a human-readable format, potentially abbreviated.",
      "description_length": 479,
      "index": 77,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Vhdl.VHDL-G-Syntax",
      "library": "rfsm",
      "description": "This module provides operations for constructing, inspecting, and transforming VHDL syntax elements like type expressions, l-values, and expressions, with utilities for type checking (e.g., verifying array or boolean types), variable extraction, and name manipulation. It supports preprocessing tasks such as identifier substitution under environments, type-directed expression rewriting, and scope-aware formatting, enabling applications like static analysis, code generation, and transformation of hardware description logic.",
      "description_length": 527,
      "index": 78,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Vcd.VCD",
      "library": "rfsm",
      "description": "Handles the serialization of signal sequences into Value Change Dump (VCD) format. It writes a `seq` value, representing a series of signal changes, to a file specified by `fname`. This module is used to generate VCD files for waveform visualization in digital circuit simulation.",
      "description_length": 280,
      "index": 79,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Host.T-Guest-Vhdl",
      "library": "rfsm",
      "description": "This module translates OCaml syntax types and expressions into VHDL representations. It provides functions to convert type declarations, expressions, l-values, and values into their corresponding VHDL syntax, supporting the generation of VHDL code from high-level descriptions. Key use cases include printing VHDL expressions from abstract syntax trees and generating VHDL type declarations and implementations for entity interfaces and architectures.",
      "description_length": 451,
      "index": 80,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rfsm.Evseq.EVSEQ-Evset-Event-Syntax",
      "library": "rfsm",
      "description": "This module provides syntax-level operations for analyzing and transforming expressions, l-values, and type expressions, including type checking, variable extraction, and pretty-printing. It supports code generation, trace visualization (e.g., VCD), and type-driven transformations through substitution-based preprocessing and environment-aware syntax manipulation. Key data structures include expressions, l-values, and type expressions, with utilities for variable tracking and l-value restructuring.",
      "description_length": 502,
      "index": 81,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Vhdl.VHDL",
      "library": "rfsm",
      "description": "This module generates VHDL output files from a state machine representation. It takes a directory path and optional prefix to write the files, working with the `Static.t` type that represents the state machine structure. It is used to produce synthesizable VHDL code for hardware description purposes.",
      "description_length": 301,
      "index": 82,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Dynamic.DYNAMIC-EvSeq",
      "library": "rfsm",
      "description": "This module implements event sequence manipulation using lists of event sets, supporting operations like merging sequences, creating periodic or sporadic events, and formatting output. It works with event identifiers and timestamped values to model dynamic event streams. Concrete use cases include simulating timed event triggers, combining event timelines, and generating event sequences for testing or system modeling.",
      "description_length": 421,
      "index": 83,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rfsm.Systemc.SYSTEMC-Static-Syntax",
      "library": "rfsm",
      "description": "This module provides utilities for composing programs, transforming models, substituting variables, normalizing expressions, and pretty-printing syntax for a guest language's static constructs. It operates on data structures representing types, expressions, programs, models, transitions, states, and declarations, primarily supporting tasks like manipulating SystemC-based finite state machine models during development, verification, or code generation workflows.",
      "description_length": 465,
      "index": 84,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Host.T-Guest-Info",
      "library": "rfsm",
      "description": "This module defines basic identity information for a guest language, providing direct access to its name and version as strings. It is used to uniquely identify and version guest languages within the system. Concrete use cases include language selection, compatibility checks, and reporting during execution.",
      "description_length": 308,
      "index": 85,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rfsm.Guest.T-Vhdl",
      "library": "rfsm",
      "description": "This module translates OCaml syntax types and expressions into VHDL representations. It provides functions to convert type declarations, expressions, l-values, and values into their corresponding VHDL code, supporting both interface and implementation generation. Use cases include emitting VHDL entities, architectures, and type definitions from an internal syntax tree.",
      "description_length": 371,
      "index": 86,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Guest.T-Systemc",
      "library": "rfsm",
      "description": "This module provides functions to print SystemC declarations and implementations for various syntax elements, including types, expressions, and values. It operates on data types such as `Syntax.type_expr`, `Syntax.type_decl`, `Syntax.expr`, `Syntax.lval`, and `Value.t`. Concrete use cases include generating SystemC code from an abstract syntax tree for simulation or synthesis purposes.",
      "description_length": 388,
      "index": 87,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Dynamic.DYNAMIC-Static-Value",
      "library": "rfsm",
      "description": "This module defines operations for handling static values with support for VCD (Value Change Dump) output generation. It provides functions to obtain default values for types, map static values to VCD types and their corresponding encoded values, and flatten structured values into scalar components qualified by a base identifier. These capabilities are used to prepare and dump simulation values into VCD format, particularly for hardware or state machine tracing.",
      "description_length": 466,
      "index": 88,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Ext.Option",
      "library": "rfsm",
      "description": "This module provides a function `pp` for formatting and printing optional values. It takes an optional `none` string and a formatter function, then applies the formatter to the value inside `Some` or prints the `none` string if the option is `None`. Useful for custom string representations of options in logging or debugging contexts.",
      "description_length": 335,
      "index": 89,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rfsm.Dynamic.DYNAMIC-Eval",
      "library": "rfsm",
      "description": "This module evaluates expressions and maintains dynamic environments for storing and updating variable bindings. It supports expression evaluation, boolean evaluation, and environment manipulation using syntax and value types defined in its submodules. Concrete use cases include interpreting runtime expressions, checking boolean conditions, and managing variable state during dynamic execution.",
      "description_length": 396,
      "index": 90,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Guest.SYSTEMC-Syntax",
      "library": "rfsm",
      "description": "This module provides operations for type checking, substitution, and preprocessing of expressions and l-values, alongside utilities for scoped name generation and variable extraction. It works with data structures representing type expressions, l-values, and expressions, enriched with substitution mappings and type environments for context-aware manipulations. These capabilities are used for tasks like type-dependent code transformations and resolving scoped identifier replacements during language processing.",
      "description_length": 514,
      "index": 91,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Host.T-Ctask-G-Syntax-Types",
      "library": "rfsm",
      "description": "This module defines and manipulates type representations in a guest language, supporting function type construction, type inspection for events and booleans, and formatted type printing. It works with a concrete type `typ` that represents guest language types, including base types like event and boolean. Use cases include building function types from argument and return types, checking if a type is an event or boolean, and printing types in a human-readable format during debugging or code generation.",
      "description_length": 505,
      "index": 92,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rfsm.Host.T-Guest-Error",
      "library": "rfsm",
      "description": "Handles guest-level exceptions raised during execution of guest-specific functions. The `handle` function takes an exception value and processes it appropriately, ensuring unhandled guest errors are managed without disrupting host-level operations. Useful in embedded systems or language interpreters where guest code runs in isolation.",
      "description_length": 336,
      "index": 93,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Host.T-Guest-Options",
      "library": "rfsm",
      "description": "This module defines a list of command-line options specific to guest language compilation, including their parsing specifications and documentation. It works with string identifiers, Arg.spec values, and descriptive strings to configure compiler behavior. Concrete use cases include extending the compiler's option parser with guest language flags like `-target` or `-optimize-level`.",
      "description_length": 384,
      "index": 94,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Dynamic.DYNAMIC-Static-Syntax-Guest",
      "library": "rfsm",
      "description": "This module provides operations for analyzing and transforming guest language constructs, focusing on type expressions, expressions, and l-values. It offers utilities to inspect type properties, extract variables, substitute identifiers/parameters, and preprocess abstract syntax trees within typed environments. Key use cases include generating VCD signal representations for simulation and performing type-directed code transformations during compilation or analysis.",
      "description_length": 469,
      "index": 95,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rfsm.Dot.DOT-Static-Typing",
      "library": "rfsm",
      "description": "This module implements type checking and environment management for a host language program representation. It provides functions to create and print typing environments, and to type-check programs into a structured representation containing models and instances. The module works with environments and programs composed of models and typed instances, enabling analysis and transformation of structured state machine definitions.",
      "description_length": 429,
      "index": 96,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rfsm.Host.T-Syntax-Guest",
      "library": "rfsm",
      "description": "This module provides utilities for analyzing, transforming, and rendering guest language syntax trees, focusing on type-aware manipulation of expressions, l-values, and type declarations. It operates on annotated data structures like type expressions and imperative l-values, supporting tasks such as variable extraction, type property checks, identifier substitution, and VCD-compatible name generation. Key use cases include compiler intermediate representation processing, simulation trace generation, and type-directed syntax rewriting.",
      "description_length": 540,
      "index": 97,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Typing.TYPING-HostSyntax-Guest-Types",
      "library": "rfsm",
      "description": "This module defines and manipulates type values for a guest language embedded within a host syntax. It provides constructors for creating function types and a special undefined type, along with inspectors to check for specific built-in types such as event and boolean. The module supports pretty-printing of types, with an option to abbreviate output for clarity in debugging or logging scenarios.",
      "description_length": 397,
      "index": 98,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Evset.T-Event-Syntax",
      "library": "rfsm",
      "description": "This module supports constructing, inspecting, and transforming type expressions, expressions, and l-values with operations like type checking (e.g., validating boolean or event types), identifier substitution, variable extraction, and scoped pretty-printing. It operates on syntax trees representing guest-language types and values, enabling code generation, VCD trace formatting, and type-directed preprocessing tasks. Key data structures include `expr`, `lval`, and `type_expr`, which are manipulated through utilities for name mangling, parameter substitution, and structured output generation.",
      "description_length": 598,
      "index": 99,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Guest.VHDL-Syntax-Types",
      "library": "rfsm",
      "description": "This module defines and manipulates type representations in a VHDL-like syntax, supporting operations to construct function types and inspect type properties such as whether a type is an event or boolean. It works with a custom `typ` type that models various VHDL data types. Concrete use cases include building and analyzing function signatures and checking for built-in types during static analysis or code generation tasks.",
      "description_length": 426,
      "index": 100,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Host.T-Systemc",
      "library": "rfsm",
      "description": "Implements a system for generating output files from static data structures, using a directory path and optional prefix. Works with lists of strings and static data types to produce file-based representations. Useful for exporting configuration or state data to disk in a structured format.",
      "description_length": 290,
      "index": 101,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Vhdl.VHDL-Static-Syntax-Guest",
      "library": "rfsm",
      "description": "This module provides static analysis, transformation, and type-checking capabilities for expressions and type declarations in a VHDL-like guest language. It operates on type expressions, l-values, and environments to enable tasks like alias type construction, identifier substitution, type-directed expression rewriting, and scoped name generation, with specific applications in VCD trace processing and syntax-driven code manipulation.",
      "description_length": 436,
      "index": 102,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Ext.File",
      "library": "rfsm",
      "description": "This module provides functions for file manipulation, including directory validation, file opening and closing with formatting support, and content copying with string substitution. It operates on standard channel types and string pairs for substitutions. Useful for generating output files from templates or transforming text during file operations.",
      "description_length": 350,
      "index": 103,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rfsm.Event.T",
      "library": "rfsm",
      "description": "This module defines a type `t` representing events in a state machine, including pure events, assignments, and state transitions. It provides operations to check if an event is a pure event, compare events, and pretty-print them. The module works with identifiers, syntax expressions, and values to model state machine behavior.",
      "description_length": 328,
      "index": 104,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rfsm.Guest.TYPING-Syntax",
      "library": "rfsm",
      "description": "This module supports manipulation and analysis of abstract syntax trees through type checking, substitution, and preprocessing operations, working with expressions, l-values, and type constructs. It provides utilities for scoped name handling, variable extraction, and environment-dependent transformations, enabling use cases like hardware simulation, VCD trace generation, and type-directed rewriting of embedded language terms. Key operations include type inspection, AST construction, and context-aware pretty-printing tailored for domain-specific language processing.",
      "description_length": 572,
      "index": 105,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rfsm.Cmodel.CMODEL",
      "library": "rfsm",
      "description": "This module defines and manipulates finite state machine models with typed states, inputs, outputs, and transitions. It supports parsing and pretty-printing of state machine definitions, validation of type expressions, and construction of state transition cases. Concrete use cases include modeling hardware state machines, protocol implementations, and typed signal processing components.",
      "description_length": 389,
      "index": 106,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rfsm.Guest.OPTIONS",
      "library": "rfsm",
      "description": "This module defines a list of command-line options specific to the guest language compiler, including their parsing specifications and documentation strings. It works with standard OCaml data types like strings, Arg specifications, and lists. Concrete use cases include adding options to enable guest-specific features, such as optimization levels or output formats, during compilation.",
      "description_length": 386,
      "index": 107,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Guest.T-Syntax",
      "library": "rfsm",
      "description": "This module provides utilities for type analysis, identifier substitution, variable extraction, name scoping, and syntax formatting across expressions, l-values, and type expressions. It supports VCD trace generation through l-value normalization and environment-driven expression preprocessing, leveraging expected types for context-aware transformations.",
      "description_length": 356,
      "index": 108,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Dot.DOT-Static-Syntax-Guest-Types",
      "library": "rfsm",
      "description": "This module defines and manipulates guest language types, including function types, event types, and boolean types. It provides constructors for building function types from argument and return types, inspectors to check for specific type kinds, and a formatter for readable type output. Concrete use cases include type checking and type representation in a guest language interpreter or compiler.",
      "description_length": 397,
      "index": 109,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Dynamic.DYNAMIC-Eval-Syntax",
      "library": "rfsm",
      "description": "This module provides operations to construct, analyze, and manipulate type expressions, expressions, and l-values in a guest language syntax, with utilities for type checking (e.g., verifying boolean or array types), variable extraction, and identifier substitution under dynamic evaluation contexts. It supports preprocessing expressions and l-values using type environments, includes specialized name manipulation for VCD trace representation, and enables scenarios like runtime type inference, symbolic evaluation, and trace-driven analysis.",
      "description_length": 544,
      "index": 110,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Host.T-Static",
      "library": "rfsm",
      "description": "This module defines data structures for representing finite state machines (FSMs) and their execution context, including typed variables, inputs, outputs, and shared signals. It provides functions to build and pretty-print FSMs and their configurations, along with global values, functions, and user-defined types. Concrete use cases include static analysis, code generation, and simulation of FSM-based systems.",
      "description_length": 412,
      "index": 111,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Ctask.CTASK-Static-Typing",
      "library": "rfsm",
      "description": "This module implements static typing for a host language program, analyzing syntax trees to infer types and produce a typed representation. It processes programs into a structured format with typed models and instances, using an environment to track type information during inference. It supports concrete tasks like type checking, model instantiation, and pretty printing of typed programs and environments for debugging or code generation.",
      "description_length": 441,
      "index": 112,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rfsm.Evseq.EVSEQ-Evset-Event-Syntax-Types",
      "library": "rfsm",
      "description": "This module defines and manipulates type values for event-based computations, supporting construction of function types and inspection of type properties such as whether a type is an event or boolean. It works with a concrete `typ` type representing guest language types, including base types and function types. Use cases include type checking event expressions and generating readable type representations during compilation or debugging.",
      "description_length": 440,
      "index": 113,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Host.T-Guest-Syntax",
      "library": "rfsm",
      "description": "This module provides substitution, preprocessing, and type analysis operations for guest language syntax, focusing on expressions, l-values, type declarations, and VCD trace representations. It enables scoped variable handling, type property checks, and environment-guided transformations, with use cases in syntax manipulation, trace integration, and type-directed code preprocessing.",
      "description_length": 385,
      "index": 114,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Host.T-Dynamic-EvSeq-Evset",
      "library": "rfsm",
      "description": "This module implements a data structure for managing sets of events associated with a specific date. It supports operations to create, modify, and query event sets, including adding events, computing unions, and partitioning based on event properties. Use cases include tracking time-stamped events in reactive systems and processing sequences of discrete events in simulation or logging contexts.",
      "description_length": 397,
      "index": 115,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Vhdl.VHDL-G",
      "library": "rfsm",
      "description": "This module translates a subset of a functional language's type and expression syntax into VHDL representations. It provides functions to convert types, expressions, and values into their corresponding VHDL syntax, along with utilities to print type declarations and associated functions in both VHDL interface and implementation contexts. It directly supports code generation for hardware description by mapping high-level constructs to VHDL equivalents.",
      "description_length": 455,
      "index": 116,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Guest.T-Error",
      "library": "rfsm",
      "description": "This module defines an exception handling mechanism for guest-level errors. It provides a single function `handle` that takes an exception and processes it, typically logging or reporting the error. It works directly with OCaml's exception type `exn` and is used in contexts where unhandled guest exceptions need to be caught and managed at the host level.",
      "description_length": 356,
      "index": 117,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "Rfsm.Host.T-Systemc-G",
      "library": "rfsm",
      "description": "This module provides functions to pretty-print SystemC declarations and implementations for types, expressions, and values. It operates on data types such as `type_expr`, `type_decl`, `expr`, `lval`, and `value`, which are defined in the `Syntax` and `Types` components. Concrete use cases include generating SystemC code for type definitions in header and source files, formatting expressions and l-values for integration into generated code, and printing typed symbols and values for debugging or output purposes.",
      "description_length": 515,
      "index": 118,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Ctask.CTASK-G-Syntax",
      "library": "rfsm",
      "description": "This module provides utilities for manipulating and analyzing annotated syntax trees in a guest language, focusing on type expressions, l-values, and expressions. It supports operations like type checking (e.g., verifying boolean or array types), variable extraction, name normalization, and VCD trace generation, alongside substitution and environment-driven preprocessing of expressions using substitution maps. These tools are particularly useful for tasks such as static analysis, code transformation, and simulation trace generation in domain-specific language implementations.",
      "description_length": 582,
      "index": 119,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rfsm.Host.T-Typing",
      "library": "rfsm",
      "description": "This module implements type checking for programs written in the HostSyntax language. It provides functions to create a typing environment, type a program within that environment, and pretty-print both environments and typed programs. The primary data structures are the typing environment and the typed_program record, which holds typed models and instances.",
      "description_length": 359,
      "index": 120,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Event.Make",
      "library": "rfsm",
      "description": "This module defines event types and operations for modeling state transitions and value updates in a finite state machine. It supports data types like events (`Ev`), assignments (`Upd`), and state moves (`StateMove`), working with identifiers, syntax elements, and values from the `GS` and `GV` modules. Concrete use cases include tracking state changes, handling variable assignments, and logging pure events during state machine execution.",
      "description_length": 441,
      "index": 121,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Host.T-Vhdl-G-Syntax",
      "library": "rfsm",
      "description": "This module enables analysis and transformation of VHDL syntax elements including type expressions, declarations, and l-values. Core operations involve type checking (e.g., `is_bool_type`), syntax tree construction (e.g., `mk_alias_type_decl`), variable extraction (`vars_of_expr`), identifier substitution, and type-aware preprocessing such as boolean literal replacement. These capabilities support use cases like type-driven expression optimization and normalization during VHDL code manipulation.",
      "description_length": 500,
      "index": 122,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rfsm.Evset.T-Event-Value",
      "library": "rfsm",
      "description": "This module defines operations for handling event values with support for VCD (Value Change Dump) output generation. It provides functions to retrieve VCD type and value encodings, flatten structured values into scalar components qualified by a base identifier, and print values using a formatter. The module works with event values that may represent scalar or structured data, such as records, and is used to produce signal hierarchies in VCD files for simulation tracing.",
      "description_length": 474,
      "index": 123,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Evseq.EVSEQ-Evset-Event",
      "library": "rfsm",
      "description": "This module defines a type `t` representing events in a state machine, including pure events, variable assignments, and state transitions. It provides operations to check if an event is a pure event, compare events, and pretty-print them. Concrete use cases include modeling transitions in reactive systems, handling event-based updates, and tracking state changes in formal verification tasks.",
      "description_length": 394,
      "index": 124,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Event.T-Syntax",
      "library": "rfsm",
      "description": "This module provides utilities for type inspection, variable extraction, and syntax tree manipulation in a guest language, focusing on operations like type checking (e.g., `is_bool_type`), identifier substitution, and environment-driven preprocessing (`ppr_expr`). It works with expressions, l-values, and type expressions parameterized over syntax and typing contexts, supporting tasks like VCD trace generation (`lval_vcd_repr`) and name manipulation. Use cases include formal verification workflows and compiler design, where type-directed transformations and context-sensitive preprocessing are critical for analyzing or rewriting guest-language code.",
      "description_length": 655,
      "index": 125,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Evseq.EVSEQ",
      "library": "rfsm",
      "description": "This module implements operations for constructing and combining event sequences, represented as lists of event sets. It supports creating periodic, sporadic, and value-change events tied to identifiers, along with merging sequences using set union. Typical use cases include modeling timed events in reactive systems, such as scheduling signals or tracking state changes over time.",
      "description_length": 382,
      "index": 126,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rfsm.Ctask.CTASK-G-Syntax-Types",
      "library": "rfsm",
      "description": "This module defines and manipulates type representations in a guest language, supporting operations to construct function types, inspect type properties like event or boolean types, and print types in a readable format. It works with a concrete `typ` type that represents the structure and kind of types in the guest language's syntax. Use cases include type checking, type inference, and generating human-readable type output during compilation or debugging.",
      "description_length": 459,
      "index": 127,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Cmodel.Make",
      "library": "rfsm",
      "description": "This module defines a concrete state machine model with typed states, parameters, inputs, outputs, and variables, using syntax and types from the `Static` parameter. It supports parsing and constructing state machines from existing FSM models or instances, producing structured representations with typed expressions and transitions. Typical use cases include model inspection, transformation, and code generation for state machines with strict type definitions.",
      "description_length": 462,
      "index": 128,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Host.T-Typing-HostSyntax-Guest",
      "library": "rfsm",
      "description": "This module provides utilities for constructing, inspecting, and transforming guest language constructs including type expressions, declarations, and expressions. It supports identifier substitution with mappings, type property checks (e.g., `is_bool_type`), variable extraction from expressions/l-values, preprocessing in typing environments, and VCD trace-specific name manipulation via functions like `lval_vcd_repr`. These capabilities enable tasks such as static analysis, program transformation, and simulation trace generation for formal verification or debugging workflows.",
      "description_length": 581,
      "index": 129,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Cmodel.CMODEL-Static-Syntax-Guest-Types",
      "library": "rfsm",
      "description": "This module defines and manipulates guest language types, including function types, event types, and boolean types. It provides constructors for building function types from argument and return types, inspectors to check for specific built-in types, and a pretty-printing function for readable type representations. Concrete use cases include type checking and type representation in a guest language interpreter or compiler.",
      "description_length": 425,
      "index": 130,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Vhdl.VHDL-G-Syntax-Types",
      "library": "rfsm",
      "description": "This module defines and manipulates type representations in a VHDL-like syntax, including support for function types and primitive type checks. It provides operations to construct function types from argument and return types, inspect whether a type is an event or boolean, and print types in a readable format. Concrete use cases include type checking and code generation in VHDL frontends or analysis tools.",
      "description_length": 409,
      "index": 131,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rfsm.Guest.EVAL",
      "library": "rfsm",
      "description": "This module evaluates expressions and boolean conditions in a dynamic environment, binding symbolic variables to values. It supports environment manipulation through creation, updates, and pretty-printing, and evaluates expressions against bound variables. Concrete use cases include interpreting configuration logic and validating constraints in runtime environments.",
      "description_length": 368,
      "index": 132,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Host.T-Vhdl",
      "library": "rfsm",
      "description": "Implements VHDL code generation for finite state machines, providing an `output` function that writes VHDL files to a specified directory using an optional prefix. Operates on `Static.t` structures representing FSM configurations. Used to produce synthesizable VHDL code from internal FSM representations.",
      "description_length": 305,
      "index": 133,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Event.T-Value",
      "library": "rfsm",
      "description": "This module defines operations for handling typed values, including creating default values for specific types. It supports conversion to VCD format by determining VCD types and values, and decomposing structured values into scalar components for VCD dumping. The module also provides functionality to print values using OCaml's formatting library.",
      "description_length": 348,
      "index": 134,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Ctask.CTASK-Static-Syntax",
      "library": "rfsm",
      "description": "This module supports operations for manipulating and transforming a guest language's static syntax, focusing on program composition, model substitution, and normalization. It works with structured representations of type declarations, expressions, transitions, states, and models, using normalized forms for consistency. Specific use cases include debugging via human-readable output generation and program analysis tasks requiring structured syntax transformations.",
      "description_length": 466,
      "index": 135,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Ext.Base",
      "library": "rfsm",
      "description": "Implements mathematical exponentiation with `pow2`, logical negation of predicates with `neg`, tuple element swapping with `swap`, and deep value duplication with `clone`. Operates on integers, boolean functions, pairs, and arbitrary values respectively. Useful for bit manipulation, predicate inversion, data structure reordering, and state duplication in functional contexts.",
      "description_length": 377,
      "index": 136,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Guest.T-Options",
      "library": "rfsm",
      "description": "This module defines a list of command-line options specific to the guest compiler, including their parsing specifications and descriptions. It works with string identifiers, Arg.spec values, and documentation strings. These options are used during compiler initialization to configure guest-specific behavior such as code generation or runtime settings.",
      "description_length": 353,
      "index": 137,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Dot.DOT-Static-Value",
      "library": "rfsm",
      "description": "This module defines operations for handling static values with support for VCD (Value Change Dump) type conversion, value encoding, and structured value flattening. It works with static values and types, producing VCD-compatible types and values for simulation tracing. It is used to generate VCD output for structured data like records by decomposing them into scalar components with qualified identifiers.",
      "description_length": 407,
      "index": 138,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Host.T-Ctask-G-Syntax",
      "library": "rfsm",
      "description": "This module provides utilities for analyzing and transforming type expressions, l-values, and expressions in a guest language syntax, with operations to inspect type properties (e.g., array or boolean checks), extract variables, and manipulate l-value components. It supports substitution of identifiers and parameters, preprocessing expressions in an environment, and generating VCD-compatible representations of l-values. These capabilities are used for tasks like type-directed code transformations, trace visualization, and symbolic manipulation of program elements.",
      "description_length": 570,
      "index": 139,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Host.T-Dynamic-Eval-Value",
      "library": "rfsm",
      "description": "This module defines operations for handling dynamic values with support for VCD interface generation and pretty-printing. It provides functions to retrieve VCD type and value encodings, flatten structured values into scalar components for VCD dumping, and print values using standard formatters. It works with dynamic values and types, producing VCD-specific types and values, and is used in scenarios such as generating VCD output for simulation data.",
      "description_length": 452,
      "index": 140,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rfsm.Guest.SYSTEMC",
      "library": "rfsm",
      "description": "This module provides functions to translate typed symbols, expressions, and type declarations into SystemC code, handling both header and implementation files. It operates on data types like `Syntax.type_expr`, `Syntax.type_decl`, `Syntax.expr`, and `value`, formatting them into SystemC syntax. Concrete use cases include generating SystemC declarations from intermediate representations and emitting SystemC expressions for signal assignments or module instantiations.",
      "description_length": 470,
      "index": 141,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Guest.T-Typing",
      "library": "rfsm",
      "description": "This module implements a type-checking environment and inference system for a functional language. It supports operations to create and extend typing environments, look up variable types, and perform type-checking on expressions, l-values, and type declarations. The module works with identifiers, type expressions, and expressions, producing and consuming typing environments while enforcing scoping and unification rules during type inference. Concrete use cases include type-checking user-defined functions, verifying model parameters, and ensuring type consistency in pattern matching and variable bindings.",
      "description_length": 611,
      "index": 142,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rfsm.Typing.TYPING-HostSyntax",
      "library": "rfsm",
      "description": "This module provides operations to construct, combine, and normalize program components such as type declarations, function declarations, and models, emphasizing model transformation and identifier substitution. It includes a Guest submodule with specialized pretty-printing functions (`pp_*`) to format abstract syntax tree nodes\u2014like transitions, states, and programs\u2014into structured output, supporting tasks such as debugging, code generation, and model normalization. The focus on syntactic manipulation and structured representation makes it suitable for program analysis and transformation workflows.",
      "description_length": 606,
      "index": 143,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rfsm.Host.T-Guest-Static",
      "library": "rfsm",
      "description": "This module implements static evaluation of guest language expressions, providing `eval` to compute constant values and `eval_fn` to represent functions as values. It operates on expression and value types from the guest language, handling cases where evaluation is not possible by raising exceptions. It is used to perform compile-time or static analysis of guest code fragments that can be resolved without runtime context.",
      "description_length": 425,
      "index": 144,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Static.T-Typing",
      "library": "rfsm",
      "description": "This module implements type checking for a host syntax program, producing a typed representation that includes models and instance bindings. It provides functions to create a typing environment, type a program, and pretty-print the resulting environment and typed program. Use this when analyzing or transforming programs in a type-safe manner, such as during compilation or static analysis.",
      "description_length": 391,
      "index": 145,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Systemc.SYSTEMC-G",
      "library": "rfsm",
      "description": "This module provides functions to print SystemC declarations and implementations for types, expressions, and values. It works with type expressions, type declarations, expressions, l-values, and values from the G.Syntax and G modules. Use it to generate SystemC code from an abstract syntax tree, such as converting type definitions to header files or expressions to C++ code.",
      "description_length": 376,
      "index": 146,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Host.T-Vhdl-G",
      "library": "rfsm",
      "description": "This module translates VHDL abstract syntax and types into concrete VHDL code, handling expressions, l-values, type declarations, and values. It provides functions to convert and print VHDL types and expressions, determine shared variable compatibility, and generate VHDL interface and implementation code for type declarations. It operates on VHDL syntax trees and values, targeting direct VHDL code generation for specific type and expression constructs.",
      "description_length": 456,
      "index": 147,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rfsm.Dot.DOT-Static-Syntax-Guest",
      "library": "rfsm",
      "description": "This module provides operations for static analysis and manipulation of guest language syntax, focusing on type inspection, expression transformation, and preprocessing. It operates on data structures including type expressions, declarations, expressions, and l-values, alongside substitution mappings and environment contexts. Key use cases include variable extraction for analysis, parameter substitution in code generation, type-dependent transformations, and generating VCD trace representations for simulation.",
      "description_length": 515,
      "index": 148,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Host.T-Static-Value",
      "library": "rfsm",
      "description": "This module defines operations for handling static values, including generating default values for given types. It supports conversion to VCD-compatible types and values, enabling simulation data export. The `flatten` function decomposes structured values into scalar components for VCD dumping, while `pp` provides formatted printing.",
      "description_length": 335,
      "index": 149,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Static.T-Syntax",
      "library": "rfsm",
      "description": "This module supports construction, transformation, and pretty-printing of abstract syntax trees representing guest language programs, models, and expressions. It provides operations for substitution, normalization, and structured formatting of syntactic elements like states, transitions, type declarations, and actions through AST manipulation. These capabilities are primarily used for debugging, logging, and facilitating model analysis in finite state machine workflows.",
      "description_length": 474,
      "index": 150,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Vhdl.VHDL-G-Static",
      "library": "rfsm",
      "description": "This module provides static evaluation of expressions and function values for guest languages that support them. It operates on expression (`expr`) and value (`value`) data types, enabling evaluation of constant expressions and function definitions at compile time. Concrete use cases include resolving constant expressions in VHDL code generation and evaluating static function calls with known arguments.",
      "description_length": 406,
      "index": 151,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Host.T-Vhdl-G-Static",
      "library": "rfsm",
      "description": "This module provides static evaluation of expressions and function application for a guest language embedded in VHDL. It operates on expression and value types, supporting concrete use cases like constant folding and compile-time function execution. The `eval` function computes values from expressions, while `eval_fn` handles function creation with static arguments.",
      "description_length": 368,
      "index": 152,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Host.T-Vhdl-G-Syntax-Types",
      "library": "rfsm",
      "description": "This module defines and manipulates type representations in a VHDL-like syntax, supporting operations to construct function types and inspect type properties such as whether a type is an event or boolean. It works with the `typ` data type, which represents various types in the syntax, including base types, function types, and special undefined types. Concrete use cases include building function type signatures and checking for specific type semantics during type analysis or code generation.",
      "description_length": 495,
      "index": 153,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rfsm.Host.T-Guest-Systemc",
      "library": "rfsm",
      "description": "This module implements printers for converting typed symbols, expressions, and type declarations into their SystemC equivalents. It operates on syntax trees and values from the `Syntax` and `Guest.Value` modules, generating formatted SystemC code for headers and implementations. Use this module to emit SystemC declarations and definitions from high-level typed constructs during code generation.",
      "description_length": 397,
      "index": 154,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Guest.CTASK-Syntax-Types",
      "library": "rfsm",
      "description": "This module defines and manipulates type values used in a guest language's type system. It supports constructing function types from argument and return types, checking if a type is an event or boolean type, and printing types in a readable format. Concrete use cases include type checking function declarations, validating event-based expressions, and generating type representations for error messages or debugging output.",
      "description_length": 424,
      "index": 155,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rfsm.Host.T",
      "library": "rfsm",
      "description": "This module defines the core operations for processing and executing finite state machine programs. It includes functions for typing, elaboration, and simulation, working with data structures like environments, typed programs, and static representations. Concrete use cases include compiling and simulating state machine models, generating VCD traces, and printing program and type environment information.",
      "description_length": 406,
      "index": 156,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Host.T-Guest-Value",
      "library": "rfsm",
      "description": "This module defines operations for converting guest values to VCD-compatible types and values, decomposing structured values into scalar components for VCD dumping, and printing guest values. It works with guest values of type `Guest.Value.t` and associated types like `Guest.Types.typ` and VCD types from `Rfsm.Vcd_types`. Concrete use cases include generating VCD output for simulation traces and debugging guest state by flattening records and printing values in a structured format.",
      "description_length": 486,
      "index": 157,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rfsm.Vhdl.VHDL-Static-Typing",
      "library": "rfsm",
      "description": "This module implements static typing for VHDL programs, providing functions to create and manipulate typing environments and to type-check programs into structured representations. It processes VHDL syntax trees, inferring types and resolving identifiers, and produces typed programs that include models and instantiated components. The module is used to ensure correctness of VHDL designs before simulation or synthesis by validating type consistency and structural constraints.",
      "description_length": 479,
      "index": 158,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Host.T-Dynamic-EvSeq",
      "library": "rfsm",
      "description": "This module represents sequences of timed events with associated values, supporting operations to construct, merge, and print event sequences. It works with lists of event sets and provides functions to create periodic, sporadic, or custom event sequences tied to identifiers. Concrete use cases include modeling timed signal changes in simulations or scheduling events at specific intervals or timestamps.",
      "description_length": 406,
      "index": 159,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Systemc.SYSTEMC-G-Static",
      "library": "rfsm",
      "description": "This module provides static evaluation of expressions and function values in a guest language. It operates on expression (`expr`) and value (`value`) types, supporting concrete use cases like compile-time constant folding and function evaluation. The `eval` function enables direct static evaluation of expressions, while `eval_fn` constructs function values from argument lists and expression bodies.",
      "description_length": 401,
      "index": 160,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rfsm.Host.T-Vcd",
      "library": "rfsm",
      "description": "Handles the serialization of value change dump (VCD) data to files. Works with VCD sequences, which represent streams of timestamped signal changes. Used to write VCD output to a specified file path, enabling waveform visualization in tools like GTKWave.",
      "description_length": 254,
      "index": 161,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Dynamic.DYNAMIC-Syntax-Guest",
      "library": "rfsm",
      "description": "This module supports syntax manipulation and type analysis for guest language constructs, focusing on substitution, preprocessing, and property checking of type expressions, l-values, and expressions. It operates within type environments to enable transformations like identifier replacement and type-guided rewriting, while tracking variable scoping for simulation trace generation. Applications include compiler intermediate representation processing and formal verification tasks requiring precise type-aware syntax manipulation.",
      "description_length": 532,
      "index": 162,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Host.T-Dynamic-Eval-Syntax-Types",
      "library": "rfsm",
      "description": "This module defines and manipulates type representations in a dynamic evaluation context. It supports constructing function types from argument and return types, inspecting types to determine if they are event or boolean types, and printing types in either full or abbreviated form. It is used in scenarios where type information must be dynamically built, analyzed, and displayed during evaluation of expressions in a guest language.",
      "description_length": 434,
      "index": 163,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Dynamic.DYNAMIC-Static-Syntax-Guest-Types",
      "library": "rfsm",
      "description": "This module defines and manipulates guest language types, including function types, event types, and boolean types. It provides constructors for building function types from argument and return types, inspectors to check for specific built-in types, and a formatter to produce readable type representations. Concrete use cases include type checking and type inference during static analysis of guest language expressions.",
      "description_length": 421,
      "index": 164,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Ext.List",
      "library": "rfsm",
      "description": "This module provides operations for list manipulation, including Cartesian products, association list updates, and element scattering with grouping. It supports data types like standard lists, association lists, and lists of lists, enabling structured transformations and aggregations. Use cases include generating combinations, updating key-value mappings, formatting structured data, and analyzing grouped elements.",
      "description_length": 417,
      "index": 165,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Host.T-Dynamic",
      "library": "rfsm",
      "description": "This module evaluates reactive programs by processing event sequences through dynamic execution. It uses the `Syntax.program` and `Static.t` types to define program structure and static configuration, while producing `Dynamic.EvSeq.t` as output. Concrete use cases include simulating event-driven behavior in reactive systems and generating execution traces for analysis or testing.",
      "description_length": 382,
      "index": 166,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rfsm.Guest.VALUE",
      "library": "rfsm",
      "description": "This module defines operations for handling typed values, including creating default values for specific types. It supports conversion to VCD format by determining VCD types and values, and provides structured value flattening for VCD signal dumping. The module works with scalar and structured values, and is used to generate VCD output for simulation signals.",
      "description_length": 361,
      "index": 167,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Guest.CTASK-Syntax",
      "library": "rfsm",
      "description": "This module supports operations for type analysis, expression manipulation, and syntax transformation in a guest language. It works with type expressions, declarations, expressions, and l-values, providing utilities for type checking (e.g., verifying boolean or array types), variable extraction, identifier renaming, and pretty-printing. Specific use cases include static analysis of type dependencies, preprocessing expressions for compilation, and rewriting boolean logic during type-driven transformations.",
      "description_length": 510,
      "index": 168,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Host.T-Dynamic-EvSeq-Evset-Event-Value",
      "library": "rfsm",
      "description": "This module defines operations for handling dynamic event values with support for VCD output generation and pretty-printing. It provides functions to retrieve default values for types, convert values to VCD types and encodings, and flatten structured values into scalar components qualified by a base identifier. It works with structured and scalar data types, particularly those used in event sequences and VCD trace dumping.",
      "description_length": 426,
      "index": 169,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Guest.T-Value",
      "library": "rfsm",
      "description": "This module defines a value type `t` and operations for converting values to VCD representations, including type mapping, value encoding, and structure flattening. It supports VCD signal dumping by decomposing structured values into scalar components qualified with a base identifier. Use cases include generating VCD output for simulation traces and printing values for debugging or logging.",
      "description_length": 392,
      "index": 170,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Dynamic.DYNAMIC-EvSeq-Evset-Event-Syntax",
      "library": "rfsm",
      "description": "This module enables inspection and construction of type expressions, expressions, and l-values in a guest language syntax, with operations for type checking (e.g., `is_bool_type`), variable extraction (e.g., `vars_of_expr`), and l-value manipulation tailored for VCD trace generation (e.g., `lval_vcd_repr`). It also supports substitution and preprocessing of these constructs under substitution environments and during type checking, enabling context-sensitive transformations like boolean literal rewriting and scoped identifier resolution, which are critical for tasks such as state machine modeling and type-directed expression processing.",
      "description_length": 643,
      "index": 171,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Host.T-Guest",
      "library": "rfsm",
      "description": "This module implements a runtime finite state machine (FSM) host environment for guest languages. It provides operations for parsing, type-checking, evaluating, and executing FSMs, along with error handling and configuration options. It works with state machine definitions expressed in a custom syntax, typed values, and execution contexts for tasks and systems. Concrete use cases include embedding domain-specific state machines, validating transitions and states, and generating runtime representations for simulation or code generation.",
      "description_length": 541,
      "index": 172,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Guest.T-Types",
      "library": "rfsm",
      "description": "This module defines and manipulates type values used to represent guest language types. It provides constructors for creating function types and a special undefined type, along with inspectors to check for specific primitive types such as event and boolean. The module also includes a function for pretty-printing types, supporting both full and abbreviated forms.",
      "description_length": 364,
      "index": 173,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rfsm.Systemc.SYSTEMC-G-Syntax",
      "library": "rfsm",
      "description": "This module enables manipulation of SystemC-like syntax constructs through operations for building and analyzing type expressions, declarations, expressions, and l-values. It supports scoped naming resolution, VCD trace generation for hierarchical variables, and type property checks (e.g., boolean validation), while providing substitution mechanisms using environments for identifier and parameter replacement. Key applications include constructing type aliases, extracting variables from expressions, and formatting code for simulation traces with type-aware preprocessing.",
      "description_length": 576,
      "index": 174,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rfsm.Ctask.Make",
      "library": "rfsm",
      "description": "This module orchestrates task execution by integrating static configuration with guest-defined logic, generating structured output paths and applying dynamic operations to them. It combines core functionality for path generation and task orchestration with a child module that translates high-level constructs into C code, supporting type-aware transformations, pretty-printing, and environment-sensitive preprocessing. Main data types include task configurations, output paths, and abstract syntax trees for C code, with operations to map, validate, and emit compilable code. Examples include generating VCD trace code from typed expressions, validating function signatures, and producing debug-ready C output from intermediate representations.",
      "description_length": 745,
      "index": 175,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Evset.T-Event",
      "library": "rfsm",
      "description": "This module defines a type `t` representing events in a state machine, including pure events, variable assignments, and state transitions. It provides operations to check if an event is a pure event, compare events, and pretty-print them. Concrete use cases include modeling transitions in reactive systems, tracking variable updates, and logging state changes.",
      "description_length": 361,
      "index": 176,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Systemc.SYSTEMC-G-Syntax-Types",
      "library": "rfsm",
      "description": "This module defines operations for constructing and inspecting types in a guest language embedded within OCaml. It supports creating function types from argument and return types, checking if a type is an event or boolean type, and printing type representations in a readable format. Concrete use cases include type checking and code generation tasks in domain-specific language implementations.",
      "description_length": 395,
      "index": 177,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Event.T-Syntax-Types",
      "library": "rfsm",
      "description": "This module defines and manipulates type representations in a guest language, supporting operations to construct function types, inspect type properties such as whether a type is an event or boolean, and print types in a readable format. It works with a polymorphic type `typ` that represents various types in the language's syntax tree. Concrete use cases include type checking expressions, generating type signatures, and debugging type inference in a compiler or interpreter.",
      "description_length": 478,
      "index": 178,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Host.T-Dynamic-EvSeq-Evset-Event",
      "library": "rfsm",
      "description": "This module defines a type `t` representing events in a state machine, including pure events, assignments, and state transitions. It provides operations to check if an event is a pure event, compare events, and format them for output. It works with identifiers, lvalues, and values from the `Dynamic.EvSeq.Evset.Event` module, supporting concrete use cases like tracking state changes and variable updates during execution.",
      "description_length": 423,
      "index": 179,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Systemc.Make",
      "library": "rfsm",
      "description": "This module generates output files from static configurations using guest-specific backends, operating on `Static.t` values to produce string lists representing file contents, parameterized by directory and prefix. It drives code generation tasks such as producing SystemC headers and source files from internal type and expression representations. Core data types include structured forms of types, expressions, and values, supporting transformations, identifier substitution, and scoped naming via child modules. Developers can emit SystemC interfaces, compile expressions into constants, and generate type signatures or VCD traces for simulation.",
      "description_length": 649,
      "index": 180,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Cmodel.CMODEL-Static-Syntax",
      "library": "rfsm",
      "description": "This module offers operations to construct and combine programs, substitute model parameters and I/O, normalize models, and pretty-print syntax elements. It works with static syntax structures like types, expressions, transitions, and states defined in `Static.Syntax` and related modules. These tools are used to generate human-readable representations of models and manipulate model components programmatically, such as during debugging or model transformation tasks.",
      "description_length": 469,
      "index": 181,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Dot.DOT-Static-Syntax",
      "library": "rfsm",
      "description": "This module provides utilities for constructing and transforming hierarchical state machine models through operations like program composition, model substitution, and syntax normalization. It works with static syntax elements such as typed expressions, state transitions, and model declarations defined in the `Static.Syntax` hierarchy, including guest-specific extensions. The pretty-printing functions enable visualization of these components for debugging state machine logic or generating documentation from formal models.",
      "description_length": 527,
      "index": 182,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Evseq.EVSEQ-Evset-Event-Value",
      "library": "rfsm",
      "description": "This module defines operations for handling event values, including retrieving default values for specific types. It supports conversion to VCD-compatible types and values, enabling simulation data to be dumped in VCD format. The module also provides functions to flatten structured values into scalar components for hierarchical VCD output, and to print values using standard OCaml formatters.",
      "description_length": 394,
      "index": 183,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rfsm.Static.T-Syntax-Guest-Types",
      "library": "rfsm",
      "description": "This module defines and manipulates guest language types, including function types, event types, and boolean types. It provides constructors for building function types from argument and return types, inspectors to check for specific type kinds, and a formatter for readable type output. Concrete use cases include type checking and type representation in a guest language interpreter or compiler.",
      "description_length": 397,
      "index": 184,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Dot.Make",
      "library": "rfsm",
      "description": "Generates static graph representations in DOT format for visualization. It operates on `Static.t` data structures, which model finite state machines, and writes output files to a specified directory. This module is used to produce graphical depictions of state machines for debugging or documentation purposes.",
      "description_length": 310,
      "index": 185,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Depg.M",
      "library": "rfsm",
      "description": "This module implements associative maps for managing relationships between identifiers and arbitrary data, optimized for graph vertices represented as simple names. It supports associative operations like key-based lookup, filtered transformations, and structural comparisons, alongside sequence-based conversions for incremental map construction and serialization. Typical applications include dependency graph analysis, configuration mapping, and symbolic computation where named entities require dynamic, structured relationships.",
      "description_length": 533,
      "index": 186,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rfsm.Systemc.SYSTEMC-Static",
      "library": "rfsm",
      "description": "This module processes and represents finite state machine (FSM) models with normalized typing and variable environments. It supports analysis and transformation of FSMs through structured contexts that track inputs, outputs, and shared variables with their readers and writers. Concrete use cases include model verification, RTL extraction, and dependency ordering of FSM components.",
      "description_length": 383,
      "index": 187,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Static.Make",
      "library": "rfsm",
      "description": "This module builds and prints a static representation of finite state machines (FSMs) with typed contexts, global variables, functions, and constants. It processes typed and raw syntax trees to analyze and store FSMs, their variables, and dependencies. Use cases include static analysis of FSM behavior, dependency tracking, and generating structured FSM reports.",
      "description_length": 363,
      "index": 188,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Host.T-Systemc-G-Syntax",
      "library": "rfsm",
      "description": "This module provides functions for analyzing and manipulating SystemC syntax elements, including type expressions, expressions, and l-values. It supports type checking (e.g., verifying boolean or array types), variable extraction from expressions and l-values, and name manipulation for generating VCD traces. Additionally, it handles substitution of identifiers and parameters, type-dependent expression rewriting, and scoped l-value printing within environment contexts, facilitating tasks like type-driven transformations and trace generation.",
      "description_length": 546,
      "index": 189,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rfsm.Guest.ERROR",
      "library": "rfsm",
      "description": "This module defines error-handling behavior for guest-level exceptions. It includes a function `handle` that takes an exception value and processes it, typically by logging or reporting the error. It is used to manage unhandled exceptions originating from guest-specific code during execution.",
      "description_length": 293,
      "index": 190,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Depg.G",
      "library": "rfsm",
      "description": "This module manages directed graphs with named vertices and edges, supporting structural queries, transformations, and traversal of predecessors and successors. It provides core operations to add or remove vertices and edges, map or fold over graph elements, and inspect adjacency relationships, with vertices identified by simple labels and edges carrying no additional data. The module includes submodules for handling vertex identity, tracking per-vertex integer states useful in traversal algorithms, and representing directed edges between named nodes. Example uses include modeling dependencies between labeled components, tracking traversal progress with vertex markers, and performing topological analysis on dynamic networks.",
      "description_length": 734,
      "index": 191,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Vhdl.VHDL-Static-Syntax-Guest-Types",
      "library": "rfsm",
      "description": "This module defines and manipulates type representations in a guest language embedded within VHDL. It supports constructing function types, checking for event and boolean types, and printing type information with optional abbreviation. Use cases include type validation during static analysis and generating readable type annotations in VHDL code generation.",
      "description_length": 358,
      "index": 192,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rfsm.Guest.SYSTEMC-Static",
      "library": "rfsm",
      "description": "This module defines types and operations for static evaluation of expressions in a guest language. It provides `eval` to compute values from static expressions and `eval_fn` to handle function evaluation, returning undefined for languages without function support. It works with `expr` and `value` types, enabling compile-time evaluation and simplification of expressions in contexts like constant folding or macro expansion.",
      "description_length": 425,
      "index": 193,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Cmodel.CMODEL-Static",
      "library": "rfsm",
      "description": "This module processes and represents finite state machine models with typed and normalized structures. It handles model construction from typed and syntactic data, tracks inputs, outputs, shared variables, and maintains global constants and functions. It supports model inspection and pretty-printing, and determines if a model conforms to a restricted transition language.",
      "description_length": 373,
      "index": 194,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Typing.TYPING-HostSyntax-Guest",
      "library": "rfsm",
      "description": "This module supports type analysis, substitution, and preprocessing operations on expressions, l-values, and type declarations in a guest language. It works with structured representations of type expressions, expressions, and l-values to enable use cases like type validation (e.g., verifying boolean or array types), variable dependency tracking, VCD trace generation for simulation, and environment-guided code transformations such as macro expansion or type-directed optimization.",
      "description_length": 484,
      "index": 195,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Cmodel.CMODEL-Static-Value",
      "library": "rfsm",
      "description": "This module defines operations for working with static values, including retrieving default values for specific types. It supports conversion to VCD-compatible types and values, enabling simulation data to be dumped in VCD format. The `flatten` function decomposes structured values into scalar components with qualified identifiers, facilitating signal tracing in hardware simulation workflows.",
      "description_length": 395,
      "index": 196,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Systemc.SYSTEMC",
      "library": "rfsm",
      "description": "Handles the generation of output files from a static configuration, using a specified directory and optional prefix. Operates on data structures defined in the `Static` module, which represents system state, and uses the `G` module for underlying graph operations. Used to serialize system state to disk with controlled naming and placement.",
      "description_length": 341,
      "index": 197,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rfsm.Guest.STATIC",
      "library": "rfsm",
      "description": "This module defines a static evaluation framework for expressions in a guest language, supporting two core types: `expr` for expressions and `value` for their evaluated results. It includes `eval_fn` for constructing function values from argument lists and expression bodies, and `eval` for performing static evaluation of expressions, raising an error when evaluation is not possible. Concrete use cases include compile-time constant folding and static analysis of guest language programs.",
      "description_length": 490,
      "index": 198,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Ext.Format",
      "library": "rfsm",
      "description": "This module provides functions for formatting output with precise control over spacing and line breaks. It works with `Stdlib.Format.formatter` and arbitrary values, enabling custom pretty-printing logic. Concrete use cases include generating structured text output such as code, logs, or configuration files with consistent layout.",
      "description_length": 332,
      "index": 199,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Vhdl.VHDL-Static",
      "library": "rfsm",
      "description": "This module processes and represents finite state machine (FSM) models extracted from VHDL code. It provides data structures for tracking FSMs, their associated variables, inputs, outputs, and global constants and functions. Key operations include building a normalized model from typed and raw syntax, pretty-printing for debugging, and checking if an FSM is RTL-level.",
      "description_length": 370,
      "index": 200,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Compiler.Make",
      "library": "rfsm",
      "description": "Builds a compiler structure by combining a language definition with lexer and parser implementations. It orchestrates the main compilation workflow, coordinating tokenization and parsing stages. Useful for implementing domain-specific compilers where distinct language rules, lexical analysis, and syntactic interpretation are defined separately.",
      "description_length": 346,
      "index": 201,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Static.T-Syntax-Guest",
      "library": "rfsm",
      "description": "This module provides utilities for analyzing, transforming, and generating guest language syntax trees, focusing on type-aware manipulations of expressions, l-values, and type declarations annotated with source positions and type metadata. It supports operations like type property checks, variable extraction, identifier substitution, and scope/type-directed rewriting, with applications in VCD signal naming, preprocessing, and context-sensitive pretty-printing.",
      "description_length": 464,
      "index": 202,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Host.T-Ctask",
      "library": "rfsm",
      "description": "This module implements task execution logic for a finite state machine, specifically handling output generation based on a given directory and static configuration. It works with the `Static.t` data type to represent configuration state and produces string lists as output artifacts. A concrete use case is generating output files or commands in a stateful workflow driven by directory-based inputs.",
      "description_length": 399,
      "index": 203,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Host.T-Dynamic-Eval",
      "library": "rfsm",
      "description": "This module evaluates expressions in a dynamic environment, supporting operations to create and update environments, evaluate expressions to values or booleans, and print environments. It works with expressions and values defined in the Syntax and Value submodules, along with environment mappings. Concrete use cases include interpreting configuration scripts, evaluating dynamic conditions in state machines, and managing runtime variable bindings.",
      "description_length": 450,
      "index": 204,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Host.T-Guest-Types",
      "library": "rfsm",
      "description": "This module defines and manipulates type representations in a guest language, supporting operations to construct function types, inspect type properties such as event or boolean types, and print types in a readable format. It works with a concrete `typ` type that represents various kinds of guest language types, including base types and function types. Use cases include type checking, type inference, and generating type representations for debugging or user output in a host system interacting with a guest language.",
      "description_length": 520,
      "index": 205,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Syntax.Make",
      "library": "rfsm",
      "description": "This module provides utilities for constructing and transforming finite state machine (FSM) models through program manipulation, normalization, and substitution of inputs/outputs. It operates on custom data types representing FSM components like states, transitions, actions, and type declarations, enabling structured modifications to models and their parameters. The functionality supports use cases such as generating human-readable representations of FSMs for debugging, optimizing model definitions, and handling type-level transformations in state machine workflows.",
      "description_length": 572,
      "index": 206,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Dynamic.DYNAMIC-Static-Typing",
      "library": "rfsm",
      "description": "This module implements static typing for programs in the HostSyntax language. It provides functions to create a typing environment, type a program, and pretty-print the environment and typed program. The main data structures are the typing environment and the typed_program record, which holds typed models and instances. Use this module to validate and analyze the type correctness of models and instances in a program.",
      "description_length": 420,
      "index": 207,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Depg.Make",
      "library": "rfsm",
      "description": "Implements dependency-aware sorting of nodes within a given context. Uses a provided node module to determine dependencies and order nodes such that dependencies come before dependent nodes. Useful for resolving build orders or execution sequences where nodes represent tasks or components with explicit dependencies.",
      "description_length": 317,
      "index": 208,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Typing.TYPING",
      "library": "rfsm",
      "description": "This module implements type checking for programs in the HostSyntax language. It provides a typing environment (`env`) and a `type_program` function that infers and verifies types for models and instances in a program, producing a `typed_program` result. The typed output includes lists of typed models and typed instance declarations, suitable for further processing like code generation or analysis.",
      "description_length": 401,
      "index": 209,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rfsm.Evseq.Make",
      "library": "rfsm",
      "description": "This module implements operations for constructing and combining event sequences, represented as lists of event sets. It provides functions to merge sequences, create periodic or sporadic events, and generate sequences from value changes. These operations are used to model timed event streams in reactive systems, such as scheduling or simulation tasks.",
      "description_length": 354,
      "index": 210,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Dynamic.DYNAMIC-Eval-Value",
      "library": "rfsm",
      "description": "This module defines operations for handling typed values, including generating default values for specific types. It supports conversion to VCD-compatible types and values, enabling simulation data to be exported in the Value Change Dump format. The `flatten` function decomposes structured values into scalar components for VCD output, using a base identifier to form qualified names.",
      "description_length": 385,
      "index": 211,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Vcd.Make",
      "library": "rfsm",
      "description": "This module writes event sequences to VCD (Value Change Dump) files for waveform visualization. It takes a sequence of events, each representing signal changes over time, and outputs them in the VCD format. A concrete use case is generating simulation traces for hardware verification or debugging temporal behavior in digital circuits.",
      "description_length": 336,
      "index": 212,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rfsm.Dot.DOT",
      "library": "rfsm",
      "description": "Handles conversion of finite state machine (FSM) representations into DOT format files. Works with FSM data structures to generate visualizations of state transitions. Useful for debugging and documentation by producing graph files that can be rendered with tools like Graphviz.",
      "description_length": 278,
      "index": 213,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Host.T-Guest-Ctask",
      "library": "rfsm",
      "description": "This module provides functions to pretty-print C declarations and expressions. It operates on type expressions, type declarations, and expressions from the Syntax module, along with identifiers. Use it to generate C code from abstract syntax structures, such as converting type definitions to C type declarations or expressions to C expressions.",
      "description_length": 345,
      "index": 214,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Dynamic.DYNAMIC-Static-Syntax",
      "library": "rfsm",
      "description": "This module supports the construction, combination, and transformation of guest-language programs and models, along with substitution in model parameters and I/O, normalization, and inspection of state interfaces. It operates on syntax elements like types, expressions, declarations, transitions, and states defined in static syntax modules. Its utilities are used for debugging via structured pretty-printing, dynamic model parameter manipulation, and program analysis workflows.",
      "description_length": 480,
      "index": 215,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Guest.TYPES",
      "library": "rfsm",
      "description": "This module defines a type `typ` representing types in a guest language, along with operations to construct and inspect function types and primitive types like events and booleans. It includes functions to check if a type is an event or boolean type and to print types in a readable format, optionally abbreviated. Use cases include type checking and pretty-printing in an embedded domain-specific language with first-class functions.",
      "description_length": 434,
      "index": 216,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rfsm.Ctask.CTASK-Static-Value",
      "library": "rfsm",
      "description": "This module defines operations for handling static values with support for VCD interface generation and pretty-printing. It provides functions to retrieve VCD types and values, flatten structured values into scalar components for VCD dumping, and print values using standard formatters. It works with static values of type `Static.Value.t` and supports structured types like records for VCD signal extraction.",
      "description_length": 409,
      "index": 217,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Guest.TYPING-Types",
      "library": "rfsm",
      "description": "This module defines a type `typ` representing types in a guest language, along with operations to construct and inspect them. It includes constructors for creating function types and a special undefined type, and inspectors to check for specific built-in types like event and boolean. The module also provides a function to print types in a readable format, optionally abbreviated.",
      "description_length": 381,
      "index": 218,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Dot.DOT-Static",
      "library": "rfsm",
      "description": "This module defines data structures for representing finite state machines (FSMs) with typed variables, inputs, outputs, and shared signals. It provides functions to build and pretty-print FSM models, along with submodules that handle syntax, typing, and value evaluation. It is used to analyze and visualize FSMs in a normalized, type-checked form, particularly for hardware description workflows.",
      "description_length": 398,
      "index": 219,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rfsm.Host.T-Static-Typing",
      "library": "rfsm",
      "description": "This module implements static typing for a host language, providing functions to create and manipulate typing environments and type-checked programs. It processes syntax trees into typed representations, tracking models and instances with their identifiers. Use cases include type-checking host programs before execution and printing typed program structures for debugging.",
      "description_length": 373,
      "index": 220,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Depg.T",
      "library": "rfsm",
      "description": "Implements topological sorting of nodes based on dependencies within a given context. Works with abstract node and context types, where context defines the dependency relationships. Useful for resolving execution order in build systems or task scheduling where nodes represent tasks and dependencies dictate ordering constraints.",
      "description_length": 329,
      "index": 221,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Cmodel.CMODEL-Static-Syntax-Guest",
      "library": "rfsm",
      "description": "This module provides static analysis and transformation capabilities for guest language syntax, focusing on type expressions, expressions, and l-values. It enables operations like type inspection (e.g., `is_bool_type`), substitution (`subst_expr`), variable extraction (`vars_of_expr`), and type-directed preprocessing (`ppr_expr`), all working with structured syntax trees and substitution maps. These tools are designed for formal modeling tasks such as trace generation (e.g., VCD) and scoped type environment manipulation, where precise identifier resolution and syntax rewriting are critical.",
      "description_length": 597,
      "index": 222,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rfsm.Dynamic.DYNAMIC-Syntax-Guest-Types",
      "library": "rfsm",
      "description": "This module defines and manipulates guest language types, including function types, event types, and boolean types. It provides constructors for building function types from argument and result types, inspectors to check for specific type kinds, and a formatter for readable type output. Concrete use cases include type checking and type representation in a guest language interpreter or compiler.",
      "description_length": 397,
      "index": 223,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Guest.SYNTAX",
      "library": "rfsm",
      "description": "This module provides functions for constructing, inspecting, and transforming abstract syntax trees, expressions, and type declarations in a guest language, with utilities for variable extraction, VCD trace generation, and scoped name prefixing. It operates on annotated AST nodes, expressions, l-values, and type expressions, supporting substitution and preprocessing via environments parameterized by identifier mappings, while offering pretty-printing capabilities to resolve and display syntactic forms in context. Specific operations include applying substitutions to expressions and types, preprocessing expressions under expected type constraints, and generating human-readable representations of syntactic elements during analysis or debugging.",
      "description_length": 752,
      "index": 224,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Guest.VHDL",
      "library": "rfsm",
      "description": "This module provides functions to translate a syntax tree into VHDL declarations and expressions. It handles type declarations, expressions, l-values, and values, mapping them to their VHDL equivalents. Use cases include generating VHDL code from a high-level description, such as synthesizing hardware components or emitting testbenches.",
      "description_length": 338,
      "index": 225,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Systemc.SYSTEMC-Static-Syntax-Guest",
      "library": "rfsm",
      "description": "This module provides operations for static syntax analysis and transformation of type expressions, expressions, and l-values, including type checking (e.g., `is_bool_type`), substitution mappings, and identifier manipulation (e.g., `lval_base_name`). It operates on guest language syntax structures like type declarations, expressions, and l-values, leveraging substitution environments and type contexts. Specific applications include type-driven expression rewriting, scoped l-value printing, and generating VCD trace representations for simulation.",
      "description_length": 551,
      "index": 226,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rfsm.Cmodel.CMODEL-Static-Typing",
      "library": "rfsm",
      "description": "This module implements static typing for a modeling language, providing functions to create and manipulate typing environments and type programs. It processes a program into a typed representation, tracking models and their instances, and includes printers for environments and typed programs. Use cases include type-checking model definitions and ensuring correctness of model instantiations during compilation.",
      "description_length": 412,
      "index": 227,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Guest.EVAL-Syntax-Types",
      "library": "rfsm",
      "description": "This module defines and manipulates type values used in a guest language's type system. It supports constructing function types from argument and return types, inspecting whether a type is an event or boolean type, and printing types in a readable format. Use cases include type checking expressions, representing function signatures, and debugging type information during evaluation.",
      "description_length": 384,
      "index": 228,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Guest.SYSTEMC-Syntax-Types",
      "library": "rfsm",
      "description": "This module defines and manipulates type representations in a guest language, supporting operations to construct function types, inspect type properties such as event or boolean types, and print types in a readable format. It works with a custom `typ` type that encodes the structure of data types in the guest language. Concrete use cases include type checking expressions, generating type signatures, and debugging type information during compilation or analysis.",
      "description_length": 465,
      "index": 229,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Host.T-Guest-Eval",
      "library": "rfsm",
      "description": "This module implements a dynamic environment management system with operations to create and update environments using logical variables and values. It provides expression evaluation capabilities for both general values and boolean conditions, ensuring strict type correctness during execution. The module is used to maintain state and evaluate symbolic expressions in program analysis tasks where logical variables are bound to computed values.",
      "description_length": 445,
      "index": 230,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rfsm.Host.T-Dynamic-Eval-Syntax",
      "library": "rfsm",
      "description": "This module provides operations for type inspection, substitution, and preprocessing of abstract syntax trees in a guest language, supporting tasks like formal verification and simulation. It works with type expressions, declarations, expressions, and l-values through utilities for AST traversal, pretty-printing, and VCD-compatible value extraction, alongside dynamic evaluation under type environments. Key use cases include type checking, trace generation for hardware verification, and runtime expression evaluation with parameter substitution.",
      "description_length": 549,
      "index": 231,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Host.T-Systemc-G-Syntax-Types",
      "library": "rfsm",
      "description": "This module defines and manipulates type representations in a SystemC-like syntax, supporting operations to construct function types and inspect primitive types such as event and boolean. It works with a single abstract type `typ`, which represents various language types, including function types built from argument and return types. Concrete use cases include type checking expressions, generating type signatures for functions, and pretty-printing types during debugging or code generation.",
      "description_length": 494,
      "index": 232,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rfsm.Dynamic.DYNAMIC-EvSeq-Evset-Event-Syntax-Types",
      "library": "rfsm",
      "description": "This module defines and manipulates type values for a guest language, supporting construction of function types and inspection of type properties such as whether a type represents an event or a boolean. It works with a concrete `typ` type that represents language-level types, including base types and function types. Use cases include type checking expressions, representing function signatures, and printing types in a human-readable format during debugging or compilation.",
      "description_length": 475,
      "index": 233,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rfsm.Vhdl.Make",
      "library": "rfsm",
      "description": "This module generates VHDL code from a finite state machine description by combining static configuration with guest logic, using the `Static.t` type to model state transitions and produce output files. It integrates type translation, expression evaluation, and syntax construction through its submodules, enabling tasks like mapping OCaml types to VHDL, resolving expressions at compile time, and generating VCD traces. Operations include static analysis of types and variables, environment-based transformations, and pretty-printing for synthesis and simulation. Example uses include converting state machine definitions into hardware descriptions and evaluating constants during code generation.",
      "description_length": 698,
      "index": 234,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rfsm.Guest.VHDL-Static",
      "library": "rfsm",
      "description": "This module provides static evaluation of expressions and function definitions in a guest language. It operates on `expr` and `value` types, representing expressions and their computed values. It is used to evaluate constant expressions at compile time and model function behavior in languages that support it.",
      "description_length": 310,
      "index": 235,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rfsm.Guest.INFO",
      "library": "rfsm",
      "description": "This module defines basic identity information for a guest language, including its name and version. It works with string values to represent metadata about the language environment. Concrete use cases include identifying the language in multi-lingual systems and version checking during integration.",
      "description_length": 300,
      "index": 236,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Typing.Make",
      "library": "rfsm",
      "description": "This module performs type-checking of finite state machine (FSM) components, including actions, transitions, guards, and program-wide elements like global declarations and stimuli, using environment-passing style to track typing contexts. It operates on abstract syntax trees (ASTs) annotated with type information and leverages structured environments (`GuestTyping.env`) to enforce correctness during FSM construction and program verification. The design supports use cases such as validating state-event interactions, ensuring type consistency in hierarchical FSM models, and analyzing annotated ASTs for well-formedness.",
      "description_length": 624,
      "index": 237,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rfsm.Host.T-Ctask-G",
      "library": "rfsm",
      "description": "This module implements printers for C expressions and type declarations, converting abstract syntax trees into their corresponding C code representations. It operates on data types such as `Ctask.G.Syntax.type_expr`, `Ctask.G.Syntax.type_decl`, and `Ctask.G.Syntax.expr`, formatting them for output in C syntax. Concrete use cases include generating C code from internal type and expression structures, such as printing \"int x\" for a typed symbol or \"int a[8]\" for an array declaration.",
      "description_length": 486,
      "index": 238,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rfsm.Ctask.CTASK-Static",
      "library": "rfsm",
      "description": "This module defines data structures for representing finite state machines (FSMs) with typed variables, inputs, outputs, and shared signals. It provides functions to build and pretty-print FSMs and their contexts, supporting analysis and transformation of state machine models. Key use cases include parsing and processing FSM descriptions with type-checked components and managing dependencies between state machines.",
      "description_length": 418,
      "index": 239,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rfsm.Systemc.SYSTEMC-Static-Syntax-Guest-Types",
      "library": "rfsm",
      "description": "This module defines and manipulates type representations in a guest language, supporting operations to construct function types, check for event or boolean types, and print types in a readable format. It works with a polymorphic type `typ` that represents various kinds of types, including base types like event and boolean, and function types built from argument and return types. Concrete use cases include type checking and type representation in a compiler or interpreter for a domain-specific language embedded within OCaml.",
      "description_length": 529,
      "index": 240,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rfsm.Ctask.CTASK-G",
      "library": "rfsm",
      "description": "This module provides functions to pretty-print C declarations and expressions from an abstract syntax tree. It handles type expressions, type declarations, and expressions, converting them into their corresponding C syntax. Concrete use cases include generating C code from a higher-level intermediate representation, such as compiling a domain-specific language to C.",
      "description_length": 368,
      "index": 241,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Guest.T",
      "library": "rfsm",
      "description": "This module defines the core components and operations for implementing a finite state machine (FSM) guest system. It includes data types for states, transitions, and events, along with functions for parsing, typing, evaluating, and generating code for FSMs in both C and SystemC. Concrete use cases include modeling hardware behavior, generating synthesizable code, and performing static analysis on state machines.",
      "description_length": 416,
      "index": 242,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Ctask.CTASK",
      "library": "rfsm",
      "description": "This module handles the generation of output files from a static configuration, using graph structures defined in the `G` submodule. It provides the `output` function, which writes files to a specified directory based on data from the `Static.t` type. Concrete use cases include exporting configuration-based artifacts to disk, such as generated source files or resource bundles.",
      "description_length": 379,
      "index": 243,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Host.T-Systemc-G-Static",
      "library": "rfsm",
      "description": "This module implements static evaluation of expressions in a guest language, providing `eval` to compute values from constant expressions and `eval_fn` to handle function-like constructs with argument lists. It operates on `expr` and `value` types, which represent the syntax and semantics of expressions in a static context. Concrete use cases include evaluating compile-time constants and resolving static function calls during analysis or optimization passes.",
      "description_length": 462,
      "index": 244,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Guest.T-Eval",
      "library": "rfsm",
      "description": "This module evaluates expressions and maintains a dynamic environment for variable bindings. It supports expression evaluation, boolean evaluation, and environment updates, working with syntax trees and values. Use it to interpret programs in a stateful context, such as executing scripts or modeling state transitions.",
      "description_length": 319,
      "index": 245,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Dynamic.Make",
      "library": "rfsm",
      "description": "This module implements a runtime engine for executing finite state machine programs, processing state transitions and event sequences guided by external evaluation logic. It integrates event manipulation capabilities for timed automata, modeling events as timestamped transitions with support for union, partitioning, and trace serialization. Key data types include state-change triggers, event sets, and timestamped expressions, enabling operations like scheduling clock-driven transitions and capturing system logs with precise timing. Users can simulate reactive systems, analyze event sequences, and generate execution traces for verification and testing purposes.",
      "description_length": 668,
      "index": 246,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Guest.EVAL-Value",
      "library": "rfsm",
      "description": "This module defines operations for handling typed values, including creating default values for specific types. It supports conversion to VCD-compatible types and values, enabling simulation data to be dumped in VCD format. The `flatten` function decomposes structured values into scalar components with qualified identifiers, facilitating hierarchical signal representation in VCD output.",
      "description_length": 389,
      "index": 247,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rfsm.Compiler.PARSER",
      "library": "rfsm",
      "description": "This module defines the interface for parsing token streams into executable programs using a provided lexer function. It operates on `token` and `program` types, which represent parsed language elements and the resulting abstract syntax tree, respectively. A concrete use case is transforming a sequence of lexical tokens generated from a source file into a structured program representation suitable for further compilation or interpretation steps.",
      "description_length": 449,
      "index": 248,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rfsm.Guest.T-Info",
      "library": "rfsm",
      "description": "This module defines basic metadata about a guest language, including its name and version. It provides direct access to these values as string literals. Use this module to retrieve identity information about the guest language implementation.",
      "description_length": 242,
      "index": 249,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Depg.TS",
      "library": "rfsm",
      "description": "This module supports topological sorting and mapping of names to graph vertices and descriptors. It provides `fold` and `iter` functions to traverse graph vertices in topological order. Use it when processing dependencies or evaluating ordered operations on directed acyclic graphs.",
      "description_length": 282,
      "index": 250,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Guest.T-Ctask",
      "library": "rfsm",
      "description": "This module provides functions to pretty-print C declarations and expressions for symbols, types, and expressions. It operates on data types such as `Rfsm.Ident.t`, `Syntax.type_expr`, `Syntax.type_decl`, and `Syntax.expr`. Use cases include generating C code from internal syntax representations, such as printing a typed variable declaration or converting an expression to its C equivalent.",
      "description_length": 392,
      "index": 251,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rfsm.Static.T",
      "library": "rfsm",
      "description": "This module represents a static analysis framework for finite state machines, providing operations to build and print structured models with typed components. It works with state machine descriptions, typed contexts, and value environments, supporting analysis of inputs, outputs, shared variables, and dependencies. Concrete use cases include validating machine configurations, analyzing signal dependencies, and generating structured representations of state transitions for further processing.",
      "description_length": 496,
      "index": 252,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Dynamic.DYNAMIC",
      "library": "rfsm",
      "description": "This module implements a runtime environment for evaluating finite state machine programs. It processes a parsed program through static analysis, event sequence generation, and dynamic evaluation to produce a trace of state transitions. The core operations include program execution, event handling, and state management, used for simulating state machine behavior from input specifications.",
      "description_length": 391,
      "index": 253,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Compiler.T",
      "library": "rfsm",
      "description": "Implements a state machine compiler that generates executable code from a state machine specification. It processes state transitions and event handlers to produce a runnable application entry point. Useful for embedding state machine logic directly into OCaml programs.",
      "description_length": 270,
      "index": 254,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Ctask.CTASK-Static-Syntax-Guest",
      "library": "rfsm",
      "description": "This module provides utilities for constructing and inspecting type expressions, declarations, and expressions in a guest language syntax, with support for substitution and environment-driven preprocessing. It operates on annotated syntax trees representing types, l-values, and expressions, offering operations like variable extraction, type alias creation, and scoped name manipulation for VCD trace generation. Specific use cases include type-directed expression rewriting, identifier substitution in guest code transformations, and preparing syntax for simulation trace analysis.",
      "description_length": 583,
      "index": 255,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Syntax.SYNTAX",
      "library": "rfsm",
      "description": "This module provides operations to construct and transform abstract syntax trees for a modeling language, including substituting inputs, outputs, and parameters, normalizing models, and rendering syntax elements into textual representations. It operates on data structures representing finite state machine components\u2014such as actions, transitions, states, and models\u2014alongside their type and expression descriptors. These capabilities enable tasks like building and analyzing FSM-based programs, generating code or documentation through formatted output, and debugging model behavior via human-readable dumps of internal structures.",
      "description_length": 632,
      "index": 256,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Guest.T-Static",
      "library": "rfsm",
      "description": "This module implements static evaluation of expressions in a guest language, handling both direct evaluation of literals and function definitions. It operates on expression and value types tied to the guest language's syntax and runtime representation. Concrete use cases include evaluating constant expressions at compile time and constructing function closures from static definitions.",
      "description_length": 387,
      "index": 257,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rfsm.Dynamic.DYNAMIC-Static",
      "library": "rfsm",
      "description": "This module implements runtime state machine evaluation by managing typed state, transitions, and execution context. It processes normalized models and maintains dynamic state through typed environments, handling input/output interactions and shared state synchronization. Key operations include building execution contexts from typed programs and pretty-printing runtime structures for debugging.",
      "description_length": 397,
      "index": 258,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Dynamic.DYNAMIC-EvSeq-Evset-Event-Value",
      "library": "rfsm",
      "description": "This module defines operations for handling typed values with support for VCD serialization and structured value decomposition. It provides functions to obtain default values for types, convert values to VCD types and encodings, flatten structured values into scalar components for VCD output, and print values. It works with scalar and structured data types, specifically supporting use cases like VCD file generation for simulation traces and value manipulation in event-driven simulations.",
      "description_length": 492,
      "index": 259,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rfsm.Depg.NODE",
      "library": "rfsm",
      "description": "This module defines operations for identifying and comparing nodes using a unique identifier. It provides a function to retrieve the unique name of a node and another to determine dependency relationships between nodes within a given context. These operations are used to manage node dependencies in a finite state machine representation.",
      "description_length": 338,
      "index": 260,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Host.T-Syntax",
      "library": "rfsm",
      "description": "This module enables constructing and combining guest language programs, substituting model inputs and parameters, normalizing models, and generating human-readable representations of syntax elements. It works with programs, models, types, expressions, and FSM constructs such as states, transitions, and actions. These operations are essential for debugging, model transformation, and building finite state machine-based systems.",
      "description_length": 429,
      "index": 261,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Ctask.CTASK-Static-Syntax-Guest-Types",
      "library": "rfsm",
      "description": "This module defines and manipulates guest language types, including function types, event types, and boolean types. It provides constructors for building function types from argument and return types, inspectors to check for specific type kinds, and a formatter for readable type output. Concrete use cases include type checking and type representation in a guest language interpreter or compiler.",
      "description_length": 397,
      "index": 262,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Host.T-Dynamic-EvSeq-Evset-Event-Syntax-Types",
      "library": "rfsm",
      "description": "This module defines and manipulates type values, including function types and primitive types like event and boolean. It provides operations to construct function types, check type properties, and print type representations. Concrete use cases include type checking expressions and formatting types for error messages or logging.",
      "description_length": 329,
      "index": 263,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Compiler.LEXER",
      "library": "rfsm",
      "description": "Implements the lexical analysis phase for parsing input streams into tokens. It defines the `token` type and handles lexical errors such as `Illegal_character`. Provides the `main` function that processes a `Lexing.lexbuf` to produce a `token`, used during the compilation of formal state machine descriptions.",
      "description_length": 310,
      "index": 264,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rfsm.Vhdl.VHDL-Static-Syntax",
      "library": "rfsm",
      "description": "This module provides operations for constructing and combining VHDL programs, substituting model parameters and signals, normalizing hierarchical models, and serializing syntax elements into human-readable text. It works with VHDL-like static syntax structures such as expressions, type declarations, state machines, transitions, and annotated program blocks. These capabilities support use cases like model transformation, formal verification workflows, and generating debuggable representations of hardware designs.",
      "description_length": 517,
      "index": 265,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Dynamic.DYNAMIC-EvSeq-Evset-Event",
      "library": "rfsm",
      "description": "This module defines a type `t` representing events in a dynamic finite state machine, including pure events, assignments, and state transitions. It provides operations to check if an event is a pure event, compare events, and pretty-print them. Concrete use cases include modeling state changes, variable updates, and event handling in reactive systems.",
      "description_length": 353,
      "index": 266,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rfsm.Host.Make",
      "library": "rfsm",
      "description": "This module builds a host language implementation from a guest language, enabling type-checking, elaboration, and execution of guest programs while supporting output formats like VCD, SystemC, and VHDL. It processes guest syntax into typed programs and structured contexts, using dynamic evaluation for reactive systems and static analysis for code generation, with core types like `program`, `t`, and `Static.t`. You can simulate guest code with event-driven execution, generate visualizations of state machines in Dot format, compile guest constructs into SystemC modules or VHDL entities, and export simulation traces to VCD files. Submodules handle tasks like syntax manipulation, type normalization, value representation, and C code generation, supporting end-to-end workflows from guest semantics to executable or synthesizable code.",
      "description_length": 839,
      "index": 267,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Host.T-Dynamic-EvSeq-Evset-Event-Syntax",
      "library": "rfsm",
      "description": "This module enables constructing, analyzing, and transforming type expressions, expressions, and l-values in a guest language, with utilities for extracting variables, checking type properties (e.g., boolean validation), and generating VCD-compatible representations. It supports substitution of identifiers/parameters and environment-driven preprocessing for dynamic event syntax contexts, handling parameterized type expressions and l-value manipulations. Key applications include VCD trace generation and runtime reconfiguration of expressions through dynamic event sequencing.",
      "description_length": 580,
      "index": 268,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Dynamic.DYNAMIC-Eval-Syntax-Types",
      "library": "rfsm",
      "description": "This module defines and manipulates type values used to represent function and base types in a guest language. It provides constructors for creating function types and a special undefined type, along with inspectors to check for specific base types such as event and boolean. The module is used to build, query, and print type information during evaluation or analysis of guest language expressions.",
      "description_length": 399,
      "index": 269,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rfsm.Systemc.SYSTEMC-Static-Value",
      "library": "rfsm",
      "description": "This module defines operations for handling static values in a hardware description context. It provides functions to generate default values for types, and to convert static values to VCD-compatible types and values for waveform visualization. It also includes a function to flatten structured values into scalar components for VCD dumping, and a printer for formatting values.",
      "description_length": 378,
      "index": 270,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Host.T-Static-Syntax",
      "library": "rfsm",
      "description": "This module provides operations for constructing, combining, and transforming guest language programs and models in a static syntax form, including parameter substitution, I/O manipulation, and model normalization. It works with structured representations of static syntax elements such as actions, transitions, states, type declarations, and expressions. These capabilities are primarily used for program analysis, transformation pipelines, and generating human-readable diagnostics through formatted output.",
      "description_length": 509,
      "index": 271,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Vcd_types",
      "library": "rfsm",
      "description": "This module defines types for representing Value Change Dump (VCD) data, including signal types like integers, booleans, and floats, along with functions to pretty-print and manipulate these types. It supports operations for registering and formatting VCD signals, which associate identifiers with their types and single-character VCD identifiers. Concrete use cases include generating and processing VCD files for digital signal simulation and waveform visualization.",
      "description_length": 468,
      "index": 272,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Compiler",
      "library": "rfsm",
      "description": "This module implements a command-line compiler that processes input files through a lexer and parser, supporting custom language definitions via modular interfaces. It coordinates the compilation workflow by combining lexer, parser, and language rule implementations to transform source code into executable programs. Core data types include `token` for lexical elements and `program` for parsed structures, with operations for tokenizing input buffers and parsing token streams. It enables use cases such as compiling domain-specific languages, translating state machine specifications into executable code, and handling lexical errors during input processing.",
      "description_length": 661,
      "index": 273,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rfsm.Cmodel",
      "library": "rfsm",
      "description": "This module provides a framework for modeling C-like abstract state machines with typed components, supporting both definition and transformation of structured models. It defines core data types for states, transitions, typed expressions, and static values, with operations to parse, validate, and pretty-print models, along with utilities for substitution, normalization, and type checking. Child modules extend this foundation with specialized capabilities such as FSM manipulation, guest language typing, VCD-compatible value handling, and structured code generation. Examples include building and analyzing protocol state machines, transforming typed signal representations, and generating simulation traces from structured models.",
      "description_length": 735,
      "index": 274,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Dot",
      "library": "rfsm",
      "description": "This module generates DOT visualizations of state machines, offering configuration options for layout and appearance, and works with structured FSM data to produce diagrams for debugging and documentation. It provides data types for state transitions, typed variables, and hierarchical models, along with operations to build, transform, and pretty-print these structures. Submodules support type checking, environment management, guest language typing, VCD conversion, and syntax analysis, enabling end-to-end workflows from program definition to graphical output. Examples include exporting FSMs to Graphviz-compatible files, normalizing model syntax, and generating traceable VCD representations of structured values.",
      "description_length": 719,
      "index": 275,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Location",
      "library": "rfsm",
      "description": "This module represents and manipulates source code locations using a custom type that captures file names and character ranges. It provides functions to create locations from lexing positions, retrieve the current input location, and format or convert locations to strings for error reporting or logging. Concrete use cases include tracking where expressions or statements originate in source files during parsing and compilation.",
      "description_length": 430,
      "index": 276,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rfsm.Dynamic",
      "library": "rfsm",
      "description": "This module simulates programs according to formal operational semantics, using mutable control flow graphs to manage execution state and trace output. It coordinates with event and value modules to evaluate expressions, track dynamic environments, and generate VCD traces of simulation runs. Concrete operations include executing state transitions, logging timestamped events, and exporting structured values to VCD format for hardware tracing. Key data types include control flow graphs, typed values, event sets, and dynamic environments, enabling simulation of reactive systems with precise timing and trace visualization.",
      "description_length": 626,
      "index": 277,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Evseq",
      "library": "rfsm",
      "description": "This module handles sequences of timed event sets, where each event occurs at a specific time, supporting alignment, merging, and querying by time intervals. It provides core operations to manipulate event sequences, extract subsets, and model system stimuli and responses in reactive systems. Child modules enhance this functionality by managing date-associated event sets, defining event types and values, implementing syntax-level transformations, and supporting VCD output for simulation. Examples include modeling state transitions, scheduling signals, and generating trace visualizations from event-based computations.",
      "description_length": 624,
      "index": 278,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rfsm.Env",
      "library": "rfsm",
      "description": "This module implements a map-like structure for managing identifier-value bindings, supporting operations like adding, updating, and finding bindings, as well as iterating, folding, and filtering over environments. It works with environments parameterized by a value type `'a`, using `Rfsm.Ident.t` as the key type. Use cases include tracking variable bindings during evaluation, managing state transitions in finite state machines, and maintaining scoped configurations.",
      "description_length": 471,
      "index": 279,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Subst",
      "library": "rfsm",
      "description": "This module implements substitution mappings from identifiers to arbitrary values, supporting application of substitutions and pretty-printing. It provides `apply` to retrieve values bound to identifiers and `pp` to format substitutions for debugging or logging. Use cases include managing variable bindings during program analysis or transforming abstract syntax trees with identifier replacements.",
      "description_length": 399,
      "index": 280,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "Rfsm.Logfile",
      "library": "rfsm",
      "description": "This module manages the logging of compiler output to a file. It provides operations to start and stop logging, write strings to the log, and control the output channel. Concrete use cases include capturing compilation traces for debugging or auditing purposes.",
      "description_length": 261,
      "index": 281,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Evset",
      "library": "rfsm",
      "description": "This module manages sets of concurrent events with rich operations for combination, filtering, and analysis, supporting event types that can be compared and composed into atomic events. It provides core data structures like event sets and timestamps, along with operations for union, intersection, and difference, enabling precise modeling of simultaneous state transitions and trigger aggregation. Submodules extend this foundation with timestamped event sets for reactive systems, type representations for event-based languages, and utilities for VCD output generation and syntax manipulation. Use it to build state machines with complex transitions, validate event types in domain-specific languages, or generate simulation traces from structured event data.",
      "description_length": 761,
      "index": 282,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Guest",
      "library": "rfsm",
      "description": "This module provides the foundational abstractions for embedding and processing guest languages in a hardware modeling or simulation environment. It defines core data types for expressions, types, and values, along with operations for type checking, static evaluation, and environment management, enabling tasks like compile-time constant folding, type inference, and dynamic interpretation. Submodules handle language-specific tasks such as C, SystemC, and VHDL code generation, VCD trace output, scoped identifier resolution, and parameterized construct substitution, supporting end-to-end workflows from parsing to simulation and synthesis. Examples include translating typed expressions into VHDL entities, evaluating configuration logic at runtime, and generating SystemC headers from internal type declarations.",
      "description_length": 817,
      "index": 283,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Annot",
      "library": "rfsm",
      "description": "This module creates and transforms annotated values with location, type, and description. It supports precise source tracking and type association for AST nodes. Use when building or modifying typed syntax trees during parsing or analysis.",
      "description_length": 239,
      "index": 284,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Vcd",
      "library": "rfsm",
      "description": "This module generates Value Change Dump files to track signal changes over time in digital simulations. It provides functions to define signals, update their values, and output transitions at specific time points, with configuration options for integer and float representations. The `Make` functor allows creating VCD writers for custom signal types, while child modules handle the serialization of signal sequences and event sequences into VCD format for waveform visualization. Example uses include generating simulation traces for hardware verification or capturing temporal behavior in digital circuits.",
      "description_length": 608,
      "index": 285,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Ext",
      "library": "rfsm",
      "description": "This module extends core OCaml functionality with utilities for optional values, file handling, mathematical operations, list transformations, and formatted output. Key data types include options, files, integers, lists, and formatters, with operations like `pp` for optional value printing, `pow2` for exponentiation, `neg` for predicate inversion, and list Cartesian product generation. It enables tasks such as custom logging of optional values, file templating with string substitution, bit manipulation, structured list aggregation, and precise text layout control. Example uses include generating debug output, transforming configuration files, implementing combinatorial logic, and formatting code or logs with alignment.",
      "description_length": 728,
      "index": 286,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Static",
      "library": "rfsm",
      "description": "This module performs static elaboration of typed programs, resolving type information and generating an optimized intermediate representation. It works with typed abstract syntax trees and module type declarations to ensure type correctness, expand type abbreviations, and prepare programs for further compilation stages. The module's core functionality is complemented by submodules that handle value conversion for VCD output, type checking, AST manipulation, guest language type management, FSM representation, type-directed syntax transformations, and static analysis of state machines. Together, these components enable tasks like generating simulation traces, analyzing dependencies, validating configurations, and producing structured FSM reports.",
      "description_length": 754,
      "index": 287,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Version",
      "library": "rfsm",
      "description": "Contains the compiler version as a string. Used to identify the exact version of the compiler being used, which is useful for debugging and ensuring compatibility across different builds.",
      "description_length": 187,
      "index": 288,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Rfsm.Options",
      "library": "rfsm",
      "description": "This module provides operations to configure compiler behavior through mutable flags and value setters, supporting tasks like target format selection (Dot, CTask, VHDL), simulation parameter tuning (time units, trace levels), and output customization. It operates on global state via `Stdlib.ref` cells for string and boolean values, enabling runtime adjustments to settings such as directories, debug modes, and code generation options. Specific use cases include enabling GUI visualization, normalizing FSM representations, and generating simulation traces or hardware description code.",
      "description_length": 588,
      "index": 289,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Misc",
      "library": "rfsm",
      "description": "This module defines an `act_semantics` type with `Sequential` and `Synchronous` constructors, representing execution modes for state machines. It includes functions for raising fatal errors, issuing warnings, and marking unimplemented features with descriptive messages. These operations support robust error handling and development feedback in state machine implementations.",
      "description_length": 376,
      "index": 290,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Host",
      "library": "rfsm",
      "description": "This module orchestrates host-specific runtime behaviors for state machine execution, integrating system call bindings, event handling, and platform customization with abstract state machine definitions. It supports constructing, analyzing, and executing guest language programs through submodules that handle type manipulation, syntax transformation, static evaluation, and code generation for targets like VHDL, SystemC, and C. Key data types include typed expressions, l-values, type declarations, and state machine models, with operations for type checking, environment management, pretty-printing, and VCD trace generation. Examples include compiling guest programs into synthesizable VHDL, simulating reactive event-driven systems, and exporting state machine configurations to static files.",
      "description_length": 797,
      "index": 291,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Ident",
      "library": "rfsm",
      "description": "This module defines identifiers with a scope and string value, supporting operations to create, modify, and print identifiers with global or local scope. It provides functions to update the identifier's string, compare identifiers (ignoring scope), and format identifiers for output, with special handling for global identifiers by prefixing with \"$\". Use cases include managing scoped names in a compiler or interpreter, such as variable names in different namespaces or symbol tables.",
      "description_length": 486,
      "index": 292,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Vhdl_types",
      "library": "rfsm",
      "description": "This module defines data types and operations for representing and printing VHDL type declarations. It includes types for standard logic, integers, arrays, enums, and records, along with configuration options for type formatting. The `pp` function prints these types using customizable type markers, while `cfg` controls aspects like enum prefixing and use of numeric_std.",
      "description_length": 372,
      "index": 293,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rfsm.Syntax",
      "library": "rfsm",
      "description": "This module defines the abstract syntax tree (AST) for a host language, with core data types for expressions, statements, and program structures. It provides functions to build and inspect AST nodes, supporting parsing and code generation for compilers or interpreters. The module works with child modules to extend syntax handling into type manipulation, domain-specific language embedding, and finite state machine (FSM) modeling. For example, it enables type checking through `typ` representations, scoped identifier resolution in DSLs, structured FSM transformations, and model normalization with textual rendering for debugging and code generation.",
      "description_length": 653,
      "index": 294,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rfsm.Systemc",
      "library": "rfsm",
      "description": "This module generates SystemC simulation code from finite state machine models, configuring output parameters like signal prefixes and simulation settings through a structured configuration. It supports type analysis, expression evaluation, and code generation via submodules that handle static typing, program transformation, expression normalization, and VCD trace generation. Developers can define clocked processes, generate testbenches, and enable waveform debugging by working with types, expressions, and FSM models as structured data. Key operations include type-checking, static evaluation, scoped substitution, and file generation for SystemC headers, source files, and simulation traces.",
      "description_length": 698,
      "index": 295,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Depg",
      "library": "rfsm",
      "description": "This module organizes dependency graphs with named vertices and directed edges, enabling topological sorting, cycle detection, and dependency resolution. It provides core operations to build and traverse graphs, associate data with nodes, and manage relationships through maps and sequences. Submodules handle vertex identity, state tracking, dependency-aware sorting, and mappings between names and graph elements. You can model build systems, schedule tasks with dependencies, or analyze networks by constructing graphs, querying adjacency, and iterating in topological order with custom data attached to nodes.",
      "description_length": 613,
      "index": 296,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Bits",
      "library": "rfsm",
      "description": "Handles bit-level operations on integers, including extracting, setting, and converting bit ranges. Works directly with integers and string representations of bit sequences. Useful for low-level data manipulation, such as encoding protocols or hardware register configuration.",
      "description_length": 276,
      "index": 297,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Ctask",
      "library": "rfsm",
      "description": "This module manages state machines with customizable configuration and typed models, enabling code generation and runtime control through mutable state and typed syntax trees. It provides core data types like typed expressions, type declarations, and FSM structures, along with operations for type inference, model instantiation, and VCD trace generation. Submodules support static analysis, syntax transformation, and C code emission, handling tasks like type checking, pretty printing, and environment-sensitive preprocessing. Examples include generating VCD signal dumps, validating function signatures, and compiling domain-specific models to executable C code.",
      "description_length": 665,
      "index": 298,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rfsm.Typing",
      "library": "rfsm",
      "description": "This module orchestrates type inference and checking across expressions, statements, and program structures, ensuring type consistency through abstract syntax trees and typing environments. It defines core data types like type values, environments, and typed ASTs, with operations for type validation, substitution, and normalization. Functionality spans from constructing and inspecting types\u2014such as function and built-in types\u2014to analyzing expressions, l-values, and FSM components within a host and guest language context. Examples include inferring types for program models, validating FSM guards and transitions, generating structured type output for debugging, and transforming programs through type-directed optimizations and macro expansion.",
      "description_length": 750,
      "index": 299,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm.Event",
      "library": "rfsm",
      "description": "This module orchestrates event handling in reactive finite state machines by combining event creation, dispatching, and filtering with rich data modeling and type manipulation. It defines core types like `t` for events, `Ev`, `Upd`, and `StateMove` for state transitions and value updates, alongside typed values and type representations that support VCD conversion, type checking, and syntax manipulation. Operations include event comparison, type inspection, identifier substitution, and environment-driven preprocessing, enabling tasks like logging state changes, generating VCD traces, and verifying guest-language expressions. Submodules extend functionality to formal verification, compiler workflows, and GUI event coordination through typed value handling, syntax tree transformations, and state-aware event routing.",
      "description_length": 824,
      "index": 300,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rfsm.Vhdl",
      "library": "rfsm",
      "description": "This module generates VHDL code for finite state machines and supports simulation with VCD or GHW waveform dumps, working with state machine descriptions and configuration parameters like library names and signal prefixes. It provides data types for state machines, types, expressions, and static values, with operations for type checking, expression evaluation, syntax construction, and VCD-compatible value conversion. Submodules handle VHDL syntax manipulation, type representation, static analysis, FSM modeling, and code generation, enabling tasks like translating OCaml types to VHDL, normalizing hierarchical models, and generating synthesizable code with customizable testbenches. Example uses include exporting RFSM models to hardware descriptions, evaluating constant expressions, and setting up traceable simulations with precise signal dumping.",
      "description_length": 856,
      "index": 301,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rfsm",
      "library": "rfsm",
      "description": "This module suite provides a comprehensive infrastructure for modeling, simulating, and compiling state machines with rich type systems, event handling, and hardware tracing capabilities. It centers around typed expressions, state transitions, and value representations, supporting operations like VCD generation, DOT visualization, and VHDL/SystemC code emission. You can define and analyze protocol state machines, simulate reactive systems with precise timing, generate waveform traces, or compile domain-specific models into executable or synthesizable code. Specific workflows include translating FSMs into simulation code, validating typed expressions, tracking source locations during compilation, and visualizing complex state transitions with customizable graph layouts.",
      "description_length": 779,
      "index": 302,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 306,
    "meaningful_modules": 303,
    "filtered_empty_modules": 3,
    "retention_rate": 0.9901960784313726
  },
  "statistics": {
    "max_description_length": 911,
    "min_description_length": 187,
    "avg_description_length": 477.2838283828383,
    "embedding_file_size_mb": 1.1009206771850586
  }
}