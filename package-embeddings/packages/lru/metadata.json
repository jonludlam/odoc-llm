{
  "package": "lru",
  "embedding_model": "Qwen/Qwen3-Embedding-8B",
  "embedding_dimension": 4096,
  "total_modules": 5,
  "creation_timestamp": "2025-08-14T23:07:52.460731",
  "modules": [
    {
      "module_path": "Lru.M.MakeSeeded",
      "library": "lru",
      "description": "This module implements a mutable cache with weight-aware eviction policies, offering operations to add, retrieve, and manipulate key-value pairs while maintaining capacity constraints based on cumulative weights. It uses a seeded hash table paired with a linked list to track access order, enabling efficient promotion of frequently used items and removal of least-recently-used entries when capacity is exceeded. It is particularly useful for resource-constrained caching scenarios where items have variable weights, such as memory-limited object caches or prioritized data buffering systems.",
      "description_length": 593,
      "index": 0,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lru.F.Make",
      "library": "lru",
      "description": "The module implements functional LRU caches that manage key-value bindings with weights derived from stored values, supporting operations like insertion, LRU eviction, and weight-based trimming. It uses priority search queues for efficient $O(\\log n)$ access and maintains ordering for traversal by usage or keys. This structure suits scenarios requiring bounded caches with dynamic weighting, such as limiting memory usage by resource size or tracking fixed-size recent item lists via unit weights.",
      "description_length": 499,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lru.F",
      "library": "lru",
      "description": "This module implements a functional LRU map backed by a priority search queue, supporting efficient insertion, lookup, and deletion with per-operation `O(log n)` complexity. It works with weighted key-value pairs, automatically evicting least-recently-used entries when the total weight exceeds a configured capacity. Concrete use cases include managing size-constrained caches where entries have variable memory footprints or prioritizing recently accessed data in logarithmic time.",
      "description_length": 483,
      "index": 2,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lru.M",
      "library": "lru",
      "description": "This module implements a mutable LRU map with O(1) operations for insertion, lookup, and deletion, backed by a hash table and doubly-linked list. It supports weight-bounded caching where each binding can contribute a specified weight toward a capacity limit. Concrete use cases include efficient in-memory caches for resource-constrained environments, such as limiting the number or total size of cached entries in a web server or database query cache.",
      "description_length": 452,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lru",
      "library": "lru",
      "description": "This module implements LRU caches with weight-bounded key-value storage, supporting efficient insertion, lookup, and eviction based on usage and configurable weights. It provides both functional and imperative map variants, where the functional version uses priority search queues for `O(log n)` operations and the imperative version combines hash tables with linked lists for `O(1)` access. It is suitable for resource-constrained caching scenarios such as limiting the memory footprint of stored values in a web server or managing a fixed-size cache of expensive computations with varying result sizes.",
      "description_length": 604,
      "index": 4,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 6,
    "meaningful_modules": 5,
    "filtered_empty_modules": 1,
    "retention_rate": 0.8333333333333334
  },
  "statistics": {
    "max_description_length": 604,
    "min_description_length": 452,
    "avg_description_length": 526.2,
    "embedding_file_size_mb": 0.07284832000732422
  }
}