{
  "package": "archetype",
  "embedding_model": "Qwen/Qwen3-Embedding-8B",
  "embedding_dimension": 4096,
  "total_modules": 97,
  "creation_timestamp": "2025-08-15T16:27:03.062046",
  "modules": [
    {
      "module_path": "Archetype.Typing.Env.Record",
      "library": "archetype",
      "description": "This module manages record type information within a typing environment, providing operations to query, insert, and retrieve record declarations and their fields. It works with record environments, long identifiers, and fully-qualified names to support precise type resolution during type checking. Concrete use cases include resolving record field types during expression typing and validating record construction against declared definitions.",
      "description_length": 444,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Typing.Env.Label",
      "library": "archetype",
      "description": "This module manages label bindings in a typing environment, providing operations to look up, retrieve, check existence, and add labels associated with identifiers. It works with typing environments and label kinds, specifically handling identifier-label associations. Concrete use cases include tracking field labels in record types and managing labeled parameters in function definitions during type checking.",
      "description_length": 410,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Typing.Type.Michelson",
      "library": "archetype",
      "description": "This module provides predicates to classify Michelson types based on their structural and operational properties. It operates on `A.ptyp` values, which represent typed intermediate representations of Michelson data. These functions are used to determine type capabilities such as comparability, storability, and packability, which are essential for validating smart contract operations and ensuring type correctness during compilation.",
      "description_length": 435,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Mtyping.Env.Contract",
      "library": "archetype",
      "description": "This module provides functions to retrieve the parameter type, storage type, and code structure from a contract environment. It operates on the `Archetype.Mtyping.Env.t` type, which represents the typing context of a contract. Concrete use cases include type checking and code generation during contract analysis or compilation.",
      "description_length": 328,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Tools.Set.Make",
      "library": "archetype",
      "description": "This module provides functions for set-theoretic operations (union, intersection, difference), element manipulation, and transformations like mapping, filtering, and folding over immutable sets. It operates on a parametric set type `t` containing elements of type `elt`, with support for conversions to and from ordered sequences (`Stdlib.Seq.t`) and lists. These capabilities are particularly useful for functional data processing pipelines where persistent, ordered collections must be aggregated, transformed, or combined without side effects.",
      "description_length": 546,
      "index": 4,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Archetype.Typing.Env.Context",
      "library": "archetype",
      "description": "This module manages type environment contexts for identifier binding and retrieval during type checking. It provides operations to access the current environment (`the`) and extend it with a new local identifier (`push`). Used to track variable scopes and type associations in the compilation pipeline.",
      "description_length": 302,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Typing.Env.Var",
      "library": "archetype",
      "description": "This module manages variable declarations within a typing environment, providing operations to add, check, and retrieve variable entries. It works with environment (`Archetype.Typing.Env.t`) and variable declaration (`Archetype.Typing.vardecl`) data types, using identifiers such as `longident` and `fullname`. It is used during type checking to track declared variables and ensure correct name resolution and scoping.",
      "description_length": 418,
      "index": 6,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Archetype.Typing.Env.State",
      "library": "archetype",
      "description": "This module manages state lookups and insertions within a typing environment, providing direct access to state declarations and environment entries. It operates on environment (`Archetype.Typing.Env.t`) and identifier (`Archetype.Typing.longident`, `Archetype.Typing.fullname`) types to track and retrieve typing information. Concrete use cases include resolving variable references, checking existence of bindings, and extending environments with new state entries during type checking.",
      "description_length": 487,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Tools.Map.Make",
      "library": "archetype",
      "description": "The module implements a polymorphic map structure with ordered keys, supporting insertion, deletion, merging, and ordered traversal, along with safe lookup variants (`_opt`) and key-based aggregations. It operates on maps with keys of type `S.t` and arbitrary values, enabling transformations like filtering, partitioning, and folding, while interfacing with lists and sequences for bulk operations. Use cases include maintaining sorted key-value associations, grouping elements by keys, and safely modifying values through key-directed updates or merges.",
      "description_length": 555,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Typing.Env.Event",
      "library": "archetype",
      "description": "This module provides operations for querying and manipulating a typing environment, including looking up and checking the existence of identifiers, retrieving records by name, and adding new records. It works with data types representing typing environments, long identifiers, full names, and record declarations. Concrete use cases include resolving variable references during type checking and managing scoped definitions in a compiler or interpreter.",
      "description_length": 453,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Typing.Env.Import",
      "library": "archetype",
      "description": "This module manages the resolution and caching of imported declarations within a typing environment. It provides operations to look up, retrieve, and store imports by identifier, as well as cache management functions to store and retrieve resolved imports by key. It is used during type checking to handle module imports and resolve external references efficiently.",
      "description_length": 365,
      "index": 10,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Typing.Env.Function",
      "library": "archetype",
      "description": "This module manages function declarations within a typing environment. It supports operations to look up, check existence, retrieve, and add function declarations using either long identifiers or full names. Concrete use cases include resolving function references during type checking and maintaining the scope of defined functions.",
      "description_length": 333,
      "index": 11,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Typing.Env.Asset",
      "library": "archetype",
      "description": "This module manages asset-related information within a typing environment. It supports operations to lookup, insert, and check existence of assets by identifier, as well as retrieving assets by field declarations. It is used during type checking to resolve asset references and validate field accesses in data structures.",
      "description_length": 321,
      "index": 12,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Archetype.Typing.Env.Local",
      "library": "archetype",
      "description": "This module manages local variable bindings in a typing environment, supporting operations to look up, add, and check the existence of variables with their types and binding kinds. It works with identifiers, type expressions, and environment structures to track local scope during type checking. Concrete use cases include resolving variable references in function bodies and enforcing correct type usage in nested scopes.",
      "description_length": 422,
      "index": 13,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Typing.Env.FunctionProperties",
      "library": "archetype",
      "description": "Tracks and modifies function properties such as side effects, storage usage, and return behavior within a typing environment. It operates directly on the `Archetype.Typing.Env.t` type, allowing inspection and updating of function characteristics during type checking. This module is used to enforce correctness constraints when analyzing or transforming function definitions in a domain-specific language.",
      "description_length": 405,
      "index": 14,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Archetype.Typing.Env.Type",
      "library": "archetype",
      "description": "This module provides operations for querying and extending a typing environment. It supports looking up type information by long identifiers, checking existence of bindings, and adding new type associations. The module works with environments (`Archetype.Typing.Env.t`), type definitions (`A.ptyp`), and identifier structures (`A.lident`, `Archetype.Typing.longident`, `Archetype.Typing.fullname`). It is used during type checking to manage and retrieve type bindings in a structured scope.",
      "description_length": 490,
      "index": 15,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Typing.Env.Tentry",
      "library": "archetype",
      "description": "This module manages typed environment entries in a functional manner, providing operations to query and extend environments with type declarations. It works with environments (`Archetype.Typing.Env.t`), type entry declarations (`Archetype.Typing.tentrydecl`), and identifiers (`Archetype.Typing.longident`, `Archetype.Typing.fullname`). Use cases include type checking by looking up declared types, verifying existence of type entries, and extending environments with new type declarations during semantic analysis.",
      "description_length": 515,
      "index": 16,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Archetype.Tools.List.Exn",
      "library": "archetype",
      "description": "This module provides operations for searching and mapping values in lists with optional results. It handles association lists and supports finding elements based on predicates or keys, returning values wrapped in `option`. Concrete use cases include safely retrieving values from key-value pairs and searching for elements that match specific conditions.",
      "description_length": 354,
      "index": 17,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Tools.Bool",
      "library": "archetype",
      "description": "This module provides a single function `compare` that orders boolean values, returning an integer indicating the relative position of two booleans. It operates directly on the `bool` type, enabling sorting and comparison logic where boolean values need to be ordered. A concrete use case is in implementing custom comparison functions for data structures that include boolean fields, such as sorting a list of records based on a boolean attribute.",
      "description_length": 447,
      "index": 18,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Gen_decompile.Decomp_model",
      "library": "archetype",
      "description": "This module defines a `decompile` function that transforms a typed Archetype program and environment into a model representation, working with data types like `T.dprogram` and `M.model`. It is used to convert low-level typed programs into higher-level models for analysis or visualization.",
      "description_length": 289,
      "index": 19,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Typing.Micheline",
      "library": "archetype",
      "description": "This module parses and manipulates Micheline expressions, specifically working with `T.obj_micheline` structures representing Michelson code. It supports operations like extracting entrypoints, views, and storage types, as well as navigating and splitting Micheline nodes by key. Use cases include analyzing smart contract interfaces, retrieving view definitions, and extracting type information from Michelson code.",
      "description_length": 416,
      "index": 20,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Gen_transform.SetString",
      "library": "archetype",
      "description": "This module offers creation, modification, and querying operations for sets of strings, including union, intersection, difference, and safe lookup variants returning optional values. It supports transformations like mapping, filtering, and partitioning, along with conversions between sets and sequences, enabling ordered traversal or bulk updates. Typical use cases involve managing unique string collections, performing set algebra, and processing elements in sequential formats for tasks like configuration management or text analysis.",
      "description_length": 538,
      "index": 21,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.UF.UF",
      "library": "archetype",
      "description": "Implements a union-find data structure with support for creating disjoint sets, finding representatives, merging sets, and duplicating the structure. Operates on integer elements, tracking set membership and equivalence relationships. Useful for algorithms requiring dynamic connectivity management, such as Kruskal's minimum spanning tree or percolation simulations.",
      "description_length": 367,
      "index": 22,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Ufind.Make",
      "library": "archetype",
      "description": "Implements a union-find data structure with path compression and customizable merge semantics. It supports efficient equivalence class queries and dynamic data updates for elements of type `I.t`, tracking associated data and effects. Useful for type inference systems or constraint solvers where elements are merged incrementally with priority-based resolution.",
      "description_length": 361,
      "index": 23,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Tools.Mstr",
      "library": "archetype",
      "description": "This module offers operations for manipulating and transforming associative containers mapping string keys (`Archetype.Tools.String.t`) to arbitrary values, supporting standard map operations like insertion, deletion, and lookup, as well as advanced combinators for merging, filtering, and grouping. It provides traversal capabilities (forward/reverse), bulk transformations (`map`, `fold`), and utilities for splitting, comparing, or converting maps to lists/sequences. Use cases include configuration management, data aggregation with custom key grouping, and scenarios requiring efficient key-based queries or bulk data manipulation.",
      "description_length": 636,
      "index": 24,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Michelson_parser.Incremental",
      "library": "archetype",
      "description": "Parses Michelson code incrementally starting from a given position, producing a checkpoint for resuming parsing. It processes Micheline objects, which represent Michelson expressions in a structured form. This module is used during the compilation of Archetype smart contracts to handle partial or streaming Michelson input.",
      "description_length": 324,
      "index": 25,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Parser.Incremental",
      "library": "archetype",
      "description": "This module provides entry points for incremental parsing of Archetype expressions and top-level structures, starting from a given lexical position. It works with `expr` and `archetype` types from the ParseTree module, producing checkpoints for the Menhir interpreter. Concrete use cases include resuming parsing after partial input or handling interactive or streaming input scenarios.",
      "description_length": 386,
      "index": 26,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Archetype.Michelson.Utils",
      "library": "archetype",
      "description": "This module processes Michelson code and data structures, providing transformations and optimizations specific to the Michelson language used in smart contracts. It includes functions for flattening and optimizing Michelson code, replacing macros, and converting between Michelson representations and internal data structures. Use cases include preparing Michelson code for execution, analysis, or serialization, and checking if a type can be stored on-chain.",
      "description_length": 459,
      "index": 27,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Mtyping.Ty",
      "library": "archetype",
      "description": "This module provides type-checking operations for validating and manipulating a type-checking stack, ensuring elements conform to specific Tezos blockchain types like `address`, `contract`, cryptographic primitives, and composite structures such as `pair`, `list`, and `option`. It works with a `stack1` structure to enforce typing rules, handling tasks like signature verification, ticket validation, and type extraction while maintaining stack consistency. These operations are critical for implementing Archetype language semantics in smart contract execution, where precise type handling ensures correctness and security in decentralized applications.",
      "description_length": 655,
      "index": 28,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Archetype.Gen_transform.MapString",
      "library": "archetype",
      "description": "This module provides associative operations for string-keyed maps, including insertion, deletion, value modification via list-specific functions like `add_to_list`, and structural transformations such as merging or partitioning. It supports maps with polymorphic values, enabling iteration, filtering, and bidirectional traversal, alongside conversions to and from sequences of key-value pairs. Common applications include managing hierarchical data structures, aggregating keyed entries, and processing ordered mappings with range-based queries or reverse iteration.",
      "description_length": 567,
      "index": 29,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Core.Format",
      "library": "archetype",
      "description": "This module provides comprehensive pretty-printing capabilities with layout control through boxes (horizontal, vertical, hybrid) and symbolic output buffering, supporting structured formatting of basic types (integers, floats, booleans) and custom data (geometric primitives, lists, options). It manages formatter state with explicit control over indentation, margins, and tabulation, enabling dynamic layout adjustments for complex output scenarios like code generation or document formatting. Use cases include domain-specific pretty-printers, interactive shell output, and applications requiring precise textual representation of hierarchical data.",
      "description_length": 651,
      "index": 30,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Tools.String",
      "library": "archetype",
      "description": "This module combines text processing operations\u2014such as functional transformations (`map`, `fold_left`), case manipulation (`capitalize_ascii`, `lowercase_ascii`), and substring searches (`index_opt`, `starts`)\u2014with low-level binary parsing capabilities for UTF-8/UTF-16 validation and endianness-aware integer extraction (`get_int32_be`, `get_int64_le`). It operates on `string` values treated as both character sequences and byte arrays, enabling use cases like decoding binary protocols, normalizing textual data, and generating hash keys compatible with OCaml's `Hashtbl`. Specific utilities for trimming whitespace, escaping characters, and validating UTF encodings further support system-level programming and data transformation pipelines.",
      "description_length": 746,
      "index": 31,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Tools.Sstr",
      "library": "archetype",
      "description": "This module provides set-like operations (insertion, union, intersection) and sequence manipulation functions (mapping, folding, filtering) for a string-like structure that enforces element uniqueness. It supports bidirectional conversion between sequences and sets, reversed traversal, and combined aggregation of multiple structures, with optional return values to handle failure cases. The design enables efficient text processing workflows where ordered traversal, uniqueness constraints, or hybrid set-sequence transformations are required, such as token deduplication or structured string aggregation.",
      "description_length": 607,
      "index": 32,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Michelson_parser.MenhirInterpreter",
      "library": "archetype",
      "description": "This module offers low-level parsing and interpreter control for a Menhir-based parser, handling tokens, checkpoints, and parser states. It supports inspecting and manipulating grammar symbols (terminals and nonterminals), productions, and environments, with utilities for feeding input, analyzing grammar properties (e.g., `nullable`, `first`), and managing control flow via operations like `force_reduction` or `pop`. It is used for parsing Michelson syntax elements (identifiers, structured nodes), error recovery, and implementing custom parsing strategies through state manipulation and symbol inspection.",
      "description_length": 610,
      "index": 33,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Ast.Utils",
      "library": "archetype",
      "description": "This module provides functions to query and manipulate elements of an abstract syntax tree (AST), including retrieving assets, fields, variables, and their types. It works with data types such as `ast`, `lident`, `pterm`, and `type_`, enabling precise inspection of program structure. Use cases include static analysis, code generation, and semantic validation within a compiler or linter pipeline.",
      "description_length": 398,
      "index": 34,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Tools.List",
      "library": "archetype",
      "description": "This module provides functions for structural list manipulations, element-wise transformations, and key-value pair operations on standard OCaml lists. It supports tasks like indexed processing, predicate-based filtering, efficient sorting, and managing association lists with physical equality checks, while offering tail-recursive folds, sequence conversions, and list partitioning for complex data workflows. Key use cases include data processing pipelines, handling heterogeneous list elements, and optimizing traversal with indexed or stateful operations.",
      "description_length": 559,
      "index": 35,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Gen_decompile.Decomp_dir",
      "library": "archetype",
      "description": "Decompiles Michelson code into a higher-level representation using a provided environment, returning the updated environment and the decompiled code. Operates on Michelson contracts and environment state, transforming low-level instructions into structured data. Useful for analyzing or translating Michelson bytecode back into a readable contract format.",
      "description_length": 355,
      "index": 36,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Mtyping.Stack",
      "library": "archetype",
      "description": "This module provides operations to manipulate stack structures by popping elements, splitting stacks, and merging optional stacks. It works with the `stack` and `stack1` types, which represent typed stacks and individual stack elements, respectively. Concrete use cases include managing evaluation contexts in interpreters, handling nested expressions, and implementing type-checking routines that require precise stack manipulation.",
      "description_length": 433,
      "index": 37,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Tools.Sint",
      "library": "archetype",
      "description": "This module provides integer set manipulation through operations like union, intersection, difference, and element filtering, alongside transformations such as mapping and folding. It operates on integer sets (`Sint.t`) and sequences (`Seq.t`), enabling conversions between these structures and supporting iterative processing with guarantees of uniqueness. It is suited for tasks requiring precise set algebra, sequence-driven data aggregation, or validation of set properties like subset relationships and equality.",
      "description_length": 517,
      "index": 38,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Tools.Set",
      "library": "archetype",
      "description": "This module implements set-theoretic operations such as union, intersection, and difference, along with element insertion, removal, and membership checks over an immutable set type `t` with elements of type `elt`. It supports transformations including mapping, filtering, and folding, and allows conversion between sets, lists, and ordered sequences. It is ideal for managing collections of unique values in pure functional workflows, such as tracking unique identifiers, performing efficient lookups, or composing data transformations with guaranteed uniqueness and order preservation.",
      "description_length": 586,
      "index": 39,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Ident.Sid",
      "library": "archetype",
      "description": "This module offers a set-like structure for managing unique string collections, supporting operations like union, intersection, difference, and element manipulation (addition, removal, membership checks). It works with abstract sets of type `t` containing `elt` elements, enabling transformations via mapping, filtering, and folding, as well as sequence-based construction and iteration. Use cases include managing identifier collections, enforcing uniqueness constraints, and performing efficient set algebra on string data.",
      "description_length": 525,
      "index": 40,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Typing.Type",
      "library": "archetype",
      "description": "This module provides type analysis and transformation operations for Michelson-based smart contract validation, focusing on type inspection, decomposition, and manipulation. It works with Michelson type representations (`A.ptyp`) to identify structural properties (e.g., containers like maps/lists, tuples, options), perform type unification with equality or compatibility constraints, and compute type signatures or distances. Specific use cases include validating type correctness in contract expressions, constructing composite types like tuples, substituting type variables during inference, and analyzing type hierarchies for lambda or public key types.",
      "description_length": 658,
      "index": 41,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Mtyping.Env",
      "library": "archetype",
      "description": "This module provides functions to construct and manage a typing environment for contract analysis, specifically including the `create` function to initialize the environment from Michelson code. It works with the `t` type, representing the typing context, and supports operations to extract contract-specific types and code structure through its `Contract` submodule. It is used in type checking and code generation during contract compilation or static analysis.",
      "description_length": 463,
      "index": 42,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Typing.Env",
      "library": "archetype",
      "description": "This module facilitates identifier management during type checking by enabling lookups, scoped insertions, and resolution of type associations for variables, functions, state variables, records, and events. It organizes declarations within a structured environment to support semantic analysis, name resolution, and consistency validation across program constructs using hierarchical identifiers and full-name tracking.",
      "description_length": 419,
      "index": 43,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Archetype.Tools.Option",
      "library": "archetype",
      "description": "This module offers operations for safely manipulating, transforming, and comparing optional values, including predicates for inspection, mapping and binding for chaining computations, and folding for accumulation. It primarily works with OCaml's `option` type, supporting nested options, optional pairs, and conversions to and from lists. Specific use cases include handling missing data with default values, composing sequences of optional computations, and comparing or flattening hierarchical optional structures.",
      "description_length": 516,
      "index": 44,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Archetype.Parser.MenhirInterpreter",
      "library": "archetype",
      "description": "This module provides low-level parsing operations for incremental token processing and error recovery in a Menhir-based parser, working with tokens, parser environments, checkpoints, and stacks. It supports manipulation of parser states and grammar symbols (terminals and nonterminals), enabling tasks like state introspection, production analysis, and custom parsing strategies. Specific use cases include parsing Archetype DSL code, inspecting grammar properties such as nullability, and implementing recovery mechanisms through environment modifications and symbol feeding.",
      "description_length": 576,
      "index": 45,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Tools.Map",
      "library": "archetype",
      "description": "This module implements a polymorphic map with ordered keys, supporting insertion, deletion, merging, and ordered traversal. It provides safe lookup variants (`_opt`), key-based aggregations, and operations like filtering, partitioning, and folding over maps with keys of type `S.t` and arbitrary values. It is used for maintaining sorted key-value associations, grouping elements by keys, and performing key-directed updates or merges.",
      "description_length": 435,
      "index": 46,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.PureLexer.Lexer",
      "library": "archetype",
      "description": "This module implements a lexer for parsing tokens from a `Lexing.lexbuf` input buffer. It provides operations to initialize the lexer state, advance to the next token, retrieve the current token, and skip input until a specific token condition is met. The lexer tracks positions using `Archetype.Position.t` and processes tokens defined in `Archetype.PureLexer.ptoken`.",
      "description_length": 369,
      "index": 47,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Tools.Mint",
      "library": "archetype",
      "description": "This module offers a map-like structure with integer keys, supporting operations to manipulate key-value pairs through additions, deletions, updates, and queries, along with specialized functions like merging maps with custom logic and appending values to list-valued entries. It emphasizes ordered traversal and transformation via folds, filters, and mappings over the map\u2019s key sequence, while also enabling bulk updates from lists or sequences. Use cases include managing hierarchical data with integer identifiers, aggregating values into lists, and combining maps with prioritized or merged values.",
      "description_length": 603,
      "index": 48,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Model.Utils",
      "library": "archetype",
      "description": "This module supports introspection and manipulation of domain-specific modeling elements by extracting components like variables, enums, and assets, while analyzing structural properties such as key positions, field constraints, and storage mappings. It operates on identifiers, terms, and storage definitions to enable tasks like asset validation, rational number construction, and API storage management through targeted queries and transformations. Use cases include model analysis for type constraints, asset metadata extraction, and structural refactoring in domain-driven design contexts.",
      "description_length": 594,
      "index": 49,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Ident.Mid",
      "library": "archetype",
      "description": "This module supports operations for ordered maps with string keys and polymorphic values, implemented as a balanced tree structure. It enables standard map manipulations like insertion, lookup, and aggregation, while maintaining key ordering through functions such as `find_first_opt`, `fold`, and `partition`, alongside utilities for converting maps to ordered sequences or lists. It is particularly useful for scenarios requiring sorted data traversal, key-based grouping, or functional transformations with ordered key-value pairs.",
      "description_length": 534,
      "index": 50,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Symbol",
      "library": "archetype",
      "description": "Converts parser tokens, symbols, and production items into human-readable strings for debugging and logging. Works with token and symbol types from the Menhir parser generator used in the Archetype project. Useful for tracing parsing steps or inspecting grammar rules during development.",
      "description_length": 287,
      "index": 51,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Micheline_printer",
      "library": "archetype",
      "description": "This module provides functions to format and print Micheline nodes with comments and annotations, handling structured data like expressions and annotations in a TeX-like syntax. It includes utilities for transforming and rendering canonical Micheline structures into human-readable strings, supporting pretty-printing of smart contract code. Concrete use cases include generating readable output for Michelson contract expressions and debugging Micheline ASTs with location-based comments.",
      "description_length": 489,
      "index": 52,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.ParseError",
      "library": "archetype",
      "description": "This module handles parsing errors by analyzing the parser's state to generate contextual error messages. It works with parser checkpoints, syntax symbols, and lexical tokens to identify incomplete productions and relevant non-terminals at the point of failure. Concrete use cases include recovering from syntax errors in configuration files, providing actionable feedback during language parsing, and improving error diagnostics in domain-specific language interpreters.",
      "description_length": 471,
      "index": 53,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Io",
      "library": "archetype",
      "description": "Handles lexical analysis and error reporting for parsing, including bracket balancing and error recovery. Works with lex buffers, parser checkpoints, and custom error types enriched with location information. Used to parse Archetype source files or strings into abstract syntax trees and expressions, with strict and lenient modes.",
      "description_length": 331,
      "index": 54,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Error",
      "library": "archetype",
      "description": "This module manages error and warning handling during code processing, supporting operations to trigger errors or warnings with positional information and customizable responses. It works with lists of position objects paired with messages, using references to track error and warning logs. Concrete use cases include reporting syntax issues at specific source locations, handling recoverable errors during parsing, and generating formatted error messages for user feedback.",
      "description_length": 474,
      "index": 55,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Gen_model",
      "library": "archetype",
      "description": "This module handles error reporting and environment management during model generation. It defines error types for invalid operations like failed type conversions or missing asset definitions, and provides functions to format and emit errors. It also includes utilities for transforming identifiers and constructing environments used in model generation from parsed ASTs.",
      "description_length": 371,
      "index": 56,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Michelson",
      "library": "archetype",
      "description": "This module provides serialization, pretty-printing, and construction operations for Michelson abstract syntax trees and intermediate representations, targeting Tezos smart contract development. It works with data structures like Michelson primitives, typed expressions, instructions, contract views, and annotations, enabling tasks such as debugging, code generation, and type manipulation. Specific use cases include converting Michelson components to JSON for interoperability, building domain-specific smart contract logic, and normalizing or optimizing Michelson code during compilation.",
      "description_length": 592,
      "index": 57,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Mtools",
      "library": "archetype",
      "description": "Converts parsed expressions or string literals into typed intermediate representation terms. Works with `P.expr` and string inputs, producing `M.mterm` values. Useful for transforming raw syntax into semantically meaningful structures during compilation or analysis phases.",
      "description_length": 273,
      "index": 58,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Printer_tools",
      "library": "archetype",
      "description": "This module offers low-level formatting and pretty-printing tools for identifiers, lists, optional values, and structured data, leveraging formatters and types like `lident` and `mident` to manage separation, enclosure, and conditional layout. It includes combinators to structure expression rendering\u2014handling precedence, associativity, and optional elements\u2014while supporting code generation and AST printing through precise control of output formatting with parentheses, infix notation, and dynamic content insertion.",
      "description_length": 519,
      "index": 59,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Ufind",
      "library": "archetype",
      "description": "This module implements a union-find (disjoint-set) data structure with support for merging sets and tracking equivalence classes. It works with abstract item and data types, allowing elements to be grouped and queried efficiently with path compression and union by rank. Concrete use cases include solving connectivity problems, managing type variable unification in compilers, and tracking connected components in graphs.",
      "description_length": 422,
      "index": 60,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Printer_pt",
      "library": "archetype",
      "description": "This module focuses on pretty-printing and converting abstract syntax tree (AST) elements from the Archetype language into human-readable strings, with specialized handling for operators, expressions, and smart contract components. It manages operator precedence and associativity rules to ensure correct parenthesization during formatting, working with data structures like identifiers, expressions, records, and contract invariants derived from the `ParseTree` module. Its utilities are used for code generation, debugging, and producing structured textual representations of parsed Archetype programs.",
      "description_length": 604,
      "index": 61,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Mtyping",
      "library": "archetype",
      "description": "This module provides type-checking and stack manipulation utilities for validating smart contracts on the Tezos blockchain, focusing on Michelson-inspired semantics. It operates on structured stacks and environments, supporting arithmetic, logical, cryptographic, and control-flow operations (e.g., `ADD`, `BLAKE2B`, `DIP`, `IF`), as well as contract interaction and data-structure manipulations (e.g., `CONTRACT`, `MAP`, `PAIR`). Key use cases include ensuring type safety during contract execution, handling Tezos-specific primitives like `TRANSFER_TOKENS`, and transforming stack states through typed intermediate representations for domain-specific smart contract logic.",
      "description_length": 674,
      "index": 62,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Gen_api_storage",
      "library": "archetype",
      "description": "This module defines an error description type and formatting functions for pretty-printing and converting errors to strings. It works with the `error_desc` variant type and integrates with formatting and string conversion utilities. Its main use case is to handle and display errors during API storage generation, particularly in the `generate_api_storage` function which transforms a model into an API storage representation with optional verification.",
      "description_length": 453,
      "index": 63,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Archetype.Tools",
      "library": "archetype",
      "description": "This module offers functional programming utilities for composable data transformations and safe value manipulations on basic types like booleans, strings, and optional values, alongside complex structures such as lists, maps, sets, and trees. It emphasizes operations like insertion, traversal, aggregation, and uniqueness enforcement, supporting use cases in text processing, structural data transformation, and system-level interfacing tasks like JSON minification and integer parsing.",
      "description_length": 488,
      "index": 64,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Archetype.UF",
      "library": "archetype",
      "description": "Implements union-find operations for managing disjoint sets of integers, supporting creation, union, find, and duplication. Works directly with integer elements to track equivalence classes and dynamic connectivity. Enables algorithms like Kruskal's MST and percolation where set membership and merging are critical.",
      "description_length": 316,
      "index": 65,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.PureLexer",
      "library": "archetype",
      "description": "This module implements a lexer for parsing tokens from a `Lexing.lexbuf` input buffer. It provides operations to initialize the lexer state, advance to the next token, retrieve the current token, and skip input until a specific token condition is met. The lexer works with `ptoken` values, which include a Menhir token and start/end positions, and is used to tokenize input for parsing Archetype smart contract code.",
      "description_length": 416,
      "index": 66,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Lexer",
      "library": "archetype",
      "description": "This module handles lexical analysis for a parser, converting raw character streams into structured tokens. It processes input using lexing tables, identifies keywords, and manages string literals, comments, and errors. Concrete use cases include parsing source code, handling nested comments, and emitting syntax errors with location information.",
      "description_length": 347,
      "index": 67,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Archetype.Lsp",
      "library": "archetype",
      "description": "This component handles serialization, conversion, and construction of LSP-compatible data structures for diagnostic reporting and code navigation. It operates on types like positions, ranges, outline items, and symbols derived from AST nodes and location data, providing JSON encoding/decoding and human-readable formatting. Its utilities are used to generate language server responses for features like error diagnostics, document outlines, and symbol hierarchies.",
      "description_length": 465,
      "index": 68,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Archetype.Gen_extra",
      "library": "archetype",
      "description": "This module offers error handling, JSON/Micheline serialization, and data manipulation capabilities for Archetype expressions and contract data structures. It operates on custom types like `eargs`, `entries`, and `storage_values`, enabling tasks such as error reporting, metadata generation, and code transformation in contract models. Key use cases include serializing contract state, extracting Micheline expressions, and formatting structured data for development tools.",
      "description_length": 473,
      "index": 69,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Printer_ast",
      "library": "archetype",
      "description": "This component provides functions to convert abstract syntax tree (AST) elements like identifiers, expressions, types, and program structures into formatted string representations. It operates on data structures such as logical/arithmetic operators, records, enums, and metadata, using OCaml's formatting utilities to handle indentation, parentheses, and source location annotations. The output is primarily used for debugging compiler transformations or generating human-readable code from ASTs.",
      "description_length": 496,
      "index": 70,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.ParseTree",
      "library": "archetype",
      "description": "This module supports JSON encoding and decoding for a wide range of abstract syntax tree (AST) components\u2014such as expressions, declarations, types, operators, and scopes\u2014using `Yojson.Safe.t` with robust error handling. It also provides formatting utilities to generate human-readable representations of these structures, aiding in debugging and logging. Additionally, it includes constructors for building and manipulating AST nodes, including typed expressions, declarations, and composite types, often incorporating source location metadata for use during parsing or transformation tasks.",
      "description_length": 591,
      "index": 71,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Archetype.Binding",
      "library": "archetype",
      "description": "This module handles type representation and event processing for model records. It provides operations to convert type definitions to formatted output, compute Michelson types from models, and construct input events with typed records. Use cases include generating type annotations and handling event data in a model-driven context.",
      "description_length": 332,
      "index": 72,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Gen_decompile",
      "library": "archetype",
      "description": "This module decompiles Michelson bytecode into higher-level Archetype representations, transforming low-level instructions into structured data using environment state. It operates on Michelson contracts, typed data, and identifiers, producing readable contract formats or models. Concrete use cases include translating Michelson back into Archetype source code and converting typed programs into analyzable models.",
      "description_length": 415,
      "index": 73,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Archetype.Gen_transform",
      "library": "archetype",
      "description": "The module provides syntactic and semantic transformations, validation, and optimization functions for Archetype models. It operates on string-keyed maps and sets alongside the model's abstract syntax tree, handling tasks like constraint enforcement, expression simplification, and structural refactoring to prepare models for code generation or further analysis. Key operations include processing containers, normalizing expressions, eliminating redundancies, and transforming high-level constructs into optimized intermediate representations.",
      "description_length": 544,
      "index": 74,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Ast",
      "library": "archetype",
      "description": "This module provides types and utilities for constructing and manipulating abstract syntax trees in a domain-specific language for smart contracts, focusing on identifiers, type expressions, operators, and control flow structures. It works with structured data types like `ptyp`, `pterm`, `instruction`, `function_`, `transition`, and `asset`, alongside enumerations and containers such as maps and bigmaps, to model smart contract logic and metadata. The module supports parsing, semantic validation, static analysis, and code generation through pretty-printing, string conversion, and AST transformation functions that track location and side-effect information for debugging and serialization.",
      "description_length": 696,
      "index": 75,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Ident",
      "library": "archetype",
      "description": "This module defines a type alias `ident` for strings, along with functions for JSON serialization and comparison. It includes formatters and converters for string-based identifiers, supporting direct manipulation and structured output. The associated modules `Mid` and `Sid` provide ordered maps and sets for string keys, enabling precise data organization and efficient lookups in contexts like symbol tables or identifier tracking.",
      "description_length": 433,
      "index": 76,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Model",
      "library": "archetype",
      "description": "The module provides operations for constructing, transforming, and pretty-printing domain-specific data structures used in smart contract modeling, including identifiers with location tracking, composite types (e.g., maps, enums, records), and abstract syntax tree (AST) nodes for terms and declarations. It handles structured representations of smart contract elements like storage items, cryptographic primitives, and Michelson terms, supporting type annotations, metadata, and error conditions. These utilities are used for debugging, compiler tooling, and manipulating ASTs during smart contract analysis, refactoring, or code generation tasks.",
      "description_length": 648,
      "index": 77,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Gen_debug_trace",
      "library": "archetype",
      "description": "This module facilitates debug tracing and code generation by serializing and formatting Micheline AST nodes, source code positions, and execution context metadata. It operates on structured representations of smart contract components like entrypoints, storage items, and type information to enable precise debugging output and Michelson code emission. Key use cases include generating human-readable traces during contract interpretation and converting abstract syntax trees to JSON for external analysis tools.",
      "description_length": 512,
      "index": 78,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Archetype.Printer_michelson",
      "library": "archetype",
      "description": "This module provides functions to format Michelson language components\u2014such as types, instructions, and data structures\u2014alongside JavaScript primitives, expressions, and programs into human-readable text. It operates on Michelson abstract syntax",
      "description_length": 245,
      "index": 79,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Micheline",
      "library": "archetype",
      "description": "This module processes Micheline-like abstract syntax trees with annotated nodes, supporting operations to manipulate node locations, extract and inject annotations, and transform node structures. It works with recursive data structures representing canonical forms of nodes, annotations as string lists, and location mappings. Concrete use cases include parsing and transforming Michelson-based smart contract code, handling source code annotations, and managing node metadata during compilation or analysis.",
      "description_length": 508,
      "index": 80,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Typing",
      "library": "archetype",
      "description": "This module provides type-checking, normalization, and semantic analysis for domain-specific language constructs, focusing on Michelson smart contract validation. It operates on abstract syntax trees, typed declarations (variables, functions, assets, records), environments, and operator metadata to enforce static typing, resolve identifiers, and validate contract-specific features like entrypoints and state transitions. Key use cases include Michelson interface extraction, declaration processing, and transformation of untyped ASTs into typed representations with error reporting for contract analysis.",
      "description_length": 607,
      "index": 81,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Archetype.Printer_model_tools",
      "library": "archetype",
      "description": "This module defines error types for unsupported terms and values, along with functions to format and raise these errors. It provides an environment type (`env`) that holds model components like function nodes, predicates, and constants, with utilities to construct, compare, and inspect this environment. Key operations include `compute_env` to build an environment from a model, `is_const` and `get_const_dv` to check and retrieve constant values, and `get_preds_index` to locate predicates within lists.",
      "description_length": 505,
      "index": 82,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Pt_helper",
      "library": "archetype",
      "description": "Validates the structure of a JSON input against an archetype definition, ensuring correctness for further processing. Works directly with the `archetype` type from the `ParseTree` module to enforce schema constraints. Useful in scenarios where JSON data must conform to a predefined structure before being passed to downstream systems.",
      "description_length": 335,
      "index": 83,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Micheline_tools",
      "library": "archetype",
      "description": "This module constructs and converts Micheline nodes used in Tezos smart contract representations. It provides functions to create Micheline literals (strings, integers, bytes) and structured nodes (primitives, sequences), along with annotations and locations. These operations support direct manipulation of Micheline ASTs for contract compilation or transformation tasks.",
      "description_length": 372,
      "index": 84,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Opt_model",
      "library": "archetype",
      "description": "This module defines a recursive type for representing model entries, supporting operations like union and entry construction, paired with pretty-printing and serialization functions. It provides utilities to transform and optimize models by manipulating declarations, removing redundant operations, and simplifying expressions. Concrete use cases include model restructuring during decompilation and optimizing intermediate representations of Archetype programs.",
      "description_length": 462,
      "index": 85,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Location",
      "library": "archetype",
      "description": "This module handles source code position tracking and transformation through operations like merging ranges, converting to JSON, and extracting buffer positions. It centers on a record type capturing file paths, offsets, and spans paired with a generic wrapper to associate values with their source locations. Common applications include preserving origin metadata during code transformations, generating placeholder locations for synthetic constructs, and normalizing positional data from lexers.",
      "description_length": 497,
      "index": 86,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Archetype.Compile",
      "library": "archetype",
      "description": "The module provides compilation, decompilation, and transformation capabilities for smart contract models and Michelson code. It operates on structured data types like `ParseTree.archetype`, `Model.model`, and `Michelson.ir`, alongside string-based and JSON-serializable inputs, to enable tasks such as type-checking, error diagnostics, and intermediate representation generation. Key workflows include parsing Archetype source code, validating contract logic, and producing executable Michelson output for blockchain deployment.",
      "description_length": 529,
      "index": 87,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Gen_storage",
      "library": "archetype",
      "description": "Handles storage initialization and error reporting for model structures. It defines error descriptions for missing initialization expressions and provides functions to generate storage models, emit errors, and format error messages. Used during model processing to ensure proper storage initialization and report issues when required fields lack initial values.",
      "description_length": 361,
      "index": 88,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Core",
      "library": "archetype",
      "description": "This module enables precise date and time arithmetic with timezone-aware operations, big integer manipulations for exact numerical calculations, and robust validation of strings, identifiers, and file paths. It operates on structured types like dates, time",
      "description_length": 256,
      "index": 89,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Parser",
      "library": "archetype",
      "description": "This module defines a comprehensive set of lexical tokens representing keywords, literals, and symbols used in the Archetype DSL, along with functions for parsing Archetype source code into abstract syntax trees. It includes parsers for expressions and top-level structures, supporting precise lexing and error recovery. Concrete use cases include parsing smart contract definitions, processing expressions with complex type literals, and handling structured data like Michelson code, timestamps, and cryptographic primitives.",
      "description_length": 526,
      "index": 90,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Printer_model",
      "library": "archetype",
      "description": "This component provides pretty-printing functions that convert data types and model elements\u2014including variables, enums, assets, records, and storage definitions\u2014into human-readable strings. It leverages OCaml's `Format.formatter` to produce structured output, following a uniform pattern where each function accepts a formatter and a value to render. These utilities are designed for use cases like logging, debugging, and generating user-facing representations of complex API constructs or metadata.",
      "description_length": 501,
      "index": 91,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Michelson_parser",
      "library": "archetype",
      "description": "This module tokenizes and parses Michelson smart contract code into structured Micheline objects, supporting concrete syntax elements like identifiers, numbers, annotations, and structured literals. It processes input via a lexer and incremental parsing interface, enabling streaming or partial parsing of Michelson expressions during contract compilation. Use cases include parsing Michelson expressions embedded in Archetype contracts and handling structured literals like lists and pairs during typechecking.",
      "description_length": 511,
      "index": 92,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Position",
      "library": "archetype",
      "description": "This module manipulates and decorates arbitrary values with source code positional metadata, primarily through `Archetype.Position.t` and `Stdlib.Lexing.position` types. It supports operations like joining ranges, extracting line/column offsets, formatting positions as strings, and handling optional position data. These capabilities are used to track parsing/lexing locations, report diagnostic errors with precise source spans, and merge positional context when combining tokens or abstract syntax tree nodes.",
      "description_length": 512,
      "index": 93,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Gen_contract_interface",
      "library": "archetype",
      "description": "This module provides data modeling and serialization operations for Michelson-based smart contract interfaces, focusing on converting between OCaml representations and structured formats like JSON and TeX-like syntax. It works with Michelson type and term structures, including contract parameters, storage declarations, entrypoints, enums, events, and errors, while supporting transformations between Archetype's internal type system and Michelson's representations. Key use cases include generating contract interface declarations, decompiling Michelson code into JSON, and facilitating tooling for Tezos blockchain contract development through structured data interchange and pretty-printing.",
      "description_length": 695,
      "index": 94,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Michelson_lexer",
      "library": "archetype",
      "description": "This module handles lexical analysis of Michelson code, converting raw character streams into structured tokens for parsing. It processes input using lexing functions that identify keywords, comments, strings, and other syntactic elements according to Michelson's grammar. Concrete use cases include reading and preprocessing Michelson smart contract files, supporting tools like linters or compilers that require accurate tokenization of Michelson source code.",
      "description_length": 461,
      "index": 95,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype",
      "library": "archetype",
      "description": "This module provides language processing operations for a Tezos-targeted DSL, focusing on abstract syntax tree manipulation, lexical analysis, and Michelson code generation. It operates on structured data like ASTs, Micheline nodes, and type-checked models, employing parser combinators and formatter-based pretty-printing. Key use cases include smart contract compilation, semantic analysis for domain-specific languages, and tooling for contract lifecycle management through JSON schema validation and debug trace generation.",
      "description_length": 527,
      "index": 96,
      "embedding_norm": 0.9999999403953552
    }
  ],
  "filtering": {
    "total_modules_in_package": 112,
    "meaningful_modules": 97,
    "filtered_empty_modules": 15,
    "retention_rate": 0.8660714285714286
  },
  "statistics": {
    "max_description_length": 746,
    "min_description_length": 245,
    "avg_description_length": 471.3814432989691,
    "embedding_file_size_mb": 1.4061651229858398
  }
}