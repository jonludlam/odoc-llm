{
  "package": "archetype",
  "embedding_model": "Qwen/Qwen3-Embedding-0.6B",
  "embedding_dimension": 1024,
  "total_modules": 99,
  "creation_timestamp": "2025-07-15T23:21:32.220480",
  "modules": [
    {
      "module_path": "Archetype.Typing.Env.Label",
      "library": "archetype",
      "description": "This module manages label bindings in a typing environment, providing operations to look up, retrieve, check existence, and add labels associated with identifiers. It works with typing environments and label kinds, specifically handling identifier-label associations. Concrete use cases include tracking field labels in record types or parameter labels during function type checking.",
      "description_length": 383,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Typing.Env.Type",
      "library": "archetype",
      "description": "This module provides operations for managing and querying type bindings in a typing environment. It supports looking up types by long identifiers, checking existence of bindings, retrieving types by full name, and adding new bindings. The module works with environments (`Archetype.Typing.Env.t`), type representations (`A.ptyp`), and identifier types (`A.lident`, `Archetype.Typing.longident`, `Archetype.Typing.fullname`). Use cases include resolving type references during type checking and maintaining type scope in a module system.",
      "description_length": 536,
      "index": 1,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Archetype.Typing.Env.Import",
      "library": "archetype",
      "description": "This module manages import declarations within a typing environment, providing operations to look up, retrieve, and store imports by identifier. It works with environments, import declarations, and a cache mapping string keys to imports. Concrete use cases include resolving imported identifiers during type checking and managing cached import results to avoid redundant computations.",
      "description_length": 384,
      "index": 2,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Archetype.Typing.Env.Record",
      "library": "archetype",
      "description": "This module manages record environments in a type-checking context. It supports operations to look up, insert, and check the existence of record declarations using both long identifiers and fully qualified names. Key use cases include resolving record types during type inference and checking field validity within record expressions.",
      "description_length": 334,
      "index": 3,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Archetype.Typing.Env.State",
      "library": "archetype",
      "description": "This module manages state information within a typing environment, providing operations to query, retrieve, and extend the environment with new state entries. It works with identifiers and state declarations, supporting lookups by both long identifiers and fully qualified names. Concrete use cases include tracking declared types and values during type checking, and resolving identifier references in expressions.",
      "description_length": 415,
      "index": 4,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Archetype.Typing.Env.Context",
      "library": "archetype",
      "description": "This module manages identifier binding and lookup within a typing environment. It provides operations to retrieve the current environment context and to extend it with new local identifiers. Used during type checking to track variable scopes and ensure correct type resolution in expressions and declarations.",
      "description_length": 309,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Typing.Env.Function",
      "library": "archetype",
      "description": "This module manages function declarations within a typing environment, providing operations to add, retrieve, and check the existence of functions using either long identifiers or full names. It works with the `Archetype.Typing.Env.t` environment type and `Archetype.Typing.fundecl` function declarations. Concrete use cases include resolving function references during type checking and maintaining function visibility in nested scopes.",
      "description_length": 437,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Typing.Env.Tentry",
      "library": "archetype",
      "description": "This module manages typed environment entries in a symbolic table structure. It supports operations to look up, insert, and check the existence of type declarations using qualified identifiers. Key functions include `lookup`, `exists`, `get`, `mem`, and `push`, which facilitate type resolution and management in a scoped environment.",
      "description_length": 334,
      "index": 7,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Archetype.Tools.List.Exn",
      "library": "archetype",
      "description": "This module provides operations for searching and mapping values in lists of key-value pairs. It includes functions to find the first matching element in a list, retrieve a value associated with a key, and map a key through a list of pairs to find a corresponding value. These functions handle optional results, returning `None` when no match is found. Use cases include configuration lookups, data filtering, and transforming identifiers into associated values.",
      "description_length": 462,
      "index": 8,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Archetype.Typing.Env.Local",
      "library": "archetype",
      "description": "This module manages local variable bindings in a typing environment, supporting operations to look up, add, and check variables. It works with identifiers, polymorphic types, and local variable kinds within a structured environment. Concrete use cases include tracking variable declarations and their types during type checking in a compiler or interpreter.",
      "description_length": 357,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Typing.Type.Michelson",
      "library": "archetype",
      "description": "This module provides predicates to check type properties in a Michelson-like type system, such as whether a type is comparable, passable, storable, or packable. It operates on type representations defined by the `A.ptyp` data type. These checks are used during type validation and contract analysis to enforce Michelson's type constraints.",
      "description_length": 339,
      "index": 10,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Tools.Set.Make",
      "library": "archetype",
      "description": "This module implements a functional set abstraction with operations for union, intersection, difference, and element manipulation, alongside utilities to query cardinality, extract extrema, or convert between sets and sequences. It operates on immutable set values (`t`) containing elements of a comparable type (`elt`), supporting transformations via higher-order functions like map, fold, and filter. Typical applications include managing unique element collections, composing set operations over sequences, and safely handling empty-set edge cases through optional returns.",
      "description_length": 576,
      "index": 11,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Archetype.Mtyping.Env.Contract",
      "library": "archetype",
      "description": "This module provides functions to retrieve the parameter type, storage type, and code structure from a contract typing environment. It operates on the `Archetype.Mtyping.Env.t` data type, extracting specific components of a smart contract's definition. These functions are used during type checking and code generation to access key elements of a contract's interface and implementation.",
      "description_length": 387,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Typing.Env.FunctionProperties",
      "library": "archetype",
      "description": "This module manages properties of functions within a typing environment, specifically tracking whether functions have side effects, use storage, or return values. It provides operations to both query and update these properties, returning modified environments where applicable. Use cases include analyzing function behavior during type checking to enforce correctness constraints in smart contract execution.",
      "description_length": 409,
      "index": 13,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Archetype.Typing.Env.Event",
      "library": "archetype",
      "description": "This module manages event-related symbol lookups and registrations within a typing environment. It provides operations to retrieve, check existence, and add event records by identifier or field, working directly with event declarations and their associated fields. Concrete use cases include resolving event references during type checking and validating event structure definitions in smart contract code.",
      "description_length": 406,
      "index": 14,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Typing.Env.Var",
      "library": "archetype",
      "description": "This module manages variable declarations within a typing environment, providing operations to look up, check existence, retrieve, and add variables. It works with environments (`Archetype.Typing.Env.t`), variable declarations (`Archetype.Typing.vardecl`), and identifiers (`Archetype.Typing.longident`, `Archetype.Typing.fullname`). Concrete use cases include resolving variable references during type checking and maintaining variable scope in a compiler or interpreter.",
      "description_length": 472,
      "index": 15,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Typing.Env.Asset",
      "library": "archetype",
      "description": "This module manages asset-related information within a typing environment. It supports operations to look up, retrieve, check existence, and add assets by identifier or fully qualified name, as well as locate assets by field declaration. It works with asset declarations, field declarations, and environment structures to support type checking and symbol resolution during language processing.",
      "description_length": 393,
      "index": 16,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Mtyping.Ty",
      "library": "archetype",
      "description": "This module provides type validation and deconstruction operations for a typed stack structure, focusing on cryptographic primitives and domain-specific data forms. It works with `stack1` values to enforce constraints on integers, lists, pairs, BLS12-381 group elements, Sapling transactions, and ticket/contract types through functions like `check_signature` and `check_ticket`. These operations are critical for verifying correctness in Archetype smart contract pipelines, particularly for handling cryptographic signatures, token transfers, and contract interaction patterns.",
      "description_length": 578,
      "index": 17,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Parser.MenhirInterpreter",
      "library": "archetype",
      "description": "This module provides low-level parsing operations for incremental parsing and error recovery, enabling manipulation of parser checkpoints, environments, and stacks to control execution flow and inspect parser state. It operates on grammar symbols (terminals, nonterminals), productions, and LR(1) parser states, supporting tasks like stack modification, symbol analysis, and token feeding. These",
      "description_length": 395,
      "index": 18,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Tools.Sstr",
      "library": "archetype",
      "description": "This module provides set operations, collection traversal, and sequence conversion for string-based data structures. It works with a custom string set type (`t`) and sequences of characters, enabling tasks like managing unique string elements, converting between lists/sequences, filtering subsets, and processing strings in forward or reverse order. Specific use cases include set algebra (union, intersection), character-level transformations, and sequence-driven construction of string data.",
      "description_length": 494,
      "index": 19,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Mtyping.Env",
      "library": "archetype",
      "description": "This module manages typing environments for Michelson contracts during type checking, providing operations to create and manipulate contexts that track variable bindings and type constraints. It includes functions to extract key contract components such as parameter types, storage types, and code structures from the typing environment. The main data type is `Archetype.Mtyping.Env.t`, which represents the full typing state of a contract during analysis or transformation. Example uses include resolving variable types during code traversal and retrieving contract interface elements for type validation.",
      "description_length": 606,
      "index": 20,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Archetype.Gen_transform.SetString",
      "library": "archetype",
      "description": "This library offers a comprehensive set of operations for managing immutable string sets, including creation, union/intersection, membership checks, and transformations like filtering or mapping. It centers around a set-like type `t` optimized for string elements, supporting efficient queries for cardinality, extremal values, and subset relationships. Typical applications include deduplicating string collections, processing ordered sequences of unique strings, or integrating set-theoretic logic into data pipelines with conversions to lists and sequences.",
      "description_length": 560,
      "index": 21,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Archetype.Gen_decompile.Decomp_dir",
      "library": "archetype",
      "description": "Decompiles Michelson code into a higher-level representation using a transformation environment. It processes `T.michelson` values and produces `T.dcode` results, maintaining and updating the decompilation state. Useful for converting low-level Michelson back into a readable, structured format during contract analysis or reverse engineering.",
      "description_length": 343,
      "index": 22,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Model.Utils",
      "library": "archetype",
      "description": "This module provides introspection and transformation capabilities for model elements, focusing on structured extraction and analysis of variables, enums, assets, and storage constructs. It operates on identifiers, type definitions, and term expressions to enable tasks like field retrieval, key-value mapping, and container inspection, while supporting advanced operations such as rational number construction and storage property validation. Specific applications include asset structure analysis, API storage list management, and term evaluation workflows requiring type-aware comparisons or list sorting.",
      "description_length": 608,
      "index": 23,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Tools.List",
      "library": "archetype",
      "description": "This module provides powerful list manipulation capabilities, centered on functional transformations, filtering, and traversal, with support for working on generic lists, pairs, and sequences. It includes core operations like `map`, `filter`, `fold`, `nth_opt`, and `assoc_opt`, enabling safe and expressive data processing pipelines, indexed access, and key-based lookups. The associated submodule enhances handling of key-value pair lists, offering targeted search, mapping, and association functions that return optional results, ideal for configuration parsing and identifier resolution. Together, they support tasks like list deduplication, conditional filtering, indexed iteration, and safe value retrieval without exceptions.",
      "description_length": 732,
      "index": 24,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Gen_transform.MapString",
      "library": "archetype",
      "description": "This module provides associative map operations for string-keyed data structures, enabling insertion, deletion, transformation, and filtering of key-value pairs with arbitrary value types. It supports advanced manipulations like merging maps, resolving first-matching bindings, and converting between maps, sequences, and lists. Common applications include managing configuration data, processing dynamic key-value collections, and implementing algorithms requiring efficient string-indexed lookups or bulk transformations.",
      "description_length": 523,
      "index": 25,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Mtyping.Stack",
      "library": "archetype",
      "description": "This module provides operations to manipulate stack structures by popping elements, splitting stacks, and merging optional stacks. It works with the `stack` and `stack1` types, which represent structured data stacks used in type checking or evaluation contexts. Concrete use cases include managing evaluation frames in interpreters, handling type inference stacks, and implementing stack-based algorithms requiring precise element extraction and recombination.",
      "description_length": 460,
      "index": 26,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Ufind.S",
      "library": "archetype",
      "description": "Implements a union-find data structure with path compression and support for tracking associated data and effects. Operates on items and their equivalence classes, allowing lookups, unions, and data updates with priority control during merges. Useful for managing dynamic connectivity problems with side effects, such as type inference with constraints or merging disjoint sets in program analysis.",
      "description_length": 398,
      "index": 27,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Archetype.Typing.Micheline",
      "library": "archetype",
      "description": "This module provides functions to parse and navigate Micheline expressions, extract type information, and retrieve entrypoints and views from smart contract code. It operates on Micheline structures represented as `T.obj_micheline`, and supports concrete use cases such as analyzing Tezos smart contract types, extracting callable entrypoints, and inspecting storage definitions. Specific functions enable searching for named nodes, splitting expressions into key-value pairs, and converting Micheline values to typed representations.",
      "description_length": 534,
      "index": 28,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Archetype.Typing.Env",
      "library": "archetype",
      "description": "The environment type and its associated modules form a structured system for managing type-checking contexts in Archetype smart contract compilation. It supports scoped operations for variables, functions, records, assets, and events, enabling precise tracking of identifiers, type resolution, and consistency validation across contract components. Key data types include environments (`t`), identifiers (`lident`, `longident`, `fullname`), type representations (`ptyp`), and declarations for variables, functions, records, and assets. Operations allow creating and extending scopes, resolving names across modules and imports, validating types in expressions and function calls, and analyzing function properties such as side effects and storage usage.",
      "description_length": 753,
      "index": 29,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Gen_decompile.Decomp_model",
      "library": "archetype",
      "description": "This module defines a `decompile` function that transforms a typed Archetype program and environment into a model representation, working with data types like `T.dprogram`, `M.model`, and environment structures. It is used to convert low-level typed programs into higher-level models for analysis or visualization tasks.",
      "description_length": 320,
      "index": 30,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Archetype.Typing.Type",
      "library": "archetype",
      "description": "This module enables analysis and manipulation of Michelson-compatible type structures through direct operations like type decomposition, variable substitution, and unification. It works with parsed types (`A.ptyp`) and Michelson types, supporting tasks such as type inference and compatibility checking. A child module provides predicates to verify type properties like comparability and storability, which are essential for validating contract constraints. Together, they form a toolkit for implementing type systems that enforce Michelson's typing rules during compilation and analysis.",
      "description_length": 588,
      "index": 31,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.UF.UF",
      "library": "archetype",
      "description": "Implements a union-find data structure with support for creating disjoint sets, finding canonical representatives, merging sets, and duplicating the structure. Operates on integer elements, tracking equivalence classes through path compression and union-by-rank optimizations. Useful for managing dynamic connectivity in graph algorithms or partitioning problems.",
      "description_length": 363,
      "index": 32,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Archetype.Michelson.Utils",
      "library": "archetype",
      "description": "This module processes Michelson code and data structures, providing transformations like flattening, optimization, and macro replacement. It converts Michelson types, data, and code to Micheline format, and determines if a type is storable. It is used for manipulating and serializing Michelson constructs during contract compilation or analysis.",
      "description_length": 346,
      "index": 33,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Archetype.Ident.Sid",
      "library": "archetype",
      "description": "This module provides set operations such as union, intersection, and difference, alongside iteration, mapping, and filtering functions for handling collections of strings. It operates on a set-like structure that supports both functional and destructive modifications, enabling bulk updates from sequences and conversions to and from lists. It is designed for scenarios requiring efficient membership checks, data aggregation, or set-based computations.",
      "description_length": 453,
      "index": 34,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Ufind.Data",
      "library": "archetype",
      "description": "This module manages disjoint-set data structures with path compression, tracking union operations and their side effects. It provides `fresh` to create new set elements and `union` to merge sets, returning updated representatives along with accumulated effects. Use it for efficient equivalence class management in algorithms like Kruskal's or dynamic connectivity problems.",
      "description_length": 374,
      "index": 35,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Tools.Mint",
      "library": "archetype",
      "description": "This module implements an ordered map structure with integer keys, supporting operations like insertion, deletion, value lookup, and ordered traversal. It provides utilities for transforming and aggregating key-value pairs, including merging maps, filtering by key ranges, and grouping elements from association lists. Such functionality is ideal for managing sorted integer-indexed data, such as frequency counters, sparse arrays, or ordered symbol tables.",
      "description_length": 457,
      "index": 36,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Tools.Option",
      "library": "archetype",
      "description": "This module offers a suite of operations for optional values, including predicates, mapping, binding, and folding to facilitate safe manipulation and chaining with default values, iteration, and accumulation. It handles `option` types, nested options, and paired optional values, providing tools to flatten hierarchies, apply custom comparisons, and extract components for further processing.",
      "description_length": 392,
      "index": 37,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Gen_michelson.MapString",
      "library": "archetype",
      "description": "This module offers operations for managing maps with string keys and polymorphic values, supporting insertion, deletion, transformation, and aggregation through functions like `map`, `filter`, `fold`, and `collect`. It handles data structures such as lists, sequences, and key-value pairs, with utilities for safe and unsafe value access, merging, and ordered operations like min/max. Specific use cases include aggregating data by string keys, converting sequences to maps with optional value handling, and performing iterative or recursive transformations on polymorphic map values.",
      "description_length": 584,
      "index": 38,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Tools.Mstr",
      "library": "archetype",
      "description": "This module supports accumulation, transformation, and querying of associative collections with string keys and polymorphic values, offering operations like list-valued aggregation, map combination, and key-based filtering. It centers on a persistent map structure (`Mstr.t`) with string-indexed entries, enabling idioms such as iterative key-value updates, ordered traversal, and partitioning based on custom predicates. Typical applications include managing hierarchical configurations, processing string-keyed datasets with heterogeneous values, and building composite data structures through functional map fusion.",
      "description_length": 618,
      "index": 39,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Archetype.Michelson_parser.MenhirInterpreter",
      "library": "archetype",
      "description": "This module offers low-level parsing and interpreter operations for Michelson, enabling incremental parsing with error recovery, precise control over parser states and transitions, and grammar structure analysis. It manipulates tokens, lexing buffers, parser checkpoints, and LR(1) states, while exposing functions to inspect grammar properties like symbol relationships and production rules. These capabilities support use cases such as implementing custom parsing strategies, integrating Michelson into compilers or IDEs with robust error handling, and analyzing grammar behavior during development.",
      "description_length": 601,
      "index": 40,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Michelson_parser.Incremental",
      "library": "archetype",
      "description": "Parses Michelson code incrementally starting from a given position, producing a checkpointed Micheline object. Works with Lexing.position and Micheline structures, enabling step-by-step parsing with error handling. Useful for interactive tools that require partial parsing or error recovery during Michelson smart contract development.",
      "description_length": 335,
      "index": 41,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Ast.Utils",
      "library": "archetype",
      "description": "This module provides functions to query and manipulate elements of an abstract syntax tree (AST), including retrieving assets, fields, variables, and their types. It works directly with data structures like `ast`, `lident`, `pterm`, and `type_` to support precise static analysis and transformation tasks. Concrete use cases include extracting asset fields for validation, checking variable declarations, and resolving named field lists during compilation.",
      "description_length": 456,
      "index": 42,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Tools.Set",
      "library": "archetype",
      "description": "This module provides a functional interface for working with immutable sets of comparable elements, supporting standard operations like union, intersection, difference, and element insertion or removal. It offers data types `t` for sets and `elt` for their elements, along with functions to query size, extract minimum or maximum values, and transform sets using map, fold, and filter. You can use it to manage collections of unique values, compose complex set operations, or safely handle empty sets when extracting extrema or searching for elements.",
      "description_length": 551,
      "index": 43,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Ufind.Item",
      "library": "archetype",
      "description": "This module defines a type `t` representing items in a union-find data structure. It includes equality checking and comparison operations for managing and querying disjoint sets efficiently. These functions enable tracking equivalence classes and merging sets in algorithms like Kruskal's or dynamic connectivity problems.",
      "description_length": 322,
      "index": 44,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Tools.String",
      "library": "archetype",
      "description": "This module provides string manipulation operations including character-level transformations (e.g., mapping, case conversion), indexed searching, folding, and predicate checks over sequences of characters. It supports binary parsing tasks like UTF-8 validation, byte-order-aware integer extraction (e.g., `get_int16_le`), and sequence conversion, while also offering hashing utilities compatible with hash tables and helpers for prefix/suffix analysis and capitalization adjustments. The primary data types are strings, byte sequences, and integer representations, with applications in text processing, binary data interpretation, and encoding-safe string validation.",
      "description_length": 668,
      "index": 45,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Archetype.PureLexer.Lexer",
      "library": "archetype",
      "description": "This module implements a lexer for parsing tokens from a lexing buffer, providing operations to initialize the buffer, advance through tokens, retrieve the current token, and skip ahead based on token conditions. It works with lexbuf from the standard library and manages a custom token type along with positional information. It is used to feed a parser with structured tokens while tracking source positions during lexing.",
      "description_length": 424,
      "index": 46,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Ufind.Make",
      "library": "archetype",
      "description": "This module implements a union-find data structure with path compression and support for merging, tracking equivalence classes of items with associated data and effects. It provides operations to find canonical representatives, check equivalence, set or retrieve data for items, and merge item sets with priority control. Use it to manage dynamic equivalence relations where items have associated state and merging them produces side effects.",
      "description_length": 442,
      "index": 47,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Archetype.Tools.Map",
      "library": "archetype",
      "description": "This module organizes a family of data structures and operations for managing ordered key-value associations. It provides immutable maps with efficient lookup, insertion, and traversal, supporting operations like `find`, `add`, and `iter`. Each child module specializes in different map variants, such as those based on comparable keys or specific performance characteristics. For example, you can use it to track symbol tables in a compiler or manage configuration settings indexed by string keys.",
      "description_length": 498,
      "index": 48,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Tools.Sint",
      "library": "archetype",
      "description": "This module supports efficient creation, modification, and querying of integer sets through operations like union, intersection, element membership checks, and bulk updates. It provides a concrete type for managing integer collections, with bidirectional conversion capabilities to lists and sequences, as well as iterative processing",
      "description_length": 334,
      "index": 49,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Parser.Incremental",
      "library": "archetype",
      "description": "This module provides entry points for incremental parsing of Archetype expressions and top-level structures, starting from a given lexical position. It works with `expr` and `archetype` types from the ParseTree module, producing checkpoints for the Menhir parser. Concrete use cases include resuming parsing after partial input or handling interactive or streaming input scenarios.",
      "description_length": 381,
      "index": 50,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Tools.Bool",
      "library": "archetype",
      "description": "This module provides a single function `compare` that orders boolean values, returning an integer indicating the relative position of the two inputs. It operates directly on the built-in `bool` type, enabling sorting and comparison logic for boolean values. A concrete use case is integrating booleans into data structures or algorithms that require ordered values, such as priority queues or ordered collections.",
      "description_length": 413,
      "index": 51,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Ident.Mid",
      "library": "archetype",
      "description": "This implementation provides a map data structure with string-based keys and polymorphic values, supporting core operations like insertion, deletion, and lookup alongside advanced transformations such as merging, filtering, and partitioning. It includes utilities for iterative traversal, value mapping, and key-based grouping, with functions to convert maps to lists or sequences. Such capabilities make it suitable for managing hierarchical configurations, processing associative datasets, or handling symbol tables in language implementations.",
      "description_length": 546,
      "index": 52,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Lsp",
      "library": "archetype",
      "description": "This component provides utilities for handling LSP-compliant data structures, focusing on JSON serialization, pretty-printing, and construction of entities like positions, ranges, diagnostics, and symbol outlines. It operates on structured types representing source code locations, AST nodes, and diagnostic information, with support for bidirectional conversion between internal representations and LSP wire formats. The functionality is particularly useful for implementing language server features such as error reporting, code navigation, and structured response generation during development tool integration.",
      "description_length": 614,
      "index": 53,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Io",
      "library": "archetype",
      "description": "This module handles lexical analysis and parsing operations, including error reporting, bracket balancing, and resuming parsing after errors. It works with lex buffers, error descriptions, and parser checkpoints to process input from strings or channels. Concrete use cases include parsing Archetype source files into abstract syntax trees, handling lexical errors during input processing, and recovering from syntax errors during interactive parsing.",
      "description_length": 451,
      "index": 54,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Parser",
      "library": "archetype",
      "description": "This module processes Archetype smart contract code by defining lexical tokens and parsing functions that build syntax trees for static analysis, code transformation, and compiler integration. It supports low-level parser control through checkpoint manipulation, environment inspection, and incremental token feeding, enabling error recovery and custom parsing strategies. High-level entry points parse expressions and full programs from specific lexical positions, producing parse trees and parser checkpoints. Examples include resuming parsing after partial input, analyzing grammar symbols during execution, and constructing ASTs for program analysis.",
      "description_length": 654,
      "index": 55,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Mtools",
      "library": "archetype",
      "description": "Converts parsed expressions or string literals into typed intermediate representation terms. Works with `P.expr` and string inputs, producing `M.mterm` values. Useful for transforming raw syntax into semantically meaningful structures during compilation or analysis phases.",
      "description_length": 273,
      "index": 56,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Gen_michelson",
      "library": "archetype",
      "description": "This module combines type manipulation and Michelson code transformation with advanced map operations to support compiler workflows. It provides core data types like Michelson ASTs, type environments, and polymorphic maps, along with operations for type validation, code generation, and environment tracking. You can reshape Michelson data structures, transform contract code, and manage variable state using functions like `map`, `fold`, and `filter` over string-keyed maps. Specific capabilities include converting intermediate representations into executable Michelson, tracking variable changes during compilation, and aggregating or transforming data by keys.",
      "description_length": 664,
      "index": 57,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Binding",
      "library": "archetype",
      "description": "This module handles type representation and event processing for model records. It provides operations to convert type kinds to formatted output, compute Micheline types from models, and construct input events with typed records. Use cases include generating type definitions and handling event data in a model-driven context.",
      "description_length": 326,
      "index": 58,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Error",
      "library": "archetype",
      "description": "This module manages error and warning reporting with positional context, supporting behaviors like raising exceptions, exiting, or resuming execution. It works with lists of position objects paired with messages, allowing precise error tracking and customizable handling. Concrete use cases include validating semantic rules during compilation, reporting syntax issues with source locations, and managing recoverable errors in program analysis.",
      "description_length": 444,
      "index": 59,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Archetype.Tools",
      "library": "archetype",
      "description": "This module combines functional utilities for data transformation with specialized structures for ordered collections, offering operations on tuples, options, lists, maps, and JSON. It enables tasks like composing functions over lists, safely chaining optional values, minifying JSON, and normalizing strings, while submodules handle set algebra on strings, integer set operations, and ordered map traversals with key-based filtering. You can process character sequences with directional iteration, deduplicate lists, merge string-keyed maps with custom logic, or extract values from key-value pairs without exceptions. Core types include ordered maps (`Mint.t`, `Mstr.t`), string sets, integer sets, and enhanced list and option combinators, supporting efficient lookups, safe value extraction, and transformation pipelines.",
      "description_length": 825,
      "index": 60,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Archetype.Michelson_lexer",
      "library": "archetype",
      "description": "This module implements a lexer for Michelson, the smart contract language used in Tezos blockchain. It includes functions to tokenize input from a `Lexing.lexbuf`, handle comments (both line and block styles), and process string literals into a `Buffer`. It directly supports parsing Michelson source code by converting raw text into structured tokens consumable by a Michelson parser.",
      "description_length": 385,
      "index": 61,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Compile",
      "library": "archetype",
      "description": "This module provides compilation, decompilation, and diagnostic utilities for Archetype smart contracts, handling operations like parsing source code into models, generating Michelson IR, and serializing intermediate representations (e.g., ASTs, models) for debugging. It works with data structures such as `archetype`, `mterm`, `model`, and `michelson`, alongside JSON serialization for contract interfaces and storage. Key use cases include toolchain integration, error diagnostics during development, and runtime inspection of compiled artifacts.",
      "description_length": 549,
      "index": 62,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Ast",
      "library": "archetype",
      "description": "This module provides core abstractions and operations for building, inspecting, and transforming abstract syntax trees, including identifiers, expressions, types, and declarations. It supports domain-specific modeling of assets, enums, and security metadata, with utilities for pretty-printing, serialization, and static analysis. Submodules enable precise queries on AST elements like variables, fields, and types, facilitating tasks such as asset validation and type resolution during compilation. Examples include extracting field definitions from asset declarations, resolving variable types in expressions, and serializing AST nodes for logging or code generation.",
      "description_length": 669,
      "index": 63,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Gen_transform",
      "library": "archetype",
      "description": "This module transforms models by validating semantics, simplifying expressions, and optimizing structure, operating on `model` and `mterm` types to prepare for code generation through tasks like variable pruning and syntactic sugar resolution. It integrates submodules for efficient string set and map operations, enabling deduplication, membership checks, key-value manipulations, and bulk transformations. These tools support tasks like compiling Archetype definitions into optimized forms, validating container correctness, and managing configuration data with precise set-theoretic and associative logic.",
      "description_length": 608,
      "index": 64,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Ident",
      "library": "archetype",
      "description": "This module defines an `ident` type as a string alias with built-in support for comparison, JSON serialization, and string conversion, making it suitable for managing identifiers in data models and logs. It includes submodules `Mid` and `Sid` for organizing identifier-keyed maps and sets, enabling efficient lookups, aggregations, and transformations over collections. With `Mid`, users can manage associative data such as configuration entries or symbol tables, while `Sid` supports set-based operations like union and membership checks. Examples include serializing identifiers to JSON, tracking unique elements in a set, or building maps that associate identifiers with structured values.",
      "description_length": 692,
      "index": 65,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Gen_extra",
      "library": "archetype",
      "description": "This module provides utilities for converting data between JSON, Micheline, and internal representations, handling parsing errors, and serializing storage entries. It operates on storage values, entries, expressions, and type information, enabling tasks like contract code replacement, metadata generation, and data marshaling for Tezos blockchain applications. Specific use cases include converting storage values for on-chain interactions, serializing data structures for transactions, and generating contract code from type definitions.",
      "description_length": 539,
      "index": 66,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Gen_model",
      "library": "archetype",
      "description": "This module handles error reporting and environment management during model generation. It defines error types for invalid constructs, provides functions to emit and format errors, and supports environment creation and conversion for model generation contexts. It works with identifiers, locations, and abstract syntax trees to validate and transform input into a model representation.",
      "description_length": 385,
      "index": 67,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Ufind",
      "library": "archetype",
      "description": "This module provides a union-find (disjoint-set) structure with path compression, supporting dynamic equivalence class management and efficient membership queries. It allows items to carry associated data and handles side effects during union operations, with control over priority when merging. You can create new elements, merge sets, find canonical representatives, and update or retrieve data attached to items, making it suitable for type inference, constraint solving, and graph algorithms like Kruskal's. The child modules refine this core functionality with specific representations, comparison operations, and effect tracking during union operations.",
      "description_length": 659,
      "index": 68,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Printer_model_tools",
      "library": "archetype",
      "description": "This module handles error reporting and environment management during model processing. It defines error types for unsupported terms and values, provides functions to format and emit errors, and manages an environment structure tracking model elements like assignments, predicates, and constants. It is used to analyze and query model components, such as identifying constants, comparing update predicates, and locating predicate indices.",
      "description_length": 438,
      "index": 69,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Typing",
      "library": "archetype",
      "description": "This module orchestrates type-checking, normalization, and semantic analysis for Archetype expressions, declarations, and environments, while integrating specialized tools for Micheline parsing, environment management, and Michelson type manipulation. It defines core data types such as environments (`t`), identifiers (`lident`, `longident`), type representations (`ptyp`), and Micheline structures (`T.obj_micheline`), with operations spanning type inference, name resolution, scope management, and AST transformation. Functionality includes extracting callable entrypoints from Micheline code, validating type consistency across function calls and storage definitions, and decomposing or unifying types to enforce Michelson typing rules. Specific use cases involve transforming parsed syntax into typed representations, analyzing Tezos smart contract types, and verifying properties like comparability and storability during compilation.",
      "description_length": 940,
      "index": 70,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Archetype.Micheline",
      "library": "archetype",
      "description": "This module processes Micheline AST nodes with support for location tracking and annotation extraction. It provides operations to strip or inject source locations, map over node structures, and extract or reconstruct location metadata. Concrete use cases include parsing and transforming Michelson smart contracts while preserving source position data for error reporting or code analysis.",
      "description_length": 389,
      "index": 71,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Opt_model",
      "library": "archetype",
      "description": "This module defines a recursive type for representing model entries, supporting operations to build, transform, and optimize models during decompilation. It includes functions to extract and display model entries, remove redundant constructs like nil operations and tuple access, and optimize model structures within a given environment. Concrete use cases include processing and simplifying Archetype models during code generation or transformation pipelines.",
      "description_length": 460,
      "index": 72,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.ParseTree",
      "library": "archetype",
      "description": "This module enables bidirectional JSON conversion of abstract syntax tree (AST) elements\u2014identifiers, types, operators, expressions, declarations, and metadata\u2014using Yojson, with robust error handling for invalid inputs. It provides pretty-printing and string formatting utilities for debugging, alongside constructors for typed AST nodes, built-in types (e.g., `tint`, `tstring`), and domain-specific structures like transfers, Michelson representations, and smart contract assets. These operations facilitate data marshaling, static analysis, code generation, and AST manipulation in a blockchain-focused language.",
      "description_length": 616,
      "index": 73,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Micheline_tools",
      "library": "archetype",
      "description": "This module constructs and converts Micheline nodes used in Tezos smart contract representations. It provides functions to create Micheline values from strings, integers, bytes, and primitives, and supports conversion between Micheline, PT (parsed type), and obj_micheline formats. Concrete use cases include building Michelson expressions programmatically and translating between different intermediate representations during contract compilation or analysis.",
      "description_length": 460,
      "index": 74,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Gen_decompile",
      "library": "archetype",
      "description": "This module decompiles Micheline and Michelson code into structured, higher-level representations, using environment mappings to manage types and identifiers during transformation. It provides core functions for parsing, type-checking, and converting intermediate representations, with data types like `T.michelson`, `T.dcode`, `T.dprogram`, and `M.model` enabling detailed contract analysis. The main `decompile` function converts typed programs into models, while child modules handle specific transformations such as turning Michelson into readable code or generating analysis models from compiled contracts. Example uses include reverse engineering Michelson bytecode into Archetype source or producing visual models from on-chain contract data.",
      "description_length": 749,
      "index": 75,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Archetype.Mtyping",
      "library": "archetype",
      "description": "This module implements a stack-based type-checked computation framework with operations for arithmetic, logic, control flow, and cryptographic primitives, operating on structured stacks (`stack`, `stack1`) and Michelson code representations (`M.code`). It enforces type safety through stack transitions and environment validation, supporting smart contract development with constructs for contracts, tickets, and cryptographic operations like `op_BLAKE2B` and `check_signature`. Submodules provide stack manipulation (e.g., `op_DROP`, `op_PAIR`), environment tracking for contract typing (via `Env.t`), and stack validation for cryptographic and domain-specific data forms. Together, they enable precise type checking, contract analysis, and execution simulation in domain-specific language pipelines.",
      "description_length": 801,
      "index": 76,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Pt_helper",
      "library": "archetype",
      "description": "Validates the structure of a JSON input against a predefined archetype schema, ensuring correctness for applications like configuration loading or data serialization. Works directly with the `Archetype.ParseTree.archetype` type to enforce schema constraints during runtime. Useful in scenarios where strict data validation is required before processing user-defined configurations or external data sources.",
      "description_length": 406,
      "index": 77,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Archetype.Printer_ast",
      "library": "archetype",
      "description": "This module supports formatting operations for abstract syntax tree components, converting structured elements like identifiers, expressions, types, and metadata into human-readable strings using OCaml's `Format.formatter`. It handles data structures such as constants, function arguments, transactions, and polymorphic types, with utilities for parenthetical grouping and nested structure rendering. These capabilities are particularly valuable in domain-specific languages for smart contracts, enabling readable output for debugging, documentation, or contract verification workflows.",
      "description_length": 586,
      "index": 78,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Archetype.Symbol",
      "library": "archetype",
      "description": "This module provides functions to convert parser tokens, symbols, and production items into human-readable string representations. It operates on types from the Menhir parser generator, including `token`, `xsymbol`, and production-int pairs. These conversions are useful for debugging parser behavior, generating error messages, or logging during parsing.",
      "description_length": 355,
      "index": 79,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Position",
      "library": "archetype",
      "description": "This module enables the creation, combination, and transformation of positional metadata for tracking locations in source code, using `Lexing.position`, `Lexing.lexbuf`, and a custom position type. It supports operations like attaching positions to parsed values, merging ranges, and extracting line/column numbers, which are essential for error reporting, source mapping, and maintaining contextual location data during lexing and parsing workflows.",
      "description_length": 450,
      "index": 80,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Printer_model",
      "library": "archetype",
      "description": "This module converts data structures from the Archetype model into human-readable string representations using OCaml's formatting system. It handles core elements like variables, enums, records, functions, and storage structures, producing output suitable for debugging or user-facing displays. The functions follow a uniform approach of accepting a formatter and value pair to generate consistently structured representations.",
      "description_length": 427,
      "index": 81,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Archetype.Core",
      "library": "archetype",
      "description": "This module provides robust tools for converting, validating, and handling structured data with precision and safety. It supports operations on big integers, durations, dates, and time zones (Ktz, Kmtz, Kutz), enabling tasks like parsing human-readable durations into numeric values, performing timezone-aware time arithmetic, and converting date strings while accounting for leap years or epoch offsets. It also ensures safe handling of input channels, such as reading from files with automatic resource cleanup. Submodules extend this functionality to specialized tasks like timestamp serialization and path validation through pattern-based conversions.",
      "description_length": 655,
      "index": 82,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Archetype.Michelson",
      "library": "archetype",
      "description": "This module enables structured manipulation of Michelson language components, supporting operations like pretty-printing, JSON serialization, and AST construction for smart contract development and analysis. It defines data types representing Michelson primitives, typed expressions, control flow instructions, and Tezos-specific values such as cryptographic data and blockchain context variables. The module processes Michelson code through transformations like flattening, optimization, and macro replacement, and handles serialization to Micheline format. It also includes utilities to determine type storable status, facilitating contract compilation and programmatic analysis of on-chain data and execution contexts.",
      "description_length": 721,
      "index": 83,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.PureLexer",
      "library": "archetype",
      "description": "This module implements a lexer for parsing Archetype smart contract code, transforming character streams into structured tokens annotated with positional information for subsequent parsing and analysis. It processes source code using a lexing buffer, supporting operations to initialize, advance, retrieve, and conditionally skip tokens, all while tracking their source positions. The core data type is the token stream, enriched with location metadata, enabling precise error reporting and semantic processing. Example usage includes feeding a parser with tokens representing Archetype keywords, identifiers, and literals, such as recognizing `contract` or `entry` keywords and extracting variable names or numeric values from the source.",
      "description_length": 739,
      "index": 84,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Gen_contract_interface",
      "library": "archetype",
      "description": "This module facilitates the modeling, transformation, and serialization of contract interface data for Tezos smart contracts, focusing on Micheline expressions, storage declarations, entrypoints, and domain-specific constructs like assets, records, and enums. It provides utilities for bidirectional JSON conversion (via Yojson), pretty-printing, and code generation, enabling use cases such as contract interface generation, type conversion between Archetype models and Michelson, and structured representation of smart contract metadata. The operations emphasize structured data marshaling and intermediate format construction for blockchain contract development workflows.",
      "description_length": 675,
      "index": 85,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Archetype.Micheline_printer",
      "library": "archetype",
      "description": "This module formats and prints Micheline expressions with comments and annotations. It transforms canonical Micheline nodes into printable structures and provides functions to render them using OCaml's Format module. Use it to generate readable Tezos smart contract code or debug Micheline ASTs with proper formatting and inline comments.",
      "description_length": 338,
      "index": 86,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Michelson_parser",
      "library": "archetype",
      "description": "This module parses Michelson code into Micheline structures, handling low-level syntax elements like strings, numbers, and annotations while supporting incremental parsing with error recovery. It provides direct access to lexer and parser operations, allowing manipulation of tokens, parser checkpoints, and LR(1) states, along with functions to analyze grammar properties such as symbol relationships. Submodules enable step-by-step parsing from specific positions, producing checkpointed Micheline objects for use in interactive tools or compilers. Example uses include building custom parsing strategies, integrating Michelson into IDEs with precise error handling, and analyzing smart contract code during development.",
      "description_length": 722,
      "index": 87,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Archetype.Gen_storage",
      "library": "archetype",
      "description": "This module defines error descriptions for missing initialization expressions and provides functions to format, display, and raise these errors. It works with the `error_desc` type and the `model` type from the `Archetype.Model` module. A concrete use case is validating that all storage fields in a model have initialization expressions during code generation.",
      "description_length": 361,
      "index": 88,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.UF",
      "library": "archetype",
      "description": "This module provides a union-find (disjoint-set) structure for managing equivalence classes of integers. It supports creating sets, finding root representatives with path compression, merging sets by rank, and duplicating the structure. You can use it to efficiently track connected components in graphs or solve partitioning problems where elements are dynamically grouped. Example operations include uniting two sets and checking if two elements belong to the same class.",
      "description_length": 473,
      "index": 89,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.ParseError",
      "library": "archetype",
      "description": "This module handles parsing errors by analyzing the parser's state to generate contextual error messages. It works with parser checkpoints, elements, and symbols to identify incomplete productions and potential expected tokens. Functions like `find_context` and `contextual_error_msg` extract meaningful context from the parser's stack to aid in error reporting during syntax analysis.",
      "description_length": 385,
      "index": 90,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Archetype.Printer_pt",
      "library": "archetype",
      "description": "This module provides pretty-printing functionality for Archetype language constructs, focusing on operator precedence management and syntactic structure formatting. It operates on parsed tree nodes like expressions, record items, asset operations, and contract elements, using associativity rules and precedence levels to ensure correct output formatting. The implementation supports use cases such as code generation, debugging output, and diagnostic reporting through structured formatter combinators.",
      "description_length": 503,
      "index": 91,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Archetype.Gen_debug_trace",
      "library": "archetype",
      "description": "This module serializes and converts source location data, Micheline AST elements, and debug trace structures for compiler debugging and trace generation. It operates on types like line/column positions, Micheline primitives, and trace metadata to support Michelson code generation, structured logging, and interactive debugging workflows. Key operations include JSON serialization, pretty-printing, and string conversion for values such as entrypoints, storage items, and typed debug traces.",
      "description_length": 491,
      "index": 92,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Model",
      "library": "archetype",
      "description": "The module organizes core data structures and transformation utilities for a blockchain modeling language, combining direct manipulation of identifiers, types, and terms with structured analysis of domain constructs like assets and storage. It defines key types such as `mterm`, `type_`, and `mident`, and supports operations including structural equality, mapping, folding, and IR generation, enabling tasks like AST traversal and type composition. The child module extends these capabilities with introspection and transformation routines for variables, enums, and containers, facilitating storage validation, API list handling, and term evaluation workflows. Together, they support concrete use cases such as asset structure analysis, rational number construction, and type-aware list sorting.",
      "description_length": 796,
      "index": 93,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Printer_michelson",
      "library": "archetype",
      "description": "This module provides functions to format Michelson and JavaScript code structures\u2014including primitives, expressions, programs, and off-chain views\u2014into human-readable strings. It operates on Michelson AST elements and formatter types, utilizing OCaml's `Format` module to ensure consistent presentation. These tools are particularly useful for debugging smart contract logic, generating documentation, or integrating with development environments that require structured code representation.",
      "description_length": 491,
      "index": 94,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Archetype.Options",
      "library": "archetype",
      "description": "This module manages configuration and runtime settings for a code generation and analysis toolchain, focusing on parsing command-line options, controlling compilation modes, and handling language server protocol (LSP) parameters. It operates on enumerated types like `target_lang` for output formats (Michelson, JavaScript, Markdown), mutable reference flags for features (debugging, test modes, output formatting), and structured configurations for LSP behaviors (error reporting, outline generation). Key use cases include enabling blockchain contract compilation, customizing decompilation output, and integrating with IDEs via LSP by dynamically adjusting runtime settings.",
      "description_length": 677,
      "index": 95,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Lexer",
      "library": "archetype",
      "description": "This module handles lexical analysis for a parser, converting raw character streams into structured tokens and managing string, comment, and keyword processing. It operates on lexing buffers, buffers, and parser tokens, with support for error reporting and stateful lexing through recursive functions. Concrete use cases include tokenizing source code, handling nested comments, and parsing string literals with escapes.",
      "description_length": 420,
      "index": 96,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Archetype.Gen_api_storage",
      "library": "archetype",
      "description": "This module defines an error description type and implements functions to generate API storage models from a given model specification. It works with the `model` type to produce an augmented model that includes API storage logic, based on a provided model. A concrete use case is automatically generating storage structures for API endpoints in a web application framework.",
      "description_length": 373,
      "index": 97,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Archetype",
      "library": "archetype",
      "description": "This module processes Archetype smart contract code through lexical analysis, parsing, and type-checking, transforming source input into structured abstract syntax trees and typed intermediate representations. It supports error-resilient parsing, bidirectional JSON conversion, and Michelson code generation, enabling tasks like static analysis, code transformation, and contract compilation. Key data types include identifiers, expressions, types, and Michelson ASTs, with operations for pretty-printing, error reporting, and positional tracking. Examples include parsing Archetype source files into ASTs, converting expressions into Michelson IR, and validating contract models with precise type checking and error diagnostics.",
      "description_length": 729,
      "index": 98,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 115,
    "meaningful_modules": 99,
    "filtered_empty_modules": 16,
    "retention_rate": 0.8608695652173913
  },
  "statistics": {
    "max_description_length": 940,
    "min_description_length": 273,
    "avg_description_length": 502.4848484848485,
    "embedding_file_size_mb": 0.3601245880126953
  }
}