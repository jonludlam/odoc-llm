{
  "package": "logical",
  "embedding_model": "BAAI/bge-base-en-v1.5",
  "embedding_dimension": 1024,
  "total_modules": 7,
  "creation_timestamp": "2025-06-18T16:29:50.380008",
  "modules": [
    {
      "module_path": "Logical.Type.T",
      "description": "Compares instances of the type using a custom ordering function. Converts values to S-expressions and string representations for serialization and debugging. Used to enforce consistent ordering and representation in data structures and logging.",
      "description_length": 244,
      "index": 0,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Logical.Type",
      "description": "Provides a unified interface for comparing, serializing, and representing type instances, enabling consistent behavior across data structures and logging. Key data types include the base type and its S-expression and string representations, with operations for comparison, conversion, and formatting. Users can define custom orderings, serialize values for storage or transmission, and generate human-readable logs. This supports tasks like sorting lists, debugging complex structures, and ensuring interoperability between components.",
      "description_length": 535,
      "index": 1,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Logical.Value",
      "description": "Converts integer, float, string, and boolean values into a unified type representation, and constructs variable references from names. Handles conversion of these values to their string equivalents for output or logging. Works with primitive types and variable names to build and manipulate symbolic representations.",
      "description_length": 316,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Logical.State",
      "description": "Manages type variable bindings and unification, allowing retrieval of values and merging of type constraints. Operates on a state structure containing variable-name to type mappings. Used to track and resolve type relationships during inference or constraint solving.",
      "description_length": 267,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Logical.Goal",
      "description": "Compares two type values to produce a goal, combines goals using logical OR and AND operations, and checks if a type value belongs to a specific set. Works with type representations and sets of types. Used to construct complex type validation conditions in constraint-solving contexts.",
      "description_length": 285,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "logical",
      "description": "Provides unification, logical conjunction, and disjunction operations for manipulating and querying symbolic expressions. Works with terms represented as recursive data structures, including atoms, variables, and nested tuples. Enables simple constraint satisfaction and backtracking search in rule-based systems.",
      "description_length": 313,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Logical",
      "description": "combines type comparison, unification, and constraint handling to support logical reasoning over type structures. it manages variable bindings, merges constraints, and evaluates type relationships through logical operations. it enables tasks like type inference, validation, and constraint satisfaction by working with type representations, variable references, and goal combinations. users can track type dependencies, resolve conflicts, and build complex validation rules.",
      "description_length": 474,
      "index": 6,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 7,
    "meaningful_modules": 7,
    "filtered_empty_modules": 0,
    "retention_rate": 1.0
  },
  "statistics": {
    "max_description_length": 535,
    "min_description_length": 244,
    "avg_description_length": 347.7142857142857,
    "embedding_file_size_mb": 0.02584075927734375
  }
}