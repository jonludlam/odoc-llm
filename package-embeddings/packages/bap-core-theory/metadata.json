{
  "package": "bap-core-theory",
  "embedding_model": "Qwen/Qwen3-Embedding-8B",
  "embedding_dimension": 4096,
  "total_modules": 47,
  "creation_timestamp": "2025-08-15T15:11:31.476378",
  "modules": [
    {
      "module_path": "Bap_core_theory.Theory.Value.Sort.Name",
      "library": "bap-core-theory",
      "description": "This module manages unique names for value sorts, ensuring their authenticity through name-based witnesses. It provides operations to declare new names, compare and order existing names, and enforce constraints like clamping values within bounds. These capabilities are essential when defining and distinguishing custom value sorts in semantic analysis tasks, such as representing bitvectors or floating-point formats with guaranteed unique identifiers.",
      "description_length": 453,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bap_core_theory.Theory.Value.Sort.Top",
      "library": "bap-core-theory",
      "description": "This module enables working with type-erased value sorts by providing **comparison**, **ordering**, and **serialization** operations, allowing their use in **monomorphic data structures** like sets and maps while preserving type information for later refinement. It supports operations such as equality checks, min/max computation, bounds validation, and clamping, which are essential for managing heterogeneous value sorts in collections (e.g., `Set.empty (module Value.Sort.Top)`). The erased type indices facilitate polymorphic storage without losing the ability to reconstruct original type distinctions when needed.",
      "description_length": 620,
      "index": 1,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Bap_core_theory.Theory.Float.Format",
      "library": "bap-core-theory",
      "description": "This module defines operations for specifying and manipulating the bitvector representation format of floating-point numbers. It provides functions to define a floating-point sort using an interpretation and a bitvector sort, retrieve the underlying bitvector sort, and obtain the expression that interprets the bits of a floating-point value. Concrete use cases include modeling IEEE 754 floating-point formats and custom floating-point representations for static analysis and binary translation tasks.",
      "description_length": 503,
      "index": 2,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Bap_core_theory.Theory.Var.Top",
      "library": "bap-core-theory",
      "description": "This module provides comparison, serialization, and total ordering operations for variables with erased sort indices, enabling their use in ordered data structures like sets and maps. It operates on unit-indexed variables, comparing them solely by their identifiers, which allows variables of the same name but different sorts to be treated as equal. It is particularly useful for building collections or performing comparisons where sort information is irrelevant, such as tracking variables by name alone or establishing canonical orderings in analysis tools.",
      "description_length": 561,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bap_core_theory.Theory.Basic.Make",
      "library": "bap-core-theory",
      "description": "This module offers low-level operations for bitvector arithmetic, bitwise logic, memory access, and control flow modeling, working with variables, typed bitvectors, and memory structures. It supports formal verification and symbolic computation tasks by enabling precise manipulation of signed/unsigned comparisons, shifts, casts, and memory effects. Specific use cases include program analysis, binary translation, and hardware modeling where exact semantic representations of machine-level operations are required.",
      "description_length": 516,
      "index": 4,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Bap_core_theory.Theory.Basic.Empty",
      "library": "bap-core-theory",
      "description": "This module provides symbolic computation operations for bitvectors and memory models, including arithmetic (addition, subtraction, multiplication, division), bitwise logic (AND, OR, NOT), control flow constructs (ITE, jumps), and memory manipulation (load/store). It supports formal verification tasks through pure symbolic value generation and structured effect handling, enabling analysis of low-level program behavior via signed/unsigned comparisons, bitvector casting, and sequencing primitives. Use cases include symbolic execution, static analysis, and semantic modeling of machine-code programs.",
      "description_length": 603,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bap_core_theory.Theory.Pass.Desugar",
      "library": "bap-core-theory",
      "description": "This module specializes in desugaring and simplifying expressions in BAP's core theory, focusing on variable alias resolution, constant propagation, and bitvector/floating-point operation normalization. It operates on low-level constructs like registers, bitvectors (`bitv`), memory (`mem`), effects (`eff`), and floating-point values (`float`), optimizing transformations such as eliminating redundant assignments to constant registers, concretizing zero-register accesses, and normalizing arithmetic or control-flow primitives. It serves in automated theory instantiation pipelines and custom transformation workflows to streamline symbolic representations for analysis or compilation tasks.",
      "description_length": 693,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bap_core_theory.Theory.Parser.Grammar",
      "library": "bap-core-theory",
      "description": "This module defines grammars for six sub-languages corresponding to each sort of Core Theory terms, enabling the construction of recursive-descent parsers for untyped BIL-style languages. It provides rules that map language constructs to Core Theory terms, handling variable binding and context management to ensure semantic correctness during parsing. Concrete use cases include implementing parsers for intermediate languages like BIL, where each grammar rule translates expressions or statements into typed terms while maintaining contextual type information and variable scoping.",
      "description_length": 583,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bap_core_theory.Theory.Target.Options",
      "library": "bap-core-theory",
      "description": "This module enables managing and comparing extensible target architecture properties, supporting operations like serialization, equality checks, and bounded value comparisons. It operates on `Target.Options.t` values\u2014a set of key-value properties stored via `KB.Value.t`\u2014with functions for S-expression and bin_prot encoding, pretty-printing, and domain-specific clamping. It is used to define and persist target-specific configurations, such as custom architectural extensions or microarchitectural details, while ensuring cross-version compatibility and efficient runtime representation.",
      "description_length": 589,
      "index": 8,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Bap_core_theory.Theory.IEEE754.Sort",
      "library": "bap-core-theory",
      "description": "This module defines operations to construct and manipulate IEEE754 floating-point sorts, including extracting their exponent, significand, and storage bitvector sorts. It works with parameterized IEEE754 formats and associated bitvector types to represent floating-point components. Concrete use cases include defining custom floating-point representations and decomposing them into their constituent fields for analysis or transformation.",
      "description_length": 439,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bap_core_theory.Theory.Value.Sort",
      "library": "bap-core-theory",
      "description": "This module defines and manipulates value sorts that encode static properties of values, such as bitvector widths or floating-point formats. It supports constructing, deconstructing, and comparing sorts using operations like `int`, `sym`, `@->`, `hd`, `tl`, and `same`, enabling precise semantic representations in expression denotations. Concrete use cases include defining `int8` as a bitvector of width 8 or building compound sorts for structured data types.",
      "description_length": 461,
      "index": 10,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Bap_core_theory.Theory.Documentation.Theory",
      "library": "bap-core-theory",
      "description": "This module represents and manages documentation for theories in the BAP semantics framework. It provides access to a theory's fully qualified name, description, required dependencies, and provided capabilities through dedicated retrieval functions. It is used to inspect and document the metadata of theories within the core BAP theory system.",
      "description_length": 344,
      "index": 11,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Bap_core_theory.Theory.Role.Register",
      "library": "bap-core-theory",
      "description": "This module provides an extensible set of semantic roles for classifying registers, such as general-purpose, stack pointer, function arguments, and status flags, represented via the `Role.t` type. It supports architecture-agnostic analysis by categorizing register behavior and usage patterns, enabling applications like calling convention modeling, static analysis, and cross-architecture reasoning. Specific use cases include identifying caller/callee-saved registers, handling target-specific extensions, and abstracting hardware versus pseudo-registers in program representations.",
      "description_length": 584,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bap_core_theory.Theory.Value.Match",
      "library": "bap-core-theory",
      "description": "This module provides a domain-specific language for pattern matching on value sorts using two core operators: `can` for conditional refinement of values based on sort, and `let|` for sequencing match cases. It works with value types defined in the `Bap_core_theory.Theory.Value` module, allowing functions to dispatch logic based on the runtime sort of values, such as bitvectors or floating-point representations. Concrete use cases include writing interpreters or analyzers that perform different operations depending on the value's type, like extracting integer ranges or handling arithmetic based on bitvector widths.",
      "description_length": 621,
      "index": 13,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bap_core_theory.Theory.Parser.Make",
      "library": "bap-core-theory",
      "description": "This module generates a recursive-descent parser that maps untyped BIL-style ASTs into typed Core Theory terms, using a set of six top-level parsing rules corresponding to term sorts. It operates on abstract syntax trees derived from intermediate languages like BIL, translating constructs such as expressions and statements into their semantic equivalents while enforcing type correctness. A concrete use case is the BIL parser, which maps BIL expressions into Core Theory terms, using the parser to infer context and produce error terms for invalid constructs.",
      "description_length": 562,
      "index": 14,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bap_core_theory.Theory.Effect.Sort",
      "library": "bap-core-theory",
      "description": "This module defines and manipulates effect sorts that classify static properties of program effects, distinguishing between control (`Ctrl`) and data (`Data`) effects. It provides constructors like `data` and `ctrl` to define effect kinds, operations such as `both`, `union`, and `join` to combine effect sets, and predefined effects like `rreg`, `wmem`, and `jump` for modeling register, memory, and control flow behavior. It is used to represent and reason about the impact of instructions on program state and execution flow in a structured and composable way.",
      "description_length": 563,
      "index": 15,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bap_core_theory.Theory.Value.Top",
      "library": "bap-core-theory",
      "description": "This module enables operations on semantically typed values with erased sort information, specifically supporting comparison, clamping, and binary serialization. It works with abstract values of type `t` that encapsulate heterogeneous data (e.g., bitvectors, floats) after type erasure, allowing uniform storage, deserialization, and ordered manipulation. Key use cases include persisting values across systems, enforcing value ranges in analyses, and dynamically restoring type context via refinement for domain-specific interpretations.",
      "description_length": 538,
      "index": 16,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bap_core_theory.Theory.Var.Ident",
      "library": "bap-core-theory",
      "description": "This module provides operations for serializing, comparing, and converting variable identifiers with case-insensitive semantics, supporting binary and S-expression formats. It defines a structured total ordering for identifiers based on their intrinsic properties, such as virtual/physical status, mutability, and version numbers, while ensuring deterministic sorting of numeric components. These capabilities are critical for tasks like canonicalizing variable representations, enforcing consistent identifier hierarchies in program analysis, or clamping identifiers within versioned or numerically bounded ranges.",
      "description_length": 615,
      "index": 17,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bap_core_theory.Theory.IEEE754",
      "library": "bap-core-theory",
      "description": "This module provides functions to construct and manipulate IEEE754 floating-point formats using specific parameters for binary and decimal representations of varying bit widths. It works with parameterized floating-point formats and associated bitvector types to represent and decompose floating-point components such as exponent and significand. Concrete use cases include defining custom floating-point sorts and extracting their internal fields for analysis or transformation in semantic representations.",
      "description_length": 507,
      "index": 18,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bap_core_theory.Theory.Semantics",
      "library": "bap-core-theory",
      "description": "This module defines program semantics as effects, providing operations to compare, serialize, and manipulate semantic values using knowledge slots and domains. It supports binary and S-expression serialization, ordering functions (ascending, descending, clamping), and comparison witness handling for data structures like effect classes, semantic value representations, and predefined slots storing program memory states. These capabilities enable use cases such as analyzing program behavior, optimizing code transformations, and persisting semantic data across sessions.",
      "description_length": 572,
      "index": 19,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bap_core_theory.Theory.Bool",
      "library": "bap-core-theory",
      "description": "This module defines the boolean sort and operations for working with one-bit boolean values in the BAP semantics representation. It provides the type `t` for boolean values, the sort `t` for classifying boolean expressions, and the `refine` function to narrow a unit sort to a boolean sort if applicable. It is used to represent and manipulate logical truth values in BAP's intermediate representation of program semantics.",
      "description_length": 423,
      "index": 20,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Bap_core_theory.Theory.Source",
      "library": "bap-core-theory",
      "description": "This module supports comparison, serialization, and metadata management for source code artifacts represented as `Source.t` values within BAP's knowledge base. It operates on extensible `KB.Value.t` structures associated with source code properties like file names, languages, and text, enabling use cases such as tracking compilation unit provenance or analyzing source-level semantics during program decompilation. Key operations include clamping source ranges, ordering values, and persisting custom metadata through `KB` slot manipulations.",
      "description_length": 544,
      "index": 21,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bap_core_theory.Theory.Role",
      "library": "bap-core-theory",
      "description": "This module defines semantic roles for program entities like variables and registers, offering operations to declare, compare, and serialize role classifications based on architectural or usage traits (e.g., general-purpose registers, stack pointers). It works with an extensible enumeration type representing roles, supporting use cases in architecture-agnostic analysis, domain modeling, and persistent storage via S-expressions or binary formats. Key functions include role comparison, clamping, and serialization, enabling structured reasoning about target-specific semantics across different platforms.",
      "description_length": 607,
      "index": 22,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bap_core_theory.Theory.Fabi",
      "library": "bap-core-theory",
      "description": "This module provides operations for managing an enumeration type representing floating-point binary interface (FABI) conventions, including named element declaration, comparison, hashing, and property inspection. It supports data structures like `Fabi.t` values, which encapsulate FABI identifiers, and offers utilities for serialization, sorting, clamping, and domain-specific persistence. The predefined `hard` and `soft` values exemplify use cases for specifying floating-point operation semantics in compiled code, distinguishing hardware-accelerated versus software-emulated execution contexts.",
      "description_length": 599,
      "index": 23,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bap_core_theory.Theory.Value",
      "library": "bap-core-theory",
      "description": "This module represents the denotation of expressions using sorted values, where each value has a sort that encodes static properties like bitvector width or floating-point format. It provides operations to create, inspect, and transform values based on their sorts, supporting concrete tasks such as constructing bitvectors of specific widths or dynamically refining value representations. Key use cases include semantic analysis of machine instructions, where precise value representation is required for operations like constant propagation or symbolic evaluation.",
      "description_length": 566,
      "index": 24,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bap_core_theory.Theory.Origin",
      "library": "bap-core-theory",
      "description": "This module defines the relationship between aliased registers and their origin registers using the `('s,'k) Origin.t` type, where `'s` represents the width and `'k` the kind of relationship\u2014either `sub` for subsets or `sup` for supersets. It provides functions like `cast_sub`, `cast_sup`, `reg`, `regs`, `hi`, and `lo` to inspect and manipulate these relationships. Use cases include analyzing register aliasing in low-level code, extracting bit ranges for sub-registers, and reconstructing composite registers from smaller components.",
      "description_length": 537,
      "index": 25,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bap_core_theory.Theory.Language",
      "library": "bap-core-theory",
      "description": "This module provides an enumeration type for representing source code languages, supporting operations like comparison, hashing, and serialization. It includes predefined constants for common languages (C, C++, Ada, etc.) and order manipulation functions to manage language hierarchies. Designed for use in analysis tools, it enables precise language identification and processing within semantic frameworks.",
      "description_length": 408,
      "index": 26,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bap_core_theory.Theory.Target",
      "library": "bap-core-theory",
      "description": "This module manages abstract execution environments through operations that compare, serialize, and inspect target architectures. It works with `Target.t` values to expose properties like endianness, bitwidth, memory alignment, and hierarchical relationships (e.g., parent/child families), alongside utilities for naming, classification, and ABI-specific configurations. These capabilities are used to model system-specific semantics in binary analysis tasks, such as cross-architecture program verification or target-aware disassembly.",
      "description_length": 536,
      "index": 27,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bap_core_theory.Theory.Label",
      "library": "bap-core-theory",
      "description": "This module provides functions to access and manipulate label properties such as address, name, and semantics, construct labels from addresses or symbolic identifiers, and perform comparisons, serialization, and ordered collection operations. It operates on `label` values representing program locations, interacting with the `program` class through `KB.slot` to manage metadata and semantic associations. Use cases include uniquely identifying code locations, persisting label data efficiently via binary I/O, and maintaining ordered relationships between program points in analysis workflows.",
      "description_length": 594,
      "index": 28,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bap_core_theory.Theory.Program",
      "library": "bap-core-theory",
      "description": "This module provides operations to analyze and manipulate abstract program semantics through equality checks, ordering relations, and range constraints. It operates on program values tied to a knowledge domain, using labels as abstract pointers to associate semantic denotations with control flow targets. These capabilities enable use cases like verifying semantic equivalence of code segments, establishing execution orderings, and enforcing behavioral bounds during program analysis.",
      "description_length": 486,
      "index": 29,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bap_core_theory.Theory.Rmode",
      "library": "bap-core-theory",
      "description": "This module defines the type `t` representing rounding modes used in floating-point operations and provides the `refine` function to restore the specific type of a rounding mode sort. It works with the `Value.sort` type to enable precise type handling in semantic representations. Use cases include modeling IEEE 754 rounding modes in program analysis and ensuring correct type interpretation during value refinement.",
      "description_length": 417,
      "index": 30,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bap_core_theory.Theory.Pass",
      "library": "bap-core-theory",
      "description": "This module implements transformation passes for BAP's core theory, focusing on expression desugaring, simplification, and optimization. It operates on low-level semantic constructs such as registers, bitvectors, memory, effects, and floating-point values, performing tasks like constant propagation, variable alias resolution, and normalization of arithmetic or control-flow operations. Concrete use cases include streamlining symbolic representations for analysis tools and optimizing intermediate forms during automated theory instantiation.",
      "description_length": 544,
      "index": 31,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bap_core_theory.Theory.Parser",
      "library": "bap-core-theory",
      "description": "This module generates recursive-descent parsers that translate untyped BIL-style abstract syntax trees into typed Core Theory terms, using a set of six top-level parsing rules corresponding to term sorts. It works with untyped ASTs from intermediate languages like BIL, mapping expressions and statements to semantic terms while enforcing type correctness and handling variable binding. A concrete use case is the BIL parser, which uses these rules to convert BIL code into Core Theory terms, inferring context and producing error terms for invalid expressions.",
      "description_length": 561,
      "index": 32,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bap_core_theory.Theory.Documentation",
      "library": "bap-core-theory",
      "description": "This module provides functions to retrieve and inspect documentation for theories in the BAP semantics framework, including their names, descriptions, dependencies, and capabilities. It works with theory metadata structures to enable introspection of the core theory system. A concrete use case is querying the list of all declared theories and their associated documentation to generate reference materials or validate theory dependencies.",
      "description_length": 440,
      "index": 33,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bap_core_theory.Theory.Abi",
      "library": "bap-core-theory",
      "description": "This module manages named Application Binary Interface (ABI) conventions, providing operations to create, compare, and serialize ABI identifiers like `gnu`, `cdecl`, or `fastcall`. It supports hashing, ordering, and standard equality checks, along with utilities for converting ABIs to strings, S-expressions, or binary representations. These capabilities are used in binary analysis tools to model calling conventions and disassembly contexts.",
      "description_length": 444,
      "index": 34,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bap_core_theory.Theory.Var",
      "library": "bap-core-theory",
      "description": "This module facilitates the creation, inspection, and type-safe manipulation of versioned variables (`Var.t`), parameterized by their sort, alongside identifiers and structured ordering mechanisms. It supports serialization via `Bin_prot` and `Sexp`, handles variable properties like virtual/mutable status, and enables scoped variable generation, catering to semantic analysis and compiler tools requiring precise variable identity tracking, version control, and structured comparison.",
      "description_length": 486,
      "index": 35,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bap_core_theory.Theory.Float",
      "library": "bap-core-theory",
      "description": "This module defines floating-point sorts using bitvector representations and provides operations to construct, query, and manipulate these sorts. It works with floating-point formats specified via the `Format` submodule and bitvector sorts from the `Bitv` module. Concrete use cases include defining IEEE 754 floating-point types and extracting bitvector components for analysis or translation tasks.",
      "description_length": 400,
      "index": 36,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Bap_core_theory.Theory.Compiler",
      "library": "bap-core-theory",
      "description": "This module manages compiler descriptors that encapsulate metadata such as names, versions, and configuration options, enabling precise representation of translation tools used in binary analysis. It supports creation, inspection, and bidirectional serialization of these descriptors, along with comparison operations to establish ordering or equivalence between compiler instances. These capabilities are particularly useful for tracking provenance in binary translation workflows, ensuring compatibility across analysis pipelines, or debugging compiler-specific behaviors in low-level code.",
      "description_length": 592,
      "index": 37,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Bap_core_theory.Theory.Empty",
      "library": "bap-core-theory",
      "description": "This module supports symbolic manipulation of bitvectors, booleans, and floating-point values through arithmetic, bitwise, and control-flow operations, including memory access, type casting, and transcendental functions. It operates on structured data types like typed bitvectors, memory models, and rounded floating-point representations, enabling formal reasoning about low-level code semantics and numeric behavior. Specific applications include program verification, binary analysis, and symbolic execution where precise modeling of machine-level operations and mathematical properties is required.",
      "description_length": 602,
      "index": 38,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Bap_core_theory.Theory.Mem",
      "library": "bap-core-theory",
      "description": "This module defines operations for working with memory sorts, where each memory is an associative container mapping bitvectors to bitvectors. It provides functions to define memory sorts with specified key and value types, extract key and value sorts from existing memory sorts, and attempt to refine a sort into a memory type. Concrete use cases include modeling memory state in program analysis and defining transformations over memory contents in a formal semantics framework.",
      "description_length": 479,
      "index": 39,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bap_core_theory.Theory.Filetype",
      "library": "bap-core-theory",
      "description": "This module manages enumeration values representing file type identifiers, enabling comparison, hashing, and serialization operations. It operates on a named enumeration type (`filetype`) with predefined constants like `elf`, `coff`, and `macho` to represent executable file formats. These capabilities support binary analysis workflows where file types must be identified, persisted, or integrated into knowledge systems for program analysis tasks.",
      "description_length": 449,
      "index": 40,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bap_core_theory.Theory.Alias",
      "library": "bap-core-theory",
      "description": "This module provides operations to define and manipulate register aliasing relationships in CPU architectures, using a DSL for expressing concatenations and parts of registers. It works with register variables and alias definitions, enabling the construction of systems of equations that describe how registers overlap or combine. Concrete use cases include modeling x86 byte registers like `AH` as parts of `RAX`, or representing AVR register pairs such as `Y` as a concatenation of `R19` and `R18`.",
      "description_length": 500,
      "index": 41,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bap_core_theory.Theory.Endianness",
      "library": "bap-core-theory",
      "description": "This component defines operations for managing endianness types, including big, little, and bi-endian representations, and provides functions for comparison, serialization, and pretty-printing. It operates on an abstract type `t` that encapsulates byte-ordering semantics for multibyte word storage in memory. Primarily used in BAP's core theory to model memory representation, enabling analysis of systems where data encoding depends on architectural byte orderings.",
      "description_length": 467,
      "index": 42,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bap_core_theory.Theory.System",
      "library": "bap-core-theory",
      "description": "This module enables operations on enumerated operating system types, supporting declaration, comparison, and persistence of system identifiers such as Linux, Darwin, and Windows. It provides utilities to manage system values through ordering (e.g., `ascending`, `clamp`), classification (e.g., RTOS vs. general-purpose OS), and serialization to formats like S-expressions, while also handling unknown status checks and string representations. Typical use cases include system environment classification, version comparison logic, and persisting system metadata across BAP analyses.",
      "description_length": 581,
      "index": 43,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bap_core_theory.Theory.Unit",
      "library": "bap-core-theory",
      "description": "This module provides operations for creating and managing code units that represent files or memory regions, including constructors (`for_file`, `for_region`), comparison operators, and binary serialization. It works with knowledge base objects (`Unit.t`) that encapsulate metadata such as file paths, address biases, target architectures, source information, and compiler details. These capabilities are used to partition instructions into semantically coherent units, enabling tasks like provenance tracking, memory layout analysis, and cross-referencing in binary reverse engineering workflows.",
      "description_length": 597,
      "index": 44,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Bap_core_theory.Theory",
      "library": "bap-core-theory",
      "description": "This module provides semantic analysis and transformation operations for program representations, focusing on typed reasoning about machine code. It works with structured semantic terms like bitvectors, boolean expressions, memory models, and floating-point values, alongside metadata such as register aliases, calling conventions, and architecture properties. Key use cases include binary decompilation, cross-architecture analysis, formal verification of low-level code, and optimizing program transformations through theory-driven simplification and knowledge-based manipulation.",
      "description_length": 582,
      "index": 45,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bap_core_theory",
      "library": "bap-core-theory",
      "description": "This module provides typed semantic representations and operations for analyzing binary programs, including bitvector arithmetic, boolean logic, memory operations, and floating-point computations. It works with structured terms that model program values and effects, such as registers, memory states, and control flow changes. Concrete use cases include formal verification of machine code, binary decompilation, and architecture-agnostic program analysis.",
      "description_length": 456,
      "index": 46,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 47,
    "meaningful_modules": 47,
    "filtered_empty_modules": 0,
    "retention_rate": 1.0
  },
  "statistics": {
    "max_description_length": 693,
    "min_description_length": 344,
    "avg_description_length": 528.1702127659574,
    "embedding_file_size_mb": 0.6817464828491211
  }
}