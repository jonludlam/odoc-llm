{
  "package": "bap-core-theory",
  "embedding_model": "Qwen/Qwen3-Embedding-0.6B",
  "embedding_dimension": 1024,
  "total_modules": 60,
  "creation_timestamp": "2025-07-15T23:17:56.914500",
  "modules": [
    {
      "module_path": "Bap_core_theory.Theory.Parser.Grammar.Float",
      "library": "bap-core-theory",
      "description": "This module provides operations for constructing and transforming IEEE 754 floating-point expressions, including arithmetic (addition, multiplication, remainder), comparisons (min/max), conversions (casts, rounding), and control flow (ite). It works with symbolic floating-point expressions (`exp`), scoped variable bindings, and rounding modes (`rmode`), enabling structured parsing of untyped BIL-style ASTs into typed Core Theory terms. It is particularly useful for representing and analyzing floating-point computations in low-level languages or binary code where precise semantic modeling of floating-point behavior is required.",
      "description_length": 634,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bap_core_theory.Theory.Value.Sort.Top",
      "library": "bap-core-theory",
      "description": "This module enables manipulation of type-erased value sorts through comparison, ordering, and serialization operations, supporting use in monomorphic data structures like sets and maps. It works with static value representations such as bitvectors, floating-point formats, and memory sorts, preserving their erased type indices while allowing refinement later. Specific use cases include constructing unified collections of heterogeneous sorts and performing bounds checks or clamping operations during semantic analysis of expressions.",
      "description_length": 536,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bap_core_theory.Theory.Parser.Grammar.Rmode",
      "library": "bap-core-theory",
      "description": "This module defines operations for parsing and representing rounding modes in BIL-style intermediate languages. It provides specific functions to map untyped language constructs to Core Theory's `rmode` type, supporting constants like `rne`, `rtz`, `rtp`, `rtn`, and `rna`. Use this module when implementing a parser for a target language that includes floating-point rounding mode specifications.",
      "description_length": 397,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bap_core_theory.Theory.Parser.Grammar.Mem",
      "library": "bap-core-theory",
      "description": "This module provides operations for constructing and manipulating memory terms in a BIL-style intermediate language, including functions for memory stores, variable declarations, conditional expressions, and scoped bindings. It works with untyped abstract syntax trees (ASTs) and maps them to Core Theory memory terms with specific type parameters. Concrete use cases include parsing low-level code into typed memory operations for analysis, handling memory effects in instruction semantics, and building memory models for binary translation.",
      "description_length": 542,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bap_core_theory.Theory.Parser.Grammar.Stmt",
      "library": "bap-core-theory",
      "description": "The module constructs statements for memory, register, and control flow operations, translating untyped BIL-like constructs into typed Core Theory effects. It operates on expressions, effect terms, and low-level data types such as words and rounding modes, enabling structured control flow and state manipulation. This facilitates parsing intermediate representations into analyzable Core Theory terms for binary program verification and disassembly tasks.",
      "description_length": 456,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bap_core_theory.Theory.Parser.Grammar.Bool",
      "library": "bap-core-theory",
      "description": "This module enables parsing untyped expressions into boolean terms and comparison operations for BIL-style intermediate languages, supporting logical operations, memory/bit extractions, and both integer and floating-point condition checks. It operates on untyped `exp` expressions to produce boolean results (`t`), handling use cases like control-flow condition translation, floating-point property checks (e.g., NaN detection), and mapping low-level comparisons to Core Theory's typed terms. Key applications include parsing BIL's conditional statements and arithmetic predicates into the Core Theory's formal representation.",
      "description_length": 626,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bap_core_theory.Theory.Value.Sort.Name",
      "library": "bap-core-theory",
      "description": "This module manages unique symbolic names for value sorts, ensuring their uniqueness and providing comparison operations. It supports declaring new names with optional package scoping and offers total ordering and equality checks. Use cases include defining distinct identifiers for custom value sorts and enforcing name-based constraints in sort hierarchies.",
      "description_length": 359,
      "index": 6,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Bap_core_theory.Theory.Parser.Grammar.Bitv",
      "library": "bap-core-theory",
      "description": "This module provides functions to parse arithmetic, bitwise logic, and type conversion operations on bitvectors from BIL-style intermediate language expressions. It operates on untyped abstract syntax trees (ASTs), mapping them to typed bitvector terms (`t`) while handling memory accesses, variable references, and conditional scoping. Its primary use case involves translating low-level code representations into formal semantic models for verification and binary analysis tasks.",
      "description_length": 481,
      "index": 7,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Bap_core_theory.Theory.Value.Sort",
      "library": "bap-core-theory",
      "description": "This module represents and manipulates value sorts with static properties like bitvector widths or floating-point formats, supporting precise semantic definitions for expressions. It provides operations to construct and inspect sorts directly, such as defining numeric sorts with `int`, composing them using `app`, and decomposing with `hd` and `tl`, while its child modules enable type-erased comparisons and symbolic naming. The type-erased manipulation allows working with heterogeneous sorts in monomorphic structures like sets and maps, and the naming system ensures unique identifiers for custom sorts with total ordering. Example uses include defining `Bitv(i)` for bitvectors, building memory sorts like `Mem(Bitv(i), Bitv(j))`, and managing symbolic sort names with scoped uniqueness.",
      "description_length": 793,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bap_core_theory.Theory.Float.Format",
      "library": "bap-core-theory",
      "description": "This module defines and manipulates sorts for floating-point number representations, using bitvectors to specify their structure. It provides operations to define a floating-point sort from a bitvector sort and an interpretation, extract the underlying bitvector sort, and retrieve the expression interpreting the bitvector. Concrete use cases include specifying IEEE 754 floating-point formats and custom floating-point encodings for formal verification tasks.",
      "description_length": 461,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bap_core_theory.Theory.Role.Register",
      "library": "bap-core-theory",
      "description": "This module defines constants for classifying registers and variables into semantic categories such as general-purpose, special-purpose, function arguments, saved registers, and architecture-specific roles. It operates on program entities within the BAP framework, using extensible enumerations to enable precise analysis of low-level code across diverse targets. These classifications support compiler optimizations, reverse engineering, and target-specific extensions through libraries that define architecture-dependent roles.",
      "description_length": 529,
      "index": 10,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Bap_core_theory.Theory.Basic.Make",
      "library": "bap-core-theory",
      "description": "This module provides low-level bitvector arithmetic, boolean logic, and memory manipulation operations, including signed/unsigned comparisons, shifts, casts, and conditional branching. It operates on bitvectors of arbitrary width and memory structures, enabling precise modeling of machine-level computations and state transitions. These capabilities are specifically used for binary analysis, formal verification of program semantics, and structured effect sequencing in emulated environments.",
      "description_length": 494,
      "index": 11,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bap_core_theory.Theory.Effect.Sort",
      "library": "bap-core-theory",
      "description": "This module defines and manipulates effect sorts that classify static properties of program effects, distinguishing between data and control effects. It provides constructors for primitive effects like memory and register reads/writes, control flow operations, and combinators to build compound effects using intersection and union. Concrete use cases include modeling the static effect of reading from a register, representing control flow changes from jumps, and combining multiple effects into a single effect sort for analysis.",
      "description_length": 531,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bap_core_theory.Theory.Value.Top",
      "library": "bap-core-theory",
      "description": "This module enables order relations and comparisons for semantically denoted values with erased sort type indices, supporting operations like equality checks, min/max determination, and clamping within bounds. It works with abstracted `t` values derived from BAP expression semantics, which encapsulate erased-type data while retaining core properties. Key use cases include type-erased value manipulation in analysis pipelines, binary serialization/deserialization via Bin_prot, and scenarios requiring polymorphic value handling without sort-specific constraints.",
      "description_length": 565,
      "index": 13,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bap_core_theory.Theory.Var.Ident",
      "library": "bap-core-theory",
      "description": "This module provides operations for serializing, converting, and comparing variable identifiers with a structured, caseless ordering. It works with `ident t` values, which represent variables in a hierarchy where virtual variables precede physical ones, mutable virtual variables precede immutable ones, and versioned or numeric variables are ordered by their version numbers or numeric values. These operations are essential for tasks like semantic analysis, where consistent variable ordering is required for comparisons, optimizations, or generating canonical forms of intermediate representations.",
      "description_length": 601,
      "index": 14,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Bap_core_theory.Theory.Parser.Make",
      "library": "bap-core-theory",
      "description": "This module implements a recursive-descent parser that maps untyped BIL-style ASTs into typed Core Theory terms, supporting six core term sorts: bitv, bool, mem, stmt, float, and rmode. It works with untyped language representations and generates parsers that translate them into structured terms of a specified theory. Concrete use cases include parsing BIL or similar intermediate languages into typed semantic expressions for analysis or transformation.",
      "description_length": 456,
      "index": 15,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bap_core_theory.Theory.Documentation.Theory",
      "library": "bap-core-theory",
      "description": "This module represents and manages documentation for theories, including their names, descriptions, required dependencies, and provided capabilities. It works with theory documentation structures that capture metadata about semantic theories. Use it to retrieve and inspect theory details like dependencies and functionality in BAP's core semantics framework.",
      "description_length": 359,
      "index": 16,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Bap_core_theory.Theory.Var.Top",
      "library": "bap-core-theory",
      "description": "This module provides comparison and serialization operations for variables with erased sort indices, enabling their use in ordered collections like sets by comparing only their identifiers. It works with variables whose equality and ordering ignore sort differences, treating same-named variables as equivalent regardless of their original types. Key applications include constructing sets or ordered data structures where variable identity is determined solely by names, not sorts, with support for serialization and order-preserving operations like `max` or `clamp`.",
      "description_length": 568,
      "index": 17,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bap_core_theory.Theory.Parser.Grammar",
      "library": "bap-core-theory",
      "description": "This module defines grammars for parsing untyped BIL-style languages into Core Theory terms across six term sorts\u2014bitv, bool, mem, stmt, float, and rmode\u2014using recursive-descent parsing rules that map language constructs to typed semantic actions. It coordinates with child modules that handle specific term constructions, such as floating-point expressions, rounding modes, memory operations, boolean logic, bitvector arithmetic, and structured control flow, all operating on untyped ASTs to produce typed Core Theory terms. Main data types include `exp` for expressions, `rmode` for rounding modes, `t` for bitvectors and booleans, and effect-laden `stmt` for memory and control operations, with operations like variable binding, scoped transformations, and semantic lifting of low-level constructs. Examples include translating BIL-like conditionals into Core Theory boolean terms, modeling memory effects from binary code, and parsing floating-point operations with rounding mode handling for formal verification.",
      "description_length": 1017,
      "index": 18,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bap_core_theory.Theory.Pass.Desugar",
      "library": "bap-core-theory",
      "description": "This module provides desugaring transformations that normalize symbolic expressions, resolve register aliasing, and simplify control flow structures by translating high-level operations into primitive forms. It operates on bitvectors, booleans, floating-point values, memory states, and effectful computations, enabling formal verification tasks like constant propagation, zero-register concretization, and modular arithmetic analysis. The desugaring pass is particularly used to preprocess theories before analysis, ensuring consistent representation of low-level semantics while supporting custom transformations of symbolic programs.",
      "description_length": 636,
      "index": 19,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Bap_core_theory.Theory.Basic.Empty",
      "library": "bap-core-theory",
      "description": "This theory defines symbolic representations of low-level machine operations, including arithmetic, bitwise logic, memory access, and control flow, all expressed as pure, unevaluated terms forming an abstract syntax tree. It operates on bitvectors, memory models, and boolean expressions, enabling formal reasoning about binary programs through symbolic manipulation rather than concrete execution. Its primary use case involves foundational modeling for binary analysis tasks like symbolic execution and formal verification of machine-code semantics.",
      "description_length": 551,
      "index": 20,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Bap_core_theory.Theory.IEEE754.Sort",
      "library": "bap-core-theory",
      "description": "This module defines operations to construct and manipulate IEEE754 floating-point sorts, including extracting exponent, significand, and storage bitvector sorts, as well as retrieving encoding parameters. It works with indexed sorts representing IEEE754 formats, parameterized by bitvector types. Concrete use cases include defining custom floating-point representations and analyzing or manipulating floating-point data in binary programs.",
      "description_length": 440,
      "index": 21,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bap_core_theory.Theory.Target.Options",
      "library": "bap-core-theory",
      "description": "This module provides operations to manage extensible target configuration options, including creating, serializing, comparing, and clamping sets of properties that define execution environments. It works with `Bap_core_theory.Theory.Target.Options.t` values\u2014structured as `KB.Value.t`\u2014to represent domain-specific attributes like CPU features, ABI constraints, or microarchitectural details. These capabilities enable use cases such as persisting target descriptions across BAP versions, dynamically extending target metadata, and normalizing divergent hardware/software configurations during program analysis.",
      "description_length": 610,
      "index": 22,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bap_core_theory.Theory.Value.Match",
      "library": "bap-core-theory",
      "description": "This module provides an embedded domain-specific language for pattern matching and refining value sorts in semantic analysis. It supports operations like `can` for conditional refinement of values based on sort descriptors, and `both` for parallel refinement of multiple values, enabling precise dispatch on complex value types. It is used to implement logic that reacts to the specific static properties of evaluated expressions, such as bitvector widths or floating-point formats, within BAP's semantic framework.",
      "description_length": 515,
      "index": 23,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bap_core_theory.Theory.Value",
      "library": "bap-core-theory",
      "description": "This module represents semantically denoted values with static sort information, enabling creation, inspection, and transformation based on properties like bitvector sizes or floating-point formats. It supports typed operations on values within a shared knowledge class, such as constructing empty values, refining sorts during evaluation, and erasing type indices for polymorphic handling, with direct use in BIL expression denotations. The sort module allows construction and decomposition of static value types, including numeric and composite sorts, while the compare module enables type-erased ordering and equality checks on abstracted values. Use cases include defining bitvector and memory sorts, performing type-agnostic comparisons, and refining value semantics using pattern-based rules in analysis pipelines.",
      "description_length": 820,
      "index": 24,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bap_core_theory.Theory.Basic",
      "library": "bap-core-theory",
      "description": "This module formalizes core operations for symbolic bitvector manipulation, memory access, and control flow structuring in a machine model, combining low-level arithmetic, bitwise logic, and memory operations with symbolic representations of machine semantics. It supports signed and unsigned arithmetic, shifts, casts, boolean logic, and structured branching over bitvectors and memory states, enabling precise modeling of low-level computations and symbolic reasoning. The module's API allows direct manipulation of bitvectors and memory, while its submodules provide symbolic term representations for formal verification and binary analysis tasks like symbolic execution. Example uses include modeling machine instructions, verifying program semantics, and analyzing binary code through structured effect sequencing and abstract syntax tree manipulation.",
      "description_length": 857,
      "index": 25,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bap_core_theory.Theory.Fabi",
      "library": "bap-core-theory",
      "description": "This module introduces an enumeration type for managing floating-point binary interface (FABI) conventions, offering comparison, ordering, and serialization operations. It includes predefined values `hard` and `soft` to specify hardware-accelerated or software-emulated floating-point handling, primarily used to model compiler and runtime behavior in binary analysis or toolchain development.",
      "description_length": 393,
      "index": 26,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bap_core_theory.Theory.Unit",
      "library": "bap-core-theory",
      "description": "This module provides operations for creating and managing code units, which represent structured regions of code such as files or memory segments with metadata like paths, addresses, and compiler information. It supports comparison logic, ordering operations, and binary serialization (via Bin_prot) for use in analysis workflows that require precise partitioning and persistence of code fragments. Key applications include binary analysis frameworks where distinct instruction sets must be organized, compared, or serialized for tasks like reverse engineering or program verification.",
      "description_length": 585,
      "index": 27,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bap_core_theory.Theory.Semantics",
      "library": "bap-core-theory",
      "description": "This module defines operations for comparing, serializing, and managing empty semantics values represented as effect-based semantics (Semantics.t), which encapsulate program semantics, effect values, and code representations. It provides utilities for ordering semantics (e.g., ascending/descending comparisons) and Bin_prot serialization for persistent storage or transmission, enabling use cases like program analysis, optimization, and formal verification. The inclusion of comparator witnesses and domain-specific serialization logic supports efficient handling of semantic data in both memory-constrained and distributed systems.",
      "description_length": 634,
      "index": 28,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bap_core_theory.Theory.Filetype",
      "library": "bap-core-theory",
      "description": "This module manages enumerated file type values, enabling equality checks, comparison, serialization, and conversions to strings or S-expressions. It defines a `filetype` type with predefined constants like `elf`, `coff`, and `macho` to represent executable file formats, alongside utilities for handling unknown values. These features are used in binary analysis workflows to identify or specify binary file formats during program processing or semantic modeling.",
      "description_length": 464,
      "index": 29,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Bap_core_theory.Theory.IEEE754",
      "library": "bap-core-theory",
      "description": "This module implements IEEE754 floating-point formats through a set of indexed sorts and parameterized bitvector types, enabling precise modeling of floating-point operations in semantic analysis. It provides predefined formats like `binary32` and `decimal64`, along with functions to generate format parameters by size, supporting both binary and decimal variants. Child modules extend this functionality with operations to construct and manipulate floating-point sorts, including extracting exponent and significand components or retrieving encoding details. Together, they allow users to define custom floating-point representations and analyze or transform floating-point data in low-level programs.",
      "description_length": 703,
      "index": 30,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Bap_core_theory.Theory.Compiler",
      "library": "bap-core-theory",
      "description": "This module enables comparison and ordering of compiler metadata values, supporting operations like equality checks, min/max determination, and clamping, while also facilitating structured manipulation of compiler descriptors. It works with compiler-specific data such as name, version, compilation options, and string-mapped specs, alongside binary serialization and pretty-printing capabilities. It is particularly useful in semantic analysis workflows where precise tracking of compilation provenance or cross-referencing of compiler configurations is required, such as in binary translation or program verification tasks.",
      "description_length": 625,
      "index": 31,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Bap_core_theory.Theory.System",
      "library": "bap-core-theory",
      "description": "This module provides operations to define and manipulate operating system models through an enumerated type, supporting tasks like declaring named elements, testing unknown status, and comparing values with functions such as `ascending` or `clamp`. It works with system values represented as an enumerated type, augmented with domain properties and persistence metadata, alongside predefined constants for common OS environments like Linux, Darwin, and Windows. These features enable binary analysis workflows where target platforms must be classified or platform-specific behaviors modeled, such as cross-system compatibility checks or OS-aware disassembly.",
      "description_length": 658,
      "index": 32,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bap_core_theory.Theory.Minimal",
      "library": "bap-core-theory",
      "description": "This module provides foundational operations for symbolic computation and low-level program semantics, including bitvector arithmetic, memory manipulation, conditional branching, and control-flow primitives. It works with bitvectors, boolean values, memory states, and effect types to model data transformations and program behavior in formal verification or binary analysis scenarios. Specific capabilities include signed/unsigned arithmetic, bitwise operations, memory access, and effect composition for branching logic in stateful computations.",
      "description_length": 547,
      "index": 33,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Bap_core_theory.Theory.Origin",
      "library": "bap-core-theory",
      "description": "This module defines the relationship between aliased registers and their origin registers using the parameterized `Origin.t` type. It supports two kinds of relationships: `sub` for subsets of a single register and `sup` for supersets formed by concatenating multiple registers. Key operations include extracting the base register, checking if a register is an alias, and retrieving bit ranges or constituent registers for subset and superset relationships, respectively.",
      "description_length": 470,
      "index": 34,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bap_core_theory.Theory.Trans",
      "library": "bap-core-theory",
      "description": "This module provides transcendental mathematical operations on floating-point numbers, including exponential, logarithmic, trigonometric, hyperbolic, and their inverse functions, all configurable with rounding modes for precision control. It operates on `float` values and `rmode` (rounding mode) parameters, enabling precise numerical computations with customizable error handling. These functions are essential for applications requiring high-accuracy arithmetic in scientific computing, formal verification, or numerical analysis where rounding behavior must be explicitly managed.",
      "description_length": 584,
      "index": 35,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Bap_core_theory.Theory.Label",
      "library": "bap-core-theory",
      "description": "The module provides operations to create and manipulate program labels that uniquely identify locations in a program's semantic representation. It works with `Label.t` values, which encapsulate properties like addresses, names, encoding, and compilation unit associations, supporting use cases such as semantic analysis, binary serialization, and label comparison for ordered collections. Functions include creating labels from addresses or interrupt vectors, querying metadata, and efficient binary serialization for storage or transmission.",
      "description_length": 542,
      "index": 36,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bap_core_theory.Theory.Bool",
      "library": "bap-core-theory",
      "description": "This module defines the boolean sort and operations for working with one-bit boolean values in the BAP semantics representation. It provides the type `t` for boolean values, the `t` function to access the boolean sort, and the `refine` function to check and convert a value sort to the boolean sort. It is used to represent and manipulate boolean expressions in BAP's intermediate representation, such as modeling program conditions and control flow decisions.",
      "description_length": 460,
      "index": 37,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Bap_core_theory.Theory.Memory",
      "library": "bap-core-theory",
      "description": "This module defines operations for manipulating memory structures with typed keys and values. It provides `load` and `store` functions to retrieve and update values at specific memory addresses, represented as bitvectors. Use cases include modeling low-level memory access in program analysis and simulating memory state transitions during instruction execution.",
      "description_length": 362,
      "index": 38,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Bap_core_theory.Theory.Parser",
      "library": "bap-core-theory",
      "description": "This module generates recursive-descent parsers that translate untyped BIL-style ASTs into typed Core Theory terms across six term sorts: bitv, bool, mem, stmt, float, and rmode. It processes untyped input languages by mapping their constructs to typed semantic representations, enabling formal analysis or transformation. Key data types include `exp` for expressions, `rmode` for rounding modes, `t` for bitvectors and booleans, and `stmt` for effectful operations like memory and control flow. Examples include parsing BIL conditionals into boolean terms, modeling memory effects from binary code, and translating floating-point operations with rounding mode handling for verification.",
      "description_length": 687,
      "index": 39,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bap_core_theory.Theory.Mem",
      "library": "bap-core-theory",
      "description": "This module defines and manipulates memory sorts as associative containers mapping bitvectors to bitvectors. It provides operations to define memory types with specified key and value sorts, refine existing sorts into memory sorts, and retrieve key and value sorts from memory sorts. Concrete use cases include modeling memory state in program analysis and defining memory transformations in binary semantics.",
      "description_length": 409,
      "index": 40,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bap_core_theory.Theory.Bitv",
      "library": "bap-core-theory",
      "description": "This module supports arithmetic, bitwise, and shift operations on typed bitvectors (`bitv`) parameterized by their sort, with arithmetic performed modulo bitwidth and explicit handling of signed/unsigned comparisons. It provides structured composition through concatenation and appending of bitvectors, ensuring sort-directed casting during combination. These capabilities are designed for precise semantic modeling in binary analysis, enabling formal verification tasks like symbolic execution and low-level program reasoning where rigorous bitvector semantics are required.",
      "description_length": 575,
      "index": 41,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bap_core_theory.Theory.Rmode",
      "library": "bap-core-theory",
      "description": "This module defines the type `t` representing rounding modes used in floating-point operations and provides the `refine` function to restore the specific rounding mode type from a generic value sort. It works with the `Value.sort` type to ensure correct typing during semantic analysis. Concrete use cases include specifying rounding behavior in floating-point arithmetic and validating rounding mode constraints in BAP's intermediate representation.",
      "description_length": 450,
      "index": 42,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Bap_core_theory.Theory.Language",
      "library": "bap-core-theory",
      "description": "This module enables the declaration, comparison, and serialization of named programming languages within an enumeration, operating on `Language.t` values that represent source code languages like C, Ada, and Fortran. It provides ordering operations (e.g., `ascending`, `between`), equality checks, and persistence integration via binary/S-expression formats, supporting use cases in program analysis tools where precise language identification and cross-representation consistency are critical. Predefined constants simplify referencing common languages in tooling workflows.",
      "description_length": 575,
      "index": 43,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Bap_core_theory.Theory.Target",
      "library": "bap-core-theory",
      "description": "This module models execution environments with structured target descriptors that capture architectural and microarchitectural properties such as endianness, bitness, and ABI conventions. It provides operations to query, compare, and manipulate these descriptors, supporting tasks like target selection, serialization, and dependency resolution across platforms. Child modules extend functionality with configurable options represented as structured values, enabling dynamic attribute management and cross-version persistence. Examples include resolving CPU-specific behaviors during binary translation or normalizing memory alignment settings for analysis pipelines.",
      "description_length": 667,
      "index": 44,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bap_core_theory.Theory.Var",
      "library": "bap-core-theory",
      "description": "This module manages typed variables with support for creation, inspection, and transformation, incorporating structured identifiers and sort relationships. It enables precise control over variable properties like mutability and scope, while its child modules provide ordering and serialization for both structured identifiers and sort-erased variables. Operations include comparing variables based on name or version, constructing canonical forms, and building ordered collections that treat variables equivalently regardless of type. Use cases include formal analysis, program optimization, and serialization where consistent variable representation and ordering are critical.",
      "description_length": 677,
      "index": 45,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bap_core_theory.Theory.Source",
      "library": "bap-core-theory",
      "description": "This module supports comparison, serialization, and metadata management for source code artifacts represented as `Source.t` values within BAP's Knowledge Base (KB). It operates on extensible `KB.Value.t` structures, enabling properties like source language, file name, and text content to be stored, retrieved, and compared, with use cases in program analysis tools that track compilation unit artifacts. The module facilitates integration with BAP's domain system by providing total ordering, binary persistence, and S-expression serialization for these artifacts.",
      "description_length": 565,
      "index": 46,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bap_core_theory.Theory.Empty",
      "library": "bap-core-theory",
      "description": "This module defines foundational operations for bitvector and boolean expressions, including arithmetic, bitwise logic, memory access, and control-flow primitives like jumps and sequencing. It operates on typed bitvectors, floating-point numbers, memory, and effect types, supporting precise numeric representations, IEEE-compliant floating-point arithmetic, and low-level program semantics modeling. These capabilities are used in binary analysis, formal verification, and compiler optimizations where accurate manipulation of data and control flow is critical.",
      "description_length": 562,
      "index": 47,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bap_core_theory.Theory.Init",
      "library": "bap-core-theory",
      "description": "This module defines fundamental operations for constructing and manipulating symbolic expressions in a semantic representation. It provides functions to reference variable values, create unknown values of a specified sort, bind expressions to variables, and conditionally select values based on boolean expressions. These operations are used to build and reason about low-level program semantics, such as modeling register values, memory states, and control flow conditions in binary analysis.",
      "description_length": 493,
      "index": 48,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bap_core_theory.Theory.Alias",
      "library": "bap-core-theory",
      "description": "This module provides operations to define and manipulate register aliasing relationships using a domain-specific language. It works with register variables and part lists to express concatenations and subparts of CPU registers, such as defining a register as a composition of smaller parts or referencing specific segments of larger registers. Concrete use cases include modeling x86-style register subparts (like AH within RAX) or AVR-style register pairs (like Y composed of R19 and R18).",
      "description_length": 490,
      "index": 49,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bap_core_theory.Theory.Effect",
      "library": "bap-core-theory",
      "description": "This module formalizes computational effects within a semantic framework, enabling precise modeling of low-level behaviors through operations like state updates, control transfers, and structured execution. It introduces typed variables, labels, and conditions to represent effects such as memory and register modifications, while supporting composition via sequencing, branching, and loops. The effect sort system classifies and combines data and control effects using intersection and union, allowing analysis of compound behaviors like combined memory access and control flow changes. Examples include tracking register writes alongside conditional jumps or analyzing the combined effect of a loop that modifies state and branches based on runtime values.",
      "description_length": 758,
      "index": 50,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bap_core_theory.Theory.Documentation",
      "library": "bap-core-theory",
      "description": "This module organizes and exposes theory documentation, providing a structured way to access and inspect semantic theories in BAP. It includes the `theories` function, which returns a list of documented theories represented by the `Theory.t` type, capturing their metadata, dependencies, and capabilities. Child modules enhance this functionality by managing detailed documentation structures, allowing users to query specific aspects like required dependencies or provided features. Use this module to generate reports or analyze the formal semantics that underpin BAP's behavior.",
      "description_length": 581,
      "index": 51,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Bap_core_theory.Theory.Program",
      "library": "bap-core-theory",
      "description": "This module provides operations for comparing, ordering, and serializing program semantics represented as abstract values associated with control flow labels. It works with `Program.t` values, which model program semantics linked to labels, enabling precise control flow modeling and integration with knowledge domains through clamping, comparison, and binary serialization capabilities. These features are utilized in semantic analysis, program reasoning, and scenarios requiring bounded value manipulation or persistent storage of semantic representations.",
      "description_length": 558,
      "index": 52,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bap_core_theory.Theory.Endianness",
      "library": "bap-core-theory",
      "description": "This module provides operations to manage endianness as an extensible enumeration, supporting equality checks, ordering comparisons, and serialization to formats like S-expressions and binary. It works with a polymorphic `endianness` type representing byte-ordering strategies, including predefined variants for big endian, little endian, and bi-endian storage. These capabilities are used to model memory layout conventions for multibyte data in cross-platform binary analysis and low-level system interactions.",
      "description_length": 512,
      "index": 53,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Bap_core_theory.Theory.Pass",
      "library": "bap-core-theory",
      "description": "This module implements desugaring transformations that normalize symbolic expressions, resolve register aliases, and simplify control flow by translating high-level constructs into primitive operations. It operates on bitvectors, booleans, floating-point values, memory states, and effectful computations, supporting tasks like constant propagation, zero-register concretization, and modular arithmetic analysis. These transformations preprocess theories for formal verification, ensuring a consistent low-level semantic representation while allowing custom symbolic program transformations. Example uses include converting complex expressions into basic arithmetic operations and resolving indirect register references into direct accesses.",
      "description_length": 741,
      "index": 54,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bap_core_theory.Theory.Float",
      "library": "bap-core-theory",
      "description": "This module combines floating-point sort definitions with bitvector-based representations to enable precise modeling of numeric formats like IEEE 754. It supports creating and refining floating-point sorts from bitvectors, extracting format details, and accessing underlying bitvector structures. Operations include defining custom floating-point encodings, converting between bitvector and floating-point sorts, and analyzing floating-point behavior in program verification. Example uses include specifying 32-bit and 64-bit floating-point formats and enabling bit-level reasoning in static analysis tools.",
      "description_length": 607,
      "index": 55,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bap_core_theory.Theory.Core",
      "library": "bap-core-theory",
      "description": "This module enables symbolic computation and manipulation of low-level program semantics through foundational operations on booleans, bitvectors, memory, and floating-point values. It supports arithmetic, bitwise logic, control-flow branching, and memory access for bitvector and boolean types, alongside precise floating-point conversions, mathematical functions, and rounding mode management. These capabilities are applied in binary analysis, program verification, and modeling numeric behaviors in software systems.",
      "description_length": 519,
      "index": 56,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Bap_core_theory.Theory.Role",
      "library": "bap-core-theory",
      "description": "This module provides an extensible system for representing and manipulating target-specific roles of program entities such as variables and registers. It defines an abstract type `t` for roles, supporting operations like declaration, comparison, and serialization to strings or S-expressions, enabling consistent role handling across program analysis tasks. The child module supplies predefined constants for common semantic categories, including general-purpose and special-purpose registers, function arguments, and saved registers, facilitating precise analysis and transformation of low-level code. Together, they allow developers to classify entities, persist role metadata, and extend role sets for architecture-specific use cases like binary translation and reverse engineering.",
      "description_length": 785,
      "index": 57,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Bap_core_theory.Theory",
      "library": "bap-core-theory",
      "description": "This module structures program semantics modeling with abstractions for boolean logic, bitvector arithmetic, memory states, and effects, while enabling symbolic computation, low-level program reasoning, and binary analysis. It provides core data types such as typed bitvectors, memory sorts, floating-point formats, and effect-based semantics, alongside operations for value creation, refinement, comparison, and transformation, supporting tasks like instruction modeling, symbolic execution, and program verification. Child modules extend this foundation with specialized capabilities including register aliasing, compiler metadata handling, endianness modeling, and floating-point transcendental functions, enabling precise semantic analysis across diverse architectures and toolchains. Example uses include formalizing machine instruction semantics, tracking compiler provenance, and performing architecture-aware binary transformations.",
      "description_length": 940,
      "index": 58,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bap_core_theory",
      "library": "bap-core-theory",
      "description": "This module provides a semantic framework for modeling program behavior with precise abstractions over bitvector arithmetic, memory states, boolean logic, and computational effects. It defines core data types such as typed bitvectors, memory sorts, and floating-point formats, along with operations for symbolic computation, value transformation, and effect tracking. You can use it to formalize instruction semantics, perform symbolic execution, verify program properties, and analyze binary code across different architectures. Specific applications include modeling machine instructions, tracking compiler transformations, and enabling architecture-aware binary analysis.",
      "description_length": 674,
      "index": 59,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 62,
    "meaningful_modules": 60,
    "filtered_empty_modules": 2,
    "retention_rate": 0.967741935483871
  },
  "statistics": {
    "max_description_length": 1017,
    "min_description_length": 359,
    "avg_description_length": 578.1,
    "embedding_file_size_mb": 0.21828365325927734
  }
}