{
  "package": "ppx_css",
  "embedding_model": "Qwen/Qwen3-Embedding-8B",
  "embedding_dimension": 4096,
  "total_modules": 56,
  "creation_timestamp": "2025-08-15T14:44:06.233850",
  "modules": [
    {
      "module_path": "Css_jane.Dimension",
      "library": "ppx_css.css_jane",
      "description": "This module defines a variant type `t` representing CSS dimension types, including length, angle, time, and frequency. It provides a function `sexp_of_t` to convert these dimension values into S-expressions for serialization or debugging. This module is used to handle and distinguish between different CSS unit categories in a type-safe manner.",
      "description_length": 345,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Css_jane.Rule",
      "library": "ppx_css.css_jane",
      "description": "This module represents CSS rules, which can be either style rules or at-rules, using a variant type. It provides a function to convert these rule types into S-expressions for serialization or debugging. It is used when generating or manipulating CSS structures programmatically, such as in CSS preprocessors or style generators.",
      "description_length": 328,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Css_jane.Declaration",
      "library": "ppx_css.css_jane",
      "description": "This module represents CSS declarations, including the property name, value components, and the `important` flag, each annotated with source locations. It provides a structured way to access and manipulate individual parts of a CSS declaration, such as extracting the property name or checking if `!important` is specified. Concrete use cases include parsing and transforming CSS rules, analyzing stylesheet structure, and generating source location-aware CSS output.",
      "description_length": 467,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Css_jane.Style_rule",
      "library": "ppx_css.css_jane",
      "description": "Handles parsing and manipulation of CSS style rules, including selectors and associated declaration blocks. Works with structured CSS components like component values, declaration lists, and source locations. Used to represent and serialize complete CSS rules for analysis or transformation tasks.",
      "description_length": 297,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Css_jane.At_rule",
      "library": "ppx_css.css_jane",
      "description": "Represents CSS at-rules with parsed components including name, prelude values, and block content, each annotated with source locations. Provides serialization to S-expressions for debugging or configuration purposes. Used to model structured CSS directives like `@media` or `@keyframes` with precise location tracking.",
      "description_length": 318,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Css_jane.Component_value",
      "library": "ppx_css.css_jane",
      "description": "This module represents and manipulates CSS component values, including identifiers, strings, numbers, percentages, and complex structures like function calls and bracketed blocks. It supports parsing and constructing CSS values with location tracking for error reporting. Use this module to build or analyze CSS values with precise syntax and structure, such as handling `url()`, `rgb()`, or media query expressions.",
      "description_length": 416,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Css_jane.Declaration_list",
      "library": "ppx_css.css_jane",
      "description": "Handles lists of CSS declarations, at-rules, and style rules with location tracking. Provides S-expression conversion for serialization and debugging. Useful for building and manipulating structured CSS AST nodes with precise source locations.",
      "description_length": 243,
      "index": 6,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Css_jane.Stylesheet",
      "library": "ppx_css.css_jane",
      "description": "This module represents and manipulates CSS stylesheets as lists of rules with source location information. It provides functions to serialize stylesheets to human-readable or minified strings, parse them from strings with optional source positions, and convert them to S-expressions. It is used to programmatically generate, transform, and analyze CSS in both development and build tools.",
      "description_length": 388,
      "index": 7,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Css_jane.Brace_block",
      "library": "ppx_css.css_jane",
      "description": "Represents CSS block structures like empty blocks, declaration lists, and nested stylesheets. Provides `sexp_of_t` to convert block values to S-expressions for serialization or debugging. Useful for building and inspecting CSS AST nodes in OCaml programs.",
      "description_length": 255,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Css_jane",
      "library": "ppx_css.css_jane",
      "description": "This module provides precise parsing, manipulation, and serialization of CSS structures with strong type safety and source location tracking. It includes variants and operations for CSS dimensions, component values, declarations, rules, and stylesheets, enabling structured access to CSS syntax elements. Concrete use cases include building CSS preprocessors, linters, transformers, and tools requiring accurate CSS analysis or generation.",
      "description_length": 439,
      "index": 9,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Css_parser.Types.Rule",
      "library": "ppx_css.css_parser",
      "description": "This module defines a variant type `t` that represents CSS rules, either as style rules or at-rules. It works with structured CSS data, enabling precise parsing and manipulation of stylesheet components. Use this module to distinguish and handle different types of CSS rules in a type-safe manner during stylesheet processing.",
      "description_length": 326,
      "index": 10,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Css_parser.Types.Component_value",
      "library": "ppx_css.css_parser",
      "description": "This module defines a variant type `t` representing individual CSS component values, such as identifiers, strings, numbers, operators, and structured blocks like parentheses or brackets. It includes constructors for handling CSS-specific syntax elements like hashes, URIs, functions, and dimensions, each optionally carrying location information for parsing and error reporting. This module is used to represent and manipulate low-level CSS values during stylesheet parsing and transformation tasks.",
      "description_length": 499,
      "index": 11,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Css_parser.Types.At_rule",
      "library": "ppx_css.css_parser",
      "description": "This module defines the structure of an at-rule in CSS parsing, including the name, prelude, and block. It provides operations to construct and manipulate at-rules with associated source locations. Use this module to represent and process CSS at-rules like `@media` or `@keyframes` with precise location tracking.",
      "description_length": 313,
      "index": 12,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Css_parser.Types.Declaration_list",
      "library": "ppx_css.css_parser",
      "description": "Handles parsing and representation of CSS declaration lists, including individual declarations, at-rules, and style rules. Works with structured types for CSS constructs, each annotated with source location information. Used to build and manipulate CSS rule sets and at-rule blocks in a typed, location-aware format.",
      "description_length": 316,
      "index": 13,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Css_parser.Types.Stylesheet",
      "library": "ppx_css.css_parser",
      "description": "Represents a parsed CSS stylesheet as a list of rules with location information. Provides operations to access and manipulate individual CSS rules, including selectors, declarations, and associated source positions. Useful for tools that analyze, transform, or generate CSS code, such as linters, formatters, or preprocessors.",
      "description_length": 326,
      "index": 14,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Css_parser.Types.Declaration",
      "library": "ppx_css.css_parser",
      "description": "This module defines a CSS declaration with fields for the property name, value components, an important flag, and source location. It works with structured CSS values like strings, numbers, and functional expressions. Use this to represent and manipulate individual CSS properties in a stylesheet or style rule.",
      "description_length": 311,
      "index": 15,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Css_parser.Types.Brace_block",
      "library": "ppx_css.css_parser",
      "description": "This module represents brace-enclosed blocks in CSS, such as rule sets or at-rules. It supports parsing and handling block contents as either empty, a list of declarations, or a nested stylesheet. It is used to model CSS syntax structures like `{ color: red }` in rules or media queries.",
      "description_length": 287,
      "index": 16,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Css_parser.Types.Style_rule",
      "library": "ppx_css.css_parser",
      "description": "Represents a CSS style rule with a prelude, a block of declarations, and a source location. It provides structured access to the components of a style rule, including the selector (prelude), property declarations, and location metadata. This type is used directly during CSS parsing and semantic analysis to process and manipulate individual style rules in a stylesheet.",
      "description_length": 370,
      "index": 17,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Css_parser.Lex_buffer",
      "library": "ppx_css.css_parser",
      "description": "This module provides a custom lexing buffer that tracks source positions and character states during lexical analysis. It wraps Sedlexing's buffer to maintain precise location information for parsing CSS input from strings or files. Key operations include character retrieval, position marking, and location-aware token tracking for accurate error reporting and source mapping.",
      "description_length": 377,
      "index": 18,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Css_parser.Parser",
      "library": "ppx_css.css_parser",
      "description": "Parses CSS stylesheets and declaration lists from strings into structured ASTs. Operates on string inputs, producing typed representations like `Stylesheet.t` and `Declaration_list.t`. Used to process raw CSS code into manipulable data structures for analysis or transformation tools.",
      "description_length": 284,
      "index": 19,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Css_parser.Lexer",
      "library": "ppx_css.css_parser",
      "description": "This component implements a CSS tokenization engine built with SEDLex, focused on character classification and state transitions for lexical analysis. It employs precomputed lookup tables and integer-encoded character mappings to recognize CSS syntax elements like identifiers, numbers, strings, and punctuation while tracking source locations. Designed for parsing CSS input streams, it handles whitespace normalization, comment stripping, URL parsing, and conversion to parser-ready tokens with positional metadata.",
      "description_length": 517,
      "index": 20,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Css_parser.Menhir_parser",
      "library": "ppx_css.css_parser",
      "description": "Parses CSS stylesheets and declaration lists from token streams generated by a lexer. It handles a wide range of CSS-specific tokens such as identifiers, numbers, dimensions, operators, and structural elements like braces and parentheses. This parser is used to convert raw CSS syntax into structured AST representations for further processing or analysis.",
      "description_length": 356,
      "index": 21,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Css_parser.Types",
      "library": "ppx_css.css_parser",
      "description": "This module defines core data types and variants for representing CSS syntax elements during parsing and manipulation. It includes types for CSS dimensions, component values, declarations, rules, and blocks, each carrying optional source location information. These structures enable precise modeling of CSS constructs like style rules, at-rules, and declaration lists, supporting tasks such as stylesheet analysis, transformation, and code generation.",
      "description_length": 452,
      "index": 22,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Css_parser",
      "library": "ppx_css.css_parser",
      "description": "This module provides precise CSS parsing capabilities through a lexing buffer that tracks source positions, a tokenizer for CSS syntax elements, and a parser that builds structured ASTs from CSS input. It handles CSS-specific constructs like identifiers, dimensions, selectors, and at-rules, producing typed representations with source location metadata. Designed for processing and analyzing CSS code in tools such as linters, transformers, and style analyzers.",
      "description_length": 462,
      "index": 23,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Ppx_css_syntax.Preprocess_arguments",
      "library": "ppx_css.syntax",
      "description": "This module manages preprocessing arguments for CSS syntax transformation, providing access to sets of strings and a map for rewrites. It allows adding values to `dont_hash`, `dont_hash_prefixes`, and `rewrite` fields, which control how CSS identifiers are processed. Use this module to configure how CSS values are rewritten or excluded during preprocessing in a Dune build system.",
      "description_length": 382,
      "index": 24,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ppx_css_syntax.String_constant",
      "library": "ppx_css.syntax",
      "description": "This module represents CSS string literals with associated source location and optional delimiter information. It provides structured access to the raw CSS content, its position in the source code, and the surrounding delimiters. This enables precise error reporting and tooling support, such as IDE features, when working with embedded CSS in OCaml code.",
      "description_length": 355,
      "index": 25,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ppx_css_syntax.Serializable_options",
      "library": "ppx_css.syntax",
      "description": "This module defines serialization options for CSS syntax processing, including rewrites, exclusions from hashing, and prefix-based exclusions. It converts S-expressions to configuration values and applies them to CSS strings to generate processed stylesheets. Concrete use cases include customizing CSS output during build-time transformations and controlling hash generation for style optimization.",
      "description_length": 399,
      "index": 26,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ppx_css_syntax",
      "library": "ppx_css.syntax",
      "description": "This module processes CSS syntax embedded in OCaml code, offering structured access to CSS strings, source locations, and rewrite rules. It supports parsing expressions into a typed representation that includes delimiters, rewrites, and hashing exclusions, enabling precise tooling integration. Concrete use cases include transforming inline CSS during compilation and configuring style processing in build systems like Dune.",
      "description_length": 425,
      "index": 27,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ppx_css.For_testing.Traverse_css.Identifier_kind.Set.Provide_hash",
      "library": "ppx_css",
      "description": "This module implements hash folding and hashing operations for sets of identifier kinds. It provides `hash_fold_t` to recursively fold over set elements during hashing and `hash` to compute a hash value for a set. These functions enable structural hashing of identifier kind sets for use in hash tables or equality checks.",
      "description_length": 322,
      "index": 28,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ppx_css.For_testing.Traverse_css.Identifier_kind.Map.Provide_bin_io",
      "library": "ppx_css",
      "description": "This module provides functions for serializing and deserializing maps where keys are of type `Key.t` and values are of a generic type `'a`. It supports binary input/output operations through the `bin_shape_t`, `bin_size_t`, `bin_write_t`, and `bin_read_t` functions, along with their associated reader and writer values. These operations enable efficient storage and transmission of map data structures in binary format, specifically for use cases involving persistent storage or network communication.",
      "description_length": 502,
      "index": 29,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ppx_css.For_testing.Traverse_css.Identifier_kind.Map.Provide_of_sexp",
      "library": "ppx_css",
      "description": "Converts S-expressions into maps where keys are of a specified identifier kind and values are derived from a provided conversion function. Works with `Sexplib0.Sexp.t` and produces maps with values of arbitrary type `'a` as long as the key type is compatible. Useful for deserializing structured configuration data where keys represent specific identifier kinds and values are parsed from S-expressions.",
      "description_length": 403,
      "index": 30,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ppx_css.For_testing.Traverse_css.Identifier_kind.Set.Elt",
      "library": "ppx_css",
      "description": "This module represents individual elements of a set used to track identifier kinds during CSS traversal. It provides functions for converting values to and from S-expressions and a comparator for ordering elements. It is used in analyzing or transforming CSS identifiers where set operations and ordered comparisons are required.",
      "description_length": 329,
      "index": 31,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ppx_css.For_testing.Traverse_css.Identifier_kind.Map.Diff",
      "library": "ppx_css",
      "description": "This module handles differencing and merging of map-like structures with identifier keys, producing optional diffs that represent changes between values. It supports operations like extracting diffs between two states, applying diffs to a base value, and combining multiple diffs into a single transformation. Concrete use cases include tracking incremental changes in CSS identifier mappings and synchronizing state between different versions of a stylesheet.",
      "description_length": 460,
      "index": 32,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ppx_css.For_testing.Traverse_css.Identifier_kind.Set.Diff",
      "library": "ppx_css",
      "description": "This module computes and applies differences between sets of CSS identifier kinds, using a diffable set structure. It supports operations to derive differences between two sets, apply those diffs to a base set, and construct diffs from lists of changes. Concrete use cases include tracking and applying incremental changes to CSS identifier sets during testing or analysis tasks.",
      "description_length": 379,
      "index": 33,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ppx_css.For_testing.Traverse_css.Identifier_kind.Map.Key",
      "library": "ppx_css",
      "description": "This module defines a key type for maps based on `Identifier_kind.t`, providing serialization to and from S-expressions and a comparator for ordering. It supports operations requiring structured keys in map-like data structures, particularly for use in analysis or transformation pipelines involving CSS identifiers. The module is useful when building or querying maps where keys are CSS identifier kinds, enabling precise key handling and comparison.",
      "description_length": 451,
      "index": 34,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ppx_css.For_testing.Traverse_css.Identifier_kind.Set.Provide_of_sexp",
      "library": "ppx_css",
      "description": "Converts S-expressions into sets of identifier kinds, specifically working with `Sexplib0.Sexp.t` input and producing values of type `Ppx_css.For_testing.Traverse_css.Identifier_kind.Set.t`. This module is used to parse and construct identifier kind sets from textual S-expression representations, typically for testing or configuration purposes. It relies on the `Elt` submodule to handle element-specific conversions.",
      "description_length": 419,
      "index": 35,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ppx_css.For_testing.Traverse_css.Identifier_kind.Map.Provide_hash",
      "library": "ppx_css",
      "description": "Implements hash folding for maps where keys are of type `Key.t` and values are of any type. This module allows generating hash values for map structures, enabling use cases like consistent hashing of CSS identifier kinds during testing or serialization. It integrates hashing logic directly over the map's key-value pairs without requiring intermediate conversions.",
      "description_length": 365,
      "index": 36,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ppx_css.For_testing.Traverse_css.Identifier_kind.Set.Provide_bin_io",
      "library": "ppx_css",
      "description": "This module provides functions for serializing and deserializing sets of `Identifier_kind` values using the Bin_prot protocol. It includes operations for computing binary size, writing to and reading from binary formats, and defining the binary shape and type class instances. Concrete use cases include persisting identifier kind sets to disk or transmitting them over a network in a compact, efficient format.",
      "description_length": 411,
      "index": 37,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ppx_css.For_testing.Traverse_css.Identifier_kind.Replace_polymorphic_compare",
      "library": "ppx_css",
      "description": "This module defines comparison operators and equality checks for the `Identifier_kind.t` type, including functions like `compare`, `equal`, `min`, and `max`. It enables direct value-level comparisons between `Identifier_kind` variants, supporting precise ordering and equality testing. Use this module when implementing or overriding default comparison logic for `Identifier_kind` values in testing or custom traversal logic.",
      "description_length": 425,
      "index": 38,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ppx_css.For_testing.Traverse_css.Identifier_kind.Map",
      "library": "ppx_css",
      "description": "This module provides operations for constructing, transforming, and merging maps with CSS identifier keys, supporting conversions from sequences, lists, and trees while handling duplicates and structural differences. It works with maps keyed by `Identifier_kind.t`, offering S-expression and binary serialization, hashing, and QuickCheck utilities for testing and random generation. These capabilities are tailored for CSS analysis pipelines requiring precise identifier tracking, configuration merging, or test data generation with structured error handling.",
      "description_length": 559,
      "index": 39,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ppx_css.For_testing.Traverse_css.Identifier_kind.Set",
      "library": "ppx_css",
      "description": "This module supports creation, transformation, and analysis of sets containing CSS identifier kinds, offering standard set operations like union, difference, map, and filter alongside conversions from lists, arrays, and hash sets. It includes utilities for serialization (S-expressions, Bin_prot), hashing, and property-based testing with Quickcheck, enabling efficient data comparison, deduplication, and structured test generation. These capabilities are particularly useful for tracking and analyzing CSS identifier relationships during traversal-based testing or static analysis workflows.",
      "description_length": 593,
      "index": 40,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ppx_css.For_testing.Traverse_css.Identifier_kind",
      "library": "ppx_css",
      "description": "This module defines a polymorphic type for identifier kinds (`Class`, `Id`, `Variable`) with comparison and ordering operations, including `compare`, `equal`, and bounded validation checks. It provides map and set manipulations tailored for CSS identifiers, supporting workflows that require precise value comparisons and ordered data structure handling during CSS traversal and testing.",
      "description_length": 387,
      "index": 41,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ppx_css.For_testing.Traverse_css.For_testing",
      "library": "ppx_css",
      "description": "Traverses and transforms CSS style sheets by applying a function to class, ID, and variable labels, while allowing selective rewriting of expressions and excluding specific prefixes from hashing. Works directly with `Css_jane.Stylesheet.t` and string maps of expressions. Useful for modifying CSS identifiers during compilation, such as renaming classes or variables while preserving structure and location information.",
      "description_length": 419,
      "index": 42,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Ppx_css.For_testing.Traverse_css.Get_all_identifiers",
      "library": "ppx_css",
      "description": "Extracts CSS and OCaml identifiers from a stylesheet, distinguishing between class names, IDs, and variables. Processes `Css_jane.Stylesheet.t` values to collect identifiers used in styles. Useful for analyzing or transforming CSS structures in OCaml code.",
      "description_length": 256,
      "index": 43,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ppx_css.For_testing.Traverse_css.Transform",
      "library": "ppx_css",
      "description": "Transforms CSS strings by hashing identifiers while preserving their relationships, generating a mapping of original to transformed identifiers along with the rewritten CSS. It processes input with functions like `f`, which takes a location, position, rewrite map, and configuration for hashing behavior. This module is used to safely rewrite CSS class names and ensure consistent identifier substitution in generated code.",
      "description_length": 423,
      "index": 44,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Ppx_css.For_testing.Traverse_css",
      "library": "ppx_css",
      "description": "This module processes and transforms CSS stylesheets by rewriting identifiers such as classes, IDs, and variables according to specified rules. It operates on `Css_jane.Stylesheet.t` structures and string maps, enabling use cases like hashing class names during compilation while preserving relationships. Functions support precise identifier substitution, exclusion of prefixes, and mapping original to transformed names for consistent code generation.",
      "description_length": 453,
      "index": 45,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Ppx_css.For_css_inliner",
      "library": "ppx_css",
      "description": "Inlines CSS styles into OCaml code by generating module structures and signatures. Processes CSS strings into hashed class names, excluding specified prefixes, and produces corresponding `.ml` and `.mli` file contents. Useful for embedding CSS directly into modules during preprocessing, ensuring type-safe class name references.",
      "description_length": 329,
      "index": 46,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ppx_css.For_testing",
      "library": "ppx_css",
      "description": "Processes and transforms CSS stylesheets by rewriting identifiers such as classes, IDs, and variables according to specified rules. It operates on `Css_jane.Stylesheet.t` structures and string maps, enabling use cases like hashing class names during compilation while preserving relationships. Functions support precise identifier substitution, exclusion of prefixes, and mapping original to transformed names for consistent code generation.",
      "description_length": 441,
      "index": 47,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Ppx_css",
      "library": "ppx_css",
      "description": "Processes CSS stylesheets by transforming identifiers like classes and variables through name hashing or substitution rules, operating on `Css_jane.Stylesheet.t` and string maps. Generates hashed class names, excludes specified prefixes, and produces OCaml module structures and signatures for type-safe CSS embedding. Used during preprocessing to inline CSS into `.ml` and `.mli` files or rewrite stylesheet identifiers while maintaining consistency.",
      "description_length": 451,
      "index": 48,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Inline_css.Private.Dynamic",
      "library": "ppx_css.inline_css",
      "description": "This module provides the `attr` function, which creates a dynamic `Vdom.Attr.t` that manages a CSS Constructed Stylesheet based on a changing string input. It works with `string` values that may change over time, such as those derived from Bonsai `Value.t`, and handles automatic stylesheet updates and removals in response to DOM changes. Use this when you need to apply styles that change dynamically, such as theme switching or user-driven styling, while ensuring proper cleanup and updates in the virtual DOM.",
      "description_length": 513,
      "index": 49,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Inline_css.Private",
      "library": "ppx_css.inline_css",
      "description": "This module provides `append` and `prepend` functions to inject raw CSS strings into the document's stylesheet, directly modifying styles at runtime. It works with string inputs representing CSS rules, allowing programmatic control over styling behavior. Use it to dynamically adjust visual presentation, such as applying theme-specific styles or injecting transient UI component styles in response to user interactions.",
      "description_length": 420,
      "index": 50,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Inline_css.For_testing",
      "library": "ppx_css.inline_css",
      "description": "This module provides functions to convert internal CSS representations to string format, retrieve the current strategy name, and dump the state of the active strategy. It operates on internal CSS data structures and strategy configurations. Use cases include debugging CSS rendering behavior and inspecting strategy execution during testing.",
      "description_length": 341,
      "index": 51,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Inline_css",
      "library": "ppx_css.inline_css",
      "description": "Injects raw CSS strings into a document's stylesheet at runtime using `append` and `prepend`, modifying styles dynamically. Converts internal CSS representations to strings, retrieves strategy names, and dumps strategy state for debugging and testing purposes.",
      "description_length": 260,
      "index": 52,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Css_printer.Merge",
      "library": "ppx_css.css_printer",
      "description": "This module merges multiple CSS stylesheets into a single stylesheet. It provides operations to add individual stylesheets and extract the combined result. The module works with CSS AST structures defined in `Css_parser.Types.Stylesheet.t`.",
      "description_length": 240,
      "index": 53,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Css_printer.Print",
      "library": "ppx_css.css_printer",
      "description": "This module provides functions to print CSS stylesheets using specified templates. It supports pretty-printing and minification through predefined templates. The `css` function applies a template to format a stylesheet into a given formatter.",
      "description_length": 242,
      "index": 54,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Css_printer",
      "library": "ppx_css.css_printer",
      "description": "This module combines CSS stylesheets and prints them using customizable templates. It operates on CSS AST structures, offering functions to merge multiple stylesheets and format the result for output. Use it to consolidate styles from different sources and generate minified or human-readable CSS.",
      "description_length": 297,
      "index": 55,
      "embedding_norm": 0.9999999403953552
    }
  ],
  "filtering": {
    "total_modules_in_package": 59,
    "meaningful_modules": 56,
    "filtered_empty_modules": 3,
    "retention_rate": 0.9491525423728814
  },
  "statistics": {
    "max_description_length": 593,
    "min_description_length": 240,
    "avg_description_length": 381.125,
    "embedding_file_size_mb": 0.8117380142211914
  }
}