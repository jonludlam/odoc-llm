{
  "package": "decoders-cbor",
  "embedding_model": "Qwen/Qwen3-Embedding-0.6B",
  "embedding_dimension": 1024,
  "total_modules": 5,
  "creation_timestamp": "2025-07-15T23:05:19.731280",
  "modules": [
    {
      "module_path": "Decoders_cbor.Decode.Infix",
      "library": "decoders-cbor",
      "description": "This module defines infix operators for composing CBOR decoding operations, enabling sequential and parallel decoding of structured data. It provides monadic and applicative combinators for working with decoders that process input streams into values, supporting precise parsing of CBOR-encoded data. Concrete use cases include decoding nested CBOR structures, validating encoded binary data, and transforming CBOR streams into typed OCaml values.",
      "description_length": 447,
      "index": 0,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Decoders_cbor.Decode.Pipeline",
      "library": "decoders-cbor",
      "description": "This module provides combinators for building CBOR decoders using a pipeline style, allowing sequential extraction and transformation of values from CBOR-encoded data. It supports operations for decoding required and optional fields by key or path, applying custom transformations, and chaining decoding steps in a readable order. Concrete use cases include parsing structured CBOR data such as configuration files, network messages, or binary protocols where field order and conditional decoding are important.",
      "description_length": 511,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Decoders_cbor.Encode",
      "library": "decoders-cbor",
      "description": "This module encodes OCaml values into CBOR format. It provides primitive encoders for strings, integers, floats, booleans, and null, along with combinators for encoding lists, arrays, and key-value objects. Use it to serialize structured data for storage or transmission, such as encoding configuration data or API payloads into a binary format.",
      "description_length": 345,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Decoders_cbor.Decode",
      "library": "decoders-cbor",
      "description": "This module decodes CBOR-encoded data from strings or files into OCaml values, supporting both primitive and structured types through monadic and applicative combinators. It enables field extraction, error handling, and dynamic decoder construction for nested or recursive data, with infix operators for sequential and parallel decoding and pipeline combinators for structured, readable decoding workflows. Examples include parsing CBOR-encoded configuration files, network messages with optional fields, and binary data into typed OCaml structures with validation and transformation steps.",
      "description_length": 590,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Decoders_cbor",
      "library": "decoders-cbor",
      "description": "This module handles bidirectional conversion between OCaml values and CBOR-encoded data, enabling serialization and deserialization of structured information. It supports primitive types like strings, integers, and booleans, along with structured types such as lists, arrays, and key-value objects, using combinators for building complex encoders and decoders. You can encode configuration data into CBOR for transmission or storage, and decode CBOR binary payloads into typed OCaml structures with validation, handling optional fields or nested data in network messages or configuration files.",
      "description_length": 594,
      "index": 4,
      "embedding_norm": 0.9999999403953552
    }
  ],
  "filtering": {
    "total_modules_in_package": 5,
    "meaningful_modules": 5,
    "filtered_empty_modules": 0,
    "retention_rate": 1.0
  },
  "statistics": {
    "max_description_length": 594,
    "min_description_length": 345,
    "avg_description_length": 497.4,
    "embedding_file_size_mb": 0.01861572265625
  }
}