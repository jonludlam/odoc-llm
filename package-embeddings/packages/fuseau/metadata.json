{
  "package": "fuseau",
  "embedding_model": "Qwen/Qwen3-Embedding-8B",
  "embedding_dimension": 4096,
  "total_modules": 28,
  "creation_timestamp": "2025-08-15T12:20:34.637236",
  "modules": [
    {
      "module_path": "Fuseau_unix.Net.Sockaddr",
      "library": "fuseau.unix",
      "description": "This module provides functions to construct and manipulate socket address values for both Unix domain and IPv4 addresses. It supports creating addresses from strings or integers, including parsing IP strings, and generating addresses for local or any interfaces. Useful for configuring network endpoints in applications like simple servers or clients using TCP/UDP or Unix sockets.",
      "description_length": 381,
      "index": 0,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fuseau_unix.IO_unix.Out",
      "library": "fuseau.unix",
      "description": "This module implements output streams for writing bytes to various destinations using low-level Unix IO. It supports operations like writing characters, strings, integers, and sequences of lines, along with stream composition via `tee`. Concrete use cases include logging to files, sending formatted data over sockets, and buffering output in memory.",
      "description_length": 350,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fuseau_unix.Net.TCP_client",
      "library": "fuseau.unix",
      "description": "This module implements TCP client connections using the `Unix.select`-based event loop. It provides the `with_connect` function to establish a connection to a given socket address and interact with the resulting input and output streams. Use this to build clients for protocols like HTTP, SMTP, or custom TCP-based services.",
      "description_length": 324,
      "index": 2,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fuseau_unix.Net.TCP_server",
      "library": "fuseau.unix",
      "description": "Implements a TCP server that accepts incoming connections and handles them with user-defined logic. It operates on `Sockaddr` addresses and provides streams for input and output communication. Use it to build network services like HTTP servers or custom TCP protocols where each connection is processed independently.",
      "description_length": 317,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fuseau_unix.IO_unix.In",
      "library": "fuseau.unix",
      "description": "This module implements input streams for reading byte sequences from various sources such as strings, bytes buffers, or Unix file descriptors. It provides operations like `input`, `really_input`, and `input_all` for controlled consumption of data, along with stream composition via `concat` and resource management through `close`. Concrete use cases include reading from network sockets, files, or in-memory buffers in applications built with the Fuseau event loop.",
      "description_length": 466,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fuseau_unix.Net.Inet_addr",
      "library": "fuseau.unix",
      "description": "This module provides operations for working with IPv4 and IPv6 addresses, including constants for loopback and any-address, string conversion, and parsing. It directly wraps `Unix.inet_addr` values, offering safe and unsafe parsing functions along with string representation. Concrete use cases include configuring network endpoints, binding sockets, and displaying address information in network applications.",
      "description_length": 410,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fuseau_unix.Net",
      "library": "fuseau.unix",
      "description": "This module implements networking functionality using the `Unix.select`-based event loop. It provides IPv4 and IPv6 address handling, socket address construction, and TCP client and server implementations. Use it to build simple network services or clients like HTTP servers, custom TCP protocols, or SMTP clients that require direct socket communication.",
      "description_length": 355,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fuseau_unix.Timer",
      "library": "fuseau.unix",
      "description": "This module manages timed events using a simple event loop based on `Unix.select`. It supports scheduling one-time or recurring actions with `run_after` and `run_every`, and provides control over task execution through cancellation handles. It works directly with floating-point durations and fiber-based concurrency via `Fuseau.Cancel_handle`.",
      "description_length": 344,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fuseau_unix.IO_unix",
      "library": "fuseau.unix",
      "description": "This module implements low-level Unix IO operations for file descriptors, including reading, writing, and waiting for readability or writability. It works directly with `Unix.file_descr` and `bytes` buffers, providing precise control over IO scheduling in event-driven applications. Concrete use cases include handling socket IO in network servers and clients built with the Fuseau event loop.",
      "description_length": 393,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fuseau_unix",
      "library": "fuseau.unix",
      "description": "This module implements an event loop for concurrent IO and fiber management using `Unix.select`, providing precise control over file descriptor operations, network communication, and timed events. It supports concrete use cases such as building TCP servers and clients, managing socket IO with `Unix.file_descr`, and scheduling time-based tasks with deadline and timeout handling. Key functions include fiber spawning, microtask scheduling, sleep and cancellation operations, and low-level IO handling via submodules like `IO_unix`, `Net`, and `Timer`.",
      "description_length": 552,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fuseau.Fiber_handle.Set",
      "library": "fuseau",
      "description": "This module provides ordered immutable sets of fiber identifiers with standard operations like union, intersection, and difference, along with ordered traversal and sequence conversion capabilities. It works with sets containing fiber handles, supporting transformations, membership queries, and monotonic predicate-based filtering. Typical use cases include tracking groups of fibers for coordination, managing concurrent task dependencies, and maintaining ordered collections of active execution contexts.",
      "description_length": 507,
      "index": 10,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fuseau.Fiber_handle.Map",
      "library": "fuseau",
      "description": "This module implements an ordered associative container for managing key-value pairs where keys are unique fiber identifiers, supporting efficient insertion, lookup, and ordered traversal. It provides a rich set of operations for functional transformations, aggregation, and bulk manipulation of fiber-bound data, including merging, filtering, and sequence-based construction. Typical applications include tracking fiber-specific state in concurrent systems, coordinating task dependencies, or maintaining ordered collections of fiber metadata in structured concurrency patterns.",
      "description_length": 579,
      "index": 11,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fuseau.Iostream.In",
      "library": "fuseau",
      "description": "This module implements input stream abstractions for reading byte sequences from various sources, such as strings, byte buffers, or custom input functions. It provides operations like `input`, `really_input`, and `input_all` for controlled and complete consumption of stream data, along with stream composition via `concat` and resource management via `close`. Concrete use cases include parsing network payloads, reading file contents incrementally, and handling in-memory byte sources like encoded messages.",
      "description_length": 509,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fuseau.Iostream.Out",
      "library": "fuseau",
      "description": "This module implements output streams for writing bytes to various destinations, supporting operations like character, string, integer, and line-based output. It works with byte sequences, strings, and buffers, enabling concrete use cases such as logging to memory buffers, writing to network sockets, or duplicating output across multiple streams using `tee`. Functions like `flush` and `close` control data propagation and resource cleanup, while `output_line` and `output_lines` simplify line-oriented output.",
      "description_length": 512,
      "index": 13,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fuseau.Scheduler",
      "library": "fuseau",
      "description": "Manages the execution of fibers within a cooperative concurrency system. It tracks active fibers, provides statistics on task execution, and allows safe cleanup of resources. Useful for coordinating background tasks and monitoring concurrency in structured applications.",
      "description_length": 270,
      "index": 14,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fuseau.Buf_pool",
      "library": "fuseau",
      "description": "Manages a reusable pool of byte buffers with bounded size. Provides operations to allocate, release, and temporarily use buffers, reducing memory allocation overhead in concurrent applications. Useful for handling transient byte data in network protocols or streaming I/O.",
      "description_length": 272,
      "index": 15,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fuseau.Fiber",
      "library": "fuseau",
      "description": "This module implements lightweight cooperative threads (fibers) that run on the scheduler, supporting operations like yielding, cancellation, and result handling. It works with fiber types (`'a t`), optional results, and callbacks for asynchronous completion. Concrete use cases include managing concurrent tasks that yield during I/O operations and registering callbacks to handle fiber results without blocking.",
      "description_length": 413,
      "index": 16,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fuseau.Cancel_handle",
      "library": "fuseau",
      "description": "This module defines a cancellation handle with an explicit `cancel` function to trigger cancellation. It works with the `t` type, which wraps a cancellation callback. Use it to manage and invoke cancellation logic in structured concurrency contexts like fibers or switches.",
      "description_length": 273,
      "index": 17,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fuseau.Resource_pool",
      "library": "fuseau",
      "description": "This module provides functions to create, acquire, and recycle resources in a non-blocking pool optimized for lightweight, transient resources like buffers. It works with any resource type `'a`, assuming that resources are inexpensive to create and discard. Concrete use cases include managing byte buffers for I/O operations or temporary data structures in high-throughput systems.",
      "description_length": 382,
      "index": 18,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fuseau.Exn_bt",
      "library": "fuseau",
      "description": "This module defines a structured representation of exceptions paired with backtrace information, enabling precise error tracking and debugging. It provides operations to construct, retrieve, and raise exceptions with backtraces, along with utilities to extract callstacks and format errors as strings. The module is used to handle exceptional conditions in concurrent code where detailed diagnostic information is required.",
      "description_length": 423,
      "index": 19,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fuseau.FLS",
      "library": "fuseau",
      "description": "This module implements fiber-local storage, providing operations to create storage keys with initialization functions, retrieve and set values specific to the current fiber, and temporarily bind values within a dynamic scope. It works with fibers and key-value pairs where keys are tied to the fiber's execution context. Concrete use cases include managing per-fiber state such as request-specific data in servers or transaction contexts in concurrent workflows.",
      "description_length": 462,
      "index": 20,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fuseau.Fiber_handle",
      "library": "fuseau",
      "description": "This module defines a unique identifier type for fibers, supporting equality checks, comparison, and hashing. It works with integer-based handles to distinguish running fibers in a concurrent system. These identifiers are used to track and manage individual fibers within sets and maps for coordination, dependency management, and structured concurrency control.",
      "description_length": 362,
      "index": 21,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fuseau.Time",
      "library": "fuseau",
      "description": "This module provides functions to retrieve the current monotonic time in nanoseconds and seconds. It works with basic numeric types, specifically `int64` and `float`. Useful for measuring time intervals in performance-sensitive code or tracking durations in concurrent programs.",
      "description_length": 278,
      "index": 22,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fuseau.Event_loop",
      "library": "fuseau",
      "description": "This module implements an event loop abstraction for the scheduler, providing functions to run loop iterations with or without blocking, schedule timed events, and interrupt blocking operations. It manages timers and event handlers, enabling precise control over asynchronous execution flow. Concrete use cases include driving fiber scheduling, handling I/O readiness, and coordinating timed callbacks in a structured concurrency environment.",
      "description_length": 442,
      "index": 23,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fuseau.Iostream",
      "library": "fuseau",
      "description": "This module implements bidirectional byte stream abstractions for structured I/O operations. It provides input stream functions to read and compose byte sequences from sources like buffers or custom readers, and output stream functions to write, buffer, or tee bytes to destinations such as sockets or memory. Concrete use cases include incremental network data processing, in-memory logging, and multiplexed output handling.",
      "description_length": 425,
      "index": 24,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fuseau.Chan",
      "library": "fuseau",
      "description": "This module implements asynchronous communication channels for exchanging values between concurrent fibers. It supports operations to send and receive values, check channel state, and handle closed channels gracefully. Channels can be bounded to a maximum size and are used to coordinate data flow in event-driven or concurrent applications.",
      "description_length": 341,
      "index": 25,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fuseau.Event",
      "library": "fuseau",
      "description": "Handles atomic event selection in a concurrent setting. Provides the `select` function to choose the first ready event from a list, returning its result. Works with lists of event branches, where each branch encapsulates a possible event outcome. Useful for implementing non-deterministic choice between concurrent operations, such as waiting for the earliest of multiple timeouts or I/O events.",
      "description_length": 395,
      "index": 26,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fuseau",
      "library": "fuseau",
      "description": "The module provides primitives for structured cooperative concurrency, including fiber creation with hierarchical relationships, event synchronization, and channel-based communication. It operates on fibers, events, channels, and time values, enabling asynchronous workflows, resource coordination through cancellation mechanisms, and precise time-based scheduling. Key patterns involve parent-child fiber management, event-driven synchronization, and scheduler interactions for cooperative multitasking.",
      "description_length": 504,
      "index": 27,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 33,
    "meaningful_modules": 28,
    "filtered_empty_modules": 5,
    "retention_rate": 0.8484848484848485
  },
  "statistics": {
    "max_description_length": 579,
    "min_description_length": 270,
    "avg_description_length": 401.4642857142857,
    "embedding_file_size_mb": 0.4062004089355469
  }
}