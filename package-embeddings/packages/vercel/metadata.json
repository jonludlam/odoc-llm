{
  "package": "vercel",
  "embedding_model": "BAAI/bge-base-en-v1.5",
  "embedding_dimension": 1024,
  "total_modules": 4,
  "creation_timestamp": "2025-06-18T16:30:41.722658",
  "modules": [
    {
      "module_path": "Vercel.Request",
      "description": "Creates a request object with specified scheme, HTTP version, headers, method, body, and URI. Operates on custom types including scheme, method, headers, body, and URI. Used to construct and inspect HTTP requests for network communication.",
      "description_length": 239,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Vercel.Response",
      "description": "Constructs HTTP responses with customizable version, headers, and body from strings, bigstrings, streams, or files, and supports protocol upgrades. Operates on HTTP status codes, headers, and various body representations including raw data and file paths. Used to generate structured HTTP responses in web servers, handle streaming content, and manage connection persistence.",
      "description_length": 375,
      "index": 1,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "vercel",
      "description": "Provides functions for initializing, handling, and terminating AWS Lambda invocations, including parsing environment variables and serializing responses. Works with JSON-encoded event data, AWS context objects, and custom response formats. Used to create lightweight, high-performance Lambda handlers that process HTTP requests and return structured outputs.",
      "description_length": 358,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Vercel",
      "description": "provides a framework for building and inspecting HTTP requests and responses, with dedicated structures for request components like scheme, method, and URI, and response elements such as status codes, headers, and body formats. It enables the creation of fully customizable HTTP messages, supporting both simple string-based bodies and complex data sources like files or streams. Users can construct requests with specific parameters, inspect their components, and generate responses that handle streaming or file-based content. Examples include forming a GET request with a custom header or sending a response with a large file as the body.",
      "description_length": 641,
      "index": 3,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 6,
    "meaningful_modules": 4,
    "filtered_empty_modules": 2,
    "retention_rate": 0.6666666666666666
  },
  "statistics": {
    "max_description_length": 641,
    "min_description_length": 239,
    "avg_description_length": 403.25,
    "embedding_file_size_mb": 0.014943122863769531
  }
}