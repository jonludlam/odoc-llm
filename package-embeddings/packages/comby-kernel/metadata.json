{
  "package": "comby-kernel",
  "embedding_model": "Qwen/Qwen3-Embedding-8B",
  "embedding_dimension": 4096,
  "total_modules": 619,
  "creation_timestamp": "2025-08-18T20:24:39.905441",
  "modules": [
    {
      "module_path": "Match.Location",
      "library": "comby-kernel.match",
      "description": "This module defines a data structure for representing positions in a text file, with fields for byte offset, line number, and column number. It includes functions for serialization to and from JSON and S-expressions, equality checking, and a default value. This module is useful for tracking source code locations in parsers or tools that process structured text.",
      "description_length": 363,
      "index": 0,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Match.Range",
      "library": "comby-kernel.match",
      "description": "This module defines a range structure with start and end locations, providing serialization to and from JSON and S-expressions, equality checking, and a default value. It works with `Match.location` values to represent positions within a matched region. Use this module when tracking or serializing ranges in text processing or parsing applications.",
      "description_length": 349,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Match.Offset",
      "library": "comby-kernel.match",
      "description": "This module provides functions to convert character offsets in a string to line and column numbers. It works with strings and integer offsets, maintaining an index structure to efficiently map positions. Use it when parsing source code to track locations for error reporting or syntax highlighting.",
      "description_length": 298,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Match.Environment",
      "library": "comby-kernel.match",
      "description": "This module manages a mapping of string variables to values and associated ranges, supporting operations to add, lookup, update, and merge variable bindings. It provides typed access to variable values and ranges, along with JSON serialization and deserialization. Concrete use cases include tracking variable assignments during pattern matching and maintaining context state across matching operations.",
      "description_length": 403,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Match",
      "library": "comby-kernel.match",
      "description": "This module provides operations for tracking source code positions, managing variable bindings with ranges, converting offsets to line/column numbers, and serializing match data to JSON. It works with structured match records that combine matched text, location metadata, and variable environments, supporting applications in parsing, pattern matching, and tools requiring precise source position tracking.",
      "description_length": 406,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Replacement",
      "library": "comby-kernel.replacement",
      "description": "This module defines a `Replacement` structure that captures a match range, replacement content, and environment, along with functions to serialize and deserialize it to and from JSON. It includes a `result` type representing the outcome of a rewriting operation, with the rewritten source and a list of applied replacements. It is used to record and export the results of source code transformations, such as those performed during refactoring or automated code modification.",
      "description_length": 475,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Vangstrom_unix",
      "library": "comby-kernel.vangstrom-unix",
      "description": "This module provides functions for parsing data from input channels using Vangstrom parsers. It supports single-shot parsing with `parse` and streaming parsing with `parse_many`, handling unconsumed input and parser errors. Concrete use cases include reading and processing binary or text-based formats like network protocols or file formats directly from input streams.",
      "description_length": 370,
      "index": 6,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Script.Make.Parser.Template.Matching",
      "library": "comby-kernel.matchers",
      "description": "This module defines parsers for template holes in a script, mapping hole sorts to string parsers. It works with `Hole.sort` and `Vangstrom.t` types to parse structured templates. Use it to extract and process templated values from strings according to predefined hole types.",
      "description_length": 274,
      "index": 7,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Rule.Make.Template.Matching",
      "library": "comby-kernel.matchers",
      "description": "This module defines parsers for handling holes in templates, specifically associating hole sorts with string parsers. It works with hole data structures and template syntax, enabling the extraction and processing of placeholder values during parsing. Concrete use cases include parsing structured text formats where placeholders must be dynamically replaced or captured.",
      "description_length": 370,
      "index": 8,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Script.Make.Parser.Template",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to parse, manipulate, and substitute template atoms in script strings. It works with `Matchers__Types.Template.atom` lists and `Match.Environment.t` to extract variables, convert templates to strings, and replace holes with evaluated values. Use it to process templated script fragments by parsing them into atoms, extracting syntax definitions, and substituting values from a match environment.",
      "description_length": 426,
      "index": 9,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Languages.Solidity.Info",
      "library": "comby-kernel.matchers",
      "description": "This module defines metadata for the Solidity programming language, including its name and file extensions. It works with string and list data types to store and expose language-specific identifiers. Concrete use cases include determining file type associations and language naming in tooling that processes or analyzes Solidity code.",
      "description_length": 334,
      "index": 10,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Javascript.Info",
      "library": "comby-kernel.matchers",
      "description": "This module defines metadata for JavaScript, including its name and file extensions. It provides direct access to the language name as a string and a list of associated file extensions. Useful for tools that need to identify JavaScript files or display language information.",
      "description_length": 274,
      "index": 11,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Reason.Syntax",
      "library": "comby-kernel.matchers",
      "description": "This module defines syntax elements for parsing and processing ReasonML code, including delimiters for nested expressions, escapable and raw string literals, and comment styles. It provides concrete configurations for handling language-specific syntax features like JSX tags, string interpolation, and multiline comments. These values are used directly by parsers and formatters to correctly tokenize and structure ReasonML source code.",
      "description_length": 436,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Move.Info",
      "library": "comby-kernel.matchers",
      "description": "This module defines metadata for the Move programming language, including its name and file extensions. It provides direct access to a string representing the language name and a list of associated file extensions. This information supports tools like linters, IDEs, or build systems that need to identify or process Move source files based on their extension or display the language name.",
      "description_length": 389,
      "index": 13,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Languages.Kotlin.Info",
      "library": "comby-kernel.matchers",
      "description": "This module defines metadata for the Kotlin programming language, including its name and file extensions. It provides direct access to the language's identifier and a list of associated file extensions. Useful for tools that need to recognize or process Kotlin files based on naming conventions or file types.",
      "description_length": 309,
      "index": 14,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Languages.Go.Info",
      "library": "comby-kernel.matchers",
      "description": "This module defines metadata for the Go programming language, including its name and file extensions. It provides direct access to the language name as a string and a list of associated file extensions. Useful for tools that need to identify or process Go source files based on their extension or refer to the language name programmatically.",
      "description_length": 341,
      "index": 15,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Languages.Text.Info",
      "library": "comby-kernel.matchers",
      "description": "This module defines metadata for text-based languages, including the language name and associated file extensions. It works with string and list data types to store and retrieve language-specific identifiers. Concrete use cases include mapping file extensions to language names for syntax highlighting or file type detection.",
      "description_length": 325,
      "index": 16,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Languages.Ruby.Info",
      "library": "comby-kernel.matchers",
      "description": "This module defines metadata for Ruby language support, including the language name and file extensions. It provides direct access to static information used for configuration or identification purposes. Concrete use cases include determining file type associations and language labeling in tooling interfaces.",
      "description_length": 310,
      "index": 17,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Python.Info",
      "library": "comby-kernel.matchers",
      "description": "This module defines metadata for Python files, including the language name and common file extensions. It provides direct access to the name as a string and the extensions as a list of strings. Concrete use cases include identifying Python source files by extension and associating them with the correct language name in tools like linters or syntax highlighters.",
      "description_length": 363,
      "index": 18,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Pascal.Info",
      "library": "comby-kernel.matchers",
      "description": "This module defines metadata for Pascal language files, including the language name and associated file extensions. It works with string and list data types to store and retrieve this information. A concrete use case is determining whether a given file path corresponds to a Pascal source file based on its extension.",
      "description_length": 317,
      "index": 19,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Swift.Info",
      "library": "comby-kernel.matchers",
      "description": "This module defines metadata for the Swift programming language, including the language name and file extensions. It provides direct access to static information used for identifying and handling Swift source files. Concrete use cases include file type detection and language-specific configuration in tools like linters or IDEs.",
      "description_length": 329,
      "index": 20,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Generic.Info",
      "library": "comby-kernel.matchers",
      "description": "This module defines metadata for a programming language, including its name and associated file extensions. It works with basic string and list data types to store and retrieve this information. Concrete use cases include identifying language-specific files based on extension or displaying language names in tooling interfaces.",
      "description_length": 328,
      "index": 21,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.R.Syntax",
      "library": "comby-kernel.matchers",
      "description": "This module defines syntax elements for parsing and matching R code, including delimiters for user-defined operators, escapable and raw string literals, and comment styles. It provides specific configurations for handling R's syntactic conventions, such as backtick-quoted identifiers and `#`-prefixed comments. Concrete use cases include building parsers or linters that need to accurately recognize R's syntax constructs during source code analysis.",
      "description_length": 451,
      "index": 22,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Html.Info",
      "library": "comby-kernel.matchers",
      "description": "This module defines metadata for HTML, including its name and common file extensions. It provides direct access to the language name as a string and a list of associated extensions. Useful for identifying HTML files based on extension or referencing the language name in tooling contexts.",
      "description_length": 288,
      "index": 23,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.SQL.Syntax",
      "library": "comby-kernel.matchers",
      "description": "This module defines syntax elements for SQL, including delimiters, string literals, and comment styles. It supports parsing and matching SQL code by specifying escapable and raw string formats, as well as comment markers. Use this module to configure SQL syntax rules in code analysis or transformation tools.",
      "description_length": 309,
      "index": 24,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Julia.Syntax",
      "library": "comby-kernel.matchers",
      "description": "This module defines syntax elements specific to the Julia language, including user-defined delimiters for strings, escapable and raw string literal markers, and comment syntax. It provides concrete configurations for parsing and handling Julia source code. Use this module when implementing or analyzing Julia code parsers, string interpolation, or comment stripping tools.",
      "description_length": 373,
      "index": 25,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.C_nested_comments.Syntax",
      "library": "comby-kernel.matchers",
      "description": "This module defines syntax elements for handling nested comments and string literals in C-like languages. It specifies delimiters for nested comments, escapable and raw string literal markers, and comment styles. Used to configure parsers for languages supporting nested comments, such as C or C++.",
      "description_length": 298,
      "index": 26,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Languages.Typescript.Syntax",
      "library": "comby-kernel.matchers",
      "description": "This module defines syntax elements specific to TypeScript, including delimiters for blocks, escapable and raw string literals, and comment styles. It provides concrete configurations for parsing and matching TypeScript code patterns. Use this module to handle syntactic constructs when analyzing or transforming TypeScript source files.",
      "description_length": 337,
      "index": 27,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Dhall.Info",
      "library": "comby-kernel.matchers",
      "description": "This module defines metadata for the Dhall configuration language, including its name and file extensions. It provides direct access to the language's identifier and a list of associated file extensions. Useful for tools that need to recognize or process Dhall files based on naming conventions or file type.",
      "description_length": 308,
      "index": 28,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Dhall.Syntax",
      "library": "comby-kernel.matchers",
      "description": "This module defines syntax elements for parsing and handling Dhall language constructs, including delimiters for interpolated strings, escapable and raw string literals, and comment formats. It provides concrete configurations for token recognition and string escaping rules specific to Dhall. Use cases include configuring parsers and formatters for Dhall source code and handling string encodings in Dhall expressions.",
      "description_length": 420,
      "index": 29,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Languages.Dyck.Syntax",
      "library": "comby-kernel.matchers",
      "description": "This module defines syntax elements for a Dyck language, including user-defined delimiters, escapable and raw string literals, and comment styles. It provides concrete configurations for parsing and tokenizing Dyck language constructs. Use this module to specify or extend the syntax rules for Dyck-based languages, such as domain-specific languages or custom configuration formats.",
      "description_length": 382,
      "index": 30,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.HCL.Syntax",
      "library": "comby-kernel.matchers",
      "description": "This module defines syntax elements for HCL (HashiCorp Configuration Language), including delimiters for user-defined identifiers, escapable and raw string literals, and comment styles. It provides concrete configurations for parsing and interpreting HCL code, such as specifying quote characters for strings and comment markers like `#` or `//`. These values are used directly by parsers and linters to correctly recognize and process HCL syntax in configuration files.",
      "description_length": 470,
      "index": 31,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Languages.SQL.Info",
      "library": "comby-kernel.matchers",
      "description": "This module defines metadata for SQL files, including the language name and associated file extensions. It works with string and list data types to store and retrieve this information. Concrete use cases include identifying SQL files by extension and displaying the language name in tools like code editors or linters.",
      "description_length": 318,
      "index": 32,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Rust.Syntax",
      "library": "comby-kernel.matchers",
      "description": "This module defines syntax elements specific to Rust, including user-defined delimiters, escapable and raw string literals, and comment kinds. It provides precise syntactic patterns for parsing and matching Rust code structures. Use cases include implementing custom parsers, linters, or code transformation tools that require accurate recognition of Rust's syntax features.",
      "description_length": 374,
      "index": 33,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Fsharp.Syntax",
      "library": "comby-kernel.matchers",
      "description": "This module defines syntax elements for F# code parsing, including delimiters for user-defined symbols, escapable and raw string literal formats, and comment styles. It provides precise syntactic patterns used to identify language constructs in source code analysis. Concrete use cases include tokenizing F# strings with escape sequences, handling triple-quoted raw strings, and recognizing line and block comments.",
      "description_length": 415,
      "index": 34,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Languages.Swift.Syntax",
      "library": "comby-kernel.matchers",
      "description": "This module defines syntax elements for Swift, including user-defined delimiters for string literals, escapable and raw string configurations, and comment kinds. It provides concrete syntax rules that support parsing and matching Swift code patterns, such as handling string boundaries and comment structures. Use cases include building custom Swift parsers, linters, or code transformation tools that rely on precise syntax recognition.",
      "description_length": 437,
      "index": 35,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.JSONC.Info",
      "library": "comby-kernel.matchers",
      "description": "This module defines metadata for the JSONC language, including its name and file extensions. It provides direct access to a string identifier and a list of associated file extensions. Use this module to retrieve JSONC language details for configuration or file handling tasks.",
      "description_length": 276,
      "index": 36,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Languages.Rust.Info",
      "library": "comby-kernel.matchers",
      "description": "This module defines metadata for the Rust language, including its name and file extensions. It provides direct access to the language name as a string and a list of associated file extensions. Useful for tools that need to identify or process Rust source files based on their extension or refer to the language name in reports or configurations.",
      "description_length": 345,
      "index": 37,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Csharp.Info",
      "library": "comby-kernel.matchers",
      "description": "This module defines metadata for the C# language, including the language name and file extensions. It provides direct access to the name as a string and the extensions as a list of strings. This information is used to identify and handle C# source files in tooling that processes code, such as parsers or syntax highlighters.",
      "description_length": 325,
      "index": 38,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Pascal.Syntax",
      "library": "comby-kernel.matchers",
      "description": "This module defines syntax elements specific to Pascal, including user-defined delimiters for blocks, escapable and raw string literal markers, and comment styles. It works with lists of string pairs for delimiters and literals, and comment kind records. Concrete use cases include parsing Pascal code with custom block structures, handling string escaping, and recognizing Pascal-style comments.",
      "description_length": 396,
      "index": 39,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.CSS.Info",
      "library": "comby-kernel.matchers",
      "description": "This module defines metadata for CSS files, including the language name and associated file extensions. It provides direct access to a string identifier and a list of filename extensions commonly used for CSS files. This information is useful for file type detection, syntax highlighting, or configuration in tools processing CSS assets.",
      "description_length": 337,
      "index": 40,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.OCaml.Info",
      "library": "comby-kernel.matchers",
      "description": "This module defines metadata for the OCaml language, including its name and file extensions. It provides direct access to the language name as a string and a list of associated file extensions. Useful for tools that need to identify OCaml files or display language information.",
      "description_length": 277,
      "index": 41,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.C.Info",
      "library": "comby-kernel.matchers",
      "description": "This module defines metadata for the C programming language, including the language name and file extensions. It provides direct access to a string identifier and a list of associated file extensions. Useful for tools that need to recognize or process C source files based on naming conventions.",
      "description_length": 295,
      "index": 42,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Julia.Info",
      "library": "comby-kernel.matchers",
      "description": "This module defines metadata for the Julia programming language, including its name and associated file extensions. It provides direct access to the language name as a string and a list of common file extensions used for Julia source files. This information is used in language detection and file association workflows within code analysis tools.",
      "description_length": 346,
      "index": 43,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Languages.OCaml.Syntax",
      "library": "comby-kernel.matchers",
      "description": "This module defines syntax elements specific to OCaml, including delimiters for user-defined syntax, escapable and raw string literals, and comment styles. It provides concrete configurations for parsing and handling OCaml code structures. Use this module when implementing or extending OCaml parsers, linters, or formatters that require precise syntax recognition.",
      "description_length": 365,
      "index": 44,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Languages.Paren.Syntax",
      "library": "comby-kernel.matchers",
      "description": "This module defines syntax elements for parenthetical languages, including delimiters for parentheses, escapable and raw string literals, and comment styles. It provides concrete configurations for parsing and tokenizing source code with support for custom syntax rules. Use this module to specify language-specific syntax when implementing parsers or formatters for programming languages with parenthetical structures.",
      "description_length": 419,
      "index": 45,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Languages.C_nested_comments.Info",
      "library": "comby-kernel.matchers",
      "description": "This module defines metadata for a language that supports nested comments, including its name and file extensions. It works with string and list data types to store and retrieve this metadata. Concrete use cases include identifying the language by name and determining file types based on extensions.",
      "description_length": 300,
      "index": 46,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Languages.Nim.Syntax",
      "library": "comby-kernel.matchers",
      "description": "This module defines syntax elements for the Nim language, including user-defined delimiters, escapable and raw string literals, and comment kinds. It provides precise syntactic patterns used for parsing and matching Nim code structures. These values are used directly in language analysis tools to identify lexical components like strings and comments during code processing.",
      "description_length": 375,
      "index": 47,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Dart.Info",
      "library": "comby-kernel.matchers",
      "description": "This module defines metadata for the Dart programming language, including its name and file extensions. It provides direct access to the language's identifier and a list of associated file extensions. Useful for tools that need to recognize or process Dart files based on naming conventions.",
      "description_length": 291,
      "index": 48,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Csharp.Syntax",
      "library": "comby-kernel.matchers",
      "description": "This module defines syntax elements for C# such as user-defined delimiters, escapable and raw string literals, and comment kinds. It provides precise syntactic patterns used for parsing and matching C# code structures. Use this module when implementing or analyzing C# language features that require detailed syntax handling, such as string interpolation or custom token recognition.",
      "description_length": 383,
      "index": 49,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Lisp.Info",
      "library": "comby-kernel.matchers",
      "description": "This module defines metadata for a Lisp dialect, including its name and associated file extensions. It works with string and list data types to store and retrieve language-specific identifiers. Concrete use cases include mapping file extensions to Lisp implementations and providing naming consistency across tooling.",
      "description_length": 317,
      "index": 50,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Rule.Make.Template",
      "library": "comby-kernel.matchers",
      "description": "This module processes template strings with placeholders, providing functions to parse templates into atomic components, extract variables, and substitute values using a match environment. It operates on template syntax and atom lists, handling dynamic placeholder replacement in structured text formats. Use cases include generating customized output strings from templates with embedded variables and parsing input strings to capture placeholder values.",
      "description_length": 455,
      "index": 51,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Fortran.Syntax",
      "library": "comby-kernel.matchers",
      "description": "This module defines syntactic elements specific to Fortran, including user-defined delimiters for string literals, escapable and raw string literal formats, and comment syntax variations. It provides concrete configurations for parsing and interpreting Fortran code, supporting accurate recognition of string boundaries and comment blocks in different dialects of Fortran. Use cases include configuring parsers or linters to correctly handle Fortran-specific syntax in source code analysis tools.",
      "description_length": 496,
      "index": 52,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Jsx.Syntax",
      "library": "comby-kernel.matchers",
      "description": "This module defines syntax elements for JSX parsing, including user-defined delimiters, escapable and raw string literals, and comment kinds. It provides precise syntactic rules for identifying and handling JSX-specific constructs in source code. Use cases include parsing and transforming JSX expressions in OCaml-based compilers or linters.",
      "description_length": 342,
      "index": 53,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Elm.Info",
      "library": "comby-kernel.matchers",
      "description": "This module defines metadata for the Elm programming language, including its name and file extensions. It provides direct access to the language name as a string and a list of associated file extensions. This information is used to identify and handle Elm source files in tooling and processing pipelines.",
      "description_length": 305,
      "index": 54,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Kotlin.Syntax",
      "library": "comby-kernel.matchers",
      "description": "This module defines syntactic elements specific to Kotlin, including delimiters for string literals, escapable and raw string configurations, and comment styles. It provides precise syntax markers used for parsing and matching Kotlin code structures. Use cases include configuring parsers to correctly identify Kotlin strings, comments, and embedded expressions.",
      "description_length": 362,
      "index": 55,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Assembly.Info",
      "library": "comby-kernel.matchers",
      "description": "This module defines metadata for assembly languages, including the language name and associated file extensions. It provides direct access to these properties through the `name` and `extensions` values. Use this module to identify and categorize assembly language files based on their extensions or to retrieve the canonical name of the language.",
      "description_length": 346,
      "index": 56,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Java.Info",
      "library": "comby-kernel.matchers",
      "description": "This module defines metadata for the Java language, including the language name and file extensions. It works with string and list data types to store and retrieve this information. Concrete use cases include identifying Java files by extension and referencing the language name in tooling or configuration contexts.",
      "description_length": 316,
      "index": 57,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Languages.Go.Syntax",
      "library": "comby-kernel.matchers",
      "description": "This module defines syntax elements specific to the Go language, including user-defined delimiters for string literals, escapable and raw string literal markers, and comment syntax. It provides precise pattern configurations for parsing and matching Go code structures. Use this module to customize or extend syntax recognition for Go in code analysis, transformation, or templating tasks.",
      "description_length": 389,
      "index": 58,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Ruby.Syntax",
      "library": "comby-kernel.matchers",
      "description": "This module defines syntax elements for Ruby, including delimiters for user-defined strings, escapable and raw string literals, and comment styles. It provides precise pattern-matching configurations tailored to Ruby's syntactic conventions. Use cases include parsing Ruby code, identifying string boundaries, and handling comments in code analysis tools.",
      "description_length": 355,
      "index": 59,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Clojure.Info",
      "library": "comby-kernel.matchers",
      "description": "This module defines metadata for the Clojure programming language, including its name and file extensions. It works with string and list data types to store and retrieve language-specific identifiers. Concrete use cases include language detection based on file extensions and providing human-readable names for Clojure files in tooling interfaces.",
      "description_length": 347,
      "index": 60,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Matlab.Syntax",
      "library": "comby-kernel.matchers",
      "description": "This module defines syntactic elements specific to MATLAB, including user-defined delimiters for blocks, escapable and raw string literals, and comment styles. It provides precise syntax configurations for parsing MATLAB code, such as handling string boundaries and comment markers. These values are used directly in parsing and analyzing MATLAB source files, especially in tools like linters, formatters, or code analyzers.",
      "description_length": 424,
      "index": 61,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.CSS.Syntax",
      "library": "comby-kernel.matchers",
      "description": "This module defines syntax elements for parsing and matching CSS code. It specifies delimiters for user-defined sections, escapable and raw string literals, and comment styles. These values support accurate tokenization and pattern matching in CSS analysis tools.",
      "description_length": 263,
      "index": 62,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.GraphQL.Info",
      "library": "comby-kernel.matchers",
      "description": "This module defines metadata about a GraphQL implementation, including the name of the language or tool and a list of supported extensions. It is used to identify and configure GraphQL processors with specific capabilities. Concrete use cases include determining extension support for schema validation and enabling tool-specific features in GraphQL servers or linters.",
      "description_length": 369,
      "index": 63,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Elixir.Info",
      "library": "comby-kernel.matchers",
      "description": "This module defines metadata for the Elixir programming language, including its name and associated file extensions. It works with string and list data types to store and expose language-specific identifiers. Concrete use cases include language detection based on file names or extensions and providing human-readable names for tooling integration.",
      "description_length": 348,
      "index": 64,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Html.Syntax",
      "library": "comby-kernel.matchers",
      "description": "This module defines syntax elements for parsing HTML, including user-defined delimiters, escapable and raw string literals, and comment structures. It provides precise configurations for handling HTML-specific syntax features like tag boundaries, quoted attributes, and comment blocks. Use cases include building parsers that correctly interpret HTML constructs such as `<div class=\"...\">` or `<!-- comments -->`.",
      "description_length": 413,
      "index": 65,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Languages.Erlang.Syntax",
      "library": "comby-kernel.matchers",
      "description": "This module defines syntax elements specific to Erlang, including user-defined delimiters for macros, escapable and raw string literals, and comment styles. It provides precise syntactic patterns for parsing and matching Erlang code constructs. Use cases include implementing custom parsers, linters, or code transformation tools that require accurate recognition of Erlang's syntax features.",
      "description_length": 392,
      "index": 66,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Languages.Assembly.Syntax",
      "library": "comby-kernel.matchers",
      "description": "This module defines syntax elements for assembly languages, including user-defined delimiters, escapable and raw string literals, and comment styles. It works with tuples, lists, and custom types like `comment_kind` and `escapable_string_literals`. Concrete use cases include parsing and tokenizing assembly source code with support for various syntax conventions.",
      "description_length": 364,
      "index": 67,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Bash.Info",
      "library": "comby-kernel.matchers",
      "description": "This module defines metadata for the Bash programming language, including its name and file extensions. It provides direct access to the language's identifier and a list of associated file extensions. Useful for tools that need to recognize or process Bash scripts based on filename or language name.",
      "description_length": 300,
      "index": 68,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Generic.Syntax",
      "library": "comby-kernel.matchers",
      "description": "This module defines syntax elements for parsing and processing code in a generic language. It includes delimiters for user-defined blocks, escapable and raw string literals, and comment styles. These values are used to configure parsers for domain-specific languages or code analysis tools.",
      "description_length": 290,
      "index": 69,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Xml.Syntax",
      "library": "comby-kernel.matchers",
      "description": "This module defines syntax elements for XML parsing, including user-defined delimiters, escapable and raw string literals, and comment structures. It provides specific configurations for handling XML syntax constructs like tags, attributes, and comments. Use cases include parsing XML documents with custom delimiters or extended string literal formats.",
      "description_length": 353,
      "index": 70,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Reason.Info",
      "library": "comby-kernel.matchers",
      "description": "This module defines metadata for the Reason programming language, including its name and file extensions. It provides direct access to the language's identifier and a list of associated file extensions. Useful for tools that need to recognize or process Reason source files based on naming conventions.",
      "description_length": 302,
      "index": 71,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Languages.Matlab.Info",
      "library": "comby-kernel.matchers",
      "description": "This module defines metadata for the MATLAB programming language, including its name and file extensions. It provides direct access to the language name as a string and a list of associated file extensions. Useful for identifying MATLAB files by extension or referencing the language name in tooling or configuration contexts.",
      "description_length": 326,
      "index": 72,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Scala.Info",
      "library": "comby-kernel.matchers",
      "description": "This module defines metadata for the Scala programming language, including its name and associated file extensions. It works with string and list data types to store and provide access to this information. Concrete use cases include language detection based on file extensions and providing human-readable names for language identifiers.",
      "description_length": 337,
      "index": 73,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Move.Syntax",
      "library": "comby-kernel.matchers",
      "description": "This module defines syntax elements for the Move programming language, including delimiters for user-defined tokens, escapable and raw string literals, and comment styles. It provides concrete configurations for parsing and lexing Move code. Use this module when implementing or extending Move language parsers to handle syntactic constructs correctly.",
      "description_length": 352,
      "index": 74,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Xml.Info",
      "library": "comby-kernel.matchers",
      "description": "This module defines metadata for XML files, including the language name and associated file extensions. It provides direct access to the name and a list of extensions as string values. Useful for identifying XML files based on their extension or referencing the language name in tooling contexts.",
      "description_length": 296,
      "index": 75,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Text.Syntax",
      "library": "comby-kernel.matchers",
      "description": "This module defines syntax elements for parsing text-based languages, including delimiters for user-defined blocks, escapable and raw string literals, and comment styles. It works with lists of string pairs for delimiters and literals, and a list of comment kinds. Concrete use cases include configuring parsers to handle custom syntax in domain-specific languages or templating systems.",
      "description_length": 387,
      "index": 76,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Latex.Info",
      "library": "comby-kernel.matchers",
      "description": "This module defines metadata for the LaTeX language, including its name and associated file extensions. It provides direct access to a list of common file extensions used by LaTeX documents. Concrete use cases include identifying LaTeX files based on extension or displaying language information in tooling interfaces.",
      "description_length": 318,
      "index": 77,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Paren.Info",
      "library": "comby-kernel.matchers",
      "description": "This module defines metadata for a programming language, specifically its name and associated file extensions. It works with basic string and list data types to store and retrieve this information. A typical use case is to identify and categorize source files based on their extension or language name.",
      "description_length": 302,
      "index": 78,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Haskell.Info",
      "library": "comby-kernel.matchers",
      "description": "This module defines metadata for the Haskell language, including its name and file extensions. It provides direct access to a string identifier and a list of associated file extensions. Useful for language detection or configuration in code analysis tools.",
      "description_length": 256,
      "index": 79,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Latex.Syntax",
      "library": "comby-kernel.matchers",
      "description": "This module defines syntax elements for LaTeX parsing, including user-defined delimiters for macros, escapable and raw string literals, and comment styles. It works with tuples and lists to represent pairs of delimiters, string literals, and comment markers. Concrete use cases include configuring parsers to recognize LaTeX-specific syntax constructs like `\\macro{}`, `% comments`, and escaped characters.",
      "description_length": 406,
      "index": 80,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Typescript.Info",
      "library": "comby-kernel.matchers",
      "description": "This module defines metadata for TypeScript files, including the language name and associated file extensions. It works with string and list data types to store and retrieve this information. Concrete use cases include identifying TypeScript files by extension and referencing the language name in tooling or configuration contexts.",
      "description_length": 332,
      "index": 81,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Languages.Scala.Syntax",
      "library": "comby-kernel.matchers",
      "description": "This module defines syntax elements specific to Scala, including delimiters for user-defined literals, escapable and raw string literal markers, and comment styles. It provides precise syntactic patterns for parsing and matching Scala code constructs. Use this module to handle Scala-specific syntax when analyzing or transforming code.",
      "description_length": 336,
      "index": 82,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Php.Info",
      "library": "comby-kernel.matchers",
      "description": "This module defines metadata for PHP language support, including the language name and associated file extensions. It provides direct access to the name and a list of extensions used to identify PHP files. This information is used in language detection and file handling workflows.",
      "description_length": 281,
      "index": 83,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Elm.Syntax",
      "library": "comby-kernel.matchers",
      "description": "This module defines syntax elements for parsing and matching Elm code, including delimiters for user-defined tokens, escapable and raw string literals, and comment styles. It provides concrete configurations for handling Elm-specific syntax features like triple-quote strings and `--` comments. Use this module when implementing parsers or syntax highlighters that need to accurately recognize Elm's syntactic constructs.",
      "description_length": 421,
      "index": 84,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.JSON.Syntax",
      "library": "comby-kernel.matchers",
      "description": "This module defines syntax elements for parsing and handling JSON-like structures, including customizable delimiters, escapable and raw string literals, and comment formats. It works with lists of string pairs for delimiters and literals, and structured comment kinds. Concrete use cases include configuring parsers to recognize specific JSON syntax variations, such as non-standard quotation marks or comment styles.",
      "description_length": 417,
      "index": 85,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Php.Syntax",
      "library": "comby-kernel.matchers",
      "description": "This module defines syntax elements specific to PHP, including user-defined delimiters for strings, escapable and raw string literal markers, and comment styles. It provides precise pattern-matching configurations for parsing PHP code structures. Use cases include building parsers or linters that require accurate recognition of PHP syntax elements like heredoc strings, comments, and string escapes.",
      "description_length": 401,
      "index": 86,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Languages.Clojure.Syntax",
      "library": "comby-kernel.matchers",
      "description": "This module defines syntax elements for parsing Clojure code, including user-defined delimiters, escapable and raw string literals, and comment styles. It provides concrete values that specify how Clojure syntax constructs are recognized in source code. Use this module to configure parsers or syntax highlighters specifically for Clojure.",
      "description_length": 339,
      "index": 87,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Nim.Info",
      "library": "comby-kernel.matchers",
      "description": "This module defines metadata for the Nim programming language, including its name and associated file extensions. It provides direct access to the language name as a string and a list of common file extensions used for Nim source files. This information is useful for tools that need to identify or process Nim files based on their extension or refer to the language name programmatically.",
      "description_length": 389,
      "index": 88,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Template.Make.Matching",
      "library": "comby-kernel.matchers",
      "description": "This module provides a list of parsers for different hole sorts, used to match and extract values from strings. It works with `Hole.sort` and `string Vangstrom.t` parsers. Concrete use cases include parsing template holes in a structured format, such as extracting variable names or typed values from a string template.",
      "description_length": 319,
      "index": 89,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.HCL.Info",
      "library": "comby-kernel.matchers",
      "description": "This module defines metadata for the HCL (HashiCorp Configuration Language) format, including the language name and associated file extensions. It provides direct access to static information used for identifying and handling HCL files. Concrete use cases include configuring parsers, setting up file type recognition, and initializing language-specific tooling.",
      "description_length": 362,
      "index": 90,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Coq.Syntax",
      "library": "comby-kernel.matchers",
      "description": "This module defines syntax elements for parsing and matching Coq code, including user-defined delimiters, escapable and raw string literals, and comment styles. It provides concrete configurations for handling Coq-specific syntax constructs like custom notations, string enclosures, and comment delimiters. Use cases include building parsers or linters that require precise recognition of Coq's syntactic elements.",
      "description_length": 414,
      "index": 91,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.GraphQL.Syntax",
      "library": "comby-kernel.matchers",
      "description": "This module defines syntax elements for parsing and matching GraphQL queries, including delimiters for variables, string literals with escape support, raw string boundaries, and comment styles. It works with lists of string pairs for delimiters and literals, optional escape configurations, and comment kind enumerations. Concrete use cases include tokenizing GraphQL documents, handling variable interpolation, and stripping or processing comments during schema or query analysis.",
      "description_length": 481,
      "index": 92,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Zig.Info",
      "library": "comby-kernel.matchers",
      "description": "This module defines metadata for the Zig programming language, including its name and associated file extensions. It provides direct access to the language name as a string and a list of common file extensions used for Zig source files. This information is used in tooling to identify and process Zig code based on its file extension or display the correct language name.",
      "description_length": 371,
      "index": 93,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.JSONC.Syntax",
      "library": "comby-kernel.matchers",
      "description": "This module defines syntax elements for JSONC, including user-defined delimiters, escapable and raw string literals, and comment styles. It provides precise configurations for parsing and handling JSONC content. Use this module to customize or extend JSONC parsing behavior in language processing tools.",
      "description_length": 303,
      "index": 94,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.C.Syntax",
      "library": "comby-kernel.matchers",
      "description": "This module defines syntactic elements specific to C-like languages, including delimiters for user-defined literals, escapable and raw string literal markers, and comment syntax variations. It supports parsing and matching operations by specifying how strings, comments, and custom syntax constructs are recognized in C-based source code. Concrete use cases include configuring parsers to handle C++ user-defined literals or distinguishing between different comment styles in C and C++.",
      "description_length": 486,
      "index": 95,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Languages.Solidity.Syntax",
      "library": "comby-kernel.matchers",
      "description": "This module defines syntax elements for parsing Solidity code, including user-defined delimiters, escapable and raw string literals, and comment styles. It provides precise syntactic patterns used to identify and tokenize Solidity source code elements. Use this module when implementing or extending Solidity parsers that require accurate recognition of string literals, comments, and custom delimiters in source files.",
      "description_length": 419,
      "index": 96,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Erlang.Info",
      "library": "comby-kernel.matchers",
      "description": "This module defines metadata for the Erlang language, including its name and file extensions. It provides direct access to the language name as a string and a list of associated file extensions. Useful for tools that need to identify or process Erlang source files based on naming conventions or language-specific attributes.",
      "description_length": 325,
      "index": 97,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Haskell.Syntax",
      "library": "comby-kernel.matchers",
      "description": "This module defines syntax elements for parsing Haskell code, including delimiters for user-defined constructs, escapable and raw string literals, and comment styles. It provides concrete configurations for handling Haskell-specific syntax features like `{- ... -}` for block comments and `\"` for string literals. Use this module when implementing parsers or syntax highlighters that need to accurately recognize and process Haskell's syntactic structures.",
      "description_length": 456,
      "index": 98,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Bash.Syntax",
      "library": "comby-kernel.matchers",
      "description": "This module defines syntax elements for Bash scripting, including user-defined delimiters, escapable and raw string literals, and comment styles. It provides precise syntactic rules for parsing and matching Bash code structures. Use this module to handle string interpolation, heredoc delimiters, and comment stripping in Bash scripts.",
      "description_length": 335,
      "index": 99,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Fsharp.Info",
      "library": "comby-kernel.matchers",
      "description": "This module defines metadata for the F# programming language, including the language name and associated file extensions. It provides direct access to the `name` and `extensions` values, which identify the language and its common file formats. This information is used in language detection and file handling workflows where specific syntax or structure rules apply to F# source files.",
      "description_length": 385,
      "index": 100,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Languages.Tsx.Info",
      "library": "comby-kernel.matchers",
      "description": "This module defines metadata for the TSX language, including its name and file extensions. It provides direct access to the language's identifier and a list of associated file extensions. Useful for tools that need to recognize or process TSX files based on their extension or display the language name.",
      "description_length": 303,
      "index": 101,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Python.Syntax",
      "library": "comby-kernel.matchers",
      "description": "This module defines syntax elements specific to Python, including user-defined delimiters, escapable and raw string literals, and comment kinds. It provides precise syntactic patterns for parsing and matching Python code constructs. Use cases include building parsers, linters, or code transformation tools that require accurate recognition of Python's syntactic features.",
      "description_length": 372,
      "index": 102,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Lisp.Syntax",
      "library": "comby-kernel.matchers",
      "description": "This module defines syntax elements for parsing Lisp-like languages, including delimiters for user-defined forms, escapable and raw string literals, and comment styles. It works with tuples and lists to specify patterns for syntax components such as brackets, quotes, and comment markers. Concrete use cases include configuring parsers to recognize custom Lisp macros, handling string interpolation, and supporting different comment conventions in Lisp dialects.",
      "description_length": 462,
      "index": 103,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Languages.Java.Syntax",
      "library": "comby-kernel.matchers",
      "description": "This module defines syntax elements specific to Java, including user-defined delimiters, escapable and raw string literals, and comment kinds. It provides precise syntactic patterns for parsing and analyzing Java code. Use this module when implementing Java-specific parsing rules or syntax highlighting in code analysis tools.",
      "description_length": 327,
      "index": 104,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Languages.Coq.Info",
      "library": "comby-kernel.matchers",
      "description": "This module defines metadata for the Coq language, including its name and associated file extensions. It provides direct access to the language identifier and a list of common file extensions used in Coq projects. This information is useful for tooling that needs to recognize or process Coq source files based on their extension or name.",
      "description_length": 338,
      "index": 105,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Fortran.Info",
      "library": "comby-kernel.matchers",
      "description": "This module defines metadata for the Fortran language, including its name and associated file extensions. It works with string and list data types to store and retrieve this information. Concrete use cases include identifying Fortran source files by extension and displaying the language name in tooling interfaces.",
      "description_length": 315,
      "index": 106,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Elixir.Syntax",
      "library": "comby-kernel.matchers",
      "description": "This module defines syntactic elements specific to Elixir, such as delimiters for expressions, string literal markers, and comment styles. It includes configurations for handling escapable and raw strings, as well as different types of comments. Concrete use cases include parsing Elixir code, identifying string boundaries, and stripping or processing comments during code analysis.",
      "description_length": 383,
      "index": 107,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Zig.Syntax",
      "library": "comby-kernel.matchers",
      "description": "This module defines syntax elements for parsing Zig code, including user-defined delimiters for blocks, escapable and raw string literals, and comment styles. It provides concrete configurations for tokenizing Zig source files, supporting accurate parsing of strings and comments. Use this module to integrate Zig syntax rules into a parser or linter that processes Zig source code.",
      "description_length": 382,
      "index": 108,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.JSON.Info",
      "library": "comby-kernel.matchers",
      "description": "This module defines metadata for the JSON language, including the language name and associated file extensions. It provides direct access to a string identifier and a list of strings representing common JSON file extensions. This information supports tools that need to recognize or process JSON files based on naming conventions, such as syntax highlighters or linters.",
      "description_length": 370,
      "index": 109,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Script.Make.Parser",
      "library": "comby-kernel.matchers",
      "description": "This module supports parsing and manipulation of script strings containing variables and structured syntax through low-level utilities and template operations. It works with abstract syntax trees (`Matchers__.Types.Ast`), environment mappings (`Match.Environment.t`), and template atoms to enable expression building, pattern matching, and substitution workflows. Key use cases include processing domain-specific language scripts, transforming expressions via rewriting rules, and extracting or injecting variables within structured text.",
      "description_length": 538,
      "index": 110,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Dyck.Info",
      "library": "comby-kernel.matchers",
      "description": "This module defines metadata for a specific language, including its name and associated file extensions. It works with string and list data types to store and retrieve this information. Concrete use cases include identifying the language by name and determining file types that belong to it using the extension list.",
      "description_length": 316,
      "index": 111,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Tsx.Syntax",
      "library": "comby-kernel.matchers",
      "description": "This module defines syntax elements for parsing and matching TypeScript JSX (TSX) code. It specifies delimiters for embedded expressions, escapable and raw string literals, and comment styles. These values support accurate pattern matching in TSX templates, such as identifying interpolated expressions or handling tagged templates with custom syntax.",
      "description_length": 351,
      "index": 112,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.R.Info",
      "library": "comby-kernel.matchers",
      "description": "This module defines metadata for the R programming language, including its name and file extensions. It provides direct access to the language name as a string and a list of associated file extensions. Concrete use cases include identifying R files by extension and referencing the language name in tooling or configuration contexts.",
      "description_length": 333,
      "index": 113,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Javascript.Syntax",
      "library": "comby-kernel.matchers",
      "description": "This module defines syntax elements specific to JavaScript, including delimiters for blocks, escapable and raw string literals, and comment styles. It provides precise string patterns and configurations that match JavaScript's syntactic conventions. Use this module to configure parsers or formatters that require accurate JavaScript syntax recognition, such as code analyzers or transpilers.",
      "description_length": 392,
      "index": 114,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Jsx.Info",
      "library": "comby-kernel.matchers",
      "description": "This module defines metadata for a JSX language variant, including its name and associated file extensions. It works with string and list data types to store and retrieve language-specific identifiers. Concrete use cases include configuring parsers or tools to recognize JSX files based on their extension or display name.",
      "description_length": 322,
      "index": 115,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Dart.Syntax",
      "library": "comby-kernel.matchers",
      "description": "This module defines syntax elements for parsing and matching Dart code, including delimiters for user-defined tokens, escapable and raw string literals, and comment styles. It provides precise syntactic patterns used in Dart, such as handling string interpolation and multiline comments. These values are used directly in constructing parsers or matchers tailored to Dart source files.",
      "description_length": 385,
      "index": 116,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Javascript",
      "library": "comby-kernel.matchers",
      "description": "This module provides metadata and syntax definitions for JavaScript. It includes operations to retrieve language name and file extensions, as well as configurations for JavaScript's syntactic elements like string literals, comments, and block delimiters. Concrete use cases include configuring code analyzers, transpilers, and formatters to accurately parse and process JavaScript files.",
      "description_length": 387,
      "index": 117,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Omega.Xml",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to match XML templates against source code, extracting matches based on configurable rules. It operates on XML structures represented as strings, supporting concrete use cases like identifying code patterns in XML-based configurations or source files. Key operations include finding all matches, retrieving the first match with optional offset, and setting a rewrite template for transformation tasks.",
      "description_length": 432,
      "index": 118,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Alpha.Jsx",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to match and transform JSX expressions using customizable templates. It operates on abstract syntax trees (ASTs) derived from source code, specifically targeting JSX structures. Use cases include code refactoring, pattern-based code analysis, and automated code generation for JSX-based frameworks.",
      "description_length": 329,
      "index": 119,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Omega.Generic",
      "library": "comby-kernel.matchers",
      "description": "This module performs structural matching of code patterns in source files using customizable templates. It supports operations to find all matches or the first match of a given template in a source string, with options to configure matching behavior, file context, and rule expressions. Use cases include automated code refactoring, static analysis, and enforcing coding standards by identifying specific syntactic structures in OCaml code.",
      "description_length": 440,
      "index": 120,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Languages.Jsx",
      "library": "comby-kernel.matchers",
      "description": "This module implements support for JSX language variants by defining syntax rules and metadata. It handles string literals, delimiters, and file extensions to enable precise parsing and configuration. Use cases include integrating JSX handling in compilers, linters, or code transformation tools.",
      "description_length": 296,
      "index": 121,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Alpha.Elixir",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to match and extract patterns from Elixir source code using a specified template. It supports finding all matches or the first match in a given source string, with options to customize configuration, file path, and rewrite templates. The primary data types include match results and Elixir AST expressions, and it is used for analyzing or transforming Elixir code programmatically.",
      "description_length": 412,
      "index": 122,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Dyck",
      "library": "comby-kernel.matchers",
      "description": "This module implements a Dyck language matcher that identifies and processes nested delimiter structures. It works with string and list data types to define and validate sequences of opening and closing delimiters. Use it to parse languages or formats where balanced parentheses, brackets, or other paired symbols are essential, such as expression evaluators or structured data formats.",
      "description_length": 386,
      "index": 123,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Alpha.Paren",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to match and extract content enclosed in parentheses from source code. It supports retrieving all matches, the first match, or setting a rewrite template for transformations. The module works with strings as input and output, and uses configurations, file paths, and shift offsets to customize matching behavior. Use cases include parsing expressions, extracting function arguments, or rewriting parenthetical structures in code.",
      "description_length": 460,
      "index": 124,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Alpha.Csharp",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions for matching C# code patterns using customizable templates and configurations. It supports operations to find all matches or the first match in a source string, with options to adjust matching behavior via parameters like file path, shift offset, and configuration settings. The module works directly with C# source code strings and expression templates, enabling targeted analysis or transformation tasks such as code refactoring, static analysis, or pattern-based code generation.",
      "description_length": 513,
      "index": 125,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Languages.Fortran",
      "library": "comby-kernel.matchers",
      "description": "This module provides metadata and syntactic definitions for Fortran, handling operations such as file extension checks, string literal parsing, and comment syntax recognition. It works with strings and lists to support concrete use cases like identifying Fortran source files and configuring code analysis tools to correctly parse Fortran dialects.",
      "description_length": 348,
      "index": 126,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Alpha.Dyck",
      "library": "comby-kernel.matchers",
      "description": "This module implements Dyck language matching for structured code patterns, providing precise matching and rewriting capabilities. It operates on string-based templates and source code, producing match results with contextual details. Use it to define and apply structured code transformations or static analysis rules with customizable templates and error handling.",
      "description_length": 366,
      "index": 127,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Haskell",
      "library": "comby-kernel.matchers",
      "description": "This module provides precise metadata and syntax definitions for Haskell, including file extensions and language identifiers. It specifies delimiters, string literals, and comment styles such as `{- ... -}` and `\"` for accurate parsing and syntax processing. Use it to implement Haskell-aware tools like parsers, linters, or syntax highlighters.",
      "description_length": 345,
      "index": 128,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Go",
      "library": "comby-kernel.matchers",
      "description": "This module provides metadata and syntax definitions for the Go programming language. It includes operations to retrieve the language name and file extensions, as well as configure string delimiters, escape sequences, and comment syntax. Concrete use cases include identifying Go source files by extension and customizing code parsers or formatters for Go-specific syntax patterns.",
      "description_length": 381,
      "index": 129,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Alpha.Swift",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to match and rewrite Swift code patterns using templates. It supports finding all matches or the first match in a source string, with configurable options, and allows setting a template for rewriting matched code. It operates on Swift source strings and expression structures, commonly used for code transformation tasks like refactoring or linting.",
      "description_length": 380,
      "index": 130,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Alpha.Reason",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to match and transform code patterns in ReasonML source files using customizable templates. It operates on strings representing source code and templates, supporting concrete syntax tree manipulations through configuration parameters. Use cases include automated code refactoring, linting, and enforcing coding standards in ReasonML projects.",
      "description_length": 373,
      "index": 131,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Omega.Scala",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to match and transform Scala code using templates. It supports finding all matches or the first match in a source string, with configurable parameters like file path and rule expressions. Use cases include automated code refactoring and static analysis tasks where specific Scala code patterns need to be identified or rewritten.",
      "description_length": 360,
      "index": 132,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Alpha.Solidity",
      "library": "comby-kernel.matchers",
      "description": "Matches Solidity code patterns using customizable templates, supporting full or first-match-only operations. Works with Solidity source files and abstract syntax trees, enabling precise structural queries. Useful for code analysis, transformation, and validation tasks in Solidity projects.",
      "description_length": 290,
      "index": 133,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Alpha.C",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to match and transform code patterns in string-based source code using a named template system. It supports finding all matches or the first match with optional configuration, file context, and rule-based filtering, returning structured match results. Use cases include automated code refactoring, pattern-based code analysis, and templated code transformations.",
      "description_length": 393,
      "index": 134,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Alpha.Pascal",
      "library": "comby-kernel.matchers",
      "description": "This module performs pattern matching on Pascal source code using a specified template and source string, extracting matches or applying rewrite rules. It operates on strings representing Pascal code, with optional configuration, file path, and rule parameters. Use cases include code analysis, transformation, and validation within Pascal projects.",
      "description_length": 349,
      "index": 135,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Omega.JSONC",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to match and extract data from JSONC content using templates. It supports finding all matches or the first match with optional configuration, file context, and template rewriting. Use cases include parsing and transforming JSONC files with customizable templates and rule-based extraction.",
      "description_length": 320,
      "index": 136,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Omega.Java",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions for matching and transforming Java code using templates. It supports operations like finding all matches in a source file, retrieving the first match with error handling, and applying rewrite templates. The module works directly with Java abstract syntax trees, string-based templates, and source code files, targeting specific use cases such as code refactoring, static analysis, and automated code transformations.",
      "description_length": 447,
      "index": 137,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Alpha.Make",
      "library": "comby-kernel.matchers",
      "description": "This module implements functions for matching and extracting patterns in source code using customizable templates. It supports operations like `all` to find all matches and `first` to retrieve the first match with optional configuration and source adjustments. The module works with string-based templates and source inputs, producing match results that can be used for analysis or transformation tasks.",
      "description_length": 403,
      "index": 138,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Alpha.Python",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to match Python code patterns using string templates, supporting operations to find all matches or the first match in a source string. It works with Python abstract syntax trees and string-based templates, handling matches with configurable settings and file context. Use cases include code analysis, transformation, and validation based on specific Python code structures.",
      "description_length": 404,
      "index": 139,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Alpha.Kotlin",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to match and transform Kotlin source code using predefined templates. It supports operations like finding all matches, extracting the first match, and rewriting code based on a specified template. The module works directly with Kotlin AST expressions and string-based source code, targeting specific use cases such as code analysis, refactoring, and transformation in Kotlin projects.",
      "description_length": 415,
      "index": 140,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Omega.Jsx",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to match and transform JSX code patterns in OCaml. It supports finding all matches or the first match of a given template in a source string, with options to configure matching behavior, file context, and transformation rules. Use cases include automated code refactoring, linting, and syntax transformation in JSX-based projects.",
      "description_length": 361,
      "index": 141,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Alpha.Move",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to match and transform code patterns using a specified template and source. It operates on string-based code inputs and supports retrieving all matches or the first match with optional configuration parameters. Use cases include automated code refactoring and pattern-based code analysis.",
      "description_length": 319,
      "index": 142,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Alpha.Xml",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to match XML templates against source code, extracting matches based on structural patterns. It operates on XML-formatted strings and supports configuration options, file paths, and rule-based filtering. Use cases include code analysis, transformation, and querying specific XML structures within source files.",
      "description_length": 341,
      "index": 143,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Move",
      "library": "comby-kernel.matchers",
      "description": "This module provides structured definitions for the Move programming language, including its name, file extensions, and core syntax elements. It supports tools that process Move source files by enabling language identification, file filtering, and accurate parsing of Move's syntactic constructs. Use it to configure linters, IDE integrations, or custom parsers requiring precise Move language metadata and syntax rules.",
      "description_length": 420,
      "index": 144,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Xml",
      "library": "comby-kernel.matchers",
      "description": "This module handles XML-specific metadata and syntax configurations. It provides operations to retrieve XML language names and extensions, and defines syntax rules for parsing XML constructs like tags, attributes, and custom string literals. It is used for identifying XML files by extension and parsing XML documents with non-standard delimiters or extended syntax features.",
      "description_length": 375,
      "index": 145,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Omega.Lisp",
      "library": "comby-kernel.matchers",
      "description": "Matches Lisp expressions in source code using customizable templates and configuration. It supports finding all matches or the first match, with options to adjust matching behavior via parameters like shift and configuration. The module works directly with strings for both source code and templates, and it operates on Lisp-like syntax structures. Use cases include code analysis, transformation, and refactoring tasks specific to Lisp dialects.",
      "description_length": 446,
      "index": 146,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Assembly",
      "library": "comby-kernel.matchers",
      "description": "This module handles metadata and syntax definitions for assembly languages. It provides direct access to language names and file extensions in the `Info` submodule, and defines syntax elements like delimiters, string literals, and comment styles in the `Syntax` submodule. Use it to categorize assembly files by extension or parse assembly code with support for custom syntax conventions.",
      "description_length": 388,
      "index": 147,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Omega.Go",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to match and rewrite code patterns in source files using a specified template. It operates on strings representing source code and templates, returning match results or rewritten code. Use it to automate code transformations or enforce coding standards in specific files.",
      "description_length": 302,
      "index": 148,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Alpha.Text",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to match text patterns using a specified template and source, supporting operations to find all matches or the first match with optional configuration and file context. It works with strings for template and source input, and uses a shift parameter to adjust match positions. Concrete use cases include parsing and transforming code snippets based on textual patterns, such as identifying and rewriting specific syntactic constructs in source files.",
      "description_length": 480,
      "index": 149,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Text",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to define and manage metadata and syntax rules for text-based languages. It operates on strings and lists to handle tasks like mapping file extensions to language names and specifying delimiters for parsing. Concrete use cases include configuring syntax highlighting systems and building parsers for domain-specific languages with custom block structures and comment styles.",
      "description_length": 405,
      "index": 150,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Omega.Latex",
      "library": "comby-kernel.matchers",
      "description": "This module performs LaTeX-specific pattern matching and transformation operations on source code. It provides functions to extract matches (`all`) or find the first match (`first`) using a template and source string, supporting configurable matching rules and file contexts. The module works directly with LaTeX syntax, enabling use cases like detecting and rewriting specific macro patterns in LaTeX documents.",
      "description_length": 412,
      "index": 151,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Omega.Julia",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to match and rewrite Julia source code using a specified template. It supports finding all matches or the first match in a source string, with configurable parameters like file path and rule expressions. The module works directly with Julia AST expressions, strings as input sources, and Match.t structures to represent results. Use cases include code transformation tasks such as refactoring Julia code or enforcing coding standards through pattern matching.",
      "description_length": 490,
      "index": 152,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Languages.R",
      "library": "comby-kernel.matchers",
      "description": "This module provides metadata and syntax definitions for the R programming language. It includes operations to identify R files by extension and configure parsing rules for R-specific syntax elements such as backtick-quoted identifiers, user-defined operators, and `#`-prefixed comments. Concrete use cases include source code analysis tools like linters and parsers that require precise recognition of R's syntactic structures.",
      "description_length": 428,
      "index": 153,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Languages.OCaml",
      "library": "comby-kernel.matchers",
      "description": "This module provides metadata and syntax definitions for the OCaml language. It includes the language name, file extensions, string delimiters, escape sequences, and comment styles. Use it to identify OCaml files or configure tools like parsers, linters, and formatters that require precise language syntax handling.",
      "description_length": 316,
      "index": 154,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Alpha.Javascript",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to match JavaScript code patterns using a template and source string, returning either all matches or the first match found. It operates on JavaScript AST expressions and supports configuration options, file paths, and custom rewrite templates. Use cases include code analysis, transformation, and validation within JavaScript projects.",
      "description_length": 367,
      "index": 155,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Clojure",
      "library": "comby-kernel.matchers",
      "description": "This module provides metadata and syntax definitions for the Clojure programming language. It includes file extensions and language names for identification, and specifies syntax elements like delimiters, string literals, and comments for parsing and highlighting Clojure code. Use it to detect Clojure files by extension or configure syntax-aware tools like parsers and formatters.",
      "description_length": 382,
      "index": 156,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Omega.GraphQL",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to match and extract data from GraphQL documents using a template-based approach. It supports operations like `all` to find all matches and `first` to retrieve the first match with optional configuration and file context. The module works with GraphQL documents and strings, enabling use cases like schema validation and query transformation.",
      "description_length": 373,
      "index": 157,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Alpha.Scala",
      "library": "comby-kernel.matchers",
      "description": "This module matches and transforms Scala code using customizable templates. It supports finding all matches or the first match between a template and a source string, with options to configure matching behavior, file context, and rewrite rules. Use cases include automated code refactoring, pattern-based code analysis, and enforcing coding standards in Scala projects.",
      "description_length": 369,
      "index": 158,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Alpha.Go",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions for matching and transforming source code using predefined templates. It operates on strings representing source code and templates, producing lists of matches or individual match results. Use it to find all occurrences of a pattern in code, retrieve the first match, or configure rewrite templates for code transformations.",
      "description_length": 355,
      "index": 159,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Omega.HCL",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions for matching and transforming HCL (HashiCorp Configuration Language) code. It supports parsing source and template strings to identify matches based on HCL syntax rules, with options to configure matching behavior, shift results, or set rewrite templates. Use cases include linting, refactoring, and enforcing code patterns in HCL-based infrastructure configurations.",
      "description_length": 398,
      "index": 160,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Metasyntax.Default",
      "library": "comby-kernel.matchers",
      "description": "This module defines default syntax rules and identifiers for pattern matching constructs. It provides a list of hole syntax configurations, an identifier string, and a list of aliases used to recognize and transform specific syntactic forms. These values are used directly in parsing and matching code structures according to predefined patterns.",
      "description_length": 346,
      "index": 161,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Omega.Swift",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to match and rewrite Swift code using templates. It supports finding all matches or the first match in a source string, with configurable rules and file context. Use cases include automated code transformations and static analysis tasks specific to Swift.",
      "description_length": 286,
      "index": 162,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Omega.Python",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to match and rewrite Python code using templates. It supports finding all matches or the first match of a template in a source string, with options to configure matching behavior, shift results, or specify file paths. The module works directly with Python AST expressions, strings as input sources and templates, and produces match results or errors. Use cases include code transformation, static analysis, and refactoring of Python codebases using declarative templates.",
      "description_length": 502,
      "index": 163,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Omega.Html",
      "library": "comby-kernel.matchers",
      "description": "Performs HTML-specific matching operations using customizable rules and templates. It supports extracting matches from source HTML based on a given template, with options to configure matching behavior, shift results, or restrict to specific AST expressions. Use cases include parsing and transforming HTML snippets, extracting structured data from web pages, or implementing custom linting rules for HTML content.",
      "description_length": 414,
      "index": 164,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Alpha.JSONC",
      "library": "comby-kernel.matchers",
      "description": "This module matches JSONC content against string templates, extracting structured matches. It supports full or first-match extraction, template-based rewriting, and file extension filtering. Use it to parse and transform JSONC configuration files with customizable match rules.",
      "description_length": 277,
      "index": 165,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Alpha.Clojure",
      "library": "comby-kernel.matchers",
      "description": "This module matches Clojure code against string templates, returning all matches or the first match with optional configuration, file context, and template variables. It operates on Clojure source strings and expression templates, supporting concrete tasks like code analysis, transformation, and pattern-based querying. Use cases include linting, refactoring, and enforcing code structure rules in Clojure projects.",
      "description_length": 416,
      "index": 166,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Omega.Kotlin",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to match and transform Kotlin code using customizable templates. It supports finding all matches or the first match in a source string, with options to configure matching behavior, file context, and rewrite rules. Use cases include automated code refactoring, linting, and generating code transformations based on specific patterns in Kotlin files.",
      "description_length": 379,
      "index": 167,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Omega.Bash",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions for matching and extracting patterns from Bash source code using a specified template. It supports operations to find all matches or the first match in a given source string, with configurable parameters for rules and file context. Use cases include static analysis of Bash scripts, code transformation, and linting based on custom templates.",
      "description_length": 373,
      "index": 168,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Language.Syntax",
      "library": "comby-kernel.matchers",
      "description": "This module defines data structures and JSON serialization functions for representing syntax elements like string literals and comments in a language. It handles escapable and raw string delimiters, comment styles, and provides direct parsing and conversion to and from JSON using Yojson. Concrete use cases include configuring language-specific syntax rules and serializing them for storage or transmission.",
      "description_length": 408,
      "index": 169,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Omega.Typescript",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions for matching TypeScript code against string templates, supporting operations like `all` to find all matches and `first` to retrieve the first match with optional configuration and file context. It works with TypeScript AST expressions, strings as input source and template parameters, and returns structured match results. Use cases include code analysis, transformation, and targeted refactoring based on template patterns.",
      "description_length": 455,
      "index": 170,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Languages.Python",
      "library": "comby-kernel.matchers",
      "description": "This module provides precise definitions for Python's syntax elements and metadata. It includes syntax patterns for parsing constructs like strings and comments, and metadata such as language name and file extensions. It is used in tools like parsers, linters, and syntax highlighters to accurately process and identify Python source files.",
      "description_length": 340,
      "index": 171,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Omega.Tsx",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions for matching and extracting data from source code using templates. It operates on strings representing source code and templates, returning match results with optional configuration and file context. Use it to find all matches in a file or extract the first match, with support for setting rewrite templates and handling specific file extensions.",
      "description_length": 377,
      "index": 172,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Kotlin",
      "library": "comby-kernel.matchers",
      "description": "This module provides direct access to Kotlin language metadata, such as its name and common file extensions, and defines syntactic elements like string delimiters, escape sequences, and comment markers. It works with string literals, file extensions, and syntax configurations specific to Kotlin. Concrete use cases include configuring parsers to correctly identify Kotlin code structures and determining file type based on extension for tooling that processes Kotlin source files.",
      "description_length": 481,
      "index": 173,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Script.Make",
      "library": "comby-kernel.matchers",
      "description": "This module provides a domain-specific language for constructing and parsing logical expressions over script syntax, focusing on operations like logical operator combination (`And`, `Or`, `Not`), parenthetical grouping, and template handling. It operates on S-expressions, abstract syntax trees (`Matchers__.Types.Ast`), and environment mappings, leveraging the `Vangstrom` parser combinator library to manage whitespace, optional elements, and operator precedence. The tools are suited for scenarios requiring structured parsing of script-like logical expressions, such as configuration validation or domain-specific query languages.",
      "description_length": 634,
      "index": 174,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Omega.Paren",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to match and extract parenthetical expressions from source code. It supports finding all matches or the first match with customizable configuration, file context, and template-based rewriting. Use cases include code analysis, refactoring, and transformation tasks where structured pattern matching on parentheses is required.",
      "description_length": 356,
      "index": 175,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Alpha.Julia",
      "library": "comby-kernel.matchers",
      "description": "This module implements pattern matching and transformation for Julia source code. It provides functions to find all matches or the first match of a given template in a source file, supporting configurable matching and error handling. The module works directly with Julia AST expressions and string-based templates, enabling use cases like code refactoring, static analysis, and automated code generation.",
      "description_length": 404,
      "index": 176,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Alpha.Latex",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions for matching LaTeX expressions against templates, extracting structured matches from source text. It supports operations like finding all matches or the first match with optional configuration, file context, and template rewriting. Use cases include parsing and transforming LaTeX documents based on specific patterns.",
      "description_length": 349,
      "index": 177,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.C_nested_comments",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to define and configure language metadata and syntax for parsing C-like languages with nested comments. It works with strings and lists to specify comment delimiters, string literals, and file extensions. Concrete use cases include setting up parsers for C or C++ that handle nested comments and correctly process string literals with escape sequences.",
      "description_length": 383,
      "index": 178,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Rust",
      "library": "comby-kernel.matchers",
      "description": "This module provides metadata and syntax definitions for the Rust language. It includes the language name, file extensions, delimiters, string literals, and comment kinds. Useful for identifying Rust files by extension and parsing or analyzing Rust code with precise syntactic patterns.",
      "description_length": 286,
      "index": 179,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Omega.R",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to match and rewrite code patterns using a specified template and source. It operates on strings representing code, with support for configuration options, file paths, and rule-based transformations. Use it to find all matches in a source file or extract the first match with optional error handling.",
      "description_length": 331,
      "index": 180,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Reason",
      "library": "comby-kernel.matchers",
      "description": "This module provides metadata and syntax configurations for the Reason programming language. It includes identifiers and file extensions for language recognition, and defines syntax elements like string delimiters, comment styles, and JSX handling for accurate parsing and formatting. It is used directly by tools that process or analyze Reason source files, such as linters, formatters, and IDE integrations.",
      "description_length": 409,
      "index": 181,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Alpha.Rust",
      "library": "comby-kernel.matchers",
      "description": "This module implements pattern matching and transformation for Rust code using specific templates. It provides functions to find all matches or the first match of a template in a source string, supporting configurable matching and error handling. Use cases include code analysis, refactoring tools, and linting rules tailored to Rust syntax.",
      "description_length": 341,
      "index": 182,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Omega.Elixir",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to match and rewrite Elixir code patterns using templates. It supports finding all matches or the first match in a source string, with configurable rules and optional source rewriting. Use cases include automated code refactoring, static analysis, and enforcing coding standards in Elixir projects.",
      "description_length": 329,
      "index": 183,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Alpha.HCL",
      "library": "comby-kernel.matchers",
      "description": "This module matches HCL templates against source code, providing functions to find all matches or the first match with optional configuration and file context. It works with HCL expressions, strings as templates and sources, and supports setting a rewrite template for transformations. Concrete use cases include validating infrastructure-as-code files, detecting misconfigurations, and rewriting HCL blocks to conform to specific standards.",
      "description_length": 441,
      "index": 184,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Template.Make",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to parse, manipulate, and substitute template atoms, including extracting variables and converting templates back to strings. It works with `Matchers__.Types.Template.atom list` and `Match.Environment.t` to handle structured template processing. Concrete use cases include parsing and substituting variable placeholders in string templates during configuration or code generation tasks.",
      "description_length": 417,
      "index": 185,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Omega.Csharp",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to match and transform C# code using a specified template. It supports finding all matches or the first match in a source string, with options to configure matching behavior, and allows setting a rewrite template for transformations. The primary data types involved are strings for source code and templates, along with match results that capture the outcome of the matching process. It is used for tasks like code analysis, refactoring, and automated code generation in C# projects.",
      "description_length": 514,
      "index": 186,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Languages.Pascal",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to identify Pascal source files by extension and handle Pascal-specific syntax elements such as block delimiters, string literals, and comment styles. It operates on string and list data types, as well as custom records for comment kinds. Concrete use cases include file type detection based on extensions and parsing Pascal code with support for custom syntax structures.",
      "description_length": 403,
      "index": 187,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Languages.HCL",
      "library": "comby-kernel.matchers",
      "description": "This module provides metadata and syntax definitions for the HCL configuration language. It includes file extensions, identifier delimiters, string literals, and comment markers. Used for configuring parsers, enabling file type recognition, and supporting linters for HCL files.",
      "description_length": 278,
      "index": 188,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Alpha.Tsx",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to match and extract data from TypeScript JSX code using string templates. It supports finding all matches or the first match between a template and source code, with configurable parsing options and file context. Use cases include code analysis, transformation, and validation tasks specific to React or JSX-based codebases.",
      "description_length": 356,
      "index": 189,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Omega.Reason",
      "library": "comby-kernel.matchers",
      "description": "Performs structural matching of OCaml code using a custom template syntax, returning all matches or the first match with optional configuration and file context. Operates on OCaml AST expressions, supporting concrete use cases like code refactoring, static analysis, and pattern-based transformations. Uses a registered name and file extensions to identify applicable code files, with support for setting rewrite templates dynamically.",
      "description_length": 435,
      "index": 190,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Elixir",
      "library": "comby-kernel.matchers",
      "description": "This module provides metadata and syntactic definitions for the Elixir language. It includes language identifiers like name and file extensions in Info, and expression delimiters, string markers, and comment styles in Syntax. Use cases include language detection from file names, parsing Elixir code, and processing comments or string literals during analysis.",
      "description_length": 360,
      "index": 191,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Dhall",
      "library": "comby-kernel.matchers",
      "description": "This module provides metadata and syntax definitions for the Dhall configuration language. It includes identifiers and file extensions for Dhall files, along with configurations for parsing string literals, interpolated strings, and comments. It is used to support Dhall-specific parsing, formatting, and file recognition in tools processing Dhall code.",
      "description_length": 353,
      "index": 192,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Tsx",
      "library": "comby-kernel.matchers",
      "description": "This module provides metadata and syntax definitions for working with TypeScript JSX (TSX) files. It includes identifiers and file extensions for recognition, and specifies syntax elements like expression delimiters, string literals, and comment styles. It supports tools that perform pattern matching or template processing on TSX code, such as parsers or code transformation utilities.",
      "description_length": 387,
      "index": 193,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Omega.Pascal",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to match and transform Pascal source code using a specified template. It supports extracting all matches or the first match from a source string, with configurable parameters like file path and rule expressions. Use cases include code analysis, refactoring, and automated code generation for Pascal projects.",
      "description_length": 339,
      "index": 194,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Omega.Assembly",
      "library": "comby-kernel.matchers",
      "description": "This module performs structural matching of code templates against source code, returning all matches or the first match with optional configuration, file context, and template customization. It operates on string-based code templates and source files, supporting concrete use cases such as identifying and extracting patterns in assembly-like code. The module allows setting rewrite templates and filtering matches by file extensions or specific rules.",
      "description_length": 453,
      "index": 195,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Csharp",
      "library": "comby-kernel.matchers",
      "description": "This module provides metadata and syntax definitions for the C# language. It includes the language name, file extensions, delimiters, string literals, and comment kinds. Use it to identify C# files and handle their specific syntactic structures in code processing tools.",
      "description_length": 270,
      "index": 196,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Omega.Ruby",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to match and transform Ruby code using templates. It supports finding all matches or the first match in a source string, with configurable rules and file context. The module works directly with Ruby AST expressions, string templates, and source code, enabling precise code analysis and rewriting tasks such as automated refactoring or linting.",
      "description_length": 374,
      "index": 197,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.External.Default",
      "library": "comby-kernel.matchers",
      "description": "Implements a handler function that processes structured input by extracting values based on name, file path, line, and column. It operates on string options and is used to resolve external references in parsing or validation workflows. This handler is useful in scenarios requiring contextual lookups, such as error reporting or symbol resolution in compilers or linters.",
      "description_length": 371,
      "index": 198,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.JSON",
      "library": "comby-kernel.matchers",
      "description": "This module provides access to JSON language metadata and syntax configuration. It includes operations to retrieve the language name and common file extensions, as well as define customizable delimiters, string literals, and comment formats for JSON parsing. Use cases include configuring parsers to handle non-standard JSON syntax and supporting tools that identify JSON files based on extension or syntax features.",
      "description_length": 416,
      "index": 199,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Omega.Dart",
      "library": "comby-kernel.matchers",
      "description": "Performs structural matching on Dart source code using customizable templates. It identifies matches based on abstract syntax tree patterns and supports extracting or rewriting specific code structures. Useful for code analysis, refactoring, or enforcing coding standards in Dart projects.",
      "description_length": 289,
      "index": 200,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Alpha.JSON",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to match and extract data from JSON content using a specified template. It supports retrieving all matches or the first match from a given source string, with options to customize matching behavior through configuration parameters. The module works directly with JSON strings and exposes a Match type to represent results, allowing template-driven parsing and optional rewriting of JSON structures.",
      "description_length": 429,
      "index": 201,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Alpha.Fortran",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to match and rewrite Fortran source code using a specified template. It supports extracting all matches or the first match from a source string, with configurable parameters like file path and rule expressions. Use cases include automated code transformation and static analysis of Fortran programs.",
      "description_length": 330,
      "index": 202,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Alpha.Haskell",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions for matching and transforming source code using predefined templates. It operates on string-based source code and expression structures, supporting concrete use cases like identifying patterns in Haskell code and applying rewrites. The `all` function returns all matches, while `first` finds the first match with error handling, and `set_rewrite_template` updates the transformation template used.",
      "description_length": 428,
      "index": 203,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Omega.Fortran",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions for matching Fortran source code against specific templates. It supports operations like finding all matches or the first match, with configurable parameters such as file path and rule expressions. Use cases include code analysis and transformation tasks specific to Fortran, such as identifying code patterns for refactoring or static analysis.",
      "description_length": 376,
      "index": 204,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Fsharp",
      "library": "comby-kernel.matchers",
      "description": "This module provides metadata and syntax definitions for F# code analysis. It includes language identification through file extensions and specifies syntactic elements like string literals, escape sequences, and comment formats. Used in parsing and tokenizing F# source files for tools like linters, formatters, or language detectors.",
      "description_length": 334,
      "index": 205,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Omega.Haskell",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions for matching and transforming code patterns in Haskell source files. It supports operations like finding all matches or the first match of a template in a source string, with configurable rewriting behavior. The primary data types involved are string-based representations of Haskell code and match results, used for tasks like automated code refactoring or static analysis.",
      "description_length": 405,
      "index": 206,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Omega.Zig",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions for matching and rewriting code patterns in Zig source files. It supports operations like finding all matches or the first match of a template in a source string, with configurable rules and file context. The primary data structures involved are Zig AST expressions and match results, which capture details of matched code segments. Use cases include automated code refactoring, static analysis rule enforcement, and targeted code transformations based on syntactic patterns.",
      "description_length": 506,
      "index": 207,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Omega.Dyck",
      "library": "comby-kernel.matchers",
      "description": "Performs structural pattern matching on code using Dyck language-based templates. It identifies matches in source code strings based on provided templates and configuration, supporting operations to retrieve all matches or the first match with optional parameters like file path and rule expressions. Use cases include code analysis and transformation tasks where precise syntactic matching is required.",
      "description_length": 403,
      "index": 208,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Omega.Dhall",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to match and transform code using Dhall templates. It supports parsing and applying match rules to source code strings, returning structured matches or transformed results. Use it to automate code refactoring or enforce coding standards by defining precise Dhall-based match templates.",
      "description_length": 316,
      "index": 209,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Alpha.SQL",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions for matching SQL expressions against templates, extracting structured matches from source code. It supports operations like finding all matches or the first match with optional configuration, file context, and template-based rewriting. Use cases include static analysis of SQL queries, automated code refactoring, and linting based on specific patterns.",
      "description_length": 384,
      "index": 210,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Languages.Matlab",
      "library": "comby-kernel.matchers",
      "description": "This module provides direct access to MATLAB language metadata and syntax definitions. It includes the language name, file extensions, delimiters for blocks, string literals, and comment styles. Used for parsing, analyzing, or processing MATLAB source files in tools like linters, formatters, or language servers.",
      "description_length": 313,
      "index": 211,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Alpha.Php",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to match PHP code patterns using customizable templates and source code inputs. It supports operations like finding all matches, retrieving the first match with optional offset, and configuring rewrite templates for transformations. The module works directly with PHP expressions, string templates, and file paths, enabling use cases such as static code analysis, automated refactoring, and code search across PHP projects.",
      "description_length": 454,
      "index": 212,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Php",
      "library": "comby-kernel.matchers",
      "description": "This module provides metadata and syntax definitions for PHP language support. It includes the language name, file extensions, string delimiters, comment styles, and literal markers. Used in language detection, file handling, and parsing workflows for tools like linters or syntax highlighters.",
      "description_length": 294,
      "index": 213,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.SQL",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to identify SQL files by extension and define SQL syntax elements such as delimiters, string literals, and comment markers. It works with string and list data types to store file metadata and syntax rules. Use it to configure code editors, linters, or SQL parsers with language-specific settings.",
      "description_length": 327,
      "index": 214,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Generic",
      "library": "comby-kernel.matchers",
      "description": "This module provides operations for defining and working with programming language metadata and syntax rules. It handles data types like strings and lists to manage file extensions, delimiters, string literals, and comment styles. Use cases include configuring parsers for domain-specific languages and identifying language files by extension.",
      "description_length": 343,
      "index": 215,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Languages.Java",
      "library": "comby-kernel.matchers",
      "description": "This module provides metadata and syntax definitions for Java, handling operations like file extension checks and syntax pattern recognition. It works with strings and lists to manage language identifiers and syntactic elements such as delimiters, string literals, and comments. Use it to implement Java-specific parsing, file detection, or syntax processing in code analysis tools.",
      "description_length": 382,
      "index": 216,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Elm",
      "library": "comby-kernel.matchers",
      "description": "This module provides metadata and syntax definitions for the Elm programming language. It includes the language name, file extensions, string delimiters, and comment markers specific to Elm. Use it to configure parsers, linters, or syntax highlighters that process Elm source files accurately.",
      "description_length": 293,
      "index": 217,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Solidity",
      "library": "comby-kernel.matchers",
      "description": "This module provides metadata and syntax definitions for the Solidity programming language. It includes language identifiers like name and file extensions, and defines syntactic elements such as delimiters, string literals, and comment styles. Use it to support file type detection, parser implementation, and source code analysis specific to Solidity.",
      "description_length": 352,
      "index": 218,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Alpha.Elm",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions for matching and rewriting Elm code based on templates. It supports parsing source files, identifying matches using a specified template, and optionally rewriting the source with a new template. The primary data types involved are string-based representations of code, templates, and match results. Use cases include automated code refactoring, linting, and enforcing coding standards in Elm projects.",
      "description_length": 432,
      "index": 219,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Omega.Fsharp",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions for matching and transforming source code using templates. It operates on strings representing source code and templates, returning match results or transformed output. Use it to find all matches in a file, retrieve the first match, or apply a rewrite template to update code dynamically.",
      "description_length": 319,
      "index": 220,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Alpha.Java",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to match and transform Java code using a specified template. It supports finding all matches or the first match in a source string, with options to configure behavior and rewrite templates. It operates on Java expressions and is used for tasks like code refactoring or pattern-based transformations.",
      "description_length": 330,
      "index": 221,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Alpha.OCaml",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to match and transform OCaml source code using a specified template. It supports finding all matches or the first match in a given source, with optional configuration and file context. Use cases include automated code refactoring and static analysis tasks where specific code patterns need to be identified or rewritten.",
      "description_length": 351,
      "index": 222,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Alpha.C_nested_comments",
      "library": "comby-kernel.matchers",
      "description": "This module identifies matches for nested C-style comments in source code. It provides functions to find all matches or the first match, supporting configurable analysis with optional parameters like file path and rule context. Use cases include static code analysis tasks such as detecting commented-out code or extracting documentation.",
      "description_length": 338,
      "index": 223,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.C",
      "library": "comby-kernel.matchers",
      "description": "This module describes the C programming language's metadata and syntactic elements. It provides direct access to the language identifier and file extensions, along with syntax rules for string literals, comments, and delimiters specific to C and related languages. It is used to configure parsers and tools to correctly recognize and process C source files and handle language-specific constructs.",
      "description_length": 397,
      "index": 224,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Omega.Matlab",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions for matching and extracting data from MATLAB code using templates. It supports operations like finding all matches or the first match in a source string, with configurable rules and templates. Use cases include code analysis, transformation, and specific pattern detection in MATLAB files.",
      "description_length": 320,
      "index": 225,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Typescript",
      "library": "comby-kernel.matchers",
      "description": "This module provides metadata and syntax definitions for TypeScript, handling file extensions and language identification. It includes configurations for parsing TypeScript syntax elements like blocks, strings, and comments. Use it to accurately process and analyze TypeScript source files in tooling or transformation workflows.",
      "description_length": 329,
      "index": 226,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Omega.SQL",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions for matching SQL code against templates, extracting structured matches. It operates on SQL strings and templates, supporting concrete use cases like query validation, transformation, and analysis. Functions include finding all matches, retrieving the first match with optional offset, and setting rewrite templates for matched SQL fragments.",
      "description_length": 372,
      "index": 227,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Lisp",
      "library": "comby-kernel.matchers",
      "description": "This module describes the metadata and syntax rules for Lisp dialects. It handles string and list data types to manage language identifiers and syntax patterns, such as delimiters and comment styles. It is used to map file extensions to Lisp implementations and configure parsers for custom macros and string literals.",
      "description_length": 318,
      "index": 228,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Omega.Php",
      "library": "comby-kernel.matchers",
      "description": "Performs matching and extraction of PHP code patterns using customizable templates. It operates on PHP source code strings and expression-based rules, returning structured match results or errors. Useful for code analysis tasks like detecting specific function calls or code constructs in PHP files.",
      "description_length": 299,
      "index": 229,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Omega.Move",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to match and transform code patterns using a specified template and source. It operates on strings representing code, with support for configuration options, file paths, and rule expressions. Use it to find all matches or extract the first match of a pattern, set a rewrite template, and process files with specific extensions.",
      "description_length": 358,
      "index": 230,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Paren",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to define and work with metadata and syntax configurations for parenthetical programming languages. It operates on string and list data types to handle language-specific extensions, delimiters, string literals, and comment styles. Use it to configure parsers or formatters for languages like Lisp or Scheme, where parenthetical structure is fundamental.",
      "description_length": 384,
      "index": 231,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Alpha.Lisp",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions for matching and rewriting Lisp code patterns using templates. It supports parsing source code with optional configuration, file paths, and rule expressions, returning matches or rewritten output. Use cases include code transformation, static analysis, and linting of Lisp dialects.",
      "description_length": 313,
      "index": 232,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Alpha.Typescript",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions for matching TypeScript code against string templates, returning structured match results. It supports parsing and comparing abstract syntax trees with customizable configurations, file paths, and rewrite templates. Use it to find all matches in a source file, retrieve the first match with error handling, or configure templates and extensions for TypeScript pattern matching.",
      "description_length": 408,
      "index": 233,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Zig",
      "library": "comby-kernel.matchers",
      "description": "This module provides direct access to Zig language metadata like its name and common file extensions, and defines syntax configurations for parsing Zig code, including delimiters, string literals, and comment styles. It works with string and list data types to represent language properties and syntax rules. Concrete use cases include identifying Zig source files by extension and configuring parsers or linters to correctly tokenize Zig code.",
      "description_length": 444,
      "index": 234,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Omega.Make",
      "library": "comby-kernel.matchers",
      "description": "This module implements pattern matching and transformation operations over source code, specifically handling expression templates and source text. It provides functions to find all matches or the first match of a template in a source string, with configurable parameters for matching behavior, file context, and rewriting. Use cases include code analysis, refactoring tools, and automated code transformation pipelines.",
      "description_length": 420,
      "index": 235,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Alpha.Zig",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions for matching and transforming source code using a specific template and configuration. It operates on strings representing source code and templates, producing lists of matches or a single match with error handling. Use cases include code analysis and transformation tasks where specific patterns need to be identified or rewritten.",
      "description_length": 363,
      "index": 236,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Alpha.R",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to match and transform source code using a specific template syntax. It supports finding all matches or the first match of a template in a source string, with options to configure matching behavior, shift positions, and rewrite templates. The module works directly with strings for both source code and templates, returning match results in a structured format. Use cases include automated code refactoring, pattern-based code analysis, and template-driven code generation.",
      "description_length": 504,
      "index": 237,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Omega.Clojure",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions for matching and transforming Clojure code using templates. It supports operations like finding all matches in a source string, extracting the first match, and applying rewrite templates. The module works with Clojure AST expressions and string-based code templates, targeting specific use cases such as code analysis, transformation, and refactoring in Clojure projects.",
      "description_length": 402,
      "index": 238,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Alpha.Erlang",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to match and rewrite Erlang source code using a specified template. It supports finding all matches or the first match in a source string, with options to configure matching behavior, file context, and rewrite templates. Use cases include automated code transformations and static analysis tasks specific to Erlang.",
      "description_length": 346,
      "index": 239,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Omega.Text",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to match text templates against source strings, extracting structured matches. It supports finding all matches or the first match with optional configuration, file context, and template rewriting. Use cases include parsing log files, extracting data from structured text, and implementing custom text-based rule engines.",
      "description_length": 351,
      "index": 240,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Alpha.Assembly",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to match and rewrite assembly-like code patterns using a specified template and source. It supports extracting all matches or the first match, with configurable parameters like file path and rule expressions, and allows setting a rewrite template for transformations. Use cases include parsing and modifying low-level code structures, such as instruction sequences or register assignments, during static analysis or code refactoring tasks.",
      "description_length": 470,
      "index": 241,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Omega.Elm",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions for matching and extracting data from Elm source code using templates. It supports operations like `all` to find all matches and `first` to find the first match with optional configuration and file context. The module works directly with Elm AST expressions and strings as input and output, handling concrete syntax patterns in Elm codebases. Use cases include automated code analysis, refactoring tools, and static linting rules specific to Elm projects.",
      "description_length": 486,
      "index": 242,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Alpha.GraphQL",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to match and extract data from GraphQL documents using string templates. It supports parsing and comparing GraphQL AST structures, returning matches as typed results. Use it to query or transform GraphQL schemas and operations with precise pattern matching.",
      "description_length": 288,
      "index": 243,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Languages.Swift",
      "library": "comby-kernel.matchers",
      "description": "This module provides precise metadata and syntax definitions for the Swift programming language. It includes file extension mappings and language name identification for file type detection, along with string delimiters, comment structures, and escapable sequences for accurate Swift code parsing. Use cases include Swift-specific tooling such as linters, formatters, and IDE integrations that require exact syntax recognition.",
      "description_length": 427,
      "index": 244,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Alpha.Html",
      "library": "comby-kernel.matchers",
      "description": "Performs HTML-specific matching operations on source code templates and target files, returning matches as structured data. It supports finding all matches or the first match, with configurable rules and optional source transformations via a rewrite template. Use cases include code analysis, refactoring, and templating tasks where HTML structure and content need to be validated or transformed.",
      "description_length": 396,
      "index": 245,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.CSS",
      "library": "comby-kernel.matchers",
      "description": "This module handles CSS-specific parsing and metadata tasks. It provides syntax definitions for tokenizing CSS code, including delimiters, string literals, and comments, along with metadata such as language name and file extensions. It is used for file type detection, syntax highlighting, and CSS analysis tooling.",
      "description_length": 315,
      "index": 246,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Erlang",
      "library": "comby-kernel.matchers",
      "description": "This module provides metadata and syntax definitions for the Erlang language. It includes direct access to the language name and file extensions, as well as syntactic patterns for macros, string literals, and comments. It supports tools that identify Erlang files or parse and analyze Erlang code, such as linters, parsers, and source transformation utilities.",
      "description_length": 360,
      "index": 247,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Bash",
      "library": "comby-kernel.matchers",
      "description": "This module provides metadata and syntax definitions for the Bash programming language. It includes operations to identify the language, recognize file extensions, and parse syntactic elements like strings, delimiters, and comments. Use it to build tools that process or analyze Bash scripts based on naming conventions or syntactic structure.",
      "description_length": 343,
      "index": 248,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Alpha.Bash",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to match and transform Bash code using predefined templates. It supports parsing source code against a template pattern, returning matches or the first match with optional configuration and file context. The module works directly with string-based templates and source code, producing structured match results that include positional and contextual information. Use cases include automated code refactoring, pattern-based linting, and static analysis of Bash scripts.",
      "description_length": 498,
      "index": 249,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Alpha.CSS",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to match and transform CSS code using a specified template. It operates on CSS source code and expression lists, supporting concrete use cases like extracting or rewriting specific CSS rules. The `all` function returns all matches, while `first` retrieves the first match with error handling, and `set_rewrite_template` allows setting a template for code transformation.",
      "description_length": 401,
      "index": 250,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Html",
      "library": "comby-kernel.matchers",
      "description": "This module provides operations for identifying HTML files via extensions and parsing HTML syntax elements like tags, attributes, and comments. It works with string and list data types to handle file metadata and configure syntax parsing rules. Concrete use cases include file type detection in tooling and constructing accurate HTML parsers.",
      "description_length": 342,
      "index": 251,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Alpha.Coq",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions for matching and rewriting code patterns in Coq source files. It supports operations like finding all matches or the first match of a template in a source string, with configurable matching and error handling. The module works directly with Coq AST expressions, string templates, and file paths, and is used for tasks like automated code transformation and static analysis in Coq projects.",
      "description_length": 420,
      "index": 252,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Omega.C",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to match and transform code using a specified template. It operates on strings representing source code and templates, returning match results or transformed code. Use it to find all matches in a source file or extract the first match with optional error handling.",
      "description_length": 295,
      "index": 253,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Omega.Javascript",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions for matching JavaScript code against templates, extracting matches or the first match with optional configuration and file context. It operates on JavaScript source code strings and expression structures, supporting use cases like code analysis, transformation, and pattern detection. Specific functions include setting rewrite templates, retrieving all matches, and finding the first match with customizable parameters.",
      "description_length": 451,
      "index": 254,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Omega.OCaml",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to match and transform OCaml source code using a specified template. It operates on OCaml abstract syntax trees, allowing precise pattern matching and rewriting of code structures. Use cases include automated code refactoring, linting, and enforcing coding standards across OCaml projects.",
      "description_length": 320,
      "index": 255,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Languages.GraphQL",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to define and process GraphQL syntax elements and metadata. It handles delimiters, string literals, escape sequences, comment styles, and extension support for GraphQL implementations. Use it to configure GraphQL processors, validate schemas, tokenize queries, and manage tool-specific features.",
      "description_length": 326,
      "index": 256,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Julia",
      "library": "comby-kernel.matchers",
      "description": "This module provides direct access to metadata such as the Julia language name and common file extensions, along with syntax configurations including string delimiters, escapable markers, and comment structures. It works with string and list data types to support language detection, file association, parser implementation, and code analysis tasks. Concrete use cases include configuring source code parsers, handling string interpolation, and stripping comments in Julia analysis tools.",
      "description_length": 488,
      "index": 257,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Latex",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to identify LaTeX files by their extensions and configure parsers for LaTeX syntax elements. It works with lists and tuples to represent file extensions, delimiters, literals, and comment markers. Use cases include file type detection based on extension and setting up LaTeX-aware parsers for macro recognition, comments, and string handling.",
      "description_length": 373,
      "index": 258,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Languages.Coq",
      "library": "comby-kernel.matchers",
      "description": "This module provides metadata about the Coq language, including its name and standard file extensions, along with syntax definitions for parsing Coq code. It supports operations like identifying Coq source files and recognizing Coq-specific syntax elements such as custom delimiters, string literals, and comments. Concrete use cases include implementing Coq parsers, linters, or file processors that require accurate language identification and syntactic analysis.",
      "description_length": 465,
      "index": 259,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Rule.Make",
      "library": "comby-kernel.matchers",
      "description": "This module provides parsing and transformation capabilities for structured text processing, focusing on template manipulation and domain-specific language (DSL) pattern matching. It operates on character streams, string templates with placeholders, and abstract syntax trees (ASTs) through Vangstrom parser combinators, supporting operations like tokenization, escape sequence handling, and delimiter-driven atom parsing. The functionality enables use cases such as rewriting structured match expressions, processing quoted strings with nested syntax, and mapping DSL constructs to executable AST nodes for analysis or transformation workflows.",
      "description_length": 645,
      "index": 260,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Omega.Erlang",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions for matching Erlang source code against string templates, returning all matches or the first match with optional configuration and file context. It operates on Erlang source strings and supports template-based pattern matching with customizable rewrite templates. Use cases include code analysis, transformation, and refactoring tasks specific to Erlang projects.",
      "description_length": 394,
      "index": 261,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Alpha.Nim",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to match and extract data from Nim source code using a template-based approach. It supports operations like finding all matches or the first match in a source string, with configurable parameters and optional template rewriting. The module works directly with Nim source files or strings, returning structured match results for further processing.",
      "description_length": 378,
      "index": 262,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Omega.C_nested_comments",
      "library": "comby-kernel.matchers",
      "description": "This module identifies matches for nested comments in source code using a provided template. It supports extracting all matches or the first match, with configurable parameters like file path and rule expressions. Use cases include parsing and transforming code comments in languages like OCaml where nested comments are valid.",
      "description_length": 327,
      "index": 263,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Omega.Solidity",
      "library": "comby-kernel.matchers",
      "description": "Matches Solidity code patterns using customizable templates, supporting precise AST-based matching with optional configuration and file context. Operates on Solidity source strings and expression templates, enabling targeted analysis or transformation of smart contract code. Useful for security audits, code refactoring, and pattern-based validation in Solidity projects.",
      "description_length": 372,
      "index": 264,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Alpha.Dhall",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions for matching and extracting data from Dhall configuration files using structured templates. It supports operations like `all` for finding all matches and `first` for retrieving the first match with optional configuration and file context. The module works with Dhall expressions and strings, offering concrete use cases such as parsing and validating Dhall-based configuration files or transforming Dhall expressions using rewrite templates.",
      "description_length": 472,
      "index": 265,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Nim",
      "library": "comby-kernel.matchers",
      "description": "This module provides direct access to metadata such as the Nim language name and its file extensions, along with syntax elements like delimiters, string literals, and comment patterns. It works with string and list data types to support precise parsing and lexical analysis of Nim source files. Concrete use cases include file type detection based on extensions and extracting syntactic components during code processing.",
      "description_length": 421,
      "index": 266,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Omega.Coq",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions for matching and rewriting code patterns in source files using a specified template. It operates on strings representing source code and templates, returning match results or errors, and allows configuration of matching behavior through optional parameters. Use cases include automated code transformation and static analysis tasks where specific syntactic patterns need to be identified or modified.",
      "description_length": 431,
      "index": 267,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Languages.JSONC",
      "library": "comby-kernel.matchers",
      "description": "This module handles JSONC language metadata and syntax configurations. It provides direct access to language identifiers, file extensions, and customizable syntax elements such as delimiters, string literals, and comment styles. Use it to configure language processing tools for JSONC parsing and file handling tasks.",
      "description_length": 317,
      "index": 268,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Omega.CSS",
      "library": "comby-kernel.matchers",
      "description": "Performs CSS-specific matching operations on source code, extracting matches based on a provided template and source string. It supports retrieving all matches or the first match, with configurable options like file path and rule expressions. Use cases include analyzing or transforming CSS code by identifying specific patterns or structures within stylesheets.",
      "description_length": 362,
      "index": 269,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Omega.Rust",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to match and transform Rust code using templates. It supports finding all matches or the first match of a template in a source string, with options to configure matching behavior, file paths, and rewrite templates. Use cases include code analysis, refactoring, and generating match results from Rust source files.",
      "description_length": 344,
      "index": 270,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Scala",
      "library": "comby-kernel.matchers",
      "description": "This module provides metadata and syntax definitions for the Scala programming language. It includes operations for language detection using file extensions and handling Scala-specific syntax elements such as string literals, delimiters, and comments. Use it to analyze or process Scala code with precise syntactic patterns and language identification.",
      "description_length": 352,
      "index": 271,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Alpha.Ruby",
      "library": "comby-kernel.matchers",
      "description": "This module matches Ruby code against string templates, returning all matches or the first match with optional configuration, file context, and rule constraints. It supports rewriting via a configurable template, and identifies matches based on Ruby-specific parsing rules. Use cases include code transformation, static analysis, and pattern-based refactoring in Ruby projects.",
      "description_length": 377,
      "index": 272,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Omega.Nim",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to match and rewrite code patterns in OCaml source files using a specific template language. It operates on strings representing source code and templates, supporting concrete use cases like automated code refactoring and linter rule enforcement. Key operations include finding all matches, extracting the first match, and applying template-based rewrites to identified code patterns.",
      "description_length": 415,
      "index": 273,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Alpha.Dart",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to match and transform Dart source code using a template-based approach. It supports finding all matches or the first match of a template in a source string, with configurable options, and allows setting a rewrite template for transformations. The module works directly with Dart source code strings and Match.t structures to represent results. Use cases include automated code refactoring, pattern-based code analysis, and generating code modifications based on predefined templates.",
      "description_length": 515,
      "index": 274,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Languages.Dart",
      "library": "comby-kernel.matchers",
      "description": "This module provides direct access to Dart language metadata, such as its name and common file extensions like `.dart`. It includes definitions for Dart-specific syntax elements, including string delimiters, escape sequences, and comment markers. These are used for building parsers or matchers that process Dart source files based on concrete syntactic patterns.",
      "description_length": 363,
      "index": 275,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Omega.JSON",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to match and extract data from JSON content using templates. It supports finding all matches, retrieving the first match, and setting rewrite templates for transformations. The primary data structures involved are JSON strings, match results, and configuration options. Use cases include parsing and validating JSON payloads, extracting specific fields from JSON logs, and rewriting JSON structures based on predefined templates.",
      "description_length": 460,
      "index": 276,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Alpha.Fsharp",
      "library": "comby-kernel.matchers",
      "description": "This module implements F#-specific pattern matching over source code, providing functions to find all matches or the first match of a given template in a source string. It works with F# abstract syntax trees and source code strings, supporting configurable matching through optional parameters like file path and rule expressions. Use it to analyze or transform F# code by defining patterns that match specific language constructs, such as function definitions or type declarations.",
      "description_length": 482,
      "index": 277,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Language.Info",
      "library": "comby-kernel.matchers",
      "description": "This module defines a set of functions for analyzing and extracting metadata from source code files, such as determining the programming language, checking file extensions, and identifying common project configurations. It operates on file paths and content, returning structured information like language identifiers and build tool hints. It is used in code processing pipelines to route files to appropriate analyzers or linters based on detected properties.",
      "description_length": 460,
      "index": 278,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Ruby",
      "library": "comby-kernel.matchers",
      "description": "This module provides metadata and syntax definitions for Ruby language support. It includes file extensions and language name information, along with patterns for string delimiters, comments, and literal syntax. It is used for code parsing, file type detection, and syntax highlighting in Ruby tooling.",
      "description_length": 302,
      "index": 279,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Alpha.Generic",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to match and extract patterns from source code using customizable templates. It supports operations like `all` to find all matches and `first` to retrieve the first match with optional configuration and file context. The module works with source strings and expression templates, enabling use cases like detecting specific code patterns or transforming code structures during analysis.",
      "description_length": 416,
      "index": 280,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Alpha.Matlab",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions for matching and rewriting MATLAB code based on templates. It operates on MATLAB source code strings and supports concrete use cases like identifying code patterns for refactoring or enforcing coding standards. The module works with match configurations, file paths, and MATLAB-specific AST expressions, allowing precise control over matching behavior and result extraction.",
      "description_length": 405,
      "index": 281,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Languages",
      "library": "comby-kernel.matchers",
      "description": "This module provides language-specific metadata and syntax configurations for parsing, detection, and processing of diverse programming and markup languages, operating primarily on strings and lists to manage file extensions, delimiters, string literals, and comment syntax. It supports use cases like syntax highlighting, code analysis, and tooling configuration by defining consistent syntactic patterns across languages such as JSON, Python, LaTeX, JavaScript, and Rust, including handling of nested comments, escape sequences, and language-specific identifiers. The structured approach enables robust language detection and processing in applications ranging from linters to file format converters.",
      "description_length": 702,
      "index": 282,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Specification",
      "library": "comby-kernel.matchers",
      "description": "This module defines a specification for matching and rewriting strings using templates and optional rules. It provides functions to create specifications, convert them to regex patterns, and serialize/deserialize to and from S-expressions. Concrete use cases include defining input parsing rules and transformation logic for structured text processing.",
      "description_length": 352,
      "index": 283,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Hole",
      "library": "comby-kernel.matchers",
      "description": "This module defines a set of named hole sorts for pattern matching, including expressions, alphanumeric sequences, and line-based units, along with a structured type combining sort, identifier, dimension, and depth constraints. It provides JSON serialization and deserialization for these sorts and the composite type. Concrete use cases include parsing and analyzing source code structures with customizable placeholders in tools like linters or refactoring engines.",
      "description_length": 467,
      "index": 284,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Rewriter",
      "library": "comby-kernel.matchers",
      "description": "This module handles string substitution based on match environments, supporting both simple and fresh identifier replacement. It operates on strings and match data structures, allowing template rewriting with customizable ID generation and external handlers. It is used to generate code from templates by replacing placeholders with matched or fresh values, either in bulk or per match.",
      "description_length": 386,
      "index": 285,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Omega",
      "library": "comby-kernel.matchers",
      "description": "This module enables structural matching and transformation of code and data formats through template-based operations, supporting source code strings and syntax trees with configurable rules. It provides functions to identify patterns, apply rewrite templates, and extract or transform content across programming languages like JSON, GraphQL, OCaml, and LaTeX, as well as structured text. Use cases include static analysis, automated refactoring, and syntax-aware code manipulation in polyglot codebases or data-processing workflows.",
      "description_length": 533,
      "index": 286,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Script",
      "library": "comby-kernel.matchers",
      "description": "Handles parsing and evaluation of script-based matchers, supporting operations like pattern matching and conditional execution. Works with abstract syntax trees (ASTs) and script contexts to apply logic to structured data. Used for implementing domain-specific rule engines and dynamic behavior injection.",
      "description_length": 305,
      "index": 287,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Matcher",
      "library": "comby-kernel.matchers",
      "description": "This module defines a set of functions for pattern matching and value extraction over structured data such as trees and records. It includes operations for defining match rules, applying matchers to values, and composing multiple matchers into complex conditions. Concrete use cases include query engines, static analysis tools, and configuration validators where precise structural matching is required.",
      "description_length": 404,
      "index": 288,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Ast",
      "library": "comby-kernel.matchers",
      "description": "This module defines data structures for representing abstract syntax trees used in pattern matching and transformation logic. It includes types for atoms, antecedents, expressions, and consequents, supporting operations like equality checks, pattern matching, and rewriting rules. Concrete use cases include parsing and evaluating domain-specific language expressions, implementing rule-based transformations, and handling symbolic computations.",
      "description_length": 445,
      "index": 289,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Configuration",
      "library": "comby-kernel.matchers",
      "description": "This module defines configuration options for matching behavior, including exact or fuzzy match modes, whitespace sensitivity, and newline handling. It provides a `create` function to construct configurations with customizable parameters like substring matching, fresh variable generation, and substitution behavior. Use this module to control matching semantics in pattern processing or transformation pipelines.",
      "description_length": 413,
      "index": 290,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Evaluate",
      "library": "comby-kernel.matchers",
      "description": "This module evaluates matching results and manipulates match environments. It provides operations to extract values from match results, merge environments, and apply matching logic with customizable behavior. It works with match results, environments, and AST expressions, supporting use cases like conditional pattern evaluation and environment propagation in template matching systems.",
      "description_length": 387,
      "index": 291,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.External",
      "library": "comby-kernel.matchers",
      "description": "Implements a handler function that processes structured input by extracting values based on name, file path, line, and column. It operates on string options and is used to resolve external references in parsing or validation workflows. This handler is useful in scenarios requiring contextual lookups, such as error reporting or symbol resolution in compilers or linters.",
      "description_length": 371,
      "index": 292,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Engine",
      "library": "comby-kernel.matchers",
      "description": "This module defines a core matching engine for processing structured queries against hierarchical data. It supports operations like pattern matching, path traversal, and value extraction on tree-like structures such as JSON or ASTs. Concrete use cases include query engines for configuration files, static analysis tools, and data validation pipelines.",
      "description_length": 352,
      "index": 293,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Language",
      "library": "comby-kernel.matchers",
      "description": "This module implements language-specific matching logic by combining syntax element handling and metadata analysis. It operates on source code content and file paths to detect language features, string delimiters, comment styles, and project configurations. Concrete use cases include language detection, syntax rule application, and configuration extraction for code processing tools.",
      "description_length": 385,
      "index": 294,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Template",
      "library": "comby-kernel.matchers",
      "description": "This module defines data types and functions for parsing and representing template syntax in a structured format. It supports operations to convert between S-expressions and custom types like `kind`, `syntax`, `atom`, and `t`, which model different aspects of template variables and constants. Concrete use cases include deserializing template configurations from S-expressions and building template-based code transformations.",
      "description_length": 427,
      "index": 295,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Metasyntax",
      "library": "comby-kernel.matchers",
      "description": "This module defines syntax rules for pattern matching constructs using JSON serialization. It handles metasyntax configurations like hole definitions, aliases, and regex patterns, which are used to parse and transform code structures during matching. Concrete use cases include specifying custom syntax for code analysis tools or templating systems that require structured pattern recognition.",
      "description_length": 393,
      "index": 296,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Rule",
      "library": "comby-kernel.matchers",
      "description": "This module processes lists of abstract syntax tree (AST) expressions, providing functions to construct and manipulate them using S-expressions. It includes a creation function that parses strings into AST expressions, supporting optional metasyntax and external handlers for resolution. The module also defines and extracts configuration options, such as whether the structure is nested, from the expression list.",
      "description_length": 414,
      "index": 297,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers",
      "library": "comby-kernel.matchers",
      "description": "This module provides core functionality for pattern matching, transformation, and evaluation over structured data such as abstract syntax trees and source code. It includes operations for defining match rules, handling placeholders (holes), applying transformations, and managing match environments with support for language-specific syntax and configuration options. Concrete use cases include static analysis, code refactoring, templating systems, and rule-based transformations across multiple programming languages.",
      "description_length": 519,
      "index": 298,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Vangstrom.Let_syntax.Let_syntax",
      "library": "comby-kernel.vangstrom",
      "description": "This module provides monadic and applicative combinators for composing parsers, including `bind`, `map`, `both`, and multi-argument `map` functions. It works directly with `Vangstrom.t` parsers, enabling sequential composition and transformation of parsed values. Concrete use cases include chaining parsers for structured data formats like JSON or binary protocols, where intermediate results guide subsequent parsing steps.",
      "description_length": 425,
      "index": 299,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Vangstrom.Consume",
      "library": "comby-kernel.vangstrom",
      "description": "This module provides functions to control how much of the input a parser consumes, with variants to either consume only a prefix or the entire input. It works with parsers that return a result and a remaining input, allowing precise management of input consumption during parsing. Concrete use cases include parsing structured data formats where partial consumption is needed, such as parsing individual fields from a stream or extracting a specific header from a larger message.",
      "description_length": 479,
      "index": 300,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Vangstrom.Let_syntax",
      "library": "comby-kernel.vangstrom",
      "description": "This module provides monadic and applicative combinators for composing parsers, including `bind`, `map`, `both`, and multi-argument `map` functions. It works directly with `Vangstrom.t` parsers, enabling sequential composition and transformation of parsed values. Concrete use cases include chaining parsers for structured data formats like JSON or binary protocols, where intermediate results guide subsequent parsing steps.",
      "description_length": 425,
      "index": 301,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Vangstrom.BE",
      "library": "comby-kernel.vangstrom",
      "description": "This module implements big-endian binary parsers for fixed-size integers and floating-point numbers. It provides functions to both match specific integer values in big-endian format and to read arbitrary big-endian values, including signed and unsigned 16, 32, and 64-bit integers, as well as 32 and 64-bit floats. These parsers are useful for decoding binary protocols or file formats that encode numeric data in big-endian byte order, such as network protocols or certain serialized data formats.",
      "description_length": 498,
      "index": 302,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Vangstrom.Unbuffered",
      "library": "comby-kernel.vangstrom",
      "description": "This module provides low-level parsing operations that require manual buffer management, enabling zero-copy input handling by avoiding internal buffering. It works directly with byte buffers and tracks parser progress through explicit state transitions, requiring users to handle partial results and buffer continuation logic. Concrete use cases include high-performance network protocol parsers or file format readers where precise memory control is critical.",
      "description_length": 460,
      "index": 303,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Vangstrom.LE",
      "library": "comby-kernel.vangstrom",
      "description": "This module provides parsers for reading and matching little-endian binary values, including signed and unsigned 16, 32, and 64-bit integers, as well as 32 and 64-bit floating-point numbers. It operates directly on binary input streams, parsing raw bytes into structured numeric types. These parsers are used for decoding binary protocols or file formats that encode numbers in little-endian byte order, such as certain network protocols or binary file formats like PCAP or ELF.",
      "description_length": 478,
      "index": 304,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Vangstrom.Unsafe",
      "library": "comby-kernel.vangstrom",
      "description": "This module exposes direct access to the internal buffer of a parser combinator library, allowing performance-critical parsers to avoid allocations by operating on raw buffer slices. It provides functions to consume or inspect input based on fixed lengths or predicate checks, returning results via callbacks that receive the buffer, offset, and length. These operations are used in scenarios requiring zero-copy parsing, such as high-performance network protocol or binary format parsers.",
      "description_length": 489,
      "index": 305,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Vangstrom.Buffered",
      "library": "comby-kernel.vangstrom",
      "description": "This module provides functions for running and feeding parsers with internal buffering of input, minimizing memory allocation and copying. It works with parsers that return unconsumed input as a buffer slice and supports incremental input feeding via the `feed` function. Concrete use cases include parsing streaming data from a socket or file where input arrives in chunks and must be processed incrementally.",
      "description_length": 410,
      "index": 306,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Vangstrom",
      "library": "comby-kernel.vangstrom",
      "description": "This module provides parser combinators for constructing efficient text and binary parsers using monadic and applicative composition, with primitives for character/string matching, numeric parsing, repetition, choice, and input manipulation. It operates on bigstrings, strings, and streaming buffers, supporting both buffered and zero-copy unbuffered input handling, along with endianness-aware binary parsing for structured data formats. Designed for high-performance scenarios, it is suited for network protocol implementations, binary file parsing, and incremental stream processing in resource-constrained environments.",
      "description_length": 623,
      "index": 307,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Parsers.Alpha_comments.Multiline.Make",
      "library": "comby-kernel.parsers",
      "description": "Parses multiline block comments like `/* ... */`, capturing the content between delimiters. It returns the parsed comment text as a string or fails if the input doesn't match the expected format. Useful for implementing comment syntax in custom language parsers.",
      "description_length": 262,
      "index": 308,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Parsers.Alpha_string_literals.Raw.Make",
      "library": "comby-kernel.parsers",
      "description": "This module implements parsers for raw string literals and character tokens using custom delimiters, without support for escape sequences or identifier-anchored strings. It works with parser state and reply types from the `MParser` module to process input streams into string values. Concrete use cases include parsing raw string literals in domain-specific languages or configuration formats where delimiters define the start and end of a string body.",
      "description_length": 452,
      "index": 309,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Parsers.Omega_comments.Multiline.Make",
      "library": "comby-kernel.parsers",
      "description": "This module implements a parser for multiline comment syntax using a specified delimiter strategy from the parameter module M. It consumes input until the closing delimiter is found, supporting nested or escaped comment structures. A typical use case is parsing C-style or SQL-style multiline comments in a custom language parser.",
      "description_length": 330,
      "index": 310,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Parsers.Omega_string_literals.Escapable.Make",
      "library": "comby-kernel.parsers",
      "description": "This module implements parsers for handling escaped characters and string literals in a custom syntax, producing Vangstrom parsers for character and string tokens. It works with character and string data types, integrating directly with Vangstrom's parser combinator framework. Concrete use cases include parsing source code strings with escape sequences in domain-specific languages or configuration formats.",
      "description_length": 409,
      "index": 311,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Parsers.Alpha_comments.Until_newline.Make",
      "library": "comby-kernel.parsers",
      "description": "This module implements a parser that reads and returns a comment string starting from the current input position until the next newline character. It operates on the `MParser.state` type, producing a `string` result on success. It is useful for parsing single-line comments in custom language parsers where comments terminate at line breaks.",
      "description_length": 341,
      "index": 312,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Parsers.Omega_comments.Until_newline.Make",
      "library": "comby-kernel.parsers",
      "description": "This module implements a parser that reads and returns comments extending up to the next newline character. It works with the `Vangstrom.t` type for string input and relies on the provided module `M` to define the specific comment syntax. A concrete use case is parsing single-line comments in a custom language where comments end at line breaks.",
      "description_length": 346,
      "index": 313,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Parsers.Alpha_comments.Nested_multiline.Make",
      "library": "comby-kernel.parsers",
      "description": "This module implements a parser for nested multiline comments, handling start and end delimiters defined by the parameter module `M`. It processes character streams, accumulating comment content while correctly managing nested comment structures. A typical use case is parsing source code comments in languages like OCaml, where nested comments are allowed, such as `(* outer (* inner *) outer *)`.",
      "description_length": 398,
      "index": 314,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Parsers.Alpha_string_literals.Escapable.Make",
      "library": "comby-kernel.parsers",
      "description": "This module parses string literals with escape sequences, handling a single delimiter that can be escaped within the string. It processes characters and escape sequences within a string body, excluding newlines, using the provided parser state. Useful for parsing quoted strings in programming languages where escapes like `\\\"` or `\\\\` are needed.",
      "description_length": 347,
      "index": 315,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Parsers.Omega_string_literals.Raw.Make",
      "library": "comby-kernel.parsers",
      "description": "This module implements parsers for raw string literals and individual character tokens using the Vangstrom parser combinator library. It works with string and character literal syntax, producing parsed string values. Concrete use cases include parsing unescaped string content and single-character literals in language implementations or data format parsers.",
      "description_length": 358,
      "index": 316,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Parsers.Omega_comments.Until_newline",
      "library": "comby-kernel.parsers",
      "description": "This module implements a parser that reads and returns comments extending up to the next newline character. It works with the `Vangstrom.t` type for string input and relies on the provided module `M` to define the specific comment syntax. A concrete use case is parsing single-line comments in a custom language where comments end at line breaks.",
      "description_length": 346,
      "index": 317,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Parsers.Omega_string_literals.Raw",
      "library": "comby-kernel.parsers",
      "description": "This module implements parsers for raw string literals and individual character tokens using the Vangstrom parser combinator library. It works with string and character literal syntax, producing parsed string values. Concrete use cases include parsing unescaped string content and single-character literals in language implementations or data format parsers.",
      "description_length": 358,
      "index": 318,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Parsers.Omega_string_literals.Escapable",
      "library": "comby-kernel.parsers",
      "description": "This module generates Vangstrom parsers for handling escaped characters and string literals in custom syntaxes, producing character and string tokens. It operates on character and string data types, tailored for parsing source code or configuration files with domain-specific escape sequences. Use cases include parsing DSLs with custom string encodings or embedded scripting languages requiring precise escape handling.",
      "description_length": 420,
      "index": 319,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Parsers.Alpha_string_literals.Raw",
      "library": "comby-kernel.parsers",
      "description": "Implements parsers for raw string literals with customizable delimiters, rejecting escape sequences and identifier-anchored syntax. Processes input streams into string values using `MParser` state and reply types. Useful for parsing domain-specific languages or configuration formats where strings are enclosed by specific start and end markers.",
      "description_length": 345,
      "index": 320,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Parsers.Omega_comments.Multiline",
      "library": "comby-kernel.parsers",
      "description": "This module implements a parser for multiline comment syntax using a specified delimiter strategy. It consumes input until the closing delimiter is found, supporting nested or escaped comment structures. A typical use case is parsing C-style or SQL-style multiline comments in a custom language parser.",
      "description_length": 302,
      "index": 321,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Parsers.Alpha_comments.Until_newline",
      "library": "comby-kernel.parsers",
      "description": "This module implements a parser that reads a comment string from the current input position until the next newline, operating on `MParser.state` and returning a `string` result. It is designed for parsing single-line comments in custom language parsers where comments end at line breaks. The `Make` functor provides the actual parser implementation.",
      "description_length": 349,
      "index": 322,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Parsers.Alpha_comments.Multiline",
      "library": "comby-kernel.parsers",
      "description": "Parses multiline block comments using start and end delimiters like `/* ... */`, returning the content as a string. Works with character streams or string inputs, handling non-nested comments only. Designed for integrating comment parsing into custom language parsers during lexing or preprocessing stages.",
      "description_length": 306,
      "index": 323,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Parsers.Alpha_string_literals.Escapable",
      "library": "comby-kernel.parsers",
      "description": "This module parses string literals with escape sequences, handling a single delimiter that can be escaped within the string. It processes characters and escape sequences within a string body, excluding newlines, using the provided parser state. Useful for parsing quoted strings in programming languages where escapes like `\\\"` or `\\\\` are needed.",
      "description_length": 347,
      "index": 324,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Parsers.Alpha_comments.Nested_multiline",
      "library": "comby-kernel.parsers",
      "description": "This module implements a parser for nested multiline comments using customizable start and end delimiters. It processes character streams, correctly handling nested comment structures by tracking delimiter nesting levels. A typical use case is parsing OCaml-style nested comments, such as `(* outer (* inner *) outer *)`, where delimiters can be configured for different comment syntaxes.",
      "description_length": 388,
      "index": 325,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Parsers.Alpha_string_literals",
      "library": "comby-kernel.parsers",
      "description": "Parses string literals with support for escape sequences and customizable delimiters. Handles quoted strings using a delimiter that can be escaped within the body, and processes raw strings enclosed by specific markers without interpreting escape sequences. Used for parsing strings in programming languages and domain-specific configurations where precise string handling is required.",
      "description_length": 385,
      "index": 326,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Parsers.Alpha_comments",
      "library": "comby-kernel.parsers",
      "description": "This module provides parsers for handling comment syntax in custom language implementations. It includes functions for reading non-nested and nested comments with customizable delimiters, capturing content until newlines, and filtering input based on parser results. Designed for use during lexing or preprocessing stages, it operates on character streams or string inputs to extract comment content while respecting comment structure and delimiters.",
      "description_length": 450,
      "index": 327,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Parsers.Omega_comments",
      "library": "comby-kernel.parsers",
      "description": "This module provides parsers for handling comment syntax in custom languages, including single-line and multiline comment structures. It works with `Vangstrom.t` parsers and character streams, offering functions to capture text until delimiters, skip reserved characters, and manage nested or non-nested comments. Concrete use cases include parsing SQL-style multiline comments and C-style single-line comments ending at newlines.",
      "description_length": 430,
      "index": 328,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Parsers.Omega_string_literals",
      "library": "comby-kernel.parsers",
      "description": "This module provides parser combinators for processing string and character literals with support for escape sequences and raw syntax. It includes functions for transforming parsed values and generating parsers tailored to custom string encodings. Use cases include parsing DSLs, configuration files, and data formats requiring precise handling of escaped or unescaped string content.",
      "description_length": 384,
      "index": 329,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Parsers",
      "library": "comby-kernel.parsers",
      "description": "This module implements parsers for handling comment syntax and string literals in custom languages. It includes functions for parsing nested and non-nested comments with customizable delimiters, as well as string literals with escape sequences, raw syntax, and quoted structures. These parsers operate on character streams or strings, supporting use cases such as SQL-style comment extraction, C-style string handling, and DSL configuration parsing.",
      "description_length": 449,
      "index": 330,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Lisp.Info",
      "library": "comby-kernel",
      "description": "This module defines metadata for the Lisp programming language, including its name and file extensions. It provides direct access to the language name as a string and a list of associated file extensions. This information is used to identify and handle Lisp source files in tooling contexts like parsing or syntax analysis.",
      "description_length": 323,
      "index": 331,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.SQL.Info",
      "library": "comby-kernel",
      "description": "This module defines metadata for SQL language support, including the language name and file extensions. It provides concrete values for identifying SQL files and handling their specific configurations. Useful for tools that process SQL files based on extension or require language-specific settings.",
      "description_length": 299,
      "index": 332,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Kotlin.Info",
      "library": "comby-kernel",
      "description": "This module defines metadata for the Kotlin programming language, including its name and file extensions. It provides direct access to the language identifier and common file suffixes used for Kotlin source files. This information is used to support language-specific processing in code analysis and transformation tools.",
      "description_length": 321,
      "index": 333,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Python.Info",
      "library": "comby-kernel",
      "description": "This module defines metadata for the Python language, including its name and file extensions. It provides direct access to the language identifier and a list of associated file extensions. Useful for tools that need to recognize or process Python files based on naming conventions.",
      "description_length": 281,
      "index": 334,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.JSONC.Syntax",
      "library": "comby-kernel",
      "description": "This module defines syntax elements for matching and parsing JSONC (JSON with comments), including customizable delimiters, escapable and raw string literals, and comment styles. It supports precise pattern matching over JSONC structures by allowing specification of string escape behaviors and comment delimiters. Use cases include implementing custom JSONC parsers or linters that require handling non-standard syntax extensions.",
      "description_length": 431,
      "index": 335,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.CSS.Info",
      "library": "comby-kernel",
      "description": "This module defines metadata for CSS language support, including the language name and file extensions. It provides the `name` and `extensions` values to identify and associate files with CSS syntax. Use this module when integrating CSS files into a processing pipeline that requires language-specific configuration.",
      "description_length": 316,
      "index": 336,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Scala.Syntax",
      "library": "comby-kernel",
      "description": "This module defines syntax-specific configurations for parsing and matching Scala code, including delimiters, string literals, and comment types. It specifies escapable and raw string formats, along with comment syntax variations, to support accurate pattern matching. Concrete use cases include implementing Scala-specific code transformations and static analysis rules.",
      "description_length": 371,
      "index": 337,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Pascal.Info",
      "library": "comby-kernel",
      "description": "This module defines metadata for Pascal language support, including the language name and file extensions. It provides concrete values for identifying Pascal source files, such as `name` set to \"Pascal\" and `extensions` listing common file suffixes like `.pas`. This data is used in tooling that processes or analyzes Pascal code, such as parsers or syntax highlighters.",
      "description_length": 370,
      "index": 338,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.CSS.Syntax",
      "library": "comby-kernel",
      "description": "This module defines syntax elements for parsing and matching CSS code, including user-defined delimiters, escapable and raw string literals, and comment styles. It works with string pairs and syntax-specific variants to handle CSS literals and comments. Concrete use cases include configuring parsers to correctly identify CSS strings, comments, and custom delimiters during code analysis or transformation.",
      "description_length": 407,
      "index": 339,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Dart.Info",
      "library": "comby-kernel",
      "description": "This module defines metadata for the Dart programming language, including its name and file extensions. It provides concrete values for identifying Dart files, such as the language name \"Dart\" and a list of extensions like `.dart`. This information is used in tooling that needs to recognize or process Dart source files, such as linters, formatters, or code analyzers.",
      "description_length": 369,
      "index": 340,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.C_nested_comments.Syntax",
      "library": "comby-kernel",
      "description": "This module defines syntax configurations for handling nested comments, string literals, and delimiters in C-like languages. It specifies user-defined delimiters, escapable and raw string literal markers, and comment styles. Concrete use cases include parsing and transforming code with nested comments or multi-line strings in languages like C, C++, or Rust.",
      "description_length": 359,
      "index": 341,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Haskell.Syntax",
      "library": "comby-kernel",
      "description": "This module defines syntax-specific configurations for parsing and matching Haskell code. It specifies delimiters, string literals, and comment styles used in Haskell, such as `(\"{-\" , \"-}\")` for comments and `\"` for string literals. These values guide pattern matching and transformation tools in accurately handling Haskell syntax constructs.",
      "description_length": 344,
      "index": 342,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Rust.Syntax",
      "library": "comby-kernel",
      "description": "This module defines syntax-specific configurations for parsing and matching Rust code. It specifies delimiters, escapable and raw string literals, and comment styles used in Rust. These values guide accurate pattern matching and transformation of Rust source code in tools like code refactoring or analysis systems.",
      "description_length": 315,
      "index": 343,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Typescript.Syntax",
      "library": "comby-kernel",
      "description": "This module defines syntax-specific configurations for parsing and matching TypeScript code. It specifies delimiters, escapable and raw string literals, and comment styles used in TypeScript. These values guide accurate pattern matching and transformation of TypeScript source code.",
      "description_length": 282,
      "index": 344,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Nim.Syntax",
      "library": "comby-kernel",
      "description": "This module defines syntax-specific configurations for parsing and matching Nim code. It specifies custom delimiters, escapable and raw string literals, and comment styles unique to Nim. These values guide accurate pattern matching and transformation in Nim source files.",
      "description_length": 271,
      "index": 345,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Dyck.Syntax",
      "library": "comby-kernel",
      "description": "This module defines syntax elements for handling delimiters, string literals, and comments in a structured format. It provides explicit lists of user-defined delimiters, escapable string literals, raw string delimiters, and comment kinds. Concrete use cases include parsing and matching code patterns that require precise handling of nested structures and quoted text.",
      "description_length": 368,
      "index": 346,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Elixir.Syntax",
      "library": "comby-kernel",
      "description": "This module defines syntax elements specific to Elixir, including user-defined delimiters, escapable and raw string literals, and comment kinds. It provides precise syntactic patterns for parsing and matching Elixir code structures. Use this module when implementing custom parsing or transformation tools that require accurate recognition of Elixir syntax features like sigils, string encodings, and comment handling.",
      "description_length": 418,
      "index": 347,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Csharp.Info",
      "library": "comby-kernel",
      "description": "This module defines metadata for the C# language, including the language name and file extensions. It provides direct access to static values that identify and associate files with the C# programming language. Use this module to retrieve the canonical name and recognized extensions for C# files in tooling or analysis contexts.",
      "description_length": 328,
      "index": 348,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Haskell.Info",
      "library": "comby-kernel",
      "description": "This module defines metadata for the Haskell programming language, including its name and file extensions. It provides direct access to the language name as a string and a list of associated file extensions. This information is used to identify and handle Haskell source files in tooling contexts like parsing or syntax analysis.",
      "description_length": 329,
      "index": 349,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Latex.Syntax",
      "library": "comby-kernel",
      "description": "This module defines syntax elements for parsing and matching LaTeX code, including user-defined delimiters for macros, escapable and raw string literals, and comment styles. It supports concrete use cases like identifying LaTeX macros with custom syntax or handling verbatim text regions. The data types include lists of string pairs for delimiters and literals, along with comment configurations specific to LaTeX.",
      "description_length": 415,
      "index": 350,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Java.Info",
      "library": "comby-kernel",
      "description": "This module defines metadata for the Java language, including its name and file extensions. It provides the `name` value as a string and `extensions` as a list of strings representing associated file extensions. Concrete use cases include identifying Java files by extension and referencing the language name in tooling or configuration contexts.",
      "description_length": 346,
      "index": 351,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Python.Syntax",
      "library": "comby-kernel",
      "description": "This module defines syntax-specific configurations for parsing and matching Python code. It specifies delimiters for user-defined literals, escapable and raw string literal markers, and comment styles. These values guide accurate pattern matching in Python source files during analysis or transformation tasks.",
      "description_length": 310,
      "index": 352,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Go.Syntax",
      "library": "comby-kernel",
      "description": "This module defines syntax-specific configurations for parsing and matching Go code, including delimiters for user-defined literals, escapable and raw string literals, and comment syntax. It provides concrete values that specify how different syntactic elements are recognized in Go source files. These configurations are used directly by pattern matchers to accurately identify and process Go code structures during analysis or transformation tasks.",
      "description_length": 450,
      "index": 353,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.C_nested_comments.Info",
      "library": "comby-kernel",
      "description": "This module defines metadata for a language variant that supports nested comments, including its name and file extensions. It works with string and list data types to specify identifier and extension values. Concrete use cases include configuring parsers or tools that require recognition of nested comment syntax in source files.",
      "description_length": 330,
      "index": 354,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.R.Syntax",
      "library": "comby-kernel",
      "description": "This module defines syntax elements for parsing and matching R code, including user-defined delimiters, escapable and raw string literals, and comment styles. It provides precise specifications for handling R's syntactic features like string interpolation and comment structures. Use this module to configure parsers or matchers that need to accurately recognize R-specific syntax constructs.",
      "description_length": 392,
      "index": 355,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Jsx.Syntax",
      "library": "comby-kernel",
      "description": "This module defines syntax elements for JSX, including user-defined delimiters, escapable and raw string literals, and comment kinds. It provides precise configurations for parsing and matching JSX structures in source code. Use cases include implementing custom JSX parsers and enabling accurate pattern matching in code transformation tools.",
      "description_length": 343,
      "index": 356,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Dhall.Info",
      "library": "comby-kernel",
      "description": "This module defines metadata for the Dhall configuration language, including its name and file extensions. It provides direct access to the language's identifier and a list of associated file extensions. Use this module to retrieve Dhall-specific naming and extension information for tooling or integration purposes.",
      "description_length": 316,
      "index": 357,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.HCL.Syntax",
      "library": "comby-kernel",
      "description": "This module defines syntax elements for HCL (HashiCorp Configuration Language), including user-defined delimiters, escapable and raw string literals, and comment styles. It provides precise syntax configurations that enable accurate parsing and matching of HCL code structures. Use cases include building custom parsers, linters, or code transformation tools specifically tailored to HCL files.",
      "description_length": 394,
      "index": 358,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Html.Info",
      "library": "comby-kernel",
      "description": "This module defines metadata for HTML, including the language name and file extensions. It provides direct access to static information used for identifying and handling HTML files. Concrete use cases include determining file type based on extension or language name matching.",
      "description_length": 276,
      "index": 359,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.JSONC.Info",
      "library": "comby-kernel",
      "description": "This module defines metadata for the JSONC language, including its name and file extensions. It provides direct access to the language identifier and a list of associated file extensions. Use this module to retrieve JSONC-specific naming and extension information for file handling or language detection tasks.",
      "description_length": 310,
      "index": 360,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Go.Info",
      "library": "comby-kernel",
      "description": "This module defines metadata for the Go programming language, including its name and file extensions. It provides direct access to the language identifier and a list of associated file extensions. Useful for tools that need to recognize or process Go source files based on naming conventions.",
      "description_length": 292,
      "index": 361,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.OCaml.Info",
      "library": "comby-kernel",
      "description": "This module defines metadata for the OCaml language, including the language name and its common file extensions. It provides direct access to predefined values used for identifying and handling OCaml source files. Concrete use cases include configuring parsers, setting up file filters, and initializing language-specific tools.",
      "description_length": 328,
      "index": 362,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Move.Info",
      "library": "comby-kernel",
      "description": "This module defines metadata for the Move programming language, including its name and file extensions. It provides direct access to the language name as a string and a list of associated file extensions. This information is used to identify and handle Move source files in tooling contexts like parsing and analysis.",
      "description_length": 317,
      "index": 363,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Generic.Syntax",
      "library": "comby-kernel",
      "description": "This module defines syntax elements for parsing and matching code in a generic language, including delimiters for user-defined syntax, escapable and raw string literals, and comment styles. It provides concrete configurations for syntactic features like string boundaries, escape sequences, and comment markers. These values are used to customize pattern matching and transformation logic in code analysis tools that handle multiple or custom programming languages.",
      "description_length": 465,
      "index": 364,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.C.Info",
      "library": "comby-kernel",
      "description": "This module defines metadata for the C programming language, including its name and file extensions. It provides direct access to the language identifier and common file extensions associated with C source files. Concrete use cases include configuring parsers or tools to recognize C files based on extension or displaying language information in an interface.",
      "description_length": 360,
      "index": 365,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Text.Info",
      "library": "comby-kernel",
      "description": "This module defines metadata for text-based languages, including the language name and associated file extensions. It works with string and list data types to store and retrieve language-specific identifiers. Concrete use cases include determining file type based on extension and providing human-readable names for language implementations.",
      "description_length": 341,
      "index": 366,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Ruby.Info",
      "library": "comby-kernel",
      "description": "This module defines metadata for the Ruby programming language, including its name and file extensions. It provides direct access to the language name as a string and a list of associated file extensions. This information is used to identify and handle Ruby files in code analysis or processing tasks.",
      "description_length": 301,
      "index": 367,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Julia.Info",
      "library": "comby-kernel",
      "description": "This module defines metadata for the Julia programming language, including its name and file extensions. It provides direct access to the language name as a string and a list of associated file extensions. This information is used to identify and handle Julia source files in tooling contexts like parsing or syntax analysis.",
      "description_length": 325,
      "index": 368,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.GraphQL.Syntax",
      "library": "comby-kernel",
      "description": "This module defines syntax elements for parsing and matching GraphQL code, including customizable delimiters for strings, escapable and raw string literals, and comment styles. It supports precise pattern matching and transformation of GraphQL queries by specifying how different syntactic constructs should be interpreted. Concrete use cases include implementing linters, formatters, or code refactoring tools that require accurate parsing of GraphQL syntax.",
      "description_length": 459,
      "index": 369,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Ruby.Syntax",
      "library": "comby-kernel",
      "description": "This module defines syntax elements specific to Ruby, including user-defined delimiters, escapable and raw string literals, and comment styles. It provides precise pattern-matching capabilities for parsing and transforming Ruby code based on its syntactic constructs. Use cases include code refactoring tools and static analysis that require accurate recognition of Ruby's syntax features.",
      "description_length": 389,
      "index": 370,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Clojure.Syntax",
      "library": "comby-kernel",
      "description": "This module defines syntax elements specific to Clojure, including user-defined delimiters, escapable and raw string literals, and comment kinds. It provides precise syntactic patterns for parsing and matching Clojure code structures. Use this module when implementing Clojure-specific code analysis, transformation, or templating tools that require accurate syntax handling.",
      "description_length": 375,
      "index": 371,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Fortran.Info",
      "library": "comby-kernel",
      "description": "This module defines metadata for the Fortran language, including its name and file extensions. It provides direct access to the language identifier and a list of associated file extensions. This information is used for language detection and file handling in Fortran-specific tooling.",
      "description_length": 284,
      "index": 372,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Swift.Info",
      "library": "comby-kernel",
      "description": "This module defines metadata for the Swift programming language, including its name and file extensions. It provides concrete values for identifying Swift source files, such as `\"Swift\"` as the name and `[\".swift\"]` as the list of extensions. This information is used in tooling that needs to recognize or process Swift files based on their extension and language identifier.",
      "description_length": 375,
      "index": 373,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Elm.Info",
      "library": "comby-kernel",
      "description": "This module defines metadata for the Elm programming language, including its name and file extensions. It provides direct access to constants that identify Elm files, such as `.elm`, and is used in tooling that requires language-specific configuration. Concrete use cases include file type detection and language-specific processing in code analysis tools.",
      "description_length": 356,
      "index": 374,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.SQL.Syntax",
      "library": "comby-kernel",
      "description": "This module defines syntax elements for SQL, including user-defined delimiters, escapable and raw string literals, and comment styles. It provides concrete configurations for parsing and matching SQL code patterns. Use this module to handle SQL-specific syntax when analyzing or transforming database queries.",
      "description_length": 309,
      "index": 375,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Javascript.Info",
      "library": "comby-kernel",
      "description": "This module defines metadata for JavaScript, including the language name and file extensions. It provides direct access to the name as a string and extensions as a list of strings. This information is used to identify and handle JavaScript files in parsing and matching operations.",
      "description_length": 281,
      "index": 376,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Erlang.Syntax",
      "library": "comby-kernel",
      "description": "This module defines syntax-specific configurations for parsing and matching Erlang code. It specifies delimiters, string literals, and comment styles used in Erlang, such as tuple syntax, module attributes, and function definitions. These values guide pattern matching and transformation tools to accurately handle Erlang's syntactic constructs.",
      "description_length": 345,
      "index": 377,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Rust.Info",
      "library": "comby-kernel",
      "description": "This module defines metadata for the Rust programming language, including its name and file extensions. It provides concrete values for identifying Rust source files, such as `.rs`, and is used in tooling that requires language-specific configuration. The data is typically consumed by parsers or matchers that need to associate files with the Rust language.",
      "description_length": 358,
      "index": 378,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Elixir.Info",
      "library": "comby-kernel",
      "description": "This module defines metadata for the Elixir programming language, including its name and file extensions. It provides direct access to the language name as a string and a list of associated file extensions. This information is used to identify and handle Elixir source files in tooling that processes multiple languages.",
      "description_length": 320,
      "index": 379,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Html.Syntax",
      "library": "comby-kernel",
      "description": "This module defines syntax-specific configurations for HTML parsing, including custom delimiters, escapable and raw string literals, and comment handling. It supports structured manipulation of HTML content by specifying how different syntactic elements are recognized. Used to enable precise pattern matching and transformation of HTML documents.",
      "description_length": 347,
      "index": 380,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Fortran.Syntax",
      "library": "comby-kernel",
      "description": "This module defines syntax elements for Fortran, including user-defined delimiters, escapable and raw string literals, and comment styles. It supports parsing and matching Fortran code by specifying how strings and comments are structured in the language. Concrete use cases include configuring code transformation tools and implementing syntax-aware pattern matching for Fortran source files.",
      "description_length": 393,
      "index": 381,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Zig.Syntax",
      "library": "comby-kernel",
      "description": "This module defines syntactic elements specific to the Zig programming language, including user-defined delimiters, escapable and raw string literals, and comment kinds. It provides precise pattern-matching capabilities for parsing and transforming Zig code based on its lexical structure. Use cases include implementing custom code analysis tools, refactoring scripts, or linters that require accurate recognition of Zig syntax features like string encodings and comment blocks.",
      "description_length": 479,
      "index": 382,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Matlab.Syntax",
      "library": "comby-kernel",
      "description": "This module defines syntax elements for parsing and matching MATLAB code, including user-defined delimiters, escapable and raw string literals, and comment styles. It provides precise syntactic patterns used in MATLAB to support accurate code transformation and analysis tasks. These constructs are essential for handling MATLAB-specific syntax in code matching and rewriting operations.",
      "description_length": 387,
      "index": 383,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Matlab.Info",
      "library": "comby-kernel",
      "description": "This module defines metadata for the MATLAB programming language, including its name and file extensions. It provides the `name` value for identifying the language and `extensions` to recognize valid file types. Use this module to associate MATLAB-specific configurations with files based on their extension or name.",
      "description_length": 316,
      "index": 384,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Reason.Info",
      "library": "comby-kernel",
      "description": "This module defines metadata for the Reason programming language, including its name and file extensions. It provides direct access to the language identifier and a list of associated file extensions. This information is used to support language-specific operations in tooling such as syntax parsing and file recognition.",
      "description_length": 321,
      "index": 385,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Tsx.Syntax",
      "library": "comby-kernel",
      "description": "This module defines syntax-specific configurations for parsing and matching in a TypeScript JSX (TSX) context. It specifies delimiters, escapable and raw string literals, and comment styles used in TSX code. These values guide accurate pattern matching and transformation of TSX source code.",
      "description_length": 291,
      "index": 386,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Php.Info",
      "library": "comby-kernel",
      "description": "This module defines metadata for the PHP language, including its name and file extensions. It provides direct access to the language identifier and a list of associated file extensions. Useful for tools that need to recognize or process PHP files based on naming conventions.",
      "description_length": 275,
      "index": 387,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Zig.Info",
      "library": "comby-kernel",
      "description": "This module defines metadata for the Zig programming language, including its canonical name and associated file extensions. It provides direct access to the language name as a string and a list of common file extensions used for Zig source files. This information is used to identify and handle Zig files in tooling that processes multiple programming languages.",
      "description_length": 362,
      "index": 388,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Dhall.Syntax",
      "library": "comby-kernel",
      "description": "This module defines syntax elements for parsing and matching Dhall code, including user-defined delimiters, escapable and raw string literals, and comment styles. It provides concrete configurations for handling Dhall-specific syntax features like multi-line strings and comment blocks. Use cases include building parsers or transformers that accurately recognize Dhall's syntax constructs in source code.",
      "description_length": 405,
      "index": 389,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.HCL.Info",
      "library": "comby-kernel",
      "description": "This module defines metadata for the HCL language, including its name and file extensions. It provides direct access to static information used for identifying and handling HCL files. Concrete use cases include file type detection and language-specific configuration in tools processing HCL syntax.",
      "description_length": 298,
      "index": 390,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.R.Info",
      "library": "comby-kernel",
      "description": "This module defines metadata for a programming language, including its name and associated file extensions. It works with string and list data types to store and retrieve language-specific identifiers. Concrete use cases include language detection based on file extension and providing human-readable names for language implementations.",
      "description_length": 336,
      "index": 391,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.C.Syntax",
      "library": "comby-kernel",
      "description": "This module defines syntax-specific configurations for parsing and matching C code, including delimiters, string literals, and comment styles. It provides explicit lists of user-defined delimiters, escapable and raw string literal markers, and supported comment formats. These values are used to customize pattern matching and transformation logic in C source code analysis tools.",
      "description_length": 380,
      "index": 392,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Move.Syntax",
      "library": "comby-kernel",
      "description": "This module defines syntax elements for the Move programming language, including user-defined delimiters, escapable and raw string literals, and comment kinds. It provides precise parsing configurations to support pattern matching and code transformation tasks. Use cases include implementing language-specific matching rules and syntax-aware processing for Move source code.",
      "description_length": 375,
      "index": 393,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Text.Syntax",
      "library": "comby-kernel",
      "description": "This module defines syntax elements for text-based languages, including user-defined delimiters, escapable and raw string literals, and comment styles. It provides concrete configurations for parsing and matching text patterns with specific lexical structures. Use cases include configuring parsers for domain-specific text formats or templating languages with custom syntax rules.",
      "description_length": 381,
      "index": 394,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Swift.Syntax",
      "library": "comby-kernel",
      "description": "This module defines syntax-specific configurations for Swift, including delimiters for string literals, comment styles, and escaping rules. It specifies raw string delimiters, escapable string patterns, and supported comment formats. These values are used to parse and match Swift code structures in pattern-matching operations.",
      "description_length": 328,
      "index": 395,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Nim.Info",
      "library": "comby-kernel",
      "description": "This module defines metadata for the Nim programming language, including its canonical name and file extensions. It provides direct access to static information used for language identification and file handling. Concrete use cases include determining Nim source files by extension and referencing the language name in tooling contexts.",
      "description_length": 336,
      "index": 396,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Generic.Info",
      "library": "comby-kernel",
      "description": "This module defines metadata for a generic programming language, including its name and file extensions. It provides direct access to these properties through the `name` and `extensions` values. This information is used to identify and associate files with the corresponding language in parsing and matching workflows.",
      "description_length": 318,
      "index": 397,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Assembly.Info",
      "library": "comby-kernel",
      "description": "This module defines metadata for assembly language files, including the language name and common file extensions. It provides direct access to predefined values for identifying and categorizing assembly source files. Use this module when handling file type detection or language-specific processing for assembly code.",
      "description_length": 317,
      "index": 398,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Kotlin.Syntax",
      "library": "comby-kernel",
      "description": "This module defines syntax elements specific to Kotlin, including user-defined delimiters, escapable and raw string literals, and comment kinds. It provides precise syntactic patterns for parsing and matching Kotlin code structures. Use this module to handle Kotlin-specific string and comment syntax during code analysis or transformation tasks.",
      "description_length": 346,
      "index": 399,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.JSON.Syntax",
      "library": "comby-kernel",
      "description": "This module defines syntax elements for parsing and matching JSON, including user-defined delimiters, escapable and raw string literals, and comment styles. It works with string literals, delimiters, and comment structures to support pattern matching in JSON documents. Concrete use cases include identifying JSON keys, values, and structural elements during code analysis or transformation tasks.",
      "description_length": 397,
      "index": 400,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Julia.Syntax",
      "library": "comby-kernel",
      "description": "This module defines syntax-specific configurations for parsing and matching Julia code, including delimiters for string literals, escapable and raw string formats, and comment styles. It provides concrete syntax rules that enable accurate pattern matching in Julia source files. Use this module when implementing tools that analyze or transform Julia code, such as linters, formatters, or refactoring utilities.",
      "description_length": 411,
      "index": 401,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.JSON.Info",
      "library": "comby-kernel",
      "description": "This module defines metadata for the JSON language, including the language name and file extensions associated with JSON files. It provides direct access to static information used for identifying and handling JSON content. Concrete use cases include determining file type based on extension and labeling JSON data in processing pipelines.",
      "description_length": 339,
      "index": 402,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Csharp.Syntax",
      "library": "comby-kernel",
      "description": "This module defines syntax elements specific to C# for parsing and matching code patterns. It specifies delimiters for user-defined literals, escapable and raw string literal syntax, and comment styles. These values support accurate pattern matching and transformation of C# code structures.",
      "description_length": 291,
      "index": 403,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Solidity.Syntax",
      "library": "comby-kernel",
      "description": "This module defines syntax-specific configurations for parsing and matching Solidity code. It specifies delimiters, string literals, and comment styles used in Solidity, such as user-defined delimiters for expressions, escapable and raw string formats, and supported comment kinds. These values are used directly during pattern matching and transformation of Solidity source code.",
      "description_length": 380,
      "index": 404,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Xml.Info",
      "library": "comby-kernel",
      "description": "This module defines metadata for XML language support, including the language name and file extensions. It provides concrete values for identifying XML files in tooling contexts. Useful for determining file type associations and enabling XML-specific processing in applications.",
      "description_length": 278,
      "index": 405,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Dyck.Info",
      "library": "comby-kernel",
      "description": "This module defines metadata for a language called Dyck, including its name and associated file extensions. It provides direct access to the language's identifier and a list of its common file extensions. This information is used when parsing or analyzing Dyck language files in tooling contexts.",
      "description_length": 296,
      "index": 406,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Erlang.Info",
      "library": "comby-kernel",
      "description": "This module defines metadata for the Erlang language, including its name and file extensions. It provides direct access to the language name as a string and a list of associated file extensions. This information is used in file processing and language detection workflows where Erlang-specific identifiers are required.",
      "description_length": 319,
      "index": 407,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Elm.Syntax",
      "library": "comby-kernel",
      "description": "This module defines syntax-specific configurations for parsing and matching Elm code, including delimiters for user-defined literals, escapable and raw string literals, and comment styles. It provides concrete values that specify how different syntactic elements are represented in Elm source code. These configurations are used directly by pattern matching and transformation tools to accurately process Elm syntax.",
      "description_length": 416,
      "index": 408,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.GraphQL.Info",
      "library": "comby-kernel",
      "description": "This module defines metadata for the GraphQL language, including its name and file extensions. It provides direct access to the language identifier and a list of associated file extensions. Useful for tools that need to recognize or process GraphQL files based on naming conventions.",
      "description_length": 283,
      "index": 409,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Pascal.Syntax",
      "library": "comby-kernel",
      "description": "This module defines syntax elements for Pascal, including user-defined delimiters, escapable and raw string literals, and comment styles. It provides specific configurations for parsing and matching Pascal code constructs. Use this module to handle Pascal-specific syntax when analyzing or transforming Pascal source files.",
      "description_length": 323,
      "index": 410,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Lisp.Syntax",
      "library": "comby-kernel",
      "description": "This module defines syntax elements for Lisp-like languages, including customizable delimiters for string literals, escapable and raw string formats, and comment styles. It supports parsing and matching code patterns by specifying how different syntactic constructs are represented. Use this to configure language-specific syntax handling in code analysis or transformation tools.",
      "description_length": 380,
      "index": 411,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Javascript.Syntax",
      "library": "comby-kernel",
      "description": "This module defines syntax-specific configurations for JavaScript, including delimiters for string literals, escapable and raw string formats, and comment styles. It provides precise syntax rules that enable accurate parsing and transformation of JavaScript code. Use cases include implementing custom code refactoring tools, linters, or syntax highlighters that require detailed language semantics.",
      "description_length": 399,
      "index": 412,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Php.Syntax",
      "library": "comby-kernel",
      "description": "This module defines syntax-specific configurations for PHP, including delimiters for user-defined strings, escapable and raw string literals, and comment styles. It provides precise syntactic patterns used for parsing and matching PHP code structures. Concrete use cases include identifying string boundaries, handling heredoc syntax, and distinguishing between different comment forms like `//` and `/* */`.",
      "description_length": 408,
      "index": 413,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Bash.Syntax",
      "library": "comby-kernel",
      "description": "This module defines syntax elements for parsing and matching Bash scripts, including delimiters, string literals, and comment styles. It supports concrete operations like identifying user-defined delimiters, handling escapable and raw string literals, and recognizing various comment formats. Use cases include building parsers or linters for Bash scripts that require precise syntax matching.",
      "description_length": 393,
      "index": 414,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Fsharp.Info",
      "library": "comby-kernel",
      "description": "This module defines metadata for the F# programming language, including its name and file extensions. It provides direct access to the language name as a string and a list of associated file extensions. This information is used for language identification and file handling in code processing tools.",
      "description_length": 299,
      "index": 415,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Jsx.Info",
      "library": "comby-kernel",
      "description": "This module defines metadata for the JSX language, including its name and file extensions. It provides direct access to the language identifier and a list of associated file extensions. Useful for tools that need to recognize or process JSX files based on their extension or name.",
      "description_length": 280,
      "index": 416,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Fsharp.Syntax",
      "library": "comby-kernel",
      "description": "This module defines syntax elements for F# such as user-defined delimiters, escapable and raw string literals, and comment kinds. It provides precise syntactic patterns used for parsing and matching F# code structures. Concrete use cases include identifying string boundaries, handling escaped characters, and recognizing single-line and multi-line comments in F# source files.",
      "description_length": 377,
      "index": 417,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Bash.Info",
      "library": "comby-kernel",
      "description": "This module defines metadata for the Bash language, including its name and file extensions. It provides direct access to the language identifier and a list of associated file extensions. Use this module to retrieve Bash-specific naming and extension information for file processing or language detection tasks.",
      "description_length": 310,
      "index": 418,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Java.Syntax",
      "library": "comby-kernel",
      "description": "This module defines syntax elements specific to Java, including user-defined delimiters, escapable and raw string literals, and comment kinds. It provides precise syntactic patterns for parsing and matching Java code structures. Use this module to handle Java-specific syntax when analyzing or transforming Java source files.",
      "description_length": 325,
      "index": 419,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Clojure.Info",
      "library": "comby-kernel",
      "description": "This module defines metadata for the Clojure programming language, including its name and file extensions. It provides direct access to the language name as a string and a list of associated file extensions. This information is used to identify and handle Clojure source files in tooling that processes multiple languages.",
      "description_length": 322,
      "index": 420,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Coq.Syntax",
      "library": "comby-kernel",
      "description": "This module defines syntax elements for parsing and matching Coq code, including user-defined delimiters, escapable and raw string literals, and comment styles. It provides precise syntactic rules to support pattern matching and transformation tasks specific to Coq. Use cases include implementing custom Coq code analysis, refactoring tools, or automated rewriting of Coq terms and definitions.",
      "description_length": 395,
      "index": 421,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Typescript.Info",
      "library": "comby-kernel",
      "description": "This module defines metadata for the TypeScript language, including its name and file extensions. It provides direct access to the language identifier and a list of associated file extensions. Useful for tools that need to recognize or process TypeScript files based on naming conventions.",
      "description_length": 289,
      "index": 422,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Tsx.Info",
      "library": "comby-kernel",
      "description": "This module defines metadata for the TSX language, including its name and file extensions. It provides direct access to the language identifier and a list of associated file extensions. Useful for tools that need to recognize or process TSX files based on their extension or name.",
      "description_length": 280,
      "index": 423,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Xml.Syntax",
      "library": "comby-kernel",
      "description": "This module defines syntax elements for XML parsing, including user-defined delimiters, escapable and raw string literals, and comment structures. It provides precise configurations for handling XML-specific syntax features like tags, attributes, and text content. Use this module to customize XML parsing behavior in tools like code analyzers or refactoring engines.",
      "description_length": 367,
      "index": 424,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.OCaml.Syntax",
      "library": "comby-kernel",
      "description": "This module defines syntax-specific configurations for OCaml, including delimiters for string literals, escapable and raw string formats, and comment styles. It provides concrete syntax rules used during pattern matching and transformation of OCaml code. These configurations enable precise parsing and manipulation of OCaml source files in tools like code linters or refactoring utilities.",
      "description_length": 390,
      "index": 425,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Scala.Info",
      "library": "comby-kernel",
      "description": "This module defines metadata for the Scala programming language, including its name and file extensions. It provides direct access to the language name as a string and a list of associated file extensions. This information is used to identify and process Scala source files in tooling contexts like code analysis or transformation.",
      "description_length": 331,
      "index": 426,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Paren.Syntax",
      "library": "comby-kernel",
      "description": "This module defines syntax configurations for parenthetical languages, specifying delimiters, string literals, and comments. It provides concrete syntax elements like user-defined parentheses, escapable and raw string delimiters, and comment markers. Used to configure parsing and matching behavior for languages with parenthetical structures.",
      "description_length": 343,
      "index": 427,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Latex.Info",
      "library": "comby-kernel",
      "description": "This module defines metadata for the LaTeX language, including its name and file extensions. It provides the `name` value as a string and `extensions` as a list of strings representing associated file types. Concrete use cases include identifying LaTeX files by extension and referencing the language name in tooling or configuration contexts.",
      "description_length": 343,
      "index": 428,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Paren.Info",
      "library": "comby-kernel",
      "description": "This module defines metadata for a programming language, specifically its name and associated file extensions. It works with string and list data types to store and retrieve this information. A concrete use case is configuring language-specific settings in a code editor or tool based on file extension or display name.",
      "description_length": 319,
      "index": 429,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Dart.Syntax",
      "library": "comby-kernel",
      "description": "This module defines syntax elements specific to Dart, including user-defined delimiters, escapable and raw string literals, and comment kinds. It provides precise syntactic patterns for parsing and matching Dart code structures. Use cases include implementing custom parsers, linters, or code transformation tools that require accurate Dart syntax recognition.",
      "description_length": 360,
      "index": 430,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Reason.Syntax",
      "library": "comby-kernel",
      "description": "This module defines syntax-specific configurations for parsing and matching code in the Reason language. It specifies delimiters, escapable and raw string literals, and comment styles used in Reason syntax. These values guide accurate pattern matching and parsing of Reason code structures in tools like code transformers or linters.",
      "description_length": 333,
      "index": 431,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Solidity.Info",
      "library": "comby-kernel",
      "description": "This module defines metadata for the Solidity programming language, including its name and file extensions. It provides direct access to the language name as a string and a list of associated file extensions. Concrete use cases include identifying Solidity files by extension and referencing the language name in tooling or configuration contexts.",
      "description_length": 347,
      "index": 432,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Assembly.Syntax",
      "library": "comby-kernel",
      "description": "This module defines syntax elements for assembly languages, including user-defined delimiters, escapable and raw string literals, and comment styles. It provides precise configurations for parsing and matching assembly code patterns. Use this module to handle assembly-specific syntax variations in code analysis or transformation tasks.",
      "description_length": 337,
      "index": 433,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Coq.Info",
      "library": "comby-kernel",
      "description": "This module defines metadata for the Coq programming language, including its name and file extensions. It provides direct access to the language's identifier and a list of associated file extensions. This information is used for language detection and file handling in tooling that processes Coq source files.",
      "description_length": 309,
      "index": 434,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Html",
      "library": "comby-kernel",
      "description": "This module provides metadata and syntax configurations for HTML files, including language identification, file extensions, and parsing rules. It defines delimiters, comment handling, and literal representations specific to HTML. Used for accurate HTML file type detection and structured document manipulation during parsing and transformation tasks.",
      "description_length": 350,
      "index": 435,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Bash",
      "library": "comby-kernel",
      "description": "This module provides operations for retrieving Bash language metadata and defining syntax rules for parsing Bash scripts. It works with string literals, delimiters, and comment structures specific to Bash. Concrete use cases include implementing Bash script parsers, linters, or tools that require accurate language detection and syntax analysis.",
      "description_length": 346,
      "index": 436,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Alpha.Java",
      "library": "comby-kernel",
      "description": "This module provides functions to find all or first matches of a template in Java source code, supporting recursive matching on nested structures. It operates on strings representing source code and templates, returning lists or individual match results. Use cases include searching for specific code patterns in Java files, such as method calls or variable declarations, while supporting configuration options and file context.",
      "description_length": 428,
      "index": 437,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Alpha.Erlang",
      "library": "comby-kernel",
      "description": "This module provides functions to match Erlang source code against templates, returning all matches or the first match with optional configuration and positional control. It operates on strings representing source code and templates, and returns structured match results. It supports Erlang-specific file extensions and identifies the language matcher by name.",
      "description_length": 360,
      "index": 438,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Reason",
      "library": "comby-kernel",
      "description": "This module provides language metadata and syntax configuration for working with the Reason programming language. It includes direct access to the language identifier and file extensions, as well as syntax-specific settings like delimiters, string literals, and comment styles. These are used to support precise code parsing, pattern matching, and tooling integration for Reason source files.",
      "description_length": 392,
      "index": 439,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Alpha.Latex",
      "library": "comby-kernel",
      "description": "This module implements LaTeX-specific pattern matching operations for source code analysis, supporting template-based matching with configurable recursion. It processes string inputs representing LaTeX content and templates, returning structured match results with contextual information. Typical use cases include automated LaTeX code transformation, syntax analysis, and structural validation tasks.",
      "description_length": 401,
      "index": 440,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.HCL",
      "library": "comby-kernel",
      "description": "This module provides functions to detect and process HCL files using language-specific metadata and syntax rules. It works with string literals, delimiters, and comment structures defined in HCL for precise code analysis. Concrete use cases include implementing HCL-aware tools such as parsers, formatters, and static analyzers.",
      "description_length": 328,
      "index": 441,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Alpha.Julia",
      "library": "comby-kernel",
      "description": "This module provides functions to find all or the first matches of a template in Julia source code, supporting recursive matching through a configuration flag. It works with strings for both template and source code, returning lists of matches or individual match results. Use cases include pattern-based code analysis and transformation tasks specific to Julia files.",
      "description_length": 368,
      "index": 442,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Template.Make",
      "library": "comby-kernel",
      "description": "Parses string templates into structured syntax trees and extracts variable names from template strings. Works with strings and syntax trees representing template structures. Used to process and analyze code templates with placeholders for pattern matching or transformation tasks.",
      "description_length": 280,
      "index": 443,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Pascal",
      "library": "comby-kernel",
      "description": "This module provides metadata and syntax definitions for Pascal, including language name, file extensions, string literals, and comment styles. It supports tools that process Pascal code by defining how to identify and parse Pascal source files. Concrete use cases include configuring parsers, syntax highlighters, and code analysis tools for Pascal.",
      "description_length": 350,
      "index": 444,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Tsx",
      "library": "comby-kernel",
      "description": "This module provides access to TSX language metadata and syntax configuration for parsing and matching. It includes the language name, file extensions, delimiters, string literals, and comment styles specific to TypeScript JSX. Directly supports tools that analyze or transform TSX code by enabling precise pattern recognition and handling of syntax elements.",
      "description_length": 359,
      "index": 445,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Elixir",
      "library": "comby-kernel",
      "description": "This module provides direct access to Elixir language metadata such as its name and common file extensions like `.ex` and `.exs`. It also defines syntactic elements specific to Elixir, including sigil delimiters, string literals, and comment formats. These features enable accurate parsing, matching, and processing of Elixir source files in tools like formatters, linters, and code transformers.",
      "description_length": 396,
      "index": 446,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Omega.Dyck",
      "library": "comby-kernel",
      "description": "This module implements Dyck language-based matching for structured code patterns, supporting operations to find all or the first match of a template within a source string. It works with string inputs representing code templates and source code, returning lists or individual match records containing positional and structural details. It is used for precise syntactic matching in code transformation tools, particularly for languages with nested or balanced constructs like parentheses or brackets.",
      "description_length": 499,
      "index": 447,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Csharp",
      "library": "comby-kernel",
      "description": "This module provides access to C# language metadata and syntax definitions for code analysis and transformation. It includes static values for identifying C# files and specifying syntax elements such as string literals, comments, and delimiters. Use it to support pattern matching, code parsing, and tooling integration for C# source files.",
      "description_length": 340,
      "index": 448,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Omega.Jsx",
      "library": "comby-kernel",
      "description": "This module provides functions to match templates within JSX source code, supporting both full and first-match searches with configurable parameters. It operates on strings representing templates and source code, returning structured match results. Use cases include identifying specific JSX patterns in files for refactoring or analysis, with support for nested matching and language-specific extensions.",
      "description_length": 405,
      "index": 449,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Alpha.Haskell",
      "library": "comby-kernel",
      "description": "This module provides functions to find all or the first occurrence of a template in Haskell source code, returning detailed match information. It works with strings for both template and source input, and supports configuration options for matching behavior and file context. Use cases include searching for specific code patterns in Haskell files, such as identifying function definitions or syntactic structures.",
      "description_length": 414,
      "index": 450,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Alpha.Xml",
      "library": "comby-kernel",
      "description": "This module implements XML-specific matching operations for finding and extracting structured patterns in source code. It provides functions to locate all or the first occurrence of a template within a given source string, supporting recursive matching when enabled. The module works with XML syntax trees and string-based templates, enabling precise code analysis tasks such as refactoring or code search in XML files.",
      "description_length": 419,
      "index": 451,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Assembly",
      "library": "comby-kernel",
      "description": "This module handles assembly language metadata and syntax definitions. It provides direct access to predefined language identifiers, file extensions, and syntax configurations such as delimiters, string literals, and comment styles. Use it for file type detection, code analysis, or transformation tasks specific to assembly languages.",
      "description_length": 335,
      "index": 452,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Alpha.Fortran",
      "library": "comby-kernel",
      "description": "This module implements template-based matching for Fortran code, supporting operations to find all or the first match of a given template within a source string. It works with string inputs representing Fortran code and templates, producing lists of match results or individual match outcomes. Use cases include automated code analysis and transformation tasks specific to Fortran, such as identifying and rewriting specific syntactic patterns in Fortran source files.",
      "description_length": 468,
      "index": 453,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.External.Default",
      "library": "comby-kernel",
      "description": "This module defines a default external handler used for processing structured data with pattern matching. It works with abstract syntax trees and string-based patterns to enable customizable matching logic. Concrete use cases include extending the matcher to support domain-specific languages or custom parsing rules.",
      "description_length": 317,
      "index": 454,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Omega.Solidity",
      "library": "comby-kernel",
      "description": "This module provides functions to find all or first matches of a template in Solidity source code, supporting recursive matching through a configuration flag. It operates on strings for both template and source code, returning lists of match results or individual match errors. Use cases include identifying specific Solidity code patterns for analysis or transformation tasks.",
      "description_length": 377,
      "index": 455,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Alpha.C",
      "library": "comby-kernel",
      "description": "This module provides functions to find all or the first occurrence of a template in C source code, returning detailed match information. It works with C language syntax, supporting `.c` and `.h` files, and uses configuration and rule parameters to customize matching behavior. Concrete use cases include searching for specific code patterns in C files, such as function calls or variable declarations, either across the entire source or starting from a given position.",
      "description_length": 468,
      "index": 456,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Omega.C_nested_comments",
      "library": "comby-kernel",
      "description": "This module implements comment matching logic for C-like nested comments, handling recursive template matching within matched regions. It provides functions to find all matches or the first match of a template in a source string, supporting configuration options and positional shifting for precise matching control. Use cases include parsing and transforming C, C++, or similar language files where nested comments need to be identified and processed.",
      "description_length": 452,
      "index": 457,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Alpha.JSONC",
      "library": "comby-kernel",
      "description": "This module provides functions to match JSONC templates in source code, returning all matches or the first match starting at a specified position. It works with strings for both template and source input, and supports configuration options for matching behavior. Concrete use cases include parsing and transforming JSONC-formatted text with customizable matching rules.",
      "description_length": 369,
      "index": 458,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Omega.GraphQL",
      "library": "comby-kernel",
      "description": "This module implements a GraphQL-based matcher for finding and extracting structured patterns in source code. It provides operations to find all matches or the first match of a template in a given source string, supporting recursive matching when enabled. The matcher works with GraphQL documents and leverages the `Comby_kernel.match'` type to represent match results, along with configuration options to control matching behavior.",
      "description_length": 432,
      "index": 459,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Omega.Fsharp",
      "library": "comby-kernel",
      "description": "This module provides functions to find all or the first matches of a template within F# source code, supporting recursive matching on nested structures. It operates on strings for both template and source code inputs, returning lists of match results or individual match results with error handling. Use cases include searching for specific syntactic patterns in F# code, such as function definitions or expressions, during code analysis or transformation tasks.",
      "description_length": 462,
      "index": 460,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Alpha.Scala",
      "library": "comby-kernel",
      "description": "This module provides functions to find all or first matches of a template in Scala source code, supporting recursive matching on nested structures. It operates on strings for both template and source code, returning lists or individual match results. Use cases include identifying specific code patterns in Scala files for refactoring or analysis.",
      "description_length": 347,
      "index": 461,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Omega.Text",
      "library": "comby-kernel",
      "description": "This module provides functions to match text templates against source code, supporting both first and all match extractions with optional nested matching. It operates on strings for templates and source code, returning lists or individual match records. Use cases include parsing and transforming code in specific languages like C or Go, where precise text pattern matching is required.",
      "description_length": 386,
      "index": 462,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Omega.Matlab",
      "library": "comby-kernel",
      "description": "This module implements template-based matching for MATLAB code, providing functions to find all or the first occurrence of a template in a source string. It operates on strings representing MATLAB code and templates, returning structured match results with support for nested matching. Use cases include code analysis and transformation tasks where specific MATLAB syntax patterns need to be identified, such as extracting function calls or variable assignments.",
      "description_length": 462,
      "index": 463,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Omega.Swift",
      "library": "comby-kernel",
      "description": "This module provides functions to match templates against Swift source code, returning all matches or the first match starting at a specified position. It operates on strings representing the template and source code, and returns structured match results. It is used for analyzing and transforming Swift code by identifying specific syntactic patterns.",
      "description_length": 352,
      "index": 464,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Alpha.Clojure",
      "library": "comby-kernel",
      "description": "This module provides functions to find all or the first matches of a template in Clojure source code, supporting recursive matching on nested structures. It works with strings for template and source input, returning lists of match results or individual match errors. Use cases include searching for syntactic patterns in Clojure files, such as identifying function definitions or code transformations.",
      "description_length": 402,
      "index": 465,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Omega.Xml",
      "library": "comby-kernel",
      "description": "This module provides functions to match XML templates against source code, returning all matches or the first match starting at a specified position. It works with strings as input for templates and source code, and returns structured match results. It is used for parsing and analyzing XML-based languages, supporting recursive matching on nested content.",
      "description_length": 356,
      "index": 466,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Ruby",
      "library": "comby-kernel",
      "description": "This module provides metadata and syntax definitions for the Ruby programming language. It includes the language name, file extensions, string literals, delimiters, and comment styles. It supports code analysis, refactoring tools, and static analysis requiring precise Ruby syntax handling.",
      "description_length": 290,
      "index": 467,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Omega.Typescript",
      "library": "comby-kernel",
      "description": "This module provides functions to match TypeScript code patterns within source code using templates. It supports finding all matches or the first match at a specific position, with configurable matching behavior and file context. The module works with strings as input and outputs structured match results, specifically tailored for TypeScript syntax. Use cases include automated code analysis and transformation tasks where precise pattern matching in TypeScript files is required.",
      "description_length": 482,
      "index": 468,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Omega.Move",
      "library": "comby-kernel",
      "description": "This module provides functions to find all or the first structural matches of a template within a source string, supporting nested matching when enabled. It operates on strings as input and returns lists or individual match records containing detailed match information. The module also identifies the language it works with via its name and supported file extensions, enabling use cases like language-specific code transformation tools or static analysis utilities.",
      "description_length": 466,
      "index": 469,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Python",
      "library": "comby-kernel",
      "description": "This module provides metadata and syntax configurations for processing Python code. It includes the language name, file extensions, string delimiters, and comment styles. It supports tools that perform code analysis, pattern matching, or transformation on Python source files.",
      "description_length": 276,
      "index": 470,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Dart",
      "library": "comby-kernel",
      "description": "This module provides concrete metadata and syntax definitions for the Dart programming language. It includes file extensions like `.dart` and syntactic elements such as string literals, delimiters, and comments. It supports tools like linters, formatters, and parsers that require precise Dart language recognition.",
      "description_length": 315,
      "index": 471,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Alpha.Jsx",
      "library": "comby-kernel",
      "description": "This module provides functions to match JSX templates within source code, supporting both full and first-occurrence matching with configurable parameters. It operates on strings representing templates and source code, returning structured match results. Use cases include identifying JSX patterns in JavaScript files for refactoring or analysis.",
      "description_length": 345,
      "index": 472,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Alpha.Lisp",
      "library": "comby-kernel",
      "description": "This module implements template-based matching for Lisp code, providing functions to find all or the first match of a template within a source string. It operates on Lisp syntax trees, supporting recursive matching when enabled, and returns structured match results. Use cases include code transformation tools and static analysis for Lisp dialects, leveraging pattern matching over abstract syntax trees.",
      "description_length": 405,
      "index": 473,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Omega.Paren",
      "library": "comby-kernel",
      "description": "This module provides functions to find all or first matches of a template in a source string, supporting recursive matching when enabled. It works with strings as input and returns structured match results, optionally starting from a specified position. The module identifies the language by name and supported file extensions, enabling targeted template matching for concrete syntax transformations.",
      "description_length": 400,
      "index": 474,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Omega.Make",
      "library": "comby-kernel",
      "description": "This module implements template-based matching for structured text, providing operations to find all or the first match of a template within a source string. It works with strings as input and produces lists or individual match records containing positional and substitution data. It is used to perform language-specific pattern matching, such as identifying function calls or variable declarations in source code files.",
      "description_length": 420,
      "index": 475,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Kotlin",
      "library": "comby-kernel",
      "description": "This module provides access to Kotlin language metadata like file extensions and syntax elements such as string delimiters and comment patterns. It works with string literals, comments, and file extension data to support parsing, matching, and processing Kotlin source files. Concrete use cases include configuring code analysis tools to correctly interpret Kotlin syntax and handling raw or escaped strings during transformations.",
      "description_length": 431,
      "index": 476,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.OCaml",
      "library": "comby-kernel",
      "description": "This module provides access to OCaml language metadata and syntax configurations. It includes predefined values for file extensions and syntax rules such as string delimiters, escape sequences, and comment formats. It is used to configure parsers, filter files, and support code analysis or transformation tools like linters and refactoring utilities.",
      "description_length": 351,
      "index": 477,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Alpha.Tsx",
      "library": "comby-kernel",
      "description": "This module provides functions to find all or the first matches of a template in a source string, supporting recursive matching on nested content. It works with strings as input sources and templates, returning lists or individual match records. Use cases include parsing and transforming TypeScript JSX code by identifying structural patterns in the source.",
      "description_length": 358,
      "index": 478,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Alpha.Fsharp",
      "library": "comby-kernel",
      "description": "This module implements F# language-specific pattern matching operations for source code analysis. It provides functions to find all or the first occurrence of a template in F# source code, supporting recursive matching on nested structures. The module works with string-based templates and source inputs, returning structured match results with language-specific parsing rules.",
      "description_length": 377,
      "index": 479,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Language.Syntax",
      "library": "comby-kernel",
      "description": "This module defines data structures and functions for representing and manipulating language-specific syntax elements such as string literals, delimiters, and comment formats. It includes types for escapable and raw string literals, comment kinds, and configurations for custom delimiters. Use this module to configure syntactic matching rules for specific programming languages like C or Go, enabling precise pattern recognition in source code.",
      "description_length": 445,
      "index": 480,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Xml",
      "library": "comby-kernel",
      "description": "This module provides operations for identifying XML files through metadata and configuring XML syntax parsing with support for tags, attributes, and text content handling. It works with string-based representations of XML structures and file extension definitions. Concrete use cases include enabling XML-specific processing in code tools and customizing parser behavior for XML documents.",
      "description_length": 389,
      "index": 481,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Alpha.Matlab",
      "library": "comby-kernel",
      "description": "This module provides functions to find all or first matches of a template in MATLAB source code, supporting recursive matching and file-specific configurations. It works with strings for template and source code inputs, returning structured match results. Use cases include identifying specific code patterns in MATLAB files for refactoring or analysis.",
      "description_length": 353,
      "index": 482,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Alpha.Html",
      "library": "comby-kernel",
      "description": "This module provides functions to match HTML templates against source code, returning all or the first match with optional configuration and file context. It operates on strings representing HTML templates and source content, and returns structured match results. Use cases include extracting or transforming specific HTML elements or patterns from web documents.",
      "description_length": 363,
      "index": 483,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Fortran",
      "library": "comby-kernel",
      "description": "This module provides metadata and syntax definitions for Fortran, including language identifiers, file extensions, string delimiters, and comment styles. It supports operations like language detection, file handling, and syntax-aware pattern matching for Fortran source files. Used in code transformation tools and parsers requiring precise Fortran syntax handling.",
      "description_length": 365,
      "index": 484,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Alpha.Bash",
      "library": "comby-kernel",
      "description": "This module provides functions to match templates against Bash source code, returning all matches or the first match starting at a specified position. It works with strings as input source and template, and returns structured match results with optional configuration for nested matching. Use cases include finding repeated patterns in Bash scripts, such as command sequences or function definitions, for analysis or transformation tasks.",
      "description_length": 438,
      "index": 485,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Alpha.Javascript",
      "library": "comby-kernel",
      "description": "This module provides functions to find all or first matches of a JavaScript template in a source code string, supporting recursive matching on nested structures. It works with JavaScript syntax trees and string-based templates, returning detailed match information. Use cases include code analysis, transformation, and refactoring tasks specific to JavaScript.",
      "description_length": 360,
      "index": 486,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Haskell",
      "library": "comby-kernel",
      "description": "This module provides direct access to Haskell language metadata, including its name and common file extensions like `.hs`. It defines syntax-specific configurations such as comment delimiters `(\"{-\", \"-}\")` and string literal markers `\"` for accurate parsing and pattern matching. These values support tools that analyze or transform Haskell source code by enabling correct recognition of language-specific constructs.",
      "description_length": 418,
      "index": 487,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Java",
      "library": "comby-kernel",
      "description": "This module provides metadata and syntax definitions for Java, including file extensions and language name in the `Info` submodule, and Java-specific syntactic elements like delimiters, string literals, and comments in the `Syntax` submodule. It works with string and list data types to enable file identification, parsing, and code transformation tasks. Use it to accurately recognize Java files and process their syntax in tools like linters, formatters, or source code analyzers.",
      "description_length": 482,
      "index": 488,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Alpha.HCL",
      "library": "comby-kernel",
      "description": "This module implements HCL (HashiCorp Configuration Language) template matching operations for finding exact or nested matches within source code. It provides functions to locate all matches or the first match of a template in a source string, supporting recursive matching on matched content when enabled. The module works with HCL syntax and is used for tasks like code analysis or transformation where HCL files are involved.",
      "description_length": 428,
      "index": 489,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.C_nested_comments",
      "library": "comby-kernel",
      "description": "This module handles parsing and transformation of C-like languages with support for nested comments and complex string literals. It works with syntax configurations to define delimiters, comment markers, and string handling rules. Concrete use cases include building parsers or code transformation tools that must correctly process nested comments and string syntax in languages such as C, C++, or Rust.",
      "description_length": 403,
      "index": 490,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Omega.Julia",
      "library": "comby-kernel",
      "description": "This module provides functions to find all or the first structural matches of a template in Julia source code, supporting recursive matching on nested structures. It operates on strings representing source code and templates, returning lists of matches or individual match results. Use cases include code analysis and transformation tasks specific to Julia, such as identifying specific syntax patterns or refactoring code elements.",
      "description_length": 432,
      "index": 491,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.R",
      "library": "comby-kernel",
      "description": "This module provides functions to define and work with R language syntax and metadata. It handles string and list operations for specifying delimiters, string literals, comments, and file extensions. Use it to configure parsers or matchers that require precise recognition of R code structure and to identify R files based on extension.",
      "description_length": 336,
      "index": 492,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Omega.Latex",
      "library": "comby-kernel",
      "description": "This module implements LaTeX-specific matching operations for finding and extracting patterns in LaTeX documents. It provides functions to find all matches or the first match of a template in a source string, supporting recursive matching when enabled. The module works directly with LaTeX syntax structures, handling templates and sources as strings, and returns matches in a structured format suitable for analysis or transformation tasks.",
      "description_length": 441,
      "index": 493,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Alpha.C_nested_comments",
      "library": "comby-kernel",
      "description": "This module implements comment-aware template matching for C-like languages, handling nested comments during pattern matching. It provides functions to find all or the first match of a template in a source string, with support for recursive matching within comments. Use it to analyze or transform C code by matching structural patterns while safely skipping commented-out sections.",
      "description_length": 382,
      "index": 494,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Clojure",
      "library": "comby-kernel",
      "description": "This module provides direct access to Clojure language metadata such as its name and file extensions, and defines syntax elements like delimiters, string literals, and comments. It works with string and list data types to support parsing, matching, and transformation of Clojure code. Concrete use cases include implementing Clojure-specific code analysis tools, templating systems, and language processing utilities that require precise syntactic handling.",
      "description_length": 457,
      "index": 495,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Javascript",
      "library": "comby-kernel",
      "description": "This module provides metadata and syntax configurations for JavaScript, including file extensions and string delimiters. It supports operations like identifying JavaScript files and parsing syntax elements such as strings and comments. Concrete use cases include building code analysis tools, linters, and syntax highlighters that require precise JavaScript language handling.",
      "description_length": 376,
      "index": 496,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Alpha.Ruby",
      "library": "comby-kernel",
      "description": "This module provides functions to find all or the first occurrence of a Ruby code template within a source string, supporting recursive matching on nested structures. It operates on Ruby-specific syntax trees and returns detailed match information for transformations. Use cases include code refactoring, pattern-based search, and automated code generation in Ruby projects.",
      "description_length": 374,
      "index": 497,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Alpha.Dart",
      "library": "comby-kernel",
      "description": "This module implements Dart language-specific pattern matching over source code using templates. It provides operations to find all matches or the first match of a template in a source string, supporting recursive matching when enabled. The module works with string-based templates and source code, returning structured match results with associated metadata.",
      "description_length": 359,
      "index": 498,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Alpha.Paren",
      "library": "comby-kernel",
      "description": "This module implements parenthetical structure matching for source code analysis. It provides functions to find all or first occurrences of template patterns in source code, supporting recursive matching and position-based search offsets. The module works with string-based templates and source code inputs, returning structured match results with language-specific naming and file extension metadata.",
      "description_length": 401,
      "index": 499,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Jsx",
      "library": "comby-kernel",
      "description": "This module provides precise definitions for JSX language metadata and syntax elements. It includes configurations for delimiters, string literals, comments, and file extensions. Concrete use cases include building JSX-aware code transformation tools and custom parsers that require accurate syntax matching.",
      "description_length": 308,
      "index": 500,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Omega.R",
      "library": "comby-kernel",
      "description": "This module provides functions to find all or the first match of a template in a source string, supporting recursive matching when enabled. It works with strings as input and returns structured match results, along with metadata like language name and file extensions. It is used to implement language-specific pattern matching for code transformation tools, operating directly on source code content.",
      "description_length": 401,
      "index": 501,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Omega.Erlang",
      "library": "comby-kernel",
      "description": "This module provides functions to match Erlang code against templates, returning all matches or the first match with optional starting position. It operates on strings representing source code and templates, producing lists of match results or individual match outcomes. Use cases include finding specific function calls, variable patterns, or structural elements in Erlang source files.",
      "description_length": 387,
      "index": 502,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Omega.JSON",
      "library": "comby-kernel",
      "description": "This module provides functions to match JSON templates against source strings, returning all or the first match with optional configuration and file context. It works with JSON structures and strings, supporting nested matching and position-based searching. Use cases include parsing and transforming JSON data, extracting specific patterns from JSON sources, and analyzing JSON content with structured queries.",
      "description_length": 411,
      "index": 503,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Omega.Generic",
      "library": "comby-kernel",
      "description": "This module provides functions to find all or first matches of a template in a source string, supporting nested matching and language-specific configurations. It works with strings as input and returns structured match results, using optional configuration parameters and file context. Use cases include pattern-based code analysis and transformation within specific programming language files, leveraging the matcher's knowledge of language syntax and structure.",
      "description_length": 463,
      "index": 504,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Lisp",
      "library": "comby-kernel",
      "description": "This module provides direct access to Lisp language metadata such as name and file extensions, and defines syntax elements like string delimiters, escape sequences, and comment styles. It works with string and list data types to support parsing and pattern matching in Lisp-like languages. Concrete use cases include configuring code analysis tools to correctly interpret Lisp syntax and handling Lisp source files based on their extensions.",
      "description_length": 441,
      "index": 505,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Metasyntax.Default",
      "library": "comby-kernel",
      "description": "This module defines the default metasyntax configuration for parsing and matching code patterns. It provides a list of hole syntax definitions, an identifier string, and a list of aliases used to represent placeholders and special constructs in pattern matching. Concrete use cases include configuring parsers to recognize variables, expressions, or custom placeholders in code transformation tools.",
      "description_length": 399,
      "index": 506,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Omega.Tsx",
      "library": "comby-kernel",
      "description": "This module provides functions to find all or first matches of a template in a source string, supporting recursive matching and optional configuration. It works with strings as input and returns lists of matches or individual match results, along with metadata like name and file extensions. It is used for pattern matching in source code, particularly for languages with TSX-like syntax.",
      "description_length": 388,
      "index": 507,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Omega.HCL",
      "library": "comby-kernel",
      "description": "This module provides functions to match HCL (HashiCorp Configuration Language) code against templates, supporting both full and first-match scanning with configurable parameters. It operates on string-based HCL source code and templates, returning structured match results with optional recursive matching. Use cases include static analysis, code transformation, and configuration validation for HCL files like Terraform or Packer templates.",
      "description_length": 441,
      "index": 508,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Omega.JSONC",
      "library": "comby-kernel",
      "description": "This module provides functions to match JSONC templates against source code, supporting both full and first-match searches with optional configuration and file context. It operates on strings for template and source input, returning structured match results or errors. Use cases include finding specific JSONC patterns in configuration files or code, such as identifying and extracting structured data elements within JSONC-formatted content.",
      "description_length": 442,
      "index": 509,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Alpha.Swift",
      "library": "comby-kernel",
      "description": "This module provides functions to find all or first matches of a template in Swift source code, supporting recursive matching through a configuration flag. It operates on strings representing source code and templates, returning lists of match results or individual match outcomes. Use cases include searching for specific Swift code patterns in files or snippets, such as identifying function calls or syntax structures.",
      "description_length": 421,
      "index": 510,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Dhall",
      "library": "comby-kernel",
      "description": "This module provides access to Dhall language metadata and syntax definitions. It includes data types for handling Dhall's naming conventions, file extensions, string literals, and comment structures. Use it to integrate Dhall support into tools that require precise syntax parsing or file identification.",
      "description_length": 305,
      "index": 511,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Alpha.Assembly",
      "library": "comby-kernel",
      "description": "This module implements template-based matching for structured text, providing operations to find all or the first occurrence of a template in a source string. It works with strings as input and produces lists of match results containing detailed match information. The module supports recursive matching within matched content and allows specifying start positions for searches, making it suitable for language-specific pattern matching and transformation tasks.",
      "description_length": 462,
      "index": 512,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Omega.Scala",
      "library": "comby-kernel",
      "description": "This module provides functions to find all or first matches of a template in Scala source code, supporting recursive matching on nested structures. It operates on strings for both template and source input, returning lists of match results or individual match errors. Use cases include parsing and transforming Scala code by identifying specific syntactic patterns within files or code snippets.",
      "description_length": 395,
      "index": 513,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Omega.Rust",
      "library": "comby-kernel",
      "description": "This module provides functions to find all or first matches of a template in a source string, supporting nested matching and positional starting points. It works with strings as input and returns lists or individual match records. Use cases include parsing and transforming code by identifying specific syntactic patterns in source files.",
      "description_length": 338,
      "index": 514,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Omega.Elm",
      "library": "comby-kernel",
      "description": "This module provides functions to find all or the first matches of a template in a source string, supporting nested matching and language-specific configurations. It works with strings as input sources and templates, returning lists of matches or individual match results. Use cases include parsing and transforming code in specific languages by identifying structural patterns, such as finding function calls or variable declarations in Elm source files.",
      "description_length": 455,
      "index": 515,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Omega.Java",
      "library": "comby-kernel",
      "description": "This module provides functions to find all or the first structural matches of a template in Java source code, supporting recursive matching on nested content. It operates on strings representing the template and source code, returning lists or individual match results with optional configuration and file context. Use cases include code analysis and transformation tasks where precise syntactic matching is required, such as identifying specific method calls or code patterns in Java files.",
      "description_length": 491,
      "index": 516,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Omega.Php",
      "library": "comby-kernel",
      "description": "This module provides functions to find all or the first matches of a template in PHP source code, supporting recursive matching through a configuration flag. It operates on strings representing the template and source code, returning lists of match results or individual match results with error handling. Use cases include searching for specific code patterns in PHP files, such as identifying function calls or code structures, while ignoring irrelevant or nested content based on configuration.",
      "description_length": 497,
      "index": 517,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Language.Info",
      "library": "comby-kernel",
      "description": "This module defines operations for retrieving language-specific matching behaviors and syntax properties, such as identifier delimiters and comment styles. It works with abstract syntax trees and string-based pattern matching rules. Concrete use cases include configuring parsers and matchers for language-specific code transformations and analysis.",
      "description_length": 349,
      "index": 518,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Omega.SQL",
      "library": "comby-kernel",
      "description": "This module provides functions to match SQL templates against source code, returning all matches or the first match starting at a specified position. It works with strings as input templates and sources, and returns structured match results with optional configuration and file context. It supports use cases like finding specific SQL query patterns in database code or identifying structural elements in SQL scripts.",
      "description_length": 417,
      "index": 519,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.GraphQL",
      "library": "comby-kernel",
      "description": "This module provides metadata and syntax definitions for working with GraphQL code. It includes identifiers for recognizing GraphQL files and specifies parsing rules for handling strings, comments, and literals. It is used to build tools like linters, formatters, and refactoring utilities that require accurate GraphQL syntax interpretation.",
      "description_length": 342,
      "index": 520,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Alpha.Python",
      "library": "comby-kernel",
      "description": "This module provides functions to find all or first matches of a template in Python source code, supporting recursive matching on nested structures. It operates on strings for both template and source code, returning lists of matches or individual match results. Use cases include searching for specific code patterns in Python files, such as identifying function calls or variable assignments.",
      "description_length": 394,
      "index": 521,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Alpha.Kotlin",
      "library": "comby-kernel",
      "description": "This module provides functions to find all or the first occurrences of a template in Kotlin source code, returning detailed match information. It operates on strings representing source code and templates, with options to control matching behavior like recursion and starting position. Use cases include code analysis and transformation tasks specific to Kotlin, such as identifying specific function calls or code patterns in Kotlin files.",
      "description_length": 440,
      "index": 522,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Alpha.Generic",
      "library": "comby-kernel",
      "description": "This module provides functions to find all or first matches of a template in a source string, supporting recursive matching on nested content. It works with strings as input and returns lists of match results or individual match results with error handling. Use cases include pattern matching in source code files for languages like C or Go, where specific templates are matched against code content to identify structural patterns.",
      "description_length": 432,
      "index": 523,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Alpha.Dyck",
      "library": "comby-kernel",
      "description": "This module implements Dyck language matching for structured text analysis, providing `all` and `first` functions to locate template matches in source code with optional nested matching and positional control. It operates on string-based templates and sources, returning structured match results tied to the language's syntax rules. Use cases include parsing nested expressions in domain-specific languages or identifying structured patterns in codebases with precise positional tracking.",
      "description_length": 488,
      "index": 524,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Alpha.Zig",
      "library": "comby-kernel",
      "description": "This module implements a matcher for the Zig programming language, providing functions to find all or the first occurrence of a template in a source string. It works with string inputs representing code templates and source code, returning structured match results with optional configuration and file context. Use cases include pattern-based code analysis and transformation within Zig files, leveraging language-specific parsing rules.",
      "description_length": 437,
      "index": 525,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Go",
      "library": "comby-kernel",
      "description": "This module provides direct access to Go language metadata and syntax configurations. It includes the language name, file extensions, and syntactic elements like string delimiters and comment markers. Used for accurately parsing and processing Go source files in code analysis or transformation tools.",
      "description_length": 301,
      "index": 526,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Erlang",
      "library": "comby-kernel",
      "description": "This module provides metadata and syntax configurations for working with Erlang code. It includes the language name, file extensions, delimiters, string literals, and comment styles specific to Erlang. It supports accurate parsing, pattern matching, and transformation of Erlang source files based on the language's syntactic rules.",
      "description_length": 332,
      "index": 527,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Alpha.Text",
      "library": "comby-kernel",
      "description": "This module implements text-based pattern matching for source code using a customizable template language. It provides functions to find all matches or the first match of a template in a given source string, supporting recursive matching when enabled. The module works with file paths, string templates, and source code inputs, and identifies matches with structured results containing positions and substitutions. It is used for code transformation tasks where specific syntactic patterns need to be located and rewritten in supported programming languages.",
      "description_length": 558,
      "index": 528,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Alpha.Reason",
      "library": "comby-kernel",
      "description": "This module implements template-based matching for ReasonML code, providing functions to find all or the first match of a template within a source string. It operates on strings representing ReasonML syntax, using configuration options to control matching behavior and returning structured match results. Use cases include automated code transformation and static analysis tasks specific to ReasonML files.",
      "description_length": 406,
      "index": 529,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Alpha.Go",
      "library": "comby-kernel",
      "description": "This module implements template-based matching for Go code, providing functions to find all or the first match of a template within a source string. It operates on strings representing Go code and templates, returning structured match results with support for nested matching. Use cases include code analysis and transformation tasks where precise syntactic matching is required.",
      "description_length": 379,
      "index": 530,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Omega.OCaml",
      "library": "comby-kernel",
      "description": "This module provides functions to find all or first matches of a template in OCaml source code, returning structured match results. It works with strings for template and source input, and supports configuration, file context, and positional shifting for precise matching. Use cases include code analysis, transformation, and querying specific OCaml code patterns.",
      "description_length": 364,
      "index": 531,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Rust",
      "library": "comby-kernel",
      "description": "This module provides concrete metadata and syntax configurations for working with Rust source code. It includes file extensions like `.rs`, delimiters, string literals, and comment styles specific to Rust. It is used in code analysis, refactoring, and transformation tools that require precise handling of Rust syntax.",
      "description_length": 318,
      "index": 532,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.CSS",
      "library": "comby-kernel",
      "description": "This module provides values for identifying CSS files by name and extension, and defines syntax rules for parsing CSS elements like strings, comments, and delimiters. It works with string pairs and syntax variants to handle CSS-specific literals and comments. Use it to configure code analysis or transformation tools to correctly process CSS syntax and file types.",
      "description_length": 365,
      "index": 533,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Alpha.Elm",
      "library": "comby-kernel",
      "description": "This module implements template-based matching for Elm source code, providing functions to find all matches or the first match of a template within a source string. It operates on strings representing code templates and source files, returning structured match results with optional recursive matching. Use cases include code analysis and transformation tasks where specific Elm code patterns need to be identified, such as refactoring tools or static analysis linters.",
      "description_length": 469,
      "index": 534,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Coq",
      "library": "comby-kernel",
      "description": "This module provides metadata and syntax definitions for the Coq language, including its name, file extensions, string literals, and comment styles. It supports operations for language detection, parsing, and pattern matching on Coq source files. Concrete use cases include building Coq-specific analysis tools, refactoring utilities, and automated term rewriting systems.",
      "description_length": 372,
      "index": 535,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Alpha.Pascal",
      "library": "comby-kernel",
      "description": "This module implements template-based matching for Pascal language code, providing functions to find all or the first match of a template within a source string. It operates on strings representing Pascal code and templates, returning structured match results with support for nested matching. Use cases include code analysis and transformation tasks where specific Pascal syntax patterns need to be identified, such as refactoring or static analysis tools.",
      "description_length": 457,
      "index": 536,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Omega.Javascript",
      "library": "comby-kernel",
      "description": "This module provides functions to match JavaScript code patterns using templates, supporting both full and first-match scans with configurable parameters. It operates on JavaScript source code strings and returns structured match results with positional and contextual details. Use cases include static code analysis, automated refactoring, and code search within JavaScript files.",
      "description_length": 381,
      "index": 537,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Paren",
      "library": "comby-kernel",
      "description": "This module implements matching logic for parenthetical language structures, handling balanced delimiters, nested expressions, and syntax-specific parsing rules. It works with abstract syntax trees, string patterns, and positional markers to enable precise code transformation and analysis. Concrete use cases include automated refactoring tools and structural code search for languages like Lisp or OCaml.",
      "description_length": 406,
      "index": 538,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Alpha.Make",
      "library": "comby-kernel",
      "description": "Implements template-based matching for structured text using customizable rules and configurations. Operates on strings as input sources and templates, returning lists of matches or individual match results. Useful for parsing and transforming code or structured data files like JSON or XML.",
      "description_length": 291,
      "index": 539,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Alpha.Dhall",
      "library": "comby-kernel",
      "description": "This module provides functions to find all or the first matches of a template in Dhall source code, supporting recursive matching through a configuration flag. It operates on strings for both template and source input, returning lists of match results or individual match results with error handling. Use cases include parsing and transforming Dhall configurations based on structural patterns.",
      "description_length": 394,
      "index": 540,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Swift",
      "library": "comby-kernel",
      "description": "This module provides concrete metadata and syntax configurations for the Swift programming language. It includes file extensions, string delimiters, comment styles, and escaping rules tailored to Swift. These definitions support pattern matching and code processing tasks specific to Swift source files.",
      "description_length": 303,
      "index": 541,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Omega.Zig",
      "library": "comby-kernel",
      "description": "This module provides functions to find all or the first matches of a template within a source string, supporting recursive matching when enabled. It works with strings as input and returns lists of match results or individual match results with error handling. The module also identifies the language name and associated file extensions for filtering purposes.",
      "description_length": 360,
      "index": 542,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Alpha.Elixir",
      "library": "comby-kernel",
      "description": "This module provides functions to find all or first matches of a template in Elixir source code, supporting recursive matching on nested content. It operates on strings for both template and source input, returning lists of match results or individual match errors. Use cases include pattern-based code analysis and transformation tasks specific to Elixir files.",
      "description_length": 362,
      "index": 543,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Alpha.R",
      "library": "comby-kernel",
      "description": "This module implements template-based matching for source code analysis, providing operations to find all or the first occurrence of a template in a source string. It works with string inputs representing code templates and source code, returning structured match results that include positions and captured variables. It is used to implement language-specific pattern matching for code transformation tools, supporting recursive matching and language-specific extensions.",
      "description_length": 472,
      "index": 544,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Nim",
      "library": "comby-kernel",
      "description": "This module provides metadata and syntax configurations specific to the Nim programming language. It includes file extensions and canonical name for language identification, and defines delimiters, string literals, and comment styles for accurate parsing and pattern matching. Concrete use cases include determining Nim source files by extension and configuring matchers for Nim's unique syntax features.",
      "description_length": 404,
      "index": 545,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Solidity",
      "library": "comby-kernel",
      "description": "This module provides direct access to Solidity language metadata and syntax configurations. It includes the language name, file extensions, delimiters, string literals, and comment styles used in Solidity. Concrete use cases include identifying Solidity files by extension and configuring parsers for pattern matching and code transformation tasks.",
      "description_length": 348,
      "index": 546,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Alpha.Php",
      "library": "comby-kernel",
      "description": "This module provides functions to find all or the first occurrence of a template in PHP source code, returning detailed match information. It operates on strings representing the template and source code, with options to control matching behavior like recursion and starting position. Use cases include code analysis and transformation tasks specific to PHP, such as identifying function calls or code patterns in PHP files.",
      "description_length": 424,
      "index": 547,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Alpha.Move",
      "library": "comby-kernel",
      "description": "This module provides functions to find all or first matches of a template in a source string, supporting nested matching and language-specific configurations. It operates on strings and returns structured match results, with support for specifying file extensions and language names. Use cases include pattern-based code analysis and transformation tasks where precise template matching is required.",
      "description_length": 399,
      "index": 548,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Alpha.SQL",
      "library": "comby-kernel",
      "description": "This module implements SQL-specific pattern matching operations for finding and extracting structured elements in SQL code. It provides functions to find all matches or the first occurrence of a template within a source string, supporting recursive matching when enabled. The module works directly with SQL syntax trees and string-based templates, enabling precise code analysis tasks such as query transformation or schema validation.",
      "description_length": 435,
      "index": 549,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.JSON",
      "library": "comby-kernel",
      "description": "This module provides functions to identify JSON file types using extensions and defines syntax rules for parsing JSON content, including delimiters and string literals. It works with string-based JSON structures to enable precise pattern matching and analysis. Concrete use cases include file type detection in JSON processing tools and extracting or modifying specific JSON elements during code transformation workflows.",
      "description_length": 421,
      "index": 550,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Alpha.Csharp",
      "library": "comby-kernel",
      "description": "This module implements C#-specific pattern matching operations for code transformation tasks. It provides functions to find all or the first occurrence of a code template within a source string, supporting recursive matching on nested structures. The module works with string-based code inputs and outputs match results with positional information, suitable for tasks like automated code refactoring or static analysis in C# projects.",
      "description_length": 434,
      "index": 551,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Omega.Lisp",
      "library": "comby-kernel",
      "description": "This module implements template-based matching for Lisp code, providing functions to find all or the first match of a template within a source string. It operates on Lisp syntax trees and supports recursive matching when enabled. Use cases include code transformation and analysis tasks specific to Lisp, such as identifying function definitions or rewriting macro invocations.",
      "description_length": 377,
      "index": 552,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Omega.Assembly",
      "library": "comby-kernel",
      "description": "This module implements template-based matching for structured text, providing operations to find all or the first match of a template within a source string. It works with string inputs and produces lists of match results that capture matched regions and variable bindings. It is used to perform pattern matching in source code or structured data, with support for recursive matching and language-specific configurations.",
      "description_length": 421,
      "index": 553,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Omega.Reason",
      "library": "comby-kernel",
      "description": "This module implements template-based matching for structured text, providing operations to find all matches or the first match of a template within a source string. It works with string inputs representing code or structured data, returning match results with contextual information. It is used to identify syntactic patterns in source code, such as function calls or variable declarations, for transformation or analysis tasks.",
      "description_length": 429,
      "index": 554,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Omega.Nim",
      "library": "comby-kernel",
      "description": "This module provides functions to find all or the first structural matches of a template within a source string, supporting recursive matching on nested content. It operates on strings as input and returns lists of match results or individual match results with error handling. Use cases include parsing and transforming code in specific languages by identifying syntactic patterns, such as finding all function calls or specific expressions in a codebase.",
      "description_length": 456,
      "index": 555,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Latex",
      "library": "comby-kernel",
      "description": "This module provides data structures and syntax definitions specific to LaTeX, including file extensions, macro delimiters, literals, and comments. It works with strings and lists to define patterns for parsing and matching LaTeX content. Concrete use cases include configuring tools to recognize LaTeX files by extension, parsing macros with custom syntax, and handling verbatim or escaped text regions in LaTeX documents.",
      "description_length": 423,
      "index": 556,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Julia",
      "library": "comby-kernel",
      "description": "This module provides direct access to the Julia language name and its file extensions for identification purposes. It also defines syntax-specific configurations for parsing and matching Julia code, including string delimiters, escape handling, and comment styles. These features support tools like linters, formatters, and refactoring utilities in accurately analyzing and transforming Julia source files.",
      "description_length": 406,
      "index": 557,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Alpha.Typescript",
      "library": "comby-kernel",
      "description": "This module implements TypeScript-specific pattern matching operations for source code analysis, supporting structured queries over syntax trees. It provides functions to find all or the first match of a template in a source string, with configurable matching behavior and file context. The module works with string-based templates and source code, returning structured match results with support for nested matching, making it suitable for tasks like code transformation and static analysis in TypeScript projects.",
      "description_length": 515,
      "index": 558,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Omega.Pascal",
      "library": "comby-kernel",
      "description": "This module provides functions to find all or the first structural matches of a template in Pascal source code, supporting recursive matching on nested structures. It operates on strings representing source code and templates, returning lists of match results or individual match errors. Use cases include code analysis and transformation tasks specific to Pascal, such as identifying specific function calls or syntax patterns in Pascal files.",
      "description_length": 444,
      "index": 559,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Omega.C",
      "library": "comby-kernel",
      "description": "This module provides functions to match templates against C source code, returning all matches or the first match with optional starting position. It operates on strings representing source code and templates, and returns structured match results. It is used for analyzing or transforming C code by identifying specific syntactic patterns.",
      "description_length": 339,
      "index": 560,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Dyck",
      "library": "comby-kernel",
      "description": "This module provides operations to define and work with the Dyck language's metadata and syntax constructs. It handles data types representing delimiters, string literals, and comments, along with file extension mappings. Concrete use cases include parsing nested expressions, quoted strings, and comment blocks in Dyck language files.",
      "description_length": 335,
      "index": 561,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Zig",
      "library": "comby-kernel",
      "description": "This module provides precise definitions for Zig language metadata and syntactic elements. It includes the canonical language name, file extensions, delimiters, string literals, and comment structures. Used for building tools that analyze or transform Zig code, such as linters, refactoring utilities, or syntax-aware parsers.",
      "description_length": 326,
      "index": 562,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Omega.Go",
      "library": "comby-kernel",
      "description": "This module provides functions to find all or first matches of a template in Go source code, supporting recursive matching through a configuration flag. It operates on strings for both template and source input, returning lists of matches or individual match results with error handling. Use cases include searching for specific Go code patterns in files or snippets, leveraging the language-specific matcher for accurate syntax parsing.",
      "description_length": 437,
      "index": 563,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Omega.Clojure",
      "library": "comby-kernel",
      "description": "This module provides functions to find all or the first structural matches of a template in Clojure source code, supporting recursive matching on nested structures. It operates on strings representing source code and templates, returning lists of match results or individual match errors. Use cases include code analysis and transformation tasks specific to Clojure, such as identifying function calls or syntactic patterns in source files.",
      "description_length": 440,
      "index": 564,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Omega.Coq",
      "library": "comby-kernel",
      "description": "This module provides functions to find all or first matches of a template in a source string, supporting nested matching and optional configuration. It works with strings as input and returns structured match results, along with metadata like supported file extensions and language name. It is used for pattern matching in source code transformation tools, where precise matching against structured templates is required.",
      "description_length": 421,
      "index": 565,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Omega.Elixir",
      "library": "comby-kernel",
      "description": "This module provides functions to find all or first matches of a template in Elixir source code, supporting recursive matching on nested structures. It operates on strings for both template and source input, returning lists of match results or individual match errors. Use cases include searching for specific code patterns in Elixir files, such as identifying function calls or syntax structures within a given source.",
      "description_length": 419,
      "index": 566,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Generic",
      "library": "comby-kernel",
      "description": "This module provides metadata and syntax configurations for handling generic programming languages. It defines language properties like file extensions and syntax elements such as string delimiters, escape sequences, and comment markers. It is used to support parsing and pattern matching across diverse or custom languages in code analysis tools.",
      "description_length": 347,
      "index": 567,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Omega.Html",
      "library": "comby-kernel",
      "description": "This module provides functions to match HTML templates against source code, returning all or the first match with optional configuration and file context. It operates on strings representing HTML templates and source content, producing lists of matches or individual match results. Use cases include extracting or transforming specific HTML structures, such as identifying script tags or rewriting anchor elements in web documents.",
      "description_length": 431,
      "index": 568,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Alpha.GraphQL",
      "library": "comby-kernel",
      "description": "This module implements a GraphQL-aware matcher for finding and extracting structured patterns in source code. It provides operations to find all matches or the first match of a template within a source string, supporting recursive matching when enabled. The matcher works with GraphQL documents and schemas, handling their specific syntax and structure.",
      "description_length": 353,
      "index": 569,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Omega.CSS",
      "library": "comby-kernel",
      "description": "This module provides functions to match CSS templates against source code, returning all matches or the first match starting at a specified position. It works with strings as input templates and sources, and returns structured match results with optional configuration and file context. Use cases include finding CSS rule patterns in stylesheets, such as locating all class selectors or specific property-value pairs within a CSS file.",
      "description_length": 435,
      "index": 570,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Omega.Bash",
      "library": "comby-kernel",
      "description": "This module provides functions to match templates against Bash source code, returning all matches or the first match starting at a specified position. It works with strings as input source and template, and returns structured match results with optional configuration and file context. Use it to find specific Bash code patterns in scripts, such as identifying function definitions or command sequences.",
      "description_length": 403,
      "index": 571,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Omega.Csharp",
      "library": "comby-kernel",
      "description": "This module implements C#-specific pattern matching over source code using customizable templates. It supports finding all matches or the first match of a template in a given source string, with optional recursive matching on nested structures. Typical use cases include code analysis, refactoring, and transformation tasks tailored to C# syntax.",
      "description_length": 346,
      "index": 572,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Alpha.Solidity",
      "library": "comby-kernel",
      "description": "This module provides functions to find all or the first occurrence of a template in Solidity source code, returning detailed match information. It works with strings for both template and source code inputs, supporting recursive matching through a configuration flag. The module identifies itself with a name and lists associated file extensions, specifically tailored for Solidity.",
      "description_length": 382,
      "index": 573,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Fsharp",
      "library": "comby-kernel",
      "description": "This module provides metadata and syntax definitions for the F# programming language. It includes the language name, file extensions, string delimiters, comment patterns, and literal handling specific to F#. Use cases include parsing F# source files, identifying code elements, and processing string and comment structures in F# code.",
      "description_length": 334,
      "index": 574,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Omega.Dhall",
      "library": "comby-kernel",
      "description": "This module provides functions to match templates within source code written in the Dhall configuration language. It supports finding all matches recursively or the first match starting at a specific position, along with metadata like the language name and file extensions. Use cases include searching for specific Dhall expressions in configuration files or analyzing Dhall codebases for structural patterns.",
      "description_length": 409,
      "index": 575,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Scala",
      "library": "comby-kernel",
      "description": "This module provides direct access to the language name and file extensions for Scala, along with syntax-specific configurations such as string delimiters, comment types, and raw string formats. It supports precise parsing and pattern matching tailored to Scala code. Concrete use cases include identifying Scala files and implementing Scala-specific code analysis or transformation tools.",
      "description_length": 389,
      "index": 576,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Omega.Haskell",
      "library": "comby-kernel",
      "description": "This module provides functions to find all or first matches of a template in a source string, supporting recursive matching when enabled. It works with strings as input and returns structured match results, along with metadata like language name and file extensions. It is used to implement template-based code matching for specific programming languages.",
      "description_length": 355,
      "index": 577,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Omega.Fortran",
      "library": "comby-kernel",
      "description": "This module provides functions to match Fortran code against templates, supporting both full and first-match searches with configurable parameters. It operates on Fortran source code strings and returns structured match results, supporting use cases like code analysis and transformation. It identifies itself with a name and associated file extensions for integration with tooling.",
      "description_length": 382,
      "index": 578,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Alpha.Nim",
      "library": "comby-kernel",
      "description": "This module provides functions to find all or first matches of a template in a source string, supporting nested matching and positional starting points. It works with strings as input and returns lists of matches or individual match results. Use cases include parsing and transforming code in languages like Nim by identifying specific syntactic patterns in source text.",
      "description_length": 370,
      "index": 579,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Omega.Ruby",
      "library": "comby-kernel",
      "description": "This module provides functions to find all or first matches of a template in Ruby source code, supporting recursive matching on nested structures. It operates on strings for both template and source input, returning lists or individual match results. Use cases include searching for specific Ruby code patterns in files or snippets, such as identifying method calls or syntactic constructs.",
      "description_length": 390,
      "index": 580,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Php",
      "library": "comby-kernel",
      "description": "This module provides precise syntactic and metadata definitions for PHP, including language identifiers, file extensions, string delimiters, and comment styles. It supports operations like recognizing PHP file types, parsing string literals, and handling heredoc and comment syntax. Concrete use cases include code analysis tools that need to accurately identify and process PHP-specific syntax elements.",
      "description_length": 404,
      "index": 581,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Omega.Dart",
      "library": "comby-kernel",
      "description": "This module provides functions to find all or the first matches of a template within a source string, supporting recursive matching when enabled. It works with strings as input and returns structured match results, using optional configuration parameters and positional shifts. The module identifies the language it operates on through its name and associated file extensions, enabling targeted pattern matching for specific language constructs.",
      "description_length": 445,
      "index": 582,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.SQL",
      "library": "comby-kernel",
      "description": "This module provides operations for identifying SQL files through extensions and language name metadata, and defines syntax configurations for parsing SQL code, including string literals, delimiters, and comments. It works with string and list data types to represent file extensions, syntax elements, and configuration parameters. Concrete use cases include configuring code analysis tools to recognize SQL files and enabling accurate pattern matching for SQL query transformations.",
      "description_length": 483,
      "index": 583,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Matlab",
      "library": "comby-kernel",
      "description": "This module provides metadata and syntax definitions for MATLAB, including file extensions and language name in the `Info` module, and syntactic constructs like delimiters, string literals, and comments in the `Syntax` module. It supports code analysis and transformation tasks by enabling accurate recognition and handling of MATLAB-specific syntax. Use it to configure file-based language detection and to define parsing rules for MATLAB code in matching and rewriting operations.",
      "description_length": 482,
      "index": 584,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Move",
      "library": "comby-kernel",
      "description": "This module provides direct access to metadata about the Move programming language, including its name and supported file extensions. It also defines syntax configurations such as delimiters, string literals, and comment kinds for accurate parsing and pattern matching. These components enable language-specific code processing, analysis, and transformation for Move source files.",
      "description_length": 380,
      "index": 585,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Alpha.JSON",
      "library": "comby-kernel",
      "description": "This module provides functions to match JSON templates against source strings, returning all matches or the first match starting at a specified position. It works with strings as input templates and sources, and returns structured match results. It is used for parsing and transforming JSON content based on pattern templates.",
      "description_length": 326,
      "index": 586,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.JSONC",
      "library": "comby-kernel",
      "description": "This module provides operations for identifying JSONC file extensions and defining syntax rules for parsing JSONC, including support for comments, custom delimiters, and string escaping. It works with string literals, comment markers, and file extension lists. Use it to build tools that process JSONC files, such as linters, formatters, or custom parsers that require handling comments and non-standard syntax.",
      "description_length": 411,
      "index": 587,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Alpha.OCaml",
      "library": "comby-kernel",
      "description": "This module provides functions to find all or the first matches of a template in OCaml source code, supporting recursive matching when enabled. It works with strings for template and source input, returning lists or individual match records. Use cases include searching for code patterns in OCaml files, such as identifying function calls or syntax structures within a given source string.",
      "description_length": 389,
      "index": 588,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Text",
      "library": "comby-kernel",
      "description": "This module provides operations for defining and working with text-based language metadata and syntax configurations. It handles data types such as strings and lists to manage language identifiers, file extensions, delimiters, and comment styles. Concrete use cases include configuring parsers for domain-specific languages and determining language type based on file extension or syntax rules.",
      "description_length": 394,
      "index": 589,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.C",
      "library": "comby-kernel",
      "description": "This module provides precise definitions for identifying C language files through extensions and configuring syntax-aware parsing rules. It includes direct access to C's language identifier, file extensions, delimiters, string literals, and comment formats. Use cases include setting up source code analyzers to correctly parse C files and enabling pattern matching tailored to C syntax.",
      "description_length": 387,
      "index": 590,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Omega.Python",
      "library": "comby-kernel",
      "description": "This module provides functions to find all or the first structural matches of a Python code template within a source string, supporting recursive matching through a configuration flag. It operates on string inputs representing Python code and returns lists of match results or individual match outcomes with error handling. Use cases include code analysis and transformation tasks where precise syntactic matching is required, such as detecting specific function calls or code patterns in Python files.",
      "description_length": 502,
      "index": 591,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Alpha.CSS",
      "library": "comby-kernel",
      "description": "This module provides functions to match CSS templates against source code, returning all matches or the first match at a specified position. It works with strings as input templates and sources, and returns structured match results with optional configuration and file context. It is used for parsing and analyzing CSS code, identifying specific patterns or structures within CSS files.",
      "description_length": 386,
      "index": 592,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Elm",
      "library": "comby-kernel",
      "description": "This module provides direct access to Elm language metadata and syntax configurations. It defines constants for file extensions like `.elm` and specifies syntax elements such as string delimiters, comment styles, and literal representations. These are used in code analysis and transformation tools to accurately parse, match, and process Elm source files.",
      "description_length": 356,
      "index": 593,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Alpha.Rust",
      "library": "comby-kernel",
      "description": "This module implements Rust-specific pattern matching over source code using customizable templates. It supports finding all matches or the first match of a template in a source string, with optional recursive matching on nested structures. Typical use cases include code analysis and transformation tasks, such as identifying function calls or rewriting specific syntax patterns in Rust files.",
      "description_length": 394,
      "index": 594,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Alpha.Coq",
      "library": "comby-kernel",
      "description": "This module implements template-based matching for Coq code, providing functions to find all matches or the first match of a template within a source string. It operates on Coq syntax trees, supporting recursive matching when enabled, and includes metadata like the language name and supported file extensions. It is used to perform structural searches in Coq files, enabling precise code analysis and transformation tasks.",
      "description_length": 423,
      "index": 595,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Omega.Kotlin",
      "library": "comby-kernel",
      "description": "This module provides functions to find all or the first structural matches of a Kotlin code template within a source string, supporting recursive matching on nested structures. It operates on strings representing Kotlin code and templates, returning lists of match results or individual match errors. Use cases include code analysis and transformation tasks specific to Kotlin, such as identifying specific function patterns or code constructs in Kotlin files.",
      "description_length": 460,
      "index": 596,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Typescript",
      "library": "comby-kernel",
      "description": "This module provides metadata and syntax configurations for TypeScript, including language identifiers, file extensions, delimiters, string literals, and comment styles. It supports precise parsing and pattern matching of TypeScript source files. Concrete use cases include code analysis tools and linters that need to accurately recognize and process TypeScript syntax and file structures.",
      "description_length": 390,
      "index": 597,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Rule",
      "library": "comby-kernel",
      "description": "This module defines match rules using abstract syntax expressions and provides operations to create, apply, and evaluate them. It supports rule application with customizable matching behavior, substitution, and environment handling. Use cases include defining and executing structured code transformations based on pattern matching.",
      "description_length": 332,
      "index": 598,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Match.Location",
      "library": "comby-kernel",
      "description": "This module defines a data structure for representing positions in text with offset, line, and column numbers. It includes functions for equality checking, serialization to and from S-expressions and JSON, and a default value for initializing locations. It is used to track and manipulate positions within source code during parsing or transformation tasks.",
      "description_length": 357,
      "index": 599,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages",
      "library": "comby-kernel",
      "description": "This module defines language-specific syntax elements\u2014such as delimiters, comment markers, and file extensions\u2014for a broad spectrum of programming and markup languages. It operates on string and list data structures to enable precise parsing, pattern matching, and code transformation in tools like linters, formatters, and analyzers. Utility functions for selecting languages by file extension or enumerating supported variants further support use cases such as language detection and automated code processing.",
      "description_length": 512,
      "index": 600,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Language",
      "library": "comby-kernel",
      "description": "This module defines language-specific syntax elements and matching behaviors for precise code pattern recognition. It includes data types for string literals, delimiters, comments, and identifier rules, along with functions to configure and retrieve these properties for languages like C or Go. Use it to set up custom syntax configurations for code analysis, transformation, and templating tasks.",
      "description_length": 397,
      "index": 601,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Template",
      "library": "comby-kernel",
      "description": "This module defines data structures and serialization functions for representing and manipulating template atoms in a pattern-matching context. It works with variants like `Hole` and `Constant`, and supports operations for parsing and generating s-expressions. Concrete use cases include handling placeholders with metadata such as variable names, offsets, and transformation kinds during template instantiation or analysis.",
      "description_length": 424,
      "index": 602,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Specification",
      "library": "comby-kernel",
      "description": "This module defines a specification for matching and rewriting code patterns using templates and optional rules. It works with strings as match and rewrite templates, and rule types for applying transformations. A concrete use case is generating regular expressions from structured match templates to find or replace code elements during analysis or refactoring tasks.",
      "description_length": 368,
      "index": 603,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Omega",
      "library": "comby-kernel",
      "description": "This module provides structural pattern matching operations for source code and structured data formats, enabling the identification of template matches within strings. It supports recursive and nested matching across a range of languages and data formats (e.g., JSON, GraphQL, LaTeX, Dhall) and includes specialized matchers for handling syntactic constructs like parentheses, indentation, and Dyck languages. The operations are designed for tasks such as code analysis, refactoring, and transformation, returning structured results with positional details to enable precise manipulation of code or data elements.",
      "description_length": 614,
      "index": 604,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.External",
      "library": "comby-kernel",
      "description": "This module defines a customizable handler for external pattern matching operations, working with structured data like abstract syntax trees and string patterns. It allows defining matchers that return optional string results based on input such as names, file paths, line and column positions. Concrete use cases include integrating domain-specific matching logic for custom languages or extending pattern recognition in code analysis tools.",
      "description_length": 442,
      "index": 605,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Match.Environment",
      "library": "comby-kernel",
      "description": "This module manages environments for storing and manipulating metavariables during pattern matching. It supports operations to add, update, and look up metavariables along with their associated values and ranges, and provides equality checks, merging, and copying of environments. Use cases include tracking variable bindings during code transformation and extracting matched values with their source locations.",
      "description_length": 411,
      "index": 606,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Metasyntax",
      "library": "comby-kernel",
      "description": "This module defines metasyntax configurations for pattern matching, including hole syntax, identifiers, and aliases. It supports data types like `hole_syntax`, `hole_definition`, and `alias`, enabling precise control over placeholder recognition in code templates. Concrete use cases include customizing parsers to match variables, expressions, or structured code elements in tools for code transformation and analysis.",
      "description_length": 419,
      "index": 607,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Rewrite",
      "library": "comby-kernel",
      "description": "This module handles template-based code rewriting using match environments. It provides `all` to apply a rewrite template across multiple matches in a source string, producing modified results with optional in-place substitution, and `substitute` to replace variables in a template string using a single match environment. It operates on match lists and environments from the `Comby_kernel.Match` module, typically used for transforming code based on pattern matches.",
      "description_length": 467,
      "index": 608,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Matcher",
      "library": "comby-kernel",
      "description": "This module implements pattern matching operations over abstract syntax trees, providing functions to match and bind variables within structured code representations. It works with tree-like data structures that represent parsed code, such as terms or expressions, and supports operations like variable capture, subpattern matching, and match result accumulation. Concrete use cases include implementing custom syntax matchers for code transformation tools and static analysis systems.",
      "description_length": 485,
      "index": 609,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "Comby_kernel.Match.Range",
      "library": "comby-kernel",
      "description": "This module defines a range structure with start and end locations, used to represent matched regions in source code. It includes functions for equality checking, serialization to and from S-expressions and JSON, and a default value for initialization. Concrete use cases include tracking positions of matches in code transformation tools and persisting match ranges across different formats.",
      "description_length": 392,
      "index": 610,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Hole",
      "library": "comby-kernel",
      "description": "This module defines different kinds of holes with specific matching behaviors for parsing and pattern matching tasks. It includes variants like `Expression`, `Alphanum`, and `Regex`, which dictate how placeholders in a template are matched against input data. Concrete use cases include implementing templating engines, code transformation tools, and structured text parsers where precise placeholder matching is required.",
      "description_length": 422,
      "index": 611,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Ast",
      "library": "comby-kernel",
      "description": "This module defines an abstract syntax tree (AST) for representing matching and rewriting rules. It includes types for atoms (templates or strings), antecedents, and logical expressions such as equality checks, pattern matching, and rewrite operations. These structures are used to encode transformation rules that can be applied to code during parsing or analysis tasks.",
      "description_length": 371,
      "index": 612,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Engine",
      "library": "comby-kernel",
      "description": "This module implements a matching engine for structural code patterns using a customizable domain-specific language. It operates on abstract syntax trees and supports pattern matching with placeholders, constraints, and transformation rules. Concrete use cases include code refactoring, semantic code search, and automated code transformation across multiple programming languages.",
      "description_length": 381,
      "index": 613,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Configuration",
      "library": "comby-kernel",
      "description": "This module defines configuration parameters that adjust matching behavior, such as enabling substring matching, controlling whitespace significance, and handling newline characters. It works with the `t` type representing a configuration state and the `match_kind` type distinguishing between exact and fuzzy matching. Concrete use cases include customizing how pattern variables are substituted and controlling top-level matching of newlines in structured text.",
      "description_length": 463,
      "index": 614,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Replacement",
      "library": "comby-kernel",
      "description": "This module represents the outcome of a rewrite operation, capturing the range of text replaced, the new content, and the matching environment. It provides functions to convert replacement results to and from JSON formats, supporting serialization and structured output. Use cases include generating JSON diffs for code transformations and tracking substitutions made during source code rewriting.",
      "description_length": 397,
      "index": 615,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers",
      "library": "comby-kernel",
      "description": "This module implements structural pattern matching and code transformation capabilities, working with abstract syntax trees, templates, and metasyntax configurations. It provides functions to define and apply matching rules, handle placeholders with specific matching behaviors, and perform precise code rewriting based on match environments. Concrete use cases include semantic code search, automated refactoring, and language-agnostic code transformation with support for nested and structured data formats.",
      "description_length": 509,
      "index": 616,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Match",
      "library": "comby-kernel",
      "description": "This module represents and manipulates match results from pattern matching in source code. It provides data structures to capture matched text, associated ranges, and environments mapping metavariables to values with positions. Functions support match creation, location conversion, and formatted output for reporting matches in files.",
      "description_length": 335,
      "index": 617,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel",
      "library": "comby-kernel",
      "description": "This module provides precise structural pattern matching and rewriting capabilities for source code, working with abstract syntax trees, templates, and metasyntax configurations. It captures match results with detailed positional information and environments mapping metavariables to values, supporting operations like semantic code search and automated refactoring. The module also handles rewrite operations by generating structured replacements with JSON serialization, enabling use cases such as code transformation tracking and diff generation.",
      "description_length": 549,
      "index": 618,
      "embedding_norm": 0.9999999403953552
    }
  ],
  "filtering": {
    "total_modules_in_package": 623,
    "meaningful_modules": 619,
    "filtered_empty_modules": 4,
    "retention_rate": 0.9935794542536116
  },
  "statistics": {
    "max_description_length": 702,
    "min_description_length": 256,
    "avg_description_length": 380.1211631663974,
    "embedding_file_size_mb": 8.969407081604004
  }
}