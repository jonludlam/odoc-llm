{
  "package": "comby-kernel",
  "embedding_model": "Qwen/Qwen3-Embedding-0.6B",
  "embedding_dimension": 1024,
  "total_modules": 756,
  "creation_timestamp": "2025-07-16T00:38:48.880928",
  "modules": [
    {
      "module_path": "Parsers.Omega_string_literals.Escapable.Make",
      "library": "comby-kernel.parsers",
      "description": "This module implements parsers for handling escaped characters and string literals in a custom syntax, producing Vangstrom parsers for `char` and `string` values. It processes input using a tokenization strategy defined by the `M` module, which supplies character recognition logic. Concrete use cases include parsing string literals with escape sequences in domain-specific languages or configuration formats.",
      "description_length": 410,
      "index": 0,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Parsers.Alpha_comments.Until_newline.S",
      "library": "comby-kernel.parsers",
      "description": "This module parses single-line comments starting with a specified string and continuing until a newline. It works with string inputs and tracks comment boundaries to extract or skip commented regions. A typical use case involves preprocessing source code to remove or process line comments during lexical analysis.",
      "description_length": 314,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Parsers.Omega_string_literals.Escapable.S",
      "library": "comby-kernel.parsers",
      "description": "This module defines a fixed delimiter and escape character for parsing string literals. It works with string and character types to handle escaped sequences within input. Use this module when implementing parsers that require consistent handling of quoted strings with escape characters.",
      "description_length": 287,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Parsers.Alpha_string_literals.Escapable.Make",
      "library": "comby-kernel.parsers",
      "description": "This module parses string literals with escape sequences, handling single-character escapes and quoted strings where delimiters can be escaped. It works with character and string data types, using a parser state that tracks input positions and errors. Concrete use cases include parsing configuration files or domain-specific languages where strings may contain escaped quotes or special characters.",
      "description_length": 399,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Parsers.Alpha_comments.Multiline.Make",
      "library": "comby-kernel.parsers",
      "description": "This module implements a parser for non-nested block comments, such as C-style `/* ... */`, extracting the content between delimiters. It provides the `comment` function, which parses a single block comment and returns its content as a string. The parser operates on input streams tracked by the `MParser.state` type, integrating with monadic parser combinators for lexing and parsing textual data.",
      "description_length": 398,
      "index": 4,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Parsers.Omega_comments.Multiline.Make",
      "library": "comby-kernel.parsers",
      "description": "This module implements a parser for multiline comment syntax using the Vangstrom parser combinator library. It takes a module `M` defining start and end delimiters to parse comments of the form `/* ... */`, supporting nested or escaped sequences as specified by `M`. The result is a parser that can be integrated into custom language parsers for handling multiline comments in source code.",
      "description_length": 389,
      "index": 5,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Parsers.Alpha_string_literals.Raw.Make",
      "library": "comby-kernel.parsers",
      "description": "Implements parsers for raw string literals with customizable delimiters, handling both single-character and base string literals without escape sequences. Works directly with `MParse.state` and string inputs, producing parsed string values or replies. Useful for parsing domain-specific languages or custom string formats where delimiters like `\"` or `|` enclose literal text bodies without requiring escape handling.",
      "description_length": 417,
      "index": 6,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Parsers.Omega_comments.Until_newline.S",
      "library": "comby-kernel.parsers",
      "description": "This module defines a parser that matches text starting from a specified string until the end of the current line. It operates on string inputs and is designed for use in comment parsing scenarios where line-based termination is required. A concrete use case includes parsing single-line comments in configuration files or source code.",
      "description_length": 335,
      "index": 7,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Parsers.Omega_string_literals.Raw.S",
      "library": "comby-kernel.parsers",
      "description": "This module defines constants for delimiters used in parsing string literals. It provides `left_delimiter` and `right_delimiter` strings that mark the boundaries of embedded string content. Useful in lexers and parsers for identifying and extracting string literals within source code.",
      "description_length": 285,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Parsers.Alpha_comments.Nested_multiline.S",
      "library": "comby-kernel.parsers",
      "description": "This module defines string values for delimiters used to parse nested multiline comments in a specific format, typically used in parsing languages or domain-specific syntax. It provides `left` and `right` values representing the opening and closing markers of such comments. A common use case is configuring a parser to recognize and skip over nested comments during lexical analysis.",
      "description_length": 384,
      "index": 9,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Parsers.Omega_comments.Until_newline.Make",
      "library": "comby-kernel.parsers",
      "description": "This module implements a parser that reads and returns a string until a newline character is encountered, specifically for handling comments. It works with the `Vangstrom.t` parser type and operates on string input. A concrete use case is parsing single-line comments in a custom language or configuration file format.",
      "description_length": 318,
      "index": 10,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Parsers.Alpha_comments.Until_newline.Make",
      "library": "comby-kernel.parsers",
      "description": "This module implements a parser that reads and returns a string starting from the current position until the next newline character. It operates on input streams managed by the underlying `MParser` module, capturing comments that span until a newline is encountered. A typical use case is parsing single-line comments in configuration files or source code where the comment starts with a specific delimiter and ends at the line break.",
      "description_length": 434,
      "index": 11,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Parsers.Alpha_string_literals.Raw.S",
      "library": "comby-kernel.parsers",
      "description": "Handles parsing of raw string literals with customizable left and right delimiters. It supports string bodies without escape sequences, ensuring strict delimiter matching. Useful for parsing domain-specific languages or embedded scripting languages where raw string content must be extracted verbatim between specified delimiters.",
      "description_length": 330,
      "index": 12,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Parsers.Alpha_comments.Nested_multiline.Make",
      "library": "comby-kernel.parsers",
      "description": "This module implements a parser for nested multiline comments, handling start and end delimiters defined by the parameter module `M`. It processes input states and returns parsed comment content or parsing errors. Useful for implementing custom comment syntax in language parsers where nested comments are allowed.",
      "description_length": 314,
      "index": 13,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Parsers.Alpha_comments.Multiline.S",
      "library": "comby-kernel.parsers",
      "description": "Handles parsing of non-nested block comments using specified start and end delimiters. Processes input streams to identify and skip comment regions, supporting lexing workflows where comments must be ignored. Useful in compiler frontends or text processors that need to handle C-style or similar block comments.",
      "description_length": 311,
      "index": 14,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Parsers.Alpha_string_literals.Escapable.S",
      "library": "comby-kernel.parsers",
      "description": "Handles parsing of string literals with escapable characters and matching delimiters. Processes input to recognize escaped sequences and properly terminated strings, returning the parsed content and position. Useful for implementing custom string syntax in configuration files or domain-specific languages.",
      "description_length": 306,
      "index": 15,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Parsers.Omega_string_literals.Raw.Make",
      "library": "comby-kernel.parsers",
      "description": "This module implements parsers for string literals and character tokens using Vangstrom, specifically handling raw string representations. It works with `string Vangstrom.t` parsers and is designed for use in lexing and parsing contexts where string and character literals must be extracted directly from input. Concrete use cases include parsing source code in a compiler or interpreter to identify string and character literals according to a specific syntax.",
      "description_length": 461,
      "index": 16,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Parsers.Omega_comments.Multiline.S",
      "library": "comby-kernel.parsers",
      "description": "Defines delimiters for multiline comments using `left` and `right` string markers. Works with string values to identify comment boundaries. Used in parsing languages where multiline comments are enclosed with specific start and end tokens.",
      "description_length": 239,
      "index": 17,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Parsers.Alpha_string_literals.Raw",
      "library": "comby-kernel.parsers",
      "description": "This module parses raw string literals with customizable left and right delimiters, enforcing strict no-escaping rules across both direct API calls and submodule parsers. It operates on character streams or strings, producing validated content that preserves verbatim text between delimiters like `\"` or `|`, suitable for domain-specific languages or template systems. The core functionality handles single-character and base string literals, while child modules extend parsing to support strict delimiter matching and extraction of raw content. Examples include parsing SQL-like string literals or Go-style raw strings without escape sequences.",
      "description_length": 645,
      "index": 18,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Parsers.Alpha_comments.Until_newline",
      "library": "comby-kernel.parsers",
      "description": "This module provides a parser that skips characters until the next newline, handling alphabetic characters and comments, and works with both character streams and string inputs. It includes submodules for parsing single-line comments starting with a specified string and extracting or skipping them, as well as capturing entire lines up to a newline. Main operations include consuming input until a newline is found, tracking comment boundaries, and returning the parsed content. Example uses include preprocessing source code to remove line comments or parsing configuration files with comment-delimited lines.",
      "description_length": 611,
      "index": 19,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Parsers.Omega_comments.Until_newline",
      "library": "comby-kernel.parsers",
      "description": "This module implements a line-based parser that captures input from a character stream until encountering a newline, producing the consumed content as a string. It supports both direct character stream parsing and integration with the `Vangstrom.t` parser type, making it suitable for extracting single-line content like comments or configuration directives. The first child module extends this behavior by anchoring the parser to a specific starting string, enabling structured comment parsing in formats that use delimiters like `#` or `//`. The second child module adapts the core functionality for comment parsing workflows, returning the captured string and supporting use cases such as reading line-based configuration entries or custom language syntax.",
      "description_length": 759,
      "index": 20,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Parsers.Omega_string_literals.Escapable",
      "library": "comby-kernel.parsers",
      "description": "This module processes string literals with escape sequences in custom syntaxes, converting escaped characters according to defined rules. It includes a submodule that builds Vangstrom parsers for escaped characters and strings using a tokenization strategy, and another that defines fixed delimiters and escape logic for consistent string parsing. Main operations involve recognizing escape sequences, converting them to values, and handling quoted string literals with embedded escapes. Example uses include implementing string parsing in DSLs, interpreters, or configuration readers.",
      "description_length": 585,
      "index": 21,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Parsers.Alpha_comments.Nested_multiline",
      "library": "comby-kernel.parsers",
      "description": "This module parses nested multiline comments using configurable delimiters, tracking nested levels to correctly handle embedded structures. It processes character streams or strings, identifying and extracting comment blocks while maintaining proper nesting balance. The main operations include initializing a parser with custom delimiters, consuming input to locate comment regions, and returning either the full comment content or an error if delimiters are mismatched. For example, given OCaml-style `(* ... *)` delimiters, it can extract nested comments from a source file while ignoring non-comment text.",
      "description_length": 609,
      "index": 22,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Parsers.Omega_comments.Multiline",
      "library": "comby-kernel.parsers",
      "description": "This module processes multiline comments in source code, identifying delimiters, extracting content, and handling nested or unterminated structures. It uses a parser built with Vangstrom that supports customizable start and end markers, allowing integration into language-specific parsers. The core functionality works with string-based delimiters to detect comment boundaries, enabling tasks like code preprocessing, documentation extraction, or custom annotation handling. For example, it can parse C-style `/* ... */` comments with nesting or process OCaml's `(* ... *)` comments as part of a larger syntax analysis tool.",
      "description_length": 624,
      "index": 23,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Parsers.Alpha_string_literals.Escapable",
      "library": "comby-kernel.parsers",
      "description": "This module parses string literals with escapable delimiters, handling embedded escapes and correctly terminated strings in formats like JSON or command-line arguments. It supports character streams and token buffers, tracking parser state to manage input positions and errors during string extraction. Concrete uses include parsing configuration files or DSLs where strings contain escaped quotes or special characters within custom syntax. Submodules extend this functionality to handle single-character escapes, quoted strings, and custom string syntax with precise termination and position tracking.",
      "description_length": 603,
      "index": 24,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Parsers.Alpha_comments.Multiline",
      "library": "comby-kernel.parsers",
      "description": "This module parses non-nested block comments, such as C-style `/* ... */`, extracting content between custom delimiters and returning it as a string. It provides the `comment` function that operates on character streams tracked by `MParser.state`, integrating with monadic parser combinators for lexing and parsing textual data. Child modules extend this functionality by allowing configurable start and end delimiters and by supporting workflows where comment regions must be skipped during lexing. Example uses include implementing domain-specific language parsers, pre-processors, or compiler frontends that require custom or standard block comment handling.",
      "description_length": 661,
      "index": 25,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Parsers.Omega_string_literals.Raw",
      "library": "comby-kernel.parsers",
      "description": "This module processes raw string literals by parsing escape sequences and handling multi-line syntax, operating on character streams and byte buffers to produce OCaml strings. It includes a submodule that defines delimiters for marking string boundaries and another that implements Vangstrom parsers for extracting string and character literals from input. Main data types include parsers for string literals and byte buffers, with operations for decoding embedded strings and interpreting source code input. Examples include parsing multi-line strings in a compiler or extracting quoted values from a custom data format.",
      "description_length": 621,
      "index": 26,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Parsers.Omega_comments",
      "library": "comby-kernel.parsers",
      "description": "This module combines character stream parsing with structured comment handling, offering functions to skip or capture content between delimiters, read until specific strings, and manage newline behavior. It includes a line-based parser for extracting content up to newlines, anchored to specific starting strings for structured comment formats like `#` or `//`, and supports integration with `Vangstrom.t`. A separate component handles multiline comments with customizable delimiters, supporting nested or unterminated structures such as `/* ... */` or `(* ... *)`. These tools enable parsing source code comments, extracting documentation blocks, and processing configuration files with comment-aware logic.",
      "description_length": 708,
      "index": 27,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Parsers.Alpha_string_literals",
      "library": "comby-kernel.parsers",
      "description": "This module processes string literals with customizable delimiters, supporting both no-escape and escape-aware parsing. It provides data types for parser state, string content, and error handling, along with operations to extract raw content from character streams or strings. You can use it to parse SQL-style quoted strings, Go-like raw strings, or JSON strings with escaped quotes, ensuring strict delimiter matching and accurate position tracking during parsing.",
      "description_length": 466,
      "index": 28,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Parsers.Alpha_comments",
      "library": "comby-kernel.parsers",
      "description": "This module handles comment parsing in text with customizable delimiters, supporting both nested and non-nested structures. It provides parsers for line comments, block comments, and nested comments, operating on character streams or strings while tracking comment boundaries and newline positions. Key operations include skipping or extracting comments, capturing lines up to newlines, and managing nested delimiter pairs to ensure balanced comment regions. For example, it can remove line comments in a config file, extract nested OCaml-style comments, or parse C-style block comments during lexing.",
      "description_length": 601,
      "index": 29,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Parsers.Omega_string_literals",
      "library": "comby-kernel.parsers",
      "description": "This module processes string literals with support for escaped characters and raw string delimiters, enabling precise parsing of custom syntaxes. It provides a core set of data types and functions for defining escape rules, handling quoted and multi-line strings, and building token-based parsers using Vangstrom. The `|>>` operator allows sequential transformation of parser outputs, enhancing the ability to compose complex parsing logic. Example uses include implementing lexers for domain-specific languages, reading configuration files with embedded strings, and parsing multi-line input in compilers or interpreters.",
      "description_length": 622,
      "index": 30,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Parsers",
      "library": "comby-kernel.parsers",
      "description": "This module provides a suite of parsers for handling structured text elements like comments and string literals with customizable delimiters, escape sequences, and nesting rules. It supports operations such as skipping or capturing content between delimiters, reading until specific strings, and managing newline behavior, with data types for parser state, string content, and error handling. You can use it to parse OCaml-style nested comments, extract SQL or JSON string literals, and build token-based parsers for domain-specific languages using Vangstrom. Specific examples include stripping line comments in config files, parsing C-style block comments, and handling multi-line strings with embedded escapes.",
      "description_length": 713,
      "index": 31,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Replacement",
      "library": "comby-kernel.replacement",
      "description": "This module defines data structures for representing code replacements during source transformations, including the range of text to replace, the new content, and contextual environment. It provides functions to serialize and deserialize replacement data to and from JSON, along with utilities to construct and manipulate replacement results. Concrete use cases include formatting tools and linters that need to report and apply automated fixes to source code.",
      "description_length": 460,
      "index": 32,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Match.Offset",
      "library": "comby-kernel.match",
      "description": "This module provides functions to convert character offsets in a string into line and column numbers. It works with strings and integer offsets to track source code positions. Use it for error reporting or debugging to locate specific characters in multi-line text.",
      "description_length": 265,
      "index": 33,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Match.Range",
      "library": "comby-kernel.match",
      "description": "This module defines a range structure with start and end locations, providing serialization to and from JSON and S-expressions, equality checking, and a default value. It works with `Match.location` values to represent positions, typically used for tracking spans in parsed or analyzed code. Concrete use cases include storing and comparing source code spans during analysis or error reporting.",
      "description_length": 394,
      "index": 34,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Match.Location",
      "library": "comby-kernel.match",
      "description": "This module defines a location type with offset, line, and column fields, representing positions in a text buffer. It includes functions for JSON and S-expression serialization, equality checking, and a default value. Use this module to track and serialize precise positions in source code during parsing or analysis tasks.",
      "description_length": 323,
      "index": 35,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Match.Environment",
      "library": "comby-kernel.match",
      "description": "This module manages a mapping of string variables to values and associated ranges, providing operations to add, update, and query variable bindings. It supports creating, copying, and merging environments, as well as serializing and deserializing them to and from JSON. Concrete use cases include tracking variable substitutions during pattern matching and maintaining context state across matching operations.",
      "description_length": 410,
      "index": 36,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Match",
      "library": "comby-kernel.match",
      "description": "This module facilitates bidirectional conversion between structured match data and JSON/S-expressions, enabling precise manipulation of positional information in source text analysis. It operates on hierarchical records representing code locations, character ranges, execution environments, and offset-adjusted match results, supporting tools that require accurate tracking of pattern matches in textual inputs. Key data types include locations with offset, line, and column fields, ranges spanning start and end locations, and environments mapping variables to values and ranges. These components work together to enable tasks like parsing pipelines, static analysis, and transformation utilities where maintaining positional metadata across text modifications is critical.",
      "description_length": 774,
      "index": 37,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Script.Make.Parser.Template.Matching",
      "library": "comby-kernel.matchers",
      "description": "This module defines parsers for template holes in a script, mapping hole sorts to string parsers. It works with `Hole.sort` and `Vangstrom.t` types to process input streams. Use it to parse structured templates with placeholders in script files.",
      "description_length": 245,
      "index": 38,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Rule.Make.Template.Matching",
      "library": "comby-kernel.matchers",
      "description": "This module provides a collection of parsers for handling template holes, specifically mapping hole sorts to string parsers using the Vangstrom library. It works with `Hole.sort` and `Vangstrom.t` types to define how different hole types should be parsed from input strings. A concrete use case is parsing templated strings where placeholders need to be dynamically interpreted based on their type, such as extracting variables or structured data from a formatted input.",
      "description_length": 470,
      "index": 39,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Script.Make.Parser.Template",
      "library": "comby-kernel.matchers",
      "description": "This module processes string templates by parsing them into structured atoms, extracting variables, and substituting values using a match environment. It supports dynamic string interpolation and tracks variable usage through environment mappings. The child module enhances this functionality by defining parsers for template holes, mapping hole sorts to string parsers using `Vangstrom.t` to handle structured input streams. Together, they enable parsing and evaluation of complex templates with placeholders from script files, such as transforming `Hello, {{name}}` into personalized messages using provided variable bindings.",
      "description_length": 628,
      "index": 40,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Swift.Syntax",
      "library": "comby-kernel.matchers",
      "description": "This module defines syntax elements for Swift, including user-defined delimiters, escapable and raw string literals, and comment kinds. It provides concrete configurations for parsing and matching Swift code patterns. Use this module to handle Swift-specific syntactic constructs in code analysis or transformation tasks.",
      "description_length": 321,
      "index": 41,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Python.Syntax",
      "library": "comby-kernel.matchers",
      "description": "This module defines syntax elements specific to Python, including user-defined delimiters, escapable and raw string literals, and comment kinds. It provides precise syntactic patterns for parsing and matching Python code structures. Use this module to handle Python-specific lexical elements in code analysis or transformation tasks.",
      "description_length": 333,
      "index": 42,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Languages.Clojure.Syntax",
      "library": "comby-kernel.matchers",
      "description": "This module defines syntax elements for parsing Clojure code, including user-defined delimiters, escapable and raw string literals, and comment styles. It works with tuples and lists to represent opening/closing pairs and syntax options. Concrete use cases include configuring parsers to correctly handle Clojure's specific syntax features like metadata tags and reader macros.",
      "description_length": 377,
      "index": 43,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Ruby.Syntax",
      "library": "comby-kernel.matchers",
      "description": "This module defines syntax elements for Ruby, including user-defined delimiters for strings, escapable and raw string literals, and comment styles. It provides precise syntactic patterns used to identify and parse Ruby-specific constructs in source code. These values are used directly in pattern matching to detect Ruby code structures during analysis or transformation tasks.",
      "description_length": 377,
      "index": 44,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Fsharp.Info",
      "library": "comby-kernel.matchers",
      "description": "This module defines metadata for the F# programming language, including its name and file extensions. It provides direct access to the language name as a string and a list of associated file extensions. This information is used for language identification and file handling in tooling contexts.",
      "description_length": 294,
      "index": 45,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Generic.Syntax",
      "library": "comby-kernel.matchers",
      "description": "This module defines syntax elements for parsing and processing source code, including delimiters for user-defined blocks, escapable and raw string literals, and comment styles. It works with tuples, lists, and custom types representing language syntax constructs. Concrete use cases include configuring parsers for domain-specific languages, handling string escaping in code analysis tools, and defining comment structures for static analysis or pretty-printing.",
      "description_length": 462,
      "index": 46,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Kotlin.Syntax",
      "library": "comby-kernel.matchers",
      "description": "This module defines syntactic elements specific to Kotlin, including delimiters for string literals, escapable and raw string configurations, and comment styles. It provides precise syntax rules for parsing and matching Kotlin code structures. Use this module to handle Kotlin-specific string and comment syntax in code analysis or transformation tools.",
      "description_length": 353,
      "index": 47,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.C.Syntax",
      "library": "comby-kernel.matchers",
      "description": "This module defines syntax elements for parsing C-like languages, including delimiters for user-defined literals, escapable and raw string literal markers, and comment styles. It works with tuples and lists to specify patterns for string boundaries and comment structures. Use this module to configure parsers for C-based languages with custom syntax extensions.",
      "description_length": 362,
      "index": 48,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Languages.Haskell.Syntax",
      "library": "comby-kernel.matchers",
      "description": "This module defines syntax elements for parsing Haskell code, including delimiters for user-defined constructs, escapable and raw string literals, and comment styles. It provides concrete configurations for handling Haskell-specific syntactic features like `{- ... -}` for block comments and `\"` for string literals. Use this module when implementing parsers or syntax highlighters that need to accurately recognize and process Haskell's syntax.",
      "description_length": 445,
      "index": 49,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Languages.Coq.Info",
      "library": "comby-kernel.matchers",
      "description": "This module defines metadata for the Coq programming language, including its name and associated file extensions. It works with string and list data types to store and provide access to this information. Concrete use cases include identifying Coq source files by extension and referencing the language name in tooling or configuration contexts.",
      "description_length": 344,
      "index": 50,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.R.Info",
      "library": "comby-kernel.matchers",
      "description": "This module defines metadata for the R programming language, including its name and associated file extensions. It provides direct access to the language name as a string and a list of common file extensions used for R source files. This information is used in language detection and file association workflows where precise language identifiers and extension matching are required.",
      "description_length": 382,
      "index": 51,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Dhall.Syntax",
      "library": "comby-kernel.matchers",
      "description": "This module defines syntax elements for parsing and handling Dhall source code, including delimiters for interpolated strings, escapable and raw string literals, and comment styles. It provides concrete configurations for token recognition and string formatting specific to the Dhall language. Use cases include configuring parsers and pretty-printers to correctly interpret and generate Dhall expressions with proper escaping and commenting.",
      "description_length": 442,
      "index": 52,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.C_nested_comments.Syntax",
      "library": "comby-kernel.matchers",
      "description": "This module defines syntax elements for handling nested comments and string literals in a language similar to C. It specifies delimiters for nested comments, escapable and raw string literal markers, and comment styles. Concrete use cases include parsing source code with nested `/* */` comments and supporting string literals with custom delimiters.",
      "description_length": 350,
      "index": 53,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Languages.Zig.Info",
      "library": "comby-kernel.matchers",
      "description": "This module defines metadata for the Zig programming language, including its name and associated file extensions. It provides direct access to the language name as a string and a list of common file extensions used for Zig source files. This information is used in tooling and editor integrations to identify and handle Zig files based on their extension and display the correct language name.",
      "description_length": 393,
      "index": 54,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Move.Syntax",
      "library": "comby-kernel.matchers",
      "description": "This module defines syntactic elements for the Move language, including user-defined delimiters, escapable and raw string literals, and comment kinds. It provides specific values that configure how Move code is parsed and processed. These structures are used directly in parsing and analyzing Move source files, such as identifying string boundaries, handling escapes, and recognizing comments.",
      "description_length": 394,
      "index": 55,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Xml.Syntax",
      "library": "comby-kernel.matchers",
      "description": "This module defines syntax elements for XML parsing, including user-defined delimiters, escapable and raw string literals, and comment kinds. It provides precise syntactic rules for tokenizing XML content. Use cases include configuring XML parsers and handling embedded XML fragments with custom syntax extensions.",
      "description_length": 314,
      "index": 56,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Reason.Syntax",
      "library": "comby-kernel.matchers",
      "description": "This module defines syntax elements for parsing and processing ReasonML code, including delimiters for blocks, escapable and raw string literals, and comment styles. It provides specific configurations for handling language-specific syntax features like JSX tags, quoted strings, and line/block comments. These values are used directly by parsers to correctly tokenize and interpret ReasonML source code.",
      "description_length": 404,
      "index": 57,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Jsx.Syntax",
      "library": "comby-kernel.matchers",
      "description": "This module defines syntax elements for parsing and handling JSX-like languages, including user-defined delimiters for embedding expressions, escapable and raw string literals, and comment configurations. It works with tuples and lists to specify patterns for delimiters and literals, and uses custom types to represent comment kinds. Concrete use cases include configuring parsers to recognize JSX syntax in templated languages or domain-specific languages with embedded expressions.",
      "description_length": 484,
      "index": 58,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Template.Make.Matching",
      "library": "comby-kernel.matchers",
      "description": "This module provides a list of parsers for different hole sorts, enabling the extraction of structured data from strings based on predefined patterns. It works with hole sorts and string parsers, specifically pairing each hole sort with a corresponding Vangstrom string parser. Concrete use cases include parsing templated text where placeholders (holes) need to be dynamically replaced or extracted using custom parsing logic.",
      "description_length": 427,
      "index": 59,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Assembly.Info",
      "library": "comby-kernel.matchers",
      "description": "This module defines metadata for assembly languages, including the language name and associated file extensions. It provides direct access to these values as constants. Use this module to identify assembly language files by extension or reference their canonical name.",
      "description_length": 268,
      "index": 60,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Languages.Elm.Info",
      "library": "comby-kernel.matchers",
      "description": "This module defines metadata for the Elm programming language, including its name and file extensions. It provides direct access to the language name as a string and a list of associated file extensions. This information is used to identify and handle Elm source files in tooling and processing pipelines.",
      "description_length": 305,
      "index": 61,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Languages.Bash.Syntax",
      "library": "comby-kernel.matchers",
      "description": "This module defines syntax elements for Bash scripting, including user-defined delimiters, escapable and raw string literals, and comment styles. It provides precise syntactic rules for parsing and matching Bash code constructs. Use this module to handle string interpolation, command substitution, and comment stripping in Bash scripts.",
      "description_length": 337,
      "index": 62,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Dyck.Syntax",
      "library": "comby-kernel.matchers",
      "description": "This module defines syntax elements for parsing languages with nested structures, such as parentheses or brackets. It includes delimiters for blocks, string literals with escape support, raw string markers, and comment styles. It is used to configure parsers for domain-specific languages or structured data formats with balanced syntax.",
      "description_length": 337,
      "index": 63,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Tsx.Syntax",
      "library": "comby-kernel.matchers",
      "description": "This module defines syntax elements for parsing and matching TypeScript JSX (TSX) code. It specifies delimiters for embedded expressions, escapable and raw string literals, and comment styles. These values are used to configure language-specific matching rules in code analysis or transformation tools.",
      "description_length": 302,
      "index": 64,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Scala.Syntax",
      "library": "comby-kernel.matchers",
      "description": "This module defines syntax elements specific to Scala, including delimiters for user-defined literals, escapable and raw string literal formats, and comment styles. It provides concrete configurations for parsing and matching Scala code structures. Use this module to handle Scala-specific syntactic patterns in code analysis or transformation tasks.",
      "description_length": 350,
      "index": 65,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Erlang.Syntax",
      "library": "comby-kernel.matchers",
      "description": "This module defines syntax elements specific to Erlang, including user-defined delimiters, escapable and raw string literals, and comment kinds. It provides precise syntactic patterns for parsing and analyzing Erlang code. Use cases include configuring parsers, highlighting syntax in editors, and building tools that process Erlang source files.",
      "description_length": 346,
      "index": 66,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Scala.Info",
      "library": "comby-kernel.matchers",
      "description": "This module defines metadata for the Scala programming language, including its name and associated file extensions. It provides direct access to the language name as a string and a list of common file extensions used for Scala source files. This information is used in language detection and file handling workflows where precise language identification is required.",
      "description_length": 366,
      "index": 67,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Elixir.Info",
      "library": "comby-kernel.matchers",
      "description": "This module defines metadata for the Elixir programming language, including its name and associated file extensions. It works with string and list data types to store and retrieve language-specific identifiers. Concrete use cases include language detection based on file extensions and providing human-readable names for Elixir files in tooling interfaces.",
      "description_length": 356,
      "index": 68,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Julia.Info",
      "library": "comby-kernel.matchers",
      "description": "This module defines metadata for the Julia programming language, including its name and file extensions. It provides direct access to the language name as a string and a list of associated file extensions. Useful for identifying Julia files or configuring language-specific tools.",
      "description_length": 280,
      "index": 69,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Jsx.Info",
      "library": "comby-kernel.matchers",
      "description": "This module defines metadata for a JSX language variant, including its name and associated file extensions. It works with string and list data types to store and expose this information. Concrete use cases include identifying JSX files by extension and referencing the language name in tooling or configuration contexts.",
      "description_length": 320,
      "index": 70,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.JSON.Info",
      "library": "comby-kernel.matchers",
      "description": "This module defines metadata for the JSON language, including its name and associated file extensions. It provides direct access to the language identifier and a list of common extensions like `.json`. Use this module to retrieve standard naming and extension information for JSON files in tooling or configuration contexts.",
      "description_length": 324,
      "index": 71,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Go.Syntax",
      "library": "comby-kernel.matchers",
      "description": "This module defines syntax elements for parsing Go code, including user-defined delimiters for string literals, escapable and raw string literal markers, and comment styles. It works with tuples and lists to represent pairs of delimiters and options for string handling. Concrete use cases include configuring parsers to correctly identify string boundaries and comment blocks in Go source files.",
      "description_length": 396,
      "index": 72,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.OCaml.Syntax",
      "library": "comby-kernel.matchers",
      "description": "This module defines syntax elements specific to OCaml, including delimiters for user-defined syntax, escapable and raw string literals, and comment styles. It provides concrete configurations for parsing and handling OCaml code structures. Use this module when implementing or extending OCaml parsers, linters, or formatters that require precise syntax recognition.",
      "description_length": 365,
      "index": 73,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Php.Syntax",
      "library": "comby-kernel.matchers",
      "description": "This module defines syntax elements specific to PHP, including user-defined delimiters for strings, escapable and raw string literals, and comment kinds. It provides precise syntactic patterns for parsing and matching PHP code structures. Use cases include building parsers, linters, or code transformation tools that require accurate recognition of PHP's textual syntax.",
      "description_length": 371,
      "index": 74,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Bash.Info",
      "library": "comby-kernel.matchers",
      "description": "This module defines metadata for the Bash programming language, including its name and file extensions. It provides direct access to the language name as a string and a list of associated file extensions. Useful for tools that need to identify or process Bash files based on their extension or display the language name.",
      "description_length": 320,
      "index": 75,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Typescript.Syntax",
      "library": "comby-kernel.matchers",
      "description": "This module defines syntax elements specific to TypeScript, including delimiters for expressions, escapable and raw string literals, and comment styles. It provides precise string patterns and configurations used for parsing and matching TypeScript code. These values are used directly in syntax analysis tools to handle TypeScript's unique formatting and structure.",
      "description_length": 366,
      "index": 76,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Languages.Java.Info",
      "library": "comby-kernel.matchers",
      "description": "This module defines metadata for the Java language, including its name and file extensions. It provides direct access to the language name as a string and a list of associated file extensions. Useful for tools that need to identify Java files by extension or display the language name in reports and interfaces.",
      "description_length": 311,
      "index": 77,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Matchers.Languages.GraphQL.Syntax",
      "library": "comby-kernel.matchers",
      "description": "This module defines syntax elements for parsing and processing GraphQL, including delimiters for blocks, escapable and raw string literals, and comment styles. It supports concrete use cases like accurately tokenizing GraphQL queries and handling string enclosures with specific markers. The data structures include lists of string pairs for delimiters and literals, along with options and custom types for comment handling.",
      "description_length": 424,
      "index": 78,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Script.Make.Parser",
      "library": "comby-kernel.matchers",
      "description": "This module combines lexing and parsing capabilities to transform template syntax into abstract syntax trees, using Vangstrom parser combinators to handle atoms, operators, whitespace, and quoted strings. It defines core data types like AST nodes and parser primitives, enabling operations such as pattern matching, expression rewriting, and structured interpolation. With support for parsing template holes and environment-based variable substitution, it allows processing strings like `Hello, {{name}}` into executable templates that can be evaluated with dynamic bindings. Submodules extend this by mapping hole sorts to specific parsers and managing variable extraction and substitution in string templates.",
      "description_length": 711,
      "index": 79,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Assembly.Syntax",
      "library": "comby-kernel.matchers",
      "description": "This module defines syntax elements for assembly languages, including user-defined delimiters, escapable and raw string literals, and comment styles. It provides precise configurations for parsing and recognizing assembly code structures. Use this module to specify syntax rules for different assembly dialects, such as NASM, GAS, or MASM, enabling accurate tokenization and parsing.",
      "description_length": 383,
      "index": 80,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.C_nested_comments.Info",
      "library": "comby-kernel.matchers",
      "description": "This module defines metadata for a language that supports nested comments, including its name and file extensions. It works with string and list data types to store and retrieve this metadata. Concrete use cases include identifying the language by name and determining which files to process based on their extensions.",
      "description_length": 318,
      "index": 81,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Dyck.Info",
      "library": "comby-kernel.matchers",
      "description": "This module defines metadata for a specific language, including its name and associated file extensions. It works with basic string and list data types to store and retrieve this information. Concrete use cases include identifying the language by name and determining file types that belong to it based on extensions.",
      "description_length": 317,
      "index": 82,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Languages.Csharp.Syntax",
      "library": "comby-kernel.matchers",
      "description": "This module defines syntax elements for C# such as user-defined delimiters, escapable and raw string literals, and comment kinds. It provides precise syntactic patterns used for parsing and matching C# code structures. Use this module when implementing or analyzing C# language features that require detailed syntax handling, such as string interpolation or custom token recognition.",
      "description_length": 383,
      "index": 83,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.C.Info",
      "library": "comby-kernel.matchers",
      "description": "This module defines metadata for the C programming language, including the language name and associated file extensions. It works with string and list data types to store and retrieve this information. Concrete use cases include identifying C source files by extension and providing language-specific configuration in tools like linters or syntax highlighters.",
      "description_length": 360,
      "index": 84,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Tsx.Info",
      "library": "comby-kernel.matchers",
      "description": "This module defines metadata for a programming language, specifically its name and associated file extensions. It works with string and list data types to store and retrieve these properties. Use this module to identify language-specific details such as naming conventions and file types.",
      "description_length": 288,
      "index": 85,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Html.Syntax",
      "library": "comby-kernel.matchers",
      "description": "This module defines syntax elements for HTML, including user-defined delimiters, escapable and raw string literals, and comment kinds. It provides precise configurations for parsing and handling HTML-specific syntactic constructs. Use this module to customize or extend HTML syntax recognition in code analysis or transformation tools.",
      "description_length": 335,
      "index": 86,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Text.Info",
      "library": "comby-kernel.matchers",
      "description": "This module defines metadata for text-based languages, including the language name and associated file extensions. It works with string and list data types to store and retrieve language-specific identifiers. Concrete use cases include mapping file extensions to language names for syntax highlighting or file type detection.",
      "description_length": 325,
      "index": 87,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Languages.Fsharp.Syntax",
      "library": "comby-kernel.matchers",
      "description": "This module defines syntax elements for F# code parsing, including customizable delimiters, escapable and raw string literals, and comment styles. It supports precise pattern matching and tokenization of F# source files. Use cases include building parsers, linters, or code transformation tools tailored to F# syntax.",
      "description_length": 317,
      "index": 88,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Languages.Pascal.Syntax",
      "library": "comby-kernel.matchers",
      "description": "This module defines syntax elements specific to Pascal, including user-defined delimiters, escapable and raw string literals, and comment styles. It provides concrete configurations for parsing Pascal code, supporting features like custom string delimiters and comment handling. Use cases include configuring parsers or linters to correctly interpret Pascal source files with non-standard syntax extensions.",
      "description_length": 407,
      "index": 89,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Languages.Elm.Syntax",
      "library": "comby-kernel.matchers",
      "description": "This module defines syntax elements for parsing and matching Elm code, including delimiters for user-defined tokens, escapable and raw string literals, and comment styles. It provides concrete configurations for handling Elm-specific syntax features like triple-quote strings and `--` comments. Use this module when implementing parsers or syntax highlighters that need to recognize Elm's syntactic constructs.",
      "description_length": 410,
      "index": 90,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Latex.Syntax",
      "library": "comby-kernel.matchers",
      "description": "This module defines syntax elements for parsing LaTeX documents, including user-defined delimiters for macros, escapable and raw string literals, and comment styles. It works with tuples and lists to represent pairs of delimiters, optional escape configurations, and comment markers. Concrete use cases include identifying LaTeX macros, handling special string syntax, and recognizing line or block comments during parsing.",
      "description_length": 423,
      "index": 91,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Languages.HCL.Info",
      "library": "comby-kernel.matchers",
      "description": "This module defines metadata for the HCL programming language, including its name and file extensions. It provides direct access to the language's identifier and a list of associated file extensions. Useful for tools that need to recognize or process HCL files based on their extension or display the language name.",
      "description_length": 315,
      "index": 92,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Swift.Info",
      "library": "comby-kernel.matchers",
      "description": "This module defines metadata for the Swift programming language, including the language name and file extensions. It provides direct access to static information used for identifying and handling Swift source files. Concrete use cases include configuring parsers or tools that require Swift file recognition based on extension or language name.",
      "description_length": 344,
      "index": 93,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Julia.Syntax",
      "library": "comby-kernel.matchers",
      "description": "This module defines syntax elements specific to the Julia language, including user-defined delimiters for strings, escapable and raw string literal markers, and comment styles. It provides precise syntactic patterns used for parsing and matching Julia code constructs. Use cases include configuring parsers or linters to correctly identify string boundaries, escaped characters, and comment blocks in Julia source files.",
      "description_length": 420,
      "index": 94,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Solidity.Info",
      "library": "comby-kernel.matchers",
      "description": "This module defines metadata for the Solidity programming language, including its name and file extensions. It provides direct access to the language identifier and a list of associated file extensions. Useful for tooling that needs to recognize or process Solidity source files based on naming conventions.",
      "description_length": 307,
      "index": 95,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Fortran.Info",
      "library": "comby-kernel.matchers",
      "description": "This module defines metadata for the Fortran language, including its name and associated file extensions. It works with string and list data types to store and retrieve this information. A concrete use case is determining whether a given file is a Fortran source file based on its extension.",
      "description_length": 291,
      "index": 96,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Languages.Zig.Syntax",
      "library": "comby-kernel.matchers",
      "description": "This module defines syntactic elements specific to the Zig programming language, including user-defined delimiters, escapable and raw string literals, and comment kinds. It provides structured data to parse and match Zig syntax constructs in code analysis tools. Concrete use cases include tokenizing Zig source files and identifying string and comment patterns during static analysis or linter development.",
      "description_length": 407,
      "index": 97,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.CSS.Syntax",
      "library": "comby-kernel.matchers",
      "description": "This module defines syntax elements for parsing CSS, including delimiters for user-defined sections, escapable and raw string literals, and comment styles. It works with lists of string pairs for delimiters and literals, and comment kind structures. Concrete use cases include configuring parsers to handle CSS-specific syntax like `@media` blocks, string escaping, and comment stripping.",
      "description_length": 388,
      "index": 98,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.R.Syntax",
      "library": "comby-kernel.matchers",
      "description": "This module defines syntax elements for parsing and matching R code, including delimiters for user-defined operators, escapable and raw string literals, and comment styles. It provides specific configurations for handling R's syntactic conventions, such as backtick-quoted identifiers and `#`-prefixed comments. Use cases include building parsers or linters that require precise recognition of R's syntax constructs.",
      "description_length": 416,
      "index": 99,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Matlab.Info",
      "library": "comby-kernel.matchers",
      "description": "This module defines metadata for the MATLAB programming language, including its canonical name and associated file extensions. It provides direct access to the language's identifier and a list of common file extensions used for MATLAB source files. This information is used to support language detection and file handling in tooling that processes or categorizes source code.",
      "description_length": 375,
      "index": 100,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Languages.Pascal.Info",
      "library": "comby-kernel.matchers",
      "description": "This module defines metadata for Pascal language files, including the language name and associated file extensions. It works with string and list data types to store and retrieve this information. A concrete use case is determining valid file extensions when processing or categorizing Pascal source files.",
      "description_length": 306,
      "index": 101,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Matlab.Syntax",
      "library": "comby-kernel.matchers",
      "description": "This module defines syntax elements for parsing MATLAB code, including delimiters for blocks, string literals with escape support, raw string markers, and comment styles. It works with tuples, lists, and custom types representing string literals and comment structures. Concrete use cases include configuring parsers to handle MATLAB-specific syntax like `%{ %}` blocks, double-quoted strings, and single-line comments.",
      "description_length": 419,
      "index": 102,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Html.Info",
      "library": "comby-kernel.matchers",
      "description": "This module defines metadata for HTML, including its name and common file extensions. It provides direct access to the language name as a string and a list of associated file extensions. Useful for identifying HTML files based on extension or referencing the language name in tooling contexts.",
      "description_length": 293,
      "index": 103,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Java.Syntax",
      "library": "comby-kernel.matchers",
      "description": "This module defines syntax elements specific to Java, including user-defined delimiters, escapable and raw string literals, and comment styles. It provides precise configurations for parsing and matching Java code constructs. Use this module to handle Java-specific syntactic patterns in code analysis or transformation tasks.",
      "description_length": 326,
      "index": 104,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Language.Info.S",
      "library": "comby-kernel.matchers",
      "description": "This module defines metadata about a programming language, including its name and associated file extensions. It works with basic string and list data types to store and retrieve this information. Concrete use cases include identifying language-specific files in a codebase or configuring tools based on file extension mappings.",
      "description_length": 328,
      "index": 105,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Languages.Solidity.Syntax",
      "library": "comby-kernel.matchers",
      "description": "This module defines syntax elements for parsing Solidity code, including delimiters for identifiers, string literal formats, and comment styles. It supports concrete use cases like tokenizing smart contract source files and handling Solidity-specific string enclosures such as `unicode\"...\"` and `hex\"...\"`. The data structures include lists of string pairs for delimiters and literals, along with comment kind enumerations tailored to Solidity's syntax rules.",
      "description_length": 460,
      "index": 106,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Coq.Syntax",
      "library": "comby-kernel.matchers",
      "description": "This module defines syntax elements for parsing Coq code, including user-defined delimiters, escapable and raw string literals, and comment styles. It provides concrete configurations for handling Coq-specific syntax constructs during lexical analysis or AST manipulation. Use this module when implementing or extending Coq language support in tools like parsers, linters, or code transformers.",
      "description_length": 394,
      "index": 107,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.JSONC.Syntax",
      "library": "comby-kernel.matchers",
      "description": "This module defines syntax elements for JSONC, including user-defined delimiters, escapable and raw string literals, and comment kinds. It provides precise syntactic rules for parsing and interpreting JSONC documents. Use this module to configure parsers or syntax highlighters that require detailed JSONC structure handling.",
      "description_length": 325,
      "index": 108,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.CSS.Info",
      "library": "comby-kernel.matchers",
      "description": "This module defines metadata for CSS files, including the language name and associated file extensions. It provides direct access to the name of the language and a list of common file extensions used for CSS files. Useful for tools that need to identify or process CSS files based on their extension or language name.",
      "description_length": 317,
      "index": 109,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Language.Syntax.S",
      "library": "comby-kernel.matchers",
      "description": "This module defines syntax elements for parsing and interpreting custom languages, including delimiters for expressions, escapable and raw string literals, and comment styles. It works with lists of string pairs for delimiters and literals, and custom types for comment kinds and escapable literals. Concrete use cases include configuring parsers for domain-specific languages or templating systems with custom syntax rules.",
      "description_length": 424,
      "index": 110,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Rule.Make.Template",
      "library": "comby-kernel.matchers",
      "description": "This module processes template strings with placeholders, parsing them into structured atoms and extracting variables. It supports substituting variables using a match environment to produce resolved strings, enabling dynamic text generation from structured templates. The child module provides parsers for handling template holes, mapping hole sorts to string parsers using Vangstrom, allowing precise control over how placeholders are interpreted during parsing. For example, you can define a template like `\"user-{id}.txt\"` and extract or substitute the `id` variable based on its specified sort and parser.",
      "description_length": 610,
      "index": 111,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Dart.Info",
      "library": "comby-kernel.matchers",
      "description": "This module defines metadata for the Dart programming language, including its name and file extensions. It provides direct access to the language's identifier and a list of associated file extensions. Useful for tools that need to recognize or process Dart files based on naming conventions, such as linters or code analyzers.",
      "description_length": 326,
      "index": 112,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Fortran.Syntax",
      "library": "comby-kernel.matchers",
      "description": "This module defines syntax elements for Fortran, including user-defined delimiters, escapable and raw string literals, and comment kinds. It works with tuples, lists, and custom types representing string and comment syntax. Concrete use cases include parsing Fortran code and handling string literals with specific delimiters or escape sequences.",
      "description_length": 346,
      "index": 113,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Javascript.Info",
      "library": "comby-kernel.matchers",
      "description": "This module defines metadata for JavaScript, including the language name and associated file extensions. It works with string and list data types to store and retrieve this information. Concrete use cases include identifying JavaScript files by extension and referencing the language name in tooling or configuration contexts.",
      "description_length": 326,
      "index": 114,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Languages.Move.Info",
      "library": "comby-kernel.matchers",
      "description": "This module defines metadata for the Move programming language, including its name and file extensions. It provides direct access to a string representing the language name and a list of associated file extensions. This information supports tools that need to identify or process Move source files based on their extension or display the language name.",
      "description_length": 352,
      "index": 115,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Languages.Php.Info",
      "library": "comby-kernel.matchers",
      "description": "This module defines metadata for PHP files, including the language name and associated file extensions. It provides direct access to the name and a list of extensions used to identify PHP files. This information is used in file type detection and language-specific processing workflows.",
      "description_length": 286,
      "index": 116,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Xml.Info",
      "library": "comby-kernel.matchers",
      "description": "This module defines metadata for XML files, including the language name and associated file extensions. It provides direct access to the name and extensions through the `name` and `extensions` values. This information is used to identify and handle XML files in tools like parsers, linters, or syntax highlighters.",
      "description_length": 314,
      "index": 117,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Go.Info",
      "library": "comby-kernel.matchers",
      "description": "This module defines metadata for the Go programming language, including its name and file extensions. It provides direct access to the language name as a string and a list of associated file extensions. This information is used for language identification and file handling in tooling contexts.",
      "description_length": 294,
      "index": 118,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Erlang.Info",
      "library": "comby-kernel.matchers",
      "description": "This module defines metadata for the Erlang language, including its name and file extensions. It provides direct access to the language name as a string and a list of associated file extensions. This information is used for language identification and file handling in tooling contexts.",
      "description_length": 286,
      "index": 119,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.JSON.Syntax",
      "library": "comby-kernel.matchers",
      "description": "This module defines syntax elements for parsing JSON, including customizable delimiters, escapable and raw string literals, and comment styles. It works with lists of string pairs for delimiters and literals, and structured comment kinds. Use this to configure JSON parsers with non-standard syntax extensions or custom formatting rules.",
      "description_length": 337,
      "index": 120,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.GraphQL.Info",
      "library": "comby-kernel.matchers",
      "description": "This module defines metadata about a GraphQL implementation, including the name of the language or tool and a list of supported extensions. It is used to identify and configure GraphQL processors with specific capabilities. Concrete use cases include determining extension support for schema validation and enabling tool-specific features in GraphQL environments.",
      "description_length": 363,
      "index": 121,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Text.Syntax",
      "library": "comby-kernel.matchers",
      "description": "This module defines syntax elements for text-based languages, including delimiters for user-defined blocks, escapable and raw string literals, and comment styles. It works with lists of string pairs for delimiters and literals, and structured comment kinds. Concrete use cases include configuring parsers for domain-specific text formats or templating systems with custom syntax rules.",
      "description_length": 385,
      "index": 122,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Dhall.Info",
      "library": "comby-kernel.matchers",
      "description": "This module defines metadata for the Dhall configuration language, including its name and file extensions. It provides direct access to the language's identifier and a list of associated file extensions. Useful for tools that need to recognize or process Dhall files based on naming conventions or language-specific attributes.",
      "description_length": 327,
      "index": 123,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Nim.Syntax",
      "library": "comby-kernel.matchers",
      "description": "This module defines syntax elements for the Nim language, including user-defined delimiters, escapable and raw string literals, and comment kinds. It provides concrete configurations for parsing and matching Nim code constructs. Use this module to handle Nim-specific syntactic patterns in code analysis or transformation tools.",
      "description_length": 328,
      "index": 124,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Typescript.Info",
      "library": "comby-kernel.matchers",
      "description": "This module defines metadata for the TypeScript language, including its name and file extensions. It provides direct access to the language name as a string and a list of associated file extensions. Useful for identifying TypeScript files or configuring tools that handle TypeScript source code.",
      "description_length": 295,
      "index": 125,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Latex.Info",
      "library": "comby-kernel.matchers",
      "description": "This module defines metadata for LaTeX files, including the language name and associated file extensions. It provides direct access to the name and extensions as concrete values. Use this module to identify LaTeX files by extension or reference their language name in tooling or configuration contexts.",
      "description_length": 302,
      "index": 126,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Haskell.Info",
      "library": "comby-kernel.matchers",
      "description": "This module defines metadata for the Haskell language, including its name and associated file extensions. It provides direct access to a string identifier and a list of common file extensions used in Haskell projects. This information supports tools that need to recognize or process Haskell source files based on naming conventions.",
      "description_length": 333,
      "index": 127,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Languages.JSONC.Info",
      "library": "comby-kernel.matchers",
      "description": "This module defines metadata for the JSONC language, including its name and file extensions. It provides direct access to the language's identifier and a list of associated file extensions. Useful for tools that need to recognize or process JSONC files based on their extension or display the language name.",
      "description_length": 307,
      "index": 128,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.HCL.Syntax",
      "library": "comby-kernel.matchers",
      "description": "This module defines syntax elements for parsing HCL (HashiCorp Configuration Language), including delimiters for user-defined identifiers, escapable and raw string literals, and comment styles. It provides concrete configurations for token recognition and parsing rules specific to HCL. Use this module when implementing or extending HCL parsers to handle string enclosures, escapes, and comment syntax accurately.",
      "description_length": 414,
      "index": 129,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.SQL.Info",
      "library": "comby-kernel.matchers",
      "description": "This module defines metadata for an SQL language variant, including its name and associated file extensions. It works with basic string and list data types to store and retrieve language-specific identifiers. Concrete use cases include mapping file types to SQL dialects and providing extension-based language detection.",
      "description_length": 320,
      "index": 130,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Languages.OCaml.Info",
      "library": "comby-kernel.matchers",
      "description": "This module defines metadata for the OCaml language, including its name and file extensions. It provides direct access to the language name as a string and a list of associated file extensions. Useful for tools that need to identify OCaml files or display language information.",
      "description_length": 277,
      "index": 131,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Languages.Javascript.Syntax",
      "library": "comby-kernel.matchers",
      "description": "This module defines syntax elements for JavaScript, including delimiters for expressions, escapable and raw string literals, and comment formats. It provides specific configurations for parsing and matching JavaScript code patterns. Use cases include building parsers or linters that require precise handling of JavaScript syntax features like template strings or comment blocks.",
      "description_length": 379,
      "index": 132,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.SQL.Syntax",
      "library": "comby-kernel.matchers",
      "description": "This module defines syntax elements for SQL, including delimiters, string literals, and comment styles. It specifies pairs of opening and closing delimiters for identifiers, escapable and raw string literal markers, and comment formats. These values are used to configure parsers for SQL dialects with custom syntax rules.",
      "description_length": 322,
      "index": 133,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Python.Info",
      "library": "comby-kernel.matchers",
      "description": "This module defines metadata for Python files, including the language name and common file extensions. It provides direct access to the name as a string and a list of associated extensions. Useful for tools that need to identify or process Python source files based on naming conventions.",
      "description_length": 288,
      "index": 134,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Languages.Lisp.Info",
      "library": "comby-kernel.matchers",
      "description": "This module defines metadata for a Lisp dialect, including its name and associated file extensions. It works with string and list data types to store and retrieve language-specific identifiers. Concrete use cases include determining file type based on extension and providing human-readable names for Lisp variants.",
      "description_length": 315,
      "index": 135,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Csharp.Info",
      "library": "comby-kernel.matchers",
      "description": "This module defines metadata for the C# language, including the language name and associated file extensions. It provides direct access to a string identifier and a list of file extension strings. Useful for tools that need to recognize or process C# source files based on naming conventions.",
      "description_length": 292,
      "index": 136,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Nim.Info",
      "library": "comby-kernel.matchers",
      "description": "This module defines metadata for the Nim programming language, including its name and file extensions. It provides direct access to the language name as a string and a list of associated file extensions. This information is used for language identification and file handling in tooling and analysis systems.",
      "description_length": 307,
      "index": 137,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Matchers.Languages.Lisp.Syntax",
      "library": "comby-kernel.matchers",
      "description": "This module defines syntax elements for parsing Lisp-like languages, including delimiters for user-defined forms, escapable and raw string literals, and comment styles. It works with tuples and lists to specify patterns for syntax components such as string markers and comment indicators. Use this module to configure parsers for Lisp-based languages with custom syntax rules, such as supporting different string delimiters or comment prefixes.",
      "description_length": 444,
      "index": 138,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Languages.Reason.Info",
      "library": "comby-kernel.matchers",
      "description": "This module defines metadata for the Reason programming language, including its name and file extensions. It provides direct access to the language's identifier and a list of associated file extensions. Useful for tools that need to recognize or process Reason files based on naming conventions.",
      "description_length": 295,
      "index": 139,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Languages.Ruby.Info",
      "library": "comby-kernel.matchers",
      "description": "This module defines metadata for the Ruby programming language, including its name and file extensions. It provides direct access to the language name as a string and a list of associated file extensions. Useful for tools that need to identify or process Ruby files based on naming conventions, such as linters or syntax highlighters.",
      "description_length": 334,
      "index": 140,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Languages.Kotlin.Info",
      "library": "comby-kernel.matchers",
      "description": "This module defines metadata for the Kotlin programming language, including its name and file extensions. It provides direct access to the language name as a string and a list of associated file extensions. Useful for tools that need to identify or process Kotlin files based on their extension or display the language name.",
      "description_length": 324,
      "index": 141,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Dart.Syntax",
      "library": "comby-kernel.matchers",
      "description": "This module defines syntax elements for parsing and matching Dart code, including user-defined delimiters for string literals, escapable and raw string configurations, and comment syntax. It specifies how string boundaries and comments are recognized in Dart source files. Use this module to configure parsers or linters that need to accurately identify Dart's syntactic constructs.",
      "description_length": 382,
      "index": 142,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Languages.Paren.Info",
      "library": "comby-kernel.matchers",
      "description": "This module defines metadata for a programming language, specifically its name and associated file extensions. It works with basic string and list data types to store and retrieve this information. A typical use case is to identify and categorize source files based on their extension or language name.",
      "description_length": 302,
      "index": 143,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Elixir.Syntax",
      "library": "comby-kernel.matchers",
      "description": "This module defines syntax elements for parsing Elixir code, including delimiters for user-defined structures, escapable and raw string literals, and comment formats. It provides precise syntactic patterns used in Elixir to support accurate code analysis and transformation. Use cases include building parsers, linters, or code formatters specific to the Elixir language.",
      "description_length": 371,
      "index": 144,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Paren.Syntax",
      "library": "comby-kernel.matchers",
      "description": "This module defines syntax elements for parenthetical languages, including delimiters for parentheses, escapable and raw string literals, and comment styles. It provides concrete configurations for parsing and tokenizing code with nested structures and string handling. Use this to support language parsers that require precise matching of brackets, strings, and comments.",
      "description_length": 372,
      "index": 145,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Generic.Info",
      "library": "comby-kernel.matchers",
      "description": "This module defines metadata for a programming language, including its name and associated file extensions. It works with basic string and list data types to store and retrieve language-specific identifiers. Concrete use cases include mapping file extensions to languages or determining language support based on file names.",
      "description_length": 324,
      "index": 146,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Clojure.Info",
      "library": "comby-kernel.matchers",
      "description": "This module defines metadata for the Clojure programming language, including its name and file extensions. It provides direct access to a string representing the language name and a list of associated file extensions. Useful for language detection, file association, or configuration in tooling that supports Clojure.",
      "description_length": 317,
      "index": 147,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Languages.Rust.Syntax",
      "library": "comby-kernel.matchers",
      "description": "This module defines syntax elements specific to Rust, including user-defined delimiters for macros, escapable and raw string literals, and comment styles. It provides concrete configurations for parsing and matching Rust code patterns, such as handling macro invocations and string formatting. Use cases include building parsers or linters that require precise recognition of Rust syntax constructs.",
      "description_length": 399,
      "index": 148,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Languages.Rust.Info",
      "library": "comby-kernel.matchers",
      "description": "This module defines metadata for the Rust programming language, including its name and file extensions. It provides direct access to the language name as a string and a list of associated file extensions. This information is used to identify and categorize Rust source files in tooling and analysis systems.",
      "description_length": 307,
      "index": 149,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Engine.S-CSS",
      "library": "comby-kernel.matchers",
      "description": "This module implements CSS-specific matching operations over source code, providing functions to find all matches or the first match of a given template in a source string. It supports configuration options, file path tracking, and template rewriting, working directly with CSS syntax trees and string-based templates. It is used for code analysis and transformation tasks targeting CSS files, such as linting, refactoring, or pattern detection.",
      "description_length": 445,
      "index": 150,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Omega.Dart",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to match and transform Dart source code using pattern templates. It supports finding all matches or the first match of a given template in a source file, with options to configure matching behavior and rewrite templates. The primary data types involved are string-based templates and source code, along with match results encapsulated in `Match.t` and `Or_error.t`. Use cases include automated code refactoring, static analysis, and enforcing coding standards in Dart projects.",
      "description_length": 508,
      "index": 151,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Engine.S-Latex",
      "library": "comby-kernel.matchers",
      "description": "This module implements LaTeX-specific matching operations over source strings using a provided template. It supports retrieving all matches or the first match, with configurable parameters like file path and rule expressions, and allows setting a rewrite template for transformation tasks. The module works directly with LaTeX syntax, making it suitable for parsing and manipulating LaTeX documents programmatically.",
      "description_length": 416,
      "index": 152,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Alpha.CSS",
      "library": "comby-kernel.matchers",
      "description": "This module matches CSS expressions against source code templates, supporting precise pattern extraction and transformation. It operates on CSS AST structures and string-based templates, enabling targeted analysis of stylesheets. Use cases include enforcing style guidelines, extracting specific CSS rules, and rewriting styles based on predefined patterns.",
      "description_length": 357,
      "index": 153,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Template.S-Matching",
      "library": "comby-kernel.matchers",
      "description": "This module defines parsers for handling template holes, associating each hole sort with a string-based parser. It works with hole sorts and string inputs, using the Vangstrom library for parsing. Concrete use cases include parsing structured text templates where placeholders must be validated or transformed according to specific rules.",
      "description_length": 338,
      "index": 154,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Omega.Fsharp",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions for matching and transforming code using templates, specifically supporting F# syntax. It includes operations to find all matches, retrieve the first match with error handling, and apply rewrite templates to code. Use cases include automated code refactoring, pattern-based code analysis, and enforcing coding standards in F# projects.",
      "description_length": 366,
      "index": 155,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Omega.Swift",
      "library": "comby-kernel.matchers",
      "description": "This module matches and transforms Swift code using configurable templates. It supports finding all matches or the first match of a given pattern in a source file, with optional configuration and file path context. Use cases include automated code refactoring, static analysis, and enforcing coding standards in Swift projects.",
      "description_length": 327,
      "index": 156,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Engine.S-Jsx",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to match and transform JSX code patterns using customizable templates. It operates on string inputs representing source code and templates, supporting concrete use cases like detecting React component patterns or enforcing JSX structure rules. Key operations include finding all matches, extracting the first match with context, and rewriting JSX elements based on a specified template.",
      "description_length": 417,
      "index": 157,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Generic",
      "library": "comby-kernel.matchers",
      "description": "This module provides language-agnostic components for parsing and metadata management. It includes data types for syntax constructs like delimiters, string literals, and comments, along with operations to configure parsers and handle escaping rules. Metadata handling is supported through types for language names and file extensions, enabling file-based language detection and configuration. Examples include defining custom syntax blocks for DSLs, processing string literals with specific escaping rules, and mapping `.ml` files to OCaml metadata.",
      "description_length": 549,
      "index": 158,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Dyck",
      "library": "comby-kernel.matchers",
      "description": "This module provides a framework for defining and parsing languages with nested syntax structures. It supports delimiters for blocks, string literals with escapes, raw strings, and comments, enabling configuration of parsers for domain-specific languages or structured formats. Language metadata such as name and file extensions can be associated, allowing identification and file type classification. For example, it can parse nested parentheses in a custom config format and associate it with `.cfg` files.",
      "description_length": 508,
      "index": 159,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Omega.Move",
      "library": "comby-kernel.matchers",
      "description": "This module identifies and extracts matches from source code using customizable templates and configuration. It supports operations to find all matches, retrieve the first match with optional offset, and apply rewrite templates. Use cases include code analysis, transformation, and targeted extraction based on structural patterns in source files.",
      "description_length": 347,
      "index": 160,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.C_nested_comments",
      "library": "comby-kernel.matchers",
      "description": "This module handles nested comments and string literals in a C-like language, supporting customizable delimiters and metadata for file processing. It provides data types for comment and string markers, along with operations to parse and identify language-specific elements. Examples include parsing code with nested `/* */` blocks and recognizing source files by extensions like `.c` or `.h`.",
      "description_length": 392,
      "index": 161,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Omega.Paren",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to match and extract content enclosed in parentheses within source code. It supports finding all matches or the first match using a specified template, with options to configure matching behavior, shift results, and set rewrite templates. Use cases include parsing expressions, extracting function arguments, or identifying parenthetical structures in code.",
      "description_length": 388,
      "index": 162,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Dart",
      "library": "comby-kernel.matchers",
      "description": "This module provides metadata and syntax definitions for the Dart programming language. It includes data types for representing language identifiers, file extensions, string delimiters, escape sequences, and comment structures. Operations allow querying file extensions, parsing string literals, and recognizing comment syntax. For example, it can identify `.dart` files, extract string boundaries, or detect single-line and multi-line comments in Dart source code.",
      "description_length": 465,
      "index": 163,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.HCL",
      "library": "comby-kernel.matchers",
      "description": "This module provides essential metadata and syntax definitions for working with the HashiCorp Configuration Language (HCL). It includes the language's name and file extensions, along with parsing rules for identifiers, string literals, and comments. Developers can use these components to build or extend HCL parsers, recognize HCL files by extension, or configure tools to handle HCL syntax accurately. For example, it enables parsing HCL strings with proper escape handling or identifying HCL files based on `.hcl` or `.tf` extensions.",
      "description_length": 537,
      "index": 164,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Languages.Zig",
      "library": "comby-kernel.matchers",
      "description": "This module provides essential metadata and syntactic definitions for the Zig programming language. It includes data types for language name, file extensions, string literals, delimiters, and comment structures, enabling accurate parsing and analysis of Zig source files. Operations allow tooling to identify Zig files by extension, tokenize content, and recognize syntactic patterns such as raw strings and custom delimiters. For example, it supports editor integrations by mapping `.zig` files to the Zig language and assists linters in detecting valid comment and string boundaries during static analysis.",
      "description_length": 608,
      "index": 165,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Languages.Elm",
      "library": "comby-kernel.matchers",
      "description": "This module provides metadata and syntax definitions for the Elm programming language. It includes data types for language name, file extensions, string delimiters, and comment markers, along with operations to access and match these elements. For example, it identifies Elm source files via extensions like `.elm`, recognizes `--` for line comments, and supports parsing triple-quote strings. Use it to build tools that process or analyze Elm code, such as linters, parsers, or IDE integrations.",
      "description_length": 496,
      "index": 166,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Text",
      "library": "comby-kernel.matchers",
      "description": "This module provides a framework for defining and working with text-based languages by combining metadata and syntax configuration. It uses strings, lists, and structured types to represent language identifiers, delimiters, literals, and comment styles. You can map file extensions to languages, define custom string escapes, or set up syntax rules for parsers and templating systems. For example, it can associate `.ml` with OCaml or configure a template engine to recognize `{% %}` as block delimiters.",
      "description_length": 504,
      "index": 167,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Bash",
      "library": "comby-kernel.matchers",
      "description": "This module combines syntactic and metadata definitions for Bash scripting. It supports parsing and manipulating Bash code with custom delimiters, string literals, and comments, while also providing language identification through name and file extensions. Key operations include handling string interpolation, command substitution, comment stripping, and retrieving `.sh` or `.bash` file extensions. For example, it enables processing Bash scripts to extract executable code or determine if a file belongs to the Bash language.",
      "description_length": 528,
      "index": 168,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Alpha.GraphQL",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to match and extract data from GraphQL source code using templates. It supports operations like finding all matches, retrieving the first match, and applying rewrite templates, working directly with GraphQL AST expressions. Use cases include static analysis of GraphQL schemas, automated code transformations, and linting specific to GraphQL APIs.",
      "description_length": 378,
      "index": 169,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Omega.Clojure",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions for matching and transforming Clojure code using templates. It supports operations like finding all matches in a source string, retrieving the first match with optional offset, and setting a rewrite template. The module works with Clojure syntax trees and string-based code representations, commonly used for static analysis and code transformation tasks.",
      "description_length": 386,
      "index": 170,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Languages.Scala",
      "library": "comby-kernel.matchers",
      "description": "This module provides precise syntactic and metadata definitions for the Scala programming language. It includes key data types and operations for handling Scala-specific syntax elements such as string literals, delimiters, and comment styles, along with language identification features like file extensions. You can use it to parse, analyze, or transform Scala code and to detect Scala source files based on naming conventions. For example, it enables recognizing raw string literals and distinguishing Scala files by their `.scala` extension.",
      "description_length": 544,
      "index": 171,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Engine.S-Coq",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions for matching and rewriting code patterns in source files, specifically using a template-based approach. It supports operations like finding all matches or the first match of a template in a source string, with configurable parameters such as file path and rule expressions. The module works with string-based templates and source code, producing match results or errors, and allows setting rewrite templates for transformation workflows.",
      "description_length": 468,
      "index": 172,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Nim",
      "library": "comby-kernel.matchers",
      "description": "This module provides syntactic and metadata definitions for the Nim programming language. It supports parsing and handling Nim code constructs with customizable delimiters, string literals, and comments, while also exposing the language name and file extensions for identification and file processing. You can use it to build tools that analyze, transform, or interact with Nim source files based on their structure and naming conventions. For example, you can detect Nim files by extension, or parse Nim strings with custom delimiters.",
      "description_length": 536,
      "index": 173,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Omega.C",
      "library": "comby-kernel.matchers",
      "description": "This module matches and transforms C code using customizable templates and configurations. It provides functions to find all matches or the first match of a template in a source string, supporting rule-based filtering and error handling. Use cases include code analysis, refactoring, and enforcing coding standards in C projects.",
      "description_length": 329,
      "index": 174,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Engine.S-Erlang",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions for matching and transforming Erlang source code using templates. It supports operations like finding all matches, retrieving the first match with error handling, and setting rewrite templates. The module works with Erlang AST expressions, strings as input sources, and match results, targeting concrete tasks such as code refactoring, pattern-based searching, and transformation rule enforcement.",
      "description_length": 428,
      "index": 175,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Engine.S-Nim",
      "library": "comby-kernel.matchers",
      "description": "This module implements pattern matching and transformation for Nim source code. It provides functions to find all matches or the first match of a given template in a source string, supporting configurable matching via optional parameters. The module works directly with Nim abstract syntax trees, string templates, and source files, enabling use cases like automated code refactoring, linting, and structural code analysis.",
      "description_length": 423,
      "index": 176,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Alpha.Jsx",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to match and transform JSX expressions using customizable templates. It supports parsing and rewriting JSX syntax trees with functions like `all` and `first`, which return matches based on provided source and template strings. Use cases include codemods for refactoring JSX components or extracting specific JSX patterns from files.",
      "description_length": 363,
      "index": 177,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Latex",
      "library": "comby-kernel.matchers",
      "description": "This module handles LaTeX document parsing and file identification by combining syntax element definitions with file metadata. It uses tuples and lists to represent delimiters, escape configurations, and comment markers, while exposing concrete values for language name and file extensions. You can use it to parse LaTeX macros and comments, handle string literals, and detect LaTeX files based on extensions like `.tex` or `.latex`.",
      "description_length": 433,
      "index": 178,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Engine.S-Ruby",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to match and rewrite Ruby code using templates. It supports finding all matches or the first match between a template and a source string, with configurable options and file context. The module works directly with Ruby source strings, expression lists, and match configurations, enabling use cases like automated code refactoring or pattern-based code analysis.",
      "description_length": 392,
      "index": 179,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Engine.S-Swift",
      "library": "comby-kernel.matchers",
      "description": "This module implements matching and transformation operations for Swift code using customizable templates. It provides functions to find all matches or the first match between a template and a source string, supporting rule-based filtering and configuration options. The module works directly with Swift source strings and expression structures, enabling precise code analysis and automated refactoring tasks.",
      "description_length": 409,
      "index": 180,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Engine.S-Generic",
      "library": "comby-kernel.matchers",
      "description": "This module implements matching engines for code pattern detection and transformation. It provides operations to find all matches or the first match of a template in a source string, supporting configurable matching via a rule AST and source context. The module works with string-based templates and sources, producing match results or errors, and allows setting rewrite templates for transformations. Use cases include static code analysis, linting, and automated code refactoring.",
      "description_length": 482,
      "index": 181,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Languages.Php",
      "library": "comby-kernel.matchers",
      "description": "This module provides precise syntactic definitions and metadata for PHP files, enabling accurate parsing and processing of PHP code. It includes data types for string delimiters, comment kinds, and file extensions, along with operations to identify PHP syntax elements and file types. You can use it to build tools that recognize PHP's specific syntax, detect PHP files based on extension, or extract language metadata for processing workflows. For example, it supports writing a PHP linter that correctly handles heredoc strings or identifying a file as PHP based on its `.php` extension.",
      "description_length": 589,
      "index": 182,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Omega.GraphQL",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to match and extract data from GraphQL schemas using customizable templates. It supports operations like `all` to find all matches and `first` to retrieve the first match with optional configuration and source input. The module works with GraphQL schema strings, expression rules, and match result types, enabling precise schema analysis and transformation tasks.",
      "description_length": 394,
      "index": 183,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Typescript",
      "library": "comby-kernel.matchers",
      "description": "This module integrates TypeScript syntax definitions and language metadata to support parsing and file identification. It includes string patterns for expressions, literals, and comments, along with language name and file extensions. These components enable precise syntax analysis and configuration of TypeScript processing tools. For example, it allows matching TypeScript string literals or determining if a file has a `.ts` extension.",
      "description_length": 438,
      "index": 184,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Alpha.JSON",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to match and extract data from JSON content using templates. It supports retrieving all matches or the first match, with options to configure matching behavior, and allows setting a rewrite template for transforming matched content. The module works directly with JSON strings and expressions, targeting use cases like parsing, validating, and transforming JSON data structures.",
      "description_length": 409,
      "index": 185,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Alpha.Text",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to match and extract text patterns using templates. It operates on strings with configurable matching rules and supports loading match results from files. The `all` function returns every match in a source string, while `first` returns the first match or an error if none is found.",
      "description_length": 312,
      "index": 186,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Alpha.Erlang",
      "library": "comby-kernel.matchers",
      "description": "This module matches and transforms Erlang source code using a specified template. It supports finding all matches or the first match in a source string, with options to configure matching behavior, shift positions, or set a rewrite template. Use cases include code analysis, refactoring, and transformation tasks specific to Erlang syntax.",
      "description_length": 339,
      "index": 187,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Kotlin",
      "library": "comby-kernel.matchers",
      "description": "This module combines syntactic and metadata definitions for Kotlin, enabling precise parsing and identification of Kotlin code. It includes data types for string delimiters, comment styles, and file extensions, along with operations to match and process Kotlin-specific syntax. With this module, you can accurately extract string literals, handle raw and escapable strings, and identify Kotlin files by extension or display name. For example, you can parse multi-line strings using triple quotes or determine if a file path corresponds to a Kotlin source file.",
      "description_length": 560,
      "index": 188,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "Matchers.Alpha.Nim",
      "library": "comby-kernel.matchers",
      "description": "This module implements pattern matching and transformation for Nim source code. It provides functions to find all matches or the first match of a given template in a source file, supporting configurable matching and error handling. The module works directly with Nim syntax trees, string templates, and source files, enabling use cases like code refactoring, static analysis, and automated code generation.",
      "description_length": 406,
      "index": 189,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Languages.Go",
      "library": "comby-kernel.matchers",
      "description": "This module provides core utilities for parsing and identifying Go source code. It includes syntax definitions for handling string literals and comments, using tuples and lists to specify delimiters and formatting options. Metadata support offers direct access to the language name and file extensions, enabling accurate language detection and file processing. Examples include configuring parsers to recognize Go string boundaries and identifying Go files by their `.go` extension.",
      "description_length": 482,
      "index": 190,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Alpha.Lisp",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to match Lisp code patterns in source files using customizable templates and configuration. It supports extracting matches based on a given rule or template string and can return all matches or the first match with optional shifting of positions. The module works directly with Lisp AST expressions, strings, and file paths, and is used for tasks like code transformation, static analysis, and linting.",
      "description_length": 433,
      "index": 191,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Languages.Assembly",
      "library": "comby-kernel.matchers",
      "description": "This module provides metadata and syntax definitions for assembly languages. It includes data types for language properties like file extensions and syntax elements such as string delimiters and comment markers. Operations allow identifying assembly files by extension and configuring parsing rules for dialects like NASM or GAS. For example, you can define a language with `.asm` extension and set its comment syntax to use semicolons.",
      "description_length": 436,
      "index": 192,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.OCaml",
      "library": "comby-kernel.matchers",
      "description": "This module combines syntax definitions and language metadata for OCaml, enabling precise code parsing and file identification. It includes data types for syntax elements like delimiters, string literals, and comments, along with operations to configure and recognize OCaml code structures. The module also exposes the language name and common file extensions such as `.ml` and `.mli`. You can use it to build or extend tools like parsers, linters, and formatters that require accurate syntax handling and file type detection.",
      "description_length": 526,
      "index": 193,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Engine.S-Lisp",
      "library": "comby-kernel.matchers",
      "description": "This module implements a matcher engine for S-expression templates, providing functions to find all matches or the first match within a source string. It operates on S-expressions represented as strings, supporting configurable matching with optional file paths and rewrite templates. Use it to analyze or transform Lisp-like code structures programmatically, such as querying or rewriting Scheme or OCaml AST fragments.",
      "description_length": 420,
      "index": 194,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Engine.S-JSONC",
      "library": "comby-kernel.matchers",
      "description": "This module performs structural matching of JSON-like data using pattern templates, returning detailed match results. It processes strings representing JSONC (JSON with comments) input and supports configurable matching rules, file context, and template-based rewrites. Use it to analyze or transform JSONC configurations, such as validating or refactoring JSON-based files with custom logic.",
      "description_length": 392,
      "index": 195,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.SQL",
      "library": "comby-kernel.matchers",
      "description": "This module provides a framework for defining SQL dialects by combining metadata and syntax rules. It uses strings and lists to represent language identifiers, file extensions, delimiters, string literals, and comment styles. Operations include mapping file types to dialects, configuring parsers with custom syntax, and detecting languages based on extensions. For example, it can associate `.pgsql` files with PostgreSQL, define `--` as a comment prefix, and use `\"` as an identifier delimiter.",
      "description_length": 496,
      "index": 196,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Alpha.Java",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to match and transform Java code using a specified template. It supports finding all matches or the first match in a source string, with options to configure behavior, shift positions, or set a rewrite template. The primary data types are strings for source code and templates, along with match results that capture successful matches. Use cases include code analysis, refactoring, and transformation tasks specific to Java syntax.",
      "description_length": 462,
      "index": 197,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Alpha.Bash",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to match and transform Bash source code using specified templates. It supports extracting all matches or finding the first match with optional configuration and file context. Use cases include code refactoring, pattern-based code analysis, and automated code transformation in Bash scripts.",
      "description_length": 321,
      "index": 198,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Omega.Coq",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions for matching and rewriting code patterns in source files using a specified template. It operates on strings representing source code and templates, returning match results or errors, and allows setting rewrite templates and file extensions. It is used for analyzing or transforming code based on structural patterns, such as identifying specific AST nodes or applying automated fixes.",
      "description_length": 415,
      "index": 199,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Alpha.Pascal",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to match and transform Pascal-style code using a specified template. It processes source code strings and templates to identify matches, supporting operations like finding all matches, retrieving the first match, and setting a rewrite template. It works with Pascal syntax trees and string-based source code, commonly used for code analysis and transformation tasks.",
      "description_length": 397,
      "index": 200,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Alpha.OCaml",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to match OCaml source code against a given template, returning all matches or the first match with optional configuration and file context. It operates on OCaml AST expressions and works with source code strings, supporting use cases like code analysis, transformation, and pattern detection. Key functionality includes setting rewrite templates, matching across files, and extracting structured match results.",
      "description_length": 441,
      "index": 201,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Lisp",
      "library": "comby-kernel.matchers",
      "description": "This module provides a framework for defining and parsing Lisp-like languages by combining metadata and syntax configuration. It uses strings, lists, and tuples to represent language identifiers, file extensions, delimiters, and comment styles. With it, you can associate file types with specific Lisp dialects, customize string and comment syntax for parsers, and define custom form delimiters for different Lisp variants. For example, you could configure a parser to recognize `#|` and `|#` as block comments or use `.lisp` and `.el` as valid file extensions for a dialect.",
      "description_length": 575,
      "index": 202,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Omega.JSON",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to match and transform JSON content using customizable templates. It supports operations like finding all matches, retrieving the first match, and applying rewrite rules to JSON structures. Use cases include validating JSON formats, extracting specific fields, and transforming JSON data based on predefined patterns.",
      "description_length": 348,
      "index": 203,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Alpha.Dyck",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to match and extract structured patterns from source code using a template-based approach. It operates on string inputs representing code templates and source files, returning match results with contextual details. Use it to identify specific syntactic structures in code, such as function calls or expressions, based on predefined templates.",
      "description_length": 373,
      "index": 204,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Languages.Tsx",
      "library": "comby-kernel.matchers",
      "description": "This module combines language configuration with syntax parsing capabilities, enabling tools to process TypeScript JSX code based on customizable delimiters, string literals, and comment styles. It uses metadata to define language properties like name and file extensions, supporting identification and handling of TSX files. With this module, developers can configure expression boundaries, escape sequences, and file type associations for code analysis or transformation tasks. For example, it can recognize embedded expressions within JSX tags or distinguish between `.tsx` and `.ts` files based on extension.",
      "description_length": 612,
      "index": 205,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Omega.Latex",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to match LaTeX expressions against templates, extracting structured matches or errors. It operates on LaTeX source strings and templates, supporting configurable matching rules and file contexts. Use it to parse and transform LaTeX documents programmatically, such as extracting equations or validating document structure.",
      "description_length": 353,
      "index": 206,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Engine.S-HCL",
      "library": "comby-kernel.matchers",
      "description": "This module implements matching and transformation operations over HCL (HashiCorp Configuration Language) code. It provides functions to find all matches or the first match of a template in a source file, supporting configurable matching rules and optional source locations. Use cases include automated code refactoring, linting, and enforcing coding standards in HCL-based infrastructure definitions.",
      "description_length": 401,
      "index": 207,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Omega.OCaml",
      "library": "comby-kernel.matchers",
      "description": "This module matches OCaml source code against a given template, returning all matches or the first match with optional configuration and file context. It operates on OCaml AST expressions and strings representing source code and templates. Use cases include code analysis, transformation, and pattern-based rewriting in OCaml projects.",
      "description_length": 335,
      "index": 208,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Omega.Ruby",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to match and transform Ruby code using customizable templates. It supports operations like finding all matches or the first match in a source string, with configurable rules and file context. Use cases include automated code refactoring, pattern-based code analysis, and enforcing coding standards in Ruby projects.",
      "description_length": 346,
      "index": 209,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Omega.Reason",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions for matching and transforming code patterns using templates and rewrite rules. It operates on string-based source code and abstract syntax tree (AST) expressions, supporting concrete use cases like code refactoring, linting, and transformation. The `all` function finds all matches of a template in a source file, while `first` returns the first match or an error if none is found.",
      "description_length": 412,
      "index": 210,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Omega.Text",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions for matching text templates against source strings, returning lists of matches or the first match with optional configuration. It operates on string inputs representing templates and source text, producing `Match.t` values. Use cases include parsing structured text, extracting patterns from code or logs, and template-based string transformations.",
      "description_length": 379,
      "index": 211,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Engine.S-C",
      "library": "comby-kernel.matchers",
      "description": "This module implements matching and transformation operations over source code using string-based templates. It provides functions to find all matches or the first match of a template in a source string, with configurable options for file paths and rules. The module works directly with strings representing code, producing lists of `Match.t` results or error-aware single matches, and allows setting rewrite templates for transformation workflows.",
      "description_length": 448,
      "index": 212,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Engine.S-Matlab",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions for matching and rewriting MATLAB code based on templates. It supports extracting matches from source code using a given template and configuration, with options to control matching behavior. The module works directly with MATLAB abstract syntax trees, string templates, and match results, enabling concrete use cases like code transformation, static analysis, and refactoring of MATLAB scripts.",
      "description_length": 426,
      "index": 213,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Matcher.S",
      "library": "comby-kernel.matchers",
      "description": "This module performs pattern matching on source code using customizable templates and configurations. It provides functions to find all matches or the first match in a given source string, supporting operations like template-based rewriting and result filtering. Use cases include code analysis, transformation, and refactoring tasks where specific syntactic patterns need to be identified or modified.",
      "description_length": 402,
      "index": 214,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Alpha.Matlab",
      "library": "comby-kernel.matchers",
      "description": "This module implements pattern matching and transformation for MATLAB source code. It provides functions to find all matches or the first match of a given template in a source string, supporting configurable matching and error handling. The module works directly with MATLAB AST expressions, strings as input sources, and match results, enabling use cases like automated code refactoring, static analysis rule enforcement, and source-to-source transformations.",
      "description_length": 460,
      "index": 215,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Language.Info",
      "library": "comby-kernel.matchers",
      "description": "This module analyzes source code files to extract structured metadata, such as programming language, file encoding, and line endings, using raw file content and paths. It supports operations like detecting comment syntax and line length limits, enabling language-specific formatting and linter configuration. The language module identifies programming languages by name and file extensions, using strings and lists to manage mappings for tool configuration and file type validation. Together, they facilitate handling diverse file types in polyglot codebases through direct analysis and extension-based metadata lookup.",
      "description_length": 619,
      "index": 216,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Template.Make",
      "library": "comby-kernel.matchers",
      "description": "This module parses string templates into literals and variables, substituting placeholders using match environments to generate dynamic output. It integrates structured parsing through child module parsers that associate hole sorts with custom Vangstrom string parsers, enabling precise extraction and replacement of template components. For example, it can transform a template like \"user-{id}.txt\" into \"user-42.txt\" by resolving {id} from an environment, or parse incoming strings against such templates to extract values. The combination of template rendering and customizable hole parsing supports flexible text processing for configuration, routing, or log analysis tasks.",
      "description_length": 678,
      "index": 217,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Engine.S-Typescript",
      "library": "comby-kernel.matchers",
      "description": "This module performs structural code matching and rewriting on TypeScript source files. It provides functions to find all matches or the first match of a given template in a source file, with support for optional configuration, file path context, and rule-based filtering. The module works directly with TypeScript AST expressions and string-based templates, enabling precise pattern detection and transformation tasks like code refactoring or linting.",
      "description_length": 452,
      "index": 218,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Omega.SQL",
      "library": "comby-kernel.matchers",
      "description": "Performs SQL-specific matching and transformation operations using configurable templates and source code. It supports extracting matches from SQL code, applying rewrite rules, and retrieving metadata like file extensions and rule names. Useful for SQL linting, refactoring tools, and query analysis systems.",
      "description_length": 308,
      "index": 219,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Engine.S-Assembly",
      "library": "comby-kernel.matchers",
      "description": "This module performs structural matching of code templates against source code, returning all matches or the first match found. It operates on strings representing code templates and source files, with optional configuration, file path context, and rule-based filtering. Use it to detect specific code patterns in source files, such as identifying deprecated function calls or enforcing coding standards across a codebase.",
      "description_length": 422,
      "index": 220,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Omega.JSONC",
      "library": "comby-kernel.matchers",
      "description": "Matches JSONC files using a template and source string, supporting configuration options and file paths. It provides `all` to return every match and `first` to get the first match with error handling. Use it to extract or validate structured data from JSONC content.",
      "description_length": 266,
      "index": 221,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Engine.S",
      "library": "comby-kernel.matchers",
      "description": "This module provides syntax-aware parsing, pattern matching, and structured text manipulation operations for programming languages and data formats, with support for nested delimiters, indentation-based syntax, and language-specific tokenization. It operates on hierarchical data representations like abstract syntax trees and token streams, handling complex structures such as balanced parentheses (Dyck languages), JSON-like nested objects, and LaTeX document elements. The implementation enables use cases like code refactoring, linting, and format-preserving transformations that require precise syntactic analysis of languages ranging from GraphQL schemas to OCaml source files.",
      "description_length": 683,
      "index": 222,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Haskell",
      "library": "comby-kernel.matchers",
      "description": "This module combines syntax parsing configurations and language metadata for Haskell. It offers data types representing delimiters, string literals, comments, and file extensions associated with Haskell. Operations include identifying valid Haskell file names and parsing source code elements like comments and strings. For example, it enables recognizing `.hs` files and correctly handling `{- ... -}` block comments during syntax analysis.",
      "description_length": 441,
      "index": 223,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Alpha.HCL",
      "library": "comby-kernel.matchers",
      "description": "This module matches HCL templates against source code, providing functions to find all matches or the first match with optional configuration and file context. It works with HCL expressions and strings as input, returning structured match results. Use cases include validating infrastructure code against policies or extracting specific HCL blocks from Terraform files.",
      "description_length": 369,
      "index": 224,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Omega.Lisp",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions for matching and rewriting Lisp code based on templates. It operates on string inputs representing source code and templates, supporting concrete tasks like finding all matches or the first match with optional configuration and file context. Use cases include code transformation and static analysis in Lisp dialects.",
      "description_length": 348,
      "index": 225,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Engine.S-Go",
      "library": "comby-kernel.matchers",
      "description": "This module implements matching and transformation operations over source code using a template-based engine. It provides functions to find all matches (`all`) or the first match (`first`) of a given template in a source string, supporting configurable matching and optional rule-based filtering. The module works directly with strings representing source code and templates, and it returns match results containing detailed location and structure information. It is used for code analysis and transformation tasks such as detecting specific expression patterns or rewriting code constructs.",
      "description_length": 591,
      "index": 226,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Languages.Html",
      "library": "comby-kernel.matchers",
      "description": "This module provides precise definitions for HTML syntax elements and metadata, enabling customization of HTML parsing and recognition in code tools. It includes configurations for delimiters, string literals, comments, and file extensions associated with HTML. Developers can use it to adjust syntax handling in analysis tools or identify HTML files by extension. For example, it allows defining custom HTML comment styles or checking if a file uses an `.html` or `.htm` extension.",
      "description_length": 482,
      "index": 227,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Alpha.Ruby",
      "library": "comby-kernel.matchers",
      "description": "This module matches Ruby code against string templates, returning all matches or the first match with optional configuration, file context, and rule constraints. It operates on Ruby source code strings and supports match result customization through a rewrite template. Use cases include code analysis, transformation, and targeted extraction of specific Ruby syntax patterns.",
      "description_length": 376,
      "index": 228,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Omega.Javascript",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to match and transform JavaScript code using templates. It supports finding all matches or the first match of a template in a source string, with options to configure matching behavior, shift positions, and specify file paths. The module works directly with JavaScript AST expressions, strings as templates and sources, and returns structured match results. Use cases include automated code refactoring, pattern-based code analysis, and generating code transformations from string templates.",
      "description_length": 522,
      "index": 229,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Omega.Solidity",
      "library": "comby-kernel.matchers",
      "description": "Matches Solidity code patterns using customizable templates, supporting full or first-match-only operations. Works with Solidity source files and abstract syntax trees, enabling precise structural queries. Useful for code analysis, transformation, and validation tasks such as detecting specific contract patterns or enforcing coding standards.",
      "description_length": 344,
      "index": 230,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Erlang",
      "library": "comby-kernel.matchers",
      "description": "This module combines syntactic and metadata definitions for the Erlang language. It supports parsing and analyzing Erlang code with customizable delimiters, string literals, and comments, while also exposing language metadata such as name and file extensions. Key operations include configuring syntax rules, identifying Erlang files, and enabling editor features like syntax highlighting. For example, it allows tools to parse Erlang source files accurately or determine if a file belongs to the Erlang language based on its extension.",
      "description_length": 536,
      "index": 231,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Engine.S-Bash",
      "library": "comby-kernel.matchers",
      "description": "This module performs pattern matching and rewriting on shell script code. It provides functions to find all matches or the first match of a template in a source string, with support for configuration options and file context. The module works directly with shell syntax trees and string-based templates, enabling use cases like automated code refactoring and static analysis of Bash scripts.",
      "description_length": 391,
      "index": 232,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Pascal",
      "library": "comby-kernel.matchers",
      "description": "This module provides configurations and metadata for parsing and handling Pascal source files, supporting custom syntax elements like user-defined delimiters, string literals, and comment styles. It includes data types for representing file extensions and language identifiers, enabling operations such as validating file names and configuring syntax parsers. For example, it allows a linter to correctly parse Pascal files using non-standard string delimiters or to recognize `.pas` and `.pp` files as Pascal source files.",
      "description_length": 523,
      "index": 233,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Python",
      "library": "comby-kernel.matchers",
      "description": "This module handles Python-specific lexical elements and file metadata for code analysis and processing. It supports parsing syntax with custom delimiters, string literals, and comments, while also providing language identification through file extensions. Key operations include matching syntactic patterns and accessing extension lists for Python files. For example, it can parse raw strings or detect Python files by `.py` extensions.",
      "description_length": 437,
      "index": 234,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Alpha.C_nested_comments",
      "library": "comby-kernel.matchers",
      "description": "This module identifies matches for nested C-style comments in source code. It provides functions to find all matches or the first match, supporting configurable parsing and error handling. Use cases include code analysis and transformation tasks where comment structures need to be located or modified.",
      "description_length": 302,
      "index": 235,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Omega.Matlab",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions for matching and extracting data from MATLAB code using templates. It supports operations like finding all matches or the first match in a source string, with configurable rules and templates. The module works directly with MATLAB AST expressions, strings as input sources, and returns structured match results. Use cases include automated code analysis, refactoring, and transformation of MATLAB scripts based on defined patterns.",
      "description_length": 462,
      "index": 236,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Engine.S-C_nested_comments",
      "library": "comby-kernel.matchers",
      "description": "This module implements comment matching functionality for nested comment syntax in source code. It provides operations to extract all matches or the first match of a comment template within a given source string, supporting configuration options and file context. The module handles comment parsing with nested structures, allowing for precise matching and rewriting of comments in languages that support nested commenting.",
      "description_length": 423,
      "index": 237,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Omega.Xml",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to match XML templates against source code, extracting matches based on specified rules and configurations. It operates on XML structures and string-based templates and sources, supporting concrete use cases like detecting code patterns in XML files or enforcing structural constraints in XML documents. Key operations include finding all matches, retrieving the first match, and setting rewrite templates for transformation tasks.",
      "description_length": 462,
      "index": 238,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Alpha.Coq",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to match and rewrite code patterns in Coq source files using templates. It supports finding all matches or the first match of a given pattern, with configurable settings and optional source location tracking. The module works directly with Coq expressions and strings, enabling concrete use cases like automated code transformation and static analysis of Coq definitions.",
      "description_length": 402,
      "index": 239,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Engine.S-Csharp",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions for matching and transforming C# code using templates. It supports operations like finding all matches, identifying the first match, and setting rewrite templates, working with strings for both source code and templates. It is used for tasks like code analysis, refactoring, and transformation in C# projects.",
      "description_length": 340,
      "index": 240,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Solidity",
      "library": "comby-kernel.matchers",
      "description": "This module provides essential metadata and syntax definitions for working with the Solidity programming language. It includes data types for language identifiers, file extensions, delimiters, string literals, and comment styles, enabling accurate parsing and processing of Solidity source files. Operations allow tooling to recognize Solidity files by extension, tokenize code using defined delimiters, and handle specialized string formats like `unicode\"...\"` and `hex\"...\"`. Example uses include building linters, formatters, or compilers that require precise syntactic analysis of Solidity smart contracts.",
      "description_length": 610,
      "index": 241,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Language.S-Info",
      "library": "comby-kernel.matchers",
      "description": "This module defines metadata about a programming language, including its name and associated file extensions. It works with basic string and list data types to store and retrieve this information. Concrete use cases include identifying language-specific files in a codebase or configuring tools based on file extension mappings.",
      "description_length": 328,
      "index": 242,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Engine.S-Tsx",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions for matching and transforming source code using a template-driven engine. It operates on string-based source code and template inputs, producing lists of matches or individual match results with optional configuration and file context. Use cases include code analysis, transformation rules, and linting based on predefined templates.",
      "description_length": 364,
      "index": 243,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Omega.Jsx",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions for matching and transforming code using declarative templates, specifically supporting JSX syntax. It operates on string-based source code and abstract syntax trees, enabling precise pattern matching and rewriting with configurable rules. Concrete use cases include codemods for refactoring JSX elements and static analysis tools that detect or transform specific component structures.",
      "description_length": 417,
      "index": 244,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Alpha.Typescript",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions for matching TypeScript code patterns using customizable templates and configurations. It supports operations like finding all matches or the first match in a source file, with options to adjust matching behavior via parameters such as file path, rule expressions, and shift offsets. The module works directly with TypeScript AST expressions, strings as templates and sources, and Match.t structures for result output. Use cases include static code analysis, automated refactoring, and linting rule enforcement.",
      "description_length": 542,
      "index": 245,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Languages.Fortran",
      "library": "comby-kernel.matchers",
      "description": "This module provides metadata and syntax definitions for the Fortran language. It supports operations for identifying Fortran source files by extension and parsing Fortran code elements such as strings and comments. Key data types include strings, lists, tuples, and custom types for comment and string syntax. For example, it can check if a file is a Fortran source file or extract and handle string literals with custom delimiters.",
      "description_length": 433,
      "index": 246,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Engine.S-Fsharp",
      "library": "comby-kernel.matchers",
      "description": "This module performs pattern matching on F# source code using customizable templates and configurations. It provides functions to find all matches or the first match in a given source string, supporting operations like template-based rewriting and result filtering by file path or rule expressions. Use cases include automated code refactoring, static analysis of F# projects, and enforcing coding standards through configurable match rules.",
      "description_length": 441,
      "index": 247,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Java",
      "library": "comby-kernel.matchers",
      "description": "This module combines language metadata and syntax definitions to support Java code identification and processing. It exposes the language name and common file extensions for detection and reporting, while providing detailed syntax configurations for parsing constructs like strings, comments, and delimiters. Use it to accurately analyze or transform Java source files by leveraging predefined syntactic patterns and file recognition. For example, tools can identify `.java` files and correctly parse multiline comments or string literals with escaped characters.",
      "description_length": 563,
      "index": 248,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Omega.Assembly",
      "library": "comby-kernel.matchers",
      "description": "This module matches assembly code patterns against source templates, returning all matches or the first match with optional configuration, file path, and rule parameters. It operates on assembly expressions and strings, supporting concrete use cases like identifying instruction sequences in low-level code. The module also allows setting rewrite templates and querying supported file extensions.",
      "description_length": 396,
      "index": 249,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Alpha.Generic",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to match and transform code patterns using a generic alpha matcher. It operates on string-based templates and source code, producing lists of matches or a single match result, with support for configuration options and file context. Use cases include identifying specific code structures in source files and applying transformations based on matched patterns.",
      "description_length": 390,
      "index": 250,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Alpha.Swift",
      "library": "comby-kernel.matchers",
      "description": "This module matches and transforms Swift code using customizable templates. It supports finding all matches or the first occurrence in a source string, with options to configure matching behavior, file context, and rewrite rules. Use cases include automated code refactoring, linting, and enforcing coding standards in Swift projects.",
      "description_length": 334,
      "index": 251,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Alpha.SQL",
      "library": "comby-kernel.matchers",
      "description": "This module matches SQL expressions against templates, extracting structural matches from source code. It supports querying all matches or the first match, with configurable templates and optional source positioning. Use cases include SQL query analysis, schema validation, and automated query rewriting.",
      "description_length": 304,
      "index": 252,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Rust",
      "library": "comby-kernel.matchers",
      "description": "This module provides precise definitions for Rust's syntax elements and metadata, enabling accurate parsing and identification of Rust code. It includes configurations for handling macros, string literals, and comments, along with accessible language name and file extension data. Operations allow for building tools like linters or parsers that recognize Rust-specific constructs and classify Rust source files. For example, it supports detecting macro invocations and identifying `.rs` files as Rust sources.",
      "description_length": 510,
      "index": 253,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Engine.S-Paren",
      "library": "comby-kernel.matchers",
      "description": "This module implements parenthetical matching logic for code patterns, providing functions to find all matches or the first match of a template in a source string. It operates on string-based templates and source code, supporting configuration options, file paths, and rule expressions. Use cases include identifying and transforming parenthetical expressions in code analysis or refactoring tools.",
      "description_length": 398,
      "index": 254,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Matchers.Omega.Typescript",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions for matching TypeScript code against string templates, supporting operations like `all` to find all matches and `first` to retrieve the first match with optional configuration and file context. It works with TypeScript AST expressions, strings as templates and source inputs, and Match.t structures for result reporting. Use cases include code analysis, transformation, and validation tasks specific to TypeScript.",
      "description_length": 445,
      "index": 255,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Omega.Pascal",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to match and rewrite Pascal source code using a specified template. It supports finding all matches or the first match in a source string, with configurable options for the matching process. The module works directly with Pascal AST expressions and string-based templates, enabling precise code transformations and analysis tasks like refactoring or static analysis.",
      "description_length": 397,
      "index": 256,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Clojure",
      "library": "comby-kernel.matchers",
      "description": "This module handles Clojure's syntax parsing and language metadata. It supports custom delimiters, string literals, and comments, using tuples and lists to manage syntax pairs and options. Key data includes the language name and file extensions, enabling parser configuration, language detection, and tooling integration. Examples include recognizing Clojure's metadata tags, reader macros, and identifying `.clj` files.",
      "description_length": 420,
      "index": 257,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Alpha.Python",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to match Python code patterns using string templates, supporting operations like finding all matches or the first match in a source string. It works with Python source code strings and Match.t structures, allowing configuration through optional parameters like file paths and rule expressions. Use cases include code analysis, transformation, and validation based on syntactic patterns.",
      "description_length": 417,
      "index": 258,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Move",
      "library": "comby-kernel.matchers",
      "description": "This module defines the syntactic and metadata foundations of the Move programming language. It includes data types and values for handling string literals, delimiters, comments, and language identifiers, enabling precise parsing and processing of Move source files. Operations allow recognizing string boundaries, escaping characters, and distinguishing comment styles, while also providing the language name and common file extensions like `.move`. For example, it supports tools that parse Move code, extract comments, or identify source files by extension.",
      "description_length": 560,
      "index": 259,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Engine.S-Move",
      "library": "comby-kernel.matchers",
      "description": "This module implements matching and transformation operations over source code using a template-based engine. It provides functions to find all matches or the first match of a template in a given source string, with configurable parameters like file path and rule expressions. The module works directly with string-based templates and source code, producing match results or errors, and allows setting a rewrite template for transformation tasks. It is used for code analysis and refactoring scenarios where pattern matching against source code is required.",
      "description_length": 557,
      "index": 260,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Alpha.Make",
      "library": "comby-kernel.matchers",
      "description": "This module implements functions for matching and extracting patterns in source code using customizable templates. It operates on string-based source code and expression structures, supporting concrete use cases like code analysis, transformation, and specific pattern detection. Key operations include finding all matches, retrieving the first match with error handling, and configuring templates for rewriting.",
      "description_length": 412,
      "index": 261,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.External.S",
      "library": "comby-kernel.matchers",
      "description": "This module defines a handler value that processes external matchers, enabling pattern matching on custom data structures. It works with the `Matchers.External.t` type, which represents matcher configurations. Concrete use cases include validating and transforming complex input formats like JSON or AST nodes using declarative matching rules.",
      "description_length": 343,
      "index": 262,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Omega.Haskell",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions for matching and transforming code patterns in Haskell source files. It supports operations like finding all matches or the first match of a template in a source string, with configurable parameters and file context. The module works directly with Haskell AST expressions and string-based templates, enabling use cases such as automated code refactoring and linting rules.",
      "description_length": 403,
      "index": 263,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Alpha.Csharp",
      "library": "comby-kernel.matchers",
      "description": "This module implements C#-specific pattern matching over source code using customizable templates. It provides functions to find all matches or the first match of a given pattern in a source string, supporting configuration options and file context. The module works directly with C# source code strings and AST expressions, enabling precise structural queries and transformations.",
      "description_length": 381,
      "index": 264,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Alpha.Html",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to match and extract data from HTML content using templates. It supports retrieving all matches or the first match, with configurable parameters like file paths and AST rules. Use cases include parsing HTML documents for specific patterns, such as extracting links or elements based on structural criteria.",
      "description_length": 337,
      "index": 265,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Engine.S-Zig",
      "library": "comby-kernel.matchers",
      "description": "This module implements matching and transformation operations for Zig source code using string-based templates and rules. It provides functions to find all matches or the first match between a template and a source string, supporting configurable matching via optional parameters. The module handles Zig-specific syntax and maintains state for rewrite operations through a mutable template setting.",
      "description_length": 398,
      "index": 266,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Engine.S-Fortran",
      "library": "comby-kernel.matchers",
      "description": "This module implements matching operations for Fortran source code, supporting pattern-based searches using templates and expressions. It provides functions to find all matches or the first match in a source string, with configurable parameters like file path and rule expressions. Use cases include code analysis, transformation, and refactoring tasks specific to Fortran syntax.",
      "description_length": 380,
      "index": 267,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Omega.Csharp",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions for matching and transforming C# code using customizable templates. It supports operations like finding all matches in a source file, extracting the first match, and rewriting code based on a specified template. The module works directly with C# source strings and expression lists, enabling targeted code analysis and refactoring tasks such as identifying specific syntax patterns or applying structured code changes.",
      "description_length": 449,
      "index": 268,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Metasyntax.S",
      "library": "comby-kernel.matchers",
      "description": "This module defines syntactic elements for pattern matching, including a list of hole syntax structures, an identifier string, and a list of aliases. It works with custom data types representing metasyntax for pattern matchers, such as `hole_syntax` and `alias`. Concrete use cases include configuring and extending pattern matching rules for code analysis or transformation tools.",
      "description_length": 381,
      "index": 269,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Alpha.Assembly",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions for matching and extracting data from assembly code using templates. It supports operations like `all` to find all matches and `first` to retrieve the first match with optional configuration and source input. The module works with assembly code strings and leverages match templates to identify patterns, making it useful for tasks like binary analysis or code transformation.",
      "description_length": 407,
      "index": 270,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Omega.Java",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions for matching and transforming Java code using customizable templates. It supports operations like `all` to find all matches of a template in a source file, and `first` to find the first match with optional error handling. The module works directly with Java abstract syntax trees, allowing for precise code analysis and rewriting tasks such as refactoring or bug pattern detection.",
      "description_length": 412,
      "index": 271,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Alpha.Dhall",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions for matching and transforming Dhall configuration files using structured templates. It supports extracting matches from source code based on Dhall expressions and applying rewrite rules to specific sections. Use cases include automated code refactoring, configuration validation, and enforcing custom Dhall schema constraints.",
      "description_length": 357,
      "index": 272,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Javascript",
      "library": "comby-kernel.matchers",
      "description": "This module provides metadata and syntax definitions for JavaScript, enabling identification of files by extension and configuration of language-specific parsing rules. It includes data types for strings and lists to manage file extensions, along with structured representations of JavaScript syntax elements such as delimiters, string literals, and comments. Operations allow tools to detect JavaScript files, extract syntax features, and support parsing or linting workflows. For example, it can match template strings or strip comments from source code based on defined syntax patterns.",
      "description_length": 589,
      "index": 273,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Omega.Dhall",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions for matching and transforming Dhall expressions using templates. It supports operations like finding all matches or the first match of a template in a source string, with configurable rewriting behavior. The core data types include Dhall expressions, match results, and configuration parameters for parsing and rewriting. Use cases include automated code refactoring, linting, and templated code generation for Dhall-based configurations.",
      "description_length": 469,
      "index": 274,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Alpha.Fsharp",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to match and transform F# code using customizable templates. It supports operations like finding all matches, extracting the first match, and rewriting code based on a specified template. The module works directly with F# source code strings and supports common F# file extensions.",
      "description_length": 312,
      "index": 275,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Alpha.Xml",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to match XML templates against source code, extracting matches based on structural patterns. It operates on XML templates and source strings, supporting use cases like detecting specific XML node structures in configuration files or code generation templates. Key functions include finding all matches, retrieving the first match, and setting a rewrite template for transformation tasks.",
      "description_length": 418,
      "index": 276,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Omega.Elm",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions for matching and transforming source code based on templates. It operates on strings representing source code and templates, producing match results or errors. Use it to find all matches in a source file or extract the first match with optional configuration and file context.",
      "description_length": 307,
      "index": 277,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Alpha.Move",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to match and transform code patterns in string-based source code using a predefined template. It supports finding all matches or the first match, with optional configuration, file context, and rule constraints, returning structured match results. Use cases include code refactoring, pattern-based transformations, and static analysis tasks where specific syntactic structures need to be identified and modified.",
      "description_length": 442,
      "index": 278,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Engine.S-JSON",
      "library": "comby-kernel.matchers",
      "description": "This module performs structural matching and transformation of JSON-like data using predefined templates and rules. It supports operations to find all matches or the first match within a source string, with configurable parameters and optional file context. The module works directly with JSON strings, match expressions, and configurations, enabling use cases like validating JSON structures, extracting specific patterns, or rewriting JSON content based on templates.",
      "description_length": 469,
      "index": 279,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "Matchers.Alpha.Paren",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to match and extract content enclosed in parentheses from source code, using customizable templates. It operates on strings representing source code and templates, returning structured matches or errors. Use it to parse and transform parenthetical expressions in code analysis or refactoring tools.",
      "description_length": 329,
      "index": 280,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Alpha.Julia",
      "library": "comby-kernel.matchers",
      "description": "This module implements pattern matching for Julia source code, providing functions to find all matches or the first match of a given template in a source string. It supports matching with optional configuration, file context, and rule-based templates, returning structured match results. Use cases include code analysis, transformation, and refactoring tasks specific to Julia programs.",
      "description_length": 386,
      "index": 281,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.CSS",
      "library": "comby-kernel.matchers",
      "description": "This module handles CSS syntax parsing and file metadata, supporting customizable delimiters, string literals, and comment handling for accurate CSS structure interpretation. Key data types include string pairs for delimiters and literals, and metadata structures for language name and file extensions. Operations allow configuring parsers for CSS constructs like `@media` blocks, stripping comments, and identifying CSS files by extension. Example uses include parsing CSS with custom escaping rules and determining file type based on `.css` or `.scss` extensions.",
      "description_length": 565,
      "index": 282,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Languages.GraphQL",
      "library": "comby-kernel.matchers",
      "description": "This module provides core utilities for parsing, processing, and configuring GraphQL implementations. It includes data types for defining syntax elements such as delimiters, string literals, and comments, along with metadata structures for tracking language names and supported extensions. Operations allow precise tokenization of GraphQL queries, handling of string enclosures, and configuration of GraphQL processors based on extension support. For example, it enables parsing queries with custom delimiters or validating schemas with tool-specific features.",
      "description_length": 560,
      "index": 283,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Engine.S-Python",
      "library": "comby-kernel.matchers",
      "description": "This module implements matching operations for Python code using string templates, returning all matches or the first match found. It works with Python source strings and expression templates, supporting configurable matching via optional parameters. Use it to find specific code patterns in Python files, such as detecting function calls or variable assignments.",
      "description_length": 363,
      "index": 284,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Alpha.Scala",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to match and transform Scala code using predefined templates. It supports operations like finding all matches, extracting the first match, and rewriting code based on a specified template. The module works directly with Scala source code strings and match expressions, enabling use cases such as code refactoring, pattern-based transformations, and static analysis of Scala files.",
      "description_length": 411,
      "index": 285,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.C",
      "library": "comby-kernel.matchers",
      "description": "This module provides syntax configuration and language metadata for C-like languages. It supports defining custom delimiters, string literals, and comment styles using tuples and lists, while also offering built-in metadata such as language name and file extensions. Use it to tailor parsers and tools like linters or syntax highlighters for C-based languages. For example, you can specify raw string markers or identify C source files by their `.c` or `.h` extensions.",
      "description_length": 469,
      "index": 286,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Alpha.Elixir",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to match and transform Elixir code patterns using templates. It supports finding all matches or the first match in a source string, with configurable parameters like file path and rule context. Use cases include code refactoring, static analysis, and automated code transformation in Elixir projects.",
      "description_length": 331,
      "index": 287,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Engine.S-Haskell",
      "library": "comby-kernel.matchers",
      "description": "This module performs pattern matching on source code using a specified template and source string, returning matches as lists or single results. It works with strings for code and templates, and supports configuration parameters, file paths, and rule expressions. Use it to find all matches in a file or extract the first match, with options to adjust behavior via configuration or shifting positions.",
      "description_length": 401,
      "index": 288,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Languages.JSONC",
      "library": "comby-kernel.matchers",
      "description": "This module combines syntax configuration and language metadata for JSONC. It supports custom delimiters, string literals, and comments while providing identifiers and file extensions for JSONC. You can define parsing rules for JSONC documents and recognize JSONC files by extension. For example, configure a parser to handle raw strings or determine if a file is JSONC based on its `.jsonc` extension.",
      "description_length": 402,
      "index": 289,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Engine.S-Julia",
      "library": "comby-kernel.matchers",
      "description": "This module implements a matching engine for Julia code that identifies patterns in source files using a provided template. It supports finding all matches or the first match in a given source string, with options to customize configuration, file path, and rule expressions. The module works directly with Julia AST expressions and strings, maintaining a list of matches with contextual data. Use cases include code analysis, transformation, and linting tasks specific to Julia syntax.",
      "description_length": 485,
      "index": 290,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Omega.Python",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to match Python code against string templates, returning all matches or the first match with optional configuration, file path, and rule parameters. It works with Python source code strings and expression templates, supporting concrete use cases like detecting specific code patterns or enforcing coding standards in Python projects. The module allows setting a rewrite template for matched code and identifies matches with contextual information such as file paths and line numbers.",
      "description_length": 514,
      "index": 291,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Engine.S-R",
      "library": "comby-kernel.matchers",
      "description": "This module implements matching and transformation operations over source code using a template-based engine. It provides functions to find all matches (`all`) or the first match (`first`) of a template in a source string, supporting configurable matching and optional rule-based constraints. The module works directly with strings representing source code and templates, and it can rewrite matches using a specified template.",
      "description_length": 426,
      "index": 292,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Template.S",
      "library": "comby-kernel.matchers",
      "description": "This module handles parsing and substitution of template strings with embedded variables. It provides functions to parse templates, extract variable names, and substitute variables using values from a matching environment. Useful for generating output strings from structured templates in configuration or code generation workflows.",
      "description_length": 332,
      "index": 293,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Alpha.R",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to match and transform code patterns using a specified template and source. It operates on strings representing code, applying rules to extract matches or rewrite content. Use it to implement custom code transformations or static analysis rules for specific file types.",
      "description_length": 300,
      "index": 294,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Omega.Rust",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to match and rewrite code patterns in source files using a specified template. It operates on strings representing source code and templates, returning match results or errors. Use it to find all matches of a pattern in a file, get the first match with error handling, or configure rewrite templates for transformations.",
      "description_length": 351,
      "index": 295,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Engine.S-Kotlin",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions for matching and transforming Kotlin source code using predefined templates. It supports operations like finding all matches or the first match of a pattern, with configurable parameters such as file path and rule expressions. Use cases include automated code refactoring, static analysis, and enforcing coding standards in Kotlin projects.",
      "description_length": 371,
      "index": 296,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Language.S",
      "library": "comby-kernel.matchers",
      "description": "This module defines core parsing and matching operations over a domain-specific language, handling structured data representations like expressions and patterns. It provides functions for constructing and deconstructing syntax trees, validating language constructs, and performing substitution and comparison operations. Concrete use cases include implementing interpreters, linters, and transformation passes over a typed language.",
      "description_length": 432,
      "index": 297,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Languages.R",
      "library": "comby-kernel.matchers",
      "description": "This module provides essential language metadata and syntax definitions for working with the R programming language. It includes data types for representing R's file extensions, language name, and syntactic elements such as string delimiters, comment markers, and operator conventions. Operations allow querying file associations, parsing R-specific syntax constructs, and configuring tools like linters or formatters. For example, it enables detecting R files by extension, identifying valid string literals, and correctly parsing backtick-quoted identifiers in R code.",
      "description_length": 570,
      "index": 298,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Alpha.Javascript",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to match JavaScript code patterns using templates, extracting matches from source code. It supports finding all matches or the first match with optional configuration, file context, and template-based rewriting. Use cases include code analysis, automated refactoring, and static pattern detection in JavaScript files.",
      "description_length": 348,
      "index": 299,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Csharp",
      "library": "comby-kernel.matchers",
      "description": "This module combines syntax handling and language metadata for C# development. It supports parsing and matching complex syntax elements like string literals, delimiters, and comments, while also providing identifiers and file extensions for C# files. Key operations include recognizing custom tokens, processing interpolated strings, and identifying C# source files by extension. For example, it enables tools to parse C# code with custom delimiters or detect `.cs` files in a project directory.",
      "description_length": 495,
      "index": 300,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Engine.S-OCaml",
      "library": "comby-kernel.matchers",
      "description": "This module implements matching and transformation operations over OCaml source code using expression templates. It provides functions to find all matches or the first match between a template and a source string, supporting configurable matching via optional parameters. The module handles OCaml AST expressions, operates on file paths and string inputs, and allows setting rewrite templates for transformation workflows.",
      "description_length": 422,
      "index": 301,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Engine.S-Dyck",
      "library": "comby-kernel.matchers",
      "description": "This module implements Dyck language pattern matching for structured code analysis. It provides operations to find all matches or the first match of a template in a source string, supporting configurable matching with context-aware rules. The module works with string-based templates and sources, producing match results that capture structural equivalences in nested syntax.",
      "description_length": 375,
      "index": 302,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Engine.S-Javascript",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions for matching and transforming JavaScript code using templates. It supports finding all matches or the first match between a template and a source string, with configurable options and error handling. Use cases include automated code refactoring, pattern detection, and custom linting rules for JavaScript.",
      "description_length": 336,
      "index": 303,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Omega.Elixir",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to match and rewrite Elixir code patterns using templates. It supports finding all matches or the first match in a source string, with configurable options, and allows setting a template for rewriting matched code. It operates on Elixir AST expressions and strings, targeting concrete tasks like code transformation and refactoring.",
      "description_length": 363,
      "index": 304,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Languages.Julia",
      "library": "comby-kernel.matchers",
      "description": "This module provides essential language metadata and syntax definitions for working with Julia code. It includes data types for representing file extensions, string delimiters, escape sequences, and comment structures, along with operations to query and match these elements. For example, it can identify valid Julia file types, parse string literals with correct escaping, and detect single-line or multi-line comments in source files.",
      "description_length": 436,
      "index": 305,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Omega.Make",
      "library": "comby-kernel.matchers",
      "description": "This module implements pattern matching and rewriting operations over source code using customizable templates. It processes strings representing source code and templates, applying matchers to find or transform code patterns with optional configuration, file context, and rule constraints. Use it to define and apply structured code transformations or static analysis rules.",
      "description_length": 375,
      "index": 306,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Alpha.Elm",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to match and transform Elm source code using a template-based approach. It supports operations like finding all matches or the first match of a template in a source file, with configurable rewriting and error handling. The module works directly with Elm AST expressions, strings as templates, and file paths, enabling use cases such as automated code refactoring and static analysis of Elm projects.",
      "description_length": 430,
      "index": 307,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Omega.Julia",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to match and rewrite Julia source code using a specified template. It supports finding all matches or the first match in a source string, with configurable parameters like file path and rule expressions. The module works directly with Julia AST expressions, strings as input sources and templates, and produces match results or errors, tailored for code transformation tasks.",
      "description_length": 406,
      "index": 308,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Elixir",
      "library": "comby-kernel.matchers",
      "description": "This module provides language-specific metadata and syntax definitions for Elixir, enabling tools to identify and process Elixir code effectively. It includes data types for handling file extensions, language identifiers, string literals, delimiters, and comment syntax. Operations allow detecting Elixir files by extension, parsing structured code elements, and formatting or analyzing Elixir source files. Examples include building language detectors, syntax highlighters, and custom code transformation tools.",
      "description_length": 512,
      "index": 309,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Engine.S-GraphQL",
      "library": "comby-kernel.matchers",
      "description": "This module implements a GraphQL query matching engine that evaluates templates against source documents. It provides operations to extract matches (`all`) or find the first match (`first`) using configurable rules, file paths, and shift offsets, returning structured match results. Use cases include validating GraphQL queries against expected patterns and transforming query fragments using rewrite templates.",
      "description_length": 411,
      "index": 310,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Engine.S-Elm",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions for matching and transforming source code based on templates. It operates on strings representing source code and templates, producing lists of matches or individual match results. Use it to find all occurrences of a pattern in code, retrieve the first match, or configure templates for rewriting.",
      "description_length": 328,
      "index": 311,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Omega.C_nested_comments",
      "library": "comby-kernel.matchers",
      "description": "This module identifies matches for nested comments in source code using customizable templates. It processes strings representing source code and templates, supporting configuration options and file context. Use it to detect and analyze nested comment patterns in languages like C or OCaml, where such comments are common.",
      "description_length": 322,
      "index": 312,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Alpha.Zig",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions for matching and extracting patterns from source code using a specified template. It operates on strings representing source code and templates, returning match results with optional configuration and file context. Use it to find all occurrences of a pattern in code or extract the first match, particularly useful for code analysis and transformation tasks.",
      "description_length": 389,
      "index": 313,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Rule.Make",
      "library": "comby-kernel.matchers",
      "description": "This module processes rule-based syntax in domain-specific languages, handling terminals like whitespace, alphanumeric tokens, quoted strings, and structured patterns. It operates on a custom AST of atoms and expressions, supporting equality checks, rewrite rules, and match-case logic for tasks like configuration parsing or query language implementation. The template processing submodule parses strings with placeholders into structured atoms, supporting variable extraction and substitution using match environments and Vangstrom-based parsers. For example, it can parse and resolve dynamic filenames like `\"user-{id}.txt\"` where `id` is interpreted according to its specified sort and parsing rule.",
      "description_length": 703,
      "index": 314,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Language.Syntax",
      "library": "comby-kernel.matchers",
      "description": "This module provides data structures and JSON serialization for syntax elements like delimiters, string literals, and comment styles, enabling the configuration of parsers for custom languages. It supports operations on lists of string pairs for delimiters and literals, along with custom types for comments and escapable strings, allowing precise definition and serialization of syntax rules. Submodules extend this functionality to handle expression delimiters, raw and escapable strings, and comment kinds, supporting use cases such as configuring templating systems or DSL parsers. Example uses include defining custom syntax for a templating engine and serializing those rules to JSON for storage or transmission.",
      "description_length": 718,
      "index": 315,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Fsharp",
      "library": "comby-kernel.matchers",
      "description": "This module provides essential metadata and syntax definitions for working with the F# programming language. It includes data types for representing language name, file extensions, string literals, delimiters, and comment styles, along with operations for parsing and identifying F# code. You can use it to build tools that process F# source files, such as parsers, linters, or syntax highlighters, by leveraging its structured representation of F# syntax and file structure. For example, it enables detecting F# files based on extension or extracting comments and strings from F# code using customizable delimiters.",
      "description_length": 616,
      "index": 316,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Alpha.Latex",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions for matching LaTeX content against string templates, extracting structured matches. It operates on LaTeX source strings and rule-based expressions, supporting use cases like parsing and transforming LaTeX documents programmatically. Key operations include finding all matches, retrieving the first match, and setting rewrite templates for transformation workflows.",
      "description_length": 395,
      "index": 317,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Omega.R",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to match and rewrite code patterns using a specified template and source. It operates on strings representing code, with `all` returning all matches and `first` finding the first match, optionally shifted by a character index. Use cases include automated code transformations and static analysis tasks.",
      "description_length": 333,
      "index": 318,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Omega.Generic",
      "library": "comby-kernel.matchers",
      "description": "This module performs structural matching of code patterns in source files using customizable templates. It supports operations to find all matches, retrieve the first match, and configure the matching process with specific rules and file contexts. The module works directly with source code strings and structured match results, enabling targeted code analysis and transformation tasks.",
      "description_length": 386,
      "index": 319,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Engine.S-Reason",
      "library": "comby-kernel.matchers",
      "description": "This module performs structural matching of code patterns in source files using customizable templates and configurations. It supports operations to find all matches or the first match in a given source, with options to adjust matching behavior via configuration, file path, and template parameters. It works directly with strings for source code and templates, producing match results that include detailed information about matched code structures.",
      "description_length": 450,
      "index": 320,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Languages.Ruby",
      "library": "comby-kernel.matchers",
      "description": "This module provides syntactic and metadata definitions for the Ruby programming language. It includes patterns for parsing Ruby constructs such as strings with custom delimiters, escaped and raw literals, and comment styles, along with identifiers like the language name and common file extensions. These components support tasks like code analysis, transformation, and file recognition. For example, it enables detecting Ruby string syntax during parsing or identifying Ruby source files by their `.rb` extension.",
      "description_length": 515,
      "index": 321,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Matchers.Languages.JSON",
      "library": "comby-kernel.matchers",
      "description": "This module provides essential components for working with JSON by combining metadata and syntax definitions. It includes data types for language identifiers, file extensions, delimiters, string literals, and comment styles, enabling customization of JSON parsing and formatting. Operations allow retrieving standard JSON metadata, configuring parsers with custom syntax, and handling non-standard formatting rules. For example, you can define a parser that recognizes `.json5` files with relaxed syntax or configure string escaping for specific use cases.",
      "description_length": 556,
      "index": 322,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Matchers.Engine.S-Solidity",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to match and rewrite Solidity code patterns using templates. It operates on Solidity source code strings and supports concrete use cases like detecting and transforming specific contract structures or expressions. Key operations include finding all matches, extracting the first match with error handling, and setting rewrite templates for code transformation.",
      "description_length": 391,
      "index": 323,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Engine.S-Php",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions for matching and transforming PHP code using templates. It supports operations like finding all matches or the first match between a template and a source string, with optional configuration and file context. The module works directly with PHP syntax trees, string templates, and match results, enabling use cases such as code refactoring, pattern-based transformations, and static analysis rules targeting PHP.",
      "description_length": 442,
      "index": 324,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Alpha.Dart",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to match and transform Dart source code using a specified template. It supports finding all matches or the first match in a given source, with options to configure matching behavior, file context, and rule constraints. The module works directly with Dart syntax trees, string templates, and source files, enabling precise code analysis and transformation tasks like refactoring or linting.",
      "description_length": 420,
      "index": 325,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Omega.Fortran",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions for matching and transforming Fortran source code using templates. It supports operations like finding all matches, retrieving the first match with error handling, and setting rewrite templates. The module works directly with Fortran AST expressions, strings for source code and templates, and Match.t structures for results. Use cases include code analysis, transformation, and refactoring specific to Fortran syntax and structure.",
      "description_length": 463,
      "index": 326,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Alpha.Rust",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to match and extract patterns in Rust source code using a template-based approach. It supports finding all matches or the first match in a given source, with configurable analysis settings and optional template rewriting. The primary data structures involved are string-based templates and source code inputs, producing match results or errors. Use cases include static code analysis, automated refactoring, and linting specific to Rust syntax and structure.",
      "description_length": 489,
      "index": 327,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Language.S-Syntax",
      "library": "comby-kernel.matchers",
      "description": "This module defines syntax elements for parsing and handling string literals, delimiters, and comments in a language. It includes configurations for user-defined delimiters, escapable and raw string literals, and comment styles. Concrete use cases include setting up syntax rules for custom language parsers or preprocessors that require precise control over lexical elements.",
      "description_length": 376,
      "index": 328,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Omega.Php",
      "library": "comby-kernel.matchers",
      "description": "Performs pattern matching on PHP code using customizable templates and configurations. It supports matching against entire files or specific expressions, returning all matches or the first match with optional offset. The module works directly with PHP source strings, file paths, and abstract syntax trees, enabling precise code analysis and transformation tasks like refactoring or bug detection.",
      "description_length": 397,
      "index": 329,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Alpha.Php",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to match and extract patterns from PHP source code using a template-based approach. It supports operations like finding all matches or the first match in a given source, with configurable parameters such as file path and rule expressions. Use cases include code analysis, transformation, and refactoring tasks specific to PHP projects.",
      "description_length": 366,
      "index": 330,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Metasyntax.Default",
      "library": "comby-kernel.matchers",
      "description": "Defines metasyntax for pattern matching, including syntax rules, an identifier string, and a list of aliases. It works with custom data types representing metasyntax structures, such as `hole_syntax` and `alias`. Used to configure and extend pattern matching capabilities in parsing and transformation workflows.",
      "description_length": 312,
      "index": 331,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Languages.Dhall",
      "library": "comby-kernel.matchers",
      "description": "This module provides core components for working with the Dhall configuration language, combining syntax handling and language metadata. It includes data types for representing Dhall syntax elements such as string delimiters, escape sequences, and comment formats, along with operations to configure parsers and pretty-printers. The module also exposes identifiers and file extensions associated with Dhall, enabling tools to recognize and process Dhall files based on naming conventions. For example, it allows configuring a parser to correctly interpret interpolated strings or determining whether a file should be treated as a Dhall configuration based on its extension.",
      "description_length": 673,
      "index": 332,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Engine.S-Rust",
      "library": "comby-kernel.matchers",
      "description": "This module performs pattern matching on source code using a specified template and source string, returning all matches or the first match found. It works with string inputs representing code, and produces match results containing details about each match location. It supports configuration options, file paths, and dynamic rewrite templates, making it suitable for code analysis and transformation tasks.",
      "description_length": 407,
      "index": 333,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Alpha.Kotlin",
      "library": "comby-kernel.matchers",
      "description": "This module matches Kotlin code patterns using customizable templates, supporting full or first-match-only operations. It processes source code strings and templates to identify structural matches, with configurable behavior and optional file context. Use cases include code analysis, refactoring, and transformation tasks specific to Kotlin syntax.",
      "description_length": 349,
      "index": 334,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Alpha.Go",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to match and extract data from OCaml source code using a template-based pattern matching system. It operates on strings representing source code and templates, producing lists or individual match results with optional configuration and file context. Use cases include code analysis, transformation, and querying specific syntactic patterns in OCaml programs.",
      "description_length": 389,
      "index": 335,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Omega.Scala",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to match and transform Scala code using templates. It supports finding all matches or the first match of a given template in a source string, with options to configure matching behavior, file context, and result transformation. Use cases include code refactoring, static analysis, and automated code generation based on pattern templates.",
      "description_length": 369,
      "index": 336,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Languages.Matlab",
      "library": "comby-kernel.matchers",
      "description": "This module provides metadata and syntax definitions for the MATLAB programming language. It includes identifiers, file extensions, and structures for parsing MATLAB source code, such as comment styles, string literals, and block delimiters. Users can detect MATLAB files by extension, parse scripts with MATLAB-specific syntax, and handle constructs like `%{ %}` blocks or escaped strings. Example uses include configuring source code analyzers or building MATLAB-aware editors.",
      "description_length": 479,
      "index": 337,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Engine.S-Make",
      "library": "comby-kernel.matchers",
      "description": "This module implements matching and transformation operations over source code using templates and rules. It processes strings representing code templates and source files, applying matchers to find or transform patterns according to a given configuration. Use it to define custom code transformations or static analysis rules that operate on specific file extensions.",
      "description_length": 368,
      "index": 338,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Alpha.Haskell",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions for matching and rewriting Haskell source code using a specified template. It supports operations like finding all matches in a source file, retrieving the first match, and setting a rewrite template for transformations. The module works with Haskell AST expressions and Match.t structures, handling concrete syntax tree manipulations tailored for Haskell codebases. Use cases include automated code refactoring, linting, and pattern-based code analysis in Haskell projects.",
      "description_length": 505,
      "index": 339,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Matchers.Omega.Erlang",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions for matching Erlang source code against string templates, returning all matches or the first match with optional configuration and file context. It operates on Erlang AST expressions and supports concrete use cases like code analysis and transformation by leveraging pattern matching on source code. The module also allows setting rewrite templates, enabling targeted code refactoring based on matched patterns.",
      "description_length": 442,
      "index": 340,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Omega.HCL",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions for matching and transforming source code using HCL templates. It supports parsing and comparing HCL expressions with customizable configurations, returning matches or the first valid match with error handling. Use cases include code analysis, refactoring, and enforcing code patterns in HCL-based configuration files.",
      "description_length": 349,
      "index": 341,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Engine.S-Html",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions for matching and extracting data from HTML templates using expression rules. It supports operations to find all matches or the first match in a source string, with configurable templates and optional file context. Use cases include parsing and transforming HTML content based on structured patterns, such as extracting specific elements or injecting dynamic values.",
      "description_length": 396,
      "index": 342,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Omega.Nim",
      "library": "comby-kernel.matchers",
      "description": "This module implements pattern matching and transformation for Nim source code using custom templates. It provides functions to find all matches or the first match of a template in a source string, supporting configurable matching and error handling. The module works directly with Nim syntax trees and string-based templates, enabling use cases like automated code refactoring and static analysis rule enforcement.",
      "description_length": 415,
      "index": 343,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Languages.Xml",
      "library": "comby-kernel.matchers",
      "description": "This module handles XML syntax and metadata, defining tokenization rules with customizable delimiters, string literals, and comments, along with file identification through language name and extensions. Key operations include configuring parsers for XML fragments and retrieving metadata for file handling. For example, it enables parsing XML with custom syntax or determining how to process a file based on its `.xml` extension.",
      "description_length": 429,
      "index": 344,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Languages.Reason",
      "library": "comby-kernel.matchers",
      "description": "This module provides syntax and metadata configurations essential for parsing and identifying ReasonML code. It includes delimiters, string literals, comment styles, JSX tag handling, and language-specific extensions. Developers can use these components to build tools that accurately tokenize, process, or recognize ReasonML files based on syntax and naming conventions. For example, parsers can leverage its syntax rules to handle multiline strings or JSX, while tooling can detect Reason files using the provided extensions.",
      "description_length": 527,
      "index": 345,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Alpha.Fortran",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to match and transform Fortran source code using a specified template. It supports finding all matches, finding the first match with optional shifting, and setting a rewrite template for transformations. The module works directly with Fortran AST expressions, strings for source and template input, and Match.t structures for output. Use cases include automated code refactoring, pattern-based code analysis, and generating modified Fortran code from templates.",
      "description_length": 492,
      "index": 346,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Alpha.C",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to match and transform code patterns in string-based source code using a specified template. It supports finding all matches or the first match with optional configuration, file context, and template rewriting. Use cases include automated code refactoring, static analysis rule application, and syntactic pattern extraction in OCaml-like code.",
      "description_length": 374,
      "index": 347,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.External.Default",
      "library": "comby-kernel.matchers",
      "description": "Implements a handler function that processes structured input by extracting values based on name, file path, line, and column position. It operates on string-based data representations, typically used for parsing or matching textual content with positional metadata. This handler is useful in scenarios like log analysis or structured text parsing where context and location information are critical.",
      "description_length": 400,
      "index": 348,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Engine.S-Xml",
      "library": "comby-kernel.matchers",
      "description": "This module performs XML-specific matching operations using templates and source strings. It provides functions to find all matches or the first match, supporting optional configuration, file paths, and rule expressions. Use cases include validating XML structures, extracting data from XML documents, or transforming XML content using rewrite templates.",
      "description_length": 354,
      "index": 349,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Alpha.Tsx",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to match and extract data from TypeScript code using string templates. It supports finding all matches or the first match between a template and a source string, with configurable parsing options. Use cases include code analysis, transformation, and specific pattern extraction from TypeScript files.",
      "description_length": 331,
      "index": 350,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Engine.S-Elixir",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to match and transform code patterns in Elixir source files. It supports finding all matches or the first match of a given template in a source string, with options to configure matching behavior, shift positions, or specify file paths. The module works directly with Elixir AST expressions, strings as templates and sources, and returns structured match results or errors. Use cases include automated code refactoring, linting, and transformation based on syntactic patterns in Elixir code.",
      "description_length": 522,
      "index": 351,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Omega.CSS",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to match and extract data from CSS code using expression rules. It supports operations like `all` for finding all matches and `first` for retrieving the first match with optional configuration and source context. The module works with CSS templates and source strings, enabling use cases like parsing stylesheets or transforming CSS rules programmatically.",
      "description_length": 387,
      "index": 352,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Engine.S-Pascal",
      "library": "comby-kernel.matchers",
      "description": "This module implements matching and transformation operations for Pascal source code. It provides functions to find all matches or the first match of a template in a source string, supporting configurable matching via optional parameters. The module works directly with string-based templates and source code, returning structured match results that include details like positions and captured variables. It is used to implement custom code analysis and transformation tools targeting Pascal dialects.",
      "description_length": 501,
      "index": 353,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Engine.S-Java",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to match and transform Java code using pattern templates. It supports finding all matches or the first match in a source string, with optional configuration and file context. The module works with Java AST expressions and string-based templates, enabling use cases like code refactoring, static analysis, and automated code generation.",
      "description_length": 366,
      "index": 354,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Languages.Swift",
      "library": "comby-kernel.matchers",
      "description": "This module provides Swift-specific syntax definitions and language metadata for code analysis and transformation tasks. It includes data types for representing string literals, delimiters, comments, and file extensions, along with operations for parsing and matching Swift code patterns. You can use it to configure parsers, recognize Swift files, or manipulate Swift syntax elements programmatically. For example, it enables detecting raw strings or extracting comments from Swift source files based on defined delimiters.",
      "description_length": 524,
      "index": 355,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Alpha.Solidity",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to match and extract data from Solidity source code using a template-based approach. It supports operations like finding all matches or the first match of a given pattern, with configurable parameters such as file path and rule expressions. Use cases include static analysis of smart contracts, code transformation, and security auditing.",
      "description_length": 369,
      "index": 356,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Engine.S-Dhall",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions for matching and transforming Dhall configuration files using templates. It supports operations like finding all matches or the first match in a source string, with configurable parameters and error handling. The module works directly with Dhall expressions and strings, enabling concrete use cases such as validating Dhall syntax or rewriting configuration snippets based on predefined templates.",
      "description_length": 428,
      "index": 357,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Engine.S-Clojure",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions for matching and transforming Clojure code using templates. It supports operations like finding all matches, identifying the first match, and setting rewrite templates, working with Clojure source strings and expression lists. Use cases include code analysis, refactoring, and transformation tasks specific to Clojure syntax.",
      "description_length": 356,
      "index": 358,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Coq",
      "library": "comby-kernel.matchers",
      "description": "This module provides metadata and syntax definitions for the Coq language, enabling tools to identify Coq files via extensions and handle Coq-specific syntax constructs. It includes data types for strings and lists to manage language names, delimiters, string literals, and comment styles. Operations allow configuration of lexical parsers and AST manipulators for Coq code. For example, it supports identifying `.v` files as Coq sources and parsing Coq's custom delimiters and comments in linters or code transformers.",
      "description_length": 519,
      "index": 359,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Engine.S-Scala",
      "library": "comby-kernel.matchers",
      "description": "This module implements pattern matching and transformation operations over Scala code. It provides functions to find all matches or the first match of a template in a source file, with configurable analysis settings. The module works directly with Scala syntax trees, supporting concrete use cases like code refactoring, static analysis, and automated code transformations.",
      "description_length": 373,
      "index": 360,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages.Paren",
      "library": "comby-kernel.matchers",
      "description": "This module combines language metadata and syntax definitions to support parsing and categorizing source files. It uses strings and lists to store language names and extensions, while syntax elements like parentheses, string literals, and comments define parsing rules. You can identify files by extension, configure language-specific tokenization, or build parsers that handle nested structures and string escaping. For example, it enables associating `.lisp` files with specific bracket and comment handling during code analysis.",
      "description_length": 531,
      "index": 361,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Script.Make",
      "library": "comby-kernel.matchers",
      "description": "This module provides a domain-specific language for constructing and parsing logical expressions using S-expressions, centered around the `exp` and `atom` types that represent abstract syntax trees. It includes combinators for managing operator precedence, parenthetical grouping, and template expansion, enabling the creation of complex matcher specifications and custom scripting languages with nested logical conditions. The child module integrates lexing and parsing with Vangstrom, transforming template syntax into executable ASTs, supporting structured interpolation, variable substitution, and pattern-based rewriting of expressions. Examples include parsing `Hello, {{name}}` into a template that evaluates with dynamic bindings or rewriting logical expressions based on environment variables.",
      "description_length": 802,
      "index": 362,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Engine.S-SQL",
      "library": "comby-kernel.matchers",
      "description": "This module implements SQL-specific matching operations over source code and templates, returning lists or individual matches with optional configuration, file context, and rule constraints. It supports match result filtering, error handling for single matches, and dynamic rewrite template configuration. Concrete use cases include SQL query pattern detection, transformation validation, and linting rule enforcement.",
      "description_length": 418,
      "index": 363,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Alpha.Clojure",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to match Clojure code against string templates, supporting configurable pattern matching and AST-based analysis. It operates on Clojure source code and expression structures, returning match results or errors. Use it to find all matches in a source file, extract the first match, or configure templates for rewriting matched code.",
      "description_length": 361,
      "index": 364,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Omega.Tsx",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions for matching and transforming TypeScript code using a specified template. It operates on strings representing source code and templates, producing match results or transformed output. Use it to find patterns in TypeScript files or apply automated code transformations.",
      "description_length": 299,
      "index": 365,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Omega.Zig",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions for matching and extracting data from Zig source code using templates. It supports operations like `all` to find all matches and `first` to get the first match with optional configuration and file context. The module works with Zig source files, handles template-based pattern matching, and allows setting rewrite templates for transformations. Use cases include static analysis, code refactoring, and automated code generation based on Zig syntax patterns.",
      "description_length": 488,
      "index": 366,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Omega.Bash",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions for matching and extracting data from Bash source code using structured templates. It supports operations like finding all matches or the first match of a template in a source string, with configurable parsing and error handling. Use cases include static analysis of shell scripts, automated code transformation, and linting based on specific syntactic patterns.",
      "description_length": 393,
      "index": 367,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Omega.Go",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to match and extract data from Go source code using templates. It supports finding all matches or the first match in a source string, with configurable parameters like file path and rule expressions. Use cases include code analysis, refactoring, and generating match results from Go codebases.",
      "description_length": 324,
      "index": 368,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Alpha.Reason",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to match and transform code patterns in OCaml source files using a named rule with configurable behavior. It operates on strings representing source code and templates, producing match results or transformed code based on the defined rule. Use it to implement custom code transformations or static analysis checks over OCaml files with specific syntax patterns.",
      "description_length": 392,
      "index": 369,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Engine.S-Dart",
      "library": "comby-kernel.matchers",
      "description": "This module implements matching and transformation operations over Dart source code using string-based templates. It provides functions to find all matches or the first match of a template in a source file, with support for custom configurations, file paths, and rule expressions. The module works directly with Dart syntax trees through string representations and produces match results containing detailed metadata.",
      "description_length": 417,
      "index": 370,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Omega.Kotlin",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions for matching and transforming Kotlin code using predefined templates. It supports operations like finding all matches in a source file, retrieving the first match, and setting rewrite templates for code transformations. The module works directly with Kotlin AST expressions, strings representing source code, and match configurations, enabling concrete use cases such as automated code refactoring, linting, and generating code modifications based on structural patterns.",
      "description_length": 502,
      "index": 371,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Engine.S-Text",
      "library": "comby-kernel.matchers",
      "description": "This module performs text pattern matching using customizable templates and configurations. It supports operations to find all matches or the first match in a source string, with optional parameters for rule specification, file context, and shifting match positions. The module works directly with strings for both templates and source input, and returns structured match results or errors. Use cases include parsing log entries, extracting structured data from text files, and implementing custom text transformation rules.",
      "description_length": 524,
      "index": 372,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Languages.Jsx",
      "library": "comby-kernel.matchers",
      "description": "This module provides a framework for defining and parsing JSX-like syntax in custom languages, supporting configurable delimiters, string literals, and comments. It uses tuples, lists, and custom types to represent syntax patterns and metadata such as language name and file extensions. You can use it to build parsers that recognize JSX in templated code, configure how expressions and strings are interpreted, and associate file extensions with a custom JSX variant. For example, it enables defining a JSX-like syntax for a templating engine with custom delimiters and recognized by a specific file extension like `.myjsx`.",
      "description_length": 625,
      "index": 373,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Omega.Dyck",
      "library": "comby-kernel.matchers",
      "description": "This module implements Dyck language pattern matching for structured code analysis. It provides `all` to find all matches of a template in a source string and `first` to find the first match, both supporting configuration options and file context. The module works with string-based templates and sources, returning match results in a structured format. It is used to detect specific syntactic patterns in code, such as function calls or control structures, by matching against a defined template.",
      "description_length": 497,
      "index": 374,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Omega.Html",
      "library": "comby-kernel.matchers",
      "description": "This module provides functions to match and extract data from HTML content using templates. It supports finding all matches or the first match with customizable configuration, file paths, and rewrite templates. Use cases include parsing HTML documents for specific patterns, such as extracting links or content from web pages.",
      "description_length": 326,
      "index": 375,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Alpha.JSONC",
      "library": "comby-kernel.matchers",
      "description": "This module matches JSONC content against string templates, extracting structured matches with optional configuration and file context. It supports finding all matches or the first match, with error handling for partial results. Use cases include parsing and transforming JSONC configuration files with customizable templates and rule sets.",
      "description_length": 340,
      "index": 376,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Omega",
      "library": "comby-kernel.matchers",
      "description": "This module enables syntax-aware parsing and matching of structured text formats, handling context-sensitive constructs across programming languages and data formats. It provides core operations to define customizable matchers that identify patterns in hierarchical data, supporting tasks like code analysis, data validation, and dynamic matcher selection based on file type. Child modules extend this functionality to specific languages and formats\u2014such as Dart, F#, JSON, GraphQL, and Swift\u2014with APIs to find matches, apply rewrites, and enforce coding standards. Each submodule exposes data types like `Match.t` and `Or_error.t`, and operations including `all` and `first`, enabling precise transformations and static analysis across diverse codebases.",
      "description_length": 755,
      "index": 377,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.External",
      "library": "comby-kernel.matchers",
      "description": "This module provides a framework for building external matchers that produce optional string results based on location data such as file paths, line and column numbers. It defines core types like `t` for matcher configurations and operations for applying custom matching logic to identifiers and structured inputs. The handler modules extend this functionality by processing declarative matching rules on complex data structures and extracting values with positional metadata. Example uses include linting, error annotation, log analysis, and AST node transformation based on source position.",
      "description_length": 592,
      "index": 378,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Languages",
      "library": "comby-kernel.matchers",
      "description": "This module enables syntax-aware parsing and matching of structured text formats by combining language-specific implementations for programming languages, markup, query languages, and configuration files. It selects appropriate parsers based on file extensions and supports operations like code analysis, transformation, and validation using structured types such as delimiters, string literals, and comment markers. Child modules provide language-specific metadata and parsing rules\u2014such as handling nested comments in C-like code, parsing Dart strings, or recognizing HCL extensions\u2014while shared components allow defining custom syntax blocks, configuring escaping rules, and mapping file types to languages. Examples include parsing GraphQL queries with custom delimiters, identifying TypeScript files by `.ts` extension, and processing LaTeX documents with macro-aware syntax handling.",
      "description_length": 889,
      "index": 379,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Rewriter",
      "library": "comby-kernel.matchers",
      "description": "This module performs substitution and rewriting of string templates based on match environments. It handles metavariable replacement using customizable naming schemes and supports both in-place and newline-separated output modes. Concrete use cases include generating code from matched patterns and transforming source code during analysis or refactoring tasks.",
      "description_length": 361,
      "index": 380,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Matcher",
      "library": "comby-kernel.matchers",
      "description": "This module enables pattern matching and value extraction over structured data like trees and lists, with operations to define match rules, apply matchers, and compose conditions. It supports parsing expressions, validating data formats, and transforming ASTs, particularly in compilers or linters. The child module extends this by applying matchers to source code through customizable templates, allowing tasks like code analysis, transformation, and refactoring by identifying and modifying syntactic patterns. Together, they provide a powerful framework for both structural and syntactic pattern matching with customizable rules and result handling.",
      "description_length": 652,
      "index": 381,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Rule",
      "library": "comby-kernel.matchers",
      "description": "This module processes lists of AST expressions to define and apply structured matching rules, supporting metasyntax and external handling logic for code analysis or transformation tasks. It works with AST expressions, configuration options, and string-based rule definitions, offering operations for pattern matching, rewriting, and validation. The child module handles domain-specific syntax, including terminals like quoted strings and structured patterns, enabling equality checks and rewrite rules over a custom AST. A template processing submodule parses and resolves placeholders in strings, such as `\"user-{id}.txt\"`, extracting and substituting variables based on their sort and parsing rules.",
      "description_length": 701,
      "index": 382,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Ast",
      "library": "comby-kernel.matchers",
      "description": "This module defines data structures for representing abstract syntax trees used in pattern matching and rewriting. It includes types for atoms, antecedents, expressions, and consequents, supporting operations like equality checks, pattern matching, and term rewriting. Concrete use cases include parsing and evaluating logical expressions, transforming structured data based on patterns, and implementing custom rule-based systems.",
      "description_length": 431,
      "index": 383,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Metasyntax",
      "library": "comby-kernel.matchers",
      "description": "This module provides data structures and JSON serialization for metasyntax configurations used in pattern matching systems. It centers around types like `alias`, `hole_definition`, `hole_syntax`, and the top-level `t` that aggregates syntax rules, identifiers, and aliases. With this module, users can define and serialize metasyntax rules that drive pattern matching in templating engines or static analysis tools. Submodules organize related components such as hole syntax lists and identifier configurations, enabling structured extensions to pattern matching workflows.",
      "description_length": 573,
      "index": 384,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Specification",
      "library": "comby-kernel.matchers",
      "description": "This module defines a structure for specifying text matching and rewriting rules using templates and optional regex rules. It provides functions to convert specifications to regex patterns and handles serialization to and from S-expressions. It is used to define and manipulate text transformation rules for input parsing or code generation tasks.",
      "description_length": 347,
      "index": 385,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Template",
      "library": "comby-kernel.matchers",
      "description": "This module processes template syntax using structured data types like `kind`, `syntax`, `atom`, and `t`, enabling precise parsing, manipulation, and serialization of templates with variables, constants, and formatting rules. It supports conversion between S-expressions and these types, facilitating integration with configuration and code generation systems. Child modules enhance this functionality by providing hole-specific parsers using Vangstrom, allowing validation and transformation of placeholders, and enabling dynamic substitution of variables based on match environments. For example, a template like \"user-{id}.txt\" can be rendered as \"user-42.txt\" or parsed to extract `id` from an input string, supporting flexible text processing for routing, configuration, or log analysis.",
      "description_length": 792,
      "index": 386,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Evaluate",
      "library": "comby-kernel.matchers",
      "description": "This module evaluates matching results and manipulates match environments. It provides operations for applying match configurations to expressions, merging environments, and extracting result components. It works with match results, environments, and AST expressions, used in scenarios like evaluating pattern matches against source code templates with customizable substitution and external handling logic.",
      "description_length": 407,
      "index": 387,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Hole",
      "library": "comby-kernel.matchers",
      "description": "This module defines a set of named hole sorts (like `Expression`, `Alphanum`, and `Regex`) used to classify placeholder patterns in code, along with a structured type `t` that captures metadata such as identifier, dimension, and depth. It includes functions to convert sorts to and from JSON, and provides a list of all available sorts. Concrete use cases include parsing and matching code templates where placeholders must be semantically distinguished and later filled based on their classification.",
      "description_length": 501,
      "index": 388,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Alpha",
      "library": "comby-kernel.matchers",
      "description": "This module enables language-specific pattern matching and transformation across a wide range of programming languages and structured formats. It provides a unified interface for defining templates and extracting or rewriting code patterns, with support for AST-based operations, string templates, and file-level context. Each child module specializes in a particular language or format\u2014such as CSS, GraphQL, JSX, JSON, and more\u2014offering functions like `all` and `first` to find matches, and optional rewrite templates to transform code. Developers can enforce style rules, perform codemods, extract structured data, or automate refactoring tasks across languages including OCaml, JavaScript, Python, Java, and many others.",
      "description_length": 723,
      "index": 389,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Matchers.Script",
      "library": "comby-kernel.matchers",
      "description": "This module implements a domain-specific language for building and processing logical expressions using S-expressions, centered around the `exp` and `atom` types that model abstract syntax trees. It offers combinators for handling operator precedence, parenthetical grouping, and template expansion, enabling the construction of matcher specifications and custom scripting languages with nested logical conditions. The module integrates lexing and parsing via Vangstrom, converting template syntax into executable ASTs with support for structured interpolation, variable substitution, and pattern-based rewriting. For example, it can parse `Hello, {{name}}` into a template that evaluates with dynamic bindings or transform logical expressions based on environment variables.",
      "description_length": 775,
      "index": 390,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Language",
      "library": "comby-kernel.matchers",
      "description": "This module enables pattern matching and transformation of abstract syntax trees while coordinating with submodules that handle language metadata, parsing rules, and lexical configurations. It provides core operations for analyzing and manipulating syntactic structures like function calls and control flow, working with structured data such as expressions, patterns, and delimiters. Submodules support language identification by file extension, definition of comment styles and string literals, and JSON serialization of syntax rules, enabling use cases like linters, code refactoring tools, and custom DSL parsers. For example, you can detect a file\u2019s programming language, define custom delimiters for a templating engine, and serialize those rules to JSON for storage or transmission.",
      "description_length": 788,
      "index": 391,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Configuration",
      "library": "comby-kernel.matchers",
      "description": "This module defines configuration options for matching behavior, including exact or fuzzy match kinds, whitespace sensitivity, and newline handling. It provides a `create` function to construct configurations with customizable parameters like substring matching, toplevel newline matching, and substitution behavior. Use this to control parsing and matching rules in pattern-processing workflows.",
      "description_length": 396,
      "index": 392,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers.Engine",
      "library": "comby-kernel.matchers",
      "description": "This module defines a core interface for pattern matching engines, enabling the compilation of abstract patterns and execution of matches against input streams like strings or ASTs. It supports operations to extract matched groups, apply rewrite templates, and handle errors, forming the foundation for language-specific extensions. Child modules specialize this functionality to target specific languages and formats\u2014such as CSS, LaTeX, JSX, Erlang, Nim, Ruby, Swift, and many others\u2014providing concrete tools for code analysis, refactoring, linting, and transformation. Each submodule implements variations of `all` and `first` matchers that work with string-based or AST-based templates, configurable rules, and optional rewrites, enabling precise structural queries and edits across diverse codebases and data formats.",
      "description_length": 821,
      "index": 393,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Matchers",
      "library": "comby-kernel.matchers",
      "description": "This module enables syntax-aware pattern matching and transformation across structured text formats, programming languages, and data structures. It provides core data types such as `Match.t`, `Or_error.t`, `t` for matcher configurations, and structured types for ASTs, templates, and metasyntax rules, supporting operations like `all`, `first`, substitution, and rewriting. You can use it to analyze, validate, and refactor code in languages like JavaScript, Python, and Swift, process structured formats like JSON and GraphQL, or define and apply custom matching rules with metavariables and hole sorts. Specific examples include extracting values from log lines, enforcing coding standards via linters, rewriting code templates like `\"user-{id}.txt\"` with dynamic values, and performing AST-level transformations based on syntactic patterns and match environments.",
      "description_length": 866,
      "index": 394,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Vangstrom.Let_syntax.Let_syntax",
      "library": "comby-kernel.vangstrom",
      "description": "This module supports monadic and applicative composition of parsers using `let%bind`, `let%map`, and `let%both` syntax extensions provided by ppx_let. It enables concise chaining of parsing operations like `bind`, `map`, and `both` over values wrapped in the Vangstrom parser type. Use it to write readable, sequential-looking parser logic that handles input incrementally, such as parsing structured binary formats or custom text protocols.",
      "description_length": 441,
      "index": 395,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Vangstrom.Let_syntax",
      "library": "comby-kernel.vangstrom",
      "description": "This module integrates with ppx_let to enable `let%bind`, `let%map`, and `let%both` syntax for composing Vangstrom parsers in a clear, sequential style. It supports monadic and applicative operations like bind, map, and both, allowing structured parsing of binary formats or text encodings by chaining parser steps. Direct use of these let-syntax forms simplifies combining incremental parsing actions over Vangstrom.t values. For example, you can write a parser that reads a length-prefixed string by binding separate byte and string parsers in sequence.",
      "description_length": 555,
      "index": 396,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Vangstrom.BE",
      "library": "comby-kernel.vangstrom",
      "description": "This module provides big-endian binary parsers for fixed-size integers and floating-point numbers. It operates on binary input streams, consuming exact byte counts to decode values like 16/32/64-bit signed and unsigned integers, floats, and doubles. Use it to parse structured binary protocols or file formats that require strict big-endian decoding, such as network packets or binary file headers.",
      "description_length": 398,
      "index": 397,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Vangstrom.Unsafe",
      "library": "comby-kernel.vangstrom",
      "description": "This module exposes low-level, unsafe operations that directly manipulate Angstrom's internal buffer, allowing parsers to access and process raw input data without allocation. It provides functions like `take`, `take_while`, and `peek` that operate on `bigstring` buffers, enabling zero-copy parsing by passing slices of the internal buffer to user-defined callbacks. These functions are used in performance-critical parsers where avoiding memory allocations is essential, such as parsing large binary formats or high-throughput network protocols.",
      "description_length": 547,
      "index": 398,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Vangstrom.Unbuffered",
      "library": "comby-kernel.vangstrom",
      "description": "This module provides low-level parsing operations that require manual buffer management, enabling zero-copy input handling. It works directly with user-managed byte buffers and tracks parser progress through explicit state transitions. Concrete use cases include high-performance network protocol parsers and file format readers where precise control over memory usage and data copying is required.",
      "description_length": 398,
      "index": 399,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Vangstrom.Buffered",
      "library": "comby-kernel.vangstrom",
      "description": "This module provides functions for running parsers with internal buffering, handling input as `Bigstring` or `String`, and managing parser state transitions. It supports incremental input feeding via `feed`, extracting results with `state_to_option` and `state_to_result`, and retrieving unconsumed input via `state_to_unconsumed`. Concrete use cases include parsing streaming data from files or network sockets where input arrives in chunks and must be processed efficiently without full buffering upfront.",
      "description_length": 507,
      "index": 400,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Vangstrom.Consume",
      "library": "comby-kernel.vangstrom",
      "description": "This module provides functions to control how much of the input is consumed during parsing, specifically by determining whether to consume only a prefix of the input or all available input. It works with the `t` variant type that represents consumption modes. Concrete use cases include managing partial input consumption in streaming parsers or ensuring full input validation in batch parsing scenarios.",
      "description_length": 404,
      "index": 401,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Vangstrom.LE",
      "library": "comby-kernel.vangstrom",
      "description": "This module implements low-level parsers for reading and matching little-endian binary values from input streams. It operates directly on byte-level input, supporting precise parsing of signed and unsigned 16, 32, and 64-bit integers, as well as 32 and 64-bit floating-point numbers. These parsers are useful for decoding binary file formats, network protocols, or structured binary data where little-endian encoding is required.",
      "description_length": 429,
      "index": 402,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Vangstrom",
      "library": "comby-kernel.vangstrom",
      "description": "This module provides monadic and applicative parser combinators for building efficient, incremental parsers with unbounded lookahead over `bigstring` and `char` input streams. It supports both buffered and zero-copy unbuffered IO, enabling precise control over memory usage and input consumption through operations like `take_while`, `skip_while`, and manual buffer management. Child modules extend its core functionality with syntactic support for `let%bind` and `let%map`, big-endian and little-endian binary parsers, and low-level buffer manipulation for zero-copy parsing. For example, you can parse a length-prefixed string by chaining parsers using `let%bind`, or decode a binary file header using `BE.int32` to read big-endian integers directly from a byte buffer.",
      "description_length": 771,
      "index": 403,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Go.Syntax",
      "library": "comby-kernel",
      "description": "This module defines syntax-specific configurations for parsing and matching Go code, including delimiters for user-defined literals, escapable and raw string literals, and comment syntax. It provides precise string patterns and comment structures used in Go, enabling accurate pattern matching and code transformation tasks. Concrete use cases include parsing Go source files to identify string literals or comments with specific delimiters, and supporting tools like linters or formatters that require syntactic analysis of Go code.",
      "description_length": 533,
      "index": 404,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Lisp.Info",
      "library": "comby-kernel",
      "description": "This module defines metadata for the Lisp programming language, including its name and file extensions. It provides concrete values for identifying Lisp files, such as the canonical name and a list of associated extensions like `.lisp` and `.el`. This information is used in tooling that needs to recognize or process Lisp source files, such as parsers or syntax highlighters.",
      "description_length": 376,
      "index": 405,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Ruby.Info",
      "library": "comby-kernel",
      "description": "This module defines metadata for the Ruby programming language, including its name and file extensions. It provides direct access to the language name as a string and a list of associated file extensions. This information is used to identify and handle Ruby files in parsing and processing workflows.",
      "description_length": 300,
      "index": 406,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.JSONC.Syntax",
      "library": "comby-kernel",
      "description": "This module defines syntax elements for JSONC, including user-defined delimiters, escapable and raw string literals, and comment styles. It works with string pairs and syntax-specific options to configure parsing behavior. Concrete use cases include parsing JSONC files with custom delimiters and handling string escaping in JSONC syntax.",
      "description_length": 338,
      "index": 407,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.HCL.Info",
      "library": "comby-kernel",
      "description": "This module defines metadata for the HCL language, including its name and file extensions. It provides direct access to static information used for identifying and handling HCL files. Concrete use cases include configuring parsers or tools based on file extension or language name.",
      "description_length": 281,
      "index": 408,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Solidity.Syntax",
      "library": "comby-kernel",
      "description": "This module defines syntax-specific configurations for parsing and matching Solidity code. It specifies delimiters, string literals, and comment styles used in Solidity, such as escapable and raw string formats, and user-defined delimiters. These values are used to configure parsers for accurate pattern matching in Solidity source files.",
      "description_length": 339,
      "index": 409,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.JSON.Syntax",
      "library": "comby-kernel",
      "description": "This module defines syntax elements for parsing and matching JSON, including customizable delimiters, escapable and raw string literals, and comment styles. It works with string-based input to identify structural components like quoted values, escaped characters, and comment blocks. Concrete use cases include configuring parsers to handle JSON variations with different quoting or commenting conventions.",
      "description_length": 406,
      "index": 410,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Paren.Info",
      "library": "comby-kernel",
      "description": "This module defines metadata for a programming language, specifically its name and associated file extensions. It works with string and list data types to store and retrieve this information. A concrete use case is configuring language-specific settings in a code editor or analysis tool based on file extension or display name.",
      "description_length": 328,
      "index": 411,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Paren.Syntax",
      "library": "comby-kernel",
      "description": "This module defines syntax configurations for parenthetical languages, specifying delimiters, string literals, and comment styles. It provides explicit lists of user-defined delimiters, escapable and raw string literal markers, and comment syntax variations. These configurations enable parsing and matching of code patterns in languages with nested parentheses and custom syntax extensions.",
      "description_length": 391,
      "index": 412,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.R.Syntax",
      "library": "comby-kernel",
      "description": "This module defines syntax elements for parsing and matching R code, including user-defined delimiters, escapable and raw string literals, and comment styles. It provides precise specifications for identifying syntactic constructs in R source files. Use this module to configure parsers or pattern matchers that need to accurately recognize R language syntax.",
      "description_length": 359,
      "index": 413,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Rust.Info",
      "library": "comby-kernel",
      "description": "This module defines metadata for the Rust programming language, including its name and file extensions. It provides concrete values for identifying Rust source files, such as `\"rs\"` as the extension. Use this module when handling file-based language detection or configuration specific to Rust.",
      "description_length": 294,
      "index": 414,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Dart.Info",
      "library": "comby-kernel",
      "description": "This module defines metadata for the Dart programming language, including its name and file extensions. It provides the `name` value for identifying the language and `extensions` for recognizing Dart source files. Concrete use cases include configuring parsers or tools to handle Dart files based on their extensions.",
      "description_length": 317,
      "index": 415,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Scala.Syntax",
      "library": "comby-kernel",
      "description": "This module defines syntax-specific configurations for parsing and matching Scala code. It specifies delimiters, string literals, and comment styles used in Scala, such as triple-quote raw strings and single-line comments. These values guide pattern matching and transformation tools in accurately handling Scala source files.",
      "description_length": 326,
      "index": 416,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Elixir.Info",
      "library": "comby-kernel",
      "description": "This module defines metadata for the Elixir programming language, including its name and file extensions. It provides direct access to the language name as a string and a list of associated file extensions. This information is used to identify and handle Elixir source files in tooling such as parsers or linters.",
      "description_length": 313,
      "index": 417,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Latex.Syntax",
      "library": "comby-kernel",
      "description": "This module defines syntax elements for parsing and matching LaTeX code, including user-defined delimiters for macros, escapable and raw string literals, and comment styles. It supports concrete use cases like identifying LaTeX macros with custom syntax or handling verbatim text blocks. The data types include lists of string pairs for delimiters and literals, along with comment configurations specific to LaTeX.",
      "description_length": 414,
      "index": 418,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.C_nested_comments.Info",
      "library": "comby-kernel",
      "description": "This module defines metadata for a language variant that supports nested comments, including its name and file extensions. It works with string and list data types to specify identifiers and extension patterns. Concrete use cases include configuring parsers or tools that require recognition of nested comment syntax in source files.",
      "description_length": 333,
      "index": 419,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Fortran.Info",
      "library": "comby-kernel",
      "description": "This module defines metadata for the Fortran language, including its name and file extensions. It provides direct access to the language identifier and a list of associated file extensions. Use this module to retrieve Fortran-specific naming and extension information for file handling or language detection tasks.",
      "description_length": 314,
      "index": 420,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.OCaml.Info",
      "library": "comby-kernel",
      "description": "This module defines metadata for the OCaml language, including the language name and file extensions. It provides direct access to static information used for identifying and handling OCaml source files. Concrete use cases include configuring parsers or tools based on file extension or displaying language-specific settings.",
      "description_length": 325,
      "index": 421,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Scala.Info",
      "library": "comby-kernel",
      "description": "This module defines metadata for the Scala programming language, including its name and file extensions. It provides direct access to the language name as a string and a list of associated file extensions. This information is used for language identification and file handling in code analysis tools.",
      "description_length": 300,
      "index": 422,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Python.Syntax",
      "library": "comby-kernel",
      "description": "This module defines syntax elements specific to Python, including user-defined delimiters, escapable and raw string literals, and comment kinds. It provides precise string patterns and configurations for parsing and matching Python code structures. Use cases include implementing custom syntax parsers, code transformers, or static analysis tools that require accurate handling of Python's syntactic constructs.",
      "description_length": 411,
      "index": 423,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.GraphQL.Syntax",
      "library": "comby-kernel",
      "description": "This module defines syntax elements for parsing and matching GraphQL code, including customizable delimiters for strings, escapable and raw string literals, and comment styles. It supports precise pattern matching and transformation of GraphQL queries by specifying how different syntactic constructs should be interpreted. Concrete use cases include implementing linters, formatters, or code analysis tools that require accurate parsing of GraphQL schemas and operations.",
      "description_length": 472,
      "index": 424,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Move.Syntax",
      "library": "comby-kernel",
      "description": "This module defines syntax elements for the Move programming language, including user-defined delimiters, escapable and raw string literals, and comment kinds. It provides precise configurations for parsing and matching Move code in transformation and analysis tools. These definitions support accurate syntactic handling of Move source files in contexts like code rewriting and static analysis.",
      "description_length": 395,
      "index": 425,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.GraphQL.Info",
      "library": "comby-kernel",
      "description": "This module defines metadata for the GraphQL language, including its name and file extensions. It provides direct access to the language identifier and a list of associated file extensions. Useful for tools that need to recognize or process GraphQL files based on extension or name.",
      "description_length": 282,
      "index": 426,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Xml.Info",
      "library": "comby-kernel",
      "description": "This module defines metadata for XML language support, including the language name and file extensions. It provides direct access to the name as a string and a list of associated file extensions. This information is used to identify and handle XML files in tooling contexts like syntax parsing or file type detection.",
      "description_length": 317,
      "index": 427,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Reason.Syntax",
      "library": "comby-kernel",
      "description": "This module defines syntax elements for parsing and matching ReasonML code, including delimiters, string literals, and comments. It supports pattern matching over source code by specifying how to handle escapable and raw strings, as well as comment syntax. Concrete use cases include implementing custom code transformations and static analysis tools that require precise syntactic matching.",
      "description_length": 391,
      "index": 428,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Typescript.Info",
      "library": "comby-kernel",
      "description": "This module defines metadata for the TypeScript language, including its name and file extensions. It provides the `name` value as a string and `extensions` as a list of strings representing associated file extensions. This information is used to identify and handle TypeScript files in code analysis or transformation workflows.",
      "description_length": 328,
      "index": 429,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.SQL.Syntax",
      "library": "comby-kernel",
      "description": "This module defines syntax elements for SQL, including user-defined delimiters, escapable and raw string literals, and comment styles. It provides concrete configurations for parsing and matching SQL code patterns. Use this module to handle SQL-specific syntactic structures in code analysis or transformation tasks.",
      "description_length": 316,
      "index": 430,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Pascal.Syntax",
      "library": "comby-kernel",
      "description": "This module defines syntax elements for Pascal, including user-defined delimiters, escapable and raw string literals, and comment styles. It provides precise string patterns and configurations for parsing and matching Pascal code. Use this to customize or extend syntax handling in code analysis tools targeting Pascal.",
      "description_length": 319,
      "index": 431,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Csharp.Syntax",
      "library": "comby-kernel",
      "description": "This module defines syntax elements specific to C#, including user-defined delimiters for code boundaries, escapable and raw string literals, and comment styles. It provides precise string patterns and configurations that match C# syntax rules. These values are used directly for parsing and analyzing C# code, such as identifying string literals or stripping comments during code transformation or analysis tasks.",
      "description_length": 414,
      "index": 432,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Kotlin.Syntax",
      "library": "comby-kernel",
      "description": "This module defines syntax elements specific to Kotlin, including user-defined delimiters for string literals, escapable and raw string configurations, and comment kinds. It provides precise syntactic patterns for parsing and matching Kotlin code structures. Use cases include implementing custom parsers, formatters, or linters that require accurate recognition of Kotlin's string and comment syntax.",
      "description_length": 401,
      "index": 433,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Clojure.Info",
      "library": "comby-kernel",
      "description": "This module defines metadata for the Clojure programming language, including its name and file extensions. It provides direct access to the language identifier and a list of associated file extensions. This information is used for language detection and file association in code processing tools.",
      "description_length": 296,
      "index": 434,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.OCaml.Syntax",
      "library": "comby-kernel",
      "description": "This module defines syntax elements specific to OCaml, including user-defined delimiters, escapable and raw string literals, and comment kinds. It provides precise syntactic patterns used for parsing and matching OCaml code structures. Use this module when implementing custom syntax analysis or transformation tools that require accurate handling of OCaml's lexical elements.",
      "description_length": 376,
      "index": 435,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Java.Syntax",
      "library": "comby-kernel",
      "description": "This module defines syntax-specific configurations for parsing and matching Java code, including delimiters for user-defined tokens, escapable and raw string literals, and comment styles. It provides concrete values that specify how Java syntax elements are recognized and processed during pattern matching. Use this module when implementing or extending Java code analysis tools that require precise handling of string literals, comments, and custom token boundaries.",
      "description_length": 468,
      "index": 436,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Nim.Info",
      "library": "comby-kernel",
      "description": "This module defines metadata for the Nim programming language, including its name and file extensions. It provides direct access to the language name as a string and a list of associated file extensions. This information is used for language identification and file handling in tools that process Nim source files.",
      "description_length": 314,
      "index": 437,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Fortran.Syntax",
      "library": "comby-kernel",
      "description": "This module defines syntax elements for Fortran, including user-defined delimiters, escapable and raw string literals, and comment kinds. It supports parsing and matching Fortran code by specifying how strings and comments are structured in the language. Concrete use cases include configuring code transformation tools and implementing syntax-aware pattern matching for Fortran source files.",
      "description_length": 392,
      "index": 438,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Move.Info",
      "library": "comby-kernel",
      "description": "This module defines metadata for the Move programming language, including its name and file extensions. It provides direct access to the language name as a string and a list of associated file extensions. This information is used to identify and handle Move source files in tooling and parsing contexts.",
      "description_length": 303,
      "index": 439,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Ruby.Syntax",
      "library": "comby-kernel",
      "description": "This module defines syntax elements specific to Ruby, including user-defined delimiters, escapable and raw string literals, and comment styles. It provides precise pattern-matching capabilities for Ruby code by specifying how strings and comments are structured. Use cases include parsing Ruby source files, transforming code snippets, and identifying syntactic patterns in Ruby programs.",
      "description_length": 388,
      "index": 440,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Nim.Syntax",
      "library": "comby-kernel",
      "description": "This module defines syntax-specific configurations for the Nim programming language, including custom delimiters, escapable and raw string literals, and comment styles. It enables precise parsing and matching of Nim code by specifying how strings and comments are structured in the language. Concrete use cases include supporting pattern matching in code analysis tools or refactoring utilities that need to handle Nim's unique syntax features like triple-backtick raw strings or hash-based comments.",
      "description_length": 500,
      "index": 441,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Haskell.Syntax",
      "library": "comby-kernel",
      "description": "This module defines syntax-specific configurations for parsing and matching Haskell code. It specifies delimiters, escapable and raw string literals, and comment styles unique to Haskell. These values guide accurate pattern matching and transformation of Haskell source files in tools like code refactoring or analysis systems.",
      "description_length": 327,
      "index": 442,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Jsx.Info",
      "library": "comby-kernel",
      "description": "This module defines metadata for the JSX language, including its name and file extensions. It provides direct access to the language identifier and a list of associated file extensions. Useful for tools that need to recognize or process JSX files based on their extension or name.",
      "description_length": 280,
      "index": 443,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Clojure.Syntax",
      "library": "comby-kernel",
      "description": "This module defines syntax elements specific to Clojure, including user-defined delimiters, escapable and raw string literals, and comment kinds. It provides precise syntactic patterns for parsing and matching Clojure code structures. Use this module when implementing Clojure-specific code analysis, transformation, or templating tools that require accurate syntax handling.",
      "description_length": 375,
      "index": 444,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "Comby_kernel.Matchers.Language.Info.S",
      "library": "comby-kernel",
      "description": "This module defines metadata for a programming language, including its name and associated file extensions. It works with string and list data types to store and retrieve language-specific identifiers. Concrete use cases include determining file type based on extension or providing language names for tooling integration.",
      "description_length": 322,
      "index": 445,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Php.Info",
      "library": "comby-kernel",
      "description": "This module defines metadata for the PHP programming language, including its name and file extensions. It provides the `name` value as a string and `extensions` as a list of strings representing associated file extensions. This information is used to identify and handle PHP files in parsing and matching operations.",
      "description_length": 316,
      "index": 446,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Zig.Info",
      "library": "comby-kernel",
      "description": "This module defines metadata for the Zig programming language, including its name and file extensions. It provides direct access to the language name as a string and a list of associated file extensions. This information is used for language identification and file handling in tooling that processes Zig source files.",
      "description_length": 318,
      "index": 447,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Java.Info",
      "library": "comby-kernel",
      "description": "This module defines metadata for the Java programming language, including its name and file extensions. It provides the `name` value as a string and `extensions` as a list of strings representing associated file extensions. This information is used to identify and process Java source files in tooling contexts like parsing or analysis.",
      "description_length": 336,
      "index": 448,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Jsx.Syntax",
      "library": "comby-kernel",
      "description": "This module defines syntax elements for JSX, including user-defined delimiters, escapable and raw string literals, and comment kinds. It provides precise parsing and matching capabilities for JSX structures in source code analysis. Use cases include template matching and transformation of JSX syntax trees in code refactoring tools.",
      "description_length": 333,
      "index": 449,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.JSON.Info",
      "library": "comby-kernel",
      "description": "This module defines metadata for the JSON language, including its name and file extensions. It provides direct access to the language identifier and a list of associated file extensions. Useful for tools that need to recognize or process JSON files based on naming conventions or language-specific configuration.",
      "description_length": 312,
      "index": 450,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Elixir.Syntax",
      "library": "comby-kernel",
      "description": "This module defines syntax elements specific to Elixir, including user-defined delimiters, escapable and raw string literals, and comment kinds. It enables parsing and matching of Elixir code patterns by specifying how strings and comments are structured in the language. Concrete use cases include configuring code transformation tools and static analysis passes that require precise syntactic handling of Elixir source files.",
      "description_length": 427,
      "index": 451,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Typescript.Syntax",
      "library": "comby-kernel",
      "description": "This module defines syntax-specific configurations for parsing and matching TypeScript code. It specifies delimiters, escapable and raw string literals, and comment styles used in TypeScript. These values guide accurate pattern matching and transformation of TypeScript source code.",
      "description_length": 282,
      "index": 452,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Coq.Syntax",
      "library": "comby-kernel",
      "description": "This module defines syntax elements for parsing and matching Coq code, including user-defined delimiters, escapable and raw string literals, and comment styles. It provides concrete configurations for handling Coq-specific syntax constructs such as notations and string enclosures. Use this module to customize pattern matching and parsing behavior when working with Coq source files.",
      "description_length": 384,
      "index": 453,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Fsharp.Info",
      "library": "comby-kernel",
      "description": "This module defines metadata for the F# programming language, including its name and file extensions. It provides direct access to the language name as a string and a list of associated file extensions. This information is used to identify and handle F# source files in tooling contexts like syntax parsing and code transformation.",
      "description_length": 331,
      "index": 454,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Matlab.Syntax",
      "library": "comby-kernel",
      "description": "This module defines syntax elements for parsing and matching MATLAB code, including user-defined delimiters, escapable and raw string literals, and comment styles. It provides precise syntactic rules to identify and handle MATLAB-specific constructs during pattern matching or code transformation tasks. Use cases include implementing custom code analysis tools or refactoring scripts that require accurate recognition of MATLAB syntax features.",
      "description_length": 445,
      "index": 455,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Elm.Syntax",
      "library": "comby-kernel",
      "description": "This module defines syntax elements for parsing and matching Elm code, including user-defined delimiters, escapable and raw string literals, and comment styles. It provides precise string patterns and configurations that match Elm's syntactic constructs. Use this module to handle Elm-specific syntax when performing code transformations or pattern matching in source code analysis tools.",
      "description_length": 388,
      "index": 456,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Generic.Syntax",
      "library": "comby-kernel",
      "description": "This module defines syntax elements for parsing and matching code in a generic language, including user-defined delimiters, escapable and raw string literals, and comment styles. It provides concrete configurations for recognizing syntactic constructs during pattern matching or transformation tasks. Use this module to customize syntax handling for a specific language when implementing code analysis or refactoring tools.",
      "description_length": 423,
      "index": 457,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Assembly.Syntax",
      "library": "comby-kernel",
      "description": "This module defines syntax elements for parsing assembly code, including user-defined delimiters, escapable and raw string literals, and comment styles. It provides precise configurations for tokenizing and recognizing assembly language constructs. Use this to customize parsing behavior for different assembly dialects, such as handling specific macro syntax or comment conventions.",
      "description_length": 383,
      "index": 458,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Csharp.Info",
      "library": "comby-kernel",
      "description": "This module defines metadata for the C# language, including the language name and file extensions. It provides direct access to static values that identify and associate files with the C# programming language. This is used primarily in tooling that processes or analyzes C# source code files based on their naming conventions.",
      "description_length": 326,
      "index": 459,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.CSS.Syntax",
      "library": "comby-kernel",
      "description": "This module defines syntax-specific configurations for parsing and matching CSS code. It specifies delimiters, escapable and raw string literals, and comment styles used in CSS. These values guide pattern matching and transformation tasks tailored to CSS syntax, such as identifying selectors, properties, or embedded values.",
      "description_length": 325,
      "index": 460,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Bash.Syntax",
      "library": "comby-kernel",
      "description": "This module defines syntax elements for parsing and matching Bash scripts, including customizable delimiters, escapable and raw string literals, and comment styles. It supports concrete use cases like pattern matching in shell scripts, handling quoted strings with escapes, and identifying comment blocks. The data types include lists of string pairs for delimiters and literals, and options for escapable string configurations.",
      "description_length": 428,
      "index": 461,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Language.Syntax.S",
      "library": "comby-kernel",
      "description": "This module defines the syntax elements for a programming language used in pattern matching. It specifies delimiters, escapable and raw string literals, and comment styles. Use this to configure language-specific syntax rules for parsing and matching code structures.",
      "description_length": 267,
      "index": 462,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Dart.Syntax",
      "library": "comby-kernel",
      "description": "This module defines syntax elements specific to Dart, including user-defined delimiters, escapable and raw string literals, and comment kinds. It provides precise syntactic patterns for parsing and matching Dart code structures. Use this module to handle Dart-specific lexical constructs in code analysis or transformation tasks.",
      "description_length": 329,
      "index": 463,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Coq.Info",
      "library": "comby-kernel",
      "description": "This module defines metadata for the Coq programming language, including its name and file extensions. It provides direct access to the language's identifier and supported file extension list. This information is used for configuration and file recognition in tools processing Coq source files.",
      "description_length": 294,
      "index": 464,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Pascal.Info",
      "library": "comby-kernel",
      "description": "This module defines metadata for Pascal language support, including the language name and file extensions. It provides concrete values for identifying Pascal source files, such as `.pas`. Useful for tools that need to recognize or process Pascal files based on extension or name.",
      "description_length": 279,
      "index": 465,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.C.Syntax",
      "library": "comby-kernel",
      "description": "This module defines syntactic elements specific to the C language for parsing and matching code patterns. It specifies delimiters, string literals, and comment styles used in C, such as `/* */` for block comments and `//` for line comments. It is used to configure pattern matching tools to correctly identify and handle C syntax constructs during code analysis or transformation tasks.",
      "description_length": 386,
      "index": 466,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Swift.Info",
      "library": "comby-kernel",
      "description": "This module defines metadata for the Swift programming language, including its name and file extensions. It provides direct access to the language name as a string and a list of associated file extensions. This information is used for language identification and file handling in code analysis tools.",
      "description_length": 300,
      "index": 467,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Javascript.Syntax",
      "library": "comby-kernel",
      "description": "This module defines syntax-specific configurations for JavaScript, including delimiters for string literals, escapable and raw string formats, and comment styles. It provides precise parsing rules for handling JavaScript code in pattern matching tasks. Use this module when implementing JavaScript-aware matching logic for code transformations or static analysis.",
      "description_length": 363,
      "index": 468,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Xml.Syntax",
      "library": "comby-kernel",
      "description": "This module defines syntax elements for XML parsing, including user-defined delimiters, escapable and raw string literals, and comment structures. It supports precise pattern matching and transformation of XML content by specifying how different syntactic components are recognized. Concrete use cases include parsing XML documents with custom tags, handling embedded expressions, and processing comments or string literals with specific escaping rules.",
      "description_length": 453,
      "index": 469,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.HCL.Syntax",
      "library": "comby-kernel",
      "description": "This module defines syntax elements for HCL (HashiCorp Configuration Language), including user-defined delimiters, escapable and raw string literals, and comment kinds. It provides precise syntactic patterns used to parse and match HCL configurations. Use this module when implementing HCL-specific matching logic, such as in code analysis or transformation tools.",
      "description_length": 364,
      "index": 470,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Assembly.Info",
      "library": "comby-kernel",
      "description": "This module defines metadata for assembly languages, including the language name and file extensions. It provides direct access to static information used for identifying and handling assembly source files. Concrete use cases include configuring parsers or tools that require language-specific file extension matching.",
      "description_length": 318,
      "index": 471,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Bash.Info",
      "library": "comby-kernel",
      "description": "This module defines metadata for the Bash language, including its name and file extensions. It provides direct access to the language identifier and a list of associated file extensions. Useful for tools that need to recognize or process Bash files based on naming conventions.",
      "description_length": 277,
      "index": 472,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Erlang.Syntax",
      "library": "comby-kernel",
      "description": "This module defines syntax-specific configurations for Erlang, including delimiters for string literals, escapable and raw string formats, and comment styles. It provides concrete syntax rules that guide parsing and matching operations in Erlang code. These configurations are used directly during pattern matching and code transformation tasks specific to Erlang.",
      "description_length": 364,
      "index": 473,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Php.Syntax",
      "library": "comby-kernel",
      "description": "This module defines syntax-specific configurations for PHP, including delimiters for user-defined strings, escapable and raw string literals, and comment styles. It provides precise syntactic patterns used for parsing and matching PHP code structures. Concrete use cases include identifying string boundaries, handling heredoc syntax, and distinguishing between different comment types in PHP source analysis.",
      "description_length": 409,
      "index": 474,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Erlang.Info",
      "library": "comby-kernel",
      "description": "This module defines metadata for the Erlang language, including its name and file extensions. It provides direct access to the language name as a string and a list of associated file extensions. This information is used to identify and handle Erlang source files in tooling that processes or analyzes code.",
      "description_length": 306,
      "index": 475,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Text.Syntax",
      "library": "comby-kernel",
      "description": "This module defines syntax elements for text-based languages, including user-defined delimiters, escapable and raw string literals, and comment styles. It provides concrete configurations for parsing and matching textual content with specific syntactic rules. Use cases include setting up custom syntax rules for domain-specific text processing or extending language support in code analysis tools.",
      "description_length": 398,
      "index": 476,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Dyck.Info",
      "library": "comby-kernel",
      "description": "This module defines metadata for a language called Dyck, including its name and associated file extensions. It provides direct access to the language's identifier and a list of its common file extensions. This information supports tools that need to recognize or process Dyck language files based on naming conventions.",
      "description_length": 319,
      "index": 477,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.JSONC.Info",
      "library": "comby-kernel",
      "description": "This module defines metadata for the JSONC language, including its name and file extensions. It provides direct access to the language identifier and a list of associated file extensions. Use this module to retrieve JSONC-specific naming and extension information for file handling or language detection tasks.",
      "description_length": 310,
      "index": 478,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.C_nested_comments.Syntax",
      "library": "comby-kernel",
      "description": "This module defines syntax elements for handling C-style nested comments, including configurable delimiters for strings and comments. It supports parsing and manipulation of escapable and raw string literals, as well as identifying different kinds of comments. Concrete use cases include implementing custom parsers for C-like languages and processing source code with nested commenting structures.",
      "description_length": 398,
      "index": 479,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Fsharp.Syntax",
      "library": "comby-kernel",
      "description": "This module defines syntax elements for F# code matching, including user-defined delimiters, escapable and raw string literals, and comment styles. It provides precise pattern recognition for F# source code analysis and transformation tasks. Use cases include parsing F# scripts, identifying string and comment patterns, and supporting code refactoring tools.",
      "description_length": 359,
      "index": 480,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Go.Info",
      "library": "comby-kernel",
      "description": "This module defines metadata for the Go programming language, including its name and file extensions. It provides concrete values for identifying Go source files, such as `\"go\"` as the name and `[\".go\"]` as the list of extensions. This information is used in tooling that processes or categorizes source code files based on language.",
      "description_length": 333,
      "index": 481,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Kotlin.Info",
      "library": "comby-kernel",
      "description": "This module defines metadata for the Kotlin programming language, including its name and file extensions. It provides direct access to the language name as a string and a list of associated file extensions. This information is used to identify and handle Kotlin files in code processing tasks such as parsing and matching.",
      "description_length": 322,
      "index": 482,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Python.Info",
      "library": "comby-kernel",
      "description": "This module defines metadata for the Python language, including its name and file extensions. It provides direct access to the language identifier and a list of associated file extensions. Useful for tools that need to recognize or process Python files based on naming conventions.",
      "description_length": 281,
      "index": 483,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Rust.Syntax",
      "library": "comby-kernel",
      "description": "This module defines syntax-specific configurations for parsing and matching Rust code. It specifies delimiters, string literals, and comment styles unique to Rust, enabling precise pattern matching and transformation. Use cases include implementing custom code analysis or refactoring tools that require accurate handling of Rust syntax elements.",
      "description_length": 346,
      "index": 484,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Lisp.Syntax",
      "library": "comby-kernel",
      "description": "This module defines syntax elements for parsing and matching Lisp-like languages, including customizable delimiters for string literals, escapable and raw string formats, and comment syntax. It supports concrete use cases such as identifying s-expressions, handling quoted strings with escapes, and recognizing line and block comments. The data types include lists of string pairs for delimiters and variants for comment kinds.",
      "description_length": 427,
      "index": 485,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Dhall.Info",
      "library": "comby-kernel",
      "description": "This module defines metadata for the Dhall configuration language, including its name and file extensions. It provides direct access to the language identifier and a list of associated file extensions. Useful for tooling that needs to recognize or process Dhall files based on extension or name.",
      "description_length": 295,
      "index": 486,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Tsx.Syntax",
      "library": "comby-kernel",
      "description": "This module defines syntax-specific configurations for parsing and matching in TSX, including delimiters for embedding expressions, escapable and raw string literals, and comment syntax. It supports precise pattern matching and transformation of TSX code by specifying how different syntactic elements are represented. Concrete use cases include implementing custom linters, code refactoring tools, and syntax highlighters that require accurate parsing of TSX constructs.",
      "description_length": 471,
      "index": 487,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.CSS.Info",
      "library": "comby-kernel",
      "description": "This module defines metadata for CSS language support, including the language name and file extensions. It provides direct access to predefined values that identify CSS files, such as `.css`. Use this module when integrating CSS parsing or processing tools that rely on file extension or language name detection.",
      "description_length": 312,
      "index": 488,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Julia.Syntax",
      "library": "comby-kernel",
      "description": "This module defines syntax elements specific to the Julia programming language, including user-defined delimiters, escapable and raw string literals, and comment kinds. It enables precise parsing and matching of Julia code by specifying how strings and comments are structured in the language. Concrete use cases include configuring code transformation tools or linters to correctly handle Julia's string interpolation and comment syntax.",
      "description_length": 438,
      "index": 489,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Html.Syntax",
      "library": "comby-kernel",
      "description": "This module defines syntax elements for HTML, including user-defined delimiters, escapable and raw string literals, and comment kinds. It provides precise parsing and matching capabilities for HTML structures, enabling accurate template and pattern recognition. Use cases include HTML template parsing, syntax highlighting, and structured code transformations.",
      "description_length": 360,
      "index": 490,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Swift.Syntax",
      "library": "comby-kernel",
      "description": "This module defines syntax-specific configurations for Swift, including delimiters for string literals, comment styles, and escaping rules. It specifies raw string delimiters, user-defined delimiters, and optional handling for escapable string literals. These values are used to parse and match Swift code patterns accurately, such as identifying multi-line strings or comment blocks during code transformation or analysis tasks.",
      "description_length": 429,
      "index": 491,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Zig.Syntax",
      "library": "comby-kernel",
      "description": "This module defines syntactic elements specific to the Zig programming language, including user-defined delimiters, escapable and raw string literals, and comment kinds. It provides precise string patterns and configurations that match Zig's syntax rules for parsing and transformation tasks. These values are used directly in tokenizing or analyzing Zig code, such as identifying string boundaries or skipping comments during structural comparisons.",
      "description_length": 450,
      "index": 492,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Latex.Info",
      "library": "comby-kernel",
      "description": "This module defines metadata for the LaTeX language, including its name and file extensions. It provides direct access to the language name as a string and a list of associated file extensions. This information is used to identify and handle LaTeX files in parsing and processing workflows.",
      "description_length": 290,
      "index": 493,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Elm.Info",
      "library": "comby-kernel",
      "description": "This module defines metadata for the Elm programming language, including its name and file extensions. It provides direct access to the language identifier and a list of associated file extensions. Use this module to retrieve Elm-specific naming and extension information for tooling or configuration purposes.",
      "description_length": 310,
      "index": 494,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Julia.Info",
      "library": "comby-kernel",
      "description": "This module defines metadata for the Julia programming language, including its name and file extensions. It provides direct access to the language name as a string and a list of associated file extensions. This information is used for language identification and file handling in code analysis tools.",
      "description_length": 300,
      "index": 495,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Dhall.Syntax",
      "library": "comby-kernel",
      "description": "This module defines syntax elements for parsing and matching Dhall code, including user-defined delimiters, escapable and raw string literals, and comment styles. It provides concrete configurations for handling Dhall-specific syntax features like multi-line strings and comment blocks. Use cases include building parsers or transformers that accurately recognize Dhall's syntax constructs during pattern matching or code analysis.",
      "description_length": 431,
      "index": 496,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Reason.Info",
      "library": "comby-kernel",
      "description": "This module defines metadata for the Reason programming language, including its name and file extensions. It provides direct access to the language name as a string and a list of associated file extensions. This information is used to identify and handle Reason source files in tooling contexts like parsing and transformation workflows.",
      "description_length": 337,
      "index": 497,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.C.Info",
      "library": "comby-kernel",
      "description": "This module defines metadata for the C programming language, including its name and file extensions. It provides direct access to the language name as a string and a list of associated file extensions. This information is used to identify and handle C source files in parsing and matching workflows.",
      "description_length": 299,
      "index": 498,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Haskell.Info",
      "library": "comby-kernel",
      "description": "This module defines metadata for the Haskell programming language, including its name and file extensions. It provides direct access to constants that identify Haskell source files, such as `.hs` and `.lhs`. This information is used in tooling that needs to recognize or process Haskell files, such as parsers or language servers.",
      "description_length": 330,
      "index": 499,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Matlab.Info",
      "library": "comby-kernel",
      "description": "This module defines metadata for the MATLAB programming language, including its name and file extensions. It provides the `name` and `extensions` values to identify and associate files with MATLAB syntax. This information is used for language detection and file handling in contexts like code parsing or editor integration.",
      "description_length": 323,
      "index": 500,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Text.Info",
      "library": "comby-kernel",
      "description": "This module defines metadata for text-based languages, including the language name and associated file extensions. It works with string and list data types to store and retrieve this information. Concrete use cases include identifying language-specific files and configuring text processing tools based on file extension or name.",
      "description_length": 329,
      "index": 501,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Tsx.Info",
      "library": "comby-kernel",
      "description": "This module defines metadata for the TSX language, including its name and file extensions. It provides direct access to the language identifier and a list of associated file extensions. Useful for tools that need to recognize or process TSX files based on their extension or name.",
      "description_length": 280,
      "index": 502,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Generic.Info",
      "library": "comby-kernel",
      "description": "This module defines metadata for a generic programming language, including its name and file extensions. It provides direct access to these properties through the `name` and `extensions` values. Useful for language detection and configuration in tools that process source files based on extension or name.",
      "description_length": 305,
      "index": 503,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Html.Info",
      "library": "comby-kernel",
      "description": "This module defines metadata for HTML language support, including the language name and file extensions. It provides the `name` and `extensions` values used to identify and associate files with HTML syntax. Concrete use cases include configuring parsers or editors to recognize HTML files based on extension or language name.",
      "description_length": 325,
      "index": 504,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Solidity.Info",
      "library": "comby-kernel",
      "description": "This module defines metadata for the Solidity programming language, including its name and file extensions. It provides direct access to the language identifier and a list of associated file extensions. Useful for tooling that needs to recognize or process Solidity source files based on extension or name.",
      "description_length": 306,
      "index": 505,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Dyck.Syntax",
      "library": "comby-kernel",
      "description": "This module defines syntax elements for handling delimiters, string literals, and comments in a structured format. It provides explicit lists of user-defined delimiters, escapable and raw string literal markers, and comment styles. It is used to configure parsing behavior for languages requiring precise syntactic recognition, such as query or transformation engines analyzing structured text.",
      "description_length": 394,
      "index": 506,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.R.Info",
      "library": "comby-kernel",
      "description": "This module defines metadata for the R programming language, including its name and file extensions. It provides direct access to the language's identifier and a list of associated file extensions. Use this module to retrieve R-specific naming and extension information for file handling or language detection tasks.",
      "description_length": 316,
      "index": 507,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.SQL.Info",
      "library": "comby-kernel",
      "description": "This module defines metadata for SQL language support, including the language name and file extensions. It provides concrete values for identifying SQL files and handling their specific characteristics. Useful for tools that process or analyze SQL files based on their extension or language name.",
      "description_length": 296,
      "index": 508,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Javascript.Info",
      "library": "comby-kernel",
      "description": "This module defines metadata for JavaScript, including the language name and file extensions. It provides direct access to the name as a string and the extensions as a list of strings. This information is used to identify and handle JavaScript files in tooling contexts like parsing or transformation pipelines.",
      "description_length": 311,
      "index": 509,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Alpha.Haskell",
      "library": "comby-kernel",
      "description": "This module implements Haskell-specific pattern matching operations for source code analysis, supporting template-based matching with configurable recursion. It operates on string inputs representing source code and templates, producing lists of matches or individual match results. Use cases include finding all instances of a Haskell code pattern within a file or identifying the first occurrence starting at a specific position.",
      "description_length": 431,
      "index": 510,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Bash",
      "library": "comby-kernel",
      "description": "This module provides facilities for analyzing and working with Bash scripts through customizable syntax parsing and language metadata. It supports operations like pattern matching in shell scripts, handling quoted and escaped strings, and identifying comments using configurable delimiters and literals. Key data types include string pairs for delimiters and options for escapable string configurations, along with direct access to Bash language identifiers and common file extensions. You can use it to parse script content, extract comments, or recognize Bash files based on their extension.",
      "description_length": 593,
      "index": 511,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Engine.S-Elixir",
      "library": "comby-kernel",
      "description": "This module provides functions to find all or the first matches of a template in Elixir source code, supporting nested matching through a configuration flag. It operates on strings for both template and source inputs, returning lists of match results or error-handled single matches. Use cases include structural code analysis and transformation tasks specific to Elixir, such as identifying function calls or pattern-based refactorings.",
      "description_length": 437,
      "index": 512,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Engine.S-Javascript",
      "library": "comby-kernel",
      "description": "This module provides functions to match JavaScript code patterns using templates, supporting both full and first-match scans with configurable parameters. It operates on JavaScript source code strings and returns structured match results with positional and contextual details. Use cases include static code analysis, automated refactoring, and pattern-based code search in JavaScript projects.",
      "description_length": 394,
      "index": 513,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Omega.Solidity",
      "library": "comby-kernel",
      "description": "This module provides functions to match Solidity code patterns using templates, supporting both full and first-match scans with configurable parameters. It operates on Solidity source code strings and returns structured match results, supporting nested matching when enabled. Use cases include static analysis and code transformation tasks specific to Solidity smart contracts.",
      "description_length": 377,
      "index": 514,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Metasyntax.Default",
      "library": "comby-kernel",
      "description": "This module defines the default metasyntax configuration for parsing and matching, including a list of hole syntax rules, an identifier string, and a list of aliases. It is used to specify placeholder patterns and their representations in concrete syntax trees. Typical use cases include configuring parsers to recognize variables, wildcards, or structured placeholders in code transformation tools.",
      "description_length": 399,
      "index": 515,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Omega.Reason",
      "library": "comby-kernel",
      "description": "This module provides functions to match templates against source code, supporting both full and first-match scans with configurable parameters. It operates on strings for templates and source code, returning lists of matches or individual match results. Use cases include finding all occurrences of a pattern in a file or identifying the first match starting at a specific position.",
      "description_length": 382,
      "index": 516,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Alpha.Scala",
      "library": "comby-kernel",
      "description": "This module provides functions to match Scala code against templates, returning all matches or the first match with optional configuration and positional control. It operates on strings representing source code and templates, producing lists of match results or error-handled single matches. Use cases include finding specific code patterns in Scala files, such as locating method definitions or expressions, with support for recursive matching when enabled.",
      "description_length": 458,
      "index": 517,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Engine.S-CSS",
      "library": "comby-kernel",
      "description": "This module provides functions to match CSS templates against source code, returning all matches or the first match with optional configuration and file context. It operates on strings representing CSS templates and source code, producing lists of match results or error-handled single matches. Use cases include finding CSS rule matches in stylesheets, supporting nested matching for recursive structures, and identifying matches starting from specific positions.",
      "description_length": 464,
      "index": 518,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Language.S-Info",
      "library": "comby-kernel",
      "description": "This module defines metadata for a programming language, including its name and file extensions. It works with string and list data types to store and retrieve this information. Concrete use cases include identifying language-specific files during parsing or analysis tasks.",
      "description_length": 274,
      "index": 519,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Omega.C",
      "library": "comby-kernel",
      "description": "This module provides functions to match code templates against C source code, supporting both full and first-occurrence matching with optional configuration and nested matching. It operates on strings representing code templates and source files, returning structured match results. Use cases include finding specific code patterns in C files, such as identifying function calls or structural elements, with support for recursive matching when enabled.",
      "description_length": 452,
      "index": 520,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Alpha.Paren",
      "library": "comby-kernel",
      "description": "This module provides functions to match and find occurrences of a template within a source string, supporting nested matching and returning all matches or only the first one. It works with strings as input and outputs structured match results, using optional configuration parameters and positional shifts. Use cases include parsing and transforming structured text like code or markup, where precise pattern extraction or replacement is needed.",
      "description_length": 445,
      "index": 521,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Alpha.Fsharp",
      "library": "comby-kernel",
      "description": "This module implements F#-specific pattern matching operations for code transformation tasks. It provides functions to find all or the first occurrence of a code template within a source string, supporting recursive matching when enabled. The module works with string-based templates and source code inputs, returning structured match results with language-specific handling for F#.",
      "description_length": 382,
      "index": 522,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Alpha.SQL",
      "library": "comby-kernel",
      "description": "This module provides functions to match SQL templates against source code, returning all matches or the first match with optional configuration and positional control. It operates on strings representing SQL code and templates, producing structured match results. Use cases include finding specific SQL query patterns in database scripts or analyzing SQL injection vulnerabilities.",
      "description_length": 381,
      "index": 523,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Omega.Typescript",
      "library": "comby-kernel",
      "description": "This module provides functions to match TypeScript code patterns against source code, supporting both full and first-occurrence matching with configurable parameters. It operates on strings representing code templates and source files, returning structured match results. Use cases include code analysis, transformation, and querying within TypeScript projects.",
      "description_length": 361,
      "index": 524,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Engine.S-Elm",
      "library": "comby-kernel",
      "description": "This module performs structural matching of code templates against source code, supporting both first-match and all-matches operations with optional nested matching. It works with string-based templates and source code, returning lists or individual match records containing detailed match information. It is used for language-specific pattern matching in code transformation and analysis tasks, such as finding function calls or syntactic constructs in source files.",
      "description_length": 467,
      "index": 525,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Metasyntax.S",
      "library": "comby-kernel",
      "description": "This module defines the syntax elements and identifiers used to parameterize a matcher, including a list of hole syntax configurations, an identifier string, and a list of aliases. It works with structured data types like `hole_syntax` and `alias` to customize matching behavior. Concrete use cases include configuring pattern matching rules for code transformation tools or query engines that require customizable syntax handling.",
      "description_length": 431,
      "index": 526,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Omega.Dyck",
      "library": "comby-kernel",
      "description": "This module implements Dyck language matching for structured source code analysis, providing `all` and `first` functions to find matches of a template within a source string. It works with strings representing code and templates, returning lists or individual match records containing positional and structural information. Use cases include finding nested or recursive patterns in code, such as matching balanced parentheses or structured control flow constructs in a specific programming language.",
      "description_length": 499,
      "index": 527,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Reason",
      "library": "comby-kernel",
      "description": "This module provides syntactic and metadata utilities for working with ReasonML code. It includes parsers for string literals, comments, and delimiters to enable precise pattern matching and code transformation, along with language metadata such as file extensions and name. You can use it to build custom static analysis tools, code formatters, or language-aware utilities that process `.re` and `.rei` files directly. For example, it allows matching specific comment structures or extracting raw strings for processing in linters or refactoring tools.",
      "description_length": 553,
      "index": 528,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Language.S-Syntax",
      "library": "comby-kernel",
      "description": "This module defines syntax-specific configurations for parsing and matching code patterns, including delimiters for user-defined literals, escapable and raw string literals, and comment syntax. It works with string-based data structures and syntax definitions to support precise pattern matching in code analysis tasks. Concrete use cases include configuring language-specific parsers for tools like code linters, refactoring engines, and static analyzers.",
      "description_length": 456,
      "index": 529,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Alpha.Jsx",
      "library": "comby-kernel",
      "description": "This module provides functions to match and find occurrences of string templates within JSX source code, supporting nested matching and first-occurrence searches with optional configuration and file context. It operates on strings representing JSX content and templates, returning structured match results. Use cases include code analysis, transformation, and pattern-based querying in JSX files.",
      "description_length": 396,
      "index": 530,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Alpha.Javascript",
      "library": "comby-kernel",
      "description": "This module provides functions to match JavaScript code patterns using templates, supporting both full and first-match scans with configurable parameters. It operates on string-based source code and template inputs, returning structured match results with optional nested matching. Use cases include code analysis, transformation, and search tasks specific to JavaScript, such as identifying function calls or variable declarations.",
      "description_length": 432,
      "index": 531,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Omega.Clojure",
      "library": "comby-kernel",
      "description": "This module provides functions to match Clojure code patterns using templates, supporting both full and first-match scans with configurable nesting. It operates on Clojure source code strings and returns structured match results. Use cases include code analysis, transformation, and search tasks specific to Clojure, such as finding function definitions or identifying code patterns in `.clj` files.",
      "description_length": 399,
      "index": 532,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Haskell",
      "library": "comby-kernel",
      "description": "This module provides essential configurations and metadata for working with Haskell source files. It defines key data types representing syntax elements like delimiters, string literals, and comments, along with constants for file extensions such as `.hs` and `.lhs`. These components enable precise parsing, pattern matching, and file recognition in tools like refactoring systems, linters, and language servers. For example, it allows a code analysis tool to correctly identify and process Haskell files based on their extension and parse nested comments or string escapes accurately.",
      "description_length": 586,
      "index": 533,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Alpha.Go",
      "library": "comby-kernel",
      "description": "This module implements a matcher for the Go programming language, providing functions to find all or the first occurrence of a template in a source string. It operates on strings using a configuration, optional file path, and rule, returning lists or individual match results with support for nested matching. Use cases include parsing and transforming Go code by identifying structural patterns in source files.",
      "description_length": 412,
      "index": 534,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Omega.Dhall",
      "library": "comby-kernel",
      "description": "This module provides functions to match Dhall templates against source code, supporting both full and first-occurrence matching with optional configuration and file context. It operates on strings representing templates and source code, returning structured match results. Use cases include finding all instances of a Dhall template in a file or identifying the first match starting at a specific position.",
      "description_length": 406,
      "index": 535,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Go",
      "library": "comby-kernel",
      "description": "This module provides language-specific definitions for processing Go code, including syntax rules for string literals, comments, and file metadata. It supports precise parsing and transformation tasks by defining delimiters, escape sequences, and recognized file extensions like `.go`. Users can leverage these definitions to build tools such as linters, formatters, or source code analyzers that handle Go syntax accurately. For example, it enables detecting raw string literals or extracting comments during static analysis of Go files.",
      "description_length": 538,
      "index": 536,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.External.Default",
      "library": "comby-kernel",
      "description": "This module defines a default external handler used for processing structured data with pattern matching. It provides a concrete implementation of the `Comby_kernel.Matchers.External.t` type, enabling matching and transformation of syntax trees based on predefined rules. It is used in scenarios where external matchers need to be invoked during the traversal and manipulation of code structures.",
      "description_length": 396,
      "index": 537,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Engine.S-Java",
      "library": "comby-kernel",
      "description": "This module provides functions to match Java code against templates, returning all matches or the first match with optional configuration and positional control. It operates on Java source code as input strings and uses a matcher configuration to guide the matching process. Use cases include finding specific code patterns in Java files, such as locating method calls or variable declarations, during code analysis or transformation tasks.",
      "description_length": 440,
      "index": 538,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Engine.S-Ruby",
      "library": "comby-kernel",
      "description": "This module provides functions to find all or the first matches of a template in Ruby source code, supporting recursive matching when enabled. It operates on strings representing the template and source code, returning lists of match results or individual match results with error handling. Use cases include pattern-based code analysis and transformation tasks specific to Ruby syntax.",
      "description_length": 386,
      "index": 539,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Swift",
      "library": "comby-kernel",
      "description": "This module provides essential language metadata and syntax configuration for Swift, enabling accurate code parsing and analysis. It includes data types for representing language name and file extensions, along with syntax rules for string literals, comments, and escape handling. Operations allow identifying Swift files, extracting code patterns, and processing multi-line strings or comments using defined delimiters. For example, it supports detecting Swift source files by extension and parsing raw strings using specified delimiter patterns.",
      "description_length": 547,
      "index": 540,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Omega.Python",
      "library": "comby-kernel",
      "description": "This module provides functions to match Python code patterns using templates, supporting both full and first-match searches with configurable parameters. It operates on string-based source code and template inputs, returning structured match results. Use cases include finding specific syntax patterns in Python files, such as function definitions or variable assignments, for analysis or transformation tasks.",
      "description_length": 410,
      "index": 541,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Alpha.Move",
      "library": "comby-kernel",
      "description": "This module implements alpha-equivalence-based matching for finding and extracting structured patterns in source code. It supports operations to find all matches or the first match of a template within a given source string, with optional recursive matching on nested structures. The matcher works with concrete syntax trees and string-based templates, and is used for tasks like code transformation, refactoring, and static analysis in specific programming languages.",
      "description_length": 468,
      "index": 542,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Omega.Coq",
      "library": "comby-kernel",
      "description": "This module provides functions to match templates against source code in a specific programming language, returning all matches or the first match found. It operates on strings representing the template and source, with options to control matching behavior like nesting and starting position. Use cases include finding structural patterns in code for analysis or transformation tasks.",
      "description_length": 384,
      "index": 543,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Omega.Bash",
      "library": "comby-kernel",
      "description": "This module provides functions to match templates against Bash source code, returning all matches or the first match with optional configuration and positional control. It operates on strings representing templates and source code, producing lists of match results or error-handled single matches. Use cases include finding specific syntactic patterns in Bash scripts for analysis or transformation tasks.",
      "description_length": 405,
      "index": 544,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.C",
      "library": "comby-kernel",
      "description": "This module provides syntactic and metadata definitions for the C programming language, enabling accurate parsing and handling of C code. It includes delimiters, string literals, and comment styles such as `/* */` and `//`, along with the language name and common file extensions like `.c` and `.h`. These components support pattern matching, code analysis, and file identification in C processing workflows. For example, it allows tools to correctly recognize C comments during code transformation or filter source files based on extension.",
      "description_length": 541,
      "index": 545,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Pascal",
      "library": "comby-kernel",
      "description": "This module combines syntax definitions and metadata for Pascal language support. It includes data types for string literals, delimiters, and comments, along with operations to configure and match Pascal syntax patterns. It also provides identifiers like file extensions (`.pas`) and language name for file recognition and tool integration. Example: Configure a parser to handle Pascal string literals with custom delimiters or identify Pascal source files by extension.",
      "description_length": 470,
      "index": 546,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Engine.S-OCaml",
      "library": "comby-kernel",
      "description": "This module performs structural matching of code templates against source code, supporting nested matches and first-occurrence searches with configurable starting positions. It operates on strings representing code templates and source content, returning lists or individual match results enriched with contextual information. Use cases include finding all instances of a code pattern in a file or identifying the first match starting at a specific offset for targeted transformations.",
      "description_length": 485,
      "index": 547,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Omega.Elm",
      "library": "comby-kernel",
      "description": "This module provides functions to match templates against source code in the Elm programming language. It supports finding all matches, optionally with nested recursion, or locating the first match starting at a specified position. The module handles match configurations, file paths, and source templates, returning structured match results.",
      "description_length": 342,
      "index": 548,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Engine.S-Zig",
      "library": "comby-kernel",
      "description": "This module implements a matcher for the Zig programming language, providing functions to find all or the first match of a template in a source string. It works with string templates and source code, supporting operations like recursive matching and position-based searching. Use cases include pattern matching and code analysis specific to Zig syntax.",
      "description_length": 352,
      "index": 549,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Rust",
      "library": "comby-kernel",
      "description": "This module provides metadata and syntax configurations for the Rust programming language. It includes data types for file extensions like `\"rs\"` and defines parsing rules for Rust-specific syntax elements such as delimiters, string literals, and comments. Operations allow for file-based language detection and precise code analysis. For example, it enables identifying Rust source files and implementing custom tools for refactoring or static analysis.",
      "description_length": 454,
      "index": 550,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Alpha.Text",
      "library": "comby-kernel",
      "description": "This module implements text-based pattern matching for source code using a customizable template syntax. It supports finding all matches or the first match of a template in a given source string, with optional recursive matching on nested structures. The module works with file-specific configurations and returns detailed match information, making it suitable for code analysis and transformation tasks in specific programming languages.",
      "description_length": 438,
      "index": 551,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Alpha.GraphQL",
      "library": "comby-kernel",
      "description": "This module implements a GraphQL-aware matcher for parsing and matching GraphQL templates against source code. It provides operations to find all matches or the first match of a template in a source string, supporting recursive matching when enabled. The matcher works with GraphQL syntax and returns structured match results, suitable for tasks like code transformation or static analysis in GraphQL-based APIs.",
      "description_length": 412,
      "index": 552,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Alpha.CSS",
      "library": "comby-kernel",
      "description": "This module provides functions to match CSS templates against source code, supporting both full and first-match searches with optional configuration and file context. It operates on strings representing CSS templates and source content, returning structured match results. Use cases include finding specific CSS rule patterns in stylesheets or extracting style blocks for transformation.",
      "description_length": 387,
      "index": 553,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Omega.Pascal",
      "library": "comby-kernel",
      "description": "This module implements template-based matching for Pascal language code, providing functions to find all matches or the first match of a given template in a source string. It operates on strings representing code and templates, returning structured match results with support for nested matching when enabled. Use cases include code analysis and transformation tasks where specific Pascal syntax patterns need to be identified, such as refactoring or static analysis tools.",
      "description_length": 473,
      "index": 554,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Omega.JSONC",
      "library": "comby-kernel",
      "description": "This module provides functions to match JSONC templates against source code, supporting both full and first-match searches with optional configuration and file context. It operates on strings for template and source input, returning structured match results. Use cases include finding all instances of a JSONC pattern in a file or identifying the first match starting at a specific position.",
      "description_length": 391,
      "index": 555,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Matlab",
      "library": "comby-kernel",
      "description": "This module provides syntactic and metadata definitions for working with MATLAB code. It includes parsers for MATLAB-specific syntax elements like strings, comments, and delimiters, enabling precise code analysis and transformation. The module also exposes metadata such as the language name and file extensions for identification and integration purposes. Examples include building custom refactoring tools or implementing MATLAB file detection in editors.",
      "description_length": 457,
      "index": 556,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Alpha.Kotlin",
      "library": "comby-kernel",
      "description": "This module provides functions to match Kotlin code against templates, returning all matches or the first match with optional configuration and positional control. It operates on strings representing source code and templates, producing lists of match results or error-handled single matches. Use cases include code analysis and transformation tasks specific to Kotlin, such as identifying patterns in source files for refactoring or static analysis.",
      "description_length": 450,
      "index": 557,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Php",
      "library": "comby-kernel",
      "description": "This module provides essential metadata and syntax configurations for the PHP language. It includes the language name and file extensions for identification, along with delimiters and comment styles for parsing PHP code structures. Specific examples include recognizing `.php` files, handling heredoc strings, and distinguishing single-line and multi-line comments during source analysis.",
      "description_length": 388,
      "index": 558,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Alpha.Julia",
      "library": "comby-kernel",
      "description": "This module provides functions to match Julia code patterns using templates, supporting both full and first-match searches with configurable parameters. It operates on strings representing source code and templates, returning structured match results. Use cases include finding specific Julia syntax constructs in codebases, such as function definitions or variable assignments, with support for recursive matching when enabled.",
      "description_length": 428,
      "index": 559,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Omega.Rust",
      "library": "comby-kernel",
      "description": "This module implements Rust-specific pattern matching over source code using templates. It provides functions to find all matches or the first match of a template in a source string, with support for recursive matching through nested structures. The module works with string-based templates and source code, returning structured match results with metadata like positions and captured variables.",
      "description_length": 395,
      "index": 560,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Kotlin",
      "library": "comby-kernel",
      "description": "This module provides precise syntactic and metadata definitions for the Kotlin language. It includes data types for string literals with customizable delimiters, escapable and raw string configurations, comment kinds, and file extension tracking. Operations allow parsing, formatting, and identifying Kotlin code structures and files. For example, it enables building a Kotlin-aware linter that correctly handles multi-line strings or detecting Kotlin source files by extension.",
      "description_length": 478,
      "index": 561,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Engine.S-Matlab",
      "library": "comby-kernel",
      "description": "This module provides functions to find all or the first match of a template in a source string, supporting nested matching and optional configuration. It works with strings as input and returns lists or individual match records, with support for file paths and language-specific rules. Use cases include parsing and transforming code in MATLAB files by identifying structural patterns.",
      "description_length": 385,
      "index": 562,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Omega.Haskell",
      "library": "comby-kernel",
      "description": "This module provides functions to match templates against Haskell source code, returning all matches or the first match with optional configuration and positional control. It operates on strings representing the template and source code, producing lists of match results or error-handled single matches. Use cases include finding specific syntactic patterns in Haskell files for refactoring or analysis, with support for recursive matching through nested structures.",
      "description_length": 466,
      "index": 563,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Typescript",
      "library": "comby-kernel",
      "description": "This module provides metadata and syntax configurations for handling TypeScript files. It includes the language name, file extensions, delimiters, string literals, and comment styles. These data types enable identifying TypeScript files and accurately parsing or transforming their content. For example, it supports detecting TypeScript files by extension and correctly processing embedded expressions within template literals.",
      "description_length": 427,
      "index": 564,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Alpha.Dyck",
      "library": "comby-kernel",
      "description": "This module implements Dyck language-based matching for structured text, supporting operations to find all or the first match of a template within a source string. It works with strings as input and outputs lists of matches or individual match results, using a configuration that may include nesting behavior. It is used for precise pattern matching in structured documents, such as source code, where hierarchical constructs need to be matched recursively.",
      "description_length": 457,
      "index": 565,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Alpha.Rust",
      "library": "comby-kernel",
      "description": "Implements Rust-specific pattern matching over source code using templates, supporting nested matching when enabled. It operates on strings for both template and source input, returning lists of matches or individual match results. Useful for code transformation tasks where precise syntactic matching is required, such as automated refactoring or static analysis rules.",
      "description_length": 370,
      "index": 566,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Html",
      "library": "comby-kernel",
      "description": "This module provides core HTML syntax definitions and language metadata for parsing and file recognition. It includes data types for HTML syntax elements like delimiters, string literals, and comments, along with operations for precise parsing and matching. The module also defines constants for HTML language identification, such as `name` and `extensions`. Examples include parsing HTML templates, transforming structured code, and configuring editors to recognize `.html` files.",
      "description_length": 481,
      "index": 567,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Python",
      "library": "comby-kernel",
      "description": "This module provides precise definitions for Python's syntactic elements and language metadata. It includes configurable string patterns for parsing Python code, such as delimiters, raw strings, and comments, along with language identifiers and file extensions. These components support tasks like building custom parsers, analyzing code structure, or recognizing Python files by extension. For example, you can define a custom string literal syntax or determine if a file should be treated as Python based on its extension.",
      "description_length": 524,
      "index": 568,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Scala",
      "library": "comby-kernel",
      "description": "This module provides language-specific definitions for parsing and identifying Scala code. It includes configurations for syntax elements like string delimiters and comments, along with metadata such as the language name and file extensions. These components enable accurate parsing, pattern matching, and language recognition in code analysis tools. For example, it allows tools to correctly handle triple-quote strings and identify Scala source files by their `.scala` extension.",
      "description_length": 481,
      "index": 569,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Omega.Fortran",
      "library": "comby-kernel",
      "description": "This module implements Fortran-specific pattern matching operations for source code analysis. It provides functions to find all or the first occurrence of a template in a source string, supporting recursive matching when enabled. The module works with Fortran syntax and is used for tasks like code transformation and static analysis in Fortran projects.",
      "description_length": 354,
      "index": 570,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Language.Syntax",
      "library": "comby-kernel",
      "description": "This module represents syntactic elements of programming languages, including string literals, escape characters, and comment formats, with operations to serialize and deserialize these definitions to and from JSON. It enables configuration and interchange of language-specific syntax rules for source code analysis. The core types allow specifying delimiters, escapable and raw strings, and comment styles, while submodules extend these definitions for specific languages. Use it to define or parse syntax patterns, such as matching string literals in a C-like language or handling nested comments in a custom DSL.",
      "description_length": 615,
      "index": 571,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Engine.S-Solidity",
      "library": "comby-kernel",
      "description": "This module provides functions to match Solidity code against templates, supporting both full and first-match scans with configurable nesting. It operates on Solidity source code strings and returns structured match results. Use cases include code analysis, transformation, and pattern-based querying within Solidity files.",
      "description_length": 323,
      "index": 572,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Engine.S-Reason",
      "library": "comby-kernel",
      "description": "This module performs structural matching of code templates against source code, supporting both first-match and all-matches operations with optional nested matching. It works with strings representing code templates and source, and returns structured match results with position and substitution data. It is used to implement language-specific pattern matching for code transformation tools, such as finding all occurrences of a function call pattern in a source file.",
      "description_length": 468,
      "index": 573,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Omega.Latex",
      "library": "comby-kernel",
      "description": "This module provides functions to match LaTeX templates against source code, returning lists of matches or the first match found. It operates on strings representing LaTeX content and templates, supporting nested matching when enabled. The module also identifies supported file extensions and names the language variant for matching purposes.",
      "description_length": 342,
      "index": 574,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Elixir",
      "library": "comby-kernel",
      "description": "This module provides essential metadata and syntax definitions for the Elixir programming language. It includes data types for language name, file extensions, string literals, delimiters, and comment structures, enabling precise parsing and analysis of Elixir code. Operations allow tools to identify Elixir files, process string and comment syntax, and support transformations or linters. For example, it can configure a parser to correctly handle heredocs or match inline comments in Elixir source files.",
      "description_length": 506,
      "index": 575,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Engine.S-Pascal",
      "library": "comby-kernel",
      "description": "This module implements a matcher engine for Pascal language templates, providing functions to find all matches or the first match of a template in a source string. It operates on strings for both template and source input, returning lists or individual match records with optional configuration parameters. Use cases include parsing Pascal code for structural patterns, such as identifying function declarations or code transformations.",
      "description_length": 436,
      "index": 576,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Ruby",
      "library": "comby-kernel",
      "description": "This module provides metadata and syntax definitions for the Ruby programming language. It includes data types for representing language name, file extensions, string literals, and comment styles, along with operations for pattern matching and parsing Ruby code. You can use it to identify Ruby files by extension, extract string content while respecting delimiters, and process comments according to Ruby's syntax rules.",
      "description_length": 421,
      "index": 577,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Alpha.Xml",
      "library": "comby-kernel",
      "description": "This module implements XML-specific matching operations for finding and extracting structured patterns in source code. It provides functions to locate all matches or the first occurrence of a given template within an XML document, supporting recursive matching when enabled. The module works directly with XML syntax trees and string templates, making it suitable for tasks like code analysis or transformation in XML-based languages.",
      "description_length": 434,
      "index": 578,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Omega.Erlang",
      "library": "comby-kernel",
      "description": "This module provides functions to match Erlang code against templates, supporting both full and first-match searches with configurable parameters. It operates on Erlang source code strings and returns structured match results, supporting use cases like code analysis and transformation. It identifies matches by parsing Erlang syntax and handles nested matches when enabled.",
      "description_length": 374,
      "index": 579,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Omega.Ruby",
      "library": "comby-kernel",
      "description": "This module implements Ruby-specific matching operations for finding and extracting patterns in source code using templates. It provides functions to find all matches or the first match of a template in a given source string, with support for recursive matching on nested structures. The module works directly with strings as input and outputs structured match results, leveraging configuration parameters to control matching behavior.",
      "description_length": 435,
      "index": 580,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Engine.S",
      "library": "comby-kernel",
      "description": "This module provides language-specific matching and parsing operations for structured text formats, handling syntactic constructs like parentheses, strings, and comments using Dyck automata or context-sensitive analysis. It works with diverse data formats (JSON, XML, LaTeX) and programming languages (Python, OCaml, JavaScript) to enable use cases such as code analysis, transformation, and structured data processing, supporting custom syntax configurations through metasyntax handlers.",
      "description_length": 488,
      "index": 581,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Omega.Php",
      "library": "comby-kernel",
      "description": "This module provides functions to match PHP code patterns using templates, supporting both full and first-match scans with configurable nesting. It operates on PHP source code strings and returns structured match results with context. Use cases include code analysis, refactoring, and transformation tasks specific to PHP syntax.",
      "description_length": 329,
      "index": 582,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Java",
      "library": "comby-kernel",
      "description": "This module provides precise syntax handling and metadata for Java code analysis. It includes configurations for parsing Java syntax elements like string literals, comments, and custom tokens, along with metadata such as the language name and common file extensions. These components support accurate pattern matching and file identification in Java tooling workflows. For example, it enables recognizing raw strings and processing `.java` files based on their extension.",
      "description_length": 471,
      "index": 583,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Engine.S-Assembly",
      "library": "comby-kernel",
      "description": "This module implements matching operations for templates against source code, supporting both full and first-match scans with configurable behavior. It processes string-based templates and sources, returning structured match results with optional recursive matching on nested content. It is used to identify syntactic patterns in code for transformation or analysis tasks.",
      "description_length": 372,
      "index": 584,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Omega.Paren",
      "library": "comby-kernel",
      "description": "This module provides functions to match templates within source code, supporting nested matching and first-occurrence searches with optional configuration and file context. It operates on strings for both template and source input, returning structured match results. Use cases include finding all instances of a code pattern in a file or identifying the first match starting at a specific position for targeted transformations.",
      "description_length": 428,
      "index": 585,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Elm",
      "library": "comby-kernel",
      "description": "This module combines syntax parsing capabilities with language metadata to support Elm code analysis and transformation. It offers data types representing Elm syntax elements, such as delimiters, string literals, and comments, along with operations to configure and match these constructs. Additionally, it provides access to Elm's name and file extensions for tooling integration. You can use it to build custom code analyzers, linters, or syntax highlighters that accurately handle Elm's syntax and file structure.",
      "description_length": 516,
      "index": 586,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Engine.S-SQL",
      "library": "comby-kernel",
      "description": "This module provides functions to find all or the first match of a template in SQL source code, supporting nested matching when enabled. It operates on strings for both template and source inputs, returning lists of matches or individual match results. Use cases include searching for specific SQL query patterns in database scripts or analyzing SQL code structure.",
      "description_length": 365,
      "index": 587,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.OCaml",
      "library": "comby-kernel",
      "description": "This module provides essential language-specific metadata and syntax definitions for working with OCaml source files. It includes data types for file extensions, string literals, delimiters, and comments, along with operations to query and match these elements. You can use it to configure parsers, analyze syntax, or build tools that recognize and transform OCaml code based on its lexical structure. For example, you might determine a file's language from its extension or extract comments and string contents while preserving their formatting.",
      "description_length": 546,
      "index": 588,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Engine.S-C_nested_comments",
      "library": "comby-kernel",
      "description": "This module implements comment-aware template matching for source code with nested structures. It provides functions to find all matches or the first match of a template in a source string, supporting nested recursion into matched content. The module works with string-based templates and source code, returning match results with contextual metadata like file path and configuration. Use cases include precise code pattern detection in languages with nested comments, such as C or Go, during refactoring or static analysis tasks.",
      "description_length": 530,
      "index": 589,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Engine.S-HCL",
      "library": "comby-kernel",
      "description": "This module implements HCL (HashiCorp Configuration Language) template matching operations for parsing and analyzing infrastructure configuration files. It provides functions to find all matches or the first match of a template within a source HCL document, supporting recursive matching when enabled. The module works with HCL syntax structures, handling matches as Comby kernel match types, and identifies supported file extensions and language name for HCL.",
      "description_length": 460,
      "index": 590,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Engine.S-Latex",
      "library": "comby-kernel",
      "description": "This module implements template-based matching for LaTeX documents, supporting operations to find all or the first occurrence of a template within a source string. It processes strings using configuration parameters that control matching behavior, such as nesting, and returns structured match results. Use cases include parsing and transforming LaTeX content based on syntactic patterns, such as extracting equations or restructuring document sections.",
      "description_length": 453,
      "index": 591,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Alpha.Java",
      "library": "comby-kernel",
      "description": "This module implements Java-specific pattern matching over source code using customizable templates. It supports finding all matches recursively or the first match starting at a specified position, operating on strings for both template and source code. Use cases include code analysis, transformation, and refactoring tasks specific to Java, such as identifying method patterns or variable usages.",
      "description_length": 398,
      "index": 592,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.C_nested_comments",
      "library": "comby-kernel",
      "description": "This module provides a framework for defining and processing nested comment syntax in C-like languages. It includes data types for specifying delimiters, string literals, and comment kinds, along with operations for parsing and manipulating source code with nested structures. You can use it to build custom parsers, configure syntax recognition for tools, or process code with complex commenting patterns. For example, it enables identifying nested `/* */` comments and handling escapable or raw strings within the same input.",
      "description_length": 527,
      "index": 593,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Engine.S-C",
      "library": "comby-kernel",
      "description": "This module implements matching operations for source code using a template, supporting both full and first-match scans. It processes strings representing source code and templates, returning structured match results with position and substitution details. It is used to identify syntactic patterns in code for tasks like refactoring or static analysis.",
      "description_length": 353,
      "index": 594,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.JSONC",
      "library": "comby-kernel",
      "description": "This module handles the syntax and metadata configuration for parsing JSONC, supporting customizable delimiters, string literals, and comments. It provides data types for syntax elements and metadata such as language name and file extensions. Operations include parsing JSONC with user-defined settings and retrieving extension lists for file identification. Example uses include parsing a JSONC file with custom string escaping or detecting JSONC files based on registered extensions.",
      "description_length": 485,
      "index": 595,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Engine.S-Swift",
      "library": "comby-kernel",
      "description": "This module provides functions to match and find occurrences of a template within Swift source code, returning structured match results. It operates on strings representing source code and templates, with support for nested matching and positional constraints. Use cases include identifying specific Swift syntax patterns for refactoring or analysis, such as locating function calls or type declarations within a codebase.",
      "description_length": 422,
      "index": 596,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Engine.S-Typescript",
      "library": "comby-kernel",
      "description": "This module provides functions to match and find occurrences of a template within TypeScript source code. It supports operations to retrieve all matches, including nested matches, or find the first match starting at a specific position. The module works with strings for both template and source code inputs, and returns structured match results. Use cases include code analysis, refactoring tools, and static code transformation pipelines where precise pattern matching in TypeScript is required.",
      "description_length": 497,
      "index": 597,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Jsx",
      "library": "comby-kernel",
      "description": "This module describes the language metadata and syntax configuration for JSX, including file extensions, delimiters, string literals, and comment kinds. It enables tools to identify JSX files and parse their syntax elements accurately. With it, developers can match JSX structures, transform syntax trees, or build refactoring tools that handle JSX-specific constructs. For example, a tool could detect `.jsx` files and rewrite embedded expressions using custom delimiters.",
      "description_length": 473,
      "index": 598,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Engine.S-Tsx",
      "library": "comby-kernel",
      "description": "This module performs structural matching of code templates against source code, supporting both full and first-match scans with configurable nesting. It operates on strings representing code templates and source inputs, returning lists or individual match records with positional and structural details. Use cases include code analysis, refactoring, and transformation tasks where precise syntactic pattern matching is required.",
      "description_length": 428,
      "index": 599,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Alpha.Generic",
      "library": "comby-kernel",
      "description": "This module provides functions to match templates against source code, supporting both full and first-match searches with optional configuration and file context. It operates on strings for template and source input, returning lists of matches or individual match results. Use cases include finding all occurrences of a code pattern in a file or identifying the first match starting at a specific position.",
      "description_length": 406,
      "index": 600,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Omega.Text",
      "library": "comby-kernel",
      "description": "This module provides functions to match text templates against source content, supporting both full and first-match scans with optional nested matching. It operates on strings for templates and sources, returning lists of matches or individual match results. Use cases include parsing structured text files, extracting patterns from code, and identifying template instances in documents.",
      "description_length": 387,
      "index": 601,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Comby_kernel.Matchers.Language.S",
      "library": "comby-kernel",
      "description": "This module defines core matching and transformation capabilities for language-specific syntax trees. It works with abstract syntax tree (AST) nodes and pattern-matching rules to enable precise code analysis and rewriting. Concrete use cases include implementing language-specific refactoring tools and static analysis passes that require deep syntactic understanding.",
      "description_length": 368,
      "index": 602,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Alpha.Fortran",
      "library": "comby-kernel",
      "description": "This module implements template matching for Fortran code, providing functions to find all or the first match of a given template within a source string. It operates on Fortran syntax trees, supporting recursive matching when enabled, and includes metadata like supported file extensions and the language name. It is used to perform structural searches in Fortran codebases, enabling precise match and rewrite operations.",
      "description_length": 421,
      "index": 603,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Alpha.C",
      "library": "comby-kernel",
      "description": "This module provides functions to match and find occurrences of a given template within C source code, returning all matches or the first match based on provided configuration. It operates on C source strings and supports nested matching when enabled. Use cases include searching for specific code patterns in C files, such as function calls or variable declarations, during code analysis or transformation tasks.",
      "description_length": 413,
      "index": 604,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Language.Info",
      "library": "comby-kernel",
      "description": "This module organizes language-specific metadata, such as names, file extensions, comment syntax, and parsing rules, enabling operations like language detection from file extensions or extracting comment delimiters for code generation. It provides data types representing programming languages and their configurations, supporting both direct queries and structured extensions through submodules. One submodule focuses on language identifiers and extensions, allowing lookups by file suffix or integration with tooling that requires language names. Together, these components form a cohesive interface for managing and retrieving language data in diverse code-processing tasks.",
      "description_length": 677,
      "index": 605,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Omega.Assembly",
      "library": "comby-kernel",
      "description": "This module implements template-based matching for structured text, providing operations to find all matches or the first match of a template within a source string. It works with strings as input and produces lists of match results or error-handled single matches, supporting recursive matching when configured. It is used for language-specific pattern matching and transformation tasks, such as identifying code patterns in source files for refactoring or analysis.",
      "description_length": 467,
      "index": 606,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Matcher.S",
      "library": "comby-kernel",
      "description": "This module implements pattern matching functionality for source code, providing operations to find all matches or the first match of a template within a given source string. It works with string-based templates and source code, supporting configuration options for nested matching and positional starting points. It is used to identify structural patterns in code, such as finding specific syntax constructs in a file or during analysis passes.",
      "description_length": 445,
      "index": 607,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Dart",
      "library": "comby-kernel",
      "description": "This module provides metadata and syntax definitions for the Dart programming language. It includes data types for file extensions, string literals, and comment kinds, along with operations to identify and process Dart source files and lexical constructs. Use it to configure parsers, recognize Dart files by extension, or analyze Dart code using its specific syntactic patterns. For example, you can match Dart string literals or extract comments using the defined delimiters and escape sequences.",
      "description_length": 498,
      "index": 608,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Omega.R",
      "library": "comby-kernel",
      "description": "This module provides functions to match templates against source code, supporting both full and first-match searches with optional configuration and file context. It operates on strings representing templates and source code, returning lists of matches or individual match results. Use cases include finding all occurrences of a code pattern in a file or identifying the first match starting at a specific position.",
      "description_length": 415,
      "index": 609,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Alpha.Dart",
      "library": "comby-kernel",
      "description": "This module implements Dart language-specific pattern matching over source code using templates. It provides operations to find all matches or the first match of a template in a source string, supporting recursive matching when nested. The module works with Dart syntax and is used for tasks like code transformation and analysis.",
      "description_length": 330,
      "index": 610,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Engine.S-Php",
      "library": "comby-kernel",
      "description": "This module provides functions to match PHP code patterns using templates, returning all matches or the first match with optional configuration and positional control. It operates on PHP source code strings and supports nested matching when enabled. Use cases include code analysis, refactoring, and transformation tasks specific to PHP files.",
      "description_length": 343,
      "index": 611,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Engine.S-Nim",
      "library": "comby-kernel",
      "description": "This module performs structural matching of code templates against source code, supporting both first-match and all-matches operations with optional nested matching. It works with string-based templates and source code, returning lists of match positions or individual match results. It is used to implement language-specific pattern matching for code analysis and transformation tools.",
      "description_length": 386,
      "index": 612,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Engine.S-Text",
      "library": "comby-kernel",
      "description": "This module provides functions to match text templates against source content, supporting both first and all match extractions with optional configuration and file context. It operates on strings for template and source input, returning structured match results or errors. Use cases include parsing and transforming code or structured text by identifying specific patterns within files or buffers.",
      "description_length": 397,
      "index": 613,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Omega.Csharp",
      "library": "comby-kernel",
      "description": "This module implements C#-specific pattern matching operations for source code analysis, providing functions to find all or the first occurrence of a template within a given source string. It works with string-based templates and source code inputs, returning structured match results. Use this module to perform precise syntactic transformations or code queries on C# files, such as identifying method calls or rewriting specific language constructs.",
      "description_length": 451,
      "index": 614,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Comby_kernel.Matchers.External.S",
      "library": "comby-kernel",
      "description": "This module defines an external matcher interface with a single handler value that processes structured data. It works with `Comby_kernel.Matchers.External.t`, a type representing external matching logic for parsing and transforming code. Concrete use cases include integrating custom pattern matchers for code analysis tools or extending syntax tree manipulation capabilities.",
      "description_length": 377,
      "index": 615,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Alpha.Erlang",
      "library": "comby-kernel",
      "description": "This module provides functions to match Erlang code against templates, returning all matches or the first match with optional configuration and positional control. It operates on strings representing source code and templates, producing lists of match results or error-handled single matches. Use cases include finding specific function calls, syntactic patterns, or structural elements within Erlang source files.",
      "description_length": 414,
      "index": 616,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Omega.Move",
      "library": "comby-kernel",
      "description": "This module provides functions to find all or the first match of a template within a source string, supporting nested matching when enabled. It operates on strings using a configuration, optional file path, and rule, returning lists or individual match results. Use cases include pattern-based code analysis and transformation tasks where precise template matching is required.",
      "description_length": 377,
      "index": 617,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Omega.OCaml",
      "library": "comby-kernel",
      "description": "This module provides functions to match OCaml code patterns within source text using templates. It supports finding all matches recursively or the first match starting at a specific position, and it identifies the language name and file extensions for OCaml. Use cases include code analysis, transformation, and searching for specific syntactic constructs in OCaml files.",
      "description_length": 371,
      "index": 618,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Alpha.Tsx",
      "library": "comby-kernel",
      "description": "This module provides functions to match templates against source code in TSX files, supporting both full and first-match searches with configurable parameters. It operates on strings representing templates and source code, returning structured match results. Use cases include finding specific syntax patterns in TypeScript React code, such as locating all instances of a component or a specific function call structure.",
      "description_length": 420,
      "index": 619,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Alpha.C_nested_comments",
      "library": "comby-kernel",
      "description": "This module implements nested comment matching logic for C-like languages, supporting recursive pattern matching within matched regions. It operates on string templates and source code, providing functions to find all matches or the first match starting at a specified position. Use cases include identifying and transforming nested comment structures in C, C++, or similar language sources.",
      "description_length": 391,
      "index": 620,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Omega.Lisp",
      "library": "comby-kernel",
      "description": "This module implements a matcher for Lisp-like languages, providing functions to find all or the first match of a template in a source string. It works with strings as input and output, along with configuration options for matching behavior such as nesting and starting position. It is used for pattern matching in Lisp code, supporting nested template matching and reporting matches with associated metadata.",
      "description_length": 409,
      "index": 621,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Engine.S-Generic",
      "library": "comby-kernel",
      "description": "This module performs structural matching of code templates against source code, supporting both first-match and all-matches operations with optional nested matching. It works with strings representing code templates and source input, returning match results that include positional and contextual details. It is used to implement language-specific matchers for code analysis and transformation tasks, such as finding function calls or rewriting code patterns in specific programming languages.",
      "description_length": 493,
      "index": 622,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Engine.S-Rust",
      "library": "comby-kernel",
      "description": "This module implements matching operations for Rust code using templates, providing functions to find all matches or the first match of a template within a source string. It operates on strings representing Rust code and templates, returning structured match results with support for nested matching. Use cases include code analysis, transformation, and pattern extraction in Rust files.",
      "description_length": 387,
      "index": 623,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Text",
      "library": "comby-kernel",
      "description": "This module provides configurations for defining and identifying text-based languages through customizable syntax and metadata. It supports syntax elements like delimiters, string literals, and comments, along with metadata such as language names and file extensions. Operations include parsing text according to specified rules and associating files with languages based on extension or name. For example, it can set up custom syntax for a domain-specific language or configure a text editor to recognize and highlight files by extension.",
      "description_length": 539,
      "index": 624,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Alpha.Bash",
      "library": "comby-kernel",
      "description": "This module implements Bash-specific pattern matching operations for parsing and analyzing Bash scripts. It provides functions to find all matches or the first match of a template in a source string, supporting recursive matching when enabled. The module works with string templates and source code inputs, returning structured match results with language-specific handling for Bash syntax.",
      "description_length": 390,
      "index": 625,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Engine.S-R",
      "library": "comby-kernel",
      "description": "This module performs structural matching of code templates against source code, supporting recursive nested matching and first-match operations. It works with strings as input for templates and source code, returning lists of match results or individual match errors. Use it to find specific syntactic patterns in code, such as locating all function calls matching a certain structure or identifying the first occurrence of a pattern starting at a given position.",
      "description_length": 463,
      "index": 626,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Latex",
      "library": "comby-kernel",
      "description": "This module provides core components for working with LaTeX syntax and metadata. It includes configurable delimiters for macros, support for raw strings and comments, enabling precise parsing and manipulation of LaTeX code. Key operations involve defining custom macro syntax, handling verbatim text, and identifying LaTeX files through extensions like `.tex`. Example uses include extracting macros with user-defined patterns and processing LaTeX documents with custom comment styles.",
      "description_length": 485,
      "index": 627,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Engine.S-Lisp",
      "library": "comby-kernel",
      "description": "This module provides functions to match templates against source code in a specific programming language, supporting both full and first-match scans. It operates on strings for templates and source code, returning lists or individual match records with optional configuration parameters. Use cases include finding all occurrences of a code pattern in a file or identifying the first match starting at a specific position.",
      "description_length": 421,
      "index": 628,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Engine.S-Csharp",
      "library": "comby-kernel",
      "description": "This module implements template-based matching for C# code, providing functions to find all matches or the first match of a given template within a source string. It operates on C# syntax trees and supports recursive matching when nested is enabled, allowing precise pattern detection in code structures. Use cases include code analysis, refactoring tools, and static pattern detection in C# files.",
      "description_length": 398,
      "index": 629,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Alpha.JSON",
      "library": "comby-kernel",
      "description": "This module provides functions to match JSON templates against source strings, supporting both full and first-match searches with optional configuration and file context. It operates on JSON structures and strings, returning lists or individual match results. Use cases include parsing and analyzing JSON content for specific patterns, such as extracting fields or validating structure.",
      "description_length": 386,
      "index": 630,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Engine.S-Jsx",
      "library": "comby-kernel",
      "description": "This module provides functions to match templates against source code, supporting both full and first-match scans with configurable parameters. It operates on string-based templates and sources, returning structured match results with optional nested matching. Use cases include parsing and transforming code in specific languages, leveraging language-specific extensions and configurations.",
      "description_length": 391,
      "index": 631,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Lisp",
      "library": "comby-kernel",
      "description": "This module provides metadata and syntax definitions for working with Lisp-like languages. It includes data types for specifying file extensions, string delimiters, and comment formats, along with operations to identify and process s-expressions, handle escaped or raw strings, and recognize line and block comments. For example, it can be used to configure a parser to correctly interpret `.lisp` files, match nested parentheses, or differentiate between quoted and unquoted string literals.",
      "description_length": 492,
      "index": 632,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.HCL",
      "library": "comby-kernel",
      "description": "This module provides the foundational syntax and metadata definitions for working with the HashiCorp Configuration Language. It includes data types for language identifiers, file extensions, string literals, delimiters, and comment structures, along with operations to match and process HCL-specific syntax patterns. Use it to build tools that analyze, transform, or validate HCL configurations based on precise syntactic rules. For example, you can identify HCL files by extension, parse raw strings, or implement custom logic for handling comments and delimiters.",
      "description_length": 565,
      "index": 633,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Omega.Javascript",
      "library": "comby-kernel",
      "description": "This module provides functions to match JavaScript code patterns using templates, supporting both full and first-match scans with optional nested matching. It operates on JavaScript source code strings and returns structured match results with contextual details. Use cases include code analysis, transformation, and refactoring tasks specific to JavaScript.",
      "description_length": 358,
      "index": 634,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Alpha.Matlab",
      "library": "comby-kernel",
      "description": "This module provides functions to match MATLAB code patterns using templates, supporting both full and first-match searches with optional configuration and file context. It operates on strings representing source code and templates, returning structured match results. Use cases include finding specific MATLAB function calls, variable assignments, or code structures within MATLAB files.",
      "description_length": 388,
      "index": 635,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Omega.Dart",
      "library": "comby-kernel",
      "description": "This module provides functions to match templates against Dart source code, returning lists of matches or the first match found. It operates on strings representing source code and templates, using configuration parameters to control matching behavior. Use cases include finding specific Dart code patterns for analysis or transformation tasks.",
      "description_length": 344,
      "index": 636,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Csharp",
      "library": "comby-kernel",
      "description": "This module provides syntax definitions and metadata for parsing and analyzing C# code. It includes patterns for string literals, comments, and code delimiters, along with identifiers like language name and file extensions. These components support tasks such as code transformation, comment stripping, and file recognition. For example, it enables detecting C# string boundaries accurately or classifying files based on `.cs` extensions.",
      "description_length": 438,
      "index": 637,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Omega.Html",
      "library": "comby-kernel",
      "description": "This module provides functions to match HTML templates against source code, specifically `all` to find all matches recursively and `first` to locate the initial match starting at a given position. It operates on strings representing HTML templates and source content, returning structured match results. It is used for analyzing or transforming HTML code by identifying specific patterns defined in templates.",
      "description_length": 409,
      "index": 638,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Engine.S-Dyck",
      "library": "comby-kernel",
      "description": "This module implements a Dyck language matching engine for structured source code analysis. It provides operations to find all or the first match of a template within a source string, supporting recursive nested matching when enabled. The engine works with string-based templates and sources, returning structured match results with language-specific configuration support.",
      "description_length": 373,
      "index": 639,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Erlang",
      "library": "comby-kernel",
      "description": "This module provides syntax and metadata configurations for working with Erlang code. It defines key data types for representing string literals, comments, and file extensions, along with operations for parsing and identifying Erlang source files. You can use it to match Erlang string patterns, handle escaped or raw strings, and recognize Erlang files by their extensions like `.erl` or `.hrl`.",
      "description_length": 396,
      "index": 640,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Alpha.Python",
      "library": "comby-kernel",
      "description": "This module provides functions to match Python code patterns using templates, supporting both full and first-match scans with configurable nesting. It operates on string-based source code and template inputs, returning structured match results. Use cases include finding specific syntax patterns in Python files, such as function definitions or variable assignments, for analysis or transformation tasks.",
      "description_length": 404,
      "index": 641,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Assembly",
      "library": "comby-kernel",
      "description": "This module handles the configuration and metadata necessary for parsing and identifying assembly languages. It allows customization of syntax elements like delimiters, string literals, and comments, and provides information such as language names and file extensions. Key operations include defining tokenization rules and associating file extensions with specific assembly dialects. For example, it can be used to set up a parser for a custom assembly variant with unique macro syntax or to match source files based on their extensions.",
      "description_length": 538,
      "index": 642,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Engine.S-Erlang",
      "library": "comby-kernel",
      "description": "This module provides functions to match Erlang syntax templates against source code, supporting both full and first-match scans with configurable nesting. It operates on strings representing templates and source code, returning structured match results. Use cases include finding all occurrences of a pattern in Erlang modules or locating the first match starting at a specific offset.",
      "description_length": 385,
      "index": 643,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Javascript",
      "library": "comby-kernel",
      "description": "This module provides JavaScript-specific parsing configurations and metadata for implementing code analysis and transformation tools. It defines syntax elements like string delimiters, escape sequences, and comment styles, along with core data types such as the language name and file extensions. Operations include accessing parsing rules for accurate pattern matching and retrieving metadata for file handling. For example, it enables recognizing JavaScript string literals during static analysis or filtering files by `.js` extension in a build pipeline.",
      "description_length": 557,
      "index": 644,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Engine.S-Dart",
      "library": "comby-kernel",
      "description": "This module performs structural matching of code templates against source code, supporting recursive matching when enabled. It operates on strings representing code templates and source files, returning lists of matches or individual match results. Use cases include finding all instances of a code pattern in a file or identifying the first occurrence starting at a specific position.",
      "description_length": 385,
      "index": 645,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Alpha.JSONC",
      "library": "comby-kernel",
      "description": "This module provides functions to match JSONC templates against source code, supporting both full and first-match searches with optional configuration and file context. It operates on strings for template and source input, returning structured match results or errors. Use cases include finding all instances of a JSONC pattern in a file or identifying the first match starting at a specific position.",
      "description_length": 401,
      "index": 646,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Omega.GraphQL",
      "library": "comby-kernel",
      "description": "This module provides functions to match GraphQL templates against source code, supporting both full and first-match scans with configurable parameters. It operates on strings for templates and source content, returning structured match results or errors. Use cases include parsing and analyzing GraphQL queries for syntax validation or transformation tasks.",
      "description_length": 357,
      "index": 647,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Engine.S-JSON",
      "library": "comby-kernel",
      "description": "This module performs structural matching of code templates against source code, supporting both full and first-match scans. It operates on string-based templates and source code, returning lists or individual match records with contextual details. It is used to identify specific syntactic patterns in code, such as finding all occurrences of a function call or variable declaration across different programming languages.",
      "description_length": 422,
      "index": 648,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Omega.Go",
      "library": "comby-kernel",
      "description": "This module provides functions to match Go code patterns using templates, supporting both full and first-match scans with configurable parameters. It operates on Go source files, leveraging language-specific parsing rules to identify matches within code structures. Use cases include automated code analysis and transformation tasks tailored to Go syntax.",
      "description_length": 355,
      "index": 649,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Omega.Swift",
      "library": "comby-kernel",
      "description": "This module provides functions to match Swift code patterns using templates, supporting both full and first-match scans with configurable parameters. It operates on Swift source code strings and returns structured match results, with support for nested matching. Use cases include code analysis, transformation, and querying specific Swift syntax structures like function calls or type declarations.",
      "description_length": 399,
      "index": 650,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Omega.Matlab",
      "library": "comby-kernel",
      "description": "This module provides functions to match templates against MATLAB source code, returning all matches or the first match with optional configuration and positional control. It operates on strings representing source code and templates, and returns structured match results. Use cases include finding specific code patterns in MATLAB files for analysis or transformation tasks.",
      "description_length": 374,
      "index": 651,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Alpha.Elm",
      "library": "comby-kernel",
      "description": "This module implements template-based matching and searching for Elm source code. It provides operations to find all matches or the first match of a template within a source string, supporting recursive matching when enabled. The module works directly with strings for templates and source code, returning structured match results with context-specific information.",
      "description_length": 365,
      "index": 652,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Engine.S-GraphQL",
      "library": "comby-kernel",
      "description": "This module performs structural matching of code templates against source code, supporting recursive nested matching and first-occurrence matching. It operates on strings representing code templates and source files, returning lists of match results or individual match errors. Used for tasks like code refactoring and pattern-based searching in language-specific contexts such as C or Go.",
      "description_length": 389,
      "index": 653,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Engine.S-Scala",
      "library": "comby-kernel",
      "description": "This module provides functions to match and find patterns in source code written in Scala. It supports operations to find all matches or the first match of a template in a given source string, with optional configuration and file context. The module works with strings as input templates and source code, returning structured match results, and includes metadata like the language name and supported file extensions.",
      "description_length": 416,
      "index": 654,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Alpha.HCL",
      "library": "comby-kernel",
      "description": "This module provides functions to match HCL (HashiCorp Configuration Language) templates against source code, supporting both full and first-match scanning with configurable parameters. It operates on HCL syntax structures, handling nested matches when enabled, and identifies matches within strings using a specified template. Use cases include parsing and transforming Terraform configurations or other infrastructure-as-code files written in HCL.",
      "description_length": 449,
      "index": 655,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Alpha.Latex",
      "library": "comby-kernel",
      "description": "This module provides functions to match LaTeX templates against source code, returning all matches or the first match with optional configuration and positional control. It operates on strings representing LaTeX content and templates, producing lists of match results or error-handled single matches. Use cases include parsing and transforming LaTeX documents by identifying structural patterns such as environments, macros, or custom commands.",
      "description_length": 444,
      "index": 656,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.SQL",
      "library": "comby-kernel",
      "description": "This module provides SQL syntax handling and language metadata for code analysis and processing tasks. It includes configurations for parsing SQL-specific structures like delimiters, string literals, and comments, along with identifiers such as language name and file extensions. You can use it to recognize SQL files by extension, parse SQL code with custom delimiters, or extract and transform SQL syntax elements. For example, it enables tools to match SQL comment styles or correctly interpret nested string literals during code transformation.",
      "description_length": 548,
      "index": 657,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Alpha.Nim",
      "library": "comby-kernel",
      "description": "This module implements pattern matching for Nim source code, providing functions to find all matches or the first match of a template within a source string. It operates on strings representing Nim code and supports recursive matching when enabled through configuration. The module also exposes metadata like the language name and supported file extensions, while offering an unused placeholder for setting rewrite templates.",
      "description_length": 425,
      "index": 658,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Dyck",
      "library": "comby-kernel",
      "description": "This module provides language metadata and syntactic configuration for processing Dyck files. It exposes identifiers, file extensions, delimiters, string markers, and comment styles as configurable elements. These data types enable tools to recognize file formats, parse structured text, and handle syntactic variations in Dyck-based languages. For example, an engine can use the delimiter list to validate bracket matching or configure string escaping rules during code analysis.",
      "description_length": 480,
      "index": 659,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Tsx",
      "library": "comby-kernel",
      "description": "This module provides precise syntactic and metadata definitions for working with TSX code. It includes configurations for parsing and matching TSX syntax elements such as embedded expressions, string literals, and comments, along with language metadata like name and file extensions. These components enable tasks like building linters, refactoring tools, and syntax highlighters that require accurate TSX parsing and file recognition. For example, it allows identifying TSX files by extension or transforming TSX code based on specific syntactic patterns.",
      "description_length": 556,
      "index": 660,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Engine.S-Julia",
      "library": "comby-kernel",
      "description": "This module implements matching operations for Julia code using templates, supporting both full and first-match strategies with optional nested matching. It operates on string-based source code and template inputs, returning structured match results. It is used to find syntactic patterns in Julia programs, such as locating function definitions or expressions matching a specific form.",
      "description_length": 386,
      "index": 661,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Omega.Tsx",
      "library": "comby-kernel",
      "description": "This module provides functions to match templates against source code in TSX files, supporting both full and first-match scans with configurable parameters. It operates on strings representing templates and source code, returning structured match results. Use cases include finding specific code patterns in TSX files for refactoring or analysis tasks.",
      "description_length": 352,
      "index": 662,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Alpha.Solidity",
      "library": "comby-kernel",
      "description": "This module provides functions to match Solidity code patterns using templates, supporting both full and first-match scans with configurable nesting. It operates on Solidity source code strings and returns structured match results, including position and substitution data. Use cases include automated code analysis, refactoring tools, and static security checks within Solidity projects.",
      "description_length": 388,
      "index": 663,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Omega.Kotlin",
      "library": "comby-kernel",
      "description": "This module provides functions to match Kotlin code patterns using templates, supporting both full and first-match scans with configurable parameters. It operates on strings representing source code and templates, returning structured match results. Use cases include code analysis, transformation, and querying specific Kotlin syntax structures.",
      "description_length": 346,
      "index": 664,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Omega.Generic",
      "library": "comby-kernel",
      "description": "This module provides functions to match templates against source code, supporting both full and first-match searches with optional configuration and file context. It operates on strings for templates and source code, returning lists or individual match records. Use cases include finding all occurrences of a code pattern in a file or identifying the first match starting at a specific position.",
      "description_length": 395,
      "index": 665,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Engine.S-Fsharp",
      "library": "comby-kernel",
      "description": "This module implements F#-specific pattern matching over source code using templates. It provides operations to find all matches (`all`) or the first match (`first`) of a template in a given source string, supporting nested matching when enabled. The module works with F# syntax and is used for tasks like code transformation and static analysis in F# files.",
      "description_length": 358,
      "index": 666,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Engine.S-Html",
      "library": "comby-kernel",
      "description": "This module provides functions to match templates against HTML source code, returning all matches or the first match based on configuration. It operates on strings representing HTML content and templates, and returns structured match results. Use cases include finding specific HTML patterns for refactoring or analysis.",
      "description_length": 320,
      "index": 667,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Omega.C_nested_comments",
      "library": "comby-kernel",
      "description": "This module implements comment-aware template matching for C-like nested syntax, specifically handling nested comments during pattern matching operations. It provides functions to find all matches or the first match of a template in a source string, supporting recursive matching when enabled. The module works with C-style source code, handling nested comments correctly, and is used for tasks like code transformation and analysis where comment boundaries must be respected.",
      "description_length": 476,
      "index": 668,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Nim",
      "library": "comby-kernel",
      "description": "This module provides essential language metadata and syntax configuration for processing Nim code. It includes data types for representing language name, file extensions, string delimiters, and comment styles, along with operations to access and match these elements. With it, developers can identify Nim files by extension, parse raw and interpolated strings, and correctly handle comment syntax for tools like linters or source code transformers. Example uses include detecting Nim source files in a build system or accurately tokenizing Nim code in an editor.",
      "description_length": 562,
      "index": 669,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Fsharp",
      "library": "comby-kernel",
      "description": "This module provides metadata and syntax definitions for the F# programming language. It includes data types for language name, file extensions, string literals, delimiters, and comments, along with operations to recognize and process these elements in F# source code. You can use it to identify F# files by extension, parse scripts, extract string content, and support refactoring tools with accurate syntax pattern recognition.",
      "description_length": 429,
      "index": 670,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Clojure",
      "library": "comby-kernel",
      "description": "This module provides metadata and syntax definitions for the Clojure programming language. It includes the language identifier, file extensions, custom delimiters, string literal forms, and comment structures. Developers can use this module to implement Clojure-aware tools for parsing, analysis, templating, and transformation. For example, it enables accurate detection of Clojure files by extension and supports precise parsing of Clojure syntax elements like parenthetical forms and comment blocks.",
      "description_length": 502,
      "index": 671,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Engine.S-Kotlin",
      "library": "comby-kernel",
      "description": "This module provides functions to find all or the first matches of a template in Kotlin source code, supporting recursive matching when enabled. It operates on strings for both template and source inputs, returning lists or individual match results. Use cases include code analysis and transformation tasks where specific Kotlin syntax patterns need to be identified.",
      "description_length": 367,
      "index": 672,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Engine.S-Haskell",
      "library": "comby-kernel",
      "description": "This module performs structural matching of code templates against source code, supporting both first-match and all-matches operations with optional nested matching. It works with string-based templates and source code, returning lists or individual match records containing detailed match information. It is used for language-specific code pattern detection, such as finding function calls or syntactic structures in source files during analysis or transformation tasks.",
      "description_length": 471,
      "index": 673,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Alpha.Make",
      "library": "comby-kernel",
      "description": "This module implements a matcher for identifying occurrences of a template within a source string, supporting both full and first-match scanning operations. It operates on string-based templates and sources, returning structured match results with optional configuration for nested matching or positional constraints. Use cases include parsing and transforming code in specific languages, where precise syntactic matching is required for refactoring or analysis tasks.",
      "description_length": 468,
      "index": 674,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Zig",
      "library": "comby-kernel",
      "description": "This module provides essential language metadata and syntactic definitions for working with the Zig programming language. It includes data types for representing language name, file extensions, string literals, delimiters, and comment syntax, along with operations to access and match these elements. For example, it enables identifying Zig source files by extension, parsing Zig strings with correct escaping rules, and recognizing comments during code analysis.",
      "description_length": 463,
      "index": 675,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Alpha.OCaml",
      "library": "comby-kernel",
      "description": "This module provides functions to match OCaml code patterns using templates, supporting both full and first-match scans with configurable parameters. It operates on OCaml source code strings and returns structured match results, with options to control matching behavior such as nesting and starting position. Use cases include code analysis, transformation, and querying specific syntactic patterns in OCaml files.",
      "description_length": 415,
      "index": 676,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Generic",
      "library": "comby-kernel",
      "description": "This module combines syntax configuration and language metadata to support customizable code analysis and transformation. It provides data types for defining delimiters, string literals, and comments, along with language identity through name and file extensions. Operations allow setting syntax rules and accessing metadata to drive language-specific processing. For example, you can define custom string escapes for a DSL or detect a language based on its file extension.",
      "description_length": 473,
      "index": 677,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Omega.Julia",
      "library": "comby-kernel",
      "description": "This module provides functions to match Julia code patterns using templates, supporting both full and first-match scans with configurable nesting. It operates on strings representing source code and templates, returning structured match results. Use cases include finding specific Julia syntax constructs in codebases, such as function definitions or variable assignments, with precise location and context.",
      "description_length": 407,
      "index": 678,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Alpha.Html",
      "library": "comby-kernel",
      "description": "This module provides functions to match HTML templates against source code, supporting both full and first-match searches with optional configuration and file context. It operates on strings representing templates and source code, returning lists of matches or individual match results. Use cases include identifying specific HTML structures in web documents, such as finding all script tags or locating the first occurrence of a particular element.",
      "description_length": 449,
      "index": 679,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Coq",
      "library": "comby-kernel",
      "description": "This module provides syntax definitions and language metadata for working with Coq source files. It supports customizable parsing through delimiters, string literals, and comment handling, while exposing Coq's name and file extensions for tool integration. Use it to configure pattern matching or recognize Coq files based on standard extensions. For example, you can define custom notation parsers or identify `.v` files as Coq source files.",
      "description_length": 442,
      "index": 680,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Engine.S-Fortran",
      "library": "comby-kernel",
      "description": "This module implements template matching for Fortran code, providing functions to find all matches or the first match of a given template within a source string. It operates on Fortran syntax trees, supporting recursive matching when enabled, and returns structured match results. Use cases include automated code transformation and static analysis tasks specific to Fortran, such as identifying and rewriting specific language constructs.",
      "description_length": 439,
      "index": 681,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Omega.Fsharp",
      "library": "comby-kernel",
      "description": "This module provides functions to match F# code patterns within source text using templates, supporting both full and first-match scans with configurable parameters. It operates on strings for templates and source code, returning structured match results or errors, and includes metadata like supported file extensions and language name. Use cases include parsing and analyzing F# codebases for specific syntactic patterns, such as identifying function definitions or code transformations.",
      "description_length": 489,
      "index": 682,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Alpha.Php",
      "library": "comby-kernel",
      "description": "This module provides functions to match PHP code patterns using templates, supporting both full and first-match searches with configurable nesting. It operates on string-based source code and template inputs, returning structured match results. Use cases include finding specific PHP function calls, class structures, or code patterns in PHP files for analysis or transformation tasks.",
      "description_length": 385,
      "index": 683,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Engine.S-Python",
      "library": "comby-kernel",
      "description": "This module provides functions to find all or the first matches of a template in Python source code, supporting nested matching through a configuration flag. It operates on strings representing the template and source code, returning lists of match results or individual match results with error handling. Use cases include searching for specific code patterns in Python files, such as identifying function calls or variable assignments.",
      "description_length": 437,
      "index": 684,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Omega.CSS",
      "library": "comby-kernel",
      "description": "This module implements CSS-specific matching operations for finding and extracting patterns in source code. It provides functions to locate all matches or the first occurrence of a template within a source string, with support for recursive matching on nested structures. The module works directly with CSS syntax trees and string-based templates, enabling precise pattern detection in CSS files.",
      "description_length": 396,
      "index": 685,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Omega.Elixir",
      "library": "comby-kernel",
      "description": "This module provides functions to match Elixir code patterns using templates, supporting both full and first-occurrence matching with configurable nesting. It operates on Elixir source code strings and returns structured match results, optionally scoped to a file path or rule. Use cases include static code analysis, automated refactoring, and code search within Elixir projects.",
      "description_length": 380,
      "index": 686,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Engine.S-Coq",
      "library": "comby-kernel",
      "description": "This module provides functions to match templates against source code in a specific programming language, returning lists of matches or the first match found. It operates on strings representing the template and source, with options to control matching behavior such as nesting and starting position. Use cases include finding structural patterns in code, such as identifying function calls or syntax constructs within a given source file.",
      "description_length": 439,
      "index": 687,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Engine.S-JSONC",
      "library": "comby-kernel",
      "description": "This module performs structural matching of code templates against source code, supporting nested matching when enabled. It operates on strings representing code templates and source input, returning lists of match results with positional information. Use cases include finding all instances of a code pattern in a file or identifying the first occurrence starting at a specific offset for targeted analysis or transformation tasks.",
      "description_length": 432,
      "index": 688,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Engine.S-Bash",
      "library": "comby-kernel",
      "description": "This module provides functions to match templates against Bash source code, returning all matches or the first match with optional configuration and positional control. It operates on strings representing source code and templates, producing lists of match results or error-handled single matches. Use cases include searching for specific Bash syntax patterns in scripts, such as function definitions or command structures, and identifying their locations for transformation or analysis.",
      "description_length": 487,
      "index": 689,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Engine.S-Clojure",
      "library": "comby-kernel",
      "description": "This module provides functions to find all or the first matches of a template in Clojure source code, supporting nested matching when enabled. It operates on strings representing the template and source code, returning lists of matches or individual match results. Use cases include structural code analysis and transformation tasks specific to Clojure, such as identifying function calls or rewriting code patterns.",
      "description_length": 416,
      "index": 690,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Engine.S-Make",
      "library": "comby-kernel",
      "description": "This module implements template-based matching engines for structured text, providing operations to find all or first matches of a template within a source string. It works with string inputs representing code or structured data, returning match results with contextual metadata like file paths and rule applications. Concrete use cases include parsing and transforming codebases using declarative templates, such as identifying function calls or rewriting expressions in specific languages.",
      "description_length": 491,
      "index": 691,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Omega.Make",
      "library": "comby-kernel",
      "description": "This module implements template-based matching for structured text, providing functions to find all matches or the first match of a template within a source string. It operates on strings using a configuration that defines matching rules and supports nested matching when enabled. Use cases include parsing and transforming code or structured data where templates represent patterns to locate or extract specific constructs.",
      "description_length": 424,
      "index": 692,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Omega.Jsx",
      "library": "comby-kernel",
      "description": "This module provides functions to match templates against source code in JSX syntax. It supports finding all matches recursively or the first match starting at a specific position, with configurable matching behavior. The module works with string-based templates and sources, returning structured match results with associated metadata.",
      "description_length": 336,
      "index": 693,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Alpha.Clojure",
      "library": "comby-kernel",
      "description": "This module provides functions to match Clojure code patterns using templates, supporting both full and first-match scans of source code. It operates on strings representing Clojure source code and templates, returning structured match results. Use cases include code analysis, transformation, and querying within Clojure projects.",
      "description_length": 331,
      "index": 694,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Engine.S-Go",
      "library": "comby-kernel",
      "description": "This module provides functions to match and find patterns in source code specific to the Go language. It supports operations like finding all matches recursively or the first match in a given source, using a specified template. The module works with strings as input for both source code and templates, and returns structured match results. Use cases include searching for code patterns in Go files, such as identifying specific function calls or variable declarations.",
      "description_length": 469,
      "index": 695,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Dhall",
      "library": "comby-kernel",
      "description": "This module provides metadata and syntax definitions for the Dhall configuration language. It includes data types representing language identifiers, file extensions, string literals, delimiters, and comment styles, along with operations to query and match these elements. For example, it allows tools to detect Dhall files by extension, parse multi-line strings, or identify comment blocks during code analysis.",
      "description_length": 411,
      "index": 696,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Alpha.Elixir",
      "library": "comby-kernel",
      "description": "This module provides functions to match Elixir code patterns using templates, supporting both full and first-occurrence matching with configurable parameters. It operates on Elixir source code strings and returns structured match results, with support for nested matching when enabled. Use cases include code analysis, transformation, and querying specific syntactic constructs in Elixir files.",
      "description_length": 394,
      "index": 697,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Alpha.Ruby",
      "library": "comby-kernel",
      "description": "This module implements Ruby-specific pattern matching over source code using structural templates. It provides operations to find all matches or the first match of a template in a given source string, with support for recursive matching on nested structures. The matcher works directly with Ruby syntax trees and is used for tasks like code transformation and static analysis in Ruby projects.",
      "description_length": 393,
      "index": 698,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Omega.Nim",
      "library": "comby-kernel",
      "description": "This module implements a matcher for the Nim programming language, providing functions to find all or the first match of a template in a source string. It works with strings as input and output, along with configurations, file paths, and match structures. Use cases include pattern matching in Nim code for refactoring or analysis, with support for nested matching when enabled.",
      "description_length": 378,
      "index": 699,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Alpha.Zig",
      "library": "comby-kernel",
      "description": "This module implements a matcher for the Zig programming language, providing functions to find all or the first matches of a template in a source string. It works with string-based templates and sources, returning structured match results with optional configuration for nested matching and positional shifting. It identifies supported file extensions and names the matcher for language-specific identification.",
      "description_length": 411,
      "index": 700,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Alpha.Pascal",
      "library": "comby-kernel",
      "description": "This module implements a matcher for Pascal language syntax, providing functions to find all or the first match of a template in a source string. It works with strings as input and outputs lists of match results or individual match results with error handling. Use cases include parsing Pascal code to identify structural patterns, such as function declarations or control flow constructs, and analyzing or transforming Pascal source files based on specific syntactic templates.",
      "description_length": 478,
      "index": 701,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Omega.JSON",
      "library": "comby-kernel",
      "description": "This module provides functions to match JSON templates against source strings, supporting both full and first-match searches with optional configuration and file context. It operates on JSON structures and strings, returning lists or individual match results. Use cases include parsing and analyzing JSON content for specific patterns, such as extracting fields or validating structure.",
      "description_length": 386,
      "index": 702,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Alpha.Reason",
      "library": "comby-kernel",
      "description": "This module provides functions to match code patterns in source code using templates, supporting both full and first-match scans with optional configuration and file context. It operates on strings representing code templates and source input, returning structured match results. Use cases include finding all occurrences of a code pattern in a file or identifying the first match starting at a specific position.",
      "description_length": 413,
      "index": 703,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.GraphQL",
      "library": "comby-kernel",
      "description": "This module provides precise syntactic definitions and language metadata for working with GraphQL code. It supports customizable parsing of strings, comments, and literals, enabling tools like linters and formatters to analyze and transform GraphQL queries and schemas. The module includes identifiers for the GraphQL language and its file extensions, facilitating file recognition and processing. For example, it allows defining custom string delimiters for parsing GraphQL fragments or detecting GraphQL files by `.graphql` extension.",
      "description_length": 536,
      "index": 704,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Alpha.Swift",
      "library": "comby-kernel",
      "description": "This module provides functions to match Swift code against templates, supporting both full and first-match scans with configurable parameters. It operates on Swift source code strings and leverages language-specific extensions and naming for accurate matching. Use cases include code analysis, transformation, and pattern detection within Swift files.",
      "description_length": 351,
      "index": 705,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Alpha.Assembly",
      "library": "comby-kernel",
      "description": "This module implements a matcher for the Alpha assembly language, providing functions to find all or the first match of a template in a source string. It works with string-based templates and sources, returning lists or individual match records with optional configuration parameters for nested matching and starting positions. It identifies itself with a name and lists supported file extensions, intended for use in parsing and transforming Alpha assembly code.",
      "description_length": 463,
      "index": 706,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Alpha.R",
      "library": "comby-kernel",
      "description": "This module provides functions to match templates against source code, supporting both full and first-match searches with optional configuration and file context. It operates on strings for template and source input, returning structured match results. Use cases include finding all occurrences of a pattern recursively in a codebase or locating the first match starting at a specific position.",
      "description_length": 394,
      "index": 707,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Omega.HCL",
      "library": "comby-kernel",
      "description": "This module implements HCL (HashiCorp Configuration Language) template matching operations for parsing and analyzing infrastructure configuration files. It provides functions to find all matches or the first match of a template in HCL source code, supporting recursive matching when enabled. The module works directly with HCL syntax structures and is used for tasks like automated configuration refactoring or policy enforcement in infrastructure-as-code workflows.",
      "description_length": 466,
      "index": 708,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Xml",
      "library": "comby-kernel",
      "description": "This module provides core definitions for XML language support, exposing metadata like the language name and file extensions for identification and handling in tooling contexts. It includes syntax elements for parsing XML, such as delimiters, string literals, and comment structures, enabling precise recognition and transformation of XML content. Developers can use it to parse XML with custom tags, process embedded expressions, and handle escaped or raw strings according to specified rules. For example, it allows defining custom delimiters for XML tags or controlling how comments are stripped during parsing.",
      "description_length": 614,
      "index": 709,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Omega.Xml",
      "library": "comby-kernel",
      "description": "This module provides functions to match XML templates against source code, supporting both full and first-match scanning with configurable starting positions. It operates on XML structures and works with file paths, string templates, and source content, returning lists or individual match results. Use cases include identifying specific XML patterns in documents, extracting structured data, or validating XML content against a given schema.",
      "description_length": 442,
      "index": 710,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "Comby_kernel.Matchers.Omega.Scala",
      "library": "comby-kernel",
      "description": "This module provides functions to match Scala code patterns using templates, supporting both full and first-match scans with configurable nesting. It operates on string-based source code and template inputs, returning structured match results. Use cases include code analysis, transformation, and search tasks specific to Scala files, leveraging precise syntactic matching.",
      "description_length": 373,
      "index": 711,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.CSS",
      "library": "comby-kernel",
      "description": "This module provides CSS-specific parsing configurations and language metadata for processing CSS files. It defines delimiters, string literals, and comment styles used in CSS syntax, along with file extensions and language identifiers. These components enable tasks such as parsing selectors, extracting properties, and detecting CSS files by extension. For example, it supports identifying a `.css` file and applying syntax-aware transformations to its content.",
      "description_length": 463,
      "index": 712,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Alpha.Coq",
      "library": "comby-kernel",
      "description": "This module implements matching functionality for Coq source code, providing operations to find all matches or the first match of a template within a source string. It works with string-based templates and sources, returning lists of match results or error-handled single matches. It supports configuration options for matching behavior and tracks the language name and associated file extensions for Coq.",
      "description_length": 405,
      "index": 713,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Engine.S-Dhall",
      "library": "comby-kernel",
      "description": "This module performs structural matching of Dhall configuration files using templates, supporting both full and partial matches within a source. It operates on Dhall syntax trees, enabling precise queries and transformations tailored to infrastructure-as-code workflows. Use cases include automated refactoring, configuration validation, and policy enforcement in Dhall-based systems.",
      "description_length": 384,
      "index": 714,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Alpha.Csharp",
      "library": "comby-kernel",
      "description": "This module implements C#-specific pattern matching over source code using structural templates. It provides operations to find all matches or the first match of a template in a given source string, supporting recursive matching when enabled. The module works with C# syntax trees and exposes match results with contextual information like positions and captured variables. Use cases include code analysis, refactoring tools, and static verification of C# codebases.",
      "description_length": 466,
      "index": 715,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Alpha.Dhall",
      "library": "comby-kernel",
      "description": "This module provides functions to match Dhall templates against source code, supporting both full and first-occurrence matching with optional configuration and file context. It operates on strings representing templates and source code, returning lists of matches or individual match results. Use cases include finding all instances of a Dhall expression in a file or locating the first match starting at a specific position.",
      "description_length": 425,
      "index": 716,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Engine.S-Move",
      "library": "comby-kernel",
      "description": "This module performs structural matching of code templates against source code, supporting both full and first-match scans. It operates on strings representing code templates and source content, returning detailed match information. It is used to identify syntactic patterns in code for tasks like refactoring or analysis.",
      "description_length": 322,
      "index": 717,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Solidity",
      "library": "comby-kernel",
      "description": "This module provides configurations and metadata for processing Solidity source files. It defines syntax-specific elements like delimiters, string literals, and comment styles, enabling accurate parsing and pattern matching. It also includes identifiers and file extensions associated with Solidity, allowing tools to recognize and handle Solidity files based on name or extension. For example, it supports configuring parsers to handle raw strings or detect Solidity files by `.sol` extension.",
      "description_length": 494,
      "index": 718,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Alpha.Lisp",
      "library": "comby-kernel",
      "description": "This module provides functions to match Lisp code patterns in source code using templates, supporting both full and first-occurrence matching with optional configuration and file context. It operates on strings representing Lisp code and returns structured match results. Use cases include finding specific function calls, macros, or syntactic structures in Lisp files for refactoring or analysis.",
      "description_length": 397,
      "index": 719,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Omega.Zig",
      "library": "comby-kernel",
      "description": "This module provides functions to match templates against source code in Zig, including finding all matches with optional nested recursion and locating the first match starting at a specified position. It operates on strings representing source code and templates, returning lists of match results or individual match outcomes. Use cases include pattern-based code analysis and transformation tasks specific to Zig source files.",
      "description_length": 428,
      "index": 720,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Engine.S-Paren",
      "library": "comby-kernel",
      "description": "This module performs structural matching of code templates against source code, supporting recursive nested matching. It operates on strings representing code templates and source input, returning lists of match results with positional and structural details. It is used to find all or first occurrences of a template pattern in a given source code, particularly for language-specific syntax matching.",
      "description_length": 401,
      "index": 721,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Omega.Java",
      "library": "comby-kernel",
      "description": "This module provides functions to match Java code against templates, supporting both full and first-match searches with configurable parameters. It operates on Java source code as input strings and returns structured match results. Use cases include finding specific code patterns in Java files for refactoring or analysis tasks.",
      "description_length": 329,
      "index": 722,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Julia",
      "library": "comby-kernel",
      "description": "This module provides precise definitions for Julia's syntax elements and language metadata to support accurate code parsing and analysis. It includes data types for representing string delimiters, comment structures, and language identifiers, along with operations to access and match these elements in Julia source code. For example, it enables tools to correctly parse string interpolations and detect valid file extensions for Julia scripts. Specific applications include configuring linters, formatters, and syntax highlighters to handle Julia's unique syntax and file conventions.",
      "description_length": 585,
      "index": 723,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Template.Make",
      "library": "comby-kernel",
      "description": "Parses string templates into structured representations and extracts variables from template syntax. Works with strings and custom syntax definitions to identify placeholders. Useful for transforming text patterns into executable templates or analyzing template structure.",
      "description_length": 272,
      "index": 724,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Fortran",
      "library": "comby-kernel",
      "description": "This module provides essential metadata and syntax definitions for working with Fortran code. It includes data types for language identifiers, file extensions, string literals, and comment structures, along with operations to access and match these elements. You can use it to detect Fortran files by extension, parse comments, or configure tools to handle Fortran-specific syntax in code analysis or transformation tasks.",
      "description_length": 422,
      "index": 725,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.R",
      "library": "comby-kernel",
      "description": "This module provides precise syntactic definitions and language metadata for working with R code. It includes customizable syntax elements like delimiters, string literals, and comments, along with core data types for parsing and pattern matching. Operations allow configuring parsers for R source files and retrieving language identifiers and file extensions. For example, you can define custom string delimiters for R code analysis or detect R files based on their extensions.",
      "description_length": 478,
      "index": 726,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Engine.S-Xml",
      "library": "comby-kernel",
      "description": "This module provides functions to match XML templates against source code, supporting both full and first-match scans with configurable parameters. It operates on strings representing XML templates and source code, returning structured match results. Use cases include identifying specific XML patterns in documents or codebases, such as detecting or transforming certain XML node structures.",
      "description_length": 392,
      "index": 727,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Alpha.Typescript",
      "library": "comby-kernel",
      "description": "This module provides functions to match TypeScript code patterns against source code using templates, supporting both full and first-match scans with configurable parameters. It operates on strings representing code templates and source files, returning structured match results or errors. Use cases include code analysis, transformation, and querying within TypeScript files based on syntactic patterns.",
      "description_length": 404,
      "index": 728,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Omega.SQL",
      "library": "comby-kernel",
      "description": "This module implements SQL-specific pattern matching operations for finding and extracting structured elements in SQL code. It provides functions to locate all matches or the first occurrence of a template within a source string, supporting nested matching when enabled. The module works directly with SQL syntax trees and string-based templates, enabling precise code analysis tasks like query transformation or schema validation.",
      "description_length": 431,
      "index": 729,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.JSON",
      "library": "comby-kernel",
      "description": "This module provides facilities for parsing and identifying JSON content with customizable syntax handling and format recognition. It supports operations to define delimiters, manage string literals, escape sequences, and comments, allowing adaptation to various JSON dialects. Key data types include configurations for syntax elements and metadata such as language name and file extensions. Examples include adjusting a parser to accept non-standard quotes or recognizing JSON files by their `.json` extension.",
      "description_length": 511,
      "index": 730,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Move",
      "library": "comby-kernel",
      "description": "This module provides syntactic and metadata definitions essential for processing Move source code. It includes data types for delimiters, string literals, comments, and language identifiers, along with operations to configure parsing and recognize file extensions. You can use it to build tools that accurately parse, analyze, or transform Move code, such as linters, formatters, or language servers. For example, it enables recognizing `.move` files and handling embedded Move snippets with custom delimiters.",
      "description_length": 510,
      "index": 731,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages.Paren",
      "library": "comby-kernel",
      "description": "This module organizes language metadata and syntax rules for parenthetical languages, enabling configuration and parsing based on file extensions, delimiters, and custom syntax markers. It supports operations to define and retrieve language names, extensions, string literals, comments, and nested delimiters. For example, it can map a file extension to a language name, specify custom parentheses for code folding, or configure string escaping for syntax highlighting.",
      "description_length": 469,
      "index": 732,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Rule",
      "library": "comby-kernel",
      "description": "This module defines match rules using abstract syntax expressions and provides operations to create, apply, and evaluate them. It works with rule expressions, match environments, and configuration options like nested matching and metasyntax. Concrete use cases include parsing and applying structured rewrite rules to source code during matching or transformation processes.",
      "description_length": 374,
      "index": 733,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Configuration",
      "library": "comby-kernel",
      "description": "This module defines configuration parameters that control matching behavior, such as exact or fuzzy matching, handling of whitespace, and newline treatment. It works with the `t` type representing the configuration state and `match_kind` to specify matching precision. Concrete use cases include customizing how pattern variables are substituted and adjusting matching rules for structured text processing.",
      "description_length": 406,
      "index": 734,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Metasyntax",
      "library": "comby-kernel",
      "description": "This module defines the core syntax and behavior of holes for code templates, supporting parsing and representation of constructs like delimited holes, reserved identifiers, and regex patterns. It works with submodules that configure default metasyntax rules and parameterize matchers using hole syntax configurations, identifiers, and aliases. Main data types include `hole_syntax` and `alias`, enabling customizable pattern matching and structured placeholder handling. Example uses include setting up parsers to recognize wildcards or variables and configuring code transformation tools to apply user-defined syntax rules.",
      "description_length": 625,
      "index": 735,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Matcher",
      "library": "comby-kernel",
      "description": "This module enables pattern matching over abstract syntax trees and source code, supporting structural and syntactic comparisons for code analysis and transformation. It provides core operations to match tree nodes and source strings against templates, with configurable options for nesting and position. The main data types include tree representations like concrete syntax trees and string-based code fragments, manipulated through functions that find all or first matches in a given context. Examples include identifying specific syntax constructs in a source file, implementing refactoring tools, or building syntax-aware diffing utilities.",
      "description_length": 644,
      "index": 736,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Match.Range",
      "library": "comby-kernel",
      "description": "This module defines a range structure with start and end locations, used to represent matched regions in source code. It provides equality checks, serialization to and from S-expressions and JSON, and a default value. Concrete use cases include tracking positions of matches in code transformation tools and parsing workflows.",
      "description_length": 326,
      "index": 737,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Match.Environment",
      "library": "comby-kernel",
      "description": "This module manages environments for storing and manipulating metavariables during pattern matching. It supports operations to add, update, and look up metavariables along with their associated values and ranges, and provides functions to merge, copy, and compare environments. Use cases include tracking variable bindings during template matching and capturing structured data from matched patterns.",
      "description_length": 400,
      "index": 738,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Template",
      "library": "comby-kernel",
      "description": "This module models template syntax for pattern matching, offering types like `kind`, `syntax`, `atom`, and `t` to represent variables, constants, and transformations. It supports converting between S-expressions and structured templates, enabling parsing and serialization for code transformation rules. The Parses submodule handles string-to-structure conversion, identifying placeholders and supporting custom syntax, making it possible to build refactoring tools that analyze or generate templated code from text patterns.",
      "description_length": 525,
      "index": 739,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Specification",
      "library": "comby-kernel",
      "description": "This module defines a specification for matching and rewriting code patterns using templates and optional rules. It works with strings as match and rewrite templates, alongside rule types that define transformation logic. It is used to create and process specifications that can generate regular expressions or apply transformations to source code.",
      "description_length": 348,
      "index": 740,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Omega",
      "library": "comby-kernel",
      "description": "This module enables syntax-aware pattern matching and parsing across a wide range of structured text formats and programming languages, including JSON, XML, and syntax trees for languages like Java, OCaml, and Rust. It offers core utilities to construct and apply language-specific matchers based on file extensions or custom syntax rules, supporting tasks like code refactoring, static analysis, and transformation, while handling language-specific features such as nested structures and metasyntax customization. Child modules extend this functionality with language-specific implementations\u2014covering Solidity, C, TypeScript, Python, Rust, Haskell, and more\u2014each providing functions to match templates against source code, returning structured match results with support for nested and positional matching. These modules enable precise querying and transformation of codebases, from finding all occurrences of a pattern to identifying the first match at a specific location, across diverse languages and structured formats.",
      "description_length": 1025,
      "index": 741,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Match.Location",
      "library": "comby-kernel",
      "description": "This module defines a data structure for representing positions in text, including offset, line, and column numbers. It provides functions for equality checks, serialization to and from S-expressions and JSON, and a default value. It is used to track and compare positions in source code during parsing or matching operations.",
      "description_length": 326,
      "index": 742,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Languages",
      "library": "comby-kernel",
      "description": "This module enables syntax-aware pattern matching and structural analysis across a wide range of programming languages and data formats, using custom parsers and language-specific metadata. It supports operations like language detection via file extensions, context-sensitive parsing, and code transformation for structured formats such as JSON, GraphQL, and LaTeX. Each child module provides precise syntax definitions\u2014such as delimiters, string literals, and comment structures\u2014along with language identifiers and file extensions for specific languages including Bash, ReasonML, Haskell, Go, Swift, C, Pascal, Rust, MATLAB, PHP, Kotlin, TypeScript, HTML, Python, Scala, Elixir, Ruby, Java, Elm, OCaml, and many more. These components enable tools like linters, formatters, refactoring engines, and static analyzers to accurately parse, match, and transform code based on each language's lexical and syntactic rules.",
      "description_length": 917,
      "index": 743,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Rewrite",
      "library": "comby-kernel",
      "description": "This module handles rewrite operations for match templates using environment substitutions. It works with match lists and environments to apply rewrite rules, supporting custom metasyntax and fresh variable generation. Use it to replace matched patterns in source code with rewritten values, either in-place or as separate outputs.",
      "description_length": 331,
      "index": 744,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Alpha",
      "library": "comby-kernel",
      "description": "This module enables language-specific pattern matching and parsing across a wide range of structured text formats and programming languages. It provides core operations for analyzing, rewriting, and traversing source code using syntax-aware AST manipulation and custom metasyntax configurations, with support for data formats like JSON, XML, and SQL. Child modules extend this functionality to specific languages such as Haskell, Scala, F#, SQL, JSX, JavaScript, Go, Kotlin, Python, OCaml, C, Rust, and more, each offering functions to find all or the first match of a template in a source string, often with configurable recursion and positional control. Examples include identifying function definitions in Scala, extracting SQL query patterns, transforming JSX elements, locating variable assignments in Python, and performing structural searches in C or Rust code, all returning structured match results for further processing or rewriting.",
      "description_length": 944,
      "index": 745,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.Hole",
      "library": "comby-kernel",
      "description": "This module defines hole types for pattern matching, such as `Expression`, `Alphanum`, and `Regex`, each controlling how placeholders in templates are matched against code. It works with string fragments and syntax trees to support customizable matching in code transformation tools. Concrete use cases include parsing and rewriting code based on structural patterns with flexible placeholder semantics.",
      "description_length": 403,
      "index": 746,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Ast",
      "library": "comby-kernel",
      "description": "This module defines an abstract syntax tree (AST) for representing matching and rewriting rules. It includes types for atoms (templates or strings), antecedents, and logical expressions such as equality checks, pattern matching, and rewrite operations. These structures are used to encode transformation rules that can be applied to code during matching or rewriting tasks.",
      "description_length": 373,
      "index": 747,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers.External",
      "library": "comby-kernel",
      "description": "This module provides a matcher interface for identifying and extracting substrings using structured pattern matching, working with file paths, line and column positions, and string-based patterns. It supports parsing and transforming code during refactoring tasks, such as matching function calls or variable declarations. The default external handler processes structured data with predefined rules, enabling integration of custom matchers for code analysis or syntax tree manipulation. Specific examples include traversing source files to rewrite code based on patterns or extracting specific syntax elements for further processing.",
      "description_length": 634,
      "index": 748,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Matchers.Engine",
      "library": "comby-kernel",
      "description": "This module implements a structural code pattern matching engine that operates on abstract syntax trees, enabling precise alignment of code against templates with support for pattern variables. It provides core operations to compare and transform code structures, with submodules extending functionality to specific languages and use cases\u2014such as Elixir, JavaScript, CSS, Java, Ruby, and more\u2014each offering functions to find first or all matches in source code strings, often with configurable nesting and positional control. The API supports tasks like code refactoring, static analysis, and pattern-based transformation, returning structured match results enriched with contextual and positional data. Examples include identifying function calls in JavaScript, locating method declarations in Java, extracting CSS rules, or rewriting expressions in languages like Rust, Python, and Go.",
      "description_length": 888,
      "index": 749,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "Comby_kernel.Matchers.Language",
      "library": "comby-kernel",
      "description": "This module defines the syntax and parsing rules for pattern matching in source code, providing data structures for grammars and utilities to identify code constructs like identifiers, literals, and operators. It supports precise structural matching and transformation across languages, using metadata such as file extensions and comment syntax to guide parsing and analysis. Submodules handle language identification, syntax configuration, and AST-level transformations, enabling use cases like configuring linters, parsing string literals, and implementing refactoring tools. Core types include AST nodes, syntax delimiters, and language metadata, with operations to serialize syntax definitions, detect languages from file extensions, and apply language-specific parsing rules.",
      "description_length": 780,
      "index": 750,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Match",
      "library": "comby-kernel",
      "description": "This module captures structured match results from pattern matching in source code, providing data types and operations to represent matched ranges, environments of metavariables, and source positions. It supports creating and manipulating match instances, converting offsets to line and column positions, and serializing match data to JSON or S-expressions for tasks like formatting grep-like output or exporting match information. The range module handles regions of code with start and end locations, enabling precise tracking of matches, while the environment module manages metavariable bindings with support for updates, lookups, and merging. The position module represents and compares text positions, integrating with the range and match modules to support parsing and transformation workflows.",
      "description_length": 802,
      "index": 751,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Comby_kernel.Replacement",
      "library": "comby-kernel",
      "description": "This module represents the outcome of a rewrite operation, capturing the range of text replaced, the new content, and the matching environment. It includes functions to convert replacement results to and from JSON, supporting serialization and structured output. Use this module to generate JSON reports of code transformations or apply substitutions and collect their metadata for further processing.",
      "description_length": 401,
      "index": 752,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel.Matchers",
      "library": "comby-kernel",
      "description": "This module enables structured pattern matching and code transformation through customizable metasyntax, working with abstract syntax trees, source strings, and templates. It supports precise matching, rewriting, and analysis of code using core data types like match environments, rule expressions, configuration parameters, and hole syntax. Operations include parsing and applying structured rewrite rules, configuring matching precision, handling placeholders with regex or AST-based semantics, and performing language-aware matching across a wide range of formats. Specific uses include refactoring codebases, extracting syntactic constructs, implementing linters, and transforming structured text using declarative rules with support for nested and positional matching.",
      "description_length": 773,
      "index": 753,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comby_kernel",
      "library": "comby-kernel",
      "description": "This module enables structural code analysis and transformation through pattern matching and rewriting, combining direct APIs for rule application with utilities for handling match results and rewrite outcomes. It centers on data types like match environments, ranges, and rewrite results, supporting operations to parse, match, replace, and serialize code transformations with precise positional tracking and metavariable handling. Use it to implement refactoring tools, linters, or code generation pipelines that work across multiple languages and handle complex syntactic structures. Submodules structure match data, manage replacement metadata, and configure pattern semantics to enable end-to-end code manipulation workflows.",
      "description_length": 730,
      "index": 754,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Vangstrom_unix",
      "library": "comby-kernel.vangstrom-unix",
      "description": "This module provides functions for parsing data from input channels using Vangstrom parsers. It supports both single-shot parsing and streaming multiple values from a channel. The `parse` function reads until a value is produced, while `parse_many` applies a parser repeatedly, consuming values as they are parsed. Useful for efficiently parsing binary or structured text data from files or network streams.",
      "description_length": 407,
      "index": 755,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 758,
    "meaningful_modules": 756,
    "filtered_empty_modules": 2,
    "retention_rate": 0.9973614775725593
  },
  "statistics": {
    "max_description_length": 1025,
    "min_description_length": 239,
    "avg_description_length": 421.26851851851853,
    "embedding_file_size_mb": 2.7469778060913086
  }
}