{
  "package": "petrol",
  "embedding_model": "Qwen/Qwen3-Embedding-8B",
  "embedding_dimension": 4096,
  "total_modules": 15,
  "creation_timestamp": "2025-08-14T23:22:43.271550",
  "modules": [
    {
      "module_path": "Petrol.Sqlite3.Expr",
      "library": "petrol",
      "description": "This module enables type-safe construction of SQL expressions through arithmetic operators, logical combinators, and aggregation functions, while supporting nullable values and explicit type coercion. It operates on typed SQL expressions that represent literals (integers, strings, booleans), computed values, and conditional logic, ensuring correctness during query composition. Typical applications include building dynamic SQL queries with safe parameter binding, expressing complex WHERE clauses with logical operators, and performing aggregations like `SUM` or `COUNT` with compile-time type guarantees.",
      "description_length": 608,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Petrol.Postgres.Type",
      "library": "petrol",
      "description": "This module directly maps PostgreSQL scalar types to OCaml values, enabling precise type declarations for database interactions. It includes typed values for integers, floats, strings, booleans, dates, times, binary data, and variable/ fixed-length character types. These are used to define schema types and ensure correct data handling in queries and result parsing.",
      "description_length": 367,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Petrol.Sqlite3.Type",
      "library": "petrol",
      "description": "This module defines values representing SQLite type mappings for use in database interactions. It includes types for boolean, integer, floating-point, text, and binary data, each corresponding directly to SQLite's storage classes. These values are used to specify column types when defining database schemas or parameter types in queries.",
      "description_length": 338,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Petrol.Type.Numeric",
      "library": "petrol",
      "description": "This module defines a set of operations for numeric type abstractions, including addition, multiplication, and comparison functions. It works with abstract numeric types that implement basic arithmetic interfaces, enabling generic numeric computations. Concrete use cases include writing functions that operate uniformly on integers, floats, or custom numeric types without committing to a specific representation.",
      "description_length": 414,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Petrol.Postgres.Expr",
      "library": "petrol",
      "description": "This module provides a rich set of operations for constructing and manipulating typed SQL expressions, including arithmetic, comparisons, boolean logic, string manipulation, and aggregate functions. It works with type-safe SQL expressions wrapped in a generic container type, supporting numeric, boolean, string, and nullable values while enforcing correct SQL syntax and type discipline. Specific use cases include building complex PostgreSQL queries with compile-time type checking, safely composing dynamic expressions for updates or conditions, and leveraging PostgreSQL-specific math and string functions like `ceil`, `coalesce`, or `similar_to` within OCaml code.",
      "description_length": 669,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Petrol.Postgres",
      "library": "petrol",
      "description": "This module provides precise mappings from PostgreSQL scalar types to OCaml values, supporting integers, floats, strings, booleans, dates, times, binary data, and character types. It enables type-safe construction and manipulation of SQL expressions with arithmetic, comparison, boolean, string, and aggregate operations. Use it to define database schema types, build complex queries with compile-time type checking, and safely compose dynamic SQL expressions using PostgreSQL-specific functions.",
      "description_length": 496,
      "index": 5,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Petrol.StaticSchema",
      "library": "petrol",
      "description": "This module supports creating and initializing a static database schema with tables and constraints. It works with SQL database connections and schema/table definitions using Caqti. Use it to prototype or debug database schemas by declaring tables and initializing them in a database.",
      "description_length": 284,
      "index": 6,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Petrol.Expr",
      "library": "petrol",
      "description": "This module provides functions to pretty print SQL expressions and lists of expressions using OCaml's Format module. It defines the `pp` function for individual expressions and `pp_expr_list` for formatting sequences of expressions. Use cases include generating readable SQL output for debugging or logging query structures directly from OCaml code.",
      "description_length": 349,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Petrol.Request",
      "library": "petrol",
      "description": "This module creates SQL request values from query values, specifying how many results the query will return. It supports constructing requests for queries that return zero, one, zero-or-one, or many results. These requests can be executed using Caqti functions like `exec`, `find`, and `find_opt`, and are designed to be cached safely for repeated use.",
      "description_length": 352,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Petrol.Schema",
      "library": "petrol",
      "description": "This module enables defining SQL table schemas using OCaml types and expressions. It provides functions to construct table fields with constraints such as primary keys, foreign keys, uniqueness, and nullability, along with conflict resolution clauses for SQL operations. Concrete use cases include declaring database tables with strongly-typed columns and specifying referential integrity constraints directly in OCaml code.",
      "description_length": 424,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Petrol.VersionedSchema",
      "library": "petrol",
      "description": "This module manages versioned database schemas with support for defining tables, migrations, and version constraints. It works with version numbers as integer lists and uses Caqti for SQL execution, allowing schema initialization and migration tracking against a database connection. Concrete use cases include declaring tables with versioned existence, specifying migration scripts between schema versions, and checking or applying necessary database updates based on stored state.",
      "description_length": 482,
      "index": 10,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Petrol.Query",
      "library": "petrol",
      "description": "This module provides an embedded domain-specific language for constructing SQL queries using OCaml expressions. It supports query-building operations like `select`, `update`, `insert`, and `delete`, along with SQL-specific clauses such as `where`, `join`, `group_by`, `order_by`, and `limit`. These functions work with typed expressions and query structures to enable precise, composable construction of SQL statements for use in database interactions.",
      "description_length": 452,
      "index": 11,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Petrol.Type",
      "library": "petrol",
      "description": "This module defines SQL type representations and pretty-printing utilities for values. It provides functions to create custom SQL types with associated Caqti type bindings, format type representations, and print values according to their SQL type. Concrete use cases include mapping OCaml types to SQL types when writing database queries and generating readable debug output for typed values.",
      "description_length": 392,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Petrol.Sqlite3",
      "library": "petrol",
      "description": "This module provides type definitions and helper values for mapping OCaml types to SQLite storage classes, along with a system for constructing and composing type-safe SQL expressions. It works directly with boolean, integer, float, string, and binary data types, enabling precise schema definitions and query parameters. Concrete use cases include defining database schemas with explicit column types, building type-checked SQL queries with conditions and arithmetic, and safely aggregating values like counts and sums in queries.",
      "description_length": 531,
      "index": 13,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Petrol",
      "library": "petrol",
      "description": "This module provides a comprehensive set of tools for building and executing type-safe SQL queries and managing database schemas directly from OCaml. It includes functions for constructing and running SQL requests with precise result handling, utilities for defining and migrating database schemas, and modules tailored for specific SQL dialects like SQLite and PostgreSQL. Use cases include generating and executing complex SQL queries with compile-time type checking, defining database tables with constraints, and managing schema versions with migration support.",
      "description_length": 565,
      "index": 14,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 15,
    "meaningful_modules": 15,
    "filtered_empty_modules": 0,
    "retention_rate": 1.0
  },
  "statistics": {
    "max_description_length": 669,
    "min_description_length": 284,
    "avg_description_length": 448.2,
    "embedding_file_size_mb": 0.21777629852294922
  }
}