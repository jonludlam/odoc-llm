{
  "package": "caisar",
  "embedding_model": "BAAI/bge-base-en-v1.5",
  "embedding_dimension": 1024,
  "total_modules": 48,
  "creation_timestamp": "2025-06-18T16:42:15.458660",
  "modules": [
    {
      "module_path": "Onnx.Onnx_protoc.Onnx.TensorShapeProto.Dimension",
      "description": "Provides functions to create, serialize, and deserialize tensor dimension metadata with optional semantic denotations. Works with a custom type representing dimensions that can hold integer values, parameter names, or be unset, along with associated denotation strings. Used to encode and decode dimension information for interoperability with ONNX tensor formats.",
      "description_length": 364,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Onnx.Onnx_protoc.Onnx.TensorProto.DataType",
      "description": "Provides functions to handle IEEE754 half-precision floats (16-bit) with 5 exponent and 10 mantissa bits, as well as a non-IEEE 16-bit format with 8 exponent and 7 mantissa bits. Supports complex numbers with float32 and float64 components. Includes a name function to retrieve the fully qualified protobuf name.",
      "description_length": 312,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Onnx.Onnx_protoc.Onnx.TensorProto.DataLocation",
      "description": "Represents the storage location of tensor data, distinguishing between in-protobuf and external storage. Provides a function to retrieve the fully qualified protobuf name of the enum. Works with a discriminated union type to encode whether data is embedded or referenced externally.",
      "description_length": 282,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Onnx.Onnx_protoc.Onnx.TensorProto.Segment",
      "description": "Provides functions to serialize and deserialize data structures representing tensor segments between binary and JSON formats, with support for default values during creation. Works with a custom type `t` that includes optional start and end indices for segment definitions. Used to encode and decode tensor segment metadata in protocols requiring chunked storage.",
      "description_length": 363,
      "index": 3,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Onnx.Onnx_protoc.Onnx.TypeProto.Tensor",
      "description": "Provides functions to serialize and deserialize data structures to and from binary and JSON formats, with support for specifying element types and shapes. Works with tensor data represented as a custom type, including operations to convert to and from Protobuf and JSON. Used to handle tensor metadata in machine learning workflows, ensuring compatibility with serialization standards.",
      "description_length": 385,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Onnx.Onnx_protoc.Onnx.TypeProto.Sequence",
      "description": "Generates and manipulates protocol buffer messages using binary and JSON serialization. Operates on a type `t` representing an optional protocol buffer type. Used to convert messages to and from binary or JSON formats for communication or storage.",
      "description_length": 247,
      "index": 5,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Onnx.Onnx_protoc.Onnx.TypeProto.Map",
      "description": "Provides functions to serialize and deserialize data structures to and from protocol buffer binary format, JSON, and retrieve the fully qualified name of the message. Works with a custom type `t` representing a protobuf message. Used to convert between in-memory data and serialized formats for network transmission or storage.",
      "description_length": 327,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Onnx.Onnx_protoc.Onnx.TypeProto.Optional",
      "description": "Handles serialization and deserialization of optional typed values between binary (Protocol Buffers), JSON, and internal representations. Operates on `TypeProto.t option` to encapsulate optional type information. Used to convert between protocol buffer messages and JSON formats while preserving type metadata.",
      "description_length": 310,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Onnx.Onnx_protoc.Onnx.TypeProto.SparseTensor",
      "description": "Provides operations to serialize and deserialize data structures to and from binary and JSON formats, with support for specifying element types and tensor shapes. Works with tensor data types and shape information defined in the TensorProto module. Used to convert in-memory tensor representations into protocol buffer or JSON formats for storage or transmission.",
      "description_length": 363,
      "index": 8,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Onnx.Onnx_protoc.Onnx.AttributeProto.AttributeType",
      "description": "Provides functions to retrieve the fully qualified protobuf name of an enum value. Works with an enumerated type representing attribute types used in schema definitions. Used to serialize or deserialize attribute type information in a protocol buffers context.",
      "description_length": 260,
      "index": 9,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Onnx.Onnx_protoc.Onnx.Version",
      "description": "Provides functions to retrieve the fully qualified protobuf name of a version enum and defines a type for version identifiers. Works with string representations and an explicitly numbered enum structure. Used to ensure compatibility between proto2 and proto3 by enforcing explicit versioning in serialized data.",
      "description_length": 311,
      "index": 10,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Onnx.Onnx_protoc.Onnx.OperatorStatus",
      "description": "Provides functions to retrieve the fully qualified protobuf name of an enum and defines a type `t` representing operator status. Works with string and enum data structures to encode and identify operational states. Used to serialize and deserialize status values in protocol buffer messages.",
      "description_length": 291,
      "index": 11,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Onnx.Onnx_protoc.Onnx.AttributeProto",
      "description": "Encapsulates attribute data with distinct types for singular or repeated values, including numeric, string, graph, and tensor representations. Offers operations to extract and manipulate attribute names, types, and underlying values, supporting both single and repeated structures. Enables precise handling of attribute serialization, deserialization, and type checking within protocol buffer contexts. For example, it can retrieve the protobuf name of an attribute type or extract a float value from a named attribute.",
      "description_length": 519,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Onnx.Onnx_protoc.Onnx.ValueInfoProto",
      "description": "Provides serialization and deserialization functions for converting between a structured value representation and binary or JSON formats, along with methods to extract the fully qualified name. Works with a custom type containing name, type, and documentation fields. Used to encode and decode value metadata during protocol buffer processing.",
      "description_length": 343,
      "index": 13,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Onnx.Onnx_protoc.Onnx.NodeProto",
      "description": "Provides functions to construct, serialize, and deserialize node representations used in computation graphs, supporting operations like convolution and fully connected layers. Works with structured data including input/output tensors, operation types, attributes, and documentation strings. Used to generate and parse node definitions for machine learning model serialization and exchange.",
      "description_length": 389,
      "index": 14,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Onnx.Onnx_protoc.Onnx.TrainingInfoProto",
      "description": "Stores model training configuration with initialization and algorithm steps, using graph structures and string bindings. It handles serialization to and from Protobuf and JSON formats. Used to define and persist training workflows for model reinitialization and parameter updates.",
      "description_length": 280,
      "index": 15,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Onnx.Onnx_protoc.Onnx.ModelProto",
      "description": "Provides functions to serialize and deserialize model data between binary and JSON formats, and to construct model instances with metadata, computation graphs, and operator sets. Operates on structured data types including GraphProto, OperatorSetIdProto, and custom metadata entries. Used to persist and exchange machine learning models with associated execution graphs and configuration details.",
      "description_length": 396,
      "index": 16,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Onnx.Onnx_protoc.Onnx.StringStringEntryProto",
      "description": "Provides functions to serialize and deserialize a key-value pair of strings into binary and JSON formats, along with a helper to create instances using default values. Operates on a custom type representing a string-to-string map entry. Used to handle protocol buffer messages in a version-agnostic way during data exchange.",
      "description_length": 324,
      "index": 17,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Onnx.Onnx_protoc.Onnx.TensorAnnotation",
      "description": "Provides functions to create, serialize, and deserialize annotated tensor metadata using predefined keys like 'SCALE_TENSOR' and 'ZERO_POINT_TENSOR'. Works with protocol buffer and JSON formats, and stores information tied to a specific tensor name. Used to encode quantization parameters for ONNX tensors during model serialization.",
      "description_length": 333,
      "index": 18,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Onnx.Onnx_protoc.Onnx.GraphProto",
      "description": "Provides operations to serialize and deserialize graph structures to and from binary and JSON formats, and to construct graphs with nodes, inputs, outputs, and metadata. Works with types such as NodeProto.t, TensorProto.t, ValueInfoProto.t, and related protobuf structures. Used to persist and load model configurations in machine learning workflows.",
      "description_length": 350,
      "index": 19,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Onnx.Onnx_protoc.Onnx.TensorProto",
      "description": "Encodes and manipulates tensor data with support for multiple floating-point formats, including IEEE754 half-precision and custom 16-bit variants, along with complex numbers using 32- and 64-bit components. Tracks tensor data location as either embedded within the protobuf or externally referenced, using a discriminated union to represent storage choices. Serializes and deserializes tensor segments between binary and JSON, allowing for segment definitions with optional start and end indices. Enables precise control over tensor representation and storage in protocol-based data exchanges.",
      "description_length": 593,
      "index": 20,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Onnx.Onnx_protoc.Onnx.SparseTensorProto",
      "description": "Provides functions to serialize and deserialize sparse-tensor data between binary and JSON formats, and to construct instances using tensor values, indices, and dimensions. Operates on tensor data structures represented as Protobuf messages and lists of integers for dimensions. Used to encode sparse tensors for storage or transmission in systems relying on Protobuf and JSON serialization.",
      "description_length": 391,
      "index": 21,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Onnx.Onnx_protoc.Onnx.TensorShapeProto",
      "description": "Encapsulates tensor dimension metadata with support for integers, symbolic variables, and denotations. Offers creation, serialization, and deserialization functions for structured dimension handling. Enables encoding of shape information for ONNX compatibility and decoding for runtime analysis. Examples include defining a dynamic batch size with a parameter name or serializing a fixed tensor rank.",
      "description_length": 400,
      "index": 22,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Onnx.Onnx_protoc.Onnx.TypeProto",
      "description": "Serializes and deserializes tensor and protocol buffer data between binary, JSON, and in-memory representations, supporting type and shape specifications. It handles custom types such as `t` for protobuf messages and `TypeProto.t option` for optional type information, enabling conversion between serialized formats and internal structures. Operations include retrieving fully qualified message names, converting tensor metadata, and managing optional values. Examples include converting a tensor to JSON for storage or parsing a protobuf message into an in-memory structure for processing.",
      "description_length": 590,
      "index": 23,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Onnx.Onnx_protoc.Onnx.OperatorSetIdProto",
      "description": "Provides functions to serialize and deserialize instances using binary and JSON formats, and to generate unique identifiers based on domain and version. Works with a structured type containing domain and version fields. Used to encode and decode operator set metadata in protocol buffer and JSON representations.",
      "description_length": 312,
      "index": 24,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Onnx.Onnx_protoc.Onnx.FunctionProto",
      "description": "Provides functions to construct, serialize, and deserialize protocol buffer messages representing computational functions, including handling inputs, outputs, attributes, nodes, and documentation. Operates on types like string lists, NodeProto.t lists, and OperatorSetIdProto.t lists, along with a structured record type for function metadata. Used to generate and parse function definitions in machine learning models, ensuring consistent representation across serialization formats.",
      "description_length": 484,
      "index": 25,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Nir.Ngraph.GFloat.E",
      "description": "Provides functions to extract source and destination vertices from a pair representing a directed edge. Works with tuples of vertex values as the core data structure. Used to process graph edges in algorithms that require separate access to start and end points.",
      "description_length": 262,
      "index": 26,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Onnx.Onnx_protoc.Onnx",
      "description": "Encapsulates ONNX data structures with support for versioning, operator status, attributes, values, nodes, models, and tensors, enabling precise serialization and deserialization across binary and JSON formats. Key types include version identifiers, operator status, attribute containers, node definitions, tensor metadata, and graph structures, with operations to extract, manipulate, and convert these elements. It allows tasks such as retrieving protobuf names, encoding quantization parameters, serializing computation graphs, and handling sparse tensor data. Examples include converting a tensor to JSON, parsing node definitions, and managing dynamic tensor shapes.",
      "description_length": 671,
      "index": 27,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Nir.Ngraph.GFloat",
      "description": "Provides functions to decompose directed edge pairs into source and destination vertices, using tuples as the primary data structure. Enables precise manipulation of graph edges in algorithms requiring separate access to start and end points. Supports operations like extracting the first element of a pair as the source or the second as the destination. Can be used to traverse or analyze directed graph structures by isolating vertex relationships.",
      "description_length": 450,
      "index": 28,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Nir.Ngraph.Dot",
      "description": "Produces visual representations of graph structures by formatting or writing them to a file or output channel. Operates on `GFloat.t` type, which represents directed graphs with floating-point weights. Used to generate graph diagrams for analysis or debugging purposes.",
      "description_length": 269,
      "index": 29,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Onnx.Onnx_protoc",
      "description": "Encapsulates ONNX data structures with versioning, operator status, attributes, nodes, models, and tensors, supporting serialization and deserialization in binary and JSON formats. Key types include version identifiers, attribute containers, node definitions, tensor metadata, and graph structures, with operations to extract, manipulate, and convert these elements. It enables tasks like retrieving protobuf names, encoding quantization parameters, and handling sparse tensor data. Examples include converting a tensor to JSON, parsing node definitions, and managing dynamic tensor shapes.",
      "description_length": 590,
      "index": 30,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Onnx.Reader",
      "description": "Parses ONNX files into an internal representation, extracting input and output tensors. Works with file paths and a private type encapsulating the ONNX model structure. Used to load models for inference or analysis workflows.",
      "description_length": 225,
      "index": 31,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Onnx.Writer",
      "description": "Writes a NIR graph to an ONNX file format using a specified filename. Operates on NIR.Ngraph.t structures representing neural network computations. Used to persist model definitions for deployment or further processing.",
      "description_length": 219,
      "index": 32,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Nir.Gentensor",
      "description": "Creates tensors from float or int64 arrays, supporting shape specification for multidimensional layouts. Operates on one-dimensional arrays and constructs tensors with explicit or inferred shapes. Used to convert raw numerical data into structured tensor representations for numerical computations.",
      "description_length": 298,
      "index": 33,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Nir.Ngraph",
      "description": "manipulates directed graphs by decomposing edges into source-destination pairs and generating visual outputs. it works with tuples to isolate vertex relationships and with `GFloat.t` to render weighted graph structures. operations include edge traversal, vertex analysis, and diagram generation. it enables detailed graph inspection and visualization for machine learning model debugging.",
      "description_length": 388,
      "index": 34,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Nir.Node",
      "description": "This module provides operations for constructing and manipulating ONNX-compatible computational nodes, including arithmetic transformations, tensor concatenation, and shape inference, aligned with ONNX IR v8 and Opset v13 standards. It works with node structures that encapsulate inputs, output shapes, and descriptions, alongside tensor-like data for constant parameters and dynamic shape computations. Use cases include optimizing inference pipelines, handling static and dynamic tensor dimensions, and ensuring compatibility with ONNX operator semantics.",
      "description_length": 557,
      "index": 35,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Nir.Shape",
      "description": "Provides operations to convert and manipulate array-based shapes, including serialization to and from arrays and lists, element access and modification, and rank and size queries. Works with a custom type `t` representing structured data layouts. Used to transform shape information for storage, communication, and low-level memory operations.",
      "description_length": 343,
      "index": 36,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Nir.Tensor",
      "description": "Provides operations to create, reshape, and access elements of multidimensional numerical arrays. Works with tensors backed by Bigarray.Genarray, supporting float64 and int64 data types. Enables converting between tensors and arrays, extracting values by coordinates, and flattening tensors into lists.",
      "description_length": 302,
      "index": 37,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Caisar_xgboost.Input",
      "description": "Provides functions to retrieve float values from a structured data type, convert feature-value pairs into this type using a parser, and parse files into lists of this type. Works with a custom type `t` and parser instances to handle input data. Used to extract specific values from parsed data and process file-based inputs for analysis.",
      "description_length": 337,
      "index": 38,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Caisar_xgboost.Parser",
      "description": "The module provides pretty-printing and JSON serialization/deserialization for XGBoost model components, including tree structures, gradient boosting parameters, and learner configurations. It operates on types like model parameters, tree records, and objective functions, supporting tasks such as converting configurations to JSON for storage or API communication, and handling parameter serialization for gbtree, gblinear, and dart models. Specific use cases include structuring machine learning specifications for training pipelines and parsing JSON inputs into OCaml types for model manipulation.",
      "description_length": 600,
      "index": 39,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Caisar_xgboost.Predict",
      "description": "Computes the sigmoid activation function for a given float value and generates a prediction based on a parsed input structure. It processes numerical data through a logistic function to produce probabilistic outputs. Used to transform model inputs into predicted probabilities during inference.",
      "description_length": 294,
      "index": 40,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Caisar_xgboost.Tree",
      "description": "Converts a parser object into a structured tree representation, and uses this structure to make predictions based on input data. It operates on custom types representing tree nodes and operations, with a focus on hierarchical data processing. Used to evaluate parsed expressions or models by traversing and applying defined operations.",
      "description_length": 335,
      "index": 41,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "caisar",
      "description": "Performs adversarial example generation, vulnerability detection, and model robustness analysis using gradient-based and query-based methods. Operates on neural network models represented as Python objects and input data in tensor formats. Enables researchers to evaluate model behavior under perturbations and assess resistance to targeted attacks.",
      "description_length": 349,
      "index": 42,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Ovo",
      "description": "Parses OVO files into a structured representation, handling input validation and error reporting. Works with string inputs and returns a result type containing either the parsed structure or an error message. Used to load and validate configuration data from OVO files in system initialization workflows.",
      "description_length": 304,
      "index": 43,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Nnet",
      "description": "Parses NNet files into a structured representation, handling optional data with a permissive flag. Converts the parsed structure into a Nir.Ngraph.t for further processing. Works with string inputs and outputs, supporting neural network models defined in the NNet format.",
      "description_length": 271,
      "index": 44,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Onnx",
      "description": "Encapsulates ONNX data structures with versioning, operator status, attributes, nodes, models, and tensors, supporting serialization and deserialization in binary and JSON formats. It provides operations to extract, manipulate, and convert elements like tensor metadata, node definitions, and graph structures, enabling tasks such as converting tensors to JSON or handling sparse data. Parses ONNX files into internal representations, extracting input and output tensors for use in inference or analysis. Writes NIR graph structures to ONNX files, allowing model definitions to be persisted for deployment or further processing.",
      "description_length": 628,
      "index": 45,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Nir",
      "description": "Combines tensor creation, graph manipulation, ONNX node handling, shape management, and array operations into a unified numerical computing framework. It supports tensor construction from arrays, graph visualization with weighted edges, ONNX node transformations, shape serialization, and multidimensional array reshaping. Users can convert raw data to tensors, debug machine learning models via graph inspection, optimize ONNX pipelines, and manage array layouts efficiently. Examples include building computational graphs, optimizing tensor dimensions, and generating visual representations of model structures.",
      "description_length": 613,
      "index": 46,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Caisar_xgboost",
      "description": "handles data parsing, model serialization, activation computation, and tree-based prediction, enabling end-to-end processing of XGBoost-related data and models. It includes a custom type `t` for structured data, supports JSON conversion for model components, and applies sigmoid functions for probabilistic predictions. It also transforms parser objects into tree structures to evaluate input data against model logic. Users can extract float values from structured inputs, serialize model configurations, compute predictions, and evaluate tree-based models.",
      "description_length": 558,
      "index": 47,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 49,
    "meaningful_modules": 48,
    "filtered_empty_modules": 1,
    "retention_rate": 0.9795918367346939
  },
  "statistics": {
    "max_description_length": 671,
    "min_description_length": 219,
    "avg_description_length": 382.9583333333333,
    "embedding_file_size_mb": 0.17478084564208984
  }
}