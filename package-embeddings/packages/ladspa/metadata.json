{
  "package": "ladspa",
  "embedding_model": "BAAI/bge-base-en-v1.5",
  "embedding_dimension": 1024,
  "total_modules": 4,
  "creation_timestamp": "2025-06-18T16:28:00.643456",
  "modules": [
    {
      "module_path": "Ladspa.Plugin",
      "description": "Loads a LADSPA plugin from a shared library file and manages its lifecycle. Operates on plugin instances represented as opaque values. Used to dynamically integrate audio processing modules into a host application.",
      "description_length": 214,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ladspa.Descriptor",
      "description": "This module enables querying and managing plugin metadata, such as unique identifiers, labels, and port configurations, while also supporting real-time audio processing tasks like connecting ports, adjusting control values, and activating instances. It operates on structured plugin data, audio buffers, and control values, facilitating both informational queries and dynamic audio workflow management. Use cases include plugin initialization, parameter tuning during performance, and automated audio routing in complex signal chains.",
      "description_length": 534,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ladspa",
      "description": "Provides functions to load, initialize, and process audio plugins using the LADSPA standard. Works with audio plugin descriptors, ports, and audio buffers. Enables real-time audio processing in applications like synthesizers and effects processors.",
      "description_length": 248,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ladspa",
      "description": "Loads a LADSPA plugin from a shared library and manages its lifecycle, working with opaque plugin instances to integrate audio processing into a host application. It handles structured plugin data, audio buffers, and control values, enabling metadata queries, port connections, and real-time parameter adjustments. Users can initialize plugins, tune controls during performance, and automate signal routing. Examples include dynamically loading a reverb plugin, adjusting its decay time, and connecting input and output buffers for audio processing.",
      "description_length": 549,
      "index": 3,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 4,
    "meaningful_modules": 4,
    "filtered_empty_modules": 0,
    "retention_rate": 1.0
  },
  "statistics": {
    "max_description_length": 549,
    "min_description_length": 214,
    "avg_description_length": 386.25,
    "embedding_file_size_mb": 0.014934539794921875
  }
}