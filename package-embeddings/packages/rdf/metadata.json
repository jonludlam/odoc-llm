{
  "package": "rdf",
  "embedding_model": "BAAI/bge-base-en-v1.5",
  "embedding_dimension": 1024,
  "total_modules": 90,
  "creation_timestamp": "2025-06-18T16:50:27.540680",
  "modules": [
    {
      "module_path": "Rdf.Mem.Mem.BGP",
      "description": "Provides operations to manipulate and query graph data, including term transformation, comparison, and retrieval of subjects and objects. Works with graph structures and term representations to support semantic queries. Enables efficient lookup of triplets based on specified subject, predicate, or object.",
      "description_length": 306,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Graph.Make.BGP",
      "description": "Provides operations to manipulate and query graph data, including term transformation, comparison, and retrieval of subjects and objects. Works with abstract term and graph types to represent and navigate structured data. Enables precise querying of triple relationships based on specified subject, predicate, or object.",
      "description_length": 320,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Sioc.Open",
      "description": "This module defines semantic relationships and properties using IRI-based structures, focusing on linking entities like users, posts, forums, and groups within social ontologies. It operates on SIOC concepts and Iri.t values to model interactions, metadata, and hierarchical connections in community-driven systems. Key use cases include structuring social network data, managing user-generated content, and enabling semantic queries for online communities.",
      "description_length": 457,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Owl.Open",
      "description": "This module provides functions to define and manipulate OWL ontology elements, including classes, properties, axioms, and annotations, by establishing semantic relationships and logical constraints. It operates on Iri.t values and ontological entities to model hierarchical structures, property characteristics, and RDF-based semantic web data. Specific use cases include expressing class disjointness, cardinality restrictions, and equivalence relationships within ontologies.",
      "description_length": 477,
      "index": 3,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rdf.Ds.NameMap",
      "description": "This module provides ordered map operations for managing key-value associations, including insertion, deletion, transformation, and traversal, with a focus on maintaining sorted key order. It works with maps where keys are of a specific type (e.g., `name`) and values are generic, enabling efficient querying and sequence-based manipulation. Use cases include configuration management, symbol table handling, and data processing scenarios requiring ordered key access and structured transformations.",
      "description_length": 499,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Ds.NameSet",
      "description": "The module provides operations for managing collections of names through set-like manipulations, including addition, removal, union, intersection, and predicate-based queries, alongside iteration and transformation functions. It works with ordered sets of elements and sequences, enabling efficient modification and traversal, such as reverse iteration or building sets from input data. Use cases include handling symbolic data in compilers or configuration systems where structured set operations and ordered processing are required.",
      "description_length": 534,
      "index": 5,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rdf.Sparql_http.Make",
      "description": "Handles HTTP GET and POST requests to a SPARQL endpoint, accepting specified content types and processing responses into out_message structures. Operates with URI values, content strings, and custom response handlers. Used to retrieve or submit SPARQL queries and updates via HTTP, with explicit control over request headers and response parsing.",
      "description_length": 346,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Security.Open",
      "description": "The module provides cryptographic operations including digital signatures, key management, and proof systems, focusing on IRI-based representations for security protocols and identity management. It works with RDF datasets, cryptographic data structures, and security metadata, handling encodings like PEM and Base58, as well as certificate chains and access control mechanisms. Use cases include securing linked data, verifying cryptographic proofs, and implementing capability-based access control in semantic web applications.",
      "description_length": 529,
      "index": 7,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rdf.Dt.ValueOrdered",
      "description": "Compares two values using a custom ordering defined by the `compare` function, returning -1, 0, or 1. It operates on the `value` type, which represents heterogeneous data including integers, strings, and nested structures. This module is used to sort lists of mixed-type values or determine equality in contexts where standard comparison is insufficient.",
      "description_length": 354,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Dt.VMap",
      "description": "This module offers comprehensive operations for manipulating ordered key-value maps, including insertion, deletion, updates, merging, and predicate-based queries, with variants for strictness and optional returns. It supports transformations like mapping and filtering, structural manipulations such as splitting and folding, and sequence-based construction/iteration, ideal for scenarios requiring ordered data processing or efficient key-based access. Specific use cases include dynamic data restructuring, efficient lookups with physical equality checks, and generating ordered output from map contents.",
      "description_length": 606,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Dt.VSet",
      "description": "The module offers standard set operations like addition, removal, and union, along with transformation functions such as mapping and filtering, all tailored for ordered sets of a generic element type. It supports efficient membership queries, ordered iteration, and conversions between sets and lists, enabling use cases like maintaining unique element collections or processing structured data with predicate-based selections. Both imperative and functional paradigms are accommodated, with behaviors emphasizing ordered traversal and element insertion control.",
      "description_length": 562,
      "index": 10,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Activitypub.Open",
      "description": "This module provides functions to define and manage IRI-based identifiers for social activity data, including actions (e.g., \"Like,\" \"Follow\"), object types (e.g., \"Note,\" \"Image\"), and metadata fields (e.g., timestamps, geographic coordinates). It operates on Iri.t values and structured data models specific to ActivityStreams and ActivityPub, enabling semantic labeling of social interactions, relationships, and content attributes. Use cases include standardizing decentralized social networking protocols, annotating JSON-based activity data, and defining endpoints for service interactions like media uploads and streams.",
      "description_length": 627,
      "index": 11,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rdf.Rdfs.Open",
      "description": "Provides IRI constants for RDFS vocabulary, including class hierarchies, property domains and ranges, resource labels, and metadata annotations. Works with Iri.t values to represent RDF schema concepts and relationships. Used to annotate and structure RDF data with semantic metadata, such as defining class hierarchies or linking resources to human-readable labels.",
      "description_length": 366,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Solid.Open",
      "description": "Provides functions to reference and manage Solid account resources, including inbox, notification, timeline, and type index structures. Works with Iri.t values to represent specific resources and their relationships. Used to track notifications, organize time-ordered data, and register RDF types within a Solid-based application.",
      "description_length": 330,
      "index": 13,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rdf.Term.Ordered_term",
      "description": "Compares two terms based on a predefined ordering, returning -1, 0, or 1. It operates on the `term` type, which represents symbolic expressions or parsed language constructs. This function is used to sort lists of terms or implement ordered data structures like trees.",
      "description_length": 268,
      "index": 14,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Term.TSet",
      "description": "Provides functions for constructing, manipulating, and querying ordered sets, operating on elements of type `elt` and `term` through comparison-based ordering and sequence operations. Includes searching, transformation, and iteration capabilities, enabling tasks such as dynamic set management, ordered data processing, and efficient conversions between sets and sequences.",
      "description_length": 373,
      "index": 15,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Term.TMap",
      "description": "This module offers operations to construct, modify, and query ordered maps, including adding, removing, and updating key-value bindings, as well as retrieving cardinality, min/max keys, and subsets. It works with ordered key-value structures and sequences, enabling efficient traversal, transformation, and filtering of data in sorted order. Use cases include dynamic data management, hierarchical indexing, and processing structured datasets where ordered access is critical.",
      "description_length": 476,
      "index": 16,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rdf.Acl.Open",
      "description": "Provides constants for defining access control policies using IRI identifiers. It includes specific access modes like read, write, and append, along with mechanisms for specifying agents, groups, and resource classes. Used to configure permissions for resources, manage delegation, and enforce access rules in systems requiring fine-grained control.",
      "description_length": 349,
      "index": 17,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Bgp.Make",
      "description": "Provides operations to transform, compare, and retrieve terms from a structured data model. Works with term representations and a graph type to manage relationships between entities. Enables querying specific triples based on subject, predicate, or object constraints.",
      "description_length": 268,
      "index": 18,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Xml.SMap",
      "description": "The module provides operations for creating, modifying, and querying ordered maps, focusing on key-based manipulations like adding, updating, removing, and merging bindings. It works with ordered maps that use string keys and generic values, enabling ordered traversal, filtering, and transformation of key-value pairs. Specific use cases include building maps from sequences, processing data in sorted key order, or efficiently managing dynamic string-based mappings.",
      "description_length": 468,
      "index": 19,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Time.Open",
      "description": "The module provides operations for modeling temporal relationships, interval comparisons, and duration calculations, focusing on structured representations of time intervals, calendar elements, and temporal units like minutes, months, and time zones. It works with interval data defined by start/end points, IRI constants for semantic labeling, and string-based temporal descriptions, enabling precise ordering and semantic annotation of time-related data. Use cases include scheduling systems, temporal data analysis, and semantic reasoning over time-based ontologies.",
      "description_length": 569,
      "index": 20,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Sparql_ms.MuOrdered",
      "description": "Compares two values of type `mu` using a custom ordering defined by the `compare` function. It operates on the `mu` type, which represents a specific domain-specific data structure. This module is used to enforce consistent sorting and equality checks in contexts requiring precise control over value comparison.",
      "description_length": 312,
      "index": 21,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Sparql_ms.MuSet",
      "description": "The module provides set operations such as union, intersection, membership checks, and element retrieval, along with traversal and modification functions, working with sets parameterized by MuOrdered.t and elements of type 'elt'. It enables use cases like efficient dynamic data management, ordered set manipulations, and constructing sets from lists for applications requiring structured collection handling.",
      "description_length": 409,
      "index": 22,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Sparql_ms.MuNOrdered",
      "description": "Compares pairs of integers and associated values, returning an integer based on the first element of each pair. Operates on tuples where the first element is an integer and the second is of a generic type. Used to sort or order records by their integer identifier while preserving associated data.",
      "description_length": 297,
      "index": 23,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Sparql_ms.Multimu",
      "description": "This module offers comprehensive set operations for managing collections, including membership checks, modifications, and combinatory functions like union, intersection, and difference, alongside traversal and cardinality metrics. It handles structured data through a type built on `MuNOrdered.t`, enabling ordered set manipulations such as retrieving extremal elements, splitting sets, and constructing sets from lists. Use cases include dynamic data management where ordered element access and efficient set transformations are critical.",
      "description_length": 539,
      "index": 24,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Activitystreams.Open",
      "description": "This module defines IRI constants for ActivityStreams vocabulary, focusing on social activity concepts, object types, and metadata attributes such as timestamps, locations, and relationships. It operates on structured data elements and semantic identifiers to model decentralized social interactions, content types, and protocol-specific properties. Use cases include representing actions like \"Like\" or \"Follow,\" structuring data for ActivityPub, and annotating objects with standardized metadata for social media or messaging systems.",
      "description_length": 536,
      "index": 25,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Pim.Open",
      "description": "Provides constants for defining and referencing different types of storage and workspace URIs, including private, public, shared, and controlled access configurations. Works with Iri.t data type to represent resource locations and access policies. Used to structure data organization in applications requiring fine-grained access control and resource categorization.",
      "description_length": 366,
      "index": 26,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Oa.Open",
      "description": "This module provides functions for defining and managing IRI-based properties and relationships within the Web Annotation model, focusing on precise targeting, structuring, and metadata handling. It operates on annotation data, including selectors, targets, bodies, and metadata, with applications in text positioning, temporal tracking, and styling of web content. Specific use cases involve linking annotated resources, specifying HTTP states, and managing resource references for accurate content annotation.",
      "description_length": 511,
      "index": 27,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Mem.Mem",
      "description": "Manipulates and queries graph data through term transformation, comparison, and triplet retrieval, supporting semantic queries by efficiently locating entries based on subjects, predicates, or objects. Key data types include graph structures, terms, and triplets, with operations for transformation, comparison, and lookup. Users can extract subjects or objects matching a given predicate or find triplets where a specific term appears. Examples include querying all objects linked to a subject or identifying triplets containing a particular predicate.",
      "description_length": 553,
      "index": 28,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Foaf.Open",
      "description": "This module provides functions for defining RDF-based identifiers and properties to model structured relationships and metadata, focusing on person-centric data such as names, contacts, affiliations, and online identities. It operates with entities like individuals, projects, organizations, and documents, using IRIs to encode semantic connections and attributes in contexts like social networks or knowledge graphs. Specific use cases include describing collaborative workflows, personal profiles, and interconnected digital assets with typed, machine-readable metadata.",
      "description_length": 572,
      "index": 29,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rdf.Doap.Open",
      "description": "This module generates IRIs for structured project metadata, including version control systems, developer roles, licenses, and software specifications, operating on types like Iri.t and project attributes. It enables semantic representation of project information, supporting use cases such as version tracking, dependency management, and standardized metadata exchange in collaborative development environments. The functions follow an RDF-like pattern to encode relationships between repositories, revisions, and project components.",
      "description_length": 533,
      "index": 30,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Vcard.Open",
      "description": "This module provides functions for defining and categorizing IRI constants that represent vCard properties, classes, and metadata, such as contact roles, communication types, and organizational relationships. It operates on structured vCard data models and semantic structures, enabling precise mapping of personal information, legacy properties, and metadata fields like addresses, phone numbers, and URLs. Use cases include standardizing contact data representation, managing deprecated vCard attributes, and facilitating semantic interoperability in entity modeling.",
      "description_length": 569,
      "index": 31,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rdf.Graph.Bid_map",
      "description": "This module provides operations for dynamically managing key-value mappings, including conditional updates, list-based insertions, and ordered traversal, with support for merging and metadata retrieval. It works with maps featuring arbitrary key-value types, ordered keys, and specialized structures for `Term.blank_id`-typed keys, enabling sequential processing and predicate-driven transformations. Use cases include bid management systems, data aggregation, and structured data manipulation where efficient key-based access and iterative processing are required.",
      "description_length": 565,
      "index": 32,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rdf.Graph.Make",
      "description": "Manipulates and queries graph data through abstract term and graph types, supporting term transformation, comparison, and retrieval of subjects and objects. Enables precise triple relationship queries by subject, predicate, or object. Operations include navigating structured data and transforming terms within graph contexts. Examples include extracting all objects for a given subject or comparing term equivalence within a graph.",
      "description_length": 432,
      "index": 33,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Earl.Open",
      "description": "This module provides functions for defining and managing IRI-based identifiers to represent test-related entities like outcomes, subjects, assertors, and criteria, along with their metadata relationships. It operates on structured test metadata, enabling precise labeling of components such as test results, locations, and execution modes. Use cases include annotating test results, linking assertions to their contexts, and standardizing test execution metadata for interoperability.",
      "description_length": 484,
      "index": 34,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Sparql_types.OrderedString",
      "description": "Compares two strings lexicographically using standard ASCII order. Accepts string values and returns -1, 0, or 1 based on their relative order. Used to sort lists of user input or configuration keys in a predictable manner.",
      "description_length": 223,
      "index": 35,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Sparql_types.VarSet",
      "description": "This module provides set operations such as membership checks, unions, intersections, and element traversal, along with functions to retrieve minimum, maximum, and arbitrary elements, and split sets around specific values. It works with sets of variables (type `var`) and generic elements (`elt`), enabling efficient manipulation and partitioning of collections. Use cases include compiler optimizations, symbolic execution, and constraint solving, where managing dynamic variable relationships and set-based computations is critical.",
      "description_length": 534,
      "index": 36,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Prov.Open",
      "description": "This module provides functions for defining and managing IRIs that encode semantic relationships and classifications within provenance models, focusing on structured interactions between entities, activities, and agents. It operates on Iri.t values and PROV ontology elements, enabling tasks like tracking entity lifecycles, modeling derivation chains, and annotating relationships with qualifiers such as time-based or responsibility metadata. Use cases include constructing knowledge graphs with provenance metadata, enforcing semantic links in distributed systems, and representing complex workflows with precise, machine-readable assertions.",
      "description_length": 645,
      "index": 37,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Types.Ordered_string",
      "description": "Compares two strings lexicographically using standard ASCII order. Processes values of type string to determine ordering. Used to sort lists of strings or implement ordered data structures like sets and maps.",
      "description_length": 208,
      "index": 38,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Types.SMap",
      "description": "The module provides operations for creating, modifying, and querying key-value maps, including adding, removing, and updating bindings, with support for ordered key operations and sequence-based construction. It works with maps featuring string keys and generic values, enabling tasks like ordered traversal, filtering, and merging. Use cases include building dynamic data structures from sequences, efficiently managing key-based transformations, and handling ordered data manipulation.",
      "description_length": 487,
      "index": 39,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rdf.Types.SSet",
      "description": "The module provides set operations like union, intersection, and element queries, along with sorted set functionalities for iteration, transformation, and predicate-based filtering, and string-specific methods for ordered addition and reverse iteration. It handles generic sets, sorted structures, and string sequences, supporting use cases such as efficient set management, ordered data traversal, and string sequence manipulation.",
      "description_length": 432,
      "index": 40,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Types.Ordered_char",
      "description": "Compares two characters using their ASCII values, returning -1, 0, or 1 based on their order. Operates on the built-in char type, enabling sorted insertion in data structures. Used to define custom ordering for character-based keys in priority queues.",
      "description_length": 251,
      "index": 41,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Types.CMap",
      "description": "This module provides key-based operations for managing ordered maps, including insertion, deletion, updates, and merging of key-value pairs, with a focus on char keys and generic values. It supports ordered traversal, filtering, and transformation of map entries, enabling use cases like merging heterogeneous data sources or processing structured sequences. Specific functions allow sequence-to-map conversions and ordered binding manipulations, ideal for scenarios requiring deterministic key ordering or incremental data aggregation.",
      "description_length": 536,
      "index": 42,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rdf.Types.CSet",
      "description": "This module provides operations for constructing, modifying, and querying sets, including union, intersection, difference, and cardinality checks, while supporting both imperative and functional paradigms. It works with ordered elements and character sequences, enabling tasks like predicate-based filtering, ordered iteration, and sequence-to-set transformations. Specific use cases include managing ordered collections, processing character-based data, and efficient set manipulations in applications requiring structured data operations.",
      "description_length": 540,
      "index": 43,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Test_manifest.Open",
      "description": "The module handles operations for defining test categories, managing metadata, and specifying test requirements using Iri.t values, focusing on SPARQL syntax and evaluation testing. It works with structured data types representing test cases, relationships, and constraints within a test manifest. Specific use cases include configuring positive/negative syntax tests, validating query/update results, and establishing links between manifest entries and resources.",
      "description_length": 464,
      "index": 44,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Dc.Open",
      "description": "This module provides functions for defining and managing IRI-based identifiers to structure metadata attributes, such as resource properties, semantic relationships, and standardized fields like dates, rights, and formats. It operates on data structures including Iri.t values and metadata elements, aligning with standards like Dublin Core to categorize resources semantically. Use cases include enhancing resource description, enabling semantic web applications, and ensuring consistent encoding of metadata for interoperability.",
      "description_length": 531,
      "index": 45,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Sparql_eval.GExprOrdered",
      "description": "Compares two lists of optional terms based on their ordered structure, returning -1, 0, or 1. It operates on lists where each element is an optional term, allowing for ordered evaluation of expressions. This is used to determine the precedence or sequence of terms in a structured expression tree.",
      "description_length": 297,
      "index": 46,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Sparql_eval.GExprMap",
      "description": "This module offers key-value map operations such as insertion, deletion, lookup, and traversal, along with advanced manipulations like splitting, searching, and transformation tailored for maps with keys of type `GExprOrdered.t`. It enables efficient handling of structured data where ordered key access and partitioning are critical, such as in symbolic expression management or configuration systems. The functions support both generic map operations and specialized transformations based on ordered key semantics.",
      "description_length": 516,
      "index": 47,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Rdf_.Open",
      "description": "This module provides functions for defining and manipulating RDF/OWL 2 vocabulary through IRI constants, enabling structured representation of semantic web data. It handles operations on RDF triples, datatypes, and literals, with specific serialization capabilities like converting IRIs to JSON. Use cases include ontology development, data modeling, and interoperability between semantic web formats.",
      "description_length": 401,
      "index": 48,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Ldp.Open",
      "description": "This module provides functions for defining and manipulating IRIs related to Linked Data Platform (LDP) resources, focusing on pagination, container structures, and metadata management. It works with RDF data, LDP resource hierarchies, and IRI-based predicates to handle operations like sorting page sequences, specifying membership relations, and managing resource containment. Use cases include implementing LDP-compliant data pagination, organizing hierarchical resources, and annotating triples with standardized metadata.",
      "description_length": 526,
      "index": 49,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Graph.BGP",
      "description": "Provides operations to manipulate and query graph data, including term transformation, comparison, and retrieval of subjects and objects. Works with term lists and graph structures to support semantic data navigation. Enables precise querying of triple patterns within a graph.",
      "description_length": 277,
      "index": 50,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Rdf.Bgp",
      "description": "Evaluates a list of SPARQL algebra triples against a multiset of RDF data, producing a filtered multiset result. It processes triple patterns and applies them to a structured dataset to retrieve matching entries. This is used to execute BGP (Basic Graph Pattern) queries in a SPARQL engine.",
      "description_length": 290,
      "index": 51,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Config",
      "description": "Returns the version string of the library. Operates on no input and produces a string representation of the current version. Used to dynamically retrieve the library's version at runtime for logging or compatibility checks.",
      "description_length": 223,
      "index": 52,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rdf.Dot",
      "description": "Provides functions to generate Graphviz DOT code from a graph or specific IRI, using namespace abbreviations and custom href attributes for nodes. Works with graph structures, IRIs, and term-based nodes, enabling visual representation of semantic data. Supports generating code for entire graphs or focused on individual IRIs with clickable elements.",
      "description_length": 350,
      "index": 53,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rdf.Ds",
      "description": "manages datasets with a default graph and named graphs, offering ordered map and set operations for structured data manipulation. It supports key-value associations with sorted access and set-based operations for name management, enabling efficient graph retrieval, modification, and transformation. Users can build and query datasets by name, perform set unions and intersections, and traverse data in ordered sequences. Examples include managing configuration symbols, organizing graph data, and processing structured datasets with predictable access patterns.",
      "description_length": 562,
      "index": 54,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rdf.Dt",
      "description": "Provides a framework for handling heterogeneous values, ordered maps, and sets, enabling complex data manipulation and comparison. It supports operations on `value` types, key-value maps with strict and optional behaviors, and ordered sets with set-theoretic and transformation functions. Users can compare mixed-type values, manage dynamic data structures with efficient lookups, and process structured data through ordered iterations. Examples include sorting heterogeneous lists, building ordered outputs from maps, and maintaining unique element collections with predicate-based filtering.",
      "description_length": 593,
      "index": 55,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rdf.Graph",
      "description": "manipulates and queries graph data through term transformations, pattern matching, and structural queries. It handles term lists and graph structures to navigate semantic relationships. Operations include retrieving subjects and objects, comparing terms, and extracting triple patterns. Users can construct complex queries and analyze graph content with precise filtering and traversal.",
      "description_length": 386,
      "index": 56,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Json",
      "description": "Converts JSON values into RDF terms and SPARQL query results. Operates on Yojson.Basic.t structures to parse and interpret JSON data. Used to process RDF triples and SPARQL query outputs from JSON-formatted sources.",
      "description_length": 215,
      "index": 57,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Lang",
      "description": "Checks if a string conforms to a valid language tag format. Operates on strings and validates them against language tag syntax rules. Used to filter or process user input related to language preferences in internationalized applications.",
      "description_length": 237,
      "index": 58,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Loc",
      "description": "Represents source code locations with file, start, and end positions. Constructs locations from strings or files with character ranges, and converts them to readable strings or pretty-printed formats. Used to track and display exact positions in source files during parsing or error reporting.",
      "description_length": 293,
      "index": 59,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Log",
      "description": "Provides logging facilities with severity levels, including error, warning, information, and debug messages. Operates with formatted message functions and a source identifier for log entries. Used to record application events, diagnostics, and troubleshooting information during runtime.",
      "description_length": 287,
      "index": 60,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Mem",
      "description": "Organizes and navigates graph data using tree-based sets, enabling efficient term-based queries and transformations. It handles graph structures, terms, and triplets, supporting operations like predicate-driven lookups and semantic comparisons. Users can retrieve all objects for a subject or find triplets containing a specific term. This allows precise manipulation of structured data through semantic filtering and hierarchical access.",
      "description_length": 438,
      "index": 61,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rdf.Misc",
      "description": "Provides functions to convert between strings and options, apply mappings to optional values, compare options and lists, read file contents as strings, and split strings based on delimiter characters. Works with options, lists, and strings. Used to handle optional data gracefully, process text with custom delimiters, and manage file input as a single string.",
      "description_length": 360,
      "index": 62,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Nq",
      "description": "Provides functions to parse N-quads from strings or files into a dataset, and to serialize datasets or graphs into N-quad strings or files. Operates on dataset and graph data structures representing RDF data. Used to load N-quad content into a dataset from a text source or save a graph's contents to a file in N-quad format.",
      "description_length": 325,
      "index": 63,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Rdf_",
      "description": "defines and manipulates RDF/OWL 2 vocabulary using IRI constants, supporting operations on triples, datatypes, and literals with serialization to formats like JSON. It enables structured semantic web data representation, allowing ontology development and data modeling. Users can create and convert IRIs, manage literals with specific datatypes, and ensure interoperability between semantic formats. Examples include defining custom ontologies, serializing triples for web exchange, and validating data against defined schemas.",
      "description_length": 527,
      "index": 64,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Rdfs",
      "description": "Exports IRI constants for RDFS vocabulary, enabling the representation of class hierarchies, property constraints, and resource metadata through Iri.t values. Supports semantic annotation of RDF data by defining relationships such as subClassOf, domain, range, and label. Allows structured modeling of ontologies by linking resources to human-readable labels and metadata. Examples include defining class inheritance, specifying property ranges, and attaching labels to resources.",
      "description_length": 480,
      "index": 65,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Sedlex",
      "description": "Handles position updates during lexical scanning and integrates Ulex with Menhir for parsing. Operates on Lexing.position and Sedlexing.lexbuf to track and modify scan states. Used to synchronize parser state with lexer progress in custom lexical analysis workflows.",
      "description_length": 266,
      "index": 66,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rdf.Sparql",
      "description": "The module provides parsing, serialization, and execution of SPARQL queries, supporting SELECT, CONSTRUCT, ASK, and DESCRIBE operations, along with term extraction and manipulation for data types like IRIs, integers, and booleans. It works with datasets, graphs, and IRIs, enabling query execution and custom IRI function registration. Use cases include querying semantic web data, extracting structured information, and managing complex graph-based datasets through precise data handling and query optimization.",
      "description_length": 512,
      "index": 67,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Sparql_eval",
      "description": "Provides ordered comparison of optional term lists and key-value map operations with ordered keys. It supports list comparison for structured expression evaluation and advanced map manipulations for efficient data handling. Functions include insertion, deletion, lookup, and transformations tailored for ordered keys. It enables precise control over term sequencing and structured data management in symbolic computations.",
      "description_length": 422,
      "index": 68,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Sparql_http",
      "description": "Provides functions to send SPARQL queries using HTTP GET and POST methods, accepting parameters like graph, base IRI, and content type. Operates with Iri.t, Uri.t, Graph.graph, and Sparql_protocol.in_message types. Used to interact with SPARQL endpoints, retrieving results in specified formats like RDF/XML.",
      "description_length": 308,
      "index": 69,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Sparql_lex",
      "description": "Handles Unicode escape sequences in SPARQL queries by converting them to their corresponding characters. Processes input streams to tokenize SPARQL syntax, extracting position information and recognized tokens. Designed for parsing SPARQL queries with extended character support.",
      "description_length": 279,
      "index": 70,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Sparql_ms",
      "description": "provides comparison and set operations for domain-specific data, including custom ordering of `mu` values, set manipulations with `MuOrdered.t` and `MuNOrdered.t`, and tuple-based sorting by integer keys. It supports tasks like sorting records by identifiers, managing dynamic collections with efficient unions and intersections, and retrieving extremal elements from ordered sets. Operations include comparing values, checking membership, and constructing sets from lists. Examples include sorting pairs by integer keys, enforcing consistent data ordering, and performing set-based data transformations.",
      "description_length": 604,
      "index": 71,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Sparql_parser",
      "description": "Parses SPARQL queries from a lexing buffer using a provided tokenizer, producing an abstract syntax tree of type `Sparql_types.query`. It processes input through a lexer and recognizes tokens defined by the `token` type. This is used to convert raw SPARQL text into a structured query representation for further processing.",
      "description_length": 323,
      "index": 72,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rdf.Sparql_print",
      "description": "The module offers functions for safely handling optional values and serializing SPARQL components into buffers, including operations on SPARQL AST nodes, IRIs, variables, literals, graph patterns, and query structures. It enables generating textual representations of query elements like clauses, modifiers, bindings, and sub-queries, as well as constructing complex SPARQL outputs incrementally. Specific use cases involve safely transforming optional data, formatting query syntax, and building structured SPARQL representations for execution or debugging.",
      "description_length": 558,
      "index": 73,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Sparql_protocol",
      "description": "Provides functions to create and manipulate SPARQL query datasets, and to convert SPARQL error values to strings. It works with structured data types representing incoming and outgoing SPARQL messages and query datasets. Used to process SPARQL queries, handle protocol errors, and manage data exchanges in RDF-based systems.",
      "description_length": 324,
      "index": 74,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Sparql_types",
      "description": "Provides lexicographic string comparison and set operations for variables and generic elements. Includes functions to compare strings, check set membership, perform unions and intersections, and retrieve extremal or arbitrary elements. Enables sorting of user input, managing variable relationships, and partitioning collections during analysis. Supports efficient manipulation of dynamic data structures in applications like compilers and constraint solvers.",
      "description_length": 459,
      "index": 75,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Stubs",
      "description": "Provides functions for string hashing using SHA-1 and SHA-256, pattern matching with PCRE, and string replacement using PCRE syntax. Works with strings, regular expression patterns, and compilation flags. Used to generate cryptographic hashes, validate input against regex patterns, and perform search-and-replace operations in text.",
      "description_length": 333,
      "index": 76,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Term",
      "description": "Sorts and manages symbolic expressions through comparison, set, and map operations. It handles `term` and `elt` types, supporting ordered data structures with insertion, deletion, and traversal. Users can perform set unions, map lookups, and ordered sequence transformations. Examples include sorting term lists, maintaining dynamic sets, and efficiently querying structured data.",
      "description_length": 380,
      "index": 77,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rdf.Ttl",
      "description": "Provides functions to parse Turtle input into a graph from a string or file, and to serialize graph data into Turtle format. Works with graph structures, terms, and IRIs, supporting compact and namespaced output. Converts individual triples and terms to strings, and writes serialized Turtle to files or returns it as a string.",
      "description_length": 327,
      "index": 78,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Ttl_lex",
      "description": "Provides functions to tokenize Unicode input, including a set of reserved characters for lexical analysis. Operates on Lexing.position and Sedlexing.lexbuf to produce parsed tokens. Used to process and analyze structured text inputs with custom lexical rules.",
      "description_length": 259,
      "index": 79,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rdf.Ttl_parser",
      "description": "Parses Turtle syntax into structured triples and named graphs using a lexer-generated token stream. Processes input to extract subject, predicate, object, and graph name information. Accepts a custom lexer function to handle different input sources.",
      "description_length": 249,
      "index": 80,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rdf.Ttl_types",
      "description": "provides a set of type definitions for handling time-to-live values in network protocols includes basic types such as integers and optionals for representing expiration states allows for straightforward manipulation of TTL values in packet processing workflows supports operations like incrementing, decrementing, and checking expiration conditions",
      "description_length": 348,
      "index": 81,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Types",
      "description": "Provides string and character comparison, set and map operations with ordered and generic data, and utilities for building and manipulating structured collections. Supports string lexicographic ordering, char-based comparisons, set unions and intersections, and ordered key-value maps with string or char keys. Enables sorting, filtering, merging, and transformation of sequences, sets, and maps, including dynamic data structure construction and efficient key-based lookups. Examples include sorting string lists, managing character-based priority queues, and merging ordered maps with custom key orderings.",
      "description_length": 608,
      "index": 82,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Update",
      "description": "The module provides a set of utilities for managing and applying changes to data structures. It includes types for representing updates, such as additions, deletions, and modifications, along with operations to combine, apply, and revert these changes. Functions like `apply`, `merge`, and `revert` allow for precise control over how updates affect underlying data. For example, it can track changes to a configuration file and roll back specific modifications when needed.",
      "description_length": 473,
      "index": 83,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Utf8",
      "description": "Provides functions to calculate the byte length of UTF-8 characters, convert between byte indices and character positions, and extract substrings based on character offsets. Operates on UTF-8 encoded strings and handles Unicode code points, line breaks, and escaping. Used for processing text with multi-byte characters, such as parsing log files, formatting JSON, or manipulating internationalized strings.",
      "description_length": 407,
      "index": 84,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Utils",
      "description": "Extracts a title from a graph based on a given IRI, returning an optional string. Works with graph data structures and IRI identifiers. Used to retrieve human-readable labels from semantic data sources.",
      "description_length": 202,
      "index": 85,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Webacl",
      "description": "Handles operations to manipulate and query access control rights for web resources, including adding or removing read, write, append, and control permissions. Works with the `rights` type, which represents a set of access permissions, and IRIs to associate rights with specific resources. Used to generate human-readable representations of rights, check permission presence, and map rights to and from IRI-based access modes.",
      "description_length": 425,
      "index": 86,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Xml",
      "description": "manages string-keyed, value-generic ordered maps with insert, update, remove, and merge operations, supporting sorted traversal and transformation. it enables building maps from sequences, processing data in key order, and maintaining dynamic mappings. operations include filtering, merging, and applying functions to key-value pairs. examples include constructing configuration maps, aggregating data by sorted keys, or updating records in a structured way.",
      "description_length": 458,
      "index": 87,
      "embedding_norm": 1.0
    },
    {
      "module_path": "rdf",
      "description": "Processes RDF triples using subject-predicate-object structure, supports parsing and serialization of RDF data in Turtle and N-Triples formats. Enables querying and manipulation of graph data through filter and join operations on named graphs. Used to integrate semantic data into knowledge representation systems and data linking pipelines.",
      "description_length": 341,
      "index": 88,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rdf",
      "description": "The module provides a comprehensive set of tools for working with RDF data, SPARQL queries, and semantic graph structures. It includes operations for evaluating SPARQL triple patterns against datasets, generating Graphviz visualizations, parsing and serializing RDF formats like Turtle and N-quad, and handling SPARQL query execution and serialization. Key data types include graphs, datasets, IRIs, terms, and SPARQL query structures, with functions for filtering, transforming, and querying semantic data. Examples include executing BGP queries, converting JSON to RDF, generating DOT code for graphs, and managing access control rights for web resources.",
      "description_length": 657,
      "index": 89,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 127,
    "meaningful_modules": 90,
    "filtered_empty_modules": 37,
    "retention_rate": 0.7086614173228346
  },
  "statistics": {
    "max_description_length": 657,
    "min_description_length": 202,
    "avg_description_length": 419.0888888888889,
    "embedding_file_size_mb": 0.32727527618408203
  }
}