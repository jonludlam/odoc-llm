{
  "package": "rdf",
  "embedding_model": "Qwen/Qwen3-Embedding-0.6B",
  "embedding_dimension": 1024,
  "total_modules": 115,
  "creation_timestamp": "2025-07-15T23:25:12.290249",
  "modules": [
    {
      "module_path": "Rdf.Mem.Mem.BGP",
      "library": "rdf",
      "description": "This module implements in-memory storage for RDF graphs using tree-based sets, supporting operations to add, query, and compare RDF terms. It works with terms representing subjects, predicates, and objects in an RDF graph, and provides direct access to lists of subjects and objects present in the graph. Concrete use cases include building and querying RDF datasets in memory, such as for semantic web applications or data integration tools.",
      "description_length": 442,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Graph.Make.BGP",
      "library": "rdf",
      "description": "Implements a basic graph pattern (BGP) engine for RDF graphs, supporting term comparison, subject-object enumeration, and triple pattern matching. Operates on graph (`g`) and term types, enabling efficient in-place queries and term conversions. Used to execute SPARQL-like pattern searches within an RDF graph instance.",
      "description_length": 319,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Foaf.Open",
      "library": "rdf",
      "description": "This module provides constants and functions for working with FOAF vocabulary terms as IRI identifiers, enabling the representation of agents, their attributes, and relationships in RDF data models. It defines properties like `foaf_knows`, `foaf_email`, and `foaf_openid` (alongside classes such as `foaf_c_Person`) to describe personal details, social connections, professional activities, and online presence. These tools are particularly useful for modeling social network data, linking individuals to resources like weblogs or chat identifiers, and structuring metadata about agents in semantic web applications.",
      "description_length": 616,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Test_manifest.Open",
      "library": "rdf",
      "description": "This module defines IRIs for categorizing RDF test types (e.g., syntax validation, query evaluation), specifying test actions, and encoding metadata like expected outcomes and status. It operates on RDF terms and manifest entries to enforce constraints such as cardinality requirements or test status validation. These constructs are used to structure and validate test suites for SPARQL and RDF processing systems, ensuring conformance with W3C specifications.",
      "description_length": 461,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Graph.Graph",
      "library": "rdf",
      "description": "This module provides in-place manipulation of RDF graphs through triple addition/removal, SPARQL-like query execution, and transaction control. It operates on RDF terms, IRIs, and triples while managing namespace mappings and blank node generation. Designed for use cases like persistent RDF storage, atomic graph updates, and SPARQL query processing with customizable prefix handling.",
      "description_length": 385,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Vcard.Open",
      "library": "rdf",
      "description": "This module exposes a comprehensive set of `Iri.t` constants representing vCard ontology elements for contact data modeling, including categories (e.g., relationship types, communication methods), properties (e.g., name components, addresses, dates), and entity classifications (individuals, organizations). These IRIs directly map to RDF/OWL representations of vCard fields like email, phone, gender, and organizational roles, enabling structured annotation of contact information in RDF graphs. It supports use cases such as integrating vCard-based contact data into semantic web applications, categorizing relationships (colleague, friend), and handling property parameters (e.g., work/home labels) while aligning with RFC6350 and W3C vCard NS standards.",
      "description_length": 757,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Bgp.P",
      "library": "rdf",
      "description": "Implements operations for querying and manipulating RDF terms within a basic graph pattern context. It provides functions to retrieve subjects and objects, compare terms, and perform pattern-based lookups using optional subject, predicate, or object filters. This module is used to evaluate SPARQL-like queries over RDF data by matching triples against specified constraints.",
      "description_length": 375,
      "index": 6,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rdf.Sparql_http.S",
      "library": "rdf",
      "description": "This module defines the interface for sending SPARQL queries over HTTP using GET and POST methods. It handles encoding SPARQL messages into HTTP requests and decoding responses, working with IRIs, graphs, and SPARQL protocol messages. It is used to implement SPARQL query execution against remote endpoints, particularly for querying RDF datasets like DBPedia.",
      "description_length": 360,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Types.Ordered_char",
      "library": "rdf",
      "description": "This module defines a character type with a total ordering, enabling comparison operations between characters. It supports data structures that require ordered elements, such as sets and maps. Concrete use cases include building ordered collections of ASCII characters and efficiently comparing character-based identifiers.",
      "description_length": 323,
      "index": 8,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rdf.Sparql_ms.MuNOrdered",
      "library": "rdf",
      "description": "This module defines a type `t` as a pair of an integer and a value of type `Rdf.Sparql_ms.mu`, and provides a `compare` function that orders such pairs based on their integer component. It is used to manage and compare ranked or indexed values in SPARQL query processing. A concrete use case is sorting or merging results based on their position in a query execution plan.",
      "description_length": 372,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Acl.Open",
      "library": "rdf",
      "description": "This module defines constants and access modes for representing and working with access control policies in RDF, particularly aligned with the W3C's ACL vocabulary. It includes specific access types like Read, Write, Append, and Control, along with entities such as Agent, Authorization, and AccessTo to model permissions. It is used to construct and interpret access control rules for resources in semantic web applications, especially when managing fine-grained permissions for RDF graphs or linked data.",
      "description_length": 506,
      "index": 10,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rdf.Types.SSet",
      "library": "rdf",
      "description": "This module implements immutable sets of strings with efficient pure functional operations including union, intersection, difference, and ordered traversal via iteration, mapping, and filtering. It supports conversions to and from lists and sequences, along with safe element access through both exception-raising and option-returning variants, making it suitable for tasks like data transformation pipelines, ordered set analysis, and scenarios requiring robust handling of optional values.",
      "description_length": 491,
      "index": 11,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Types.Ordered_string",
      "library": "rdf",
      "description": "Implements a named string type with a total ordering for use in RDF term comparisons. Provides a `compare` function to determine the order of two strings based on their lexicographical values. Useful for maintaining consistent sorting and equality checks in RDF datasets.",
      "description_length": 271,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Owl.Open",
      "library": "rdf",
      "description": "This module exposes constants and utility functions for defining and manipulating semantic relationships in OWL 2 ontologies, focusing on class hierarchies, property constraints, and logical axioms. It operates primarily on `Iri.t` values to represent ontology elements like classes, properties, and annotations, enabling precise modeling of semantic web constructs. Typical applications include constructing knowledge graphs with formal semantics, enforcing domain constraints (e.g., cardinality, disjointness), and expressing metadata for RDF-based data integration or reasoning systems.",
      "description_length": 589,
      "index": 13,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Doap.Open",
      "library": "rdf",
      "description": "This module provides a collection of predefined IRIs for DOAP vocabulary terms that describe software project metadata, repositories, and relationships. It operates on RDF triples using `Iri.t` values to represent entities like projects, developers, licenses, and version control systems. These IRIs are used to build or query RDF graphs that model software project information, such as linking a project to its Git repository, contributors, or distribution endpoints.",
      "description_length": 468,
      "index": 14,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Dc.Open",
      "library": "rdf",
      "description": "This module provides standardized Dublin Core metadata terms as `Iri.t` values, enabling the description of resource properties like creators, dates, formats, and relationships in RDF triples. It operates on RDF data structures to support semantic web applications requiring interoperable metadata, such as cataloging digital resources, encoding provenance, or expressing licensing terms using DCMI vocabularies. Specific use cases include annotating datasets with temporal/spatial coverage or linking resources via hierarchical relationships like `dc_isPartOf`.",
      "description_length": 562,
      "index": 15,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rdf.Dt.ValueOrdered",
      "library": "rdf",
      "description": "Implements comparison logic for RDF term values in SPARQL computations, handling ordered value types like numbers, dates, and strings. Uses the `compare` function to determine ordering, which is essential for operations like sorting or grouping query results. Useful when evaluating SPARQL expressions that require value comparisons, such as `ORDER BY` or `GROUP BY`.",
      "description_length": 367,
      "index": 16,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Bgp.S",
      "library": "rdf",
      "description": "Implements operations for evaluating basic graph patterns against RDF datasets, producing multiset results. It processes SPARQL algebra triples and returns structured query results. Useful for executing SPARQL queries over RDF data models.",
      "description_length": 239,
      "index": 17,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Solid.Open",
      "library": "rdf",
      "description": "This module defines RDF classes and properties for Solid protocol resources, including accounts, inboxes, notifications, timelines, and type indexes. It provides IRIs for working with notification state, timeline containers, and type registries in Solid-compliant storage systems. Concrete use cases include modeling user inboxes with read/unread status, organizing time-ordered data in file-based systems, and registering RDF types for application-specific resources.",
      "description_length": 468,
      "index": 18,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Term.TSet",
      "library": "rdf",
      "description": "This module implements ordered collections of RDF terms with efficient membership checks, set algebra operations, and ordered traversal capabilities. It works with sets of `Rdf.Term.term` values maintained in sorted order using a custom comparator, supporting transformations like mapping, filtering, and partitioning while preserving element uniqueness and order. Typical applications include managing RDF term vocabularies with deterministic ordering, performing set-based reasoning over RDF graphs, and generating ordered sequences for serialization formats like RDF/XML or Turtle.",
      "description_length": 584,
      "index": 19,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Sparql_http.Make",
      "library": "rdf",
      "description": "This module implements a functor for creating HTTP bindings to send SPARQL queries via GET or POST requests, handling protocol encoding and decoding. It works with SPARQL input and output messages, IRIs, and HTTP response types from the provided parameter module. Concrete use cases include querying SPARQL endpoints like DBpedia or Wikidata by constructing and sending properly formatted HTTP requests with optional graph context and content negotiation.",
      "description_length": 455,
      "index": 20,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Sparql_types.OrderedString",
      "library": "rdf",
      "description": "This module defines a string type with a comparison function for maintaining ordered collections. It supports operations requiring lexicographical ordering of strings, such as sorting or use in ordered data structures. It is useful in scenarios like query result sorting or managing ordered sets of identifiers.",
      "description_length": 311,
      "index": 21,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Types.CMap",
      "library": "rdf",
      "description": "This module implements a char-keyed ordered map with efficient physical equality checks, supporting insertion, deletion, merging, and ordered key queries like min/max bindings. It operates on sorted key-value structures, enabling ordered traversal, transformation via mapping and filtering, and conversion to/from sequences of bindings. Designed for scenarios requiring consistent key ordering and optimized updates, it's suited for RDF data modeling where character-indexed maps must maintain sorted structure and enable operations like incremental construction from key-value streams.",
      "description_length": 586,
      "index": 22,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rdf.Security.Open",
      "library": "rdf",
      "description": "This module provides cryptographic signature schemes (e.g., BBS-BLS, Ed25519, ECDSA), canonicalization algorithms, and key management operations for securing RDF data. It works with RDF graphs, cryptographic primitives (keys, digests, nonces), and IRIs representing security constructs like verification methods or proof metadata. These capabilities enable decentralized identity systems, verifiable credentials, and selective disclosure workflows requiring data integrity, authentication, and capability delegation.",
      "description_length": 516,
      "index": 23,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Dt.VMap",
      "library": "rdf",
      "description": "This module implements ordered maps with `Rdf.Dt.value` keys, supporting precise manipulation of RDF term bindings through operations like merging, filtering, and ordered traversal. It provides transformations over key-value pairs (e.g., `map`, `filter_map`), structural queries (`union`, `split`), and sequence-based construction (`of_list`, `to_seq`), while ensuring safe error handling via optional return types. Designed for SPARQL query evaluation and RDF data processing, it enables efficient aggregation, comparison, and ordered enumeration of RDF term mappings.",
      "description_length": 569,
      "index": 24,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rdf.Types.SMap",
      "library": "rdf",
      "description": "This module handles ordered maps with string keys, providing operations for insertion, deletion, ordered traversal, and bulk transformations like mapping, filtering, and merging. It supports conversions to and from lists and sequences, enabling efficient iteration in",
      "description_length": 267,
      "index": 25,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Pim.Open",
      "library": "rdf",
      "description": "This module provides functions to manage access control and storage configurations for workspaces, including operations to retrieve and set storage types such as public, private, and shared. It works with IRI-based identifiers to define policies and relationships between workspaces, storages, and user preferences. Concrete use cases include configuring user-specific data isolation, defining access permissions for shared resources, and managing URI prefixes for resource addressing.",
      "description_length": 485,
      "index": 26,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rdf.Bgp.Make",
      "library": "rdf",
      "description": "Implements evaluation of Basic Graph Patterns (BGP) by processing SPARQL algebra triples into multiset results. Works directly with SPARQL algebra representations and multiset data structures. Used to execute SPARQL queries over RDF datasets by matching triple patterns against stored data.",
      "description_length": 290,
      "index": 27,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Rdf_.Open",
      "library": "rdf",
      "description": "This module provides standardized IRI constants for core RDF vocabulary and XSD datatypes, enabling precise representation of semantic web constructs. It operates on and returns IRI values to identify RDF classes (e.g., `rdf_c_Property`), statement components (e.g., `rdf_predicate`), literal types (e.g., `rdf_dt_JSON`, `xsd_integer`), and container structures (e.g., `rdf_c_Bag`). These IRIs are essential for building and interpreting RDF graphs in applications like JSON-LD serialization, linked data frameworks, and semantic data validation.",
      "description_length": 546,
      "index": 28,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Activitystreams.Open",
      "library": "rdf",
      "description": "This module provides a collection of standardized IRI constants for ActivityStreams 2.0 vocabulary terms, enabling precise modeling of social interactions, content types, and metadata in RDF-based systems. It defines identifiers for activities (e.g., `Like`, `Announce`), object types (e.g., `Note`, `Person`), and properties (e.g., `actor`, `accuracy`) to facilitate consistent construction and interpretation of semantic data. These IRIs directly support applications like ActivityPub implementations, social data aggregation, and linked data workflows requiring structured representation of digital interactions.",
      "description_length": 615,
      "index": 29,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rdf.Ds.NameSet",
      "library": "rdf",
      "description": "This module offers functional set operations for managing ordered collections of dataset names, including union, intersection, difference, element insertion/removal, and transformations like mapping and filtering. It works with immutable sets of `Rdf.Ds.name` values, leveraging their total ordering for efficient queries (e.g., membership checks, min/max) and ordered iteration. Use cases include tracking named graphs in datasets, comparing graph identifier sets, and converting between sets and ordered lists for deterministic processing.",
      "description_length": 541,
      "index": 30,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rdf.Ldp.Open",
      "library": "rdf",
      "description": "This module defines RDF terms and relations for modeling container hierarchies, membership constraints, and pagination mechanics in Linked Data Platform systems. It operates on RDF graphs and resources to manage containment relationships (e.g., basic/direct/indirect containers), member indexing, and paged sequence sorting. Specific applications include structuring hierarchical data stores, enforcing membership rules in RDF datasets, and efficiently navigating large collections through sorted, paginated views using customizable sort criteria and directional ordering.",
      "description_length": 572,
      "index": 31,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Types.CSet",
      "library": "rdf",
      "description": "This module supports operations like union, intersection, and element-wise transformations on **immutable, ordered sets of characters**, leveraging total ordering for predictable behavior. It provides conversions between sets and sequences, along with iterative processing and structural manipulation, while preserving physical equality for efficient reuse. Such functionality is useful in text analysis, lexing, or data processing tasks where ordered character sets require efficient membership checks, ordered traversal, or aggregation into lists and sequences.",
      "description_length": 563,
      "index": 32,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Rdfs.Open",
      "library": "rdf",
      "description": "This module provides direct access to RDFS vocabulary terms as Iri.t values, enabling precise semantic annotations and metadata description in RDF data models. It includes core elements like class hierarchies, property domains and ranges, human-readable labels, and container membership. Concrete use cases include building and interpreting RDF schemas, enriching RDF triples with descriptive metadata, and validating semantic relationships between resources.",
      "description_length": 459,
      "index": 33,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Sparql_types.VarSet",
      "library": "rdf",
      "description": "This module offers operations for managing ordered collections of SPARQL variables, including union, intersection, difference, membership checks, and conversions from lists, alongside utilities to query size, retrieve elements, and identify extremum values. It operates on an abstract type representing variable sets, which encapsulates ordered structures for efficient comparison and iteration. These capabilities support use cases like analyzing variable scoping in queries, optimizing join conditions through overlap detection, and enforcing constraints during SPARQL algebra transformations.",
      "description_length": 595,
      "index": 34,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rdf.Sparql_ms.Multimu",
      "library": "rdf",
      "description": "This module provides two core data structures for handling SPARQL mappings: an unordered multiset type supporting set-theoretic operations (union, intersection, filtering) and an ordered multiset-like structure for cardinality tracking, element retrieval, and ordered transformations. Both are designed to model SPARQL's multiset semantics, enabling use cases like merging query results, eliminating duplicates with custom equality, or processing ranked solutions. The unordered variant emphasizes efficient membership checks and bulk operations, while the ordered variant supports priority-based element access and sequence-aware manipulations.",
      "description_length": 645,
      "index": 35,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Earl.Open",
      "library": "rdf",
      "description": "This module provides identifiers and structured relationships for expressing test assertions and evaluation results in RDF graphs. It defines IRIs to represent test metadata, outcomes, and contextual links between test subjects, criteria, and locations, enabling machine-readable conformance reports. These components are specifically used to model W3C-style test suite results and semantic web protocol validations using RDF triples.",
      "description_length": 434,
      "index": 36,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Term.Ordered_term",
      "library": "rdf",
      "description": "Implements comparison operations for RDF terms, enabling ordering of resources, literals, and blank nodes. Works directly with the `t` type representing RDF terms. Useful for sorting collections of RDF terms or building ordered data structures like sets and maps.",
      "description_length": 263,
      "index": 37,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rdf.Sparql_eval.GExprOrdered",
      "library": "rdf",
      "description": "This module defines a type `t` as a list of optional RDF terms and provides a `compare` function to order such lists. It is used to evaluate and compare sequences of SPARQL graph expressions where variables may be unbound. The module supports operations requiring ordered matching of query results against RDF graph patterns.",
      "description_length": 325,
      "index": 38,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Time.Open",
      "library": "rdf",
      "description": "This module provides operations for modeling temporal entities, intervals, durations, and ordering relations (e.g., *before*, *after*) using structured calendar-clock semantics. It works with `Iri.t` values to represent temporal positions, units (like minutes, months), and interval relationships (e.g., *contains*, *overlaps*) in RDF data. Specific use cases include semantic web applications requiring precise temporal reasoning, time-based metadata modeling, and calendar/ordinal system integrations.",
      "description_length": 503,
      "index": 39,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rdf.Graph.Make",
      "library": "rdf",
      "description": "This implementation provides an in-memory RDF graph with transactional control, allowing triples to be added, removed, or queried while supporting metadata management like namespace mappings and blank node generation. It features a built-in BGP engine for executing SPARQL-like pattern queries, enabling term comparison, triple pattern matching, and subject-object enumeration directly over the graph. Operations such as `commit` and `rollback` facilitate transactional data processing, while namespace handling and blank node management support dynamic, real-time linked data applications. Example uses include semantic web data manipulation, transaction-safe RDF updates, and efficient in-memory SPARQL query execution.",
      "description_length": 721,
      "index": 40,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Graph.Bid_map",
      "library": "rdf",
      "description": "This module implements bidirectional maps with ordered keys for managing bidirectional relationships in graph data, supporting operations like key-based lookups, value transformations, and ordered traversal. It works with maps binding `Rdf.Term.blank_id` keys to arbitrary values, enabling efficient filtering, partitioning, and sequence-based construction while maintaining key order. Typical use cases include representing RDF graph structures with reversible associations, such as tracking blank node mappings or maintaining ordered indexes for query optimization.",
      "description_length": 567,
      "index": 41,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rdf.Sioc.Open",
      "library": "rdf",
      "description": "This module provides operations for modeling semantic relationships and metadata in social web data using RDF IRIs. It works with SIOC ontology entities like forums, posts, user accounts, and groups to represent hierarchical connections (e.g., replies, parent-child scopes), user roles (moderator, owner), content properties (timestamps, descriptions), and social interactions (membership, subscriptions). These tools enable semantic linking and categorization of online community resources for applications like social network analysis or content moderation systems.",
      "description_length": 567,
      "index": 42,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Graph.Storage_BGP",
      "library": "rdf",
      "description": "This module evaluates Basic Graph Patterns (BGP) by efficiently matching and joining triples within a graph. It works directly with abstract term representations and provides operations to retrieve subjects, objects, and matched triples based on optional subject, predicate, or object constraints. Concrete use cases include SPARQL query processing and optimizing triple pattern joins in RDF datasets.",
      "description_length": 401,
      "index": 43,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Oa.Open",
      "library": "rdf",
      "description": "This module provides operations for constructing and managing annotations, including text/image selection mechanisms, metadata attachment, and resource state tracking. It works with RDF classes and predicates to model annotations as structured entities linked to targets, bodies, and selectors via IRIs, incorporating temporal, stylistic, and provenance metadata. Specific applications include defining precise content ranges (e.g., text positions, CSS/SVG selections), associating annotations with contextual motivations, and capturing resource derivation or rendering details.",
      "description_length": 578,
      "index": 44,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Graph.Storage",
      "library": "rdf",
      "description": "This module provides operations for managing RDF triples through insertion, removal, and pattern-based querying using subject-predicate-object templates, alongside advanced features like graph traversal, transaction control, and namespace management. It operates on a polymorphic graph type `g` containing RDF terms (IRIs, literals, blank nodes) and supports use cases such as SPARQL query execution, transactional updates in persistent RDF stores, and manipulation of blank node identifiers during graph copying or merging. Key applications include semantic web data integration, versioned RDF graph management, and BGP (Basic Graph Pattern) evaluation for query planning.",
      "description_length": 673,
      "index": 45,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "Rdf.Prov.Open",
      "library": "rdf",
      "description": "This module provides operations for defining and manipulating IRI constants and qualified relations from the PROV-O ontology, enabling structured representation of provenance metadata. It works with RDF triples, directed acyclic graphs, and semantic web data models to express relationships between entities, activities, and agents. Specific use cases include tracking entity derivation, activity influence, delegation, and temporal provenance constraints in semantic web applications aligned with PROV-DM standards.",
      "description_length": 516,
      "index": 46,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Sparql_eval.GExprMap",
      "library": "rdf",
      "description": "This module manages associative collections with ordered keys derived from SPARQL expressions, supporting polymorphic values. It provides ordered traversal, key-based splitting, and transformations with functions that manipulate both values and key-value pairs, enabling efficient filtering and aggregation over structured RDF data. Typical use cases include query result processing, where ordered expression keys represent variable bindings or intermediate evaluation steps in SPARQL queries.",
      "description_length": 493,
      "index": 47,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Dt.VSet",
      "library": "rdf",
      "description": "This module implements set-theoretic operations and ordered collection transformations for elements of type `Rdf.Dt.VSet.elt`, which represent SPARQL value computations that may carry errors. It supports functional manipulation of immutable sets through union, intersection, difference, and filtered transformations, while leveraging a total ordering to enable efficient membership checks, ordered iteration, and sequence conversions. Typical applications include aggregating and querying RDF term values with error propagation, optimizing SPARQL expression evaluation through ordered set operations, and converting between sets and sequences for pipeline processing.",
      "description_length": 667,
      "index": 48,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Graph.Storage-BGP",
      "library": "rdf",
      "description": "Implements in-place graph storage for RDF terms with support for term comparison, subject/object enumeration, and pattern-based triple lookups. Works directly with graph (`g`) and term types, enabling efficient traversal and querying of RDF datasets. Useful for applications requiring direct manipulation of RDF triples in memory or persistent storage backends.",
      "description_length": 361,
      "index": 49,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rdf.Sparql_ms.MuOrdered",
      "library": "rdf",
      "description": "This module defines a type `t` as an alias for `Rdf.Sparql_ms.mu` and provides a `compare` function to establish a total ordering between values of this type. It is used to manage and compare SPARQL query solution mappings in a way that supports ordered collections or sorting. A concrete use case is enabling efficient storage and retrieval of SPARQL query results in ordered data structures like sets or maps.",
      "description_length": 411,
      "index": 50,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Graph.Graph-BGP",
      "library": "rdf",
      "description": "Implements a graph-based Basic Graph Pattern (BGP) engine for RDF data. It supports operations to bind and compare terms, retrieve subjects and objects, and query triples using partial patterns. Designed for in-memory traversal and manipulation of RDF graphs based on SPARQL semantics.",
      "description_length": 285,
      "index": 51,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Activitypub.Open",
      "library": "rdf",
      "description": "This module provides standardized Internationalized Resource Identifiers (IRIs) for ActivityPub and ActivityStreams vocabulary terms, encompassing actions (e.g., Follow, Block), object types (e.g., Article, Video), properties (e.g., attributedTo, url), and collection types (e.g., Collection, OrderedCollection). These IRIs, represented as `Iri.t` values, enable precise RDF-based data modeling, JSON-LD serialization, and semantic annotation of social interactions and metadata. They are critical for interoperability in federated social networks, supporting use cases like media uploads, relationship management (e.g., followers, likes), and endpoint routing (e.g., inbox, OAuth tokens).",
      "description_length": 689,
      "index": 52,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Mem.Mem",
      "library": "rdf",
      "description": "This module provides in-memory RDF graph management with transactional support, combining tree-based triple indexing and list-based namespace mappings to enable efficient storage, querying, and state manipulation. It allows adding, removing, and querying triples by subject-predicate-object patterns, managing blank nodes, and resolving namespaces dynamically during processing. Operations include transactional updates, graph comparison, and enumeration of subjects and objects within the dataset. Use cases range from semantic web data integration to transaction-safe RDF processing workflows.",
      "description_length": 595,
      "index": 53,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rdf.Term.TMap",
      "library": "rdf",
      "description": "This module supports ordered map operations over key-value pairs where keys are RDF terms, enabling efficient traversal, filtering, and transformation based on key order. It provides functions like `fold`, `filter_map`, and `split`, along with conversions to and from sequences and lists, ensuring compatibility with ordered RDF term keys. Typical applications include managing RDF datasets with sorted term mappings, merging graphs with conflict resolution, or extracting subsets of data via key predicates.",
      "description_length": 508,
      "index": 54,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rdf.Sparql_http.P",
      "library": "rdf",
      "description": "This module defines the interface for sending SPARQL queries over HTTP using GET and POST methods, handling content negotiation and response parsing. It works with URIs, HTTP headers, and SPARQL result formats like XML or JSON. Concrete use cases include querying remote RDF datasets via HTTP endpoints and integrating SPARQL result parsing into client applications.",
      "description_length": 366,
      "index": 55,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Term",
      "library": "rdf",
      "description": "This module handles RDF terms including IRIs, literals, and blank nodes, offering construction, comparison, conversion, and serialization to Turtle syntax. It provides core operations for managing term identity with hashing, datetime handling, and string-based identifier conversion, enabling precise term manipulation and RDF data processing. The set submodule supports ordered collections with efficient set algebra and ordered traversal, ideal for managing vocabularies and performing set-based RDF reasoning. The map submodule enables ordered key-value mappings using RDF terms as keys, supporting transformations and traversals useful for dataset management and graph merging.",
      "description_length": 681,
      "index": 56,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rdf.Owl",
      "library": "rdf",
      "description": "This module provides core OWL vocabulary elements and utilities for working with RDF triples and OWL ontologies, focusing on classes, properties, and logical axioms. It includes operations for building and manipulating class expressions, property restrictions, and ontology metadata, using `Iri.t` to represent semantic constructs. Submodules extend this functionality with constants and utilities for defining class hierarchies, enforcing constraints like cardinality and disjointness, and expressing logical relationships. Together, they enable modeling domain knowledge, constructing semantic web ontologies, and supporting reasoning over linked data.",
      "description_length": 654,
      "index": 57,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rdf.Sparql_map",
      "library": "rdf",
      "description": "This module transforms SPARQL query components through recursive traversal of abstract syntax trees, applying user-defined mappers to elements like variables, IRIs, literals, graph patterns, and solution modifiers. It operates on structured representations of SPARQL constructs including expressions, constraints, triples, and sub-selects, enabling systematic rewriting or analysis of query logic. Typical applications include query optimization, schema-aware rewriting, and semantic transformations of SPARQL queries during processing or compilation.",
      "description_length": 551,
      "index": 58,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Webacl",
      "library": "rdf",
      "description": "This module provides operations to manipulate access rights by adding, removing, and checking read, write, append, and control permissions. It works with a custom `rights` type representing sets of permissions, along with IRI lists to map rights to standardized identifiers. Concrete use cases include enforcing access control policies in RDF-based web applications and converting between human-readable rights and their serialized representations.",
      "description_length": 448,
      "index": 59,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Stubs",
      "library": "rdf",
      "description": "This module defines placeholder implementations and references to external functions for string manipulation and hashing. It includes stubs for SHA-1 and SHA-256 hashing, PCRE-based string replacement, and pattern matching. These are used when full implementations are unavailable or during early development stages.",
      "description_length": 316,
      "index": 60,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Ds",
      "library": "rdf",
      "description": "This module manages RDF datasets composed of a default graph and named graphs, supporting retrieval, addition, iteration, merging, and isomorphism checks. It provides core operations like `add_graph`, `get_graph`, and `merge_named_graphs`, while its child module handles ordered sets of graph names with functional transformations and efficient membership queries. Use cases include SPARQL dataset manipulation, RDF quad management with distinct contexts, and deterministic processing through ordered graph identifier sets. The API combines direct dataset mutation with immutable set logic for flexible data handling.",
      "description_length": 617,
      "index": 61,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rdf.Utf8",
      "library": "rdf",
      "description": "This module handles UTF-8 encoded strings with functions for indexing, substring extraction, character counting, and encoding conversion. It supports operations like finding character positions, slicing by UTF-8 index, checking prefixes/suffixes, escaping and unescaping sequences, and case transformations. Use cases include parsing and manipulating UTF-8 text in formats like JSON, XML, or RDF where precise character handling and string transformations are required.",
      "description_length": 469,
      "index": 62,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Mem",
      "library": "rdf",
      "description": "This module implements an in-memory RDF graph system with transactional capabilities, using tree-based indexing for efficient triple storage and retrieval. It supports operations such as adding, removing, and querying triples by subject-predicate-object patterns, dynamic namespace resolution, and graph comparison. Blank nodes are managed internally, and the system allows enumeration of subjects and objects for analysis or export. Example uses include semantic data integration, versioned RDF processing, and transaction-safe data manipulation workflows.",
      "description_length": 557,
      "index": 63,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Sparql_http",
      "library": "rdf",
      "description": "This module implements HTTP bindings for the SPARQL query protocol, encoding queries into GET and POST requests and decoding structured responses in formats like XML or JSON. It provides a functor that integrates with HTTP clients to send SPARQL queries\u2014such as SELECT, ASK, and CONSTRUCT\u2014to remote endpoints like DBpedia or Wikidata, handling content negotiation and result parsing. The core types include SPARQL messages, IRIs, and HTTP response handlers, with operations for query execution and result decoding. Submodules define interfaces for request/response handling, content negotiation, and result format parsing, enabling applications to query RDF datasets and process structured results directly.",
      "description_length": 707,
      "index": 64,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Json",
      "library": "rdf",
      "description": "Converts JSON data into RDF terms and SPARQL query results. Processes `Yojson.Basic.t` structures to construct RDF model elements and parse SPARQL responses. Useful for integrating JSON-based APIs or storage with RDF data processing workflows.",
      "description_length": 243,
      "index": 65,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rdf.Rdf_",
      "library": "rdf",
      "description": "This module enables the construction and manipulation of RDF statements, literals, and containers using standardized IRIs and XML Schema datatypes. It supports RDF triples, typed literals with language tags or XML content, and semantic structures like lists and bags, with direct operations for creating and inspecting RDF graphs. The child module supplies essential IRI constants for RDF vocabulary and XSD types, such as `rdf_predicate`, `xsd_integer`, and `rdf_c_Bag`, which are used to accurately represent and process semantic web data. Together, they facilitate tasks like modeling metadata, serializing JSON-LD, and validating linked data structures.",
      "description_length": 657,
      "index": 66,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Doap",
      "library": "rdf",
      "description": "This module defines the DOAP RDF vocabulary using `Iri.t` values to represent structured metadata for software projects, including repositories, contributors, licenses, and release data. It enables the construction and querying of RDF graphs that link projects to source code, developers, and external resources like bug trackers. The child module supplies standard IRIs for common DOAP terms, simplifying the creation of triples that describe project relationships and attributes. Together, they support modeling and navigating software ecosystems through precise RDF-based metadata representations.",
      "description_length": 600,
      "index": 67,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Sioc",
      "library": "rdf",
      "description": "This module enables the construction of namespaced IRIs and defines semantic relationships between entities in online communities, such as forums, posts, and users, using RDF resources. It supports modeling hierarchical connections, user roles, content metadata, and social interactions, with operations to represent forum structures, track replies, associate content with topics, and manage user memberships or ownership. The child module extends this functionality by providing specific tools for semantic linking, categorization, and metadata handling within the SIOC ontology. Together, they facilitate applications like social network analysis, content moderation, and semantic web integration through structured relationships and typed RDF-based data modeling.",
      "description_length": 766,
      "index": 68,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Utils",
      "library": "rdf",
      "description": "Extracts the title of a resource from a graph by looking up the `dc:title` or `rdfs:label` properties. Works with RDF graphs and IRI identifiers. Useful for retrieving human-readable names of resources in semantic web applications.",
      "description_length": 231,
      "index": 69,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Sparql_eval",
      "library": "rdf",
      "description": "This module evaluates SPARQL expressions and executes query algebra operations over RDF datasets, handling built-in functions, value comparisons, and constraint filtering. It processes data using variable mappings and solution sequences, supporting joins, unions, sorting, and aggregations like `COUNT` and `GROUP_CONCAT`. One submodule defines ordered sequences of optional RDF terms for comparing SPARQL graph expression results, while another manages ordered associative collections for efficient filtering and aggregation based on SPARQL expression keys. Together, they enable structured manipulation of RDF data through operations such as type conversion, language-tagged string matching, and ordered traversal of query solutions.",
      "description_length": 735,
      "index": 70,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rdf.Sparql_ms",
      "library": "rdf",
      "description": "This module manages variable bindings and multiset structures essential for SPARQL query evaluation, offering operations for union, join, filtering, and transformation with immutable data semantics. It includes submodules that define ordered and unordered multiset types for handling SPARQL mappings with set-theoretic and sequence-aware operations, a ranked pair structure for indexed result merging, and comparison utilities for mapping ordering. The unordered multiset supports efficient membership and bulk operations, while the ordered variant enables priority-based access and cardinality tracking, useful for query result merging and duplicate elimination. Concrete uses include sorting solutions by rank, enforcing SPARQL filter constraints, and combining partial query results with union or join operations.",
      "description_length": 816,
      "index": 71,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rdf.Sparql_expand",
      "library": "rdf",
      "description": "This module facilitates SPARQL query normalization and transformation by resolving prefixed names, normalizing IRIs, and rewriting query components like variables, paths, and graph patterns using a shared environment that tracks base IRIs and namespace prefixes. It operates on SPARQL abstract syntax trees, recursively processing elements such as constraints, solution modifiers, and dataset declarations while maintaining contextual consistency. Typical applications include query preprocessing for execution, dataset construction with environment-aware substitutions, and semantic rewriting of RDF graph patterns in SPARQL engines.",
      "description_length": 634,
      "index": 72,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rdf.Sparql_lex",
      "library": "rdf",
      "description": "Performs Unicode-aware lexing for SPARQL queries, handling input streams and position tracking. It converts escaped Unicode sequences into actual characters and produces tokens for the SPARQL parser. Useful for processing SPARQL query strings with internationalized identifiers and literals.",
      "description_length": 291,
      "index": 73,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Vcard",
      "library": "rdf",
      "description": "This module provides a set of IRI constants for modeling contact information in RDF, based on the W3C vCard ontology. It includes classes and properties for personal data such as names, addresses, dates, and communication methods, along with relationship types and metadata like organizations and revisions. The module enables structured annotation of contact details in semantic web applications, supporting both standard vCard fields and legacy property mappings. Specific IRIs allow categorizing contacts by relationship (e.g., colleague, friend) and labeling communication methods (e.g., work, home).",
      "description_length": 604,
      "index": 74,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rdf.Activitypub",
      "library": "rdf",
      "description": "This module enables the construction and interpretation of ActivityPub data models using semantic identifiers and RDF principles, centered around `Iri.t` values that represent activities, object types, and metadata properties. It provides core operations for working with social actions like `Follow` and `Create`, content types such as `Article` and `Video`, and relationships including `attributedTo` and `inReplyTo`, supporting JSON-LD serialization and federated protocol implementation. The child module supplies standardized IRIs for key vocabulary terms, ensuring interoperability across decentralized systems by precisely identifying entities and endpoints required for social interactions, media handling, and user relationships. Together, they facilitate the modeling, exchange, and semantic annotation of user activities and content in federated networks.",
      "description_length": 866,
      "index": 75,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Sparql_types",
      "library": "rdf",
      "description": "This module provides core types and structures for representing and manipulating SPARQL queries, including variables, literals, graph patterns, and update operations, with support for precise source location tracking. It enables the construction and analysis of SPARQL syntax trees for applications such as query optimization, RDF data transformation, and semantic web tooling. A submodule handles ordered string collections with lexicographical comparison, facilitating sorted result handling and identifier management, while another manages ordered sets of SPARQL variables with set operations and extremum queries, aiding in scoping analysis and constraint enforcement during query rewriting. Together, these components support precise, efficient manipulation of SPARQL syntax and semantics across diverse processing pipelines.",
      "description_length": 830,
      "index": 76,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rdf.Sparql_vis",
      "library": "rdf",
      "description": "This module provides visitor functions for traversing and transforming SPARQL abstract syntax trees, handling constructs like IRIs, literals, variables, triple patterns, graph patterns, and solution modifiers. Built on data structures from `Rdf.Sparql_types`, it enables tasks such as query analysis, optimization, or conversion into alternative representations by systematically processing expressions, aggregates, and path components through dedicated visitor methods.",
      "description_length": 470,
      "index": 77,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Time",
      "library": "rdf",
      "description": "This module models temporal entities, intervals, and durations using the W3C Time Ontology, supporting calendar-clock semantics through `Iri.t` values to represent time positions, units, and relations. It enables operations such as comparing intervals (*before*, *overlaps*), expressing durations (minutes, years), and annotating RDF data with temporal constraints. Child modules extend this functionality with structured operations for temporal reasoning, including interval containment, ordering, and integration with semantic web standards like OWL. Examples include modeling event timelines, enforcing time-based metadata, and expressing temporal constraints in linked data applications.",
      "description_length": 691,
      "index": 78,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Ttl_parser",
      "library": "rdf",
      "description": "Parses Turtle and N-Triples syntax into RDF terms and triples. It processes lexbuf input using a tokenizer, converting sequences of tokens into structured data like IRIs, literals, and blank nodes. Useful for reading RDF data from strings or files into a graph representation.",
      "description_length": 276,
      "index": 79,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rdf.Sparql",
      "library": "rdf",
      "description": "This module supports parsing and executing SPARQL queries over RDF data, handling operations like SELECT, CONSTRUCT, ASK, DESCRIBE, and UPDATE to retrieve or manipulate graph structures. It works with RDF graphs and datasets, producing typed query results such as solutions, boolean responses, or transformed RDF terms, while allowing customization through user-defined IRI resolution logic. Typical applications include semantic web querying, data integration pipelines, and dynamic graph validation workflows.",
      "description_length": 511,
      "index": 80,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rdf.Graph",
      "library": "rdf",
      "description": "This module provides in-place manipulation of RDF graphs through triple addition, removal, and querying, alongside structural operations like isomorphism checks and subgraph copying. It supports RDF terms (IRIs, literals, blank nodes) and advanced features such as transaction control, namespace management, and BGP evaluation for SPARQL-like queries. Submodules offer specialized functionality: in-memory graph storage with transactional updates, bidirectional mapping for blank node tracking, and optimized BGP engines for efficient triple pattern matching. Example workflows include semantic data synchronization, transaction-safe RDF updates, and cross-storage graph persistence with customizable query execution.",
      "description_length": 717,
      "index": 81,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Activitystreams",
      "library": "rdf",
      "description": "This module provides a set of IRI constants for the ActivityStreams 2.0 vocabulary, enabling precise modeling of social activities, objects, and metadata in RDF graphs. It defines core types such as activity kinds (`c_Create`, `c_Like`), object classes (`c_Event`, `c_Person`), and properties like `published` and `totalItems`, all operating on `Iri.t` values. These constants support semantic web applications by encoding structured relationships and actions for systems like ActivityPub. Submodules extend this vocabulary with additional standardized IRIs for activities, object types, and properties, enhancing interoperability in social data aggregation and linked data workflows.",
      "description_length": 684,
      "index": 82,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rdf.Sparql_protocol",
      "library": "rdf",
      "description": "This module handles the SPARQL protocol for querying and updating RDF datasets. It defines data structures for input messages, including queries and datasets with default and named graphs, and supports parsing, validation, and error handling for SPARQL requests. Concrete use cases include constructing SPARQL query requests with specific datasets and processing protocol-level errors during SPARQL execution.",
      "description_length": 409,
      "index": 83,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rdf.Sedlex",
      "library": "rdf",
      "description": "This module provides functions to integrate Ulex lexical analysis with Menhir parsers, specifically handling position tracking during lexing. It works with `Sedlexing.lexbuf` and `Stdlib.Lexing.position` to maintain accurate source locations. A key use case is enabling Menhir-based parsers to consume input from Ulex-generated lexers while correctly reporting positions in error messages or AST nodes.",
      "description_length": 402,
      "index": 84,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Pim",
      "library": "rdf",
      "description": "This module defines RDF classes and properties for modeling storage and workspace configurations, such as public and private workspaces and storage types, using IRIs to represent resources like preferences files and master workspaces. It includes operations to construct and identify URIs within workspaces, supporting use cases like access control policy modeling, data organization in semantic web applications, and managing shared or user-specific workspaces. The child module extends this functionality with functions to manage access control policies, set storage types, and define relationships between workspaces and storages using IRI-based identifiers. Together, they enable configuring data isolation, defining permissions on shared resources, and handling URI prefixes for resource addressing.",
      "description_length": 804,
      "index": 85,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Loc",
      "library": "rdf",
      "description": "This module represents and manipulates source code locations using character positions. It defines a `loc` type that captures start and end positions in a source file or string, and provides functions to construct locations from file content or strings, as well as convert locations to human-readable strings or formatted output. It is used to track and report precise source positions during parsing or error reporting.",
      "description_length": 420,
      "index": 86,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Log",
      "library": "rdf",
      "description": "This module provides logging functionality using the `Logs` library, exposing standard severity-level log functions (`err`, `warn`, `info`, `debug`) to emit formatted messages. It works with string-based log messages and supports structured logging through `Logs.msgf` formatting. Concrete use cases include tracking parsing errors, reporting load progress, and debugging triple generation in RDF processing pipelines.",
      "description_length": 418,
      "index": 87,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Ldp",
      "library": "rdf",
      "description": "This module provides tools for managing Linked Data Platform resources by organizing them into hierarchical containers, enforcing membership constraints, and enabling efficient traversal of large datasets through sorted, paginated sequences. It uses `Iri.t` to represent RDF constructs like containers and members, and supports operations for defining containment relations, indexing members, and applying predicate-based sorting with directional ordering. Child modules extend this functionality by defining RDF terms and relations that model container hierarchies, manage member inclusion rules, and implement pagination mechanics over RDF graphs. Examples include structuring data stores with nested containers, enforcing membership conditions, and retrieving large collections in ordered, paged segments based on custom criteria.",
      "description_length": 833,
      "index": 88,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rdf.Types",
      "library": "rdf",
      "description": "This module provides a suite of ordered data structures built around characters and strings, enabling efficient comparison, traversal, and transformation. It includes character and string types with total ordering, immutable ordered sets and maps with operations like union, intersection, and ordered iteration, as well as named string types for RDF-compatible comparisons. You can build and manipulate ordered collections of characters and strings, perform set and map operations with predictable ordering, and model RDF data using ordered maps and comparable string types. Examples include constructing character sets for lexing, transforming string sets in data pipelines, and maintaining sorted maps for RDF term indexing.",
      "description_length": 726,
      "index": 89,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Config",
      "library": "rdf",
      "description": "Retrieves the library's version as a string. Works with no data structures, returning a simple string value. Useful for checking the current version of the library at runtime.",
      "description_length": 175,
      "index": 90,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Ttl",
      "library": "rdf",
      "description": "This module parses and serializes RDF data in Turtle format. It provides functions to read from strings or files into an RDF graph, write a graph to a Turtle string or file with optional namespace declarations and compact formatting, and convert individual RDF terms and triples to their Turtle string representations. It directly handles RDF graphs, terms, IRIs, and namespaces.",
      "description_length": 379,
      "index": 91,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Oa",
      "library": "rdf",
      "description": "This module enables the creation and manipulation of semantic annotations using RDF triples, with core operations for defining targets, bodies, selectors, and metadata through standardized relationships. It centers on `Iri.t`-based modeling of annotation components like textual or temporal ranges, styling, and provenance, supporting precise resource targeting and contextual metadata attachment. Child modules extend this by providing structured mechanisms for annotation management, including selection techniques (XPath, CSS, text ranges), motivation tagging, and state tracking. Examples include building annotations with CSS selectors and styling hints, or capturing temporal states and derivation chains for versioned resources.",
      "description_length": 735,
      "index": 92,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Foaf",
      "library": "rdf",
      "description": "This module provides direct access to FOAF vocabulary terms as IRI values, enabling the representation of individuals, their attributes, and relationships within RDF graphs. It includes core classes like `foaf_c_Person` and properties such as `foaf_knows`, `foaf_email`, and `foaf_openid`, supporting the modeling of social connections, digital identities, and personal metadata. Submodules extend this functionality with additional constants and utilities for structured data interchange in semantic web and linked data applications. Example uses include integrating social network data, linking agents to online resources, and standardizing descriptions of people and groups in RDF-based systems.",
      "description_length": 698,
      "index": 93,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Dt",
      "library": "rdf",
      "description": "This module provides a comprehensive framework for working with RDF terms as typed values in SPARQL computations, handling literals, integers, booleans, and datetimes with error-aware operations. It supports parsing, conversion, and coercion of RDF terms while propagating type errors, enabling robust expression evaluation. Submodules extend this with comparison logic for ordered values, ordered maps for term bindings, and set operations for error-aware collections. These tools facilitate tasks like sorting query results, aggregating term mappings, and performing set-theoretic transformations in SPARQL processing pipelines.",
      "description_length": 630,
      "index": 94,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Nq",
      "library": "rdf",
      "description": "This module parses and serializes N-quads data, handling input and output operations for datasets and graphs. It provides functions to convert N-quads strings and files to and from dataset and graph structures, supporting direct data persistence and interchange. Concrete use cases include loading RDF data from N-quads files into a dataset or exporting a graph to an N-quads string for transmission.",
      "description_length": 400,
      "index": 95,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Bgp",
      "library": "rdf",
      "description": "This module evaluates Basic Graph Patterns over RDF datasets using pattern matching and variable substitution, enabling SPARQL-like query execution. It provides core operations for matching triple patterns, resolving variables, and joining results, working with RDF terms, triples, and graph structures. The module processes SPARQL algebra triples into multiset results, supporting structured query evaluation and pattern-based lookups with subject, predicate, or object filters. It combines direct APIs for triple matching with submodules that handle result merging, term comparison, and algebraic evaluation.",
      "description_length": 610,
      "index": 96,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Acl",
      "library": "rdf",
      "description": "This module provides RDF terms and classes for modeling access control policies, including permissions like read, write, append, and control over resources. It defines core entities such as Agent, Authorization, and AccessTo, enabling the construction and interpretation of fine-grained access rules in semantic web applications. The module supports operations for specifying ownership, agent groups, and delegation, aligning with W3C's ACL vocabulary. Use cases include defining ACL rules for linked data, managing permissions on RDF graphs, and implementing authorization policies in web-based systems.",
      "description_length": 604,
      "index": 97,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Ttl_lex",
      "library": "rdf",
      "description": "This module implements a Unicode-aware lexer for parsing Turtle (TTL) files. It defines a set of reserved characters used in TTL syntax and provides the `main` function to tokenize input from a `Sedlexing.lexbuf`, producing positions and tokens for the parser. It is used directly during the lexical analysis phase of RDF data ingestion in Turtle format.",
      "description_length": 354,
      "index": 98,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Dc",
      "library": "rdf",
      "description": "This module provides semantic identifiers for Dublin Core metadata terms, enabling structured annotations of resources using standardized vocabularies. It defines Iri.t values for properties such as title, rights, and date, along with data types like time intervals and geographic points, to model metadata in RDF graphs. The child module exposes specific Dublin Core terms as Iri.t values, supporting the description of creators, formats, and relationships in RDF triples. Use cases include annotating datasets with spatial coverage, encoding provenance information, and expressing licensing terms using DCMI vocabularies.",
      "description_length": 623,
      "index": 99,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Dot",
      "library": "rdf",
      "description": "This module converts RDF graphs into Graphviz format for visualization. It provides functions to generate namespace mappings, apply prefixes to IRIs, and output DOT representations of entire graphs or specific IRI-related triples. It works directly with RDF graphs and IRI values, enabling visual inspection of RDF data through directed graphs.",
      "description_length": 344,
      "index": 100,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Prov",
      "library": "rdf",
      "description": "This module enables the construction and interpretation of RDF triples that model provenance information using the PROV-O vocabulary, representing entities, activities, and agents through typed IRIs and constants. It supports relationships such as generation, usage, and influence, facilitating the description of data lineage, temporal interactions, and contextual roles in semantic web applications. The child module extends this by defining IRI constants and qualified relations, allowing structured metadata representation through directed acyclic graphs and semantic web data models. Together, they enable precise tracking of derivation, delegation, and provenance constraints, suitable for scientific workflow tracking and digital artifact auditing.",
      "description_length": 755,
      "index": 101,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Sparql_print",
      "library": "rdf",
      "description": "This module serializes SPARQL abstract syntax tree (AST) elements\u2014such as queries, graph patterns, triples, and expressions\u2014into string buffers, handling components like `SELECT` clauses, `VALUES` blocks, path modifiers, and solution modifiers. It operates on SPARQL AST types, formatting structured data into human-readable SPARQL syntax for query generation or debugging purposes. The resulting output can be used to construct executable SPARQL queries or inspect internal representations during development.",
      "description_length": 510,
      "index": 102,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rdf.Earl",
      "library": "rdf",
      "description": "This module provides RDF IRI constants for modeling test outcomes and metadata in semantic web validation, including classes like `c_Pass` and `c_TestCase`, and properties such as `assertedBy` and `info`. It operates on `Iri.t` values to represent test subjects, assertors, and evaluation results, enabling structured reporting through EARL-compliant RDF graphs. Submodules define identifiers and relationships for expressing test assertions, outcomes, and contextual links, supporting machine-readable conformance reports. Specific uses include encoding W3C test suite results and semantic protocol validations using RDF triples.",
      "description_length": 630,
      "index": 103,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Ttl_types",
      "library": "rdf",
      "description": "This module defines core data structures and types for parsing and representing Turtle (TTL) syntax in RDF, including IRIs, literals, subjects, objects, and statements. It handles namespaces through prefix and base directives, maintaining context with IRI resolution and prefix mappings. It is used for processing Turtle documents into structured statements that can be further interpreted into RDF graphs.",
      "description_length": 406,
      "index": 104,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Security",
      "library": "rdf",
      "description": "This module enables cryptographic operations for RDF datasets, combining signature schemes like ECDSA, Ed25519, and BBS-BLS with key management and proof metadata handling. It supports cryptographic primitives such as keys, digests, and nonces, and works with RDF graphs and IRIs to secure data integrity, authentication, and decentralized identity workflows. Child modules extend these capabilities with canonicalization algorithms and selective disclosure mechanisms, enabling use cases like blockchain identifier integration and processing JSON-LD/RDFa-encoded security metadata. Together, they provide a comprehensive toolkit for creating and verifying linked data proofs in semantic web applications.",
      "description_length": 705,
      "index": 105,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Update",
      "library": "rdf",
      "description": "This module handles RDF graph updates by applying SPARQL solutions to triples, managing blank node mappings, and performing insertions, deletions, and modifications on RDF graphs. It operates on RDF graphs, SPARQL algebra triples, solution mappings, and blank node identifiers. Concrete use cases include updating RDF datasets based on SPARQL `INSERT`, `DELETE`, and `MODIFY` operations, and applying query solutions to graph mutations while handling blank node scoping.",
      "description_length": 470,
      "index": 106,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Lang",
      "library": "rdf",
      "description": "This module validates language tags according to RFC5646. It provides a function `is_valid_language_tag` that checks if a given string conforms to the language tag format specified in section 2.1 of RFC5646. It operates on string inputs and is used to ensure correct formatting of language identifiers in applications handling multilingual data.",
      "description_length": 345,
      "index": 107,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rdf.Xml",
      "library": "rdf",
      "description": "This module parses and serializes RDF/XML documents into a tree structure, handling XML namespaces, blank nodes, and base IRIs. It processes XML trees to populate RDF graphs using subject-predicate-object triples, supporting node and property input with language and datatype tracking. You can read RDF data from XML strings, files, or input handles, and convert RDF graphs back to RDF/XML with optional namespace declarations and compact serialization. Submodules extend this functionality with specialized parsing, formatting, and namespace management tools for more precise control over RDF/XML processing.",
      "description_length": 609,
      "index": 108,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Solid",
      "library": "rdf",
      "description": "This module provides RDF terms and classes from the Solid vocabulary, enabling precise modeling of core concepts like accounts, inboxes, notifications, and timelines through direct IRI access and constructors. It supports operations for tracking notification states, organizing data in timeline containers, and registering RDF types within Solid-compliant storage. Submodules extend this functionality with specialized IRIs and structures for managing notification status, time-ordered resources, and type registries. Example uses include building unread tracking systems, structuring data in file-based timelines, and registering application-specific types for discovery.",
      "description_length": 672,
      "index": 109,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rdf.Rdfs",
      "library": "rdf",
      "description": "This module enables the construction and manipulation of RDF Schema elements using `Iri.t` identifiers and `Rdf.Graph.graph` structures, supporting the definition of classes with inheritance, properties with domain and range constraints, and metadata annotations. It provides direct access to core RDFS vocabulary terms for precise semantic modeling, allowing operations like declaring subclass relationships, specifying property characteristics, and attaching human-readable labels. Concrete applications include building ontology hierarchies, validating RDF data against schema definitions, and enriching semantic graphs with structured metadata. The combination of programmatic schema assembly and vocabulary-based annotations supports robust semantic web data modeling and vocabulary creation workflows.",
      "description_length": 807,
      "index": 110,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Misc",
      "library": "rdf",
      "description": "This module includes functions for handling optional values, such as converting between strings and string options, mapping over optional values, and comparing optional and list values. It operates on data types like `string option`, `'a list`, and `char list`. Specific use cases include reading file contents into a string, splitting strings based on delimiter characters, and performing comparisons on lists and optional values.",
      "description_length": 431,
      "index": 111,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Sparql_parser",
      "library": "rdf",
      "description": "This module defines a lexer and parser for SPARQL queries, converting input text into an abstract syntax tree representing SPARQL operations. It recognizes SPARQL keywords, variables, literals, and operators as distinct token types and processes them into structured query representations. It is used to parse SPARQL SELECT, INSERT, DELETE, and other query forms into executable structures for RDF data manipulation.",
      "description_length": 416,
      "index": 112,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rdf.Test_manifest",
      "library": "rdf",
      "description": "This module provides constants and IRIs for structuring RDF test manifests, enabling the classification of test types, specification of actions, and encoding of metadata such as expected outcomes and status indicators. It supports operations on RDF vocabularies to define test cases, validate constraints like cardinality and status, and organize test suites for RDF and SPARQL processing systems. Specific uses include identifying syntax validation tests, associating test entries with datasets, and annotating test cases with conformance requirements. Submodules extend these capabilities by providing specific IRIs for test categorization and metadata handling.",
      "description_length": 664,
      "index": 113,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rdf",
      "library": "rdf",
      "description": "This module provides a comprehensive toolkit for working with RDF data, including terms, triples, graphs, and datasets, alongside support for SPARQL query processing, OWL ontologies, and semantic vocabularies. Core data types include IRIs, literals, blank nodes, RDF graphs, datasets, and SPARQL expressions, with operations for construction, transformation, querying, and serialization. It enables tasks such as semantic reasoning with OWL, access control modeling, temporal data representation, and cryptographic signing of RDF datasets. Specific applications include parsing and executing SPARQL queries, building linked data applications with FOAF and DOAP vocabularies, and visualizing RDF graphs using Graphviz.",
      "description_length": 717,
      "index": 114,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 138,
    "meaningful_modules": 115,
    "filtered_empty_modules": 23,
    "retention_rate": 0.8333333333333334
  },
  "statistics": {
    "max_description_length": 866,
    "min_description_length": 175,
    "avg_description_length": 523.6173913043478,
    "embedding_file_size_mb": 0.4182004928588867
  }
}