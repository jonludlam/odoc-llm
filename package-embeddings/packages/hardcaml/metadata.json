{
  "package": "hardcaml",
  "embedding_model": "Qwen/Qwen3-Embedding-8B",
  "embedding_dimension": 4096,
  "total_modules": 453,
  "creation_timestamp": "2025-08-18T20:25:50.382617",
  "modules": [
    {
      "module_path": "Ppx_hardcaml0",
      "library": "ppx_hardcaml0",
      "description": "This module implements hardware description and simulation utilities for digital circuits, focusing on operations like signal manipulation, combinational logic synthesis, and sequential circuit construction. It works with data types representing hardware signals, registers, and clocked processes. Concrete use cases include defining synchronous hardware designs, simulating circuit behavior, and generating Verilog output for synthesis.",
      "description_length": 437,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Flags_vector.Make.Flags.Map.Diff",
      "library": "hardcaml",
      "description": "This module defines operations for representing and manipulating differences between two states of a flag vector, specifically supporting serialization to and from S-expressions. It provides functions to construct diffs from lists, extract diffs between specific states, and apply diffs to a base state to produce a modified state. The module works with flag vectors and their derived types, where each flag's state transition is captured as an optional difference.",
      "description_length": 465,
      "index": 1,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Types.With_valid.Wrap.Make.Of_signal",
      "library": "hardcaml",
      "description": "This interface provides functions for constructing and manipulating hardware signal graphs with explicit validity tracking, supporting operations like signal connection (`<==`), port creation (`inputs`/`outputs`), and width-aware composition (concatenation, multiplexing, register instantiation). It operates on signal interfaces represented as structured tuples of data and valid signals, enabling safe routing and naming of hierarchical digital circuits. Key use cases include building synchronized pipeline stages, validating signal width consistency in arithmetic blocks, and generating named ports for simulation or synthesis from abstract hardware descriptions.",
      "description_length": 667,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.With_valid.Fields.Make.Of_bits",
      "library": "hardcaml",
      "description": "This module provides operations to construct, manipulate, and validate bit-level interfaces with explicit valid signals. It works with record-like structures where each field is a `Hardcaml.Bits.t` value paired with a validity bit. Concrete use cases include packing and unpacking hardware interfaces to and from bit vectors, multiplexing between multiple interfaces based on a selector, and validating field widths to ensure correct signal alignment in hardware descriptions.",
      "description_length": 476,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Flags_vector.Make.Flags.Map.Key",
      "library": "hardcaml",
      "description": "This module defines a key type for maps based on a vector of flags, including serialization to and from S-expressions. It supports comparison operations using a comparator tailored for flag vectors. This module is useful when managing sets or maps keyed by combinations of boolean flags, such as configuration settings or bitmask identifiers.",
      "description_length": 342,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.With_valid.Wrap.Make.Of_always",
      "library": "hardcaml",
      "description": "This module provides functions to construct and manipulate hardware interfaces using the Always API, specifically for creating and assigning register and wire signals within an always block. It works with interface types that wrap signals in the `With_valid.t2` structure, allowing for named signal declarations and assignments. Concrete use cases include defining register pipelines with optional enables, creating wire signals with default values, and assigning values to interface fields inside always blocks.",
      "description_length": 512,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Flags_vector.Make.Flags.Set.Elt",
      "library": "hardcaml",
      "description": "This module defines a set element type for a specific flag-based data structure, supporting conversion to and from S-expressions and providing a comparator for ordering. It works with flag vectors, enabling efficient set operations and serialization. Concrete use cases include managing collections of unique flag configurations and persisting them in a structured format.",
      "description_length": 372,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Flags_vector.Make.Flags.Set.Provide_bin_io",
      "library": "hardcaml",
      "description": "This module implements binary serialization and deserialization for a set of flags, enabling efficient storage and transmission of flag states. It operates directly on the `Flags.Set.t` type, leveraging the underlying flag definitions to encode and decode values. Concrete use cases include persisting configuration options to disk or sending runtime state over a network.",
      "description_length": 372,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Flags_vector.Make.Flags.Set.Diff",
      "library": "hardcaml",
      "description": "This module represents and manipulates differences between sets of flag values. It supports operations to compute, apply, and serialize set differences, working with sets of flag elements that have a defined ordering. Concrete use cases include tracking incremental changes to flag sets and merging or replaying sets of flag modifications.",
      "description_length": 339,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.With_valid.Fields.Make.Names_and_widths",
      "library": "hardcaml",
      "description": "This module generates port names and widths for a Hardcaml interface, producing a list of string-integer pairs representing each port's name and bit width. It operates on record types to extract field names and their corresponding widths based on the `With_valid.t` type structure. Use this module when defining hardware interfaces to automatically derive port metadata for simulation or synthesis purposes.",
      "description_length": 407,
      "index": 9,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Types.With_valid.Fields.Make.Make_comb",
      "library": "hardcaml",
      "description": "This module implements combinational logic operations for structured interfaces with valid signals, supporting operations like packing/unpacking to vectors, multiplexing, concatenation, and priority/one-hot selection. It works with interfaces represented as `'a With_valid.t X.t`, where each field has a defined bit width. Concrete use cases include building complex control logic, routing data paths, and constructing decoders or arbiters in hardware designs.",
      "description_length": 460,
      "index": 10,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Flags_vector.Make.Flags.Map.Provide_hash",
      "library": "hardcaml",
      "description": "Implements hash folding for flag maps using a key module to define the hash function. Works with `Flags.Map.t` structures, which are maps over boolean flags indexed by keys. Useful for generating hash values for maps where keys are hashed according to the provided key module.",
      "description_length": 276,
      "index": 11,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Flags_vector.Make.Flags.Set.Provide_of_sexp",
      "library": "hardcaml",
      "description": "Converts S-expressions into sets of flags, where each flag corresponds to an element of the `Elt` type. It supports parsing textual representations of flag sets into their in-memory counterparts for structured manipulation. This is useful when deserializing configurations or input data encoded as S-expressions into typed flag sets.",
      "description_length": 333,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.With_valid.Fields.Make.Of_always",
      "library": "hardcaml",
      "description": "This module provides functions to manipulate and assign signals within an always block when working with structured interfaces. It supports creating register and wire variables, assigning signal values, and applying naming conventions to interface fields. Concrete use cases include building synchronous logic circuits with named signal interfaces and managing signal propagation in hardware descriptions.",
      "description_length": 405,
      "index": 13,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.With_valid.Fields.Make.Of_signal",
      "library": "hardcaml",
      "description": "This module enables the construction and manipulation of structured hardware interfaces with field-based signal layouts, offering operations like constant assignment, signal concatenation, multiplexing, register control, and interface wiring. It works with `Of_signal.comb t` and `Of_signal.t` types, which represent hierarchical signal groupings validated for correctness. These tools are used to design digital circuits where precise signal interfacing, naming conventions, and width validation are critical, such as connecting functional blocks or generating synthesizable register-transfer level descriptions.",
      "description_length": 613,
      "index": 14,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.With_valid.Fields.Make.All",
      "library": "hardcaml",
      "description": "This module provides the `all` function, which combines a product of monadic values into a monadic product, effectively lifting the monad outside the interface structure. It operates on data types that conform to the `With_valid.t` interface, allowing each field to carry a monadic context. A typical use case involves aggregating multiple signal validations or computations within a hardware description, where each field's validity is tracked and processed collectively.",
      "description_length": 472,
      "index": 15,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.With_valid.Wrap.Make.Unsafe_assoc_by_port_name",
      "library": "hardcaml",
      "description": "This module directly maps record fields to an association list using port names as keys, enabling conversion between structured interfaces and string-indexed lists. It operates on `With_valid.t2` types, where each field is associated with a validity signal. Use this when interfacing with external systems that require dynamic access to signal values by name, such as generating netlists or debugging signal states.",
      "description_length": 415,
      "index": 16,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.With_valid.Wrap.Make.Names_and_widths",
      "library": "hardcaml",
      "description": "This module generates a Hardcaml interface with named ports and specified widths, producing values like `port_names`, `port_widths`, and `tags` for use in hardware description. It operates on type-level representations to define signal names and their bit widths as part of an interface. Concrete use cases include defining input/output interfaces for hardware modules with precise naming and sizing, enabling structured signal handling in simulations or synthesis.",
      "description_length": 465,
      "index": 17,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Flags_vector.Make.Flags.Set.Provide_hash",
      "library": "hardcaml",
      "description": "This module implements hash-related operations for a set of flags, enabling efficient hashing of flag set values. It provides `hash_fold_t` and `hash` functions that work directly with `Flags.Set.t` data structures. These functions are useful when flag sets need to be used as keys in hash tables or for generating unique identifiers based on their state.",
      "description_length": 355,
      "index": 18,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Flags_vector.Make.Flags.Map.Provide_of_sexp",
      "library": "hardcaml",
      "description": "This module provides a function `t_of_sexp` that converts S-expressions into a map of flags, using a provided function to parse the values. It works with flag maps where keys are determined by the `Key` module and values are of a generic type. A concrete use case is deserializing configuration data from S-expressions into typed flag maps for hardware description models.",
      "description_length": 372,
      "index": 19,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Flags_vector.Make.Flags.Map.Provide_bin_io",
      "library": "hardcaml",
      "description": "This module provides binary serialization and deserialization functions for maps where keys are of a specified type and values are flag sets. It supports operations like reading, writing, and measuring the size of such maps in binary format, enabling efficient storage or transmission of structured flag data. Concrete use cases include persisting configuration flags or encoding hardware state representations in a compact binary form.",
      "description_length": 436,
      "index": 20,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.With_valid.Fields.Make.Unsafe_assoc_by_port_name",
      "library": "hardcaml",
      "description": "This module directly associates interface fields with their port names, enabling unsafe but efficient conversion between record-like structures and association lists. It operates on data types that represent hardware interfaces with valid signals, using strings as keys for field access. Use this when mapping hardware interface signals to named ports in a design, particularly when interfacing with external systems requiring string-indexed signal representations.",
      "description_length": 465,
      "index": 21,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.With_valid.Wrap.Make.Of_bits",
      "library": "hardcaml",
      "description": "This module provides operations to construct, manipulate, and validate hardware interfaces composed of bit vectors. It supports concrete operations such as packing and unpacking interfaces to and from bit vectors, multiplexing, concatenation, and selecting between interfaces using priority or one-hot encoding. Use cases include building and validating complex signal interfaces in digital circuit design, such as register file outputs or control signal multiplexers.",
      "description_length": 468,
      "index": 22,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Types.With_valid.Wrap.Make.All",
      "library": "hardcaml",
      "description": "Combines interface values within a monadic context, lifting the monad outside the interface structure. Works with interfaces containing monadic values, transforming them into a single monadic interface result. Useful for aggregating multiple signal or register values into a unified monadic computation in hardware description contexts.",
      "description_length": 336,
      "index": 23,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Types.With_valid.Wrap.Make.Make_comb",
      "library": "hardcaml",
      "description": "This module implements combinational logic operations for wrapping and manipulating hardware interfaces with valid signals. It provides functions like `pack`, `unpack`, `mux`, and `concat` to transform interfaces, along with validation and width-checking utilities. Use cases include building multiplexers, concatenating signal groups, and converting between structured interfaces and flat vectors.",
      "description_length": 398,
      "index": 24,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.With_valid.Fields.Make.Unsafe_assoc_by_port_name",
      "library": "hardcaml",
      "description": "This module directly maps fields of a hardcaml interface to an association list using port names as keys. It enables conversion between an interface and a list of `(string * 'a)` pairs, where each string corresponds to a field's port name. Use this when interfacing with external systems that require field-level access by name, such as configuration parsers or dynamic signal routing logic.",
      "description_length": 391,
      "index": 25,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Enum.Make_enums.One_hot.All",
      "library": "hardcaml",
      "description": "This module provides the `all` function, which transforms a one-hot encoded interface of monadic values into a monadic one-hot encoded interface. It operates specifically on data structures of type `'a M.t One_hot.t`, where `M` is a monad. A concrete use case is combining multiple one-hot signals within a monadic context, such as assembling register outputs or managing concurrent state transitions in hardware descriptions.",
      "description_length": 426,
      "index": 26,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Async_fifo.Make.I.All",
      "library": "hardcaml",
      "description": "Lifts monadic values from within an interface to the interface itself, combining them into a single monadic interface. Works with any monad `M` and interface `I` where values inside the interface are wrapped in the monad. Useful for constructing hardware descriptions where interface signals are computed using monadic operations, allowing effects to be handled outside the interface structure.",
      "description_length": 394,
      "index": 27,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Clocking.Make.All",
      "library": "hardcaml",
      "description": "Lifts monadic values within an interface to a monadic interface, combining them into a single monad. Works with polymorphic interface types `'a t` and a monad `M`. Useful for aggregating clocked signals into a unified clock domain.",
      "description_length": 231,
      "index": 28,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Enum.Make_enums.One_hot.Of_bits",
      "library": "hardcaml",
      "description": "This module provides operations for working with one-hot encoded enumeration values represented as bit vectors, including case analysis, selection, and bitwise transformations. It manipulates `Bits.t` values structured according to enumeration interfaces, enabling tasks like priority encoding, multiplexing, and validation of one-hot representations. These capabilities are particularly useful for hardware synthesis scenarios requiring compact, efficient decoding of control signals or state representations.",
      "description_length": 510,
      "index": 29,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Pair.Wrap.All",
      "library": "hardcaml",
      "description": "Lifts monadic values within a pair structure, combining them into a single monadic result. Works with nested monad types where the inner monad is wrapped in a pair. Useful for handling pairs of computations that must be executed together, such as managing dual signal paths in hardware description workflows.",
      "description_length": 308,
      "index": 30,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Fifo.With_interface.I.Unsafe_assoc_by_port_name",
      "library": "hardcaml",
      "description": "This module provides direct, unsafe conversions between FIFO interface values and association lists indexed by port names. It supports extracting or constructing FIFO interfaces using string-labeled fields, enabling dynamic manipulation of FIFO port data. Use this when interfacing with external systems that require named field access or dynamically generating FIFO configurations from labeled data.",
      "description_length": 400,
      "index": 31,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.With_valid.Fields.Make.All",
      "library": "hardcaml",
      "description": "Combines interface values within a monadic context, lifting the monad outside the interface structure. Works with interfaces containing monadic values, transforming them into a single monadic interface. Useful for aggregating multiple signal-valid pairs into a unified monadic result.",
      "description_length": 284,
      "index": 32,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.With_valid.Wrap.Make.Of_signal",
      "library": "hardcaml",
      "description": "This module provides operations for constructing and manipulating hardware interfaces through signal composition, control logic, and state elements. It works with `Of_signal.t` and `Of_signal.comb t` types to represent structured signal interfaces and their combinational derivatives, enabling tasks like multiplexing, register creation, and hierarchical signal naming. Key use cases include building synchronous pipelines, implementing control flow with priority selects, and organizing complex signal hierarchies for clarity in hardware designs.",
      "description_length": 547,
      "index": 33,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Pair.Wrap.Of_always",
      "library": "hardcaml",
      "description": "This module provides functions to manipulate and assign values to hardware description interfaces within an `always` block. It supports operations like creating register and wire variables, assigning signals, and applying naming conventions to interface fields. Concrete use cases include building and connecting hardware components such as registers and wires with named signals in a structured interface.",
      "description_length": 406,
      "index": 34,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.With_valid.Vector.Of_bits",
      "library": "hardcaml",
      "description": "This module provides operations to construct, manipulate, and validate bit vector interfaces. It supports functions for packing/unpacking, multiplexing, concatenation, and selection operations with support for valid signals. Concrete use cases include building and verifying hardware interfaces with fixed-width bit fields, such as register banks or communication protocols.",
      "description_length": 374,
      "index": 35,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.With_valid.Vector.Of_always",
      "library": "hardcaml",
      "description": "This module provides functions to manipulate and assign values to hardware description interfaces using the Always API. It supports operations like creating register and wire variables, assigning signals, and applying naming conventions to interface fields. It works with interface structures composed of `Hardcaml.Always.Variable.t` and `Hardcaml.Signal.t`, enabling direct signal assignment and register instantiation within always blocks. Use cases include building and connecting hardware modules with named signals, initializing wires to specific values, and conditionally updating registers based on enable signals.",
      "description_length": 621,
      "index": 36,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Enum.Make_enums.Binary.Unsafe_assoc_by_port_name",
      "library": "hardcaml",
      "description": "This module provides direct, unsafe conversions between binary representations of enumeration types and association lists indexed by field names. It operates on `Binary.t` values and string-keyed lists, enabling low-level manipulation of enum interfaces without runtime safety checks. Use this for performance-critical enum serialization or when interfacing with external systems that require string-indexed field access.",
      "description_length": 421,
      "index": 37,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.With_valid.Vector.Of_signal",
      "library": "hardcaml",
      "description": "This module enables the creation and transformation of hardware interfaces through width-checked signal vector operations, including concatenation, packing, unpacking, and register instantiation, alongside utilities for connecting and hierarchically naming signals. It operates on combinational (`Of_signal.comb t`) and registered (`Of_signal.t`) signal types, supporting use cases such as pipelined data path construction, validated signal routing, and structured hierarchical design organization with named input/output ports.",
      "description_length": 528,
      "index": 38,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Enum.Make_enums.One_hot.Names_and_widths",
      "library": "hardcaml",
      "description": "This module generates enumerated type representations with one-hot encoding, providing access to port names, widths, and associated tags. It works with variant types representing enumeration cases, producing lists of string names and integer widths for each port. Use this to define hardware interfaces where each enum case maps to a one-hot signal with explicit port sizing.",
      "description_length": 375,
      "index": 39,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.With_valid.Fields.Make.Of_bits",
      "library": "hardcaml",
      "description": "This module provides operations to construct, manipulate, and validate bit-level interfaces with explicit field widths. It supports concrete operations such as packing and unpacking interfaces to and from bit vectors, multiplexing, concatenation, and selection via priority or one-hot encoding. Use cases include hardware description and simulation where structured signal interfaces must be converted to flat bit vectors or combined from multiple sources.",
      "description_length": 456,
      "index": 40,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Flags_vector.Make.Flags.Set",
      "library": "hardcaml",
      "description": "This module offers set operations for flag-based data structures, including creation from lists or hash-based collections, set difference computation, and deduplication through comparison or mapping. It primarily manipulates `Flags.Set.t` values, enabling conversion from maps, trees, or sequences, alongside serialization via S-expressions, binary encoding, and hashing. These capabilities support use cases like configuration management, persistent data storage, and property-based testing with Quickcheck generators.",
      "description_length": 519,
      "index": 41,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Pair.Wrap.Of_signal",
      "library": "hardcaml",
      "description": "This module provides operations for constructing and manipulating structured hardware interfaces composed of combinational signals, enabling tasks like signal routing (e.g., concatenation, multiplexing), register insertion, pipeline creation, and interface validation. It supports wiring named signal ports and hierarchical naming conventions through functions like `<==`, `inputs`, `outputs`, and `apply_names`, which facilitate precise signal composition and organization. These capabilities are used to build register-transfer level (RTL) designs with well-defined interface hierarchies and signal interconnections.",
      "description_length": 618,
      "index": 42,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.With_valid.Wrap.Make.Of_always",
      "library": "hardcaml",
      "description": "This module provides functions to construct and manipulate hardware description interfaces using the Always API. It supports operations like assigning signals to variables, creating registers and wires, and applying naming conventions to interface fields. Concrete use cases include defining synchronous logic blocks, instantiating register pipelines, and managing signal wiring in a structured interface.",
      "description_length": 405,
      "index": 43,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Fifo.With_interface.I.Names_and_widths",
      "library": "hardcaml",
      "description": "This module defines port names and widths for FIFO interfaces, providing direct access to signal identifiers and their bit-widths. It works with lists of strings and integers to represent port configurations. Use this to generate signal declarations or interface mappings in HDL code generation workflows.",
      "description_length": 305,
      "index": 44,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Flags_vector.Make.Flags.Replace_polymorphic_compare",
      "library": "hardcaml",
      "description": "This module defines comparison operators and functions for a type `t`, including equality checks, ordering relations, `min`, `max`, `equal`, and `compare`. It works directly with values of type `t`, enabling direct comparison and ordering operations. These functions are useful when implementing or extending types that require standard comparison logic, such as in sorting routines or conditional branching based on value relationships.",
      "description_length": 437,
      "index": 45,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Enum.Make_enums.One_hot.Unsafe",
      "library": "hardcaml",
      "description": "This module provides low-level, unsafe operations for working with one-hot encoded enumeration values represented as bit vectors. It includes functions for converting between enumerated values and their one-hot bit vector representations without runtime safety checks. Use cases include performance-critical hardware description code where direct bit-level manipulation is required and type safety is ensured by the developer.",
      "description_length": 426,
      "index": 46,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Async_fifo.Make.I.Of_always",
      "library": "hardcaml",
      "description": "This module provides functions to manipulate and assign values to hardware description interfaces using the Always API. It supports operations like creating register and wire variables, assigning signals, and applying naming conventions to interface fields. It works with interfaces containing `Always.Variable.t` values, enabling structured hardware design with named signals and registers. Use cases include building and connecting FIFOs, registers, and other synchronous logic blocks with clear signal hierarchies.",
      "description_length": 517,
      "index": 47,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Clocking.Make.Make_comb",
      "library": "hardcaml",
      "description": "This module provides operations for constructing and manipulating clocked hardware interfaces using a combinatorial logic representation. It supports data types involving packed vectors and structured interfaces with typed fields, enabling precise bit-width control and validation. Concrete use cases include building multiplexers, priority encoders, and concatenation logic for hardware description in digital circuit design.",
      "description_length": 426,
      "index": 48,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Async_fifo.Make.I.Of_bits",
      "library": "hardcaml",
      "description": "This module provides operations to manipulate and validate bit-level FIFO interfaces, including packing/unpacking signals into vectors, multiplexing, concatenation, and selection functions like priority or one-hot encoding. It works directly with `Hardcaml.Bits.t` values and structured FIFO interface types. Use cases include building and verifying FIFO control logic, routing data paths, and managing signal widths in hardware descriptions.",
      "description_length": 442,
      "index": 49,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Fifo.With_interface.O.Make_comb",
      "library": "hardcaml",
      "description": "This module provides combinational logic operations for constructing and manipulating FIFO interfaces, including packing/unpacking signals, multiplexing, concatenation, and selection functions. It works with interface types composed of combinational signals, supporting operations like constant assignment, width validation, and priority/one-hot selection. Concrete use cases include building custom FIFO control logic, routing data paths, and generating test stimuli with fixed signal values.",
      "description_length": 493,
      "index": 50,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Async_fifo.Make.O.All",
      "library": "hardcaml",
      "description": "Lifts monadic values within a nested structure, combining them into a single monad that contains the unwrapped values. Works with any monad `M` and data types structured as `O.t` containing `M.t` values. Useful for handling collections of asynchronous computations where results need to be collected and processed together.",
      "description_length": 323,
      "index": 51,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Clocking.Make.Unsafe_assoc_by_port_name",
      "library": "hardcaml",
      "description": "This module provides direct conversions between a structured interface and an association list indexed by field names. It supports data types that can be represented as key-value pairs, using strings as keys and arbitrary values. Concrete use cases include serializing and deserializing hardware interface signals for debugging or configuration purposes.",
      "description_length": 354,
      "index": 52,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.With_valid.Fields.Make.Of_always",
      "library": "hardcaml",
      "description": "This module provides functions to manipulate and assign signals within an always block for a structured interface. It supports creating registers and wires for each field, enabling direct integration with hardware description logic. Use cases include defining synchronous logic, such as state machines or data pipelines, where signal assignment and naming must align with interface definitions.",
      "description_length": 394,
      "index": 53,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.With_valid.Wrap.Make.Unsafe_assoc_by_port_name",
      "library": "hardcaml",
      "description": "This module provides unsafe functions to convert between a hardcaml interface and an association list indexed by field names. It works with values of type `'a t` and `(string * 'a) list`. Use when directly mapping interface fields to named entries in a list, such as dynamically constructing or inspecting interfaces from external data sources.",
      "description_length": 344,
      "index": 54,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Async_fifo.Make.I.Of_signal",
      "library": "hardcaml",
      "description": "This module provides utilities for constructing and transforming structured signal interfaces in hardware designs, with operations for binding signals, defining input/output ports, and managing bit-width-correct register pipelines. It works with structured signal interface types (`I.Of_signal.t`) to enable RTL-level manipulation, such as multiplexing, packing/unpacking, and applying hierarchical naming conventions. These capabilities are particularly useful for implementing asynchronous FIFOs with precise timing and signal integrity between clock domains.",
      "description_length": 561,
      "index": 55,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Fifo.With_interface.I.Of_bits",
      "library": "hardcaml",
      "description": "This module provides operations to construct and manipulate FIFO interfaces using bit vectors. It supports packing and unpacking interfaces to and from bit vectors, multiplexing between interfaces, concatenation, and priority/one-hot selection logic. Concrete use cases include implementing hardware FIFOs with fixed or dynamic data widths, and creating multiplexed data paths in digital circuits.",
      "description_length": 397,
      "index": 56,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Enum.Make_enums.One_hot.Of_always",
      "library": "hardcaml",
      "description": "This module provides functions to manipulate one-hot encoded signals within Hardcaml's Always blocks. It supports operations like assigning values, creating registers and wires, applying signal names, and performing case-based logic branching. It works directly with `Always.Variable.t One_hot.t` and `Signal.t One_hot.t`, enabling precise control over state machines and multiplexed logic paths in hardware descriptions.",
      "description_length": 421,
      "index": 57,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Flags_vector.Make.Flags.Map",
      "library": "hardcaml",
      "description": "This module provides operations for constructing and transforming maps with flag vectors as keys, supporting conversions from sequences, lists, and hash tables, along with error handling for duplicate keys. It includes serialization via S-expressions and binary I/O, hashing, and QuickCheck testing tools, enabling use cases like managing boolean configurations, persistent data storage, and automated test scenario generation.",
      "description_length": 427,
      "index": 58,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Pair.Wrap.Of_bits",
      "library": "hardcaml",
      "description": "This module provides functions to manipulate structured bit vector interfaces, supporting operations like packing/unpacking to and from flat vectors, multiplexing, concatenation, and selection. It works with types like `t` representing structured interfaces of bit vectors and `comb` for combinational logic signals. Concrete use cases include building register files, decoding instruction fields, and constructing finite state machines with structured signal routing.",
      "description_length": 468,
      "index": 59,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Async_fifo.Make.O.Of_always",
      "library": "hardcaml",
      "description": "This module provides functions to manipulate and assign values to hardware description interfaces using the Always API. It supports operations on `Signal.t` and `Always.Variable.t` types, enabling direct assignments, register creation, and wire initialization within synchronous logic blocks. Concrete use cases include building and naming signal interfaces for FIFOs, registers, and combinational logic in hardware designs.",
      "description_length": 424,
      "index": 60,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Enum.Make_enums.Binary.Of_signal",
      "library": "hardcaml",
      "description": "This module supports manipulating binary signals tied to enumeration types through operations like multiplexing, equality comparison, and conversion between raw signals and enum values. It works with `Binary.Of_signal.t` and `Hardcaml.Signal.t` types, enabling circuit construction where enums drive conditional logic or state transitions. Specific use cases include implementing state machines, command decoders, and hardware structures requiring compact enum-based signal representations with validation and composition capabilities.",
      "description_length": 535,
      "index": 61,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Enum.Make_enums.Binary.Of_always",
      "library": "hardcaml",
      "description": "This module provides functions to manipulate and assign binary signals within an always block, specifically handling interfaces composed of `Always.Variable.t Binary.t` types. It supports creating registers, wires, assigning values, applying names, and performing pattern matching on binary signals. Use cases include building and managing hardware state machines or control logic where binary signals represent enumerated states or commands.",
      "description_length": 442,
      "index": 62,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Flags_vector.Make.Flags.Unstable",
      "library": "hardcaml",
      "description": "This module implements serialization and comparison operations for a set of flag values, supporting binary and S-expression encoding/decoding. It works directly with the `Flags.Unstable.t` type, which represents a collection of named boolean flags. Concrete use cases include persisting flag configurations to disk, transmitting them over a network, or comparing flag states in testing and configuration management.",
      "description_length": 415,
      "index": 63,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Async_fifo.Make.O.Of_signal",
      "library": "hardcaml",
      "description": "This module provides operations for constructing and manipulating structured hardware signal interfaces, focusing on packing/unpacking, multiplexing, concatenation, and pipeline/register creation. It works with signal vectors and structured types like `O.Of_signal.comb O.t`, enabling precise control over field widths and signal behaviors. These utilities are particularly used to implement FIFOs with parameterizable depths up to `2 ^ LUT_SIZE`, ensuring glitch-free addressing logic in distributed RAM-based designs.",
      "description_length": 519,
      "index": 64,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Pair.Wrap.Names_and_widths",
      "library": "hardcaml",
      "description": "This module defines named values and widths for hardware ports, providing direct access to lists of port names, widths, and associated tags. It works with basic string and integer types, structured as lists, to represent hardware interface properties. Concrete use cases include specifying and accessing port metadata in hardware description and synthesis flows.",
      "description_length": 362,
      "index": 65,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Enum.Make_enums.One_hot.Unsafe_assoc_by_port_name",
      "library": "hardcaml",
      "description": "This module provides direct, unsafe conversions between one-hot encoded signals and association lists indexed by port names. It operates on one-hot encoded data structures, specifically `One_hot.t`, and string-value pairs. Use it to map field names to one-hot signal values or reconstruct one-hot signals from named associations, bypassing safety checks for performance.",
      "description_length": 370,
      "index": 66,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Clocking.Make.Cdc",
      "library": "hardcaml",
      "description": "This module provides functions for managing clock domain crossings in digital circuits. It includes operations to stretch pulses across multiple clock cycles, detect rising edges on valid signals from slower clocks, and pipeline signals with asynchronous register annotations. These functions work with `Signal.t` and `With_valid.t` types, specifically handling synchronization and metastability mitigation between different clock domains. Use cases include safely transferring control signals and data between clock domains in hardware designs.",
      "description_length": 545,
      "index": 67,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Fifo.With_interface.O.Unsafe_assoc_by_port_name",
      "library": "hardcaml",
      "description": "This module provides direct conversions between FIFO interface values and association lists indexed by field names, enabling programmatic access and manipulation of FIFO signals by their string identifiers. It operates on `O.t` interface types, which represent structured hardware signals, and supports use cases like dynamic signal routing or introspection during simulation. The `to_alist` and `of_alist` functions allow working with FIFO fields as named key-value pairs, bypassing type-safe accessors for flexibility in metaprogramming scenarios.",
      "description_length": 549,
      "index": 68,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Fifo.With_interface.O.Names_and_widths",
      "library": "hardcaml",
      "description": "This module defines the names and widths of ports for a FIFO interface, providing direct access to port metadata as lists of strings and integers. It works with synchronous FIFO implementations that require explicit port definitions, such as when generating HDL or connecting to hardware descriptions. Use cases include inspecting or generating signal names and widths for simulation, synthesis, or debugging purposes.",
      "description_length": 418,
      "index": 69,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Enum.Make_enums.One_hot.Of_signal",
      "library": "hardcaml",
      "description": "This module provides operations for constructing, transforming, and controlling one-hot encoded signal interfaces, including combinational logic (e.g., multiplexing, priority selection) and sequential elements (e.g., registers, pipelines). It operates on combinational (`comb`) and sequential (`t`) one-hot signal types, alongside utilities for enum value assignment, signal comparison, and hierarchical wiring. These capabilities are particularly useful for implementing control logic, state machines, or priority-encoded circuits where single-bit decoding and glitch-free transitions are critical.",
      "description_length": 599,
      "index": 70,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Fifo.With_interface.I.Make_comb",
      "library": "hardcaml",
      "description": "This module provides combinational logic operations for constructing and manipulating FIFO interfaces using a vector type. It supports packing and unpacking interfaces to and from vectors, multiplexing and concatenating interface values, and validation of signal widths. These operations are used to build flexible, interface-driven FIFO logic circuits with precise control over data flow and structure.",
      "description_length": 403,
      "index": 71,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Enum.Make_enums.Binary.Unsafe",
      "library": "hardcaml",
      "description": "This module provides low-level, unsafe operations for working with binary representations of enumeration types, including functions to convert between enumerated values and their binary encodings. It operates directly on enumerated types (variants with no arguments) and their corresponding binary representations as integers or bit vectors. Use cases include efficient serialization of enum values to hardware signals or memory, and direct manipulation of enum encodings in performance-critical sections.",
      "description_length": 505,
      "index": 72,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Enum.Make_enums.Binary.All",
      "library": "hardcaml",
      "description": "This module provides a function `all` that takes a binary interface of monadic values and returns a monadic value of a binary interface, effectively lifting the monad outside the interface. It operates specifically on binary interfaces and is useful for combining multiple monadic computations over binary signals into a single computation. A concrete use case includes aggregating several register reads or wire assignments within a hardware description into a unified monadic structure.",
      "description_length": 488,
      "index": 73,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Clocking.Make.Of_bits",
      "library": "hardcaml",
      "description": "This module provides functions to manipulate clocking interfaces represented as bit vectors, enabling operations like packing, unpacking, concatenation, and multiplexing. It supports data types involving bit-level representations and validates signal widths to ensure structural correctness. Concrete use cases include constructing and verifying hardware interfaces, implementing multiplexers, and handling signal routing in digital circuits.",
      "description_length": 442,
      "index": 74,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.With_valid.Wrap.Make.Of_bits",
      "library": "hardcaml",
      "description": "This module provides functions to construct and manipulate hardware interfaces using bit vectors. It supports operations like packing/unpacking interfaces to/from bit vectors, multiplexing, concatenation, and priority/one-hot selection. Concrete use cases include building register files, control logic, and data path circuits with precise bit-level control.",
      "description_length": 358,
      "index": 75,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Async_fifo.Make.O.Names_and_widths",
      "library": "hardcaml",
      "description": "This module defines port names and widths for an asynchronous FIFO, providing direct access to signal identifiers and their bit widths. It works with lists of strings and integers to represent port metadata, alongside a list of tags for additional signal annotations. Use this to inspect or generate interface descriptions for FIFO ports in hardware designs.",
      "description_length": 358,
      "index": 76,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Async_fifo.Make.O.Make_comb",
      "library": "hardcaml",
      "description": "This module provides combinational logic operations for constructing and manipulating FIFO interfaces with a focus on signal packing, unpacking, multiplexing, and selection. It works with bit vector types and structured interfaces composed of those vectors, enabling direct hardware modeling tasks like bus multiplexing, signal concatenation, and priority-encoded selection. Concrete use cases include building control logic for asynchronous FIFOs, routing data paths based on one-hot or priority-encoded signals, and validating signal widths during design elaboration.",
      "description_length": 569,
      "index": 77,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Bits.Mutable.Comb.Unsigned",
      "library": "hardcaml",
      "description": "This module provides operations for manipulating unsigned, mutable bit vectors, including arithmetic operations like addition, subtraction, and multiplication, as well as comparison operations that return bit vectors. It works with the `v` type, which represents unsigned vectors, and supports conversions to and from `Comb.t`. Concrete use cases include building and simulating digital circuits where unsigned arithmetic and comparisons are required, such as counters, arithmetic logic units (ALUs), and control logic.",
      "description_length": 519,
      "index": 78,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Fifo.With_interface.O.Of_bits",
      "library": "hardcaml",
      "description": "This module provides operations to construct and manipulate FIFO interfaces using bit vectors. It supports packing and unpacking interfaces into bit vectors, multiplexing and concatenating interfaces, and validating signal widths. Concrete use cases include implementing hardware FIFOs with precise bit-level control, connecting pipeline stages, and managing data routing in synchronous circuits.",
      "description_length": 396,
      "index": 79,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.With_valid.Vector.Unsafe_assoc_by_port_name",
      "library": "hardcaml",
      "description": "This module provides direct conversions between a structured interface and an association list indexed by field names. It operates on values of type `'a t` and pairs them with strings to form lists, enabling straightforward serialization and deserialization. Concrete use cases include debugging interfaces by inspecting field-value pairs or constructing test inputs from named components.",
      "description_length": 389,
      "index": 80,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Async_fifo.Make.O.Of_bits",
      "library": "hardcaml",
      "description": "This module provides operations to manipulate and transform bit-level FIFO interfaces, including packing/unpacking to vectors, multiplexing, concatenation, and selection functions like priority or one-hot encoding. It works with `O.Of_bits.comb O.t` types representing FIFO signals and supports concrete use cases such as building custom FIFO logic with dynamic selection, constant initialization, and width validation. Functions like `mux`, `concat`, and `priority_select` enable constructing complex signal routing directly in hardware description.",
      "description_length": 550,
      "index": 81,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Bits.Mutable.Comb.Sop",
      "library": "hardcaml",
      "description": "This module provides arithmetic and comparison operations for mutable bit vectors, including addition, subtraction, multiplication, and comparisons like less than or equal. It works directly with `Comb.t` values, which represent combinational logic signals in a hardware description. These operations are used to build digital circuits where bit-width safety and signed interpretation are required, such as ALUs or control logic in a simulator.",
      "description_length": 444,
      "index": 82,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Clocking.Make.Names_and_widths",
      "library": "hardcaml",
      "description": "This module defines clocking-related port names, widths, and tags for hardware description in Hardcaml. It provides direct access to signal names, their bit widths, and associated metadata tags as separate lists. This supports generating and manipulating clocked hardware components with precise signal definitions.",
      "description_length": 315,
      "index": 83,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Enum.Make_enums.One_hot.Make_comb",
      "library": "hardcaml",
      "description": "This module provides operations for converting between integers and one-hot encoded representations, selecting active signals in combinational logic, and safely handling validity flags with optional default cases. It works with packed bit vectors (`comb`) and one-hot tagged types (`t`), enabling synthesis of control logic that requires dense encoding or prioritized signal activation. Typical applications include state machine decoding, multipath data selection, and hardware interfaces where sparse one-hot signaling improves timing or area efficiency.",
      "description_length": 556,
      "index": 84,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Fifo.With_interface.I.Of_signal",
      "library": "hardcaml",
      "description": "This module provides operations for constructing and manipulating structured signal interfaces composed of `Signal.t` fields, including packing/unpacking to vectors, multiplexing, concatenation, and pipeline registration. It facilitates connecting interfaces via assignment (`<==`), generating input/output signal wires, and applying naming conventions for hierarchical organization. These capabilities are used to build and validate hardware FIFOs with pipelined stages, manage signal routing between modules, and maintain clear signal hierarchies in complex designs.",
      "description_length": 568,
      "index": 85,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Fifo.With_interface.I.Of_always",
      "library": "hardcaml",
      "description": "This module provides functions to manipulate and assign values to interfaces using the Always API in synchronous FIFO designs. It supports operations like creating register and wire variables, assigning signals, and applying naming conventions to interface fields. These functions are used to build and manage FIFO interfaces with concrete signal behaviors in a hardware description context.",
      "description_length": 391,
      "index": 86,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Rtl.Ast.Signals_name_map.Uid_with_index",
      "library": "hardcaml",
      "description": "This module defines a type `t` as a tuple of a signal UID and an integer index, used to uniquely identify and compare signal instances in RTL name mapping. It provides comparison and S-expression conversion functions for use in data structures requiring ordering or serialization. This supports name mangling in Hardcaml's Verilator integration by distinguishing signals with the same UID but different indices.",
      "description_length": 411,
      "index": 87,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Async_fifo.Make.O.Unsafe_assoc_by_port_name",
      "library": "hardcaml",
      "description": "This module directly maps input and output fields of a FIFO interface to an association list, using field names as keys. It operates on FIFO interfaces and association lists, enabling direct conversion between them. Use this to dynamically construct or inspect FIFO interfaces from named field-value pairs, such as when integrating with configuration systems or debugging signal values.",
      "description_length": 386,
      "index": 88,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Types.With_valid.Fields.Make",
      "library": "hardcaml",
      "description": "This module provides operations for manipulating structured hardware interfaces with per-field validity, including mapping, zipping, folding, and conversions between association lists, bit vectors, and signals. It operates on parameterized records to support combinational logic, register control, and port metadata extraction for RTL synthesis. Typical applications include creating validated hardware descriptions with named ports, managing monadic signal assignments, and ensuring correctness through tag-based indexing and structural introspection during FPGA/ASIC design flows.",
      "description_length": 582,
      "index": 89,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.With_valid.Wrap.Make.Names_and_widths",
      "library": "hardcaml",
      "description": "This module generates port names and widths for a Hardcaml interface, producing a list of string-integer pairs representing each port's name and bit width. It works with basic list and integer types to define hardware signal interfaces. Use this module to automatically derive structured port definitions for hardware components based on their type specifications.",
      "description_length": 364,
      "index": 90,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Enum.Make_enums.Binary.Make_comb",
      "library": "hardcaml",
      "description": "This module provides functions to encode integers into binary-encoded enumeration values, manipulate bit-level representations via packing/unpacking, and perform comparisons or multiplexing operations on combinational logic signals. It operates on binary-encoded enum types (`t`) and their bit-vector counterparts (`Binary.outer`), facilitating tasks like decoding signal branches, converting raw hardware signals to structured enums, and implementing digital circuits where enumeration states are compactly represented in binary form.",
      "description_length": 535,
      "index": 91,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Bits.Mutable.Comb.Signed",
      "library": "hardcaml",
      "description": "This module provides operations for working with signed, mutable bit vectors, including arithmetic operations like addition, subtraction, and multiplication, which return results with extended widths to prevent truncation. It supports comparison operations between vectors of differing widths and allows resizing vectors to specified widths with appropriate sign extension. These capabilities are useful for implementing digital circuits that require signed arithmetic and dynamic bit-width manipulations, such as ALUs or data path components in a simulator.",
      "description_length": 558,
      "index": 92,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.With_valid.Vector.All",
      "library": "hardcaml",
      "description": "Lifts monadic values within a vector to a monadic vector of values. Works with polymorphic vectors containing monadic elements. Useful for hardware description workflows where signal validity and computation sequencing must be preserved across vectorized operations.",
      "description_length": 266,
      "index": 93,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Fifo.With_interface.O.Of_signal",
      "library": "hardcaml",
      "description": "This module provides operations for constructing and manipulating signal-based FIFO interfaces, including packing/unpacking, multiplexing, concatenation, and inserting pipeline registers, along with wiring and naming utilities for hierarchical signal management. It works with FIFO interfaces composed of `Hardcaml.Signal.t` values, enabling precise control over synchronous data flow and structural hierarchy. These features are particularly useful for implementing pipelined FIFOs with named signal boundaries in hardware designs, such as connecting modular components with register-staged communication channels.",
      "description_length": 615,
      "index": 94,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Pair.Wrap.Unsafe_assoc_by_port_name",
      "library": "hardcaml",
      "description": "This module provides direct conversions between a structured interface and an association list indexed by field names. It supports data types that can be represented as key-value pairs, using strings as keys. Concrete use cases include debugging interface values or dynamically constructing interfaces from named signal lists.",
      "description_length": 326,
      "index": 95,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Async_fifo.Make.I.Make_comb",
      "library": "hardcaml",
      "description": "This module provides combinational logic operations for manipulating an interface with bit vector fields. It supports packing/unpacking interfaces to vectors, multiplexing, concatenation, and selection operations like priority and onehot selects. These operations are used to build and validate control logic for asynchronous FIFOs with fixed-width signals.",
      "description_length": 357,
      "index": 96,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Types.Clocking.Make.Of_always",
      "library": "hardcaml",
      "description": "This module provides functions to manipulate and assign values to hardware description interfaces within always blocks. It supports operations like creating register and wire variables, assigning signals, and applying naming conventions to interface fields. Concrete use cases include building clocked logic circuits by defining register state transitions and wiring signals with named interfaces.",
      "description_length": 397,
      "index": 97,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Types.Clocking.Make.Of_signal",
      "library": "hardcaml",
      "description": "This module provides functions for constructing and transforming structured signal interfaces in hardware designs. It supports operations like constant assignment, signal wiring, register and pipeline creation, multiplexing, and packing/unpacking on combinational and sequential signal types (`Of_signal.comb t` and `Of_signal.t`), primarily used for implementing registers, pipelines, and multiplexers in digital circuits.",
      "description_length": 423,
      "index": 98,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.With_valid.Fields.Make.Make_comb",
      "library": "hardcaml",
      "description": "This module implements combinational logic operations for structured interfaces with valid signals. It supports packing/unpacking interfaces to vectors, multiplexing and concatenation of interface lists, and selection operations like priority and onehot with optional branching factors. Concrete use cases include building complex control logic, data routing circuits, and fixed-width signal manipulations in hardware designs.",
      "description_length": 426,
      "index": 99,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Fifo.With_interface.O.All",
      "library": "hardcaml",
      "description": "This module provides the `all` function, which lifts monadic values within an interface to the outer monad, effectively combining them. It operates on interfaces containing monadic values, specifically transforming `'a M.t O.t` into `'a O.t M.t`. Use this to sequence multiple monadic operations across an interface, such as collecting results from multiple FIFO reads into a single monadic structure.",
      "description_length": 401,
      "index": 100,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.With_valid.Wrap.M",
      "library": "hardcaml",
      "description": "This module defines a type `'a t` representing a hardware interface with validity, combining a value of type `'a` and a validity signal derived from `'a X.t`. It provides operations to construct, destructure, and manipulate these interfaces, such as `create`, `value`, and `valid`. Use this module to model handshaked data transfers in hardware designs, where each data signal is paired with a validity indicator.",
      "description_length": 413,
      "index": 101,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Fifo.With_interface.O.Of_always",
      "library": "hardcaml",
      "description": "This module provides functions to manipulate interface-based FIFOs using the Always API, enabling direct assignment, registration, and naming of interface fields. It works with `Always.Variable.t` and `Signal.t` types, structured within an interface (`O.t`). Concrete use cases include creating register or wire interfaces for FIFOs, assigning signals in always blocks, and applying naming conventions to FIFO interface fields.",
      "description_length": 427,
      "index": 102,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.With_valid.Fields.Make.Names_and_widths",
      "library": "hardcaml",
      "description": "This module generates port names and widths for a Hardcaml interface, providing direct access to lists of port names, port widths, and associated tags. It operates on a structured type that combines signal values with validity, producing concrete signal definitions for hardware description. Use this to define interface signals in a Hardcaml design, mapping abstract type definitions to physical port representations.",
      "description_length": 418,
      "index": 103,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.With_valid.Fields.M",
      "library": "hardcaml",
      "description": "This module defines operations for working with a structured interface where each field has an associated validity signal. It provides functions to create, access, and manipulate fields of type `'a With_valid.t` within a container defined by module `X`. Concrete use cases include building and decomposing hardware interfaces with valid-ready signaling, such as AXI streams or custom handshake protocols.",
      "description_length": 404,
      "index": 104,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Async_fifo.Make.I.Names_and_widths",
      "library": "hardcaml",
      "description": "This module defines port names and widths for an asynchronous FIFO, providing direct access to signal identifiers and their bit widths. It works with lists of strings and integers to represent port metadata. Concrete use cases include generating signal declarations or configuring FIFO interfaces in hardware descriptions.",
      "description_length": 322,
      "index": 105,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Types.With_valid.Vector.Make_comb",
      "library": "hardcaml",
      "description": "This module provides operations for manipulating vector-like hardware interfaces with combinational logic. It supports concrete tasks such as packing/unpacking signals into vectors, multiplexing between interface lists, concatenation, and selecting based on one-hot or priority-encoded inputs. The module works directly with signal vectors and valid-qualified signal pairs, enabling precise control over bit widths and signal routing in hardware descriptions.",
      "description_length": 459,
      "index": 106,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Pair.Wrap.Make_comb",
      "library": "hardcaml",
      "description": "This module implements combinational logic operations for wrapping and unwrapping signal interfaces, including packing/unpacking to and from vectors, multiplexing, concatenation, and selection operations. It works with signal interfaces composed of fields of type `comb`, where each field has a defined bit width. Concrete use cases include constructing complex signal routing logic, validating signal widths during interface conversion, and implementing priority or one-hot encoded multiplexers for hardware description.",
      "description_length": 521,
      "index": 107,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.With_valid.Wrap.Make.Make_comb",
      "library": "hardcaml",
      "description": "This module implements combinational logic operations for wrapping and manipulating hardware interfaces with valid signals. It provides functions like `pack`, `unpack`, `mux`, and `concat` to transform interfaces, along with validation and width-checking utilities. Use cases include building multiplexers, concatenating signal groups, and converting between structured interfaces and flat bit vectors.",
      "description_length": 402,
      "index": 108,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Bits.Mutable.Comb.Uop",
      "library": "hardcaml",
      "description": "This module performs arithmetic and comparison operations on mutable bit vectors, including addition, subtraction, multiplication, and comparisons like less than or equal. It works directly with `Hardcaml.Bits.Mutable.Comb.t`, supporting operations between vectors of different widths and producing appropriately resized results. Concrete use cases include implementing combinational logic circuits where mutable bit vectors are used to model hardware signals in simulation.",
      "description_length": 474,
      "index": 109,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.With_valid.Wrap.Make.All",
      "library": "hardcaml",
      "description": "This module provides the `all` function, which lifts a monadic structure from within an interface to the outer layer, transforming a nested interface of type `'a M.t t` into `'a t M.t`. It operates on interfaces that include a monad `M`, enabling sequential composition of computations across the interface. A typical use case involves combining multiple signal pipelines in hardware description, where each pipeline stage is wrapped in a monad like `Result` or `Option`.",
      "description_length": 471,
      "index": 110,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Types.Clocking.Make.Var",
      "library": "hardcaml",
      "description": "Implements clocked register logic with optional enable and reset behavior for signal processing. Works with `Signal.t` and `Always.Variable.t` types to manage state in hardware descriptions. Useful for creating synchronous storage elements like counters or state machines with controlled update conditions.",
      "description_length": 306,
      "index": 111,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.With_valid.Wrap.Make",
      "library": "hardcaml",
      "description": "This module enables structured manipulation of hardware interfaces with validity signals through mapping, zipping, and conversion between bit vectors and signals. It operates on record-like interface types with named ports and validity tags, supporting combinational logic, signal routing, register assignment in always blocks, and interface validation via port metadata extraction and equality checks. Key applications include synchronous circuit design tasks like stateful transformations, bit vector packing, and structured port definitions for digital systems.",
      "description_length": 564,
      "index": 112,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.With_valid.Vector.Names_and_widths",
      "library": "hardcaml",
      "description": "This module defines lists of port names and their corresponding widths, along with a list of tags, all used to describe the interface of a hardware module in Hardcaml. It provides direct access to these lists through simple value bindings, enabling clear and structured signal naming and sizing in hardware descriptions. Concrete use cases include specifying input and output ports for hardware components, ensuring consistency between signal names and their bit widths in generated HDL code.",
      "description_length": 492,
      "index": 113,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Fifo.With_interface.I.All",
      "library": "hardcaml",
      "description": "This module provides the `all` function, which lifts monadic values within an interface to the outer monad, effectively combining them into a single monadic interface value. It operates on data types involving interfaces (`I.t`) and a monad `M`, transforming a structure of type `'a M.t I.t` into `'a I.t M.t`. A concrete use case is aggregating multiple signal values within a hardware description into a single interface-wrapped monad, enabling sequential composition of hardware modules.",
      "description_length": 490,
      "index": 114,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Enum.Make_enums.Binary.Names_and_widths",
      "library": "hardcaml",
      "description": "This module defines operations to create enumerations with binary encoding, specifying port names and their bit widths. It works with lists of string-integer pairs to represent signal names and widths, alongside binary-encoded tags for enumeration values. It is used to generate hardware interfaces where each enumeration variant maps to a unique binary code with explicit signal dimensions.",
      "description_length": 391,
      "index": 115,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Enum.Make_enums.Binary.Of_bits",
      "library": "hardcaml",
      "description": "This module provides utilities for manipulating binary-encoded enumeration types through operations like packing/unpacking, multiplexing, concatenation, and field width validation, alongside bitwise pattern matching with optional default cases. It operates on `Hardcaml.Bits.t` values and structured combinational interfaces, using `Cases.t` patterns to drive conditional logic based on bitvector inputs. Typical applications include designing hardware components such as instruction decoders, state transition controllers, and multiplexed data paths where enumeration values are binary-represented.",
      "description_length": 599,
      "index": 116,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Async_fifo.Make.I.Unsafe_assoc_by_port_name",
      "library": "hardcaml",
      "description": "This module provides `to_alist` and `of_alist` functions for converting between record-like interface values and association lists indexed by field names. It operates on data structures of type `'a I.t`, typically representing hardware interfaces with named ports. These functions enable dynamic access and manipulation of interface fields by string keys, useful for tasks like configuration mapping or runtime introspection of signal values.",
      "description_length": 442,
      "index": 117,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Clocking.Var",
      "library": "hardcaml",
      "description": "Implements clocked register logic with optional enable and reset behavior. Works with clocking specifications and variable-width signals to model sequential circuits. Use to define state elements in synchronous hardware descriptions where precise control over clock edges and resets is required.",
      "description_length": 295,
      "index": 118,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Bits_list.Int_comb.Signed",
      "library": "hardcaml",
      "description": "This module provides operations for working with signed integer vectors represented as lists of bits. It supports arithmetic operations like addition, subtraction, and multiplication, with automatic sign extension and widening to prevent truncation. Comparison operators and resizing functionality enable precise manipulation and relational checks on signed bit vectors of varying widths.",
      "description_length": 388,
      "index": 119,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Bits_list.Bool_comb.Signed",
      "library": "hardcaml",
      "description": "This module provides operations for working with signed fixed-width bit vectors represented as lists of boolean values. It supports arithmetic operations like addition, subtraction, and multiplication, along with comparison operators for inequality and equality checks. These functions are used to construct combinational logic circuits for signed integer arithmetic and comparisons, with automatic sign extension handled during operations.",
      "description_length": 440,
      "index": 120,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Interface.Empty.Unsafe_assoc_by_port_name",
      "library": "hardcaml",
      "description": "This module directly associates interface fields with values by port name using unsafe operations. It works with empty interfaces and string-indexed value lists, enabling direct signal mapping without runtime checks. Use it to quickly construct or deconstruct interfaces when port names are known and correctness is ensured externally.",
      "description_length": 335,
      "index": 121,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Interface.Make.Names_and_widths",
      "library": "hardcaml",
      "description": "This module generates named signal groups with specified widths, providing access to their field names, widths, and combined tag lists. It operates on lists of string-integer pairs representing port names and widths, producing structured signal interfaces. Use it to define hardware module ports with explicit naming and bit-widths for simulation or synthesis.",
      "description_length": 360,
      "index": 122,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Rtl.Signals_name_map.Uid_with_index",
      "library": "hardcaml",
      "description": "This module represents a pair of a signal UID and an integer index, used to uniquely identify and compare signals in RTL name mapping. It supports comparison and serialization operations, enabling efficient key handling in maps. It is used in signal mangling during Verilog generation to ensure unique naming across signal instances.",
      "description_length": 333,
      "index": 123,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.List.Make_comb",
      "library": "hardcaml",
      "description": "This module implements combinational logic operations for manipulating hardware signal interfaces. It supports operations like packing/unpacking interfaces to/from bit vectors, multiplexing, concatenation, and priority/one-hot selection, working with lists of combinational signals. Concrete uses include building register file outputs, decoding control signals, and constructing complex mux trees with validated bit-widths.",
      "description_length": 424,
      "index": 124,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Enum.Make_binary.Of_always",
      "library": "hardcaml",
      "description": "This module provides functions to manipulate and assign values to hardware interfaces using the Always API, specifically for binary-represented enumeration types. It supports creating registers, wires, and named variables, and performing pattern matching on signals. Use cases include building state machines, decoding signal values, and managing hardware state transitions within always blocks.",
      "description_length": 395,
      "index": 125,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Flags_vector.Make.Names_and_widths",
      "library": "hardcaml",
      "description": "This module defines port names, widths, and associated tags for hardware description in Hardcaml. It provides direct access to lists of port names, widths, and precomputed tags derived from those ports. It is used to construct and manipulate hardware components with named, typed ports in a vectorized format.",
      "description_length": 309,
      "index": 126,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Interface.Empty.Of_always",
      "library": "hardcaml",
      "description": "This module provides functions to create and manipulate interface containers with register and wire variables in the Always API. It supports operations like assigning signals, extracting values, and applying names with optional prefixes or suffixes. Concrete use cases include building hardware descriptions with named signal groups and managing default signal values in synchronous logic blocks.",
      "description_length": 396,
      "index": 127,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Types.Array.Names_and_widths",
      "library": "hardcaml",
      "description": "This module defines lists of port names paired with their bit widths, individual lists of port names and widths, and a list of tags. It provides direct access to these predefined collections for use in hardware description contexts. These values are used to specify interface properties in circuit design, such as signal names and their sizes.",
      "description_length": 343,
      "index": 128,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.List.All",
      "library": "hardcaml",
      "description": "This module provides a single function `all` that takes a list of monadic values and returns a monadic list of values, effectively flipping the structure of a list of monadic elements into a monad containing a list of elements. It operates on lists where each element is wrapped in a monad, lifting the monadic effects outside the list structure. A concrete use case is combining a list of computations that each produce a value within a context, such as accumulating results from a sequence of I/O operations or handling optional values in a list.",
      "description_length": 548,
      "index": 129,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Interface.Make.All",
      "library": "hardcaml",
      "description": "Lifts monadic values through an interface structure, combining monads within each field of the interface. Works with any monadic type `M` and interface `X` containing signals. Useful for collecting results from multiple concurrent computations into a structured interface format.",
      "description_length": 279,
      "index": 130,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Comb.Make.Sop",
      "library": "hardcaml",
      "description": "This module implements arithmetic and comparison operations for signed bit vectors, including addition, subtraction, multiplication, and comparisons like less than or equal, supporting varying input widths. It provides functions to convert between vector and signal types, and resizes values with appropriate sign extension. Concrete use cases include implementing arithmetic logic units (ALUs) and comparison-based control logic in hardware designs.",
      "description_length": 450,
      "index": 131,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Bits_list.Make.Sop",
      "library": "hardcaml",
      "description": "This module implements arithmetic and comparison operations for fixed-width bit vectors, supporting addition, subtraction, multiplication, and comparisons between vectors of differing widths. It provides functions to convert between bit vectors and combinational logic signals, and includes resizing to adjust vector widths with appropriate sign or zero extension. Concrete use cases include implementing arithmetic logic units (ALUs) and comparison-based control logic in hardware descriptions.",
      "description_length": 495,
      "index": 132,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Value.Make_comb",
      "library": "hardcaml",
      "description": "This module implements combinational logic operations for manipulating structured hardware interfaces. It supports operations like packing/unpacking interfaces to/from bit vectors, multiplexing, concatenation, and priority/one-hot selection, all working with a base combinational logic type. Concrete use cases include building complex signal routing structures, decoding control signals, and managing bus interfaces in hardware designs.",
      "description_length": 437,
      "index": 133,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.With_valid.Fields.Make",
      "library": "hardcaml",
      "description": "This module supports mapping, zipping, and converting interface fields with valid signals, handling tuples of signals up to five elements through combination, transformation, and folding operations. It operates on structured interfaces represented as `'a With_valid.t X.t` values and facilitates conversions to bit vectors, port definitions, and signal extractions. These capabilities are used in hardware design workflows for combinational logic synthesis, signal packing, register management, and interface-to-port mapping during simulation and implementation.",
      "description_length": 562,
      "index": 134,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Interface.Empty.All",
      "library": "hardcaml",
      "description": "This module provides the `all` function, which lifts monadic values within an empty interface to the outside, effectively combining them into a single monadic interface. It operates specifically on empty interfaces with monadic values, transforming `'a M.t Hardcaml.Interface.Empty.t` into `'a Hardcaml.Interface.Empty.t M.t`. A typical use case involves aggregating multiple monadic signal computations into a unified interface structure for hardware description.",
      "description_length": 464,
      "index": 135,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.With_valid.Vector.Make_comb",
      "library": "hardcaml",
      "description": "This module provides operations for manipulating structured hardware interfaces with combinational logic, including packing/unpacking to vectors, multiplexing, concatenation, and priority/one-hot selection. It works with signal interfaces composed of fields of fixed bit widths, ensuring correctness through validation and width assertions. Concrete use cases include building register files, control logic, and data path multiplexers where structured signal manipulation is required.",
      "description_length": 484,
      "index": 136,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Rtl.Deprecated.Vhdl",
      "library": "hardcaml",
      "description": "Generates VHDL code from a Hardcaml circuit, writing to a file or returning as a string based on the boolean flag. It operates on a circuit description and an I/O specification to produce signals and name mappings required for the VHDL output. Useful for hardware synthesis and simulation workflows where VHDL output is needed for FPGAs or ASICs.",
      "description_length": 346,
      "index": 137,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Enum.Make_enums.Binary",
      "library": "hardcaml",
      "description": "This module provides utilities for transforming and manipulating binary-encoded enumeration interfaces through structured traversal, conversion between bit vectors and enum representations, and combinational logic construction. It operates on hardware signals (`Binary.t`) and supports use cases like state machine synthesis, simulation input/output handling, and low-level bit-level manipulations with both safe and unsafe operations. Key functionalities include mapping over enum variants, folding across multiple interfaces, and simulating enum signal behavior via pattern matching or direct bit-level access.",
      "description_length": 612,
      "index": 138,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Cross_product.Names_and_widths",
      "library": "hardcaml",
      "description": "This module defines lists of port names paired with their bit widths, along with separate lists of just names and widths. It provides direct access to these lists and a list of associated tags. Concrete use cases include describing hardware interface signals and their properties for simulation or synthesis tasks.",
      "description_length": 314,
      "index": 139,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Interface.Empty.Of_signal",
      "library": "hardcaml",
      "description": "This module provides functions for connecting and transforming groups of hardware signals with fixed widths, including assignment (`<==`), concatenation, multiplexing, and register pipelining. It operates on structured signal interfaces (`Hardcaml.Interface.Empty.Of_signal.t`) that define named signal groups with explicit bit-widths, enabling tasks like component interconnection, hierarchical bus creation, or register bank generation. The operations support both combinational logic and sequential circuit design through register insertion and name-scoped signal manipulation.",
      "description_length": 580,
      "index": 140,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Logic.Four_state_vector.Unsigned",
      "library": "hardcaml",
      "description": "This module implements arithmetic and comparison operations for unsigned four-state logic vectors, including addition, subtraction, multiplication, and comparisons like less than or equal. It works directly with the `v` type representing unsigned vectors, supporting operations between vectors of different widths and handling sign extension automatically. These functions are used to model digital circuit behavior where unsigned binary values are manipulated, such as in arithmetic logic units or data path components.",
      "description_length": 520,
      "index": 141,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Flags_vector.Make.Make_comb",
      "library": "hardcaml",
      "description": "This module provides operations for manipulating bitvector interfaces using combinational logic, including packing/unpacking, multiplexing, concatenation, and selection functions. It works with typed bitvector interfaces (`comb t`) where each field has a defined width. Concrete use cases include constructing and validating hardware signal interfaces, selecting between multiple input interfaces based on control signals, and assembling or disassembling complex signal structures into flat bitvectors.",
      "description_length": 502,
      "index": 142,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Vcd.Scope.Type",
      "library": "hardcaml",
      "description": "This module defines the hierarchical scope types used in VCD generation, including `Begin`, `Fork`, `Function`, `Module`, and `Task`. It provides conversions to S-expressions and strings for these scope types. These types are used to structure signal hierarchies in VCD files, enabling accurate representation of hardware simulation contexts.",
      "description_length": 342,
      "index": 143,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Interface.Update.Make_comb",
      "library": "hardcaml",
      "description": "This module combines and manipulates hardware interfaces using combinational logic operations. It supports operations like packing/unpacking interfaces to/from bit vectors, multiplexing, concatenation, and priority/one-hot selection. It works with fixed-width signal groups defined by an interface, enabling tasks like bus routing, signal selection, and constant initialization in hardware designs.",
      "description_length": 398,
      "index": 144,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Enum.Make_binary.Of_signal",
      "library": "hardcaml",
      "description": "This module enables the representation of enumeration types as binary signals for hardware design, providing operations to pack, unpack, compare, and multiplex enum values within a signal-based composition framework. It works with enumeration types and binary-encoded signals (`Of_signal.t`, `Signal.t`), supporting use cases like control logic synthesis, state machine encoding, and register pipeline generation in digital circuit design. Key functionality includes enum-to-signal conversion, bitwise manipulation, and validation through combinational and sequential signal wiring patterns.",
      "description_length": 591,
      "index": 145,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Flags_vector.Make.Unsafe_assoc_by_port_name",
      "library": "hardcaml",
      "description": "This module provides direct conversions between a structured interface and an association list indexed by field names. It operates on any interface type `'a t` that has named fields, using strings as keys. These functions are used to serialize or deserialize field-value pairs, enabling straightforward debugging or dynamic configuration of interfaces.",
      "description_length": 352,
      "index": 146,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Types.Cross_product.Make_comb",
      "library": "hardcaml",
      "description": "This module implements combinational logic operations for structured signal interfaces, supporting constant assignment, packing/unpacking, multiplexing, and selection operations. It works with signal interfaces composed of multiple fields of fixed bit widths, using a provided combinational logic type. Concrete uses include building register file outputs, decoding control signals, and constructing complex mux trees from structured data.",
      "description_length": 439,
      "index": 147,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Interface.Update.Of_bits",
      "library": "hardcaml",
      "description": "This module provides functions to construct, manipulate, and validate bit-level interfaces with concrete signal widths. It supports operations like packing/unpacking interfaces to/from bit vectors, multiplexing, concatenation, and selection from one-hot or priority-encoded inputs. Use cases include building register files, memory interfaces, and control logic where precise bit-level manipulation and interface transformation are required.",
      "description_length": 441,
      "index": 148,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Comb.Make.Signed",
      "library": "hardcaml",
      "description": "This module provides operations for working with signed two's complement vectors, including arithmetic operations like addition, subtraction, and multiplication, where operands are automatically extended and results are widened to prevent truncation. It supports comparison operations such as less than, greater than, and equality, which handle operands of differing widths. Use cases include implementing arithmetic logic units (ALUs) and performing bit-accurate signed computations in hardware descriptions.",
      "description_length": 509,
      "index": 149,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.With_valid.Fields.M",
      "library": "hardcaml",
      "description": "This module defines operations for constructing and manipulating hardware description language (HDL) interfaces with validity signals. It provides functions to create, project, and combine structured fields of signals paired with a valid bit, enabling precise control over dataflow and synchronization in digital circuits. Use it to model complex hardware pipelines where data validity must be explicitly tracked alongside data signals.",
      "description_length": 436,
      "index": 150,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Enum.Make_one_hot.Make_comb",
      "library": "hardcaml",
      "description": "This module provides combinational logic operations for manipulating one-hot encoded enumeration types, including conversion between integer representations, multiplexing with priority or one-hot selection, and validation of encoded signals. It operates on `comb` and `comb outer` types, which represent raw and wrapped combinational logic values, respectively. These utilities are particularly useful for implementing state machines, control logic, and hardware interfaces where one-hot encoding ensures efficient signal decoding and avoids ambiguity in multi-bit transitions.",
      "description_length": 577,
      "index": 151,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Rtl_attribute.Vivado.Srl_style",
      "library": "hardcaml",
      "description": "This module defines specific SRL (Shift Register LUT) configuration attributes for Xilinx Vivado synthesis. It provides predefined values to control how SRLs are implemented in the design, such as using registers, SRL primitives, or block RAM. These attributes guide the synthesis tool to optimize area or timing based on the target FPGA architecture.",
      "description_length": 351,
      "index": 152,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Bits_list.X_comb.Unsigned",
      "library": "hardcaml",
      "description": "This module provides arithmetic and comparison operations for unsigned binary vectors represented as lists of `F, T, X` bits. It supports addition, subtraction, multiplication, and comparisons like less than or equal, directly on vector values, automatically handling width differences via extension. Concrete use cases include implementing combinational logic circuits such as arithmetic units or comparison blocks in hardware descriptions.",
      "description_length": 441,
      "index": 153,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Bits_list.Bool_comb.Uop",
      "library": "hardcaml",
      "description": "This module implements arithmetic and comparison operations for lists of boolean values representing unsigned binary vectors. It supports addition, subtraction, multiplication, and comparisons like less than or equal, with automatic bit-width extension to preserve precision. These operations are used to model combinational logic circuits where bit lists represent data paths, such as in ALUs or control logic blocks.",
      "description_length": 418,
      "index": 154,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Enum.Make_one_hot.Unsafe",
      "library": "hardcaml",
      "description": "This module provides low-level, unchecked conversion functions between enumeration values and their one-hot encoded bitvector representations. It works directly with variant types that represent enumerations and their corresponding one-hot encoded values. Use this module when implementing custom serialization or hardware-level interfaces where one-hot encoding is required and safety checks are unnecessary.",
      "description_length": 409,
      "index": 155,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Array.Make_comb",
      "library": "hardcaml",
      "description": "This module implements operations for manipulating arrays of combinational logic signals, supporting tasks like packing/unpacking interfaces into vectors, multiplexing, concatenation, and priority/one-hot selection. It works with types `comb` and `t`, where `comb` represents combinational signals and `t` is an array of such signals. Concrete use cases include building multiplexers, validating signal widths, and constructing complex signal routing logic from simpler components.",
      "description_length": 481,
      "index": 156,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Array.Of_bits",
      "library": "hardcaml",
      "description": "This module provides functions to manipulate arrays of bit vectors, enabling operations like packing, unpacking, concatenation, and multiplexing. It works with fixed-width bit vectors and structured interfaces composed of multiple bit fields. Concrete use cases include hardware signal routing, bus multiplexing, and bit-level data serialization/deserialization.",
      "description_length": 362,
      "index": 157,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Flags_vector.Make.Unsafe",
      "library": "hardcaml",
      "description": "Wraps a value into a vector type without runtime checks. Works directly with bit vectors and custom data types. Useful for low-level hardware descriptions where type safety is managed manually.",
      "description_length": 193,
      "index": 158,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Types.Scalar.Of_signal",
      "library": "hardcaml",
      "description": "This module provides structured signal manipulation operations like packing, multiplexing, concatenation, and register pipeline creation, alongside wiring and naming capabilities for signal interconnection and hierarchical naming. It operates on `Of_signal.t` and `Of_signal.comb t` types representing scalar signals with field-specific bitwidths, enabling combinational logic and registered behavior. Key use cases include hardware interface synthesis with validated signal hierarchies, named wire management for clarity, and bitwidth-aware transformations in digital circuit design.",
      "description_length": 584,
      "index": 159,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Logic.Std_logic_vector.Uop",
      "library": "hardcaml",
      "description": "This module implements arithmetic and comparison operations for unsigned logic vectors, supporting addition, subtraction, multiplication, and comparisons like less-than or equal-to. It works directly with `Hardcaml.Logic.Std_logic_vector.t`, handling width mismatches by extending inputs and outputs as needed. Use cases include building arithmetic circuits, comparison logic, and resizing logic vectors for signal processing or hardware design.",
      "description_length": 445,
      "index": 160,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Bits_list.X_comb.Signed",
      "library": "hardcaml",
      "description": "This module provides operations for working with signed fixed-width bit vectors represented as lists of ternary bits (`F`, `T`, `X`). It supports arithmetic operations like addition, subtraction, and multiplication, with automatic sign extension and widening to prevent truncation. Comparison operators and resizing enable precise manipulation and relational checks on signed values, suitable for hardware modeling tasks like ALU design or signal processing pipelines.",
      "description_length": 468,
      "index": 161,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Logic.Bit_vector.Unsigned",
      "library": "hardcaml",
      "description": "This module provides operations for manipulating unsigned bit vectors, including arithmetic (addition, subtraction, multiplication) and comparison (less than, greater than, equality) functions. It supports resizing vectors to specified widths and converting to and from generic bit vectors. These operations are used to implement digital logic circuits that perform arithmetic and decision-making tasks, such as counters, state machines, and data path components.",
      "description_length": 463,
      "index": 162,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Clocking.Names_and_widths",
      "library": "hardcaml",
      "description": "This module defines clocking-related metadata for hardware description, specifically listing port names paired with their bit widths. It provides direct access to port names, widths, and clocking tags used in circuit configuration. This data is essential for generating and validating clock domains and signal interfaces in hardware designs.",
      "description_length": 341,
      "index": 163,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Rtl.Name.Vhdl",
      "library": "hardcaml",
      "description": "This module defines rules and conventions for valid VHDL identifiers, including checks for valid starting and subsequent characters, a replacement character for invalid ones, and a list of reserved words. It works with character and string types to enforce naming constraints required by VHDL synthesis tools. Concrete use cases include sanitizing signal and module names during HDL code generation to ensure compliance with VHDL syntax and toolchain requirements.",
      "description_length": 464,
      "index": 164,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Types.Scalar.Of_always",
      "library": "hardcaml",
      "description": "This module provides functions to manipulate and assign values to hardware description interfaces within always blocks. It supports operations on `Signal.t` and `Always.Variable.t` types, enabling register and wire creation, value assignment, and signal naming. Concrete use cases include building synchronous logic with named registers, connecting interface signals in always blocks, and initializing wire interfaces with default values.",
      "description_length": 438,
      "index": 165,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Cyclesim.Private.Traced_nodes",
      "library": "hardcaml",
      "description": "Handles tracing of node values during cycle-accurate simulation by recording internal signal states at each clock cycle. Works with `Hardcaml.Signal.t` and simulation state structures to capture waveform data for debugging and verification. Used to inspect signal transitions and validate circuit behavior over time in a simulated environment.",
      "description_length": 343,
      "index": 166,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Signal.Unoptimized.Sop",
      "library": "hardcaml",
      "description": "This module implements arithmetic and comparison operations for signed vectors, supporting addition, subtraction, multiplication, and comparisons like less than or equal, greater than, etc. It works directly with `Signal.t` values, handling width mismatches by extending operands appropriately during operations. Use this module to build combinational circuits that perform signed integer arithmetic and comparisons without relying on optimization passes.",
      "description_length": 455,
      "index": 167,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Interface.Make_interface_with_conversion.Unsafe_assoc_by_port_name",
      "library": "hardcaml",
      "description": "This module directly maps interface fields to and from association lists using port names as keys. It provides `to_alist` and `of_alist` functions that convert between interface values and lists of string-keyed signal pairs. Use this when you need to dynamically construct or inspect interfaces by name, such as for debugging, serialization, or integration with external configuration formats.",
      "description_length": 393,
      "index": 168,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Pair.M",
      "library": "hardcaml",
      "description": "This module implements operations for pairing and manipulating values of type `Data.t * Data.t`, including functions for mapping, folding, and comparing pairs. It provides utilities to construct, deconstruct, and transform pairs in a type-safe manner. Concrete use cases include representing dual signals in hardware descriptions and managing paired data during circuit synthesis.",
      "description_length": 380,
      "index": 169,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Clocking.Unsafe_assoc_by_port_name",
      "library": "hardcaml",
      "description": "This module converts clocking interfaces to and from association lists indexed by port names. It supports mapping between structured clocking data and string-keyed lists of values. Useful for inspecting or dynamically constructing clocking configurations from named port entries.",
      "description_length": 279,
      "index": 170,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Cross_product.Unsafe_assoc_by_port_name",
      "library": "hardcaml",
      "description": "This module directly converts between a product type and an association list indexed by field names. It supports two operations: `to_alist` extracts fields into a string-keyed list, and `of_alist` builds a product from such a list. It works with polymorphic product types where each field is associated with a string name. Use this when mapping hardware interface signals to named entries in a list or reconstructing interfaces from such mappings.",
      "description_length": 447,
      "index": 171,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Comb.Make.Unsigned",
      "library": "hardcaml",
      "description": "This module provides operations for working with unsigned bit vectors, including arithmetic operations like addition, subtraction, and multiplication, where results are widened to avoid truncation. It supports comparison operations between vectors of differing widths and resizing vectors with appropriate zero extension. These functions are used to model combinational logic circuits that operate on unsigned binary numbers, such as arithmetic units, comparators, and data path components.",
      "description_length": 490,
      "index": 172,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Types.Scalar.Unsafe_assoc_by_port_name",
      "library": "hardcaml",
      "description": "This module converts between scalar interfaces and association lists indexed by field names, using `to_alist` to serialize and `of_alist` to reconstruct. It operates on `'a t` values, which represent structured hardware signals, and string-keyed lists of values. Use this when mapping hardware interfaces to named signal values, such as for configuration or dynamic signal routing.",
      "description_length": 381,
      "index": 173,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Rtl.Ast.Signals_name_map",
      "library": "hardcaml",
      "description": "Maps signal UIDs with indices to mangled RTL names for Verilator integration. It supports name mangling by distinguishing signals with identical UIDs but different indices. Used during RTL generation to ensure unique signal naming in Verilator outputs.",
      "description_length": 252,
      "index": 174,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Interface.Ast.Ast",
      "library": "hardcaml",
      "description": "This module represents the structure of an interface as a list of abstract syntax tree (AST) nodes, capturing how the interface is composed from fields, arrays, lists, and sub-modules. It provides a `sexp_of_t` function for converting the AST into an S-expression, enabling serialization and inspection of interface structures. It is used primarily in code generation workflows, such as creating register interface specifications from interface definitions.",
      "description_length": 457,
      "index": 175,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Flags_vector.Make.Of_bits",
      "library": "hardcaml",
      "description": "This module provides operations to manipulate bit vector interfaces, including packing/unpacking, multiplexing, concatenation, and validation of signal widths. It works with bit vectors and structured interfaces composed of multiple bit fields. Concrete use cases include building register files, decoding instruction fields, and constructing complex digital circuits from smaller components.",
      "description_length": 392,
      "index": 176,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Bits.Mutable.Comb",
      "library": "hardcaml",
      "description": "This module enables bit-level manipulation, conversion, and arithmetic on mutable fixed-width bit vectors optimized for combinational logic synthesis. It supports operations like bit slicing, logical gates, signed/unsigned arithmetic, and multiplexing, alongside conversions between integers, strings, and bit sequences. Commonly used in digital circuit design for tasks such as register modeling, ALU implementation, and control logic synthesis where precise bit-level control and efficient simulation are critical.",
      "description_length": 516,
      "index": 177,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Cross_product.Of_bits",
      "library": "hardcaml",
      "description": "This module handles structured bit-level data manipulation using a record-like interface with fixed-width fields. It supports operations like packing/unpacking to bit vectors, multiplexing, concatenation, and selection from lists of interfaces using one-hot or priority-encoded control signals. Concrete use cases include hardware register manipulation, bus routing logic, and configuration data handling in digital circuits.",
      "description_length": 425,
      "index": 178,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Interface.Make_interface_with_conversion.Of_bits",
      "library": "hardcaml",
      "description": "This module provides functions to convert between integer values and bit-level representations of structured interfaces, enabling operations like packing and unpacking fields into bit vectors, multiplexing between interface instances, and validating signal widths. It works with `t` types parameterized by `Hardcaml.Bits.t`, representing structured hardware signals, and supports concrete use cases such as serializing hardware state, building multiplexed control paths, and ensuring correct bit-width assignments in hardware descriptions. Key operations include `pack`, `unpack`, `mux`, and `assert_widths`, which directly manipulate and verify the binary layout of structured data in hardware designs.",
      "description_length": 703,
      "index": 179,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Array.All",
      "library": "hardcaml",
      "description": "This module provides the `all` function, which transforms a tuple or record of monadic values into a monadic tuple or record, effectively lifting the monad outside. It operates on data structures like tuples and records where each field is wrapped in a monad `M`. A concrete use case is unwrapping multiple result values from a computation, such as collecting the outputs of several sequential operations into a single structured result.",
      "description_length": 437,
      "index": 180,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Rtl.Deprecated.Verilog",
      "library": "hardcaml",
      "description": "Writes a Verilog representation of a hardware circuit to a file or standard output. It takes a boolean flag to control formatting, an I/O specification, and a circuit definition to generate the corresponding Verilog code. This function is used for exporting synthesized hardware designs in Verilog format for simulation or further toolchain processing.",
      "description_length": 352,
      "index": 181,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Clocking.Of_signal",
      "library": "hardcaml",
      "description": "This module provides operations for constructing, transforming, and composing clocked hardware interfaces through combinational signal manipulation, including selection logic, register insertion, and structural routing. It operates on `t` values representing clocked signal interfaces, enabling use cases like building hierarchical digital circuits, connecting components via named signal wires, and implementing pipelined architectures with validated signal widths.",
      "description_length": 466,
      "index": 182,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Array.Unsafe_assoc_by_port_name",
      "library": "hardcaml",
      "description": "This module provides direct conversions between a structured interface and an association list indexed by field names. It operates on data types that represent hardware interfaces with named ports. Use this module to serialize or deserialize port-based hardware descriptions to and from string-keyed lists, enabling straightforward inspection or configuration of port mappings.",
      "description_length": 377,
      "index": 183,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Signal.Unoptimized.Unsigned",
      "library": "hardcaml",
      "description": "This module provides operations for manipulating unsigned binary vectors as signals, including arithmetic (addition, subtraction, multiplication) and comparison operations (less than, greater than, equality). It supports resizing vectors to specified widths with appropriate zero extension and handles operand width mismatches automatically during computations. These capabilities are used to model and simulate digital circuits where precise control over bit-level representations and combinational logic is required.",
      "description_length": 518,
      "index": 184,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Clocking.Of_always",
      "library": "hardcaml",
      "description": "This module provides functions to manipulate and assign clocked interfaces using the Always API. It works with clocked interfaces containing signals, registers, and wires, enabling structured hardware descriptions. Use it to create named clocked registers or wires, assign interface fields in always blocks, or apply naming conventions to interface elements.",
      "description_length": 358,
      "index": 185,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.List.Unsafe_assoc_by_port_name",
      "library": "hardcaml",
      "description": "Converts between a polymorphic record and an association list indexed by field names. Works with any record type `'a t` and strings as keys. Useful for dynamically accessing or constructing record fields by name, such as in serialization or configuration parsing.",
      "description_length": 263,
      "index": 186,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Vcd.Var.Generator",
      "library": "hardcaml",
      "description": "Constructs unique string identifiers for `Var` instances to be used in VCD files. It maintains an internal state to generate sequential IDs within a specified character range. This ensures each variable in the VCD output has a distinct identifier, essential for correct signal tracing and waveform visualization.",
      "description_length": 312,
      "index": 187,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Bits_list.Make.Uop",
      "library": "hardcaml",
      "description": "This module performs arithmetic and comparison operations on lists of bits representing unsigned integers. It supports addition, subtraction, multiplication, and comparisons like less than or equal, directly on bit vectors of varying widths. These operations are used to model combinational logic circuits where bit list widths determine values and results are appropriately extended to preserve precision.",
      "description_length": 406,
      "index": 188,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Comb.Make.Uop",
      "library": "hardcaml",
      "description": "This module implements arithmetic and comparison operations for unsigned bit vectors, supporting addition, subtraction, multiplication, and comparisons like less than or equal, greater than, and equality. It operates directly on types like `Bits.t` or `Signal.t`, handling width mismatches by extending inputs as needed and returning appropriately resized results. Use it to implement datapath logic such as counters, arithmetic units, or control decisions based on unsigned numeric comparisons.",
      "description_length": 495,
      "index": 189,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.With_valid.Fields",
      "library": "hardcaml",
      "description": "This module supports structured hardware interfaces with per-field validity signals, offering operations like mapping, zipping, and folding over record-like data structures. It works with parameterized types `'a With_valid.t X.t`, enabling precise control over combinational logic, register interfaces, and signal assignment in RTL designs. It is used to implement protocols with valid-ready signaling, such as AXI streams, and to manage hardware interfaces with named, validated ports during FPGA/ASIC synthesis.",
      "description_length": 513,
      "index": 190,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Bits_list.Make.Unsigned",
      "library": "hardcaml",
      "description": "This module implements arithmetic and comparison operations for unsigned binary vectors represented as lists of bits. It supports addition, subtraction, multiplication, and comparisons like less-than or equal-to, with automatic bit-width extension to preserve precision. These operations are used to model combinational logic circuits where vector widths and operations must explicitly handle overflow and comparison results.",
      "description_length": 425,
      "index": 191,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Interface.Make.Of_always",
      "library": "hardcaml",
      "description": "This module provides functions to create and manipulate interface containers of always block variables, including registers and wires, with support for signal assignment and naming. It works with interface types parameterized by `Hardcaml.Always.Variable.t`, enabling structured hardware description within always blocks. Concrete use cases include defining register interfaces with optional enables, creating wire interfaces with default signal values, and assigning signal values to variable interfaces in sequential logic.",
      "description_length": 525,
      "index": 192,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Interface.Empty.Of_bits",
      "library": "hardcaml",
      "description": "This module provides operations to manipulate empty interface values represented as bit vectors, including packing, unpacking, multiplexing, and concatenation. It works with `Hardcaml.Interface.Empty.t` values where each field is a `Hardcaml.Bits.t`. Concrete use cases include constructing and validating bit-level representations of empty interfaces, selecting between multiple interfaces using priority or one-hot encoding, and converting between integer values and bit vectors.",
      "description_length": 481,
      "index": 193,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.With_valid.Vector.Unsafe_assoc_by_port_name",
      "library": "hardcaml",
      "description": "This module directly converts between a polymorphic vector and an association list indexed by field names. It operates on types `'a t` and `(string * 'a) list`, enabling structured data extraction and reconstruction. Use it to map hardware interface signals to named fields or build interfaces from pre-existing named data.",
      "description_length": 323,
      "index": 194,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Signal.Unoptimized.Uop",
      "library": "hardcaml",
      "description": "This module implements arithmetic and comparison operations for hardware signals representing unsigned integer values. It supports addition, subtraction, multiplication, and comparisons like less than or equal, greater than, and equality, with automatic bit-width extension to prevent truncation. These operations are used to construct combinational logic circuits for hardware simulation or synthesis, such as implementing ALUs, counters, or control logic.",
      "description_length": 457,
      "index": 195,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Enum.Make_one_hot.Names_and_widths",
      "library": "hardcaml",
      "description": "This module generates port names and widths for a one-hot encoded enumeration type. It provides access to lists of port names, widths, and combined name-width pairs, derived from the enumeration's tags. Each port corresponds to a variant in the enumeration, with a width of 1 for one-hot encoding.",
      "description_length": 297,
      "index": 196,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Rtl.Name.Verilog",
      "library": "hardcaml",
      "description": "This module defines rules and conventions for generating valid Verilog identifiers. It includes character validation, replacement, and naming prefix settings. Use it to sanitize signal names and avoid conflicts with Verilog reserved words.",
      "description_length": 239,
      "index": 197,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Vcd.Var.Type",
      "library": "hardcaml",
      "description": "This module defines the set of variable types supported in VCD (Verilog Change Dump) files, such as `Wire`, `Reg`, `Integer`, and `Real`, which correspond to hardware signal types. It provides functions to convert these types to S-expressions and strings, primarily used for serialization and debugging during waveform generation. These types are essential when declaring variables in a VCD file to accurately represent signal behavior in simulation tools like GTKWave.",
      "description_length": 469,
      "index": 198,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Logic.Std_logic_vector.Unsigned",
      "library": "hardcaml",
      "description": "This module provides operations for manipulating unsigned fixed-width bit vectors, including arithmetic (addition, subtraction, multiplication), comparison (less than, greater than, equality), and resizing. It works directly with the `v` type, which represents unsigned vectors, and supports conversions to and from `Comb.t` signals. These operations are used in digital circuit design for tasks like implementing arithmetic logic units, comparators, and data path components.",
      "description_length": 476,
      "index": 199,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Bits_list.Bool_comb.Sop",
      "library": "hardcaml",
      "description": "This module implements arithmetic and comparison operations for lists of boolean values representing signed binary numbers. It supports addition, subtraction, multiplication, and comparisons like less than or equal, directly operating on `Bool_comb.t` values. Typical use cases include building custom digital circuits that require signed integer arithmetic or comparison logic with dynamic bit-width handling.",
      "description_length": 410,
      "index": 200,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Fifo.With_interface.O",
      "library": "hardcaml",
      "description": "This module provides functions for transforming and combining structured FIFO interfaces through mapping, zipping, and higher-order operations, along with bit-level manipulation and conversion to/from lists. It operates on hardware signal interfaces and bit vectors, supporting use cases like dynamic signal routing, FIFO implementation with introspection capabilities, and hardware description workflows requiring precise port metadata management.",
      "description_length": 448,
      "index": 201,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Scalar.Unsafe",
      "library": "hardcaml",
      "description": "Converts a regular value into a scalar type, allowing it to be used in contexts expecting a wrapped scalar. Works directly with any polymorphic type `'a`, wrapping it into a scalar representation. Useful when initializing scalar values for hardware description computations without runtime overhead checks.",
      "description_length": 306,
      "index": 202,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Interface.Make_interface_with_conversion.Names_and_widths",
      "library": "hardcaml",
      "description": "This module defines operations to extract and manipulate signal metadata such as names, widths, and tags from a Hardcaml interface. It works with lists of strings and integers to represent port names and widths, along with a list of tag values. Concrete use cases include inspecting interface structure for debugging, generating signal documentation, or driving custom code generation based on interface properties.",
      "description_length": 415,
      "index": 203,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Interface.Make_interface_with_conversion.Make_comb",
      "library": "hardcaml",
      "description": "This module implements combinational logic operations on structured signal interfaces, enabling manipulation of grouped signals as cohesive units. It supports operations like packing/unpacking to vectors, multiplexing, concatenation, and priority/onehot selection, working with interfaces that map fields to combinatorial signals. Concrete use cases include building complex control logic, data routing structures, and register file access circuits directly from structured interface definitions.",
      "description_length": 496,
      "index": 204,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Async_fifo.Make.I",
      "library": "hardcaml",
      "description": "This module enables structured manipulation of hardware interfaces with named ports and bit widths through mapping, zipping, folding, and scanning operations. It supports dynamic field access, serialization, and width aggregation for asynchronous FIFO design, while integrating combinational logic and bit-level transformations using signal and register primitives. Specialized utilities for FIFO interface creation and offset calculation further streamline register-transfer level modeling in synchronous circuits.",
      "description_length": 515,
      "index": 205,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Enum.Make_binary.Names_and_widths",
      "library": "hardcaml",
      "description": "This module provides values listing the names and widths of ports, along with the list of tags, for a binary-encoded hardware interface derived from an enumeration. It works with enumeration types represented as lists of strings and integers for port metadata, and lists of tags for variant identifiers. Concrete use cases include generating port definitions for hardware description code and mapping enum variants to binary signal widths.",
      "description_length": 439,
      "index": 206,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Interface.Make.Of_signal",
      "library": "hardcaml",
      "description": "This module provides operations for transforming and composing groups of signal vectors, including packing/unpacking, concatenation, multiplexing, and pipeline register insertion. It works with parameterized interface types (`X.t`) that define signal hierarchies and widths, manipulating them as `Of_signal.comb` values to model hardware connections. These capabilities are used to build structured hardware modules with named signal bundles, wire hierarchical components, and enforce interface consistency during synthesis.",
      "description_length": 524,
      "index": 207,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Logic.Std_logic_vector.Sop",
      "library": "hardcaml",
      "description": "This module provides arithmetic and comparison operations for signed logic vectors, supporting addition, subtraction, multiplication, and comparisons like less than or equal. It works directly with `Hardcaml.Logic.Std_logic_vector.t` values, allowing operations without explicit conversion to and from combinational signals. Use cases include implementing arithmetic logic units (ALUs) and comparison-based control logic in hardware designs.",
      "description_length": 441,
      "index": 208,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Logic.Std_logic.Variants",
      "library": "hardcaml",
      "description": "This module defines individual variants of the `std_logic` type used in digital circuit modeling, such as `'U'`, `'X'`, `'0'`, `'1'`, `'Z'`, `'W'`, `'L'`, `'H'`, and `\"don't care\"`. It provides operations to fold, iterate, and map over these variants, enabling precise value transformations and inspections. These functions are used to implement logic that handles signal resolution, simulation behavior, and value comparisons in hardware descriptions.",
      "description_length": 452,
      "index": 209,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Rtl.Deprecated.VerilogNames",
      "library": "hardcaml",
      "description": "This module defines naming conventions for Verilog signals, including a flag for case sensitivity, a prefix for generated names, and a list of reserved keywords. It provides a function to legalize signal names by escaping or modifying invalid characters and reserved terms. Use this module to ensure generated Verilog code adheres to naming rules and avoids conflicts with reserved words.",
      "description_length": 388,
      "index": 210,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Bits_list.Int_comb.Uop",
      "library": "hardcaml",
      "description": "This module implements arithmetic and comparison operations for unsigned bit vectors represented as `Bits.t` lists. It supports addition, subtraction, multiplication, and comparisons like less than or equal, directly operating on variable-width vectors with automatic bit extension. Typical use cases include building combinational logic circuits such as adders, comparators, or arithmetic units in hardware descriptions.",
      "description_length": 421,
      "index": 211,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Enum.Make_enums.One_hot",
      "library": "hardcaml",
      "description": "This module provides operations for manipulating one-hot encoded values through mapping, folding, zipping, and converting between bit vectors and enumerated types. It works with tagged one-hot data structures (`One_hot.t`), tuples, lists, and hardware-specific types like `Signal.t` and `Bits.t`, enabling precise control over port widths and names. These utilities are particularly useful for implementing state machines, control logic, and synthesizable hardware where one-hot encoding ensures efficient decoding and glitch-free signal transitions.",
      "description_length": 550,
      "index": 212,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.With_valid.Vector.All",
      "library": "hardcaml",
      "description": "Lifts monadic values within a vector structure, transforming a vector of monadic elements into a monadic vector of elements. Works with polymorphic vector types where elements are wrapped in a monad. Useful for sequencing operations across multiple signals in hardware description contexts.",
      "description_length": 290,
      "index": 213,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Interface.Make_interface_with_conversion.Of_signal",
      "library": "hardcaml",
      "description": "This module provides operations for constructing and validating hardware interfaces composed of structured signal groups, supporting transformations like packing/unpacking, concatenation, and register pipeline insertion. It works with `Of_signal.t` and `Of_signal.comb t` types to manage signal hierarchies with explicit width definitions, enabling tasks like constant assignment and RTL signal routing. Specific use cases include connecting input/output ports via signal linking, applying hierarchical naming conventions, and validating interface compatibility during hardware synthesis workflows.",
      "description_length": 598,
      "index": 214,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Value.All",
      "library": "hardcaml",
      "description": "Combines multiple monadic values within an interface into a single monadic interface, lifting the monad outside. Works with polymorphic interface types `'a M.t t` and transforms them into `'a t M.t`. Useful for handling collections of monadic signals in hardware description contexts.",
      "description_length": 284,
      "index": 215,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Interface.Make.Make_comb",
      "library": "hardcaml",
      "description": "This module provides operations for constructing and manipulating hardware interfaces composed of signal groups with defined widths. It supports concrete tasks like packing and unpacking interfaces to and from bit vectors, multiplexing between interface instances, and validating signal widths. Use cases include building register files, bus multiplexers, and control logic with precise bit-level signal handling.",
      "description_length": 413,
      "index": 216,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Enum.Make_binary.All",
      "library": "hardcaml",
      "description": "This module provides the `all` function, which lifts and combines monadic values across an interface, transforming a structure of monadic values into a monadic structure of values. It operates on interfaces containing values within a monad `M`, restructuring the monad to wrap the entire interface. A concrete use case is aggregating multiple signal computations in hardware description, where each signal is wrapped in a monadic context representing computation or state.",
      "description_length": 472,
      "index": 217,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Logic.Four_state.Variants",
      "library": "hardcaml",
      "description": "This module defines and manipulates four-state logic values (x, z, l0, l1) used in digital circuit simulation. It provides operations to fold, iterate, map, and match over these states, enabling precise control and transformation of logic signals. Use cases include implementing custom logic gates, signal processing pipelines, and simulation tools where multi-valued logic is required.",
      "description_length": 386,
      "index": 218,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.With_valid.Vector.Names_and_widths",
      "library": "hardcaml",
      "description": "This module defines port names and widths for hardware description in Hardcaml, providing direct access to lists of port names, widths, and associated tags. It works with basic string and integer lists, along with a custom `tag` type, to describe interface properties. Use this module when constructing or inspecting hardware modules with named and typed ports.",
      "description_length": 361,
      "index": 219,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.With_valid.Wrap",
      "library": "hardcaml",
      "description": "This module wraps hardware interfaces with validity signals, enabling precise control over data-valid handshaking in circuit design. It provides functions to create, access, and transform valid-tagged interfaces, working with record-like types that combine data values and their associated validity signals. It is used to implement synchronous communication patterns such as FIFOs, pipelines, and state machines where data validity must be explicitly tracked and synchronized.",
      "description_length": 476,
      "index": 220,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Clocking.Cdc",
      "library": "hardcaml",
      "description": "This module provides functions for managing clock domain crossings in digital circuits. It includes operations to stretch pulses across clock cycles, detect rising edges on valid signals from slower clocks, and pipeline signals with asynchronous register annotations. These functions work with clocked signals and valid-ready protocols, typically used in FPGA or ASIC designs to safely transfer data between different clock domains.",
      "description_length": 432,
      "index": 221,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Enum.Make_binary.Of_bits",
      "library": "hardcaml",
      "description": "This module provides bit-level conversion and pattern matching operations for enumeration types, enabling hardware synthesis of combinational logic circuits that interface with binary representations (`Bits.t`). It supports operations like packing/unpacking enum values into bit vectors, multiplexing, concatenation, and comparison, while working with `comb t` structures that pair interfaces with combinational logic. Specific use cases include encoding finite state machines into hardware signals, decoding binary data streams into enumerated states, and implementing configurable logic blocks with pattern-driven behavior.",
      "description_length": 625,
      "index": 222,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Interface.Make_interface_with_conversion.Of_always",
      "library": "hardcaml",
      "description": "This module provides functions to work with Hardcaml interfaces in the context of always blocks, enabling signal assignment, register creation, and naming of interface fields. It operates on interface types containing `Always.Variable.t` signals, allowing integration of custom types with the Always API. Concrete use cases include defining register and wire interfaces with initial values, assigning signals within always blocks, and applying naming conventions to interface components for clarity in generated hardware descriptions.",
      "description_length": 534,
      "index": 223,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Enum.Make_one_hot.Of_bits",
      "library": "hardcaml",
      "description": "This module provides bitwise operations, pattern matching, and validation logic for one-hot encoded enumeration interfaces represented as bit vectors and structured interface types. It enables efficient synthesis of priority-encoded logic, safe case analysis with default handling, and manipulation of one-hot signals in hardware designs. Typical applications include instruction decoding, state machine implementation, and scenarios requiring compact, high-speed enumeration representations with guaranteed single-active-bit semantics.",
      "description_length": 536,
      "index": 224,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Interface.Update.All",
      "library": "hardcaml",
      "description": "This module combines a group of monadic values within an interface, lifting the monad outside the interface structure. It operates on interfaces containing signals with associated monadic context, transforming them into a single monadic interface. Useful when collecting results from multiple signal-processing actions into a unified context.",
      "description_length": 342,
      "index": 225,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Logic.Four_state_vector.Sop",
      "library": "hardcaml",
      "description": "This module implements arithmetic and comparison operations for four-state logic vectors, supporting addition, subtraction, multiplication, and comparisons like less than or equal, greater than, and equality. It operates directly on `Four_state_vector.t` values, handling signed values with automatic bit-width extension during operations and allowing resizing to specified widths. Concrete use cases include building arithmetic logic units (ALUs) and comparison circuits in hardware descriptions where signed vector operations are required.",
      "description_length": 541,
      "index": 226,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Logic.Four_state_vector.Signed",
      "library": "hardcaml",
      "description": "This module provides operations for working with signed four-state logic vectors, including arithmetic operations like addition, subtraction, and multiplication, as well as comparison operations such as less than, greater than, and equality. It supports resizing vectors to specified widths with appropriate sign extension. These functions are used when implementing digital circuits that require signed integer arithmetic and comparisons, such as ALUs or control logic in hardware designs.",
      "description_length": 490,
      "index": 227,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Rtl.Deprecated.Uid_with_index",
      "library": "hardcaml",
      "description": "This module pairs a signal UID with an integer index, enabling ordered comparisons and serialization. It supports concrete use cases like tracking signal instances with unique identifiers and managing signal routing in RTL designs. The module ensures signals can be uniquely ordered and converted to s-expressions for debugging or configuration purposes.",
      "description_length": 354,
      "index": 228,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.List.Names_and_widths",
      "library": "hardcaml",
      "description": "This module defines lists of port names paired with their bit-widths, individual port names, port widths, and tags used in hardware description contexts. It provides direct access to these predefined lists for use in signal and port handling during hardware design compilation or simulation. Concrete use cases include mapping signal identifiers to their widths in digital circuit representations and managing tagged hardware components.",
      "description_length": 437,
      "index": 229,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Types.Clocking.Of_bits",
      "library": "hardcaml",
      "description": "This module provides functions to manipulate clocked interfaces represented as bit vectors. It supports operations like packing/unpacking interfaces to/from bit vectors, multiplexing, concatenation, and selection logic with priority or one-hot encoding. These functions are used to build and transform register-transfer level circuits where each field has a defined bit width and can be driven by combinational logic.",
      "description_length": 417,
      "index": 230,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Rtl_attribute.Vivado.Ram_style",
      "library": "hardcaml",
      "description": "This module defines specific RAM implementation styles for Xilinx Vivado synthesis, including block, distributed, registers, and ultra RAM types. It works with RTL attribute specifications to control memory resource selection during synthesis. Use these values to explicitly constrain how Vivado infers and implements memory elements in the generated HDL code.",
      "description_length": 360,
      "index": 231,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Fifo.With_interface.I",
      "library": "hardcaml",
      "description": "This module enables structural manipulation of FIFO interfaces through mapping, zipping, and combinational logic operations, alongside utilities for serialization, equality checks, and unsafe conversions to port-name-based association lists. It primarily handles typed interface values (`I.t`) with embedded port metadata (names, bit-widths) to support hardware workflows like HDL signal declarations and pipeline registration. These capabilities are applied in synchronous FIFO design for tasks such as multiplexing, register assignment, and port-driven data aggregation in digital circuits.",
      "description_length": 592,
      "index": 232,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.With_valid.Wrap.M",
      "library": "hardcaml",
      "description": "This module defines a type `'a t` representing a hardware interface with validity, combining a value of type `'a` and its associated valid signal from module `X`. It provides operations to construct, destructure, and manipulate these interfaces, such as `create`, `value`, and `valid`. Use this module to model data paths in hardware designs where signals must be qualified by a valid bit, such as pipeline stages or communication protocols.",
      "description_length": 441,
      "index": 233,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Enum.Make_binary.Unsafe_assoc_by_port_name",
      "library": "hardcaml",
      "description": "This module creates an association list from an enumerated type's field names and corresponding values, and constructs an interface from such a list. It operates on enumerated types represented as strings paired with values in a list. Use it to map hardware interface signals by field name or to dynamically construct interfaces from named value pairs.",
      "description_length": 352,
      "index": 234,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Types.Clocking.Make",
      "library": "hardcaml",
      "description": "This module enables structured manipulation of clocked hardware interfaces with typed fields, supporting transformations like mapping, zipping, and folding over combinational and sequential logic. It operates on hardware signals and clocking primitives to implement synchronous design patterns such as state machines, pipelined data paths, and cross-clock domain synchronization, with utilities for register creation, signal routing, and interface composition. Key applications include digital circuit synthesis tasks requiring precise timing control, signal aggregation, and hierarchical interface management.",
      "description_length": 610,
      "index": 235,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Interface.Make_interface_with_conversion.All",
      "library": "hardcaml",
      "description": "This module provides the `all` function, which lifts monadic values through an interface, transforming a structure of monadic signals into a monadic structure of signals. It operates on interfaces containing values within a monad `M`, such as `Signal.t` or `Wire.t`. Use it to sequence operations across an interface when building or simulating hardware descriptions with Hardcaml.",
      "description_length": 381,
      "index": 236,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Async_fifo.Make.O",
      "library": "hardcaml",
      "description": "This module enables structural manipulation and introspection of FIFO interfaces using higher-order functions like `map`, `zip`, and `iter`, alongside utilities for inspecting port metadata (names, widths) and converting between tagged interface elements and association lists. It operates on hardware description interfaces and distributed RAM-based FIFOs, supporting use cases such as dynamic port configuration, combinational signal logic (e.g., multiplexing, concatenation), and pipeline-aware transformations.",
      "description_length": 514,
      "index": 237,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Bits_list.X_comb.Uop",
      "library": "hardcaml",
      "description": "This module implements arithmetic and comparison operations for lists of `F`, `T`, and `X` bits, representing unsigned binary vectors. It supports addition, subtraction, multiplication, and comparisons like less than or equal, with automatic bit-width extension during operations and resizing. These functions directly manipulate bit lists to build combinational logic circuits with precise width control and without truncation.",
      "description_length": 428,
      "index": 238,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Enum.Make_one_hot.All",
      "library": "hardcaml",
      "description": "This module provides the `all` function, which takes a one-hot encoded enumeration of monadic values and lifts the monad outside the enumeration, effectively combining the monadic results. It operates specifically on types produced by the `Make_one_hot` functor, representing enumerations with a one-hot internal format. A concrete use case is collecting and sequencing register reads across an enumeration of hardware signals in a single clock cycle.",
      "description_length": 451,
      "index": 239,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Logic.Bit_vector.Sop",
      "library": "hardcaml",
      "description": "This module provides arithmetic and comparison operations for signed bit vectors, supporting addition, subtraction, multiplication, and comparisons like less than or equal. It works directly with `Bits.t` or `Signal.t` types, handling width mismatches by automatically extending operands and preserving sign. Use cases include implementing arithmetic logic units (ALUs) and comparison-based control logic in digital circuits.",
      "description_length": 425,
      "index": 240,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Types.Clocking.Make_comb",
      "library": "hardcaml",
      "description": "This module implements combinational logic operations for clocking interfaces, providing functions to pack, unpack, multiplex, and validate signal widths. It works with clocking interface types parameterized over a combinational logic type `comb`, supporting operations like constant assignment, concatenation, and priority/one-hot selection. Concrete use cases include constructing and validating hardware interfaces with precise bit-width control, multiplexing signal paths, and converting structured interfaces to flat vectors.",
      "description_length": 530,
      "index": 241,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Signal.Unoptimized.Signed",
      "library": "hardcaml",
      "description": "This module provides operations for working with signed fixed-width bit vectors in a hardware description context. It supports arithmetic operations like addition, subtraction, and multiplication, with automatic sign extension and widening to prevent truncation. It also includes comparison operators for signed values and a resize function for adjusting bit widths, making it suitable for tasks like implementing arithmetic logic units or data path components in digital circuits.",
      "description_length": 481,
      "index": 242,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Bits_list.Bool_comb.Unsigned",
      "library": "hardcaml",
      "description": "This module implements arithmetic and comparison operations for unsigned binary vectors represented as lists of boolean values. It supports addition, subtraction, multiplication, and comparisons like less than or equal, with automatic bit-width extension to preserve precision. These operations are used to model combinational logic circuits where each vector corresponds to a fixed-width unsigned integer.",
      "description_length": 406,
      "index": 243,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Parameter.Value.Variants",
      "library": "hardcaml",
      "description": "This module defines variant constructors for different types of parameter values used in hardware design configurations, such as `bit`, `int`, `string`, and various logic vector types. It supports operations like `fold`, `map`, and `iter` to process these variants, and provides utilities to convert values to ranks or names. It is used to handle and manipulate parameter values in RTL designs when generating or analyzing configurable hardware components.",
      "description_length": 456,
      "index": 244,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Bits_list.Make.Signed",
      "library": "hardcaml",
      "description": "This module provides operations for working with signed fixed-width bit vectors represented as lists of bits. It supports arithmetic operations like addition, subtraction, and multiplication, with automatic sign extension and widening to prevent truncation. Comparison operators and resizing enable precise manipulation and relational checks on signed values of varying widths.",
      "description_length": 377,
      "index": 245,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Array.Of_always",
      "library": "hardcaml",
      "description": "This module provides functions to manipulate and assign values to arrays of always block variables in Hardcaml, specifically working with `Always.Variable.t` and `Signal.t` types. It supports creating register and wire interfaces, assigning signals within always blocks, and applying naming conventions to interface fields. Concrete use cases include building structured hardware descriptions with named signals, initializing wires to known states, and conditionally updating register interfaces in synchronous logic.",
      "description_length": 517,
      "index": 246,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.List.Of_bits",
      "library": "hardcaml",
      "description": "This module provides functions to manipulate lists of bit vectors as structured interfaces. It supports operations like packing/unpacking interfaces to/from bit vectors, multiplexing, concatenation, and priority/one-hot selection with validity signals. Use cases include hardware description tasks such as signal routing, bus manipulation, and interface validation in digital circuit design.",
      "description_length": 391,
      "index": 247,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Always.State_machine.Encoding",
      "library": "hardcaml",
      "description": "This module defines state machine encoding types such as Binary, Gray, and Onehot, and provides functions to convert these encodings to S-expressions and strings. It is used to specify how state values are represented in generated HDL code when building state machines within the Always DSL. The encodings influence synthesis results, allowing control over area, power, and timing in the resulting circuit.",
      "description_length": 406,
      "index": 248,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.With_valid.Wrap.Make",
      "library": "hardcaml",
      "description": "This module supports structural transformations and compositional operations for hardware interfaces with valid signals, enabling tasks like pipeline construction and register file creation. It works with structured interfaces (`'a t`), bit vectors, signals, and port metadata, offering utilities for mapping, zipping, folding, and monadic lifting across tagged or named ports. Specific abstractions like `Of_bits` facilitate bit-level packing and concatenation, while `Of_always` handles synchronous logic definition, and `Of_signal` enables signal composition with combinational or sequential elements.",
      "description_length": 604,
      "index": 249,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Cross_product.All",
      "library": "hardcaml",
      "description": "Lifts monadic values within an interface to the outer monad, combining them into a single monadic interface. Works with polymorphic interface types where each field is wrapped in a monad `M`. Useful for collecting results from multiple monadic computations across an interface into a unified monadic structure.",
      "description_length": 310,
      "index": 250,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Cross_product.Of_always",
      "library": "hardcaml",
      "description": "This module provides functions to manipulate and assign signals within the Always API when working with hardware description interfaces. It supports operations like creating register and wire variables, assigning signal values, and applying naming conventions to interface fields. Concrete use cases include building synchronous logic blocks, defining wire defaults, and structuring signal assignments in a readable and maintainable way.",
      "description_length": 437,
      "index": 251,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Logic.Four_state_vector.Uop",
      "library": "hardcaml",
      "description": "This module implements arithmetic and comparison operations for four-state logic vectors, supporting addition, subtraction, multiplication, and comparisons like less than or equal, greater than, and equality. It operates directly on `Four_state_vector.t` values, which represent unsigned binary vectors in digital logic design. Use cases include building combinational logic circuits where operations on variable-width binary signals are required, such as in ALUs, counters, or data path components.",
      "description_length": 499,
      "index": 252,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Signal.Type.Uid",
      "library": "hardcaml",
      "description": "This module implements a signal identifier system with unique integer values, supporting operations to create, compare, hash, and convert identifiers to integers or strings. It provides atomic generation of fresh identifiers and reset functionality for deterministic testing or simulation contexts. Concrete use cases include managing unique signal names during hardware simulation and netlist generation, ensuring signal identity consistency across transformations.",
      "description_length": 466,
      "index": 253,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Enum.Make_one_hot.Of_always",
      "library": "hardcaml",
      "description": "This module provides functions to manipulate and assign one-hot encoded enumeration interfaces within always blocks. It supports creating register and wire variables, assigning signals, applying names, and performing pattern matching on one-hot signals. Use it to implement state machines or multiplexed logic paths directly in the Always API.",
      "description_length": 343,
      "index": 254,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Rtl.Deprecated.VhdlNames",
      "library": "hardcaml",
      "description": "This module defines naming conventions for VHDL identifiers, including case sensitivity settings, a prefix, and a list of reserved words. It provides a function to legalize strings by transforming them into valid VHDL identifiers according to these rules. Use this module when generating or sanitizing signal or entity names in VHDL code generation workflows.",
      "description_length": 359,
      "index": 255,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Cross_product.Of_signal",
      "library": "hardcaml",
      "description": "This module provides structural transformations and validation for hardware interfaces using signal bundles, including operations like concatenation, multiplexing, and register pipelines to manage signal widths and hierarchies. It also enables precise signal wiring and customizable naming strategies, supporting use cases such as constructing complex digital circuits and organizing large-scale hardware descriptions with automated name scoping.",
      "description_length": 446,
      "index": 256,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Enum.Make_one_hot.Of_signal",
      "library": "hardcaml",
      "description": "This module provides operations for converting, comparing, and combining one-hot encoded enumeration values using signal-based representations, supporting combinational logic, multiplexing, and pipeline construction. It works with one-hot encoded enum types (`Of_signal.t`) and case analysis structures (`Cases.t`), enabling direct manipulation of signal interfaces and enum value validation. Typical use cases include implementing state machines, interfacing with external one-hot encoded hardware signals, and building named, type-safe signal multiplexers.",
      "description_length": 558,
      "index": 257,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Bits_list.Int_comb.Sop",
      "library": "hardcaml",
      "description": "This module implements arithmetic and comparison operations for signed integer vectors represented as lists of bits. It supports addition, subtraction, multiplication, and comparisons like less than or equal, greater than, and equality, with automatic sign extension and resizing to preserve precision. These operations are used to model low-level digital logic circuits where signed integers are manipulated directly as bit vectors.",
      "description_length": 433,
      "index": 258,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Logic.Bit_vector.Signed",
      "library": "hardcaml",
      "description": "This module provides operations for working with signed bit vectors, including arithmetic operations like addition, subtraction, and multiplication, as well as comparison operations such as less than, equal to, and greater than. It supports the `v` type for representing signed values and includes functions to convert to and from standard bit vectors, and to resize vectors with appropriate sign extension. Concrete use cases include implementing arithmetic logic units (ALUs) and performing signed comparisons in digital circuit design.",
      "description_length": 538,
      "index": 259,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Interface.Update.Unsafe_assoc_by_port_name",
      "library": "hardcaml",
      "description": "This module directly maps interface fields to and from an association list, using port names as keys. It supports converting an interface into a list of `(name, value)` pairs or building an interface from such a list. This is useful when dynamically modifying port names or values, such as during interface transformations or external configuration parsing.",
      "description_length": 357,
      "index": 260,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Array.Of_signal",
      "library": "hardcaml",
      "description": "This module provides operations for constructing and transforming structured hardware signals with field-based bit-widths, enabling tasks like constant assignment, concatenation, multiplexing, and pipeline creation. It works with `Of_signal.t` and `Of_signal.comb t` types to model hierarchical digital circuits, supporting use cases such as register transfer level design, interface port generation, and signal naming conventions for clarity in hardware descriptions.",
      "description_length": 468,
      "index": 261,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Signal.Type.Make_deps",
      "library": "hardcaml",
      "description": "This module processes dependencies of hardware design signals through traversal operations. It provides `fold`, `iter`, `map`, and `rev_map` to process, transform, and collect dependencies of a signal in a defined order. Use cases include analyzing signal dependencies for simulation or netlist generation, collecting inputs to a circuit, or transforming signals during optimization passes.",
      "description_length": 390,
      "index": 262,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Bits_list.Int_comb.Unsigned",
      "library": "hardcaml",
      "description": "This module implements arithmetic and comparison operations for unsigned binary vectors represented as lists of integers. It supports addition, subtraction, multiplication, and comparisons like less than or equal, operating on values implicitly sized by the list length. These operations are used to model combinational logic circuits where vector widths are managed automatically to prevent truncation.",
      "description_length": 403,
      "index": 263,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.With_valid.Vector.Of_signal",
      "library": "hardcaml",
      "description": "This module provides operations for constructing and transforming structured hardware interfaces through vectorized signal manipulation, including concatenation, multiplexing, pipelining, and field-based wiring. It works with `Of_signal.comb t` and `Of_signal.t` types that represent hardware signals as typed vectors with explicit field widths and hierarchical structure. These capabilities are used to build register-transfer-level designs by connecting signal interfaces, applying naming conventions, and modeling synchronous or combinational logic blocks.",
      "description_length": 559,
      "index": 264,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Types.Value.Of_always",
      "library": "hardcaml",
      "description": "This module provides functions to construct and manipulate interfaces within always blocks using variables. It supports operations like assigning signals to variable interfaces, creating registers and wires with specified behaviors, and applying naming conventions to interface fields. Concrete use cases include building hardware descriptions with structured, named signals in a functional style, such as defining register interfaces with enable conditions or initializing wire interfaces with default signal values.",
      "description_length": 517,
      "index": 265,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Bits_list.X_comb.Sop",
      "library": "hardcaml",
      "description": "This module implements arithmetic and comparison operations for lists of signed bits, supporting addition, subtraction, multiplication, and comparisons like less than or equal, greater than, etc. It works directly with `Bits.t` and `Signal.t` types, handling width mismatches by extending operands as needed. Concrete use cases include building arithmetic circuits, implementing comparators, and converting between bit vectors and signals in hardware descriptions.",
      "description_length": 464,
      "index": 266,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.With_valid.Vector.Of_bits",
      "library": "hardcaml",
      "description": "This module provides operations to construct, manipulate, and validate bit vector interfaces. It supports concrete tasks such as packing and unpacking interfaces into bit vectors, multiplexing between interface values, concatenating interfaces, and selecting between one-hot or priority-encoded inputs. Functions like `of_int`, `validate`, and `widths` enable working directly with integer constants and checking signal widths for correctness.",
      "description_length": 443,
      "index": 267,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Enum.Make_binary.Make_comb",
      "library": "hardcaml",
      "description": "Provides operations for binary-encoded enumeration manipulation in hardware designs, including packing/unpacking, priority/one-hot multiplexing, validation, and integer-enum conversions. Works directly with `comb t` and `comb outer` types representing combinational logic signals, enabling case-based dispatch through `Cases.t` for pattern matching and signal routing. Useful for implementing finite state machines, control logic, and hardware interfaces requiring compact binary representations of enumerated states.",
      "description_length": 517,
      "index": 268,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.List.Of_always",
      "library": "hardcaml",
      "description": "This module provides functions to manipulate and assign values to hardware description interfaces within always blocks. It supports operations like creating register and wire variables, assigning signals, and applying naming conventions to interface fields. Use cases include building and managing complex hardware interfaces with named signals in a structured way.",
      "description_length": 365,
      "index": 269,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Types.Scalar.Of_bits",
      "library": "hardcaml",
      "description": "This module provides operations to construct, manipulate, and validate scalar signal interfaces using bit vectors. It supports concrete operations such as packing/unpacking interfaces to/from bit vectors, multiplexing, concatenation, and selection logic (priority and one-hot). Use cases include building and validating hardware interfaces where each field's bit width must be explicitly controlled and checked.",
      "description_length": 411,
      "index": 270,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Flags_vector.Make.Of_signal",
      "library": "hardcaml",
      "description": "This module enables structured signal manipulation through operations like concatenation, multiplexing, and register creation, while enforcing compile-time width validation and constant assignment. It works with hierarchical digital signal types (`comb t` and `t`) to support transformations such as packing/unpacking and pipeline construction. Key applications include building complex circuit hierarchies with strict type safety and configuring signal interfaces using naming conventions during hardware synthesis.",
      "description_length": 516,
      "index": 271,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Enum.Make_one_hot.Unsafe_assoc_by_port_name",
      "library": "hardcaml",
      "description": "This module provides `to_alist` and `of_alist` functions for converting between enumeration-based interface values and association lists indexed by field names. It operates on types produced by one-hot enumeration functors, where each variant is represented as a single active bit. Use cases include serializing and deserializing one-hot encoded signals for configuration or debugging purposes.",
      "description_length": 394,
      "index": 272,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Interface.Update.Of_signal",
      "library": "hardcaml",
      "description": "This module enables precise manipulation of hardware interfaces composed of signal vectors, supporting operations like concatenation, multiplexing, register pipelining, and width-aware signal assignment. It works with structured groups of `Hardcaml.Signal.t` values organized under named interfaces, allowing dynamic updates to signal names, prefixes, and port configurations during RTL design. Key use cases include synthesizing complex signal transformations, managing hierarchical naming conventions, and adapting interface definitions for simulation or implementation workflows.",
      "description_length": 582,
      "index": 273,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Enum.Make_binary.Unsafe",
      "library": "hardcaml",
      "description": "This module provides low-level, unchecked conversion functions between enumeration values and their binary representations. It works with variant types that have no arguments, representing them as integers in hardware. Use this when directly manipulating hardware signals that encode enum values as bits, such as decoding or encoding control signals in a pipeline.",
      "description_length": 364,
      "index": 274,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Logic.Bit_vector.Uop",
      "library": "hardcaml",
      "description": "This module implements arithmetic and comparison operations for unsigned bit vectors, working directly with `Hardcaml.Logic.Bit_vector.t` values. It supports addition, subtraction, multiplication, and comparisons (less than, greater than, equal, etc.), automatically handling operand extension and result widening. These operations are used to build digital logic circuits where fixed-width unsigned integer arithmetic and comparisons are required, such as counters, arithmetic logic units (ALUs), and control logic.",
      "description_length": 516,
      "index": 275,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Value.Unsafe_assoc_by_port_name",
      "library": "hardcaml",
      "description": "This module directly maps fields of a value to an association list using port names as keys. It provides `to_alist` to convert a value into a list of (port name, value) pairs and `of_alist` to reconstruct a value from such a list. Use this when serializing or deserializing structured values based on named ports, such as configuring hardware interfaces from external data.",
      "description_length": 373,
      "index": 276,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Pair.Wrap",
      "library": "hardcaml",
      "description": "This module provides operations to manipulate pairs and tuples of hardware interface elements\u2014such as bit vectors, combinational signals, and port metadata\u2014through mapping, zipping, and parallel folding over up to five inputs. It supports combinational logic synthesis (e.g., packing, concatenation, multiplexing), signal routing, and hierarchical interface construction tasks like register insertion or port specification. These capabilities enable RTL design workflows, including dynamic signal hierarchy manipulation, debugging, and structured hardware description generation with typed, hierarchical interfaces.",
      "description_length": 615,
      "index": 277,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Interface.Update.Names_and_widths",
      "library": "hardcaml",
      "description": "This module updates port names and widths in a Hardcaml interface, preserving the structure while modifying identifiers and sizes. It operates on lists of string-int pairs representing port names and their corresponding widths. Use it to programmatically adjust interface definitions for simulation or synthesis purposes.",
      "description_length": 321,
      "index": 278,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Clocking.All",
      "library": "hardcaml",
      "description": "This module provides the `all` function, which lifts monadic values from within a clocking interface to the outer monad, effectively combining them into a single monadic result. It operates on values of type `'a M.t Hardcaml.Types.Clocking.t`, where `M` is a monad, transforming them into `'a Hardcaml.Types.Clocking.t M.t`. A typical use case is when working with multiple clocked signals in a monadic context, such as gathering and sequencing register updates across different clock domains.",
      "description_length": 493,
      "index": 279,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Flags_vector.Make.Of_always",
      "library": "hardcaml",
      "description": "This module provides operations to manipulate and assign signal values within an always block, specifically for interface types containing variables. It supports creating register and wire variables, assigning signals to variables, and applying naming conventions to interface fields. Concrete use cases include building synchronous logic blocks, defining interface signals with default values, and organizing signal names in hardware descriptions.",
      "description_length": 448,
      "index": 280,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Interface.Update.Of_always",
      "library": "hardcaml",
      "description": "This module provides functions to create and manipulate interfaces using the Always API, including assigning signals to variables, creating registers and wires, and applying names to interface fields. It works with `Hardcaml.Always.Variable.t` and `Hardcaml.Signal.t` types, structured within interface containers. Concrete use cases include building register interfaces with optional enables, creating wire interfaces with default signal values, and naming interface signals during simulation setup.",
      "description_length": 500,
      "index": 281,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Logic.Std_logic_vector.Signed",
      "library": "hardcaml",
      "description": "This module implements arithmetic and comparison operations for signed fixed-width binary vectors. It supports addition, subtraction, multiplication, and comparisons like less than or equal, operating on the `v` type which wraps `Comb.t` signals. These operations automatically handle sign extension and resizing, making them suitable for hardware synthesis tasks like implementing ALUs or control logic in digital circuits.",
      "description_length": 424,
      "index": 282,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.List.Of_signal",
      "library": "hardcaml",
      "description": "This module enables structured manipulation of hardware signal interfaces through operations like packing/unpacking, concatenation, multiplexing, and pipelining. It operates on `Of_signal.comb t` and `Of_signal.t` types, which represent signals with hierarchical fields, supporting tasks like validation, constant assignment, and register creation with RTL attributes. Key use cases include connecting inputs/outputs via `<==`, applying naming conventions with prefixes/suffixes, and constructing complex signal hierarchies for digital circuit design.",
      "description_length": 551,
      "index": 283,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Interface.Make.Unsafe_assoc_by_port_name",
      "library": "hardcaml",
      "description": "This module directly associates interface fields with values by port name, enabling conversion between interface types and association lists where each field name maps to a corresponding value. It supports operations like `to_alist` for extracting field-value pairs and `of_alist` for constructing interfaces from such pairs. Use this when interfacing with external systems that require named signal mappings, such as generating or parsing signal vectors by name.",
      "description_length": 463,
      "index": 284,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Flags_vector.Make.All",
      "library": "hardcaml",
      "description": "Lifts monadic values within a vector structure, transforming a vector of monadic values into a monadic vector of values. Works with polymorphic vector types where elements are wrapped in a monad. Useful for parallel computations that need to be composed into a single monadic result.",
      "description_length": 283,
      "index": 285,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Cyclesim.Private.Step",
      "library": "hardcaml",
      "description": "This module defines the simulation phases used in a cycle-accurate hardware simulation, including reset, pre-clock, clock edge, and post-clock stages. It provides functions to convert these phase values to S-expressions for serialization or debugging. Use cases include tracking and controlling the progression of simulation steps in synchronous digital circuit testing.",
      "description_length": 370,
      "index": 286,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Interface.Make.Of_bits",
      "library": "hardcaml",
      "description": "This module provides functions to convert interfaces to and from bit vectors, validate signal widths, and perform multiplexing, concatenation, and selection operations on interfaces. It works with `Hardcaml.Bits.t` signals structured according to an interface definition. Use cases include packing and unpacking register states, building multiplexed data paths, and ensuring correct signal widths during hardware synthesis.",
      "description_length": 423,
      "index": 287,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Value.Names_and_widths",
      "library": "hardcaml",
      "description": "This module defines operations to access and manipulate named value ports, including retrieving lists of port names, widths, and associated tags. It works with tuples of strings and integers to represent port names and their bit widths. Concrete use cases include inspecting and serializing hardware description components for simulation or debugging.",
      "description_length": 351,
      "index": 288,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Value.Of_bits",
      "library": "hardcaml",
      "description": "This module handles bit-level value manipulation for hardware description, providing operations like packing/unpacking interfaces into bit vectors, multiplexing, concatenation, and selection from one-hot or priority-encoded inputs. It works with fixed-width bit types (`comb`) and structured interfaces (`t`) where each field has a defined bit width. Concrete use cases include building register files, decoding instruction fields, and constructing arbiters from encoded select signals.",
      "description_length": 486,
      "index": 289,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.With_valid.Vector.Of_always",
      "library": "hardcaml",
      "description": "This module provides functions to manipulate and assign values to hardware description interfaces using the Always API. It supports operations on `t` values containing `Always.Variable.t` elements, enabling structured register and wire creation, signal assignment, and field naming. Concrete use cases include building and connecting hardware modules with named signals, assigning register state within always blocks, and generating wire interfaces with default signal values.",
      "description_length": 476,
      "index": 290,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Structural.Base2",
      "library": "hardcaml",
      "description": "This module provides combinational logic primitives for constructing and manipulating hardware signals, including bit-level operations like selection and concatenation, arithmetic operations such as addition and signed multiplication, and comparison operators for equality and ordering. It operates on structural signal values, which represent hardware circuit components in a structural description. These capabilities are used to implement arithmetic logic units, control logic comparators, and",
      "description_length": 496,
      "index": 291,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Cyclesim.Traced",
      "library": "hardcaml",
      "description": "Handles tracing of input/output ports and internal signals in a cycle-accurate simulation. Provides structured access to signal data with naming information for debugging and waveform visualization. Useful for capturing simulation state transitions and analyzing signal propagation over time.",
      "description_length": 292,
      "index": 292,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Structural.With_interface",
      "library": "hardcaml",
      "description": "This module defines circuit instantiation and composition with explicit input, output, and tri-state signal interfaces. It provides `create_circuit` to define circuits with named ports and `inst` to instantiate them with optional attributes and generics. It is used to build hierarchical hardware designs with well-defined signal boundaries.",
      "description_length": 341,
      "index": 293,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Rtl.Expert",
      "library": "hardcaml",
      "description": "Generates a mapping of signal names to outputs during RTL generation, using a specified output mode, database, and blackbox configuration. Works with circuits, signal name maps, and RTL languages to facilitate custom naming and output handling. Useful for integrating with external tools that require precise signal naming or for debugging synthesized circuits.",
      "description_length": 361,
      "index": 294,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Bits.Unsigned",
      "library": "hardcaml",
      "description": "This module provides operations for manipulating unsigned bit vectors, including arithmetic (addition, subtraction, multiplication) and comparison (less than, greater than, equality) functions. It works directly with the `v` type representing unsigned values, converting to and from standard bit vectors. Concrete use cases include implementing digital logic circuits where unsigned arithmetic and comparisons are required, such as counters, address generators, or data path components.",
      "description_length": 486,
      "index": 295,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Bits.Mutable",
      "library": "hardcaml",
      "description": "This module provides mutable bit vectors with in-place bitwise, arithmetic, and comparison operations (e.g., logical gates, addition, masking) for efficient bit-level computation. It works with fixed-width bit sequences stored as mutable 64-bit words, supporting conversions to/from immutable bit representations and direct word-level access. Designed for hardware simulation workflows, it enables high-performance combinational logic evaluation and cycle-accurate digital circuit modeling where mutation reduces allocation overhead.",
      "description_length": 533,
      "index": 296,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Clocking",
      "library": "hardcaml",
      "description": "This module offers structured transformations of clocked hardware interfaces through mapping, zipping, folding, and scanning operations, alongside utilities for converting between list-based and structured representations of clocked values. It works with typed clocked signal interfaces, combinational logic modules, and register structures, enabling precise control over synchronous state elements, pipelined datapaths, and clock domain crossings. Key capabilities include register creation with configurable clear signals, signal pipelining across clock cycles, and safe handling of error-aware clocked computations using combinational logic combinators.",
      "description_length": 656,
      "index": 297,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Property.LTL",
      "library": "hardcaml",
      "description": "This module provides constructors and combinators for building temporal logic expressions with operations like conjunction, negation, and temporal modalities (next, until, release), alongside transformations to normalize formulas, limit temporal depth, and extract atomic components. It operates on temporal logic formulas represented as path expressions, supporting formal verification workflows in hardware design where temporal properties must be rigorously specified, analyzed, or simplified for model checking and circuit validation tasks.",
      "description_length": 544,
      "index": 298,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Signal.Sop",
      "library": "hardcaml",
      "description": "This module implements arithmetic and comparison operations for signed vectors, supporting addition, subtraction, multiplication, and comparisons like less than or equal. It operates directly on `Hardcaml.Signal.t`, automatically handling bit-width extension during operations and allowing comparisons between different widths. Use this when building arithmetic logic units, performing signed math in hardware pipelines, or implementing control logic based on signed value comparisons.",
      "description_length": 485,
      "index": 299,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Interface.Empty",
      "library": "hardcaml",
      "description": "This module provides utilities for defining and manipulating structured hardware interfaces composed of named ports with specified bit widths, enabling operations like mapping, folding, and zipping over signal groups. It supports tasks such as register file design, packet encoder construction, and hierarchical bus creation through combinational logic assembly, bit vector transformations, and synchronous logic block generation. Key workflows include simulation-friendly signal interconnection, layout control via bit-level offsets, and validation of named signal groups in hardware description tasks.",
      "description_length": 603,
      "index": 300,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Enum.Make_one_hot",
      "library": "hardcaml",
      "description": "This module supports mapping, folding, and combinational logic operations on one-hot encoded enumeration types, represented via polymorphic `'a t` structures alongside `Cases.t` and `Bits.t` for hardware-specific signal manipulation. It enables efficient state machine synthesis, enum-to-signal conversion, and metadata-driven interface transformations, with unsafe utilities for name-based port resolution and raw bit-level operations in performance-critical paths.",
      "description_length": 466,
      "index": 301,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Interface.Ast",
      "library": "hardcaml",
      "description": "This module represents the structure of an interface as a list of abstract syntax tree (AST) nodes, capturing how the interface is composed from fields, arrays, lists, and sub-modules. It provides a `sexp_of_t` function for converting the AST into an S-expression, enabling serialization and inspection of interface structures. It is used primarily in code generation workflows, such as creating register interface specifications from interface definitions.",
      "description_length": 457,
      "index": 302,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Flags_vector.Make",
      "library": "hardcaml",
      "description": "This module enables functional transformations and bit-level manipulations of structured hardware interfaces, supporting zipping, mapping, and serialization across polymorphic vector types and bitvectors (`comb t`). It facilitates type-safe circuit construction through combinational logic operations, signal conversion, and register creation, targeting hardware designs that require precise signal encoding, width validation, or interface introspection. Use cases include control logic synthesis, register-transfer-level modeling, and configuration-driven hardware serialization.",
      "description_length": 580,
      "index": 303,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Always.Variable",
      "library": "hardcaml",
      "description": "This module defines variables used in `always` blocks for hardware description, supporting both combinational `wire` and sequential `reg` types. It provides operations to create and manipulate these variables, including pipeline generation, enable-controlled registers, and access to the current signal value. Use cases include building stateful logic circuits, control paths, and pipelined dataflows directly within `always` blocks.",
      "description_length": 433,
      "index": 304,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Bits.Expert",
      "library": "hardcaml",
      "description": "This module provides low-level operations for manipulating bit sequences, including direct access to the underlying byte representation and data offsets. It works with `Hardcaml.Bits.t`, which represents fixed-width bit sequences that can be interpreted as signed or unsigned integers. Use cases include efficient bit-level serialization, custom memory layouts, and performance-critical bit manipulation where direct access to the internal representation is required.",
      "description_length": 467,
      "index": 305,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Fifo.Unsafe_assoc_by_port_name",
      "library": "hardcaml",
      "description": "This module provides direct, unsafe conversions between FIFO instances and association lists keyed by port names. It works with `Hardcaml.Fifo.t` values and string-augmented data pairs. Use this module when inspecting or modifying FIFO internals via port names, such as for debugging or custom serialization.",
      "description_length": 308,
      "index": 306,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Cross_product",
      "library": "hardcaml",
      "description": "This module provides structured manipulation of hardware interfaces through product types with tagged fields, enabling operations like zipping, mapping, and folding over signal bundles while tracking port metadata such as names and widths. It works with polymorphic interface types (`'a t`), association lists, and bit-level representations to support use cases including combinational logic synthesis, signal wiring, and precise circuit construction with named, typed fields. Key utilities include converting between structured interfaces and external representations, computing signal offsets, and handling synchronous logic assignments through lifted monadic operations.",
      "description_length": 673,
      "index": 307,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Scope.Path",
      "library": "hardcaml",
      "description": "This module represents and manipulates hierarchical paths used for naming signals in a circuit design. It provides operations to convert paths to strings or lists, using a configurable separator, and supports hierarchical navigation. Use it when building or inspecting signal names in a structured, nested circuit context.",
      "description_length": 322,
      "index": 308,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Logic.Std_logic",
      "library": "hardcaml",
      "description": "This module provides operations for modeling and verifying digital circuits using a 9-value logic system, supporting states like uninitialized, unknown, logic 0/1, high impedance, and weak signals. It works with the `std_logic` type to enable comparisons, integer/character encoding, state inspection via predicates (e.g., `is_h`, `u_val`), and conversions between logic states and other representations. These capabilities are critical for tasks like circuit simulation, testbench generation, and formal verification where precise handling of digital signal behavior is required.",
      "description_length": 580,
      "index": 309,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Rtl.Digest",
      "library": "hardcaml",
      "description": "This module computes and manipulates circuit digests for identifying and comparing hardware designs. It supports creating digests from circuits using a specified RTL language, converting digests to strings or constants, and parsing them from Verilog source. Typical use cases include tracking changes in circuit implementations and generating unique identifiers for circuit variants.",
      "description_length": 383,
      "index": 310,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Vcd.Scope",
      "library": "hardcaml",
      "description": "This module organizes signal hierarchies for VCD output using structured scopes such as `Begin`, `Module`, and `Fork`. It supports creating and traversing nested scopes with associated variables, enabling precise signal grouping and hierarchy representation in simulation dumps. Functions include scope construction, variable collection, and hierarchical traversal for VCD header generation.",
      "description_length": 391,
      "index": 311,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Constant.Expert",
      "library": "hardcaml",
      "description": "This module provides low-level operations for constructing and manipulating constant values with precise bit-widths, including functions to create constants from integers, booleans, and strings, and to perform bitwise and arithmetic operations. It works directly with the `t` type representing hardware constants and `Base.int` for specifying bit widths. Concrete use cases include synthesizing immediate values in hardware descriptions and optimizing constant propagation during circuit compilation.",
      "description_length": 500,
      "index": 312,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Constant.Raw",
      "library": "hardcaml",
      "description": "This module converts constants to and from raw bit patterns stored in strings and byte buffers. It supports padding and resizing during conversion, ensuring correct width representation. Use cases include serializing hardware constants for storage or transmission and deserializing bit patterns into fixed-width constants for simulation or synthesis.",
      "description_length": 350,
      "index": 313,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Circuit.With_interface",
      "library": "hardcaml",
      "description": "This module creates hardware circuits from input and output interface definitions, automatically labeling inputs and outputs based on those interfaces. It directly works with `Hardcaml.Interface.Create_fn(I)(O).t` as the circuit definition and produces `Hardcaml.Circuit.t` values. Use it to construct circuits with well-defined, structured I/O without manually wiring ports.",
      "description_length": 375,
      "index": 314,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Cyclesim.With_interface",
      "library": "hardcaml",
      "description": "This module creates and manipulates cycle-accurate simulators with explicitly typed input and output interfaces. It supports operations to instantiate simulators from circuits with defined input/output types, coerce raw port lists to interface-typed ports, and serialize simulator state. It is used to simulate hardware designs with strict interface definitions, enabling testbenches that interact with hardware models through well-defined signals.",
      "description_length": 448,
      "index": 315,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Assertions.Always",
      "library": "hardcaml",
      "description": "This module adds assertions to Hardcaml simulations using signals and scoped identifiers, primarily through the `add` function. It works with `Scope.t`, `Signal.t`, and `Always.t` types to define and track assertions within simulation blocks. Use it to embed and monitor design checks directly in simulation traces by attaching signal-based conditions to always blocks.",
      "description_length": 369,
      "index": 316,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Assertions.Violated_or_not",
      "library": "hardcaml",
      "description": "This module defines a type `t` to represent the outcome of assertions in Hardcaml simulations, either `Violated` with a list of failing cycle numbers or `Not_violated`. It includes a function `sexp_of_t` to serialize these outcomes into S-expressions. Use this module to capture and report assertion results during hardware simulation runs.",
      "description_length": 340,
      "index": 317,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Signal.Uop",
      "library": "hardcaml",
      "description": "This module implements arithmetic and comparison operations for unsigned bit vectors, working directly with `Signal.t` values. It supports addition, subtraction, multiplication, and comparisons like less than or equal, with automatic bit-width extension to prevent truncation. Use cases include building arithmetic logic units, comparators, or counters in hardware descriptions.",
      "description_length": 378,
      "index": 318,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Logic.Four_state_vector",
      "library": "hardcaml",
      "description": "This module supports creation, manipulation, and arithmetic operations on four-state logic vectors (composed of `Four_state.t` values representing 0, 1, X, Z states) for digital logic simulation. It provides utilities for bit-level operations (selection, insertion, shifting), logical and arithmetic expressions with explicit handling of unknown/high-impedance states, and conversions between integers, strings, and bit vectors with signed/unsigned interpretations. Designed for hardware modeling tasks like ALUs and control logic, it enables precise simulation of digital signals with variable-width operations, sign/zero extensions, and tree-based reductions.",
      "description_length": 661,
      "index": 319,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Types.Pair",
      "library": "hardcaml",
      "description": "This module implements type-safe operations for pairing, transforming, and comparing values of type `Data.t * Data.t`, supporting tasks such as mapping, folding, and comparison. It works directly with hardware interface elements like bit vectors and combinational signals, enabling RTL design workflows such as signal routing, register insertion, and structured interface manipulation. Concrete use cases include dual signal representation in circuit synthesis and parallel transformation of hardware data during logic generation.",
      "description_length": 530,
      "index": 320,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.With_valid.Vector",
      "library": "hardcaml",
      "description": "This module provides polymorphic vector operations for mapping, zipping, and folding over multiple typed vectors in parallel, along with conversions between lists and structured interfaces. It works with vectors indexed by port names or tags, supporting hardware description tasks like combinational logic synthesis, bit vector manipulation, and register/wire management using Always blocks. Key applications include RTL design for precise bit-level control, interface metadata handling, and sequential circuit construction with monadic sequencing.",
      "description_length": 548,
      "index": 321,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Structural.Lib",
      "library": "hardcaml",
      "description": "This module implements register and tri-state buffer primitives for hardware description. It operates on `Hardcaml.Structural.signal` values, representing digital signals in a hardware design. These functions are used to model synchronous logic with clocked registers and tri-state buffers for bus interfacing.",
      "description_length": 310,
      "index": 322,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.With_valid.Wrap",
      "library": "hardcaml",
      "description": "This module implements structural transformations and compositional operations for hardware interfaces tagged with valid signals. It works with structured interfaces (`'a t`), bit vectors, signals, and port metadata, providing operations like mapping, zipping, folding, and monadic lifting across named ports. Use it to build pipelines, register files, or communication protocols where data flows are qualified by validity signals.",
      "description_length": 431,
      "index": 323,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Scope.Naming_scheme",
      "library": "hardcaml",
      "description": "This module defines naming strategies for signals in hierarchical circuits, with options to use auto-generated full paths, local paths, or no path prefixing. It works with hierarchical module structures to control how signal names are generated during circuit compilation. Use this to manage name collisions or improve debug visibility in complex hardware designs.",
      "description_length": 364,
      "index": 324,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Vcd.Var",
      "library": "hardcaml",
      "description": "This module manages variable declarations in VCD files by associating names with unique identifiers and signal types. It supports operations to create variables, retrieve their properties (type, name, ID, width), and write value changes to an output channel using functions like `write_bits` or `write_string`. Concrete use cases include tracking signal transitions in digital simulations and generating waveform data consumable by tools like GTKWave.",
      "description_length": 451,
      "index": 325,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.With_valid.Fields",
      "library": "hardcaml",
      "description": "This module supports mapping, zipping, and converting interface fields paired with valid signals, handling tuples of signals up to five elements. It operates on structured interfaces represented as `'a With_valid.t X.t`, enabling transformations, combinations, and folding operations. Use it to model hardware pipelines, manage signal validity, and perform interface-to-port mappings in digital circuit design.",
      "description_length": 410,
      "index": 326,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Bits_list.Int_comb",
      "library": "hardcaml",
      "description": "This module supports bit-level manipulation, arithmetic, and conversion operations on integer vectors represented as lists of discrete logic levels (`0` or `1`). It provides combinational logic primitives for constructing and transforming bit vectors through logical operations, arithmetic (addition, multiplication, negation), comparisons, resizing (sign/zero extension), shifting, and structural manipulations like concatenation or slicing, while maintaining explicit control over bit ordering and width. Typical applications include modeling digital circuits such as arithmetic logic units, data path components, or control logic where precise bit-level operations and combinational signal processing are required.",
      "description_length": 717,
      "index": 327,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Cyclesim_float_ops.Float",
      "library": "hardcaml",
      "description": "This module implements 32-bit floating-point arithmetic and mathematical operations\u2014including basic algebraic functions, trigonometric and hyperbolic operations, and logarithmic computations\u2014using combinational logic networks to process `Hardcaml.Signal.t` values. These operations transform hardware signals element-wise, enabling precise numerical simulations in digital circuit design contexts. It specifically supports simulation workflows requiring high-fidelity floating-point calculations for signal processing or computational hardware modeling.",
      "description_length": 553,
      "index": 328,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Signal.Signed",
      "library": "hardcaml",
      "description": "This module implements arithmetic and comparison operations for signed binary vectors, including addition, subtraction, multiplication, and comparisons like less than or equal. It works with the `v` type representing signed signals, supporting variable-width operands and automatic sign extension. Use cases include implementing arithmetic logic units (ALUs) and control logic that requires signed integer operations in hardware designs.",
      "description_length": 437,
      "index": 329,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Fifo.Of_signal",
      "library": "hardcaml",
      "description": "This module enables the construction and transformation of synchronous FIFO structures using signal-based combinational and sequential logic operations, including multiplexing, concatenation, and pipeline insertion. It operates on FIFO signal interfaces (`Of_signal.t`), providing explicit control over input/output wiring, signal naming, and hierarchical composition for hardware modeling. Typical applications include data buffering in pipelined digital circuits, protocol bridging with dynamic signal selection, and structured FIFO hierarchy generation with customizable signal annotations.",
      "description_length": 593,
      "index": 330,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Rtl.Vhdl",
      "library": "hardcaml",
      "description": "Converts a hardware description in RTL AST form into VHDL code, writing the result directly to a buffer. Works with the `Rtl_ast.t` type representing circuit structures and signal connections. Useful for generating synthesizable VHDL from Hardcaml circuit definitions.",
      "description_length": 268,
      "index": 331,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Enum.Make_binary",
      "library": "hardcaml",
      "description": "This module provides functions to convert between enumeration types and their binary representations (e.g., `Bits.t`, `Signal.t`) while supporting operations like mapping, folding, and combinational logic on binary-encoded hardware interfaces. It operates on tuples or lists of hardware signals (`'a t`), association lists pairing names with values,",
      "description_length": 349,
      "index": 332,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Fifo.With_interface",
      "library": "hardcaml",
      "description": "This module implements FIFOs using structured hardware interfaces, enabling operations like mapping, zipping, and bit-level manipulation of FIFO ports. It works with typed interface values (`I.t`) that carry port metadata such as names and bit-widths, supporting tasks like signal routing and register assignment in synchronous circuits. Concrete use cases include building pipelined FIFOs with precise control over port behavior, integrating FIFOs into HDL workflows with automatic signal declarations, and implementing showahead functionality with register-staged data aggregation.",
      "description_length": 583,
      "index": 333,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Instantiation.With_interface",
      "library": "hardcaml",
      "description": "Instantiates RTL designs with explicitly defined input and output interfaces, supporting parameterized configuration and attribute assignment. Works with interface modules I and O to define port mappings and data types. Useful for integrating generated RTL blocks with customizable instance names, libraries, and synthesis directives.",
      "description_length": 334,
      "index": 334,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Scalar",
      "library": "hardcaml",
      "description": "This module enables functional manipulation of structured hardware signal interfaces through operations like mapping, zipping, and folding over scalar signals, with support for combinational logic synthesis and bitwidth-aware transformations. It works with scalar signal types, tuples of signals, and metadata-rich interfaces that include port names, widths, and hierarchical tags, facilitating precise control over hardware representation. Key use cases include hardware interface synthesis, register pipeline construction, and bit-level signal aggregation while maintaining alignment with hardware description semantics.",
      "description_length": 622,
      "index": 335,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Hierarchy.In_scope",
      "library": "hardcaml",
      "description": "This module provides functions to create and manage hierarchical Hardcaml designs by extending the interface creation pattern with a scope argument. It works with signal and circuit data types, enabling scoped signal naming and automatic design recording in a circuit database. Concrete use cases include building modular circuits for simulation or synthesis where hierarchical structure is required, such as instantiating child modules within a parent design.",
      "description_length": 460,
      "index": 336,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Fifo.Of_always",
      "library": "hardcaml",
      "description": "Implements FIFO operations using always-block variables, providing direct manipulation of FIFO signals through assignment, registration, and wiring. Works with `Always.Variable.t` and `Signal.t` types structured as FIFOs. Enables building synchronous FIFOs with precise control over enable signals, register specifications, and signal naming.",
      "description_length": 342,
      "index": 337,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Bits_list.X",
      "library": "hardcaml",
      "description": "This module represents logic values with support for undefined states (`X`), alongside standard boolean values (`F`, `T`). It provides logical operations such as AND (`&:`), OR (`|:`), XOR (`^:`), and NOT (`~:`), as well as conversions to and from characters. Use this module when modeling digital circuits with tri-state logic or handling signal propagation where unknown values are semantically significant.",
      "description_length": 409,
      "index": 338,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Rtl.Output_mode",
      "library": "hardcaml",
      "description": "This module defines output destinations for RTL generation, supporting writing circuits to files, buffers, or channels. It includes variants for specifying directories, single files, or direct output streams. Use cases include directing Verilog or VHDL output to disk, in-memory buffers, or custom output channels during hardware compilation.",
      "description_length": 342,
      "index": 339,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Signal_graph.Deps_for_loop_checking",
      "library": "hardcaml",
      "description": "This module processes signal dependencies in a graph, allowing traversal and transformation of signals while accommodating loops through instantiations. It provides operations like `fold`, `iter`, `map`, and `to_list` to process dependencies in a defined order. Use cases include analyzing signal propagation paths and generating ordered signal lists for simulation or scheduling.",
      "description_length": 380,
      "index": 340,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Vcd.Timescale",
      "library": "hardcaml",
      "description": "Represents and manipulates VCD timescale units (e.g., nanoseconds, picoseconds) with valid integer prefixes (1, 10, 100). Provides conversion to string and S-expression formats. Used to define time units in VCD file headers for simulation waveform output.",
      "description_length": 255,
      "index": 341,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Cyclesim.Port_list",
      "library": "hardcaml",
      "description": "Handles lists of named simulation ports with mutable bit values. Provides functions to create, update, and query port values during cycle-accurate simulation runs. Useful for tracking and modifying register or signal states at specific simulation steps.",
      "description_length": 253,
      "index": 342,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Bits_list.Make",
      "library": "hardcaml",
      "description": "This module supports the creation of fixed-width bit vectors from integers, strings, and boolean values, along with bit-level manipulations such as selection, concatenation, shifting, and resizing. It enables arithmetic operations, logical computations, and comparisons on bit vectors\u2014with explicit handling of signed and unsigned representations\u2014while providing utilities for encoding transformations, priority selection, and hardware synthesis optimizations. These capabilities are used to model combinational digital circuits for components like arithmetic logic units, control logic, and data path elements requiring precise bit-level control.",
      "description_length": 647,
      "index": 343,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Fifo.Kinded_fifo",
      "library": "hardcaml",
      "description": "Implements synchronous FIFOs with support for `classic` and `showahead` modes, providing distinct signal interfaces for write, read, and control operations. Works with `Hardcaml.Signal.t` values and parametrizes behavior via type indices `(`Classic` and `Showahead`). Used to model hardware FIFOs in digital designs where precise control over data flow and pipeline stages is required.",
      "description_length": 385,
      "index": 344,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Interface.Update",
      "library": "hardcaml",
      "description": "This module enables transforming, combining, and analyzing hardware interfaces through operations like mapping, zipping, and converting between association lists and bit-level representations. It works with interfaces composed of typed, named ports, supporting tasks like dynamic reconfiguration, error aggregation, and combinational logic synthesis. Specific capabilities include programmatically adjusting port names or widths, packing/unpacking signal vectors, and integrating with simulation or synthesis workflows via structured transformations of registers, signals, and Always API variables.",
      "description_length": 598,
      "index": 345,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.List",
      "library": "hardcaml",
      "description": "This module implements list-based transformations and combinational logic for hardware description tasks, supporting operations like mapping, folding, zipping, and parallel iteration across polymorphic records and bit vectors. It works with RTL-specific data structures such as port-named interfaces, signal bundles, and width-tagged registers, enabling dynamic field access, serialization, and conversion between list and interface representations. Key use cases include synthesizing digital circuits, managing hierarchical signal hierarchies, and automating port-width consistency checks in register-transfer level designs.",
      "description_length": 625,
      "index": 346,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Cyclesim.Memory",
      "library": "hardcaml",
      "description": "This module implements cycle-accurate memory simulation with typed read/write operations for both mutable and immutable bit vectors. It supports memory initialization from byte arrays, signals, or pre-allocated storage, and provides direct access to memory contents via address-indexed 64-bit operations. Concrete use cases include modeling instruction/data memory in CPU simulations and implementing testable hardware memory blocks with precise timing behavior.",
      "description_length": 462,
      "index": 347,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.With_valid",
      "library": "hardcaml",
      "description": "This module provides functions for serializing and manipulating hardware interface values paired with explicit validity signals, supporting operations like mapping, iteration, and structured record-like access. It works with generalized wrapper types (`With_valid.t`, `With_valid.t2`) that pair data with validity indicators, and includes utilities for vector operations, synchronous communication, and AXI stream/FIFO patterns. These capabilities are particularly useful for RTL designs requiring precise control over data validity and handshake protocols in hardware pipelines.",
      "description_length": 579,
      "index": 348,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Array",
      "library": "hardcaml",
      "description": "This module provides structural transformations and metadata-aware operations on arrays of hardware ports and signals, enabling typed access, combination, and serialization with port names, widths, and tags. It supports bit-level manipulation, combinational logic synthesis, and register-transfer-level circuit construction through functions for mapping, zipping, folding, and monadic lifting over structured interfaces. Use cases include signal routing, interface packing/unpacking, and hardware description tasks requiring precise port associations or dynamic array restructuring.",
      "description_length": 582,
      "index": 349,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Comb.Make",
      "library": "hardcaml",
      "description": "This module generates a combinational logic API for hardware design, offering arithmetic operations (addition, multiplication), logical operators (AND, XOR), and bit-level manipulations (selection, shifting, concatenation) on fixed-width bitvectors (`t`) representing digital signals. It supports signed and unsigned comparisons, multiplexers, and conversions between signals and primitive types (integers, strings, booleans), enabling tasks like control logic synthesis, data path modeling, and register-level operations. Specialized utilities for overflow handling, priority selection, and tree-based reductions optimize circuit synthesis for FPGA or ASIC implementations.",
      "description_length": 674,
      "index": 350,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Value",
      "library": "hardcaml",
      "description": "This module supports structured manipulation of hardware interfaces through mapping, zipping, and folding operations, along with combinational logic for bit-level transformations like packing, unpacking, and multiplexing. It operates on port-based values (`'a t`), signals, and metadata tuples, enabling tasks such as interface serialization, structured hardware modeling, and sequential logic design within always blocks. Key patterns include monadic composition for error handling, offset calculation for signal alignment, and functional signal manipulation to bridge high-level abstractions with low-level hardware descriptions.",
      "description_length": 631,
      "index": 351,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Structural.Base",
      "library": "hardcaml",
      "description": "This module provides low-level signal manipulation capabilities for structural hardware design, including arithmetic operations, bitwise logic, and bit-level concatenation or selection. It operates on a signal type `t` representing wires or hardware signals, enabling tasks like tri-state management, combinational circuit synthesis, and arithmetic computation in circuit descriptions. Specific use cases include constructing and transforming digital circuits where precise control over signal behavior and structural representation is required.",
      "description_length": 545,
      "index": 352,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Bits.Signed",
      "library": "hardcaml",
      "description": "This module provides operations for working with signed fixed-width bit vectors, including arithmetic (addition, subtraction, multiplication) and comparison operators that handle sign extension automatically. It supports conversions to and from standard bit vectors and allows resizing with sign extension. Concrete use cases include implementing arithmetic logic units (ALUs) and performing bit-accurate signed integer computations in hardware descriptions.",
      "description_length": 458,
      "index": 353,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Cyclesim.Combine_error",
      "library": "hardcaml",
      "description": "Handles errors during cycle-accurate simulation by capturing discrepancies in signal values at specific ports and clock edges. Works with simulation state data, including cycle numbers, clock edges, port names, and bit vectors. Used to report mismatches between expected and actual signal values during simulation steps.",
      "description_length": 320,
      "index": 354,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Fifo.Make_comb",
      "library": "hardcaml",
      "description": "This module implements combinational logic operations for manipulating FIFO structures with packed data representations. It provides functions for packing and unpacking FIFO values to and from a flat combinatorial type, multiplexing between FIFO values using priority or one-hot selection, and converting between integer values and FIFO structures. These operations are used to build register-transfer level (RTL) circuits where FIFO behavior is modeled using combinational logic without synchronous state elements.",
      "description_length": 515,
      "index": 355,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Enum.Make_enums",
      "library": "hardcaml",
      "description": "This module creates specialized enumeration interface modules for binary and one-hot encoded hardware signals. It provides operations to convert between bit vectors and enumerated types, perform structured traversal, and construct combinational logic for state machines and control circuits. It works directly with hardware-specific types like `Signal.t`, `Bits.t`, and tagged encodings (`Binary.t`, `One_hot.t`) to enable precise bit-level manipulation and synthesis.",
      "description_length": 468,
      "index": 356,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Cyclesim.Config",
      "library": "hardcaml",
      "description": "This module defines configuration options for the cycle-accurate simulator, controlling signal visibility, combinational operation substitution, signal deduplication, and circuit storage. It works with simulation configurations, signals, and combinational operation databases. Use it to customize simulation behavior, such as selecting which signals to trace or enabling optimizations during simulation compilation.",
      "description_length": 415,
      "index": 357,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Ram.Collision_mode",
      "library": "hardcaml",
      "description": "This module defines comparison and ordering operations for collision resolution modes in RAM configurations. It supports the two primary modes\u2014`Read_before_write` and `Write_before_read`\u2014and provides functions to compare, sort, and constrain these values. These operations are used to determine behavior during memory access conflicts, particularly when inferring RAM behavior in RTL synthesis.",
      "description_length": 394,
      "index": 358,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Rtl.Verilog",
      "library": "hardcaml",
      "description": "Converts a hardware description in RTL AST format into Verilog code, writing the result directly to a buffer. Works with the `Hardcaml__.Rtl_ast.t` type, which represents the abstract syntax tree of a hardware design. Useful for generating synthesizable Verilog output from a high-level hardware specification in Hardcaml workflows.",
      "description_length": 332,
      "index": 359,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Cyclesim_float_ops.Double",
      "library": "hardcaml",
      "description": "This module provides 64-bit floating-point arithmetic and mathematical operations\u2014including addition, multiplication, trigonometric functions, logarithms, and rounding\u2014on signals representing double-precision numbers. It leverages a combinational operations database to simulate hardware behavior, enabling precise modeling of floating-point computations in digital circuits for applications like signal processing or numerical analysis.",
      "description_length": 437,
      "index": 360,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Rtl.Signals_name_map",
      "library": "hardcaml",
      "description": "Maps signal UIDs paired with indices to string representations for unique RTL name mangling during Verilog generation. It uses a specialized key type to ensure distinct naming across signal instances in hardware descriptions. Used directly in workflows involving signal renaming for Verilator integration.",
      "description_length": 305,
      "index": 361,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Signal.Unsigned",
      "library": "hardcaml",
      "description": "This module provides operations for manipulating unsigned binary vectors, including arithmetic operations like addition, subtraction, and multiplication, as well as comparison operations for equality and ordering. It supports fixed-width bit vectors represented by the type `v`, which can be converted to and from standard combinational signals. These operations are used to implement digital logic circuits such as counters, arithmetic units, and control logic where unsigned integer values are processed directly in hardware descriptions.",
      "description_length": 540,
      "index": 362,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Rtl.Language",
      "library": "hardcaml",
      "description": "This module defines types and functions for working with hardware description languages. It includes a variant type representing Verilog and VHDL, a function to convert these values to S-expressions, and a function to retrieve the corresponding file extension. It is used to support language-specific operations in hardware compilation workflows.",
      "description_length": 346,
      "index": 363,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Rtl.Blackbox",
      "library": "hardcaml",
      "description": "This module defines a type `t` with three variants (`None`, `Top`, `Instantiations`) that control how blackboxes are generated during RTL compilation. It includes a function `sexp_of_t` to serialize these values into S-expressions. Use this module to specify blackbox behavior when generating hardware descriptions, such as when integrating with external synthesis tools or managing hierarchical designs.",
      "description_length": 404,
      "index": 364,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Signal_graph.Deps_for_simulation_scheduling",
      "library": "hardcaml",
      "description": "This module computes dependencies of a signal for simulation scheduling, breaking loops through sequential elements like registers and memories. It provides traversal operations such as `fold`, `iter`, `map`, and `to_list` over the dependencies of a signal. These functions are used to determine the order of signal evaluation during simulation, ensuring correct handling of combinational and sequential logic.",
      "description_length": 410,
      "index": 365,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Bits_list.Bool_comb",
      "library": "hardcaml",
      "description": "This module implements combinational logic operations on boolean lists treated as bit vectors, offering arithmetic (addition, multiplication), logical (AND/OR/XOR), comparison (signed/unsigned), and bit manipulation (shifting, concatenation, field extraction). It works with lists of booleans as fixed-width binary values, supporting conversions to/from integers, strings, and numeric types while enabling precise control over endianness, sign extension, and bit-level composition. Typical applications include digital circuit design for data path operations, hardware verification testbenches, and low-level bitstream processing with variable-width signals.",
      "description_length": 658,
      "index": 366,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Signal.Unoptimized",
      "library": "hardcaml",
      "description": "This module offers combinational logic operations for bit-level manipulation, arithmetic, and type conversion on fixed-width hardware signals. It provides utilities for constructing and transforming `Hardcaml.Signal.t` values through unoptimized primitives like bitwise operations, arithmetic (addition, multiplication), comparisons, multiplexing, and width-aware concatenation/selection, while preserving explicit control over signal behavior. Designed for hardware modeling tasks requiring precise signal representation, it supports use cases such as building arithmetic logic units, control logic, and bitfield manipulators where constant propagation or optimization might obscure intentional design semantics.",
      "description_length": 713,
      "index": 367,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Circuit.Config",
      "library": "hardcaml",
      "description": "Controls circuit construction behavior with options like combinational loop detection, UID normalization, port validation, and output signal modification. Works with hardware circuits built from signals and interfaces, influencing how they are validated and structured during creation. Used when instantiating circuits to enforce consistency, enable simulation-specific optimizations, or manage unused interface inputs.",
      "description_length": 419,
      "index": 368,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Rtl.Deprecated",
      "library": "hardcaml",
      "description": "This module handles signal identification and code generation for hardware description languages. It pairs signal UIDs with indices for ordering and serialization, and provides functions to generate legal VHDL and Verilog code from circuits, including name sanitization to comply with language-specific naming rules. Use it to export hardware designs to VHDL or Verilog formats for synthesis, simulation, or debugging.",
      "description_length": 418,
      "index": 369,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Fifo.Names_and_widths",
      "library": "hardcaml",
      "description": "This module defines and exposes the names and widths of ports used in synchronous FIFO implementations, along with associated tags. It provides direct access to lists of port names, their corresponding widths, and FIFO-specific tags for configuration and introspection. Use this module to retrieve metadata about FIFO port structure for simulation, testing, or integration with hardware description tools.",
      "description_length": 405,
      "index": 370,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Bits.Uop",
      "library": "hardcaml",
      "description": "This module performs arithmetic and comparison operations on unsigned bit vectors, including addition, subtraction, multiplication, and comparisons like less than or equal. It supports resizing bit vectors to specified widths and converting between bit vectors and signals. These operations are used to implement digital logic circuits where precise control over bit-level representations and operations is required.",
      "description_length": 416,
      "index": 371,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Rtl_attribute.Value",
      "library": "hardcaml",
      "description": "This module defines a polymorphic type `t` that represents attribute values as integers, strings, or booleans. It includes functions for equality comparison and S-expression serialization of these values. It is used to specify and serialize RTL attribute data for downstream tooling such as synthesis or simulation tools.",
      "description_length": 321,
      "index": 372,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Rtl.Ast",
      "library": "hardcaml",
      "description": "This module provides an abstract syntax tree (AST) for representing register-transfer level (RTL) hardware designs, supporting operations like structural equality checks, S-expression serialization, and conversion of circuit elements into AST nodes. It works with data structures modeling hardware constructs such as typed variables, binary operations (arithmetic, bitwise), conditional logic (muxes, selects), memory declarations, and hierarchical submodule instantiations. The AST facilitates tasks like Verilator integration through signal name mangling, sequential logic modeling with sensitivity lists, and precise signal referencing in both combinational and clocked contexts.",
      "description_length": 682,
      "index": 373,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Circuit.Signal_map",
      "library": "hardcaml",
      "description": "Maps unique identifiers to signal values within a circuit. Supports lookup and insertion operations for associating signals with their unique identifiers. Useful for tracking and managing individual signals in a circuit during simulation or analysis.",
      "description_length": 250,
      "index": 374,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Cyclesim.Private",
      "library": "hardcaml",
      "description": "This module implements the core simulation engine for cycle-accurate hardware testing, managing signal propagation, register updates, and memory state transitions across simulation phases. It operates on hardware description types like `port_list`, `node`, `reg`, and `memory`, coordinating tasks such as reset assertion, clock edge processing, and output evaluation. Concrete use cases include simulating synchronous digital circuits with precise timing control, enabling tasks like functional verification and waveform tracing for design validation.",
      "description_length": 551,
      "index": 375,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Always.State_machine",
      "library": "hardcaml",
      "description": "This module implements state machines within the Always DSL, using registers to store state and supporting conditional transitions via `if` and `switch` constructs. It works with user-defined state types that conform to the `State` module type, and applies encodings like Binary, Gray, or Onehot to represent states in generated HDL. Use it to describe synchronous state machines with explicit transition logic and custom register specifications.",
      "description_length": 446,
      "index": 376,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Interface.Make_interface_with_conversion",
      "library": "hardcaml",
      "description": "This module enables defining and transforming hardware interfaces through function conversions, supporting bulk operations like mapping over tagged fields, combining hierarchical signals, and bit-level manipulations. It works with structured signal groups represented as tuples, lists, or named hierarchies, facilitating tasks such as manual interface creation without PPX, integrating register logic via always blocks, and validating signal widths during bit-packing. Key applications include low-level signal routing, metadata extraction for signal hierarchies, and constructing combinational logic across complex interface topologies.",
      "description_length": 637,
      "index": 377,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Logic.Std_logic_vector",
      "library": "hardcaml",
      "description": "This module offers bit-level manipulation, arithmetic, and comparison operations on fixed-width bit vectors, including signed and unsigned addition, subtraction, multiplication, and logical operations. It supports conversions between bit vectors and numeric or string representations, along with utilities for resizing, shifting, and priority selection, commonly used in digital circuit design for implementing arithmetic logic units, control circuits, and signal processing components. Key patterns include precise width management, combinational logic construction, and simulation tasks requiring bit-accurate modeling.",
      "description_length": 621,
      "index": 378,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Hierarchy.With_interface",
      "library": "hardcaml",
      "description": "This module supports creating and managing hierarchical subcircuits with explicit input and output interfaces. It provides the `create` function to instantiate subcircuits within a given database, allowing for structured circuit design. Concrete use cases include building complex digital circuits by composing smaller, well-defined modules with specified interfaces.",
      "description_length": 367,
      "index": 379,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Constant.Make_bit_list",
      "library": "hardcaml",
      "description": "Converts between lists of `Bit.t` values and `Hardcaml.Constant.t` values. Works directly with `Bit.t` lists and `Hardcaml.Constant.t` for representing fixed-width constants. Useful when constructing hardware descriptions that require bit-level manipulation and constant initialization from list-based bit representations.",
      "description_length": 322,
      "index": 380,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Interface.Make",
      "library": "hardcaml",
      "description": "This module enables composing and transforming hierarchical signal groups with named ports, widths, and tags through operations like zipping, mapping, and folding over structured interfaces. It works with parameterized interface types (`X.t`) representing signal vectors, always blocks, and bit-level encodings, supporting use cases like pipeline register insertion, multiplexing, and sequential logic synthesis. Key utilities include converting interfaces to association lists for inspection, validating signal structures during simulation, and generating port definitions from named, width-annotated signals.",
      "description_length": 610,
      "index": 381,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Fifo.All",
      "library": "hardcaml",
      "description": "This module provides a transformation that distributes a FIFO across a module context, converting a FIFO of module values into a module of FIFOs. It operates on parametric module types `'a M.t` and associated FIFO structures. Useful for instantiating separate FIFOs within each instance of a module, such as in dataflow pipelines with replicated stages.",
      "description_length": 353,
      "index": 382,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Rtl_attribute.Vivado",
      "library": "hardcaml",
      "description": "This module defines Xilinx Vivado-specific RTL attributes for controlling synthesis behavior, such as register synchronization, state machine encoding, and net preservation. It operates on `Hardcaml.Rtl_attribute.t` values, targeting registers, nets, modules, and ports in HDL code. Use cases include preventing optimization on critical paths, specifying FSM encodings, marking nets for debugging, and constraining RAM or SRL implementation styles during synthesis.",
      "description_length": 465,
      "index": 383,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Logic.Bit_vector",
      "library": "hardcaml",
      "description": "This module provides functions for constructing, converting, and manipulating bit vectors represented as integer lists. It supports arithmetic (addition, multiplication), bitwise (AND, OR, shifts), logical (comparisons, implication), and structural operations (concatenation, bit selection, resizing), with distinct handling for signed and unsigned interpretations. These capabilities are used in digital circuit design for modeling hardware signals, implementing arithmetic logic units, and synthesizing combinational or sequential circuits.",
      "description_length": 542,
      "index": 384,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Bits_list.X_comb",
      "library": "hardcaml",
      "description": "This module offers bit-level combinational logic operations for ternary bit lists (`F`, `T`, `X`), supporting arithmetic, logical, and conversion tasks such as addition, comparison, shifting, and encoding. It works with variable-width bit vectors represented as lists, enabling precise control over bit ordering (MSB/LSB), sign extension, and endianness-sensitive transformations. Use cases include hardware synthesis, digital signal processing, and simulation scenarios requiring fine-grained manipulation of binary data, such as implementing arithmetic units or encoding logic.",
      "description_length": 579,
      "index": 385,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Structural.Base0",
      "library": "hardcaml",
      "description": "The API provides operations for constructing and transforming structural signals through bit-level manipulations, arithmetic/logical operators, and comparison functions, working directly with the `t` type representing hardware signals. It supports tasks like combinational logic synthesis, circuit construction, and tri-state logic integration, with specific functions for concatenation, selection, and signed arithmetic operations. This enables low-level hardware description and optimization in FPGA or ASIC design flows.",
      "description_length": 523,
      "index": 386,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Interface.Create_fn",
      "library": "hardcaml",
      "description": "This module defines functions for implementing circuits that transform input interfaces into output interfaces, with types ensuring correct signal width and structure. It operates on input and output types parameterized by modules `I` and `O`, which describe the signal groups. Use this to define circuit implementations that map input signals to output signals in a type-safe way.",
      "description_length": 381,
      "index": 387,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Cyclesim.Reg",
      "library": "hardcaml",
      "description": "This module implements low-level register manipulation for a cycle-accurate simulation environment. It provides functions to create, read, and write registers from various data sources such as `Bits.Mutable.t`, `Signal.t`, and raw byte arrays, supporting operations like `get64`, `set64`, and conversion to and from bit representations. Use cases include modeling hardware registers in simulations, direct memory manipulation, and interfacing with low-level signal data.",
      "description_length": 470,
      "index": 388,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Parameter.Value",
      "library": "hardcaml",
      "description": "This module provides operations to construct parameter values of various types (bit vectors, integers, floats, strings), type-safe inspection via predicates and extraction functions, and S-expression serialization. It supports RTL design configuration tasks like hardware synthesis, design manipulation, and persistent storage of parameter settings through structured serialization.",
      "description_length": 382,
      "index": 389,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Structural.Base1",
      "library": "hardcaml",
      "description": "This module provides functions for manipulating hardware signals through concatenation, bit selection, arithmetic operations (including signed multiplication and comparisons), and logical operations. It operates on signals and constants, facilitating the construction of digital circuits and arithmetic logic units within a structural hardware generation framework.",
      "description_length": 365,
      "index": 390,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Bits.Sop",
      "library": "hardcaml",
      "description": "This module performs arithmetic and comparison operations on fixed-width bit vectors, including addition, subtraction, multiplication, and comparisons like less than or equal. It supports conversions between bit vectors and signals, and resizing bit vectors with sign extension. Use cases include implementing digital circuits where precise control over bit-level operations and signed integer representations is required.",
      "description_length": 422,
      "index": 391,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Vcd.Config",
      "library": "hardcaml",
      "description": "This module defines configuration parameters for VCD file headers, including date, version, optional comment, and timescale settings. It provides a default configuration, serialization to S-expressions, and writing to an output channel. Used to set up metadata when generating VCD files for waveform visualization.",
      "description_length": 314,
      "index": 392,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Instantiation.Expert",
      "library": "hardcaml",
      "description": "Handles low-level instantiation of sub-modules in generated RTL, allowing integration of external modules not written in Hardcaml. Works directly with module names and ports, validating and mapping signals appropriately. Useful when instantiating pre-synthesized components or black boxes with known interfaces.",
      "description_length": 311,
      "index": 393,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Cyclesim.Node",
      "library": "hardcaml",
      "description": "This module provides direct access to simulation node data through low-level operations like reading and writing bits, extracting integer values, and converting to and from mutable and immutable bit representations. It works with node values stored in byte arrays, supporting precise bit-width and memory layout operations. Concrete use cases include inspecting and modifying internal simulation state, interfacing with hardware descriptions at the bit level, and implementing custom serialization or debugging tools.",
      "description_length": 517,
      "index": 394,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Property.CTL",
      "library": "hardcaml",
      "description": "This module represents Computation Tree Logic (CTL) formulas using algebraic data types for states and paths. It provides constructors and combinators to build temporal logic expressions over atomic propositions, including logical operations and path quantifiers like `ax`, `ex`, `af`, and `ef`. Use this module to define formal verification properties for hardware designs, such as safety and liveness conditions, and manipulate these properties through transformation, serialization, and extraction of atomic components.",
      "description_length": 522,
      "index": 395,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Rtl.Name",
      "library": "hardcaml",
      "description": "This module enforces naming conventions for HDL identifiers by providing functions to legalize and mangle names according to specified language rules. It operates on strings and signal types, applying transformations to avoid reserved words and invalid characters. Concrete use cases include sanitizing signal and port names during Verilog or VHDL code generation to ensure compatibility with synthesis tools.",
      "description_length": 409,
      "index": 396,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Async_fifo.Make",
      "library": "hardcaml",
      "description": "This module implements asynchronous FIFOs with configurable depth and synchronization options, operating on hardware signals through structured input and output interfaces. It provides functions to create FIFOs with delayed output valid signals, enabling reliable packet buffering across clock domains. Use cases include clock domain crossing with controlled output timing and pipelined data transfer with guaranteed signal stability.",
      "description_length": 434,
      "index": 397,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Fifo.Of_bits",
      "library": "hardcaml",
      "description": "This module implements synchronous FIFOs using bit vectors, providing operations for packing and unpacking data, multiplexing between FIFOs, concatenation, and priority/one-hot selection logic. It works directly with `Hardcaml.Bits.t` and FIFO structures parameterized over those bits. Concrete use cases include building register-based data pipelines, managing data streams with variable width, and implementing arbitration logic in hardware designs.",
      "description_length": 451,
      "index": 398,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Caller_id.Mode",
      "library": "hardcaml",
      "description": "This module defines modes for embedding callstack information into signal types during creation, specifically supporting `Disabled`, `Top_of_stack`, and `Full_trace` options. It works with signal data structures to capture and display callstacks when exceptions occur, particularly useful for debugging dangling wires by showing their construction origin. Use cases include enabling detailed traceability in complex circuits during development or debugging, especially when precise signal origin tracking is required.",
      "description_length": 517,
      "index": 399,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Circuit.Port_checks",
      "library": "hardcaml",
      "description": "This module validates that the ports declared in a circuit's interface match the actual ports defined within the circuit. It supports checking for agreement in port sets and optionally their widths, based on the specified validation level. Use it during circuit construction to catch interface mismatches before simulation or synthesis.",
      "description_length": 336,
      "index": 400,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Always",
      "library": "hardcaml",
      "description": "This module implements a hardware description DSL resembling Verilog's `always` blocks, supporting imperative-style circuit logic with variables, assignments, and control structures. It provides combinational and sequential variable types, conditional branching with `if` and `switch`, and state machine construction via the `State_machine` submodule. Concrete use cases include modeling synchronous logic with explicit state transitions, building control logic with prioritized conditions, and describing pipelined datapaths using variable assignments and enable-controlled registers.",
      "description_length": 585,
      "index": 401,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Cyclesim_float_ops",
      "library": "hardcaml",
      "description": "This module implements 32-bit and 64-bit floating-point arithmetic and mathematical operations\u2014such as addition, multiplication, trigonometric functions, logarithms, and rounding\u2014on hardware signals. It works directly with `Hardcaml.Signal.t` values, simulating floating-point computations using combinational logic networks. Use cases include high-fidelity numerical simulations in digital circuit design, particularly for signal processing and computational hardware modeling.",
      "description_length": 478,
      "index": 402,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Logic",
      "library": "hardcaml",
      "description": "This module implements digital circuit modeling and verification using multi-valued logic systems, supporting operations on `std_logic`, `four_state`, and associated vector types for bit-level manipulation, arithmetic, and signal state tracking. It provides precise handling of digital signals with operations such as logic evaluation, state transitions, vector resizing, and arithmetic with signed and unsigned interpretations, working directly on logic and vector types to enable simulation, testbench generation, and formal verification. Concrete use cases include designing arithmetic logic units, modeling control circuits, and simulating digital signals with support for high-impedance and unknown states.",
      "description_length": 711,
      "index": 403,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Signedness",
      "library": "hardcaml",
      "description": "Represents and converts signedness annotations for hardware signals. Supports serialization to S-expressions for configuration or debugging purposes. Used when defining arithmetic operations or interfaces that require explicit signedness handling, such as signal width or overflow behavior in hardware descriptions.",
      "description_length": 315,
      "index": 404,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Rtl_attribute",
      "library": "hardcaml",
      "description": "This module defines RTL attributes used to annotate hardware designs with metadata that influences synthesis and simulation tools. It supports creating and manipulating attributes with optional values of type integer, string, or boolean, and provides operations for comparison, hashing, and serialization. Specific use cases include marking registers for synchronization, specifying state machine encodings, preserving nets, and controlling RAM or SRL implementation in Xilinx Vivado.",
      "description_length": 484,
      "index": 405,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Enum",
      "library": "hardcaml",
      "description": "This module creates specialized enumeration interface modules for binary and one-hot encoded hardware signals. It provides operations to convert between bit vectors and enumerated types, perform structured traversal, and construct combinational logic for state machines and control circuits. It works directly with hardware-specific types like `Signal.t`, `Bits.t`, and tagged encodings (`Binary.t`, `One_hot.t`) to enable precise bit-level manipulation and synthesis.",
      "description_length": 468,
      "index": 406,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Cyclesim",
      "library": "hardcaml",
      "description": "This module enables cycle-accurate simulation of digital circuits through operations that manage ports, trace signals, and control sequential logic with reset and cycle steps, operating on bit vectors, signals, and memory structures. It supports inspection and manipulation of internal components such as registers, memories, and nodes, allowing debugging, verification, and initialization of hardware designs with precise control over logic transitions and memory access.",
      "description_length": 472,
      "index": 407,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types",
      "library": "hardcaml",
      "description": "This module provides foundational abstractions for hardware description through structured transformations of clocked interfaces, signal pairs, validity-annotated data, and scalar/vector signal types. It supports precise manipulation of hardware signals using combinational logic, register pipelines, and structured data flows, working directly with typed interfaces like clocked signals, port-based values, and metadata-rich arrays/lists. Concrete use cases include RTL circuit synthesis, pipeline construction with explicit clocking, AXI stream handling, and structured signal routing with validity control.",
      "description_length": 609,
      "index": 408,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Wave_format",
      "library": "hardcaml",
      "description": "This module defines how to format and display signal values in waveforms, supporting binary, hexadecimal, integer, and custom representations. It works with signal data encoded as `Bits.t` and provides specific formatting options like `Bit`, `Hex`, and `Index` for visualizing digital signals. Use cases include rendering simulation waveforms with appropriate radix or mapping signal values to string labels for debugging.",
      "description_length": 422,
      "index": 409,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Signal_graph",
      "library": "hardcaml",
      "description": "This module constructs and analyzes directed acyclic graphs of digital circuit signals, starting from a given list of output signals and tracing backward to inputs. It supports traversal operations like depth-first search, topological sorting, and combinational loop detection, along with mapping and filtering functions to process signals based on custom criteria. Concrete use cases include signal dependency analysis, simulation scheduling, and circuit optimization by examining fan-in/fan-out relationships or extracting specific signal layers for synthesis or debugging.",
      "description_length": 575,
      "index": 410,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Signal",
      "library": "hardcaml",
      "description": "This module provides operations for constructing and manipulating hardware signals as bitvector abstractions, supporting arithmetic, logical, and structural transformations. It works with signals representing digital logic values, enabling conversions between integers, strings, and bit-level representations, along with operations like concatenation, selection, shifting, and arithmetic comparisons. Key use cases include building combinational circuits (counters, multiplexers, priority encoders), modeling sequential logic (registers, pipelines), and generating synthesizable netlists for hardware simulation and implementation.",
      "description_length": 631,
      "index": 411,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Circuit",
      "library": "hardcaml",
      "description": "This module provides operations for defining circuit ports, analyzing signal relationships (like fan-in/fan-out and combinational loops), mapping signals to unique identifiers, and performing structural comparisons or extracting component instantiations from circuits. It operates on signal graphs, interfaces, and hierarchical circuit structures to support tasks like port consistency validation, UID normalization, and interface-driven circuit construction. Use cases include verifying circuit integrity, optimizing signal propagation paths, and building reusable hardware components from interface specifications.",
      "description_length": 616,
      "index": 412,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Reserved_words",
      "library": "hardcaml",
      "description": "This module provides direct access to lists of reserved keywords for Verilog, VHDL, and OCaml. It includes separate values for each language, allowing checks or filtering against their respective reserved words. Useful for code generation or parsing tools that need to avoid naming conflicts with language keywords.",
      "description_length": 315,
      "index": 413,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Constant",
      "library": "hardcaml",
      "description": "This module provides operations to construct and manipulate fixed-width bit-level constants, supporting bitwise logic, arithmetic, and conversions between binary representations, integers (int, int64), and strings (hex, binary). It centers on a byte-based `t` type for hardware constants and interacts with bit lists, integers, and Zarith big integers, primarily serving hardware synthesis tasks like immediate value encoding and constant propagation optimizations. Key utilities include truncation-aware conversions, padding, resizing, and serialization for both human-readable and machine-efficient data exchange.",
      "description_length": 615,
      "index": 414,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Combinational_op",
      "library": "hardcaml",
      "description": "This module defines custom combinational logic operations that take lists of mutable bit vectors as inputs and produce lists of mutable bit vectors as outputs. It supports defining operations via a function that directly manipulates mutable state during simulation. Use it to implement specialized hardware primitives like encoders, decoders, or arithmetic units that are not covered by standard gates.",
      "description_length": 402,
      "index": 415,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Parameter",
      "library": "hardcaml",
      "description": "This module represents configurable attributes of RTL designs with operations to create, compare, and serialize parameter values. It works with named parameters paired with typed values, supporting lookup by name and subset checks. Concrete use cases include configuring hardware synthesis settings and persisting design parameters via S-expressions.",
      "description_length": 350,
      "index": 416,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.With_valid",
      "library": "hardcaml",
      "description": "This module provides serialization, deserialization, and transformation operations for hardware signals paired with validity indicators. It works with structured types like `t` and `t2` through submodules (`Fields`, `Wrap`, `Vector`) to enable bit-level control, pipeline construction, and validity-aware signal processing in digital circuit design. Key use cases include managing timing-critical data flows, synchronizing valid signal states, and composing hierarchical hardware interfaces.",
      "description_length": 491,
      "index": 417,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Flags_vector",
      "library": "hardcaml",
      "description": "This module enables functional transformations and bit-level manipulations of structured hardware interfaces, supporting zipping, mapping, and serialization across polymorphic vector types and bitvectors. It provides combinational logic operations, signal conversion, and register creation for type-safe circuit construction. Use cases include control logic synthesis, register-transfer-level modeling, and configuration-driven hardware serialization.",
      "description_length": 451,
      "index": 418,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Vcd",
      "library": "hardcaml",
      "description": "This module generates VCD (Verilog Change Dump) files for digital simulation waveform visualization. It provides structured management of timescales, variable declarations, and hierarchical signal scopes, along with functions to write VCD headers and time-stamped signal changes. Use cases include capturing signal transitions during cycle-accurate simulations and producing input for waveform viewers like GTKWave.",
      "description_length": 415,
      "index": 419,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Design_rule_checks",
      "library": "hardcaml",
      "description": "Verifies that all sequential elements in a circuit use only specified clock pins. Works with `Circuit.t` and string lists, ensuring clock inputs match expected names. Useful for enforcing clock domain constraints in hardware designs.",
      "description_length": 233,
      "index": 420,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Rtl",
      "library": "hardcaml",
      "description": "This module implements RTL generation for hardware designs, converting circuits into Verilog or VHDL code. It supports writing hierarchical designs to files, buffers, or channels, with control over blackbox instantiation and signal naming. Key operations include circuit serialization, digest computation for design tracking, and AST manipulation for precise code generation targeting synthesis and simulation tools.",
      "description_length": 416,
      "index": 421,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Circuit_utilization",
      "library": "hardcaml",
      "description": "Analyzes and summarizes circuit resource usage, including gates, arithmetic operators, multiplexers, and memories, by aggregating bit counts and structural characteristics. It categorizes elements to highlight critical path implications and resource distribution, such as grouping multiplexers by depth and memories by data width and depth. Useful for evaluating hardware cost and performance tradeoffs in synthesized circuits.",
      "description_length": 427,
      "index": 422,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Caller_id",
      "library": "hardcaml",
      "description": "Captures callstack information in signal types to aid debugging, particularly for identifying origins of dangling wires. Uses modes like `Disabled`, `Top_of_stack`, and `Full_trace` to control trace detail, with `sexp_of_t` displaying stack traces on exceptions. Enables or disables tracing globally via `set_mode`, useful for tracking signal creation sites in complex circuits during development.",
      "description_length": 397,
      "index": 423,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Ram",
      "library": "hardcaml",
      "description": "This module implements random access memory structures with configurable read and write ports, supporting collision resolution modes like `Read_before_write` and `Write_before_read`. It operates on `Signal.t` values within `Read_port` and `Write_port` records, managing memory state during RTL synthesis. Concrete use cases include modeling dual-port RAMs in hardware designs where precise control over memory access timing and conflict resolution is required.",
      "description_length": 460,
      "index": 424,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Side",
      "library": "hardcaml",
      "description": "Represents temporal phases for scheduling operations relative to clock edges in hardware descriptions. It defines `Before` and `After` as distinct points to trigger actions, such as register updates or combinational logic evaluation. Used to control the precise timing of signal changes in synchronous circuits.",
      "description_length": 311,
      "index": 425,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Wave_data",
      "library": "hardcaml",
      "description": "This module represents and manipulates waveform data as a sequence of bit vectors. It supports creating, initializing, and modifying waveforms with fixed width and length, along with direct memory operations for performance-critical sections. Use cases include simulation trace storage, waveform visualization, and interfacing with external tools that consume binary waveform data.",
      "description_length": 381,
      "index": 426,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Bits_list",
      "library": "hardcaml",
      "description": "This module implements combinational logic operations on lists of bits, supporting arithmetic, logical, and bit-level manipulations such as addition, shifting, concatenation, and comparison. It works directly with lists of boolean or ternary values (`F`, `T`, `X`) to model fixed-width bit vectors with explicit control over sign, endianness, and bit ordering. Concrete use cases include designing arithmetic logic units, control logic circuits, and data path components where precise handling of binary signals and undefined states is required.",
      "description_length": 545,
      "index": 427,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Build_mode",
      "library": "hardcaml",
      "description": "Represents configuration modes for hardware compilation, specifically simulation or synthesis targets. Supports comparison, equality checks, string conversion, and S-expression serialization. Used to control hardware generation behavior in synthesis toolchains and simulation environments.",
      "description_length": 289,
      "index": 428,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Circuit_database",
      "library": "hardcaml",
      "description": "Stores and manages a collection of Hardcaml circuits, indexed by unique names. It supports inserting circuits with optional structural sharing, looking up circuits by name, and retrieving all stored circuits. Used to map instantiated circuits to their implementations for generating RTL hierarchies.",
      "description_length": 299,
      "index": 429,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Architecture",
      "library": "hardcaml",
      "description": "This module defines an enumeration for hardware architecture configurations with three variants: `Small`, `Balanced`, and `Fast`. It provides functions to convert between string representations and the enumerated type, as well as serialization to and from S-expressions. It is used to specify trade-offs between circuit size and performance in hardware generation contexts.",
      "description_length": 373,
      "index": 430,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Parameter_name",
      "library": "hardcaml",
      "description": "This module represents parameter names used in RTL modules, providing operations to create, compare, and convert them to and from strings and S-expressions. It supports use cases like tracking and serializing module parameter names during hardware compilation or debugging. Key functions include `of_string`, `to_string`, `compare`, and serialization support via `t_of_sexp` and `sexp_of_t`.",
      "description_length": 391,
      "index": 431,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Write_port",
      "library": "hardcaml",
      "description": "This module represents a memory write port with operations to map, iterate, and combine values. It works with memory interface structures to define how data is written. Use it to specify memory updates in hardware designs, such as setting values at specific addresses during simulation or synthesis.",
      "description_length": 299,
      "index": 432,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Scope",
      "library": "hardcaml",
      "description": "This module manages hierarchical circuit generation by tracking instantiated modules and controlling signal naming through configurable schemes. It provides functions to create and navigate hierarchical scopes, generate scoped signal names, and handle LTL properties and assertions within a design. Use it to avoid naming conflicts, inspect hierarchical paths, or control module inlining in complex hardware descriptions.",
      "description_length": 421,
      "index": 433,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Combinational_ops_database",
      "library": "hardcaml",
      "description": "This module manages a collection of custom combinational operations, enabling insertion, lookup by name, iteration, and folding over the stored operations. It supports creating an empty database, merging multiple databases, and serializing the contents to S-expressions. Use this module to define and organize reusable combinational logic for simulation with Cyclesim-based simulators.",
      "description_length": 385,
      "index": 434,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Comb",
      "library": "hardcaml",
      "description": "This module implements low-level combinational logic operations on fixed-width bitvectors (`t`), including arithmetic (addition, multiplication), logical operators (AND, XOR), bit manipulation (selection, shifting, concatenation), and multiplexing. It supports both signed and unsigned comparisons and provides functions for converting between bitvectors and primitive types like integers and booleans. Use cases include designing control logic, implementing data paths, and modeling register transfers in hardware circuits for FPGA or ASIC synthesis.",
      "description_length": 551,
      "index": 435,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Hierarchy",
      "library": "hardcaml",
      "description": "This module supports defining and traversing hierarchical circuits by composing and instantiating nested modules. It operates on `Circuit.t`, `Scope.t`, and interface types defined via `Hardcaml.Interface.S_Of_signal`, enabling structured circuit assembly with named instances and attributes. Use it to build complex, nested digital designs modularly, and to traverse or print the resulting hierarchy for analysis or debugging.",
      "description_length": 427,
      "index": 436,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Async_fifo",
      "library": "hardcaml",
      "description": "Implements asynchronous FIFOs with configurable depth and synchronization options, operating on hardware signals through structured input and output interfaces. Provides functions to create FIFOs with delayed output valid signals, enabling reliable packet buffering across clock domains. Used for clock domain crossing with controlled output timing and pipelined data transfer with guaranteed signal stability.",
      "description_length": 410,
      "index": 437,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Property_manager",
      "library": "hardcaml",
      "description": "Manages the creation and tracking of LTL (Linear Temporal Logic) properties in hardware designs. It provides functions to add named LTL properties, extract atomic propositions as signals, and finalize the collection to retrieve a map of all added properties. This module is used when defining formal verification properties to be checked during simulation or synthesis.",
      "description_length": 369,
      "index": 438,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Reg_spec",
      "library": "hardcaml",
      "description": "This module defines specifications for register behavior in digital circuits, including clock, reset, clear, and enable signals with associated edges and levels. It provides operations to create and modify register configurations, set default values, and access individual signal components. Use cases include defining synchronous register blocks with customizable reset and clear logic in hardware designs.",
      "description_length": 407,
      "index": 439,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Assertions",
      "library": "hardcaml",
      "description": "This module enables assertion checking in hardware simulations by allowing users to define signal-based conditions that trigger violations. It works with simulation scopes, signals, and assertion managers to track and report failures during simulation cycles. Use it to enforce design constraints and capture waveform traces when violations occur.",
      "description_length": 347,
      "index": 440,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Mangler",
      "library": "hardcaml",
      "description": "This module maps strings to unique mangled names, ensuring uniqueness within a mangler instance. It supports operations to add identifiers, check for duplicates, and retrieve mangled versions of names. Use it when generating unique signal or variable names in hardware descriptions to avoid naming conflicts.",
      "description_length": 308,
      "index": 441,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Read_port",
      "library": "hardcaml",
      "description": "This module represents a memory read port with operations to map, iterate, and combine values. It works with polymorphic data structures that can be converted to S-expressions or lists. Concrete use cases include defining and manipulating memory read interfaces in hardware descriptions.",
      "description_length": 287,
      "index": 442,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Interface",
      "library": "hardcaml",
      "description": "This module provides operations for defining and manipulating structured hardware interfaces composed of named signals with specified bit widths. It supports creating hierarchical signal groups, converting interfaces to inspectable representations, and performing transformations like mapping and folding over interface fields. Concrete use cases include building register files, designing packet encoders, and generating bus structures with precise bit-level control.",
      "description_length": 468,
      "index": 443,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Structural",
      "library": "hardcaml",
      "description": "This module enables structural hardware modeling through operations like signal creation (inputs, outputs, wires), tri-state management, and hierarchical module instantiation. It works with signals, circuits, and RTL attributes, supporting low-level bit manipulation, arithmetic, and Verilog generation for digital design synthesis. Key use cases include building complex digital circuits with tri-state buses and generating synthesizable hardware descriptions for FPGA or ASIC targets.",
      "description_length": 486,
      "index": 444,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Fifo",
      "library": "hardcaml",
      "description": "This module provides operations for transforming, combining, and manipulating synchronous FIFO structures with configurable features like showahead and pipelining. It works with FIFOs represented as `Hardcaml.Fifo.t` and signal-level data (`Hardcaml.Signal.t`), enabling precise control over timing and interface composition. Use cases include hardware design workflows where FIFOs must be dynamically restructured, introspected, or integrated into larger synchronous circuits with strict timing requirements.",
      "description_length": 509,
      "index": 445,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Property",
      "library": "hardcaml",
      "description": "This module defines temporal logic formulas using algebraic data types, with support for atomic propositions based on signal types. It includes submodules for Computation Tree Logic (CTL) and Linear Temporal Logic (LTL), offering constructors and combinators to express and manipulate formal verification properties. Use these submodules to specify safety and liveness conditions, perform model checking, and simplify temporal expressions in hardware verification workflows.",
      "description_length": 474,
      "index": 446,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Bits",
      "library": "hardcaml",
      "description": "This module supports creation, manipulation, and conversion of fixed-width bit vectors, treating them as signed or unsigned integers through operations like bitwise logic, arithmetic, comparison, shifting, and bit-level extraction/insertion. It works with immutable bit sequences (`t`) and mutable variants optimized for simulation, offering utilities for hardware modeling tasks such as circuit design, signal processing, and low-level bit manipulations. Key applications include digital logic synthesis, combinational logic evaluation, and hardware verification workflows requiring precise bit-level control.",
      "description_length": 610,
      "index": 447,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Level",
      "library": "hardcaml",
      "description": "Represents digital signal levels with values `High` and `Low`. Provides conversion to integers, equality checks, and S-expression serialization. Useful for hardware simulation and testing where binary signal states must be explicitly modeled and compared.",
      "description_length": 255,
      "index": 448,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Edge",
      "library": "hardcaml",
      "description": "Represents and manipulates signal edges, specifically rising or falling transitions, typically used for clock signals. Provides conversion to S-expressions, equality checks, and integer representation. Useful in hardware description for specifying clock edge behavior in synchronous logic.",
      "description_length": 289,
      "index": 449,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Dedup",
      "library": "hardcaml",
      "description": "Performs structural deduplication of combinatorial logic in circuits by identifying and merging nodes that compute the same value. Works directly with `Hardcaml.Circuit.t` to optimize circuit representations. Useful when generating hardware descriptions from high-level specifications to reduce redundant logic and minimize resource usage.",
      "description_length": 339,
      "index": 450,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Instantiation",
      "library": "hardcaml",
      "description": "Instantiates sub-modules in generated RTL, integrating external components not written in Hardcaml. It maps input and output ports by name, supporting parameters and attributes, and works directly with signal lists and module interfaces. Use to include pre-synthesized blocks or black boxes with defined port layouts in a Hardcaml design.",
      "description_length": 338,
      "index": 451,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml",
      "library": "hardcaml",
      "description": "This module supports operations like signal manipulation, combinational logic, register specification, and structural modeling for hardware design, targeting both high-level patterns (state machines, hierarchical circuits) and low-level bitvector control. It works with typed hardware signals (`Signal.t`), bit vectors (`Bits.t`), and structured interfaces, enabling precise timing and state management through constructs like clock phases, pipelines, and memory blocks (RAM, FIFO). Applications include FPGA prototyping, ASIC synthesis, and formal verification of digital circuits with cycle-accurate simulation and RTL generation.",
      "description_length": 632,
      "index": 452,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 460,
    "meaningful_modules": 453,
    "filtered_empty_modules": 7,
    "retention_rate": 0.9847826086956522
  },
  "statistics": {
    "max_description_length": 717,
    "min_description_length": 193,
    "avg_description_length": 441.5871964679912,
    "embedding_file_size_mb": 6.565526962280273
  }
}