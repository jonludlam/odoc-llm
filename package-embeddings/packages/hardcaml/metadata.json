{
  "package": "hardcaml",
  "embedding_model": "Qwen/Qwen3-Embedding-0.6B",
  "embedding_dimension": 1024,
  "total_modules": 745,
  "creation_timestamp": "2025-07-16T00:40:32.188965",
  "modules": [
    {
      "module_path": "Hardcaml.Types.With_valid.Wrap.M.S-Of_always",
      "library": "hardcaml",
      "description": "This module provides functions to construct and manipulate hardware interfaces using the Always API, specifically for creating and assigning register and wire signals. It works with interface types parameterized by `Hardcaml.Always.Variable.t` and `Hardcaml.Signal.t`, enabling direct signal assignment and naming within always blocks. Concrete use cases include defining synchronous logic with `reg`, creating combinational signals with `wire`, and assigning values in an always block using `assign`.",
      "description_length": 501,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Flags_vector.Make.Flags.Map.Key",
      "library": "hardcaml",
      "description": "This module defines a key type for maps based on a vector of flags, supporting conversion to and from S-expressions and providing a comparator for ordering. It works with flag vectors represented as `t` and uses `comparator_witness` to ensure correct comparison semantics. Concrete use cases include managing sets of named flags and efficiently comparing or serializing flag-based configurations.",
      "description_length": 396,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.With_valid.Wrap.Make.Of_bits",
      "library": "hardcaml",
      "description": "This module provides operations to construct, manipulate, and validate hardware interfaces composed of bit vectors. It supports concrete operations such as packing and unpacking interfaces to and from bit vectors, multiplexing between interface values, concatenation, and selection based on one-hot or priority-encoded signals. Use cases include building register files, decoding control signals, and managing data paths in hardware designs.",
      "description_length": 441,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.With_valid.Wrap.Make.Unsafe_assoc_by_port_name",
      "library": "hardcaml",
      "description": "This module directly maps record fields to an association list using port names as keys, enabling conversion between records and lists of key-value pairs. It operates on record types that follow a specific naming convention for ports, allowing field access and construction by string identifiers. Use this when interfacing with external systems that require named signal mappings, such as generating netlists or connecting components by port name.",
      "description_length": 447,
      "index": 3,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Types.With_valid.Wrap.M.S-Unsafe_assoc_by_port_name",
      "library": "hardcaml",
      "description": "This module directly maps record fields to and from association lists, using field names as keys. It supports converting structured data to and from lists of key-value pairs, where each key is a string corresponding to a field name. Use this when interfacing with external systems that require named field access, such as configuration parsers or serialization formats.",
      "description_length": 369,
      "index": 4,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Flags_vector.Make.Flags.Map.Provide_bin_io",
      "library": "hardcaml",
      "description": "This module provides binary serialization and deserialization functions for maps where keys are of a specified type and values are flag sets. It supports operations like `bin_write_t` and `bin_read_t` to convert map values to and from binary format, enabling efficient storage or transmission. Concrete use cases include persisting configuration flags to disk or sending them over a network.",
      "description_length": 391,
      "index": 5,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Flags_vector.Make.Flags.Set.Elt",
      "library": "hardcaml",
      "description": "This module defines a set element type for a specific flag type, including serialization to and from S-expressions and a comparator for ordering. It works with flag-based data structures that require set operations and ordered comparisons. Concrete use cases include managing sets of hardware configuration flags or status indicators in a circuit description.",
      "description_length": 359,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.With_valid.Fields.M.S-Of_always",
      "library": "hardcaml",
      "description": "This module provides functions to construct and manipulate hardware interfaces using the Always API, specifically for creating and assigning register and wire signals. It works with interface types composed of `Hardcaml.Always.Variable.t` and `Hardcaml.Signal.t`, enabling direct assignment and naming within always blocks. Concrete use cases include defining register pipelines with optional enables, creating wire containers with default values, and applying consistent naming to interface fields.",
      "description_length": 499,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.With_valid.Fields.Make.Comb",
      "library": "hardcaml",
      "description": "This module provides combinational logic operations for manipulating structured interfaces with valid signals. It supports operations like packing/unpacking interfaces to/from bit vectors, multiplexing, concatenation, and selection functions such as one-hot and priority selects. These functions operate on `comb t` values, which represent hardware signals structured according to a defined interface.",
      "description_length": 401,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.With_valid.Fields.Make.All",
      "library": "hardcaml",
      "description": "Combines monadic values across an interface, lifting the monad outside the structure. Works with interfaces containing monadic values of type `'a M.t`. Useful for aggregating results from multiple monadic computations into a single structured result.",
      "description_length": 250,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.With_valid.Fields.Make.Of_signal",
      "library": "hardcaml",
      "description": "This module supports the construction and manipulation of field-structured hardware interfaces using combinational (`comb t`) and registered (`t`) signal types, enabling operations like signal assignment, multiplexing, concatenation, and pipeline creation. It emphasizes explicit naming and connection of signal fields with customizable prefixes or suffixes, which is particularly useful for designing hierarchical hardware modules and synchronous data paths with clear, structured interfaces.",
      "description_length": 493,
      "index": 10,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.With_valid.Fields.Make.Of_bits",
      "library": "hardcaml",
      "description": "This module provides functions to construct, manipulate, and validate bit-level hardware interfaces with explicit valid signals. It supports operations like packing/unpacking interfaces to/from bit vectors, multiplexing, concatenation, and selection mechanisms such as priority and one-hot selects. Concrete use cases include building register file ports, control signal multiplexers, and hardware packet encoders/decoders where field-level bit control and validity checking are required.",
      "description_length": 488,
      "index": 11,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Flags_vector.Make.Flags.Set.Provide_bin_io",
      "library": "hardcaml",
      "description": "This module implements binary serialization and deserialization for a set of flags, enabling efficient storage and transmission of flag states. It provides functions to compute binary size, read and write flag sets, and define binary shape and type classes. Concrete use cases include persisting hardware configuration states and exchanging flag data between systems.",
      "description_length": 367,
      "index": 12,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Types.With_valid.Wrap.M.S-Make_comb",
      "library": "hardcaml",
      "description": "This module provides combinational logic operations for packing, unpacking, and manipulating structured data interfaces. It supports types like `comb t` for representing hardware interfaces with combinational signals and includes operations for multiplexing, concatenation, and validation of signal widths. Concrete use cases include building multiplexers, priority encoders, and constant-driven signal generation in hardware descriptions.",
      "description_length": 439,
      "index": 13,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Flags_vector.Make.Flags.Map.Provide_of_sexp",
      "library": "hardcaml",
      "description": "Converts S-expressions into maps of flags indexed by a specified key type, using a provided key conversion function. Works with immutable maps where keys are of a user-defined type and values are flag sets. Useful for parsing configuration files or command-line arguments into structured flag maps.",
      "description_length": 298,
      "index": 14,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Types.With_valid.Fields.M.S-Of_signal",
      "library": "hardcaml",
      "description": "This module supports operations for constructing and validating hardware interfaces with field-level bitwidth control, including signal manipulation via concatenation, multiplexing, and register creation, alongside wiring utilities for signal connection and hierarchical naming. It operates on `With_valid.t` interfaces composed of combinational signals (`Of_signal.comb`), enabling precise control over data paths and validity semantics. These capabilities are particularly useful for implementing register-transfer-level designs with structured signal hierarchies and protocol-specific data alignment.",
      "description_length": 603,
      "index": 15,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Flags_vector.Make.Flags.Map.Provide_hash",
      "library": "hardcaml",
      "description": "Implements hash folding for maps of flags indexed by a custom key type. Works with `Flags.Map.t` structures, where keys are of the provided `Key` module type. Enables efficient hashing of flag maps for use in persistent data structures or checksumming individual flag configurations.",
      "description_length": 283,
      "index": 16,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Flags_vector.Make.Flags.Map.Diff",
      "library": "hardcaml",
      "description": "This module handles differential updates for flag vectors by providing functions to serialize and deserialize differences, extract specific diffs, apply changes to base values, and construct diffs from lists. It operates on types that represent flag vector differences, specifically `'a Flags.Map.Diff.t`, and works with derived flag vector types. Concrete use cases include comparing and applying incremental changes to hardware configuration flags or status registers in a circuit design context.",
      "description_length": 498,
      "index": 17,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Types.With_valid.Fields.M.S-Make_comb",
      "library": "hardcaml",
      "description": "This module provides combinational logic operations for manipulating structured hardware interfaces with valid signals. It supports data types involving packed vectors and records with field-based access, enabling bit-width validation, integer initialization, and multiplexing. Concrete use cases include constructing and validating hardware interfaces, packing/unpacking signals for transmission, and implementing priority or one-hot multiplexers in digital design flows.",
      "description_length": 472,
      "index": 18,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.With_valid.Wrap.Make.Of_signal",
      "library": "hardcaml",
      "description": "This module provides operations for constructing and validating hardware interfaces through signal manipulation, including concatenation, multiplexing, register pipelines, and width-preserving transformations. It operates on combinational (`comb t`) and sequential (`t`) signal types, emphasizing interface-level wiring and structural integrity. These tools are particularly useful for building named, type-safe hardware modules with explicit signal boundaries and programmatically managed naming conventions during design synthesis or simulation.",
      "description_length": 547,
      "index": 19,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.With_valid.Fields.M.S-All",
      "library": "hardcaml",
      "description": "Combines monadic values across an interface, lifting the monad outside the structure. Works with interfaces containing monadic values, transforming a structure of monads into a monad of structures. Useful for aggregating results from multiple concurrent computations within an interface.",
      "description_length": 287,
      "index": 20,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.With_valid.Fields.Make.Names_and_widths",
      "library": "hardcaml",
      "description": "This module generates port names and widths for a Hardcaml interface with valid signals. It provides access to individual port metadata, including names, widths, and tags, based on the underlying structure of the interface. It is used when constructing or inspecting hardware descriptions that require explicit signal naming and sizing information.",
      "description_length": 348,
      "index": 21,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.With_valid.Fields.Make.Make_comb",
      "library": "hardcaml",
      "description": "This module provides combinational logic operations for manipulating structured interfaces with valid signals, including packing/unpacking to vectors, multiplexing, concatenation, and selection functions like priority and one-hot selects. It works with interfaces of type `comb t`, where `comb` is a combinational logic type, and supports concrete operations such as `mux`, `concat`, and `priority_select` for building complex signal routing logic. Use cases include constructing and validating hardware interfaces, dynamically selecting between signal sources, and converting structured data to and from flat bit vectors.",
      "description_length": 622,
      "index": 22,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.With_valid.Wrap.M.S-module-type-Comb",
      "library": "hardcaml",
      "description": "This module implements combinational logic operations for structured interfaces with valid signals. It supports packing/unpacking interfaces to vectors, multiplexing and concatenation of interface lists, and selection operations like priority and one-hot decoding with optional branching factors. These functions are used to build complex signal routing and transformation circuits in hardware descriptions.",
      "description_length": 407,
      "index": 23,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.With_valid.Fields.Make.Unsafe_assoc_by_port_name",
      "library": "hardcaml",
      "description": "This module directly maps fields of a hardcaml interface to and from an association list using field names as keys. It provides `to_alist` and `of_alist` functions to convert between the interface and a list of `(string * 'a)` pairs. Use this when interfacing with external systems that require named signal mappings, such as configuration parsers or simulation input/output handlers.",
      "description_length": 384,
      "index": 24,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.With_valid.Fields.M.S-Unsafe_assoc_by_port_name",
      "library": "hardcaml",
      "description": "This module provides direct, unsafe access to fields of a Hardcaml interface using port names as keys. It supports converting structured interfaces to and from association lists where each entry maps a field name to its value. Use this when dynamically inspecting or constructing interfaces based on runtime field names, such as in automated test generation or interface introspection tools.",
      "description_length": 391,
      "index": 25,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Types.With_valid.Fields.M.S-Of_bits",
      "library": "hardcaml",
      "description": "This module handles bit-level manipulation and validation of structured interfaces with valid signals. It supports operations like packing/unpacking interfaces to/from bit vectors, multiplexing, concatenation, and priority/one-hot selection with validity handling. Concrete uses include constructing and validating hardware interfaces from bit vectors, selecting between multiple valid data paths, and ensuring signal width consistency in hardware descriptions.",
      "description_length": 461,
      "index": 26,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.With_valid.Wrap.M.S-Of_signal",
      "library": "hardcaml",
      "description": "This module provides operations for constructing and transforming hardware interfaces with signal routing, constant assignment, and structural manipulation capabilities. It works with hardware signals, registers, pipelines, and packed/unpacked data structures to enable tasks like building multiplexers, priority encoders, and hierarchical signal networks. Specific use cases include creating data paths with register stages, implementing control logic via signal selection, and organizing signal hierarchies with named wire bundles.",
      "description_length": 533,
      "index": 27,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.With_valid.Wrap.Make.All",
      "library": "hardcaml",
      "description": "Lifts monadic computations from within an interface to the outer monad by combining all monadic values across the interface fields. Works with any monad `M` and structured interfaces containing monadic values. Useful for aggregating effects like error handling or state across hardware description components.",
      "description_length": 309,
      "index": 28,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.With_valid.Fields.Make.Of_always",
      "library": "hardcaml",
      "description": "This module provides functions to manipulate and assign values to hardware description interfaces using the Always API. It works with interfaces containing `Hardcaml.Always.Variable.t` and `Hardcaml.Signal.t` types, supporting operations like wire and register creation, signal assignment, and naming. Concrete use cases include building and connecting register and wire signals within an always block, such as assigning a register interface with a specified reset behavior or creating a named interface of wire signals initialized to zero.",
      "description_length": 540,
      "index": 29,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Flags_vector.Make.Flags.Set.Provide_of_sexp",
      "library": "hardcaml",
      "description": "Converts S-expressions into sets of flags, where each flag corresponds to a variant constructor. Uses the `Elt` module to map S-expression atoms to flag values. Useful for parsing configuration files or command-line arguments that represent sets of options as symbols.",
      "description_length": 268,
      "index": 30,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Flags_vector.Make.Flags.Set.Provide_hash",
      "library": "hardcaml",
      "description": "This module provides hash folding and hashing operations for sets of flags. It works with `Flags.Set.t`, a set type derived from the `Elt` module's elements. Concrete use cases include enabling efficient hashing of flag sets for use in hash tables or other data structures requiring hashable keys.",
      "description_length": 297,
      "index": 31,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Types.With_valid.Wrap.M.S-Of_bits",
      "library": "hardcaml",
      "description": "This module handles bit-level manipulation and validation of hardware description interfaces. It provides operations for packing, unpacking, concatenating, and multiplexing interfaces, along with width validation and constant initialization. Use it when constructing and verifying signal interfaces in digital circuit design.",
      "description_length": 325,
      "index": 32,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Types.With_valid.Fields.M.S-module-type-Comb",
      "library": "hardcaml",
      "description": "This module defines combinational logic operations for manipulating structured interfaces with valid signals. It supports operations like packing/unpacking interfaces to vectors, multiplexing, concatenation, and selection functions such as one-hot and priority selects. These functions operate on `comb t` values, which represent hardware signals grouped into fields with specified widths. Use cases include building complex control logic, data routing circuits, and register file access structures in hardware designs.",
      "description_length": 519,
      "index": 33,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.With_valid.Wrap.Make.Names_and_widths",
      "library": "hardcaml",
      "description": "This module generates port names and widths for a Hardcaml interface with valid signals. It provides access to individual port metadata, including names, widths, and tags, based on the underlying type structure. Use it to inspect or construct interface signals with named and sized ports for simulation or synthesis.",
      "description_length": 316,
      "index": 34,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.With_valid.Fields.M.S",
      "library": "hardcaml",
      "description": "This module provides structural transformations, introspection, and metadata utilities for hardware interfaces represented as product types with valid signals. It operates on tuples of signals (`'a t`) and their associated metadata, enabling operations like zipping, folding, and port-name-based associations while supporting error handling and combinational logic construction. Typical use cases include hardware simulation pipelines, interface validation, and synthesis workflows where structured signal manipulation and metadata-driven transformations are required.",
      "description_length": 568,
      "index": 35,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Types.With_valid.Fields.M.S-Names_and_widths",
      "library": "hardcaml",
      "description": "This module provides values for retrieving lists of port names, widths, and tags associated with a Hardcaml interface. It operates on the data types `string`, `int`, and `tag`, structured as lists. Concrete use cases include inspecting interface signal properties during simulation or generating hardware descriptions based on port metadata.",
      "description_length": 341,
      "index": 36,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "Hardcaml.Flags_vector.Make.Flags.Set.Diff",
      "library": "hardcaml",
      "description": "This module represents and manipulates differences between sets of flag values. It supports operations to apply diffs to base sets, extract diffs between two derived sets, and construct diffs from lists. It works directly with sets of flag elements and is used to track and apply incremental changes to flag configurations.",
      "description_length": 323,
      "index": 37,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.With_valid.Wrap.Make.Make_comb",
      "library": "hardcaml",
      "description": "This module implements combinational logic operations for wrapping and manipulating hardware interfaces with valid signals. It provides functions like `pack`, `unpack`, `mux`, and `concat` to transform interfaces, along with validation and width-checking utilities. Use cases include building multiplexers, concatenating signal groups, and converting between structured interfaces and flat bit vectors.",
      "description_length": 402,
      "index": 38,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.With_valid.Wrap.Make.Of_always",
      "library": "hardcaml",
      "description": "This module provides functions to manipulate and assign values to hardware description interfaces within an `always` block. It supports creating register and wire variables, assigning signals, and applying naming conventions to interface fields. Concrete use cases include constructing and managing synchronous logic, such as state machines or data path elements, using structured interfaces.",
      "description_length": 392,
      "index": 39,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.With_valid.Wrap.M.S",
      "library": "hardcaml",
      "description": "This module provides type-safe transformations for hardware interfaces that pair data with validity states, supporting operations like mapping, zipping, and folding over tuples of signals, bit-level packing/unpacking, and metadata introspection. It works with structured types such as `'a t` (data-valid pairs), multi-signal tuples, and bit-level representations, enabling use cases like designing ready/valid protocols, manipulating signal groups in combinational logic, and error propagation in hardware pipelines.",
      "description_length": 516,
      "index": 40,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.With_valid.Wrap.Make.Comb",
      "library": "hardcaml",
      "description": "This module implements combinational logic operations for wrapping and manipulating hardware interfaces with valid signals. It supports operations like packing/unpacking interfaces to/from bit vectors, multiplexing, concatenation, and priority/one-hot selection, working with types like `comb` and `comb t`. Use it to build complex signal routing and control logic in hardware descriptions, such as selecting between multiple data paths or assembling/disassembling compound signals.",
      "description_length": 482,
      "index": 41,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Hardcaml.Types.With_valid.Wrap.M.S-All",
      "library": "hardcaml",
      "description": "This module provides the `all` function, which combines a list of monadic values within a Hardcaml interface, lifting the monad outside the interface structure. It operates on data types of the form `('a, 'a X.t) With_valid.t2`, where each element is wrapped in a monad `M`. A concrete use case is aggregating multiple signal-valid pairs in a circuit description, where each signal is represented in a monadic context such as a simulation or hardware generation monad.",
      "description_length": 468,
      "index": 42,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.With_valid.Wrap.M.S-Names_and_widths",
      "library": "hardcaml",
      "description": "This module defines operations to extract and manipulate port names, widths, and tags from a Hardcaml interface that includes validity signals. It provides direct access to structured metadata such as lists of port names and their corresponding bit widths. Concrete use cases include generating signal declarations, validating interface compatibility, and debugging hardware descriptions.",
      "description_length": 388,
      "index": 43,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Types.Clocking.Make.Make_comb",
      "library": "hardcaml",
      "description": "This module provides operations for constructing and manipulating clocked hardware interfaces using a combinatorial logic representation. It supports data types involving packed vectors and structured interfaces with typed fields, enabling operations like packing/unpacking, multiplexing, concatenation, and priority/one-hot selection. Concrete use cases include building register files, control logic, and data path components where signal widths and combinational behavior are explicitly managed.",
      "description_length": 498,
      "index": 44,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Enum.Make_enums.Binary.All",
      "library": "hardcaml",
      "description": "This module provides the `all` function, which lifts monadic binary values into a binary structure of monadic values, enabling parallel composition of binary interfaces within a monadic context. It operates on data types involving binary signals wrapped in a monad, specifically `'a M.t Binary.t`. A concrete use case includes combining multiple monadic binary computations into a single result, such as aggregating signal transformations in hardware description workflows.",
      "description_length": 473,
      "index": 45,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Fifo.With_interface.O.Make_comb",
      "library": "hardcaml",
      "description": "This module provides combinational logic operations for constructing and manipulating FIFO interfaces, including packing/unpacking interfaces to vectors, multiplexing, concatenation, and selection functions like priority and onehot selects. It works with interface types composed of combinational signals, supporting constant initialization, width validation, and bit-level transformations. Concrete use cases include building custom FIFO control logic, signal routing, and register-less data path structures in hardware designs.",
      "description_length": 529,
      "index": 46,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Fifo.With_interface.I.Unsafe_assoc_by_port_name",
      "library": "hardcaml",
      "description": "This module provides direct, unsafe conversions between FIFO interface values and association lists indexed by field names. It operates on values of type `'a I.t` and lists of string-value pairs. These functions are useful for low-level manipulation of FIFO interface data, such as when interfacing with external systems or generating debug representations.",
      "description_length": 357,
      "index": 47,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.With_valid.Fields.M.S-module-type-Comb",
      "library": "hardcaml",
      "description": "This module provides combinational logic operations for manipulating structured interfaces with valid signals. It supports operations like packing/unpacking interfaces to vectors, multiplexing, concatenation, and selection functions such as one-hot and priority selects. These functions work on `comb t` values, which represent combinational logic signals structured according to a declared interface.",
      "description_length": 401,
      "index": 48,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.With_valid.Wrap.Make.Unsafe_assoc_by_port_name",
      "library": "hardcaml",
      "description": "This module directly maps fields of a hardcaml interface to and from an association list using port names as keys. It provides `to_alist` and `of_alist` functions that convert between an interface value and a list of string-keyed field-value pairs. Use this when interfacing with external systems that require named signal mappings, such as generating netlists or connecting components by port name.",
      "description_length": 399,
      "index": 49,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Enum.Make_enums.Binary.Make_comb",
      "library": "hardcaml",
      "description": "This module provides combinational logic operations for binary-encoded enumeration types, including packing/unpacking, multiplexing, concatenation, and selection. It operates on `comb Binary.t` values representing signals with binary encodings, enabling efficient decoding logic and pattern matching with optional default cases. These capabilities are particularly useful for implementing state machines, control logic, and hardware interfaces where compact binary representations are critical.",
      "description_length": 494,
      "index": 50,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.With_valid.Fields.Make.All",
      "library": "hardcaml",
      "description": "This module provides the `all` function, which lifts a monadic interface of a record type into a record of monadic types, enabling sequential composition of computations across all fields. It operates on interfaces where each field is wrapped in a monad `M`, restructuring them so the entire interface is within the monad. A typical use case is combining multiple signal-valid streams into a single stream where validity is synchronized across all fields.",
      "description_length": 455,
      "index": 51,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.With_valid.Fields.M.S-Unsafe_assoc_by_port_name",
      "library": "hardcaml",
      "description": "This module directly maps fields of a Hardcaml interface to and from an association list using field names as keys. It supports converting structured interfaces to named value pairs and reconstructing interfaces from such lists. Use this when interfacing with external systems that require named signal mappings, such as configuration parsers or simulation tools.",
      "description_length": 363,
      "index": 52,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Types.With_valid.Fields.S",
      "library": "hardcaml",
      "description": "This module provides operations for structured hardware interface manipulation, including mapping, zipping, equality checks, and list conversions over tagged field-based data structures (`'a t`) that represent interfaces with validity signals. It supports combinational logic transformations on tuples of signals (up to five elements) and handles bit-level operations, error aggregation, and width-aware signal processing. Key use cases include parallel signal routing, error-tolerant hardware pipelines, and structured interface synthesis with named port widths.",
      "description_length": 563,
      "index": 53,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Async_fifo.Make.O.Of_always",
      "library": "hardcaml",
      "description": "This module provides functions to manipulate and assign values to hardware description interfaces using the Always API. It supports creating registers, wires, and named signals within an interface, working directly with `Always.Variable.t` and `Signal.t` types. Concrete use cases include building and connecting FIFO interface components, assigning default values to signals, and generating named hardware elements for simulation or synthesis.",
      "description_length": 444,
      "index": 54,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.With_valid.Wrap.M.S-Of_signal",
      "library": "hardcaml",
      "description": "This module provides operations for constructing and manipulating hardware interfaces using `comb` signals and `t` interfaces, with support for constant assignment, signal routing (e.g., multiplexing, concatenation), register and pipeline creation, and structural transformations like packing/unpacking. It enables precise signal wiring through assignment operators and naming utilities to organize hierarchical designs with prefixes/suffixes. Key use cases include building pipelined data paths, implementing priority-encoded signal selection, and managing structured interface connections in synthesizable hardware descriptions.",
      "description_length": 630,
      "index": 55,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Clocking.Make.Of_signal",
      "library": "hardcaml",
      "description": "This module provides operations for constructing and transforming hardware signal interfaces, including signal assignment, concatenation, multiplexing, and register creation. It operates on signal types representing combinational and registered logic, enabling precise control over signal hierarchy and naming conventions. These capabilities are essential for building and organizing digital circuits in hardware description tasks.",
      "description_length": 431,
      "index": 56,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Enum.Make_enums.One_hot.Names_and_widths",
      "library": "hardcaml",
      "description": "This module generates enumerated types with one-hot encoding, providing access to port names, widths, and associated tags. It works with lists of strings and integers to define the structure of hardware interfaces. Concrete use cases include defining state machines or command signals where each value is represented by a unique bit in a bus.",
      "description_length": 342,
      "index": 57,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.With_valid.Wrap.M.S-Of_bits",
      "library": "hardcaml",
      "description": "This module provides operations to construct, manipulate, and validate hardware interfaces represented as bit vectors. It supports concrete operations such as packing and unpacking interfaces to and from bit vectors, multiplexing, concatenation, and selection from one-hot or priority-encoded inputs. Use cases include building and validating digital circuit interfaces where each field has a defined bit width and behavior.",
      "description_length": 424,
      "index": 58,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.With_valid.Wrap.M.S-Of_always",
      "library": "hardcaml",
      "description": "This module provides functions to construct and manipulate hardware interfaces using the Always API, specifically for creating and assigning register and wire signals. It works with interface types parameterized by `Hardcaml.Always.Variable.t` and `Hardcaml.Signal.t`, enabling structured signal assignment and naming within always blocks. Concrete use cases include defining register pipelines with optional enables, creating wire containers with default values, and applying consistent naming conventions to interface fields.",
      "description_length": 527,
      "index": 59,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Rtl.Ast.Signals_name_map.Uid_with_index",
      "library": "hardcaml",
      "description": "This module represents a pair of a signal UID and an integer index, used to uniquely identify and compare signals in RTL name mapping. It provides comparison and serialization functions for use in contexts like Verilator integration. The module supports efficient key-based operations such as ordering and sexp conversion, specifically for managing signal mappings during RTL generation and transformation.",
      "description_length": 406,
      "index": 60,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Types.With_valid.Wrap.S-Names_and_widths",
      "library": "hardcaml",
      "description": "This module defines a structured interface for hardware description by combining signal values with validity indicators. It provides operations to access port names, widths, and associated tags, enabling precise signal handling in digital circuit design. Use it to manage interface definitions where each signal's name and bit-width must be explicitly tracked alongside its validity.",
      "description_length": 383,
      "index": 61,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Async_fifo.Make.I.All",
      "library": "hardcaml",
      "description": "Lifts monadic values from within an interface to the interface itself, combining them into a single monadic interface. Works with monadic types and interface structures to synchronize and collect results across multiple signals or computations. Useful for managing concurrent signal updates and ensuring consistent state transitions in hardware descriptions.",
      "description_length": 358,
      "index": 62,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Clocking.Make.Cdc",
      "library": "hardcaml",
      "description": "This module provides functions for managing clock domain crossings in digital circuits. It includes operations to stretch pulses across clock cycles, detect rising edges on valid signals from slower clocks, and pipeline signals with asynchronous register annotations. These functions work with `Signal.t` and `With_valid.t` types, enabling precise control over timing and synchronization between different clock domains.",
      "description_length": 420,
      "index": 63,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Fifo.With_interface.O.Names_and_widths",
      "library": "hardcaml",
      "description": "This module defines the names and widths of ports for a FIFO interface, providing direct access to port metadata as lists of strings and integers. It works with basic FIFO interface descriptions, enabling inspection of port names, widths, and associated tags. Concrete use cases include generating hardware descriptions, debugging FIFO configurations, and interfacing with external systems requiring explicit port definitions.",
      "description_length": 426,
      "index": 64,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Pair.M.S",
      "library": "hardcaml",
      "description": "This module provides utilities for manipulating structured pairs and tuples of hardware signals, enabling operations like mapping, zipping, and folding across interface elements with associated port names and bit widths. It supports conversions between signal representations (e.g., from combinational logic or always blocks) and structured forms, while offering tools for error aggregation, field offset calculations, and interface restructuring. Key applications include RTL interface design, combinational logic construction, and managing hierarchical signal groupings with named, typed fields.",
      "description_length": 597,
      "index": 65,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "Hardcaml.Types.With_valid.Vector.Names_and_widths",
      "library": "hardcaml",
      "description": "This module defines operations for working with lists of named signal ports, each associated with a specific bit width. It provides access to port names, widths, and combined name-width pairs as lists. Useful for generating signal declarations, bus interfaces, or metadata-driven hardware descriptions where port information must be processed or emitted programmatically.",
      "description_length": 371,
      "index": 66,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.With_valid.Fields.Make.Make_comb",
      "library": "hardcaml",
      "description": "This module implements combinational logic operations for structured interfaces with valid signals. It supports operations like packing/unpacking interfaces to vectors, multiplexing, concatenation, and priority/onehot selection, all working directly on `comb t` interfaces. These functions are used to build and manipulate complex signal routing and control logic in hardware descriptions.",
      "description_length": 389,
      "index": 67,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.With_valid.Wrap.M",
      "library": "hardcaml",
      "description": "This module pairs values with explicit validity signals using a parameter module `X`, providing core operations like `of_data_and_valid`, `data`, and `valid` to construct and inspect these pairs. It enables safe handling of potentially invalid signals in hardware descriptions, forming the basis for structured validity-aware data manipulation. Submodules extend this foundation with specialized functionality: they support hardware interface construction using always blocks, mapping records to association lists, packing and unpacking combinational signals, implementing valid-aware logic transformations, bit-level interface validation, and metadata introspection for port names and widths. Specific capabilities include building multiplexers, defining synchronous registers, converting structured data to key-value pairs, and aggregating monadic signal-valid pairs for circuit simulation or synthesis.",
      "description_length": 905,
      "index": 68,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.With_valid.Wrap.Make.Comb",
      "library": "hardcaml",
      "description": "This module provides combinational logic operations for manipulating hardware interfaces with valid signals. It supports operations like packing/unpacking interfaces to/from bit vectors, multiplexing, concatenation, and selection functions such as one-hot and priority selects. These functions operate on `comb t` values, which represent hardware signals with associated field widths, enabling precise bit-level control and validation.",
      "description_length": 435,
      "index": 69,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Async_fifo.Make.O.All",
      "library": "hardcaml",
      "description": "This module provides a function `all` that transforms a record of monadic values into a monadic record, effectively lifting the monad outside. It operates on data structures of type `'a M.t O.t`, where `O` is a module defining an interface with fields of type `'a M.t`. A concrete use case is combining multiple asynchronous computations within a hardware description into a single structure, enabling parallel execution and result aggregation.",
      "description_length": 444,
      "index": 70,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.With_valid.Wrap.M.S-Make_comb",
      "library": "hardcaml",
      "description": "This module implements combinational logic operations for packing, unpacking, and multiplexing hardware interfaces. It works with vector and record-based data types representing hardware signals. Use it to build logic that combines or selects between signal interfaces, such as in multiplexers, decoders, or signal routing logic.",
      "description_length": 329,
      "index": 71,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Types.With_valid.Wrap.S-Of_always",
      "library": "hardcaml",
      "description": "This module provides functions to construct and manipulate hardware description interfaces using the Always API. It supports operations like assigning signals to variables, creating registers and wires with customizable initial values, and applying naming conventions to interface fields. It works with data types such as `Hardcaml.Always.Variable.t t` and `Hardcaml.Signal.t t`, enabling concrete use cases like building named, register-based circuits or wiring signal interfaces with defined defaults.",
      "description_length": 503,
      "index": 72,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Enum.Make_enums.Binary.Of_always",
      "library": "hardcaml",
      "description": "This module provides functions to manipulate and assign binary signal interfaces within always blocks, supporting operations like wire and register creation, signal assignment, and pattern matching. It works with `Hardcaml.Always.Variable.t Binary.t` and `Hardcaml.Signal.t Binary.t` types, representing binary-encoded hardware signals. Use cases include building state machines, decoding binary inputs, and managing sequential logic with named fields in a structured interface.",
      "description_length": 478,
      "index": 73,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Types.Clocking.Make.Of_bits",
      "library": "hardcaml",
      "description": "This module defines operations for constructing and manipulating clocked hardware interfaces using bit vectors. It supports constant initialization, packing/unpacking to and from bit vectors, multiplexing, concatenation, and selection operations with support for one-hot or priority-encoded control signals. Typical use cases include building register files, control logic, and hardware interfaces with fixed-width fields.",
      "description_length": 422,
      "index": 74,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.With_valid.Fields.M.S-Of_signal",
      "library": "hardcaml",
      "description": "This module enables the construction of hardware interfaces through signal composition (e.g., packing",
      "description_length": 101,
      "index": 75,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Pair.Wrap.Make_comb",
      "library": "hardcaml",
      "description": "This module implements combinational logic operations for wrapping and manipulating structured signal interfaces. It supports operations like packing/unpacking interfaces to/from bit vectors, multiplexing, concatenation, and priority/one-hot selection, working with signal types defined by the `Comb` module. Use it to build complex signal routing logic in hardware descriptions, such as bus multiplexers, encoded signal selectors, or interface adapters.",
      "description_length": 454,
      "index": 76,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.With_valid.Wrap.Make.Of_always",
      "library": "hardcaml",
      "description": "This module provides functions to construct and manipulate hardware interfaces using the Always API, specifically for creating and assigning register and wire signals. It works with interface types containing `Hardcaml.Always.Variable.t` values, enabling direct signal assignment and naming within always blocks. Concrete use cases include defining synchronous logic with `reg`, connecting signals via `wire`, and applying hierarchical names to interface fields.",
      "description_length": 462,
      "index": 77,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Async_fifo.Make.I.Of_always",
      "library": "hardcaml",
      "description": "This module provides functions to manipulate and assign values to interfaces using the Always API, specifically for creating and managing register and wire variables. It operates on `Hardcaml.Always.Variable.t` and `Hardcaml.Signal.t` types, structured within interfaces. Concrete use cases include defining synchronous logic blocks, initializing interface fields with default signals, and applying naming conventions to signals in an interface.",
      "description_length": 445,
      "index": 78,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Types.With_valid.Wrap.Make",
      "library": "hardcaml",
      "description": "This module enables structural manipulation and introspection of hardware interfaces with validity tracking, supporting operations like mapping, zipping, folding, and metadata extraction. It works with interface values paired with validity signals (`'a t`), lists of interfaces, and bit vector representations, allowing composable hardware descriptions with validity guarantees, conversion between signal representations, and structural analysis for synthesis or verification. Child modules provide concrete functionality for packing/unpacking interfaces, multiplexing signals, converting records to named port mappings, managing monadic effects across interfaces, generating port metadata, and implementing combinational logic for signal routing and transformation. Examples include building register files, decoding control signals, constructing state machines, and programmatically managing signal naming and wiring in hardware designs.",
      "description_length": 939,
      "index": 79,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.With_valid.Wrap.S-Of_signal",
      "library": "hardcaml",
      "description": "This module enables the creation and validation of hardware interfaces composed of combinational and registered signals, supporting operations like signal packing, multiplexing, concatenation, and pipeline construction. It works with structured signal types (`Of_signal.comb t` and `Of_signal.t`) to enforce correctness in hardware descriptions, while providing utilities for wiring signals (`<==`), defining named input/output interfaces, and managing signal hierarchy. These capabilities are particularly useful for building complex digital circuits where structured signal connectivity and validated interface boundaries are critical, such as register-transfer-level designs or pipelined architectures.",
      "description_length": 705,
      "index": 80,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Types.Clocking.Make.Comb",
      "library": "hardcaml",
      "description": "This module provides operations for constructing and manipulating combinational logic interfaces. It supports signal packing, unpacking, multiplexing, concatenation, and selection operations on bit vectors with defined field widths. Concrete use cases include building register file read ports, decoding instruction fields, and implementing priority encoders in digital circuits.",
      "description_length": 379,
      "index": 81,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Flags_vector.Make.Flags.Replace_polymorphic_compare",
      "library": "hardcaml",
      "description": "This module defines standard comparison operators and functions for a polymorphic type `t`, including equality checks, ordering relations, `min`, `max`, and a three-way `compare` function. It enables direct comparison of values of type `t` using familiar infix operators like `(>)`, `(=)`, and `(<>)`, along with equivalent named functions. This is particularly useful when working with custom or abstract types that require consistent and total ordering, such as numeric wrappers, enumerated types, or structured data with defined comparison semantics.",
      "description_length": 553,
      "index": 82,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.With_valid.Wrap.S-All",
      "library": "hardcaml",
      "description": "This module provides the `all` function, which transforms a list of monadic values into a monadic value of a list, effectively lifting the monad outside the interface. It operates on data structures of type `'a M.t t`, where `t` represents the interface and `M` is a monad. A concrete use case is combining multiple signal generators in Hardcaml into a single signal, enabling parallel computation within the circuit description.",
      "description_length": 429,
      "index": 83,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Pair.Wrap.Of_bits",
      "library": "hardcaml",
      "description": "This module operates on packed bit vectors representing structured interfaces, providing functions to pack, unpack, concatenate, and multiplex these interfaces. It supports operations like width validation, integer initialization, and priority/one-hot selection for signal routing. Use cases include hardware description and simulation tasks where structured data interfaces are manipulated as bit vectors.",
      "description_length": 406,
      "index": 84,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Enum.Make_enums.One_hot.Make_comb",
      "library": "hardcaml",
      "description": "This module provides combinational logic operations for manipulating one-hot encoded enumeration values, such as packing/unpacking, multiplexing, and pattern matching. It operates on bit vector representations of enumerated types, enabling direct conversion from integers or enums while enforcing correct bit-width constraints. Typical use cases include implementing state machines, control logic, or hardware interfaces where compact, efficient encoding of discrete states or commands is required.",
      "description_length": 498,
      "index": 85,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Enum.Make_enums.One_hot.All",
      "library": "hardcaml",
      "description": "This module provides a function `all` that transforms a one-hot encoded interface of monadic values into a monadic value of a one-hot encoded interface. It operates specifically on data structures of type `'a M.t One_hot.t`, where `M` is a monad. A concrete use case is combining multiple one-hot signals wrapped in a monad (e.g., `Signal.t`) into a single monadic one-hot signal, enabling parallel evaluation of effects across the interface.",
      "description_length": 442,
      "index": 86,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Async_fifo.Make.I.Of_bits",
      "library": "hardcaml",
      "description": "This module provides operations to manipulate bit-level FIFO interfaces using basic integer and vector representations. It supports packing and unpacking interfaces into bit vectors, multiplexing between multiple interfaces, concatenation, and selection operations with optional branching factors. These functions are used to build and verify FIFO control logic with precise bit-width constraints in hardware descriptions.",
      "description_length": 422,
      "index": 87,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Enum.Make_enums.One_hot.Of_signal",
      "library": "hardcaml",
      "description": "This module provides operations for constructing, validating, and transforming one-hot encoded signals, including bitwise manipulations, multiplexing (via `mux`, `priority_select`), and sequential logic (registers, pipelines). It works with `One_hot.Of_signal.t` types representing hardware signals, enabling synthesis-safe enum encoding and conditional logic. Specific use cases include designing multiplexer arrays, priority encoders, and state machine controllers where one-hot encoding ensures safe transitions and avoids combinatorial hazards.",
      "description_length": 548,
      "index": 88,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.With_valid.Wrap.Make.All",
      "library": "hardcaml",
      "description": "Combines a structure of monadic values within an interface into a single monadic result, lifting the monad outside the interface. Works with any monadic type `'a M.t` contained inside an interface type `'a t`. Useful for sequencing multiple computations that each produce an interface, resulting in a single interface that carries the combined results.",
      "description_length": 352,
      "index": 89,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Types.Pair.M.S-Unsafe_assoc_by_port_name",
      "library": "hardcaml",
      "description": "Converts between a polymorphic record-like structure and an association list indexed by field names. Works with any type `'a t` that represents a record with named fields, using strings as keys. Useful for dynamically accessing or constructing record values by field name, such as in serialization or configuration parsing.",
      "description_length": 323,
      "index": 90,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.With_valid.Fields.S-All",
      "library": "hardcaml",
      "description": "Lifts monadic values from within a structured interface to the outer monad, combining them into a single result. Works with interfaces containing monadic values of type `'a M.t t`, producing a monadic interface of type `'a t M.t`. Useful for aggregating asynchronous or effectful computations across a hardware description interface.",
      "description_length": 333,
      "index": 91,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.With_valid.Fields.M.S-All",
      "library": "hardcaml",
      "description": "Combines monadic values across an interface, lifting the monad outside to sequence operations like `Monad.all` for lists. Works with `'a M.t t` structures, where `M` is a monad, transforming them into `'a t M.t`. Useful for parallel computation sequencing in hardware description interfaces with validity signals.",
      "description_length": 313,
      "index": 92,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Enum.Make_enums.One_hot.Unsafe",
      "library": "hardcaml",
      "description": "This module provides low-level, unsafe operations for working with one-hot encoded enumeration values represented as bit vectors. It includes functions for converting between enumerated values and their one-hot bit vector representations without runtime safety checks. Use cases include performance-critical hardware description code where one-hot encodings are manually managed for efficiency or interface compatibility.",
      "description_length": 421,
      "index": 93,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Async_fifo.Make.O.Of_signal",
      "library": "hardcaml",
      "description": "This module provides combinational and registered signal interface manipulation for hardware design, supporting operations like constant assignment, signal concatenation/multiplexing, register pipeline creation, and RTL-level wiring. It works with `comb` and `t` types representing unregistered and registered signal interfaces, enabling width validation, structural composition, and naming management. These utilities are specifically used to implement asynchronous FIFOs with parameterizable depths (constrained by LUT_SIZE limits) and to manage their internal signal connectivity, synchronization logic, and hierarchical naming during synthesis.",
      "description_length": 648,
      "index": 94,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.With_valid.Vector.Make_comb",
      "library": "hardcaml",
      "description": "This module provides operations for manipulating vector interfaces with valid signals using combinational logic. It supports packing and unpacking interfaces to and from vectors, multiplexing and concatenating interfaces, and validating signal widths. Concrete use cases include building complex signal routing structures, such as priority encoders or multiplexed data paths, in hardware descriptions.",
      "description_length": 401,
      "index": 95,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Pair.Wrap.All",
      "library": "hardcaml",
      "description": "This module provides the `all` function, which transforms a pair of monadic values into a monadic pair, effectively lifting the monad outside the pair structure. It operates on data types involving pairs (`t`) where each element is wrapped in a monad (`M.t`). A concrete use case is combining two computations in a monadic context, such as reading two signals in a hardware description and treating them as a single combined signal.",
      "description_length": 432,
      "index": 96,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Enum.Make_enums.One_hot.Of_always",
      "library": "hardcaml",
      "description": "This module provides functions to manipulate one-hot encoded signals within Hardcaml's Always blocks. It supports creating and assigning register and wire variables, applying hierarchical names, and performing conditional execution via pattern matching. Use cases include implementing finite state machines and multiplexing logic where one-hot encoding simplifies transition logic and reduces synthesis artifacts.",
      "description_length": 413,
      "index": 97,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Fifo.With_interface.I.Of_signal",
      "library": "hardcaml",
      "description": "This module supports constructing and manipulating signal-driven FIFO interfaces through operations like packing/unpacking into vectors, multiplexing, concatenation, and priority/onehot selection, alongside creating wires, registers, and pipelines. It operates on structured interfaces (`I.Of_signal.t`) composed of `Hardcaml.Signal.t` values, enabling use cases such as connecting FIFO pipelines with named signal hierarchies and applying naming transformations for design clarity. Specific applications include building hierarchical FIFOs with showahead functionality and managing complex signal routing in synchronous hardware designs.",
      "description_length": 638,
      "index": 98,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Types.With_valid.Vector.All",
      "library": "hardcaml",
      "description": "This module provides a function `all` that transforms a vector of monadic values into a monadic vector of values, effectively lifting the monad outside the vector structure. It operates on vectors where each element is wrapped in a monad, allowing the collection to be processed as a single monadic computation. A typical use case involves combining multiple signal computations in a hardware description context, where each signal is represented as a monadic value within a vector.",
      "description_length": 482,
      "index": 99,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Types.With_valid.Wrap.S-Of_bits",
      "library": "hardcaml",
      "description": "This module handles bit-level signal manipulation in hardware descriptions, providing operations to pack, unpack, concatenate, and multiplex structured interfaces. It works with fixed-width bit vectors and interfaces defined by `With_valid.t2`, ensuring correct signal widths during synthesis. Use cases include building register files, decoding instruction fields, and constructing memory-mapped peripherals.",
      "description_length": 409,
      "index": 100,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.With_valid.Wrap.M.S",
      "library": "hardcaml",
      "description": "This module provides operations for structured manipulation of hardware signals with validity, including mapping, zipping, folding, and scanning over tuples or lists of signals, as well as converting between interfaces and bit-level representations. It works with signal types (`'a t`) and interface descriptions, supporting combinational logic synthesis, metadata introspection (names, widths), and stateful computations. Specific use cases include building or transforming hardware interfaces, error handling during signal processing, and extracting signal values with fallback defaults.",
      "description_length": 589,
      "index": 101,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Enum.Make_enums.Binary.Comb",
      "library": "hardcaml",
      "description": "This module provides operations for manipulating binary-encoded enumeration interfaces as vectors. It supports packing and unpacking enum values to and from bit vectors, multiplexing between multiple enum interfaces, and constructing constants from integer values. Use cases include converting enum types to hardware-friendly binary representations, selecting between multiple enum signals using priority or one-hot logic, and validating bit widths during simulation or synthesis.",
      "description_length": 480,
      "index": 102,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Flags_vector.Make.Flags.Unstable",
      "library": "hardcaml",
      "description": "This module implements serialization and comparison operations for a set of flag values, supporting binary and S-expression encoding/decoding. It works directly with the `Flags.Unstable.t` type, which represents a collection of named boolean flags. Concrete use cases include persisting flag configurations to disk, transmitting them over a network, or comparing flag states in testing and configuration management.",
      "description_length": 415,
      "index": 103,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Enum.Make_enums.Binary.Of_signal",
      "library": "hardcaml",
      "description": "This module provides utilities for manipulating binary signals representing enumeration values in hardware designs. It supports operations like converting between enum and raw signal representations, multiplexing over enum cases, comparing enum signals, and composing signal bits via concatenation or register stages. These functions work with `Signal.t` and `Binary.Of_signal.t` types, enabling use cases such as building state machines, implementing conditional logic, and validating enum-encoded data paths.",
      "description_length": 510,
      "index": 104,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Bits.Mutable.Comb.Unsigned",
      "library": "hardcaml",
      "description": "This module provides arithmetic and comparison operations for unsigned bit vectors used in digital circuit simulation. It supports addition, subtraction, multiplication, and comparisons like less than or equal, directly on mutable bit vectors, automatically handling width adjustments. These operations are used to model combinational logic circuits where bit vector widths and values change dynamically during simulation.",
      "description_length": 422,
      "index": 105,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Fifo.With_interface.I.Of_bits",
      "library": "hardcaml",
      "description": "This module provides operations to construct, manipulate, and validate FIFO interfaces using bit vectors. It supports packing and unpacking interfaces to and from bit vectors, multiplexing and concatenating interfaces, and selecting between interfaces using priority or one-hot encoding. Concrete use cases include building hardware FIFOs with fixed or dynamic control signals, validating signal widths during simulation, and constructing constant or integer-initialized FIFO interfaces for testbenches.",
      "description_length": 503,
      "index": 106,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Bits.Mutable.Comb.Signed",
      "library": "hardcaml",
      "description": "This module provides operations for working with signed, mutable bit vectors, including arithmetic operations like addition, subtraction, and multiplication, which return results widened by one bit to prevent truncation. It supports comparison operations between signed vectors of differing widths, returning boolean results as vectors. These operations are used for simulating and manipulating signed integer values in hardware descriptions where mutability improves performance.",
      "description_length": 480,
      "index": 107,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Async_fifo.Make.O.Names_and_widths",
      "library": "hardcaml",
      "description": "This module defines the interface for an asynchronous FIFO by specifying port names and their corresponding bit widths. It provides concrete values for port names, port widths, and tags used in the FIFO implementation. These values are used to generate hardware descriptions with precise signal naming and sizing for synthesis and simulation.",
      "description_length": 342,
      "index": 108,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.With_valid.Fields.S-Make_comb",
      "library": "hardcaml",
      "description": "This module provides operations to manipulate structured hardware interfaces with combinational logic, including packing/unpacking to vectors, multiplexing, concatenation, and selection functions. It works with interfaces of type `comb t`, where each field has a defined bit width and combinational logic type `Comb.t`. Concrete use cases include building and validating hardware structures like register files, control logic multiplexers, and data path components with precise bit-level control.",
      "description_length": 496,
      "index": 109,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Types.Pair.Wrap.Of_signal",
      "library": "hardcaml",
      "description": "This module supports tasks such as constant assignment, multiplexing, concatenation, and register pipeline creation for hardware signal interfaces, while also enabling connection management and name customization through operations like input/output wire generation and prefix application. The primary data structures are `Of_signal.t` and `Of_signal.comb t`, representing hierarchical signal bundles with combinational or registered semantics, used in structural synthesis and component integration scenarios requiring precise timing control and signal routing.",
      "description_length": 562,
      "index": 110,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Fifo.With_interface.I.Make_comb",
      "library": "hardcaml",
      "description": "This module provides combinational logic operations for constructing and manipulating FIFO interfaces, including packing/unpacking interfaces to vectors, multiplexing, concatenation, and selection functions with support for valid signals. It works with interface types parameterized by a combinational logic type, allowing direct manipulation of signal vectors and structured data fields. Concrete use cases include building custom FIFO control logic, routing data paths, and implementing arbitration schemes in hardware designs.",
      "description_length": 529,
      "index": 111,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Fifo.With_interface.O.Of_bits",
      "library": "hardcaml",
      "description": "This module provides operations to manipulate FIFO interfaces represented as bit vectors. It supports packing and unpacking interfaces to and from bit vectors, multiplexing between interfaces, concatenating interfaces, and selecting between multiple interfaces using priority or one-hot encoding. These operations are used to build and verify synchronous FIFOs with fixed bit-width fields, ensuring correct signal widths and enabling constant initialization.",
      "description_length": 458,
      "index": 112,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Bits.Mutable.Comb.Sop",
      "library": "hardcaml",
      "description": "This module provides arithmetic and comparison operations for mutable bit vectors, including addition, subtraction, multiplication, and comparisons like less than or equal. It supports operations on `Comb.t` values, which represent combinational logic signals in Hardcaml, and handles automatic sign extension and resizing. These functions are used when implementing arithmetic logic units (ALUs) or comparison-based control logic in hardware simulations.",
      "description_length": 455,
      "index": 113,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.With_valid.Wrap.Make.Of_signal",
      "library": "hardcaml",
      "description": "This module provides combinational logic and register-based operations for constructing and validating hardware interfaces, supporting tasks like signal packing, muxing, concatenation, and priority encoding over interface-typed signals. It operates on structured types such as `'a X.t` and `With_valid.t2`, facilitating wire connections, register pipelines, and hierarchical signal naming through dedicated wiring and naming functions. It is used in hardware design workflows to build and manage complex signal hierarchies, connect input/output interfaces, and enforce naming conventions in circuit descriptions.",
      "description_length": 612,
      "index": 114,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Enum.Make_enums.Binary.Unsafe_assoc_by_port_name",
      "library": "hardcaml",
      "description": "This module provides `to_alist` and `of_alist` functions for converting between binary representations of enumeration types and association lists indexed by field names. It operates on `Binary.t` values derived from variant types with no arguments, enabling direct mapping between field names and their corresponding binary data. Use this to serialize or deserialize named fields of an enum interface using string-keyed lists, particularly when working with hardware descriptions that require explicit port naming.",
      "description_length": 514,
      "index": 115,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Pair.M.S-Make_comb",
      "library": "hardcaml",
      "description": "This module implements combinational logic operations for manipulating structured signal interfaces. It supports operations like packing/unpacking signals to vectors, multiplexing, concatenation, and selection from one-hot or priority-encoded inputs. These functions are used to build and verify hardware interfaces with precise bit-width control, such as assembling register file outputs or decoding control signals.",
      "description_length": 417,
      "index": 116,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.With_valid.Wrap.Make.Of_bits",
      "library": "hardcaml",
      "description": "This module provides functions to construct and manipulate hardware interfaces using bit vectors. It supports operations like packing/unpacking interfaces to/from bit vectors, multiplexing, concatenation, and validation of signal widths. Concrete use cases include building register files, memory interfaces, and control logic where fixed-width bit fields are used to represent valid/data signals.",
      "description_length": 397,
      "index": 117,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Types.With_valid.Fields.S-module-type-Comb",
      "library": "hardcaml",
      "description": "This module provides operations for constructing and manipulating hardware interfaces with combinational logic. It supports data types like `comb t` for representing structured hardware signals and `Sexplib0.Sexp.t` for serialization. Concrete use cases include packing/unpacking interfaces into vectors, multiplexing between multiple interfaces, concatenating interfaces, and selecting between one-hot or priority-encoded inputs.",
      "description_length": 430,
      "index": 118,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.With_valid.Fields.Make.Of_always",
      "library": "hardcaml",
      "description": "This module provides functions to manipulate and assign signals within an always block for a structured interface. It supports creating registers, wires, and named signal fields, specifically working with `Hardcaml.Always.Variable.t` and `Hardcaml.Signal.t` types. Use it to build and manage hardware interfaces with valid signals in a synchronous design context.",
      "description_length": 363,
      "index": 119,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Types.Pair.Wrap.Names_and_widths",
      "library": "hardcaml",
      "description": "This module defines lists of port names and their corresponding widths, along with a list of tags, used to describe hardware interface signals in Hardcaml. It provides direct access to these lists through simple value bindings. Concrete use cases include generating signal declarations, configuring hardware module interfaces, and supporting introspection during simulation or synthesis.",
      "description_length": 387,
      "index": 120,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Clocking.Make.Names_and_widths",
      "library": "hardcaml",
      "description": "This module defines clocking-related port names, widths, and tags for hardware description in Hardcaml. It provides direct access to lists of port names, port widths, and associated tags used in clock domain configurations. These values are used to specify and generate clocking infrastructure in hardware designs, such as clock signals and reset lines for synchronous logic.",
      "description_length": 375,
      "index": 121,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Pair.Wrap.Unsafe_assoc_by_port_name",
      "library": "hardcaml",
      "description": "This module provides direct conversions between a product type and an association list indexed by field names. It supports operations to_alist and of_alist for serializing and reconstructing values using string keys corresponding to port names. This is useful when mapping hardware interface signals to named entries in a list or parsing such structures from external representations.",
      "description_length": 384,
      "index": 122,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Enum.Make_enums.One_hot.Comb",
      "library": "hardcaml",
      "description": "This module represents enumeration types using one-hot encoding in combinational logic. It provides operations to construct, validate, and manipulate one-hot encoded signals, including packing/unpacking to bit vectors, multiplexing, concatenation, and selection functions. Concrete use cases include building state machines, control logic, and hardware interfaces where one-hot encoding improves performance or simplifies correctness checks.",
      "description_length": 441,
      "index": 123,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Enum.Make_enums.One_hot.Of_bits",
      "library": "hardcaml",
      "description": "This module enables the creation and manipulation of one-hot encoded enumeration interfaces using bit vectors, supporting operations like integer conversion, bit-level packing/unpacking, multiplexing, and priority/one-hot selection. It works with `t` values representing enumerated states and `Hardcaml.Bits.t` for low-level bit manipulation, facilitating hardware synthesis tasks. Specific applications include implementing priority-encoded logic, safe multiplexer circuits, and state machine encodings where one-hot representations improve timing or reduce combinational logic complexity.",
      "description_length": 590,
      "index": 124,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.With_valid.Wrap.M.S-All",
      "library": "hardcaml",
      "description": "Combines a structure of monadic values into a single monadic value, lifting the monad outside the interface. Works with any monad `M` and interfaces containing values wrapped in `With_valid.t2`. Useful for aggregating results from multiple concurrent operations while preserving validity signals.",
      "description_length": 296,
      "index": 125,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.With_valid.Wrap.S",
      "library": "hardcaml",
      "description": "This module supports structural transformation and metadata manipulation of hardware interfaces composed of value tuples paired with validity signals. It provides operations for mapping, zipping, and folding over signal tuples, extracting port names and widths, and converting interfaces to list representations or combinational logic. These capabilities are particularly useful for constructing pipelined hardware designs, integrating with simulation frameworks, or compiling hardware descriptions where validity tracking and structural introspection are required.",
      "description_length": 565,
      "index": 126,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Fifo.With_interface.I.Names_and_widths",
      "library": "hardcaml",
      "description": "This module defines the names and widths of ports for a FIFO interface, providing direct access to port metadata as lists of strings and integers. It works with FIFO interfaces that include tags, port names, and bit-width specifications. Concrete use cases include inspecting or generating FIFO port configurations for simulation or synthesis, where explicit port naming and sizing are required.",
      "description_length": 395,
      "index": 127,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.With_valid.Fields.S-Of_always",
      "library": "hardcaml",
      "description": "This module provides functions to construct and manipulate hardware interfaces using the Always API, specifically for creating and assigning register and wire signals within an always block. It works with interface types parameterized by `Hardcaml.Always.Variable.t` and supports concrete operations like signal assignment, register instantiation, and wire creation with customizable naming. Use cases include building synchronous logic blocks where interface fields are assigned to registers or wires with specific enable conditions and naming conventions.",
      "description_length": 557,
      "index": 128,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.With_valid.Wrap.S-Make_comb",
      "library": "hardcaml",
      "description": "This module provides combinational logic operations for packing, unpacking, and multiplexing hardware interfaces. It works with signal vectors and structured interfaces using a combinatorial logic type. Concrete uses include building priority encoders, concatenating signal buses, and validating signal widths in hardware descriptions.",
      "description_length": 335,
      "index": 129,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Fifo.With_interface.O.Of_always",
      "library": "hardcaml",
      "description": "This module provides functions to manipulate and assign values to FIFO interfaces using the Always API. It supports operations like creating register and wire variables, assigning signals within always blocks, and applying naming conventions to interface fields. These functions are used to build and manage synchronous FIFOs with structured interfaces in hardware descriptions.",
      "description_length": 378,
      "index": 130,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Async_fifo.Make.O.Comb",
      "library": "hardcaml",
      "description": "This module provides combinational logic operations for manipulating FIFO interfaces, including packing/unpacking signals, multiplexing, concatenation, and selection functions. It works with the `comb` type and structured FIFO interfaces defined in the `O` module. Concrete use cases include building control logic for asynchronous FIFOs, such as selecting valid data sources, validating signal widths, and constructing complex signal routing from basic combinational elements.",
      "description_length": 477,
      "index": 131,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.With_valid.Fields.Make.Names_and_widths",
      "library": "hardcaml",
      "description": "This module generates port names and widths for a Hardcaml interface, producing lists of string names, integer widths, and typed tags. It operates on a polymorphic record type `'a With_valid.t X.t` to extract structural interface information. Use it to define and inspect signal interfaces in hardware descriptions, particularly when mapping to HDL ports or validating signal widths.",
      "description_length": 383,
      "index": 132,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Types.With_valid.Fields.S-Of_signal",
      "library": "hardcaml",
      "description": "This module enables the construction and manipulation of hardware interfaces through signal composition, validation, and wiring. It operates on `Of_signal.comb t` and `Of_signal.t` types, representing combinational and sequential signals, and provides utilities for tasks like concatenation, multiplexing, register creation, and signal width validation. These operations are used to define data paths, connect hardware components, and enforce naming conventions in hierarchical designs.",
      "description_length": 486,
      "index": 133,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Clocking.Make.All",
      "library": "hardcaml",
      "description": "Lifts monadic values within an interface structure to a monadic interface, enabling sequential composition of interface elements. Works with polymorphic interface types `'a t` and a monad `M`. Useful for combining multiple clocked signals into a single monadic computation.",
      "description_length": 273,
      "index": 134,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.With_valid.Wrap.M.S-Names_and_widths",
      "library": "hardcaml",
      "description": "This module defines operations to construct and manipulate Hardcaml interfaces with associated validity signals, specifically exposing port names and widths as lists. It works with tuples of the form ('a, 'a X.t) and provides access to metadata like port names, widths, and tags. Concrete use cases include generating signal interfaces for hardware components where each signal has a corresponding validity indicator, enabling structured I/O handling in circuit descriptions.",
      "description_length": 475,
      "index": 135,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Fifo.With_interface.O.Of_signal",
      "library": "hardcaml",
      "description": "This module provides operations for constructing and manipulating signal interfaces representing synchronous FIFOs, focusing on tasks like packing/unpacking, multiplexing, concatenation, and pipeline insertion. It works with `O.Of_signal.t` values, which model hardware signal bundles, and supports connecting named signals via operators like `<==` for circuit wiring. It is particularly useful for implementing FIFO-based buffering in digital circuits with pipelined or synchronized data paths.",
      "description_length": 495,
      "index": 136,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Bits.Mutable.Comb.Uop",
      "library": "hardcaml",
      "description": "This module performs arithmetic and comparison operations on mutable bit vectors, including addition, subtraction, multiplication, and comparisons like less than or equal. It works directly with `Hardcaml.Bits.Mutable.Comb.t`, supporting operations between vectors of different widths and automatically handling sign extension and resizing. Concrete use cases include implementing combinational logic circuits where mutable bit vectors are used to model register-transfer level (RTL) behavior with dynamic width adjustments.",
      "description_length": 524,
      "index": 137,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.With_valid.Fields.Make.Of_bits",
      "library": "hardcaml",
      "description": "This module provides functions to construct, manipulate, and validate bit-level hardware interfaces with explicit field widths. It supports operations like packing/unpacking interfaces to/from bit vectors, multiplexing, concatenation, and selection mechanisms such as priority and one-hot selects. Concrete use cases include defining register layouts, decoding instruction fields, and building bus interfaces with strict width constraints.",
      "description_length": 439,
      "index": 138,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Pair.M.S-Of_always",
      "library": "hardcaml",
      "description": "This module provides functions to create and manipulate interface containers with register and wire variables within an always block. It supports operations like assigning signals to variables, creating registers with optional enable signals, and applying naming conventions to interface fields. Concrete use cases include building hardware interfaces with named signals, initializing wires to specific values, and managing register state in sequential logic blocks.",
      "description_length": 466,
      "index": 139,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Enum.Make_enums.One_hot.Unsafe_assoc_by_port_name",
      "library": "hardcaml",
      "description": "This module provides direct, unsafe conversions between one-hot encoded signals and string-keyed association lists, using port names to map fields. It operates on one-hot encoded data structures where each field corresponds to a named signal. Use this when interfacing with external systems that require string-based field selection or dynamic signal routing by name.",
      "description_length": 367,
      "index": 140,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.With_valid.Vector.Unsafe_assoc_by_port_name",
      "library": "hardcaml",
      "description": "This module provides direct conversions between a polymorphic vector type and association lists indexed by string field names. It supports extracting field-value pairs from a vector and constructing vectors from such lists, using field names as keys. These operations are useful for debugging, serialization, or dynamic field access when working with hardware description data structures.",
      "description_length": 388,
      "index": 141,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Types.Clocking.Make.Var",
      "library": "hardcaml",
      "description": "Implements clocked register logic with optional enable and reset behavior. Works with signal types and variables to create stateful hardware components. Useful for building counters, state machines, and pipeline stages where controlled data storage is required.",
      "description_length": 261,
      "index": 142,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.With_valid.Vector.Of_always",
      "library": "hardcaml",
      "description": "This module provides functions to manipulate and assign values to hardware description interfaces using the Always API. It supports operations on `Always.Variable.t` and `Signal.t` types, enabling register and wire creation, signal assignment, and field naming within an interface. Concrete use cases include building synchronous logic blocks with named registers and wires, assigning signal values in always blocks, and structuring hierarchical hardware designs with clear field identifiers.",
      "description_length": 492,
      "index": 143,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Async_fifo.Make.O.Of_bits",
      "library": "hardcaml",
      "description": "This module provides operations to construct and manipulate asynchronous FIFO interfaces using bit vectors. It supports packing and unpacking interfaces to and from bit vectors, multiplexing between multiple interfaces, concatenation, and selection operations with priority or one-hot encoding. These functions are used to implement hardware circuits with precise bit-level control, particularly in scenarios requiring asynchronous data transfer between clock domains with fixed-width signals.",
      "description_length": 493,
      "index": 144,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.With_valid.Wrap.S-module-type-Comb",
      "library": "hardcaml",
      "description": "This module provides combinational logic operations for manipulating hardware interfaces with valid signals. It supports packing and unpacking interfaces to and from vectors, multiplexing between interface values, concatenation, and selection operations like priority and onehot selects. Concrete use cases include building multiplexers, demultiplexers, and control logic that selects between multiple hardware interface inputs based on control signals.",
      "description_length": 453,
      "index": 145,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.With_valid.Fields.M.S-Of_bits",
      "library": "hardcaml",
      "description": "This module provides operations to construct, validate, and manipulate bit-level hardware interfaces with explicit field definitions. It supports functions like packing/unpacking interfaces to/from bit vectors, multiplexing, concatenation, and selection operations such as priority and one-hot decoding. Concrete use cases include building register interfaces, decoding control signals, and assembling complex hardware structures from fixed-width bit fields.",
      "description_length": 458,
      "index": 146,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.With_valid.Fields.Make.Unsafe_assoc_by_port_name",
      "library": "hardcaml",
      "description": "This module provides direct, unchecked conversion between structured interfaces and string-indexed association lists, enabling field access and construction by port name. It operates on `'a t` interface types, transforming them to and from `(string * 'a) list` representations. Use this when mapping hardware interface signals to named ports in a flattened or dynamic context, such as generating port lists for simulation or synthesis.",
      "description_length": 435,
      "index": 147,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.With_valid.Fields.Make",
      "library": "hardcaml",
      "description": "This module enables the transformation, combination, and validation of structured hardware interfaces with tagged, valid signals, supporting tuple and list-based combinators for zipping, mapping, and folding over signals. It centers around the `'a t` data type representing hardware interfaces with named, typed fields, and provides operations for converting between bit vectors, signals, and structured values, such as building interfaces from bit streams or applying validity-aware combinational logic. Submodules extend this foundation with combinational operations like multiplexing and priority selection on `comb t`, monadic lifting for aggregating structured results, and utilities for mapping interfaces to association lists or Hardcaml ports with explicit widths and names. Use cases include constructing register file ports, control multiplexers, pipeline stages, and simulation interfaces, with support for both flat bit vector conversions and hierarchical, named signal connections.",
      "description_length": 994,
      "index": 148,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.With_valid.Wrap.Make.Names_and_widths",
      "library": "hardcaml",
      "description": "This module generates port names and widths for a Hardcaml interface, providing direct access to lists of port names, widths, and associated tags. It operates on type parameters representing signal types and their wrapped counterparts with validity. Use this to define and inspect interface layouts in Hardcaml designs, such as when constructing or verifying signal bundles with validity flags.",
      "description_length": 394,
      "index": 149,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Pair.M.S-All",
      "library": "hardcaml",
      "description": "Lifts monadic values within a pair structure, combining them into a single monadic result. Works with monadic values wrapped in a pair type, where the monad is defined by the parameter module `M`. Useful for handling computations that return pairs of values within a monadic context, such as accumulating state while processing hardware description elements in Hardcaml.",
      "description_length": 370,
      "index": 150,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Enum.Make_enums.Binary.Unsafe",
      "library": "hardcaml",
      "description": "This module provides low-level, unsafe operations for creating and manipulating binary representations of enumeration types. It works directly with binary values and variant types that have no arguments, enabling efficient conversion between variants and their binary encodings. Use cases include optimizing performance-critical sections of hardware description code where safety checks can be omitted.",
      "description_length": 402,
      "index": 151,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Types.Pair.M.S-Of_signal",
      "library": "hardcaml",
      "description": "This module enables the construction and transformation of hardware interfaces through operations like packing, multiplexing, and concatenating signal vectors, as well as creating register pipelines. It operates on structured signal types (`Of_signal.comb t` and `Of_signal.t`) that represent hardware signals with defined field widths, supporting use cases such as hierarchical module interconnects and named port wiring via operators like `<==`.",
      "description_length": 447,
      "index": 152,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Clocking.Make.Unsafe_assoc_by_port_name",
      "library": "hardcaml",
      "description": "This module provides direct conversions between a structured interface and an association list indexed by field names. It supports any data type that can be represented as a record or interface with named ports. These functions are used to dynamically inspect or construct hardware interfaces by name, enabling runtime manipulation of signal mappings.",
      "description_length": 351,
      "index": 153,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.With_valid.Fields.M.S-Make_comb",
      "library": "hardcaml",
      "description": "This module implements combinational logic operations for manipulating structured interfaces with valid signals. It supports operations like packing/unpacking interfaces to/from bit vectors, multiplexing, concatenation, and priority/onehot selection, all working with `comb t` interfaces where each field has a defined bit width. Use cases include building complex signal routing logic, decoding instruction fields, or constructing state machine transitions directly from hardware description code.",
      "description_length": 498,
      "index": 154,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.With_valid.Fields.S-Of_bits",
      "library": "hardcaml",
      "description": "This module handles bit-level manipulation and validation of structured interfaces with valid signals. It supports operations like packing/unpacking interfaces to/from bit vectors, multiplexing, concatenation, and selection from one-hot or priority-encoded inputs. Concrete use cases include hardware interface validation, signal routing, and register file or packet format manipulation.",
      "description_length": 387,
      "index": 155,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.With_valid.Wrap.M.S-module-type-Comb",
      "library": "hardcaml",
      "description": "This module provides combinational logic operations for packing, unpacking, and multiplexing hardware interfaces with valid signals. It works with fixed-width signal types represented as `comb t`, supporting operations like concatenation, priority selection, and one-hot selection. Concrete use cases include constructing and validating hardware interfaces, routing signals based on control inputs, and converting between structured interfaces and flat bit vectors.",
      "description_length": 465,
      "index": 156,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.With_valid.Fields.M",
      "library": "hardcaml",
      "description": "This module enables structured manipulation of hardware interfaces with combinational and registered signals, supporting operations like packing/unpacking, multiplexing, concatenation, and validation with bitwidth control. It works with data types such as `With_valid.t`, `comb t`, and interfaces composed of signals and monadic values, allowing precise construction and transformation of digital designs. Examples include defining register pipelines with enables, creating priority multiplexers, lifting monads over interface structures, and dynamically inspecting or constructing interfaces by port names. It also supports bit-level operations, hierarchical naming, and metadata-driven transformations for simulation, validation, and synthesis workflows.",
      "description_length": 756,
      "index": 157,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Fifo.With_interface.O.All",
      "library": "hardcaml",
      "description": "Lifts monadic values within an interface structure, combining them into a single monadic interface. Works with any monadic type `M` and interface types `'a M.t O.t`. Useful for composing multiple FIFO operations within a shared monadic context, such as building complex pipelines or synchronized data flows.",
      "description_length": 307,
      "index": 158,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Fifo.With_interface.O.Comb",
      "library": "hardcaml",
      "description": "This module provides combinational logic operations for constructing and manipulating FIFO interfaces using bit vectors. It supports packing/unpacking interfaces to/from vectors, multiplexing and concatenating interface values, and selecting between prioritized or one-hot encoded inputs. Concrete use cases include building custom FIFO control logic, routing data between hardware modules, and implementing arbitration schemes with fixed or dynamic selection criteria.",
      "description_length": 469,
      "index": 159,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Fifo.With_interface.I.All",
      "library": "hardcaml",
      "description": "Lifts monadic values within an interface to a monad wrapping the entire interface. Works with any monad `M` and interface `I` containing signals. Useful for combining multiple monadic computations across interface signals into a single monadic result.",
      "description_length": 251,
      "index": 160,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.With_valid.Fields.M.S-Names_and_widths",
      "library": "hardcaml",
      "description": "This module defines operations to access and manipulate the names and widths of ports in a Hardcaml interface. It provides direct access to port metadata as lists of strings and integers, and supports tagging of ports for further categorization. Use this module when constructing or inspecting hardware interfaces where port details need to be explicitly handled, such as generating netlists or validating signal widths.",
      "description_length": 420,
      "index": 161,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Types.Pair.M.S-Names_and_widths",
      "library": "hardcaml",
      "description": "This module defines a list of signal ports with their associated names and bit widths, along with a list of tags. It provides direct access to separate lists of port names, port widths, and tags. Useful for describing hardware interfaces where named signals have fixed bit widths and metadata tags.",
      "description_length": 298,
      "index": 162,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Bits.Mutable.Comb.Typed_math",
      "library": "hardcaml",
      "description": "This module provides arithmetic and comparison operations for a mutable bit vector type `v`, supporting addition, subtraction, multiplication, and comparisons like less than or equal, greater than, etc. It works directly with fixed-width bit vectors, handling sign extension and resizing as needed during operations. Concrete use cases include implementing digital circuit simulations where bit-accurate arithmetic and comparisons are required, such as in ALUs or control logic within hardware descriptions.",
      "description_length": 507,
      "index": 163,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Enum.Make_enums.Binary.Names_and_widths",
      "library": "hardcaml",
      "description": "This module generates enumerated type representations with binary encoding, providing lists of port names and widths for hardware interface construction. It works with variant types to derive string-int pairs for port identifiers and bit widths, along with binary tags for serialization. Concrete use cases include defining register fields, instruction opcodes, or state machine values in hardware descriptions where binary encoding is required.",
      "description_length": 445,
      "index": 164,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Pair.Wrap.Comb",
      "library": "hardcaml",
      "description": "This module provides operations for constructing and manipulating hardware interfaces composed of signal vectors. It supports concrete tasks like packing and unpacking signals into vectors, multiplexing between interface values, concatenating interfaces, and selecting signals based on one-hot or priority-encoded inputs. The module works directly with signal vectors (`comb`) and structured interface types (`t`), enabling precise control over signal widths and layout in hardware descriptions.",
      "description_length": 495,
      "index": 165,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Interface.Ast.Sequence.Kind",
      "library": "hardcaml",
      "description": "This module defines the kinds of sequences used to represent structured groups of signals in hardware descriptions. It supports operations to convert these sequence kinds to S-expressions for serialization and debugging. Concrete use cases include specifying array or list structures when defining hardware interfaces with fixed-width signals.",
      "description_length": 343,
      "index": 166,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Pair.Wrap.Of_always",
      "library": "hardcaml",
      "description": "This module provides functions to manipulate and assign values to hardware description interfaces within an `always` block. It supports operations like creating register and wire variables, assigning signals, and applying naming conventions to interface fields. Concrete use cases include building and managing structured hardware components with named signals in a declarative style.",
      "description_length": 384,
      "index": 167,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.With_valid.Vector.Of_bits",
      "library": "hardcaml",
      "description": "This module provides operations to construct, manipulate, and validate bit vector interfaces. It supports packing and unpacking interfaces into flat bit vectors, multiplexing between interface values, concatenation, and selection operations including priority and one-hot decoding. Concrete uses include assembling and disassembling hardware signals for simulation or synthesis, and validating signal widths during design elaboration.",
      "description_length": 434,
      "index": 168,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Async_fifo.Make.I.Comb",
      "library": "hardcaml",
      "description": "This module provides combinational logic operations for constructing and manipulating hardware interfaces using vectors and constants. It supports packing and unpacking interfaces to and from bit vectors, multiplexing between multiple interfaces, concatenation, and selection operations like priority and one-hot decoding. These operations are used to build complex signal routing and control logic directly in the combinational domain, such as decoding control signals, routing data paths, or constructing constant-initialized interfaces.",
      "description_length": 539,
      "index": 169,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Fifo.With_interface.O.Unsafe_assoc_by_port_name",
      "library": "hardcaml",
      "description": "This module provides direct, unsafe conversions between FIFO interface values and association lists indexed by field names. It operates on values of type `'a O.t` and `(string * 'a) list`, enabling concrete use cases such as inspecting or constructing FIFO interfaces from named field mappings. These functions are useful when interfacing with external systems or debugging, where named access to FIFO fields is required.",
      "description_length": 421,
      "index": 170,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.With_valid.Fields.M.S-Of_always",
      "library": "hardcaml",
      "description": "This module provides functions to construct and manipulate hardware interfaces using the Always API, specifically for creating and assigning register and wire signals within an always block. It works with interface types parameterized by `Hardcaml.Always.Variable.t` and supports concrete operations like signal assignment, register instantiation, and wire creation with default values. Use cases include building synchronous logic blocks where interface fields are updated conditionally or combinational logic with named wires and registers.",
      "description_length": 542,
      "index": 171,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Types.Clocking.Make.Of_always",
      "library": "hardcaml",
      "description": "This module provides functions to create and manipulate clocked and combinational logic elements using the Always API with interfaces. It supports operations like assigning signals to variables, creating registers with optional enable signals, and defining wire variables with default values. Concrete use cases include building synchronous hardware blocks like state machines, pipelines, and control logic where signal assignments and register updates are expressed within always blocks.",
      "description_length": 488,
      "index": 172,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Types.With_valid.Wrap.S-Unsafe_assoc_by_port_name",
      "library": "hardcaml",
      "description": "This module directly maps record fields to and from an association list using field names as keys. It supports converting structured data to and from lists of key-value pairs, where each key is a string corresponding to a field name. Use this when interfacing with external systems that require named field access or when dynamically constructing and deconstructing records by field names.",
      "description_length": 389,
      "index": 173,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Async_fifo.Make.I.Unsafe_assoc_by_port_name",
      "library": "hardcaml",
      "description": "This module provides direct, unsafe access to FIFO interface fields by name through association lists. It converts FIFO interfaces to and from string-keyed lists of values, enabling dynamic field manipulation. Use cases include runtime configuration of FIFO signals and debugging via named signal inspection.",
      "description_length": 308,
      "index": 174,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Enum.Make_enums.Binary.Of_bits",
      "library": "hardcaml",
      "description": "This module supports operations such as conversion between enumerated values and integer/bit vector representations, bit vector concatenation/multiplexing, validation of binary encodings, and priority/one-hot selection logic. It operates on enumerated types and their binary counterparts represented via `Bits.t`, enabling structured manipulation of hardware-level data. These capabilities are particularly useful for tasks like decoding instruction sets, implementing state machine transitions, or handling configuration registers where compact binary representations and efficient selection between cases are required.",
      "description_length": 620,
      "index": 175,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Async_fifo.Make.O.Unsafe_assoc_by_port_name",
      "library": "hardcaml",
      "description": "This module provides direct, unsafe conversions between a FIFO interface and an association list indexed by port names. It operates on the `O.t` type, which represents the output interface of a FIFO, and lists of string-keyed values. Use this module to inspect or construct FIFO outputs by field name, bypassing type safety for performance.",
      "description_length": 340,
      "index": 176,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Pair.M.S-module-type-Comb",
      "library": "hardcaml",
      "description": "This module provides operations for manipulating hardware description signals as packed vectors and structured interfaces. It supports tasks like packing/unpacking signals, multiplexing between interface lists, concatenation, and selecting based on one-hot or priority-encoded inputs. Concrete use cases include building register file outputs, decoding instruction fields, and constructing complex signal routing logic in digital circuits.",
      "description_length": 439,
      "index": 177,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.With_valid.Fields.Make.Comb",
      "library": "hardcaml",
      "description": "This module provides combinational logic operations for manipulating structured interfaces with valid signals. It supports operations like packing/unpacking interfaces to vectors, multiplexing, concatenation, and selection functions such as one-hot and priority selects. These functions are used to build and verify complex signal routing and control logic in hardware designs.",
      "description_length": 377,
      "index": 178,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.With_valid.Vector.Of_signal",
      "library": "hardcaml",
      "description": "This module provides operations for structuring and validating hardware signal interfaces through transformations like concatenation, multiplexing, and register insertion, alongside utilities for connecting and naming signals. It works with `Of_signal.t` values representing hardware interfaces, enabling precise width validation, constant assignment, and structural wiring (e.g., input/output connections using `<==`). Specific use cases include constructing validated hardware pipelines, ensuring correct signal routing in digital circuits, and managing interface names for clarity in complex designs.",
      "description_length": 603,
      "index": 179,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.With_valid.Wrap.Make.Make_comb",
      "library": "hardcaml",
      "description": "This module provides combinational logic operations for packing, unpacking, and multiplexing hardware interfaces. It works with vector and interface types defined by the `Comb` module, enabling bit-level manipulation and signal routing. Concrete uses include constructing muxes, concatenating signals, and validating signal widths in hardware descriptions.",
      "description_length": 356,
      "index": 180,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Fifo.With_interface.I.Comb",
      "library": "hardcaml",
      "description": "This module provides combinational logic operations for constructing and manipulating FIFO interfaces using vectors and constants. It supports packing/unpacking interfaces to/from bit vectors, multiplexing and concatenating interface values, and implementing priority or one-hot selection logic with optional branching factors. Concrete use cases include building control logic for data routing, validation of signal widths during simulation, and synthesis-friendly constant initialization of FIFO fields.",
      "description_length": 505,
      "index": 181,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Types.Pair.M.S-Of_bits",
      "library": "hardcaml",
      "description": "This module handles bit-level manipulation of structured data interfaces, providing operations to pack, unpack, concatenate, and multiplex signals. It works with fixed-width bit vectors and structured types where each field has an associated bit width. Concrete uses include assembling and disassembling hardware interfaces, validating signal widths, and implementing multiplexers or priority encoders for digital circuits.",
      "description_length": 423,
      "index": 182,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.With_valid.Fields.Make.Of_signal",
      "library": "hardcaml",
      "description": "This module provides operations for constructing and transforming hardware interfaces composed of combinational and registered signals, supporting tasks like multiplexing, concatenation, register pipelining, and signal routing. It works with structured interfaces containing `comb t` and `t` types to model signal graphs with control logic, priority encoding, and named wire connections. Typical applications include building pipelined datapaths, implementing control units with dynamic signal selection, and managing hierarchical signal naming in digital circuit designs.",
      "description_length": 572,
      "index": 183,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.With_valid.Wrap.M.S-Unsafe_assoc_by_port_name",
      "library": "hardcaml",
      "description": "This module directly maps record fields to an association list using port names as keys, enabling conversion between structured data and key-value pairs. It operates on tuples of the form ('a, 'a X.t) With_valid.t2, where each field is associated with a string identifier. Use this to serialize or deserialize hardware interfaces for debugging, configuration, or dynamic signal mapping.",
      "description_length": 386,
      "index": 184,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Types.With_valid.Vector.Comb",
      "library": "hardcaml",
      "description": "This module provides operations for manipulating structured hardware interfaces as vectors, including packing/unpacking to and from bit vectors, multiplexing, concatenation, and selection operations like priority and one-hot decoding. It works with `comb t` types representing hardware signals with named fields and associated valid bits. Concrete use cases include building register files, decoding instruction fields, and constructing complex multiplexed data paths in digital circuits.",
      "description_length": 488,
      "index": 185,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.With_valid.Fields.S-Names_and_widths",
      "library": "hardcaml",
      "description": "This module defines operations to access and manipulate the names and widths of ports in a Hardcaml interface that includes a valid signal. It works with lists of strings and integers to represent port names and their bit widths, along with a list of tags for additional metadata. Concrete use cases include generating signal declarations, validating interface layouts, and debugging port configurations in hardware descriptions.",
      "description_length": 429,
      "index": 186,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Fifo.With_interface.I.Of_always",
      "library": "hardcaml",
      "description": "This module provides functions to manipulate and assign values to FIFO interfaces using the Always API. It supports operations like creating register and wire variables, assigning signals, and applying names to interface fields. These functions are used to implement synchronous FIFOs with named, structured interfaces for clarity in hardware descriptions.",
      "description_length": 356,
      "index": 187,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.With_valid.Fields.S-Unsafe_assoc_by_port_name",
      "library": "hardcaml",
      "description": "This module directly associates fields of a Hardcaml interface with their port names using unsafe operations. It enables conversion between interface values and association lists where each field is paired with its string name. Use this when mapping hardware interface signals to named entries in a list, such as for dynamic configuration or debugging.",
      "description_length": 352,
      "index": 188,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Flags_vector.Make.Flags.Set",
      "library": "hardcaml",
      "description": "This module provides a comprehensive toolkit for working with sets of flag values, combining core set operations like union, mapping, and deduplication with advanced serialization, comparison, and diffing capabilities. It centers around a flag-based element type that supports ordered comparisons, S-expression and binary serialization, and hashing, enabling use cases such as managing hardware configurations, parsing command-line flags, and persisting system states. Submodules extend this foundation with binary encoding, diff tracking, and Quickcheck integration, allowing efficient storage, incremental updates, and property-based testing of flag sets. Together, these components facilitate robust handling of flag data across configuration, validation, and inter-system communication scenarios.",
      "description_length": 800,
      "index": 189,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Async_fifo.Make.O.Make_comb",
      "library": "hardcaml",
      "description": "This module provides combinational logic operations for constructing and manipulating structured hardware interfaces, including packing/unpacking signals into vectors, multiplexing, concatenation, and selection functions like priority and one-hot encoding. It works with fixed-width bitvector types and structured interfaces defined by the `Comb` module, enabling precise control over signal routing and transformation. Concrete use cases include building custom data paths, implementing control logic for FIFOs, and managing multi-channel signal routing in hardware designs.",
      "description_length": 575,
      "index": 190,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Async_fifo.Make.I.Names_and_widths",
      "library": "hardcaml",
      "description": "This module defines port names and widths for an asynchronous FIFO implementation. It provides direct access to lists of port names, widths, and associated tags, used to describe FIFO interface signals. These values are used to generate hardware descriptions with correct signal naming and sizing for synthesis and simulation.",
      "description_length": 326,
      "index": 191,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Flags_vector.Make.Flags.Map",
      "library": "hardcaml",
      "description": "This module manages key-value associations where keys are typed and values represent sets of flags, enabling operations like folding, conversion, and serialization with strong type guarantees. It supports building and transforming maps from sequences, lists, or hashtables, handles duplicate keys, and integrates with Quickcheck for property-based testing, S-expressions for structured parsing, and binary formats for efficient storage. Submodules provide flag-specific key types with comparison and serialization, diffing capabilities for incremental updates, and hash operations for integrity checks. Examples include parsing configuration files into flag maps, persisting flag states to disk, comparing hardware configurations, and generating test data with controlled variations.",
      "description_length": 783,
      "index": 192,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Fifo.With_interface.O",
      "library": "hardcaml",
      "description": "This module combines interface manipulation with bit-level operations and monadic composition to support the construction and transformation of FIFO structures in hardware design. It provides core data types for representing FIFO interfaces as signal bundles, bit vectors, and named field mappings, with operations for packing, unpacking, multiplexing, and concatenation, along with support for synchronous logic through register and wire assignments. Submodules enable metadata inspection, unsafe conversions to association lists, and monadic lifting for composing FIFO operations in structured contexts. Examples include building custom FIFO control logic, routing signals between modules, generating hardware descriptions from interface definitions, and implementing pipelined data paths with synchronized buffering.",
      "description_length": 819,
      "index": 193,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Rtl.Signals_name_map.Uid_with_index",
      "library": "hardcaml",
      "description": "This module defines a type representing a signal identifier paired with an integer index, used to map original signal names to their mangled representations in RTL generation. It includes comparison and serialization functions for use in data structures requiring ordering or persistent storage. This type is essential for managing signal identity and indexing during Verilog translation in Hardcaml.",
      "description_length": 400,
      "index": 194,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Interface.Make_interface_with_conversion.Make_comb",
      "library": "hardcaml",
      "description": "This module implements combinational logic operations on structured signal interfaces, enabling manipulation of grouped signals as atomic units. It supports operations like packing/unpacking to vectors, multiplexing, concatenation, and priority/one-hot selection, working with signal groups defined by their bit widths. Concrete use cases include building complex control logic, data path routing, and register file access structures in digital circuit designs.",
      "description_length": 461,
      "index": 195,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Signal.Unoptimized.Uop",
      "library": "hardcaml",
      "description": "This module implements arithmetic and comparison operations for hardware signals, including addition, subtraction, multiplication, and comparisons like less than or equal. It operates directly on `Hardcaml.Signal.t`, handling width extension automatically to avoid truncation during operations. Use this module when designing combinational circuits that require unsigned arithmetic, such as counters, accumulators, or datapath elements in HDL simulations.",
      "description_length": 455,
      "index": 196,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Types.Clocking.Var",
      "library": "hardcaml",
      "description": "Implements clocked register logic with optional enable and reset behavior for signal state storage. Works with clocking configurations and variable-width signals to model sequential circuits. Useful for describing flip-flops in hardware designs where specific reset values or conditional updates are required.",
      "description_length": 309,
      "index": 197,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Cross_product.Comb",
      "library": "hardcaml",
      "description": "This module provides operations for constructing and manipulating hardware interfaces composed of bit vectors. It supports creating constant values, packing and unpacking interfaces to and from vectors, multiplexing between multiple interfaces, and concatenating or selecting from lists of interfaces using priority or one-hot encoding. These operations are used to build complex digital circuits with well-defined signal widths and structures.",
      "description_length": 444,
      "index": 198,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Types.List.All",
      "library": "hardcaml",
      "description": "This module provides a function `all` that transforms a list of monadic values into a monadic list of values, effectively sequencing the monadic effects across the list. It operates on lists where each element is wrapped in a monad `M`, lifting the monad outside the list structure. A concrete use case is collecting results from a list of computations that each return a monadic value, such as reading multiple signals in a hardware description where each read operation returns a result in a monadic context.",
      "description_length": 510,
      "index": 199,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Types.Array.All",
      "library": "hardcaml",
      "description": "This module provides the `all` function, which transforms a tuple of monadic values into a monadic tuple, effectively lifting the monad outside the tuple structure. It operates on tuples of types wrapped in a monad `M`, allowing the combination of multiple monadic computations into a single result. A concrete use case is when working with hardware description circuits where multiple signal wires are represented as a tuple of monadic wire types, and you need to combine them into a single monadic tuple for further processing.",
      "description_length": 529,
      "index": 200,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Interface.Empty.Of_signal",
      "library": "hardcaml",
      "description": "This module includes operations for constructing and manipulating structured signal groups using constant assignment, wiring, multiplexing, and bit-level transformations, alongside register and pipeline creation. It operates on signal interfaces (`Empty.t`) and individual signals (`Signal.t`), enforcing width constraints through validation to ensure correctness. These capabilities are particularly useful for building hardware components with named signal fields, hierarchical designs requiring prefixed naming conventions, and validated data paths in digital circuits.",
      "description_length": 572,
      "index": 201,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Bits_list.X_comb.Unsigned",
      "library": "hardcaml",
      "description": "This module implements arithmetic and comparison operations for unsigned binary vectors represented as lists of X_comb bits. It supports addition, subtraction, multiplication, and comparisons like less than or equal, directly on vector values with automatic bit-width extension. These operations are used to model combinational logic circuits where vector widths and values are manipulated explicitly, such as in digital signal processing or hardware synthesis tasks.",
      "description_length": 467,
      "index": 202,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Flags_vector.Make.Unsafe_assoc_by_port_name",
      "library": "hardcaml",
      "description": "This module creates and extracts association lists indexed by field names, mapping strings to values of type `'a`. It supports converting structured data to and from lists of named fields. Useful for dynamically inspecting or constructing hardware interfaces by name.",
      "description_length": 267,
      "index": 203,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Comb.Make.Signed",
      "library": "hardcaml",
      "description": "This module provides operations for working with signed two's complement vectors, including arithmetic operations like addition, subtraction, and multiplication, where operands are automatically extended and results are widened to prevent truncation. It supports comparison operations such as less than, greater than, and equality, which handle operands of differing widths. Use cases include implementing arithmetic logic units (ALUs) and control logic that require precise signed integer behavior in hardware designs.",
      "description_length": 519,
      "index": 204,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Array.Of_always",
      "library": "hardcaml",
      "description": "This module provides functions to manipulate and assign values to arrays of always block variables in Hardcaml, specifically when working with hardware description interfaces. It supports operations like creating register and wire variables, assigning signals, and applying naming conventions to interface fields. Concrete use cases include building and managing complex hardware interfaces within always blocks, such as connecting register banks or named signal wires in a structured way.",
      "description_length": 489,
      "index": 205,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Fifo.With_interface.I",
      "library": "hardcaml",
      "description": "This module enables manipulation of FIFO interface values through transformations like mapping, zipping, and folding, while supporting conversions between interfaces and structured data such as lists and bit vectors. It operates on data structures representing FIFO ports, signals, and registers, providing access to metadata like names, widths, and bit offsets, and supports structural equality and error-aware computations. Child modules extend this functionality with signal-driven operations, combinational logic, port configuration, and monadic lifting, enabling use cases such as hierarchical FIFO construction, control logic design, and synchronous signal management. Examples include packing interfaces into bit vectors, building FIFO pipelines with named signals, validating signal widths, and creating named registers for simulation or synthesis.",
      "description_length": 856,
      "index": 206,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Flags_vector.Make.Names_and_widths",
      "library": "hardcaml",
      "description": "This module defines port names, widths, and associated tags for hardware description in Hardcaml. It provides direct access to lists of port names, widths, and precomputed tags derived from them. Useful for generating signal interfaces and managing port configurations in hardware modules.",
      "description_length": 289,
      "index": 207,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Bits_list.Make.Typed_math",
      "library": "hardcaml",
      "description": "Implements arithmetic and comparison operations for fixed-width bit vectors represented as lists of bits. Supports addition, subtraction, multiplication, and comparisons like less than, equal, and greater than, with automatic width extension as needed. Useful for hardware description where precise bit-level control is required, such as ALU operations or bus manipulations.",
      "description_length": 374,
      "index": 208,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Interface.Make.All",
      "library": "hardcaml",
      "description": "This module provides the `all` function, which lifts monadic values from within an interface structure to the monad outside, enabling sequential composition of interface operations. It operates on interfaces containing signals wrapped in a monadic type, allowing monadic effects to be sequenced across the entire interface. A concrete use case is combining multiple register reads or writes across an interface into a single monadic action.",
      "description_length": 440,
      "index": 209,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Logic.Four_state_vector.Signed",
      "library": "hardcaml",
      "description": "This module implements arithmetic and comparison operations for signed four-state logic vectors, including addition, subtraction, multiplication, and comparisons like less than or equal. It works with the `v` type representing signed vectors, supporting operations between vectors of different widths and automatically extending results to prevent truncation. Concrete use cases include building digital circuits that require signed integer arithmetic and comparisons in hardware description tasks.",
      "description_length": 498,
      "index": 210,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Hardcaml.Types.Cross_product.S-Make_comb",
      "library": "hardcaml",
      "description": "This module implements combinational logic operations for manipulating structured signal interfaces, including packing/unpacking to vectors, multiplexing, concatenation, and selection from one-hot or priority-encoded inputs. It works with signal interfaces defined by the `Comb` module, handling width validation and bit-level operations. Concrete use cases include building multiplexers, demultiplexers, and signal routers in digital circuit design.",
      "description_length": 450,
      "index": 211,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Types.Cross_product.Make_comb",
      "library": "hardcaml",
      "description": "This module implements combinational logic operations for manipulating structured hardware interfaces. It supports operations like packing/unpacking interfaces to/from bit vectors, multiplexing, concatenation, and priority/one-hot selection, all while validating signal widths. It works with a custom combinational logic type `comb` and structured interface types `t`, enabling precise bit-level control and routing in hardware designs. Use cases include building multiplexers, demultiplexers, and signal routers in digital circuits with strict width and validity checks.",
      "description_length": 571,
      "index": 212,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Types.Cross_product.All",
      "library": "hardcaml",
      "description": "Lifts monadic values within a nested structure, transforming a monad of a nested type into a nested type of a monad. Works with monadic values wrapped inside a polymorphic container. Useful for flattening layers of monadic computations when handling interfaces with multiple embedded effects.",
      "description_length": 292,
      "index": 213,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Types.Value.Names_and_widths",
      "library": "hardcaml",
      "description": "This module defines operations to access and manipulate named value ports, including retrieving lists of port names, widths, and associated tags. It works with tuples of strings and integers to represent port names and their bit widths. Concrete use cases include inspecting hardware description values to extract structural information for simulation or debugging.",
      "description_length": 365,
      "index": 214,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Array.Of_bits",
      "library": "hardcaml",
      "description": "This module provides functions to manipulate arrays of bit vectors as structured interfaces. It supports operations like packing/unpacking to and from flat bit vectors, multiplexing, concatenation, and selection from one-hot or priority-encoded inputs. Concrete use cases include hardware register file access, bus multiplexing, and configuration data serialization.",
      "description_length": 366,
      "index": 215,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Logic.Std_logic_vector.Typed_math",
      "library": "hardcaml",
      "description": "This module provides arithmetic and comparison operations for fixed-width bit vectors, supporting addition, subtraction, multiplication, and comparisons like less than or equal. It works with the `v` type representing typed logic vectors, allowing conversions to and from standard logic vectors. Use this module to implement hardware circuits with precise bit-level control, such as ALUs or data path components.",
      "description_length": 412,
      "index": 216,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Vcd.Var.Generator",
      "library": "hardcaml",
      "description": "This module generates unique string identifiers for VCD signal variables. It provides functions to create a generator state and produce sequential IDs within a specified character range. Useful for emitting VCD files where each signal must have a distinct identifier.",
      "description_length": 267,
      "index": 217,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Types.Clocking.S-Of_bits",
      "library": "hardcaml",
      "description": "This module provides functions to manipulate structured hardware interfaces represented as bit vectors. It supports operations like packing/unpacking interfaces to/from bit vectors, multiplexing, concatenation, and validation of signal widths. Concrete use cases include building register files, decoding instruction fields, and constructing complex hardware units from fixed-width bit signals.",
      "description_length": 394,
      "index": 218,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Enum.Make_binary.Unsafe_assoc_by_port_name",
      "library": "hardcaml",
      "description": "This module creates and manipulates enumeration-based interfaces using string-keyed association lists. It provides `to_alist` and `of_alist` for converting between enumerated values and lists of named fields with associated data. Use it to serialize or deserialize hardware interfaces where field names directly map to port names in a design.",
      "description_length": 342,
      "index": 219,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Flags_vector.Make.Of_bits",
      "library": "hardcaml",
      "description": "This module provides operations to manipulate bit vectors as structured interfaces, supporting construction from integers, packing/unpacking to and from flat vectors, and multiplexing or concatenating interfaces. It includes functions for validation, width assertion, and priority/one-hot selection over lists of interfaces with optional branching factors. Concrete use cases include building and validating register interfaces, decoding control signals, and constructing complex multiplexed data paths from bit-level components.",
      "description_length": 529,
      "index": 220,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Logic.Four_state_vector.Typed_math",
      "library": "hardcaml",
      "description": "This module provides arithmetic and comparison operations for four-state logic vectors, including addition, subtraction, multiplication, and comparisons like less than or equal. It works with the abstract type `v`, which represents four-state vectors, and supports operations between values of this type, automatically handling bit-width extensions. Concrete use cases include implementing digital circuit logic where signed or unsigned vector arithmetic and comparisons are required, such as in ALUs or control logic.",
      "description_length": 518,
      "index": 221,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Types.Scalar.Of_bits",
      "library": "hardcaml",
      "description": "This module provides functions to manipulate scalar signal interfaces using bit vectors, including operations like packing/unpacking, multiplexing, concatenation, and validation of signal widths. It works with types representing scalar signals (`comb t`) and bit vectors (`comb`). Concrete use cases include constructing constant signals from integers, validating signal widths at runtime, and multiplexing between multiple signal interfaces using priority or one-hot selection.",
      "description_length": 478,
      "index": 222,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Rtl.Deprecated.VhdlNames",
      "library": "hardcaml",
      "description": "This module defines naming conventions for VHDL signals by enforcing case sensitivity rules, applying a prefix, and avoiding reserved keywords. It provides a function to legalize signal names by transforming them to comply with these constraints. Use this when generating VHDL code to ensure signal names are valid and avoid conflicts with reserved words.",
      "description_length": 355,
      "index": 223,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Enum.Make_enums.Binary",
      "library": "hardcaml",
      "description": "This module enables conversion between enumerated types and binary representations, manipulation of multi-bit interfaces through element-wise and cumulative operations, and structured handling of RTL signals with error tracking. It operates on `Binary.t` values representing hardware signals, bits, or combinational logic, alongside association lists mapping port names to widths or values, and supports use cases such as serializing hardware interfaces, simulating binary-encoded state machines, and error-resilient signal processing. Submodules enhance this functionality by enabling monadic composition of binary interfaces, implementing combinational logic for enums, managing signal assignments in always blocks, and converting enums to and from bit vectors with multiplexing and validation. Specific capabilities include packing/unpacking enum values, constructing priority-encoded logic, deriving port metadata from variants, and optimizing performance-critical paths with low-level binary operations.",
      "description_length": 1008,
      "index": 224,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Interface.Ast.Type",
      "library": "hardcaml",
      "description": "This module defines the structure of interface types in Hardcaml, including signal and module declarations with associated attributes like bit widths and RTL names. It provides functions for constructing and deconstructing these interface types, enabling precise signal group manipulation. Concrete use cases include defining hardware module interfaces and generating corresponding RTL representations.",
      "description_length": 402,
      "index": 225,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Interface.Update.Of_always",
      "library": "hardcaml",
      "description": "This module provides functions to create and manipulate interfaces using the Always API, specifically for working with registers, wires, and signal assignments. It operates on `Hardcaml.Always.Variable.t` and `Hardcaml.Signal.t` types, enabling direct assignment and naming of interface fields within always blocks. Concrete use cases include defining register interfaces with optional enable signals, creating wire interfaces with default values, and applying naming conventions to signals during simulation or synthesis.",
      "description_length": 522,
      "index": 226,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.With_valid.Fields.S-Of_bits",
      "library": "hardcaml",
      "description": "This module handles bit-level manipulation and validation of structured hardware interfaces. It provides operations to pack, unpack, concatenate, and multiplex interfaces, along with width validation and constant initialization. Use it when building or verifying register-transfer level designs with fixed-width signals and control logic.",
      "description_length": 338,
      "index": 227,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.With_valid.Wrap.Make",
      "library": "hardcaml",
      "description": "This module enables functional manipulation and metadata inspection of hardware interfaces through transformations like mapping, folding, and zipping over signal tuples, while tracking port names, widths, and errors. It supports structured operations on signal lists, bit vectors, and combinational logic, with core data types like `'a t` for interfaces and `comb t` for signal-level logic. Child modules extend this foundation with specific capabilities: converting interfaces to named field mappings, packing/unpacking signals to bit vectors, defining combinational logic and registers, and lifting monadic computations over interface structures. Examples include building register files using bit vector operations, constructing muxes and priority encoders, defining synchronous logic in always blocks, and aggregating validation results across interface fields.",
      "description_length": 865,
      "index": 228,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.With_valid.Fields.S-All",
      "library": "hardcaml",
      "description": "Combines monadic values across an interface, lifting the monad outside the structure. Works with interfaces containing monadic values, transforming them into a single monadic interface. Useful for aggregating computations like signal processing pipelines in hardware description contexts.",
      "description_length": 288,
      "index": 229,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Signal.Type.Printable",
      "library": "hardcaml",
      "description": "This module provides functions to convert hardware design signals and registers into S-expressions and strings for debugging and visualization. It supports recursive conversion with configurable depth and identifier visibility, specifically handling signal dependencies like muxes and concatenations. Use cases include inspecting signal structures during simulation and generating readable netlist representations.",
      "description_length": 414,
      "index": 230,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Bits_list.X_comb.Signed",
      "library": "hardcaml",
      "description": "This module provides arithmetic and comparison operations for signed binary vectors represented as lists of bits with X (unknown) values. It supports addition, subtraction, multiplication, and comparisons like less than or equal, operating on vectors of potentially different widths. Concrete use cases include implementing arithmetic logic units (ALUs) and comparison-based control logic in digital circuit design.",
      "description_length": 415,
      "index": 231,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Rtl.Name.Language",
      "library": "hardcaml",
      "description": "This module defines rules for valid identifier characters and naming conventions in HDL code generation. It includes predicates for checking valid first and subsequent identifier characters, a replacement character for invalid ones, and settings for case sensitivity and reserved keywords. It is used to ensure generated HDL identifiers conform to toolchain requirements and avoid naming conflicts.",
      "description_length": 398,
      "index": 232,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Enum.Make_binary.Of_always",
      "library": "hardcaml",
      "description": "This module provides functions to manipulate and assign values to hardware interfaces using the Always API, specifically for binary-represented enumeration types. It supports creating registers, wires, and named variables, and includes pattern matching on signals for conditional logic. Use cases include building state machines, decoding signal values, and managing interface assignments in hardware descriptions.",
      "description_length": 414,
      "index": 233,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Bits_list.Make.Uop",
      "library": "hardcaml",
      "description": "This module implements arithmetic and comparison operations on lists of Bits representing unsigned integers. It supports addition, subtraction, multiplication, and comparisons like less than or equal, directly on these bit vectors, with automatic width extension to preserve precision. These operations are used to build combinational logic circuits for tasks like arithmetic computations or control flow decisions in hardware designs.",
      "description_length": 435,
      "index": 234,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Types.List.Comb",
      "library": "hardcaml",
      "description": "This module provides operations for constructing and manipulating hardware description combinational logic interfaces. It supports data types like `comb t`, representing signal interfaces with typed fields, and operations for packing/unpacking, multiplexing, concatenation, and validation of signal widths. Concrete use cases include building multiplexers, concatenating signal buses, validating signal integrity, and converting between integer values and signal representations.",
      "description_length": 479,
      "index": 235,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.With_valid.Fields.M",
      "library": "hardcaml",
      "description": "This module suite enables structured manipulation of hardware interfaces through combinational logic, signal composition, and metadata handling. It centers on `comb t` and `Hardcaml.Always.Variable.t` types, supporting operations like packing/unpacking to bit vectors, multiplexing, concatenation, and selection with priority or one-hot decoding. Users can construct register interfaces, decode control signals, sequence monadic operations across fields, and interface with external systems using named signal mappings or port metadata. Example uses include assembling instruction decoders, building state machine transitions, and generating netlists from structured interfaces.",
      "description_length": 678,
      "index": 236,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Enum.Make_one_hot.Of_signal",
      "library": "hardcaml",
      "description": "This module provides operations to convert integers to one-hot signals (`of_int`), multiplex between cases (`mux`, `mux2`), and manipulate packed bit representations of enumeration values. It works with signal types (`t`) and case-labeled structures (`Cases.t`) to enforce correct bit widths and enable combinational logic for control paths. Use cases include implementing state machines, priority encoders, or any digital circuit requiring compact, safe one-hot encoded enum representations with explicit input/output handling.",
      "description_length": 528,
      "index": 237,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Rtl_attribute.Vivado.Ram_style",
      "library": "hardcaml",
      "description": "This module defines specific RTL attributes for controlling RAM implementation styles in Xilinx Vivado. It provides constants to specify block RAM, distributed RAM, register-based, and ultra RAM configurations. These attributes guide synthesis tools in selecting the appropriate hardware resources for memory elements in the generated netlist.",
      "description_length": 343,
      "index": 238,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Comb.Make.Sop",
      "library": "hardcaml",
      "description": "This module implements arithmetic and comparison operations for signed bit vectors, supporting addition, subtraction, multiplication, and comparisons like less than or equal, with automatic sign extension. It works directly with `t` values, representing bit vectors, and includes resizing to adjust vector widths with proper sign handling. Concrete use cases include implementing arithmetic logic units (ALUs) and comparison-based control logic in hardware designs.",
      "description_length": 465,
      "index": 239,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Bits_list.X_comb.Sop",
      "library": "hardcaml",
      "description": "This module implements arithmetic and comparison operations for lists of signed bits, supporting addition, subtraction, multiplication, and comparisons like less than or equal. It works directly with lists of bits (`Hardcaml.Bits_list.X_comb.t`) that may represent either signals or values, handling sign extension and resizing automatically during operations. Concrete use cases include building arithmetic logic units (ALUs) or performing signed comparisons in hardware descriptions where bit vectors need to be manipulated as lists.",
      "description_length": 535,
      "index": 240,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Pair.Wrap",
      "library": "hardcaml",
      "description": "This module enables structured manipulation of pairs and product types in hardware descriptions, combining mapping, zipping, and folding operations with bit-level composition and signal conversion. It supports key data types such as bit vectors, signals, and named width specifications, allowing tasks like combinational logic synthesis, interface aggregation, and type-safe signal decomposition. Child modules extend this functionality with operations for packing/unpacking interfaces, multiplexing, concatenation, and monadic pair transformations, enabling concrete use cases such as bus multiplexers, signal routing, and structured hardware component integration. Additional utilities for port naming, register pipelines, and association list conversions provide fine-grained control over interface layout and metadata during synthesis and simulation.",
      "description_length": 854,
      "index": 241,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Always.State_machine.State",
      "library": "hardcaml",
      "description": "This module represents states in a state machine, providing constructors and comparisons for state values. It works with symbolic state identifiers used in hardware description circuits. Use it to define and manipulate finite state machines within the Always DSL, such as encoding control logic for sequential circuits.",
      "description_length": 319,
      "index": 242,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Logic.Bit_vector.Sop",
      "library": "hardcaml",
      "description": "This module provides arithmetic and comparison operations for signed bit vectors, including addition, subtraction, multiplication, and comparisons like less than or equal. It works directly with `Hardcaml.Logic.Bit_vector.t`, supporting operations between values of different widths and handling sign extension automatically. Use this module for implementing arithmetic logic units (ALUs) or data path components where signed integer behavior is required in hardware descriptions.",
      "description_length": 480,
      "index": 243,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Logic.Four_state_vector.Uop",
      "library": "hardcaml",
      "description": "This module implements arithmetic and comparison operations for four-state logic vectors, including addition, subtraction, multiplication, and comparisons like less than or equal. It supports operations between vectors of different widths, automatically extending inputs and widening results to prevent truncation. These functions are used to build digital circuits that manipulate fixed-width binary signals, such as counters, arithmetic logic units, or data path components.",
      "description_length": 476,
      "index": 244,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Bits_list.Int_comb.Signed",
      "library": "hardcaml",
      "description": "This module represents signed integer vectors using lists of bits, supporting arithmetic operations like addition, subtraction, and multiplication with automatic sign extension. It provides comparison operators for signed values of potentially different widths, producing bit list results indicating the truth of the comparison. Concrete use cases include implementing fixed-point arithmetic circuits and signed value comparisons in hardware descriptions.",
      "description_length": 455,
      "index": 245,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.With_valid.Wrap.M",
      "library": "hardcaml",
      "description": "This module represents hardware interfaces with validity signals, pairing data values with their readiness indicators through the `'a t` type. It enables construction, transformation, and routing of these interfaces using combinational logic, register pipelines, and structured signal manipulation, with core operations like `map`, `valid`, and `of_tuple`. Submodules extend this foundation with bit vector handling, always-block assignments, metadata introspection, and monadic composition, supporting tasks like pipeline creation, signal routing, and interface serialization. Use it to build synthesizable circuits where data validity is critical, such as handshake protocols or pipelined datapaths.",
      "description_length": 701,
      "index": 246,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Interface.Update.Make_comb",
      "library": "hardcaml",
      "description": "This module implements combinational logic operations for manipulating structured signal interfaces, such as packing/unpacking to vectors, multiplexing, concatenation, and selection operations. It works with typed signal groups defined by the `comb t` structure, where each field corresponds to a named, fixed-width signal. Concrete use cases include building multiplexers, priority encoders, and constant initialization for hardware description in Hardcaml designs.",
      "description_length": 466,
      "index": 247,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.With_valid.Vector",
      "library": "hardcaml",
      "description": "This module enables polymorphic vector operations tailored for hardware interface manipulation, supporting mapping, zipping, folding, and tuple transformations across vectors with 3-5 arguments. It works with tagged hardware ports, signals, and vectors augmented with valid bits, enabling RTL-level tasks like port width aggregation, bit-level combinational logic synthesis, and error-aware interface list conversions. Specific utilities handle field offset calculations, signal name/width extraction, and safe association list conversions for hardware description workflows. Submodules enhance this foundation by enabling named port list processing, monadic vector transformations, bit vector interface validation, and structured signal wiring with register and wire creation through the Always API.",
      "description_length": 800,
      "index": 248,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Types.Clocking.Cdc",
      "library": "hardcaml",
      "description": "This module provides functions for managing clock domain crossings in digital circuit design. It includes operations to stretch pulses across clock cycles, detect rising edges on valid signals from slower clocks, and pipeline signals with asynchronous register annotations. These functions work with clocking contexts and signal types to handle synchronization between different clock domains, such as stretching control pulses, converting valid signals between clock speeds, and safely registering signals across domains.",
      "description_length": 522,
      "index": 249,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Bits_list.X_comb.Uop",
      "library": "hardcaml",
      "description": "This module implements arithmetic and comparison operations for lists of combinational logic bits represented as `F`, `T`, or `X`. It supports addition, subtraction, multiplication, and comparisons like less than or equal, directly on bit lists, automatically handling width differences through extension. These operations are used to build digital circuits that perform calculations or make decisions based on unsigned binary values.",
      "description_length": 434,
      "index": 250,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Interface.Make_interface_with_conversion.Names_and_widths",
      "library": "hardcaml",
      "description": "This module defines operations to extract and manipulate signal metadata, specifically port names and widths, from a Hardcaml interface. It provides direct access to the list of port names, widths, and combined name-width pairs, enabling introspection and dynamic construction of signal groups. These functions are used to interface with hardware description constructs that require explicit signal naming and sizing information.",
      "description_length": 429,
      "index": 251,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Clocking.S-Unsafe_assoc_by_port_name",
      "library": "hardcaml",
      "description": "This module converts between a structured interface and an association list indexed by field names. It supports serializing and reconstructing values using string keys corresponding to field names. Concrete use cases include debugging, dynamic configuration, and interfacing with external systems that require named field access.",
      "description_length": 329,
      "index": 252,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Array.Of_signal",
      "library": "hardcaml",
      "description": "This module enables the construction and manipulation of hardware interfaces using structured signal arrays, supporting operations like concatenation, multiplexing, register pipelines, and bit-width validation. It operates on field-structured signal types (`Of_signal.comb t` and `Of_signal.t`) that model hardware signals with explicit bit-widths, providing utilities for wiring, assignment, and interface naming. Key use cases include circuit validation, register transfer level design, and managing hierarchical signal connections with customizable naming strategies.",
      "description_length": 570,
      "index": 253,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Always.State_machine.Encoding",
      "library": "hardcaml",
      "description": "This module defines state machine encoding types such as Binary, Gray, and Onehot, and provides conversions to S-expressions and strings. It is used to specify and serialize the encoding scheme of state machines within the Always DSL. Concrete use cases include configuring state machine representations for synthesis or debugging in hardware description code.",
      "description_length": 360,
      "index": 254,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Bits.Mutable.Comb",
      "library": "hardcaml",
      "description": "This module combines combinational logic operations with a suite of submodules to support comprehensive manipulation of mutable bit vectors for digital circuit simulation and hardware design. It provides core data types like fixed-width and mutable bit vectors, along with operations for arithmetic, bitwise manipulation, logical evaluation, and conversion between integers, strings, and binary representations, handling both signed and unsigned interpretations. The submodules extend this functionality by offering specialized arithmetic and comparison operations tailored to unsigned, signed, and mixed-width bit vectors, with automatic resizing and sign extension, enabling efficient simulation of components like ALUs, multiplexers, and control logic. Together, they allow tasks such as dynamic signal modification, RTL modeling, and bit-accurate computation in performance-sensitive simulation contexts.",
      "description_length": 908,
      "index": 255,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.With_valid.Fields.S-Names_and_widths",
      "library": "hardcaml",
      "description": "This module defines operations for extracting and working with named ports and their widths from a Hardcaml interface. It provides direct access to port names, widths, and associated tags as lists. Use this module when generating or inspecting hardware interfaces where port metadata must be processed or exposed programmatically.",
      "description_length": 330,
      "index": 256,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Types.Value.Of_bits",
      "library": "hardcaml",
      "description": "This module provides functions to convert between integer values and bit-level representations of hardware interfaces, enabling operations like packing and unpacking fields into vectors, multiplexing between interface values, and validating signal widths. It works with `comb t` types representing hardware signals and supports concrete operations such as `of_int` for constant assignment, `pack` and `unpack` for vector conversion, and `mux`, `mux2`, and `concat` for signal selection and combination. Use cases include constructing and manipulating hardware register interfaces, implementing control logic with priority or one-hot multiplexers, and ensuring signal width consistency during design elaboration.",
      "description_length": 711,
      "index": 257,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.With_valid.Vector.Make_comb",
      "library": "hardcaml",
      "description": "This module provides operations for manipulating vector interfaces using combinational logic, including packing/unpacking to and from vectors, multiplexing, concatenation, and selection functions like priority and onehot selects. It works with signal vectors and interfaces where each field has a defined bit width, using the `comb` type for combinational logic. Concrete use cases include building multiplexers, demultiplexers, and control logic that selects or combines data paths based on valid signals.",
      "description_length": 506,
      "index": 258,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Flags_vector.Make.Make_comb",
      "library": "hardcaml",
      "description": "This module provides operations for manipulating bit vector interfaces using combinational logic, including packing/unpacking, multiplexing, concatenation, and selection functions. It works with signal interfaces composed of fields of type `comb`, where each field has a defined bit width. Concrete use cases include constructing complex signal routing logic, validating signal widths during simulation, and implementing priority or one-hot encoded multiplexers for hardware designs.",
      "description_length": 483,
      "index": 259,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Logic.Std_logic.Variants",
      "library": "hardcaml",
      "description": "This module defines individual variants of the `std_logic` type used in digital circuit modeling, such as `'U'`, `'X'`, `'0'`, `'1'`, `'Z'`, `'W'`, `'L'`, `'H'`, and `\"don't care\"`. It provides operations to fold, iterate, and map over these variants, enabling precise handling of signal resolution and state transitions. These functions are used to implement logic that depends on the full IEEE std_logic behavior, such as bus resolution functions or simulation kernels.",
      "description_length": 471,
      "index": 260,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Interface.Update.Of_bits",
      "library": "hardcaml",
      "description": "This module provides functions to construct and manipulate bit-level hardware interfaces using `Hardcaml.Bits.t` values. It supports operations like packing/unpacking interfaces to/from bit vectors, multiplexing between interface values, concatenation, and priority/one-hot selection logic. Concrete use cases include building register files, control logic, and bus multiplexers where structured signal groups need to be dynamically updated or selected based on runtime conditions.",
      "description_length": 481,
      "index": 261,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Types.Clocking.Comb",
      "library": "hardcaml",
      "description": "This module provides operations for constructing and manipulating clocking interfaces with combinational logic. It supports types like `comb` and `t`, enabling tasks such as packing/unpacking interfaces, multiplexing, concatenation, and validation of signal widths. Use cases include building and verifying complex clocking structures in hardware designs, such as selecting between multiple clock domains or ensuring signal width consistency.",
      "description_length": 442,
      "index": 262,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Scalar.Unsafe_assoc_by_port_name",
      "library": "hardcaml",
      "description": "This module converts between scalar interfaces and association lists indexed by field names, using `to_alist` to extract named fields and `of_alist` to reconstruct interfaces from such lists. It operates on `'a t` structures representing hardware scalar values and string-keyed lists of those values. Use this when mapping hardware interface signals to named entries or building interfaces dynamically from named signal lists.",
      "description_length": 426,
      "index": 263,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Async_fifo.Make.I",
      "library": "hardcaml",
      "description": "This module structures hardware interface manipulation through transformations like mapping, zipping, and folding over signal streams, while supporting stateful operations and metadata inspection. It enables construction of parameterized asynchronous FIFOs, composition of complex interfaces, and conversion between signal representations with preserved naming and width semantics. Submodules provide combinational logic, bit-level FIFO handling, register management via the Always API, and dynamic field access, allowing tasks like control signal decoding, synchronous logic definition, and runtime FIFO configuration. Specific uses include building FIFO control logic with precise bit-widths, defining register variables with default signals, and dynamically inspecting named FIFO fields for debugging.",
      "description_length": 804,
      "index": 264,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.With_valid.Wrap.S-All",
      "library": "hardcaml",
      "description": "Combines a structure of monadic values into a monad containing the structure, lifting the monad outside the interface. Works with any monad `M` and structured types `'a M.t t`, transforming them into `'a t M.t`. Useful for aggregating multiple signal-valid pairs into a single monadic result in hardware description contexts.",
      "description_length": 325,
      "index": 265,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Enum.Make_binary.Make_comb",
      "library": "hardcaml",
      "description": "This module provides combinational logic operations for working with binary-encoded enumeration types, including case analysis via pattern matching, conversion from raw bitvectors, and width-managed construction from integers or sexps. It operates on `comb` values representing hardware signals and `t` types that encapsulate binary enum representations, supporting use cases like state machine decoding, control signal multiplexing, and priority/one-hot selection in digital circuits. Key features include safe validation of encoded values and ergonomic manipulation of enum variants through combinational logic transformations.",
      "description_length": 629,
      "index": 266,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Interface.Empty.Names_and_widths",
      "library": "hardcaml",
      "description": "This module defines lists of tuples containing signal names and their corresponding bit widths, along with separate lists for names and widths. It works with basic OCaml data structures like strings and integers, and is used to describe hardware signal interfaces in a format compatible with Hardcaml's PPX extensions. Concrete use cases include defining port layouts for hardware components and generating signal metadata for simulation or synthesis tools.",
      "description_length": 457,
      "index": 267,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.List.Of_signal",
      "library": "hardcaml",
      "description": "This module enables structured manipulation of hardware signal interfaces through operations like packing/unpacking into vectors, multiplexing between interfaces, and constructing registers or wires. It works with structured collections of signals (`comb t` and `t` types) to support tasks such as concatenation, pipeline validation, and naming transformations with prefixes/suffixes. Specific use cases include wiring input/output connections, assigning semantic names to signals for clarity, and ensuring signal width correctness during hardware design.",
      "description_length": 555,
      "index": 268,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Array.Comb",
      "library": "hardcaml",
      "description": "This module provides operations for constructing and manipulating hardware description arrays in a combinatorial context. It supports types like `comb` and `t` for representing signal interfaces and vectors, with functions for packing/unpacking, multiplexing, concatenation, and validation. Use cases include building complex digital circuits with fixed-width signals, priority encoders, and multiplexers.",
      "description_length": 405,
      "index": 269,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.With_valid.Fields.Make",
      "library": "hardcaml",
      "description": "This module enables structured manipulation of hardware interfaces with typed fields, converting between record-like structures and value lists while preserving field identities through a `tag` type. It supports operations on tuples of varying arity, bit vectors, and combinational logic, with core functions for mapping, iteration, and metadata extraction, such as deriving port names and widths or constructing register layouts. Child modules extend this foundation with monadic restructuring, signal assignment in always blocks, combinational logic synthesis, and port mapping, enabling tasks like synchronizing valid signals, building pipelined datapaths, or generating HDL port lists from structured interfaces. Specific capabilities include decoding instruction fields, validating signal associations, and synthesizing control logic with one-hot selects or priority encoders.",
      "description_length": 881,
      "index": 270,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Enum.Make_binary.Unsafe",
      "library": "hardcaml",
      "description": "This module provides low-level, unsafe operations for converting between an enumerated type and its binary representation in hardware. It works directly with variant types that have no arguments, representing each case as a fixed-size bit vector. Use this when manually managing the encoding and decoding of enum values in hardware descriptions, such as when interfacing with external signals or optimizing for specific bit widths.",
      "description_length": 431,
      "index": 271,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Logic.Four_state.Variants",
      "library": "hardcaml",
      "description": "This module defines and manipulates four-state logic values (x, z, l0, l1) using variants. It supports operations like mapping, folding, and iteration over these states, enabling precise logic synthesis and simulation tasks. Use cases include implementing digital circuit behavior, modeling signal states in hardware description workflows, and performing logic transformations.",
      "description_length": 377,
      "index": 272,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.With_valid.Fields.S-Make_comb",
      "library": "hardcaml",
      "description": "This module combines and manipulates hardware description interfaces with valid signals using a combinatorial logic module. It supports operations like packing/unpacking interfaces to/from bit vectors, multiplexing, concatenation, and priority/one-hot selection, all while validating signal widths. Use it to build and verify complex digital circuits from structured interfaces.",
      "description_length": 378,
      "index": 273,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Clocking.S-Cdc",
      "library": "hardcaml",
      "description": "This module provides functions for managing clock domain crossings in digital circuits. It includes operations for stretching pulses across clock cycles, detecting rising edges on valid signals from slower clocks, and creating pipelined registers with async_reg attributes. These functions are used to safely transfer signals between different clock domains and ensure proper synchronization.",
      "description_length": 392,
      "index": 274,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Value.Unsafe_assoc_by_port_name",
      "library": "hardcaml",
      "description": "This module directly maps interface fields to values using string keys, enabling efficient lookup and construction of interface values from named field associations. It operates on association lists pairing strings with values, transforming them to and from structured interface types. Use this when converting between flat lists of named signals and their structured representations in hardware descriptions.",
      "description_length": 409,
      "index": 275,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Types.With_valid.Fields",
      "library": "hardcaml",
      "description": "This module enables structured manipulation of hardware interfaces with valid signals, supporting combinational logic, monadic lifting, and bit-level operations across fields with named ports and defined widths. It provides core data types like `'a t` for tagged interfaces, `comb t` for combinational signals, and utilities for mapping, zipping, packing, and multiplexing structured data. You can build register pipelines with enables, construct priority multiplexers, convert interfaces to association lists or bit vectors, and validate signal widths and names for simulation or synthesis. Submodules extend this with monadic aggregation, always-block assignments, and unsafe name-to-field conversions for dynamic configuration.",
      "description_length": 730,
      "index": 276,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Vcd.Var.Type",
      "library": "hardcaml",
      "description": "This module defines the set of variable types supported in VCD (Verilog Change Dump) files, such as `Wire`, `Reg`, `Integer`, and `Real`, corresponding to hardware simulation signal types. It provides direct mappings to VCD format identifiers and includes functions to convert these types to strings or S-expressions for serialization and debugging. These types are used when declaring signals in a VCD file to accurately represent their behavior in waveform viewers.",
      "description_length": 467,
      "index": 277,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Interface.Make_interface_with_conversion.Comb",
      "library": "hardcaml",
      "description": "This module provides operations to manipulate and convert interfaces composed of combinational logic signals. It supports creating constant interfaces, packing and unpacking interfaces to and from vectors, multiplexing and concatenating interfaces, and selecting between one-hot or priority-encoded inputs. Concrete use cases include building multiplexers, routing logic, and fixed-width signal conversions in hardware descriptions.",
      "description_length": 432,
      "index": 278,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Interface.Empty.Make_comb",
      "library": "hardcaml",
      "description": "This module implements combinational logic operations for an empty interface, including signal packing, unpacking, multiplexing, and validation. It works with `comb` signals grouped in an empty interface structure, ensuring correct bit widths during operations. Use cases include constructing and validating constant interfaces, muxing between interface values, and serializing interface signals to vectors.",
      "description_length": 407,
      "index": 279,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Enum.Make_one_hot.Make_comb",
      "library": "hardcaml",
      "description": "This module provides combinational logic operations for one-hot encoded enumeration types, enabling conversions between integer representations and bit vectors, priority-based selection, and case-matching logic. It operates on `comb` and `comb outer` types, which represent raw combinational signals and their wrapped interface forms, while supporting validation and multiplexing over one-hot bit patterns. These capabilities are particularly useful for implementing state machines, control logic, and priority-encoded decision paths in hardware designs.",
      "description_length": 554,
      "index": 280,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.With_valid.Wrap.S",
      "library": "hardcaml",
      "description": "This module provides operations to manipulate hardware interfaces that pair data with validity information, supporting structured transformations like zipping, mapping, and folding over composite signals. It works with tuple-like interface values (`'a t`) containing named ports, widths, and tags, enabling conversions between lists of signals and bit-level representations. Key use cases include building and validating hardware descriptions with combinational logic, error handling during interface composition, and extracting signal metadata for simulation or synthesis workflows.",
      "description_length": 583,
      "index": 281,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Scalar.Of_always",
      "library": "hardcaml",
      "description": "This module provides functions to manipulate and assign values to hardware description interfaces within always blocks. It supports operations like creating register and wire variables, assigning signals, and applying naming conventions to interface fields. It works with interfaces containing `Always.Variable.t` values, enabling structured hardware design with named signals and registers. Use cases include building synchronous logic blocks, connecting interface signals in always blocks, and generating named hardware signals for simulation or synthesis.",
      "description_length": 558,
      "index": 282,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Array.Names_and_widths",
      "library": "hardcaml",
      "description": "This module defines lists of port names and their corresponding widths, along with a list of tags, used to describe the interface of a hardware module. It provides direct access to these lists through simple value bindings. Concrete use cases include specifying input/output port configurations for hardware components during circuit design and analysis.",
      "description_length": 354,
      "index": 283,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Types.Scalar.Of_signal",
      "library": "hardcaml",
      "description": "This module provides functions for manipulating structured digital signals, including packing/unpacking, concatenation, multiplexing, and creating register pipelines. It works with `comb t` and `t` types representing signal interfaces, offering operations to connect signals, define named input/output ports, and apply hierarchical naming conventions. These capabilities are used to construct hardware interfaces, manage signal routing, and generate RTL with consistent naming and pipelined stages.",
      "description_length": 498,
      "index": 284,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Signal.Unoptimized.Unsigned",
      "library": "hardcaml",
      "description": "This module provides operations for manipulating unsigned binary vectors as signals, including arithmetic (addition, subtraction, multiplication) and comparison operations (less than, greater than, equality). It supports resizing vectors to specified widths with proper zero extension and handles operand width mismatches automatically during computations. These capabilities are used to model and simulate digital circuits with arbitrary-precision unsigned integer values.",
      "description_length": 473,
      "index": 285,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Signal.Type.Uid_map-Uid",
      "library": "hardcaml",
      "description": "Maps hardware signal identifiers (Uid.t) to values, enabling efficient lookups and transformations based on unique signal IDs. It supports operations like creation, updating, and traversal with functions tailored for signal routing and netlist manipulation tasks. This structure is essential for managing signal mappings during hardware compilation and optimization phases.",
      "description_length": 373,
      "index": 286,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Rtl_attribute.Vivado.Srl_style",
      "library": "hardcaml",
      "description": "This module defines specific RTL attributes for controlling SRL (Shift Register LUT) inference in Xilinx Vivado synthesis. It provides predefined attribute values that dictate whether and how SRLs are inferred, including placement relative to registers and whether block RAM is used. These attributes are applied directly in HDL code to guide synthesis behavior for shift register implementations.",
      "description_length": 397,
      "index": 287,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Enum.Make_binary.Names_and_widths",
      "library": "hardcaml",
      "description": "This module generates a list of port names and their corresponding bit widths for a given enumeration type, along with separate lists for just the names and just the widths. It works with variant types (without arguments) to produce hardware interface descriptions in Hardcaml. It is used to define signal interfaces in digital circuit design where each variant represents a distinct signal port with a specified width.",
      "description_length": 419,
      "index": 288,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Interface.Update.All",
      "library": "hardcaml",
      "description": "This module combines monadic values within an interface structure, lifting the monad outside the interface. It transforms an interface where each field is a monadic value into a monadic interface. A concrete use case is collecting results from multiple concurrent signal computations into a single interface-typed result.",
      "description_length": 321,
      "index": 289,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Interface.Empty.All",
      "library": "hardcaml",
      "description": "This module provides the `all` function, which lifts monadic values within an empty interface structure to a monadic interface value. It operates on interfaces with monadic signal values, enabling collective manipulation of those signals as a single monadic unit. A typical use case involves combining multiple monadic signals into a single monadic interface for sequential processing or bulk transformation.",
      "description_length": 408,
      "index": 290,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Array.Unsafe_assoc_by_port_name",
      "library": "hardcaml",
      "description": "This module provides direct conversions between a record-like structure and an association list indexed by field names. It supports operations to serialize the structure into a list of named values and reconstruct the structure from such a list. Useful for inspecting or dynamically manipulating hardware description data based on field names.",
      "description_length": 343,
      "index": 291,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Clocking.S-Var",
      "library": "hardcaml",
      "description": "Implements clocked register logic with optional enable and reset behavior. Works with signal types to manage state in synchronous circuits. Use for creating pipeline stages or storage elements in hardware descriptions.",
      "description_length": 218,
      "index": 292,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Types.Scalar.All",
      "library": "hardcaml",
      "description": "This module provides a function `all` that takes a list of monadic values and returns a monadic value of a list, effectively flipping the structure of the input. It operates on data types involving nested monads, specifically transforming `'a M.t t` into `'a t M.t`. A concrete use case is combining multiple interface signals wrapped in a monad into a single monadic interface, simplifying operations on collections of signals in hardware description contexts.",
      "description_length": 461,
      "index": 293,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.With_valid.Fields.S-module-type-Comb",
      "library": "hardcaml",
      "description": "This module provides combinational logic operations for manipulating structured interfaces with valid signals. It supports operations like packing/unpacking interfaces to vectors, multiplexing, concatenation, and selection functions such as one-hot and priority selects. These functions are used to build and verify hardware structures where each field has a defined bit width and behavior.",
      "description_length": 390,
      "index": 294,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Logic.Bit_vector.Uop",
      "library": "hardcaml",
      "description": "This module implements arithmetic and comparison operations for unsigned bit vectors, working directly with `Hardcaml.Logic.Bit_vector.t` values. It supports addition, subtraction, multiplication, and comparisons (like less than, equal to, etc.), with automatic bit width extension to preserve precision. Use cases include building arithmetic logic units (ALUs), implementing digital signal processing (DSP) blocks, and constructing custom control logic in hardware designs.",
      "description_length": 474,
      "index": 295,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Interface.Ast.Sequence",
      "library": "hardcaml",
      "description": "This module provides tools to define and manipulate structured sequences of hardware signals, enabling the creation of fixed-length data streams, bus interfaces, and signal groups with precise type and structural information. It supports operations to construct, transform, and deconstruct sequences, including mapping over elements, concatenating sequences, and extracting sub-sequences based on index ranges. The child module introduces sequence kinds that represent structured groupings like arrays or lists, offering conversion to S-expressions for debugging and serialization. Together, they allow defining a 4-element signal array, transforming its elements with a function, and serializing the structure for inspection.",
      "description_length": 726,
      "index": 296,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.With_valid.Fields.S-Of_always",
      "library": "hardcaml",
      "description": "This module provides functions to construct and manipulate hardware interfaces using the Always API, specifically for creating and assigning register and wire signals. It works with interface types parameterized over `Hardcaml.Always.Variable.t`, allowing field-level signal manipulation within always blocks. Concrete use cases include defining register pipelines with optional enables, wiring default signals, and assigning values across structured interfaces in a clocked design.",
      "description_length": 482,
      "index": 297,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Interface.Empty.Of_bits",
      "library": "hardcaml",
      "description": "This module provides operations to construct, manipulate, and validate interfaces composed of bit vectors. It supports concrete actions such as packing and unpacking interfaces to and from bit vectors, multiplexing between interface values, concatenating interfaces, and selecting between one-hot or priority-encoded inputs. The module works directly with `Hardcaml.Interface.Empty.t` structures where each field is represented as `Hardcaml.Bits.t`, enabling precise bit-level control and transformation.",
      "description_length": 504,
      "index": 298,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Bits_list.Make.Unsigned",
      "library": "hardcaml",
      "description": "This module implements arithmetic and comparison operations for unsigned binary vectors represented as lists of bits. It supports addition, subtraction, multiplication, and comparisons (less than, greater than, equal, etc.), automatically handling width mismatches by extending inputs and outputs as needed. Concrete use cases include building custom digital circuits for arithmetic logic units (ALUs) or data path components where variable-width unsigned operations are required.",
      "description_length": 480,
      "index": 299,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Rtl.Ast.Signals_name_map",
      "library": "hardcaml",
      "description": "This module maps signal names to mangled RTL names using a unique identifier and index pair as the key, ensuring uniqueness and correct referencing during Verilator compilation. It operates directly on RTL AST structures to generate required name mappings and supports key-based operations like comparison and serialization through its key module. The key submodule handles efficient identification and comparison of signals, enabling precise name mangling and transformation in Verilog code generation. Example usage includes mapping a signal's UID and index to a unique RTL name during AST processing for Verilator integration.",
      "description_length": 629,
      "index": 300,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Interface.Ast.Ast",
      "library": "hardcaml",
      "description": "This module represents the structure of an interface as a list of fields, capturing how it is composed from signals, arrays, lists, and sub-modules. It provides a `sexp_of_t` function for converting the interface structure into an S-expression, useful for serialization or inspection. Concrete use cases include generating register interface specifications or other structured outputs from interface definitions.",
      "description_length": 412,
      "index": 301,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Interface.Update.Comb",
      "library": "hardcaml",
      "description": "This module supports combinational logic operations on structured signal interfaces, enabling manipulation of signal groups via packing, unpacking, multiplexing, and concatenation. It works with `comb t` types representing hardware interfaces, where each field corresponds to a signal with a defined width. Use it to construct and validate hardware components like register files, data paths, and control logic units directly from interface definitions.",
      "description_length": 453,
      "index": 302,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Rtl.Deprecated.Uid_with_index",
      "library": "hardcaml",
      "description": "This module pairs a unique identifier with an integer index, enabling ordered comparisons and serialization. It supports efficient sorting and equality checks on signal identifiers combined with numeric indices. Useful for tracking and comparing indexed hardware signals in RTL designs.",
      "description_length": 286,
      "index": 303,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.List.Of_always",
      "library": "hardcaml",
      "description": "This module provides functions to manipulate and assign values to always block variables within an interface, specifically handling register and wire types. It supports creating register containers with optional enable signals, wire containers with default values, and assigning or extracting signal values from always variables. Concrete use cases include building and wiring hardware interfaces in an always block, such as connecting register outputs or initializing wire-based components.",
      "description_length": 491,
      "index": 304,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Rtl.Name.Vhdl",
      "library": "hardcaml",
      "description": "This module defines naming rules for VHDL identifiers, including character validation, replacement, and reserved word handling. It works with strings and characters to enforce naming conventions. Use it to sanitize and validate signal or variable names in VHDL code generation.",
      "description_length": 277,
      "index": 305,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Cyclesim.Private.Traced_nodes",
      "library": "hardcaml",
      "description": "Handles tracing of node values during cycle-accurate simulation, capturing signal transitions and internal state changes. Works with `Hardcaml.Signal.t` and simulation state structures to record historical values. Useful for debugging and waveform generation by tracking signal behavior over time.",
      "description_length": 297,
      "index": 306,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Bits_list.Bool_comb.Typed_math",
      "library": "hardcaml",
      "description": "This module implements arithmetic and comparison operations on bit lists interpreted as signed or unsigned integers. It supports addition, subtraction, multiplication, and comparisons (less than, greater than, equal, etc.), with automatic sign extension and resizing to preserve precision. These operations are used to model hardware circuits where bit list widths and values directly correspond to digital signal behavior.",
      "description_length": 423,
      "index": 307,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Flags_vector.Make.All",
      "library": "hardcaml",
      "description": "This module provides the `all` function, which transforms a vector of monadic values into a monadic vector of values. It operates on vectors of type `'a M.t t`, where `M` is a monad, and lifts the monadic structure outside the vector. A concrete use case is combining multiple concurrent computations, each represented as a monadic action, into a single action that produces a vector of results.",
      "description_length": 395,
      "index": 308,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Logic.Bit_vector.Typed_math",
      "library": "hardcaml",
      "description": "This module provides arithmetic and comparison operations for a typed bit vector representation, supporting addition, subtraction, multiplication, and comparisons like less than or equal, greater than, and equality. It works with a concrete type `v` representing bit vectors, allowing conversion to and from standard bit vector signals, and includes resizing to adjust bit widths with proper sign or zero extension. It is used for precise bit-level computations in digital circuit design, such as implementing arithmetic logic units or data path components.",
      "description_length": 557,
      "index": 309,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Bits_list.Bool_comb.Uop",
      "library": "hardcaml",
      "description": "This module implements arithmetic and comparison operations for lists of boolean values representing unsigned binary vectors. It supports addition, subtraction, multiplication, and comparisons like less than or equal, greater than, and equality, with automatic bit-width extension to preserve precision. These operations are used to model combinational logic circuits directly on boolean lists, enabling hardware descriptions with dynamic vector widths.",
      "description_length": 453,
      "index": 310,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Signal.Type.Type-Uid",
      "library": "hardcaml",
      "description": "This module defines a unique identifier type for hardware signals, supporting operations like comparison, hashing, and conversion to integers or strings. It works with the `t` type representing UIDs, along with standard types like integers and strings for conversion. Concrete use cases include tracking individual signal instances during simulation and netlist generation to ensure uniqueness and support debugging or optimization passes.",
      "description_length": 439,
      "index": 311,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Comb.Make.Uop",
      "library": "hardcaml",
      "description": "This module implements arithmetic and comparison operations for unsigned bit vectors, working directly with `t` values representing hardware signals. It supports addition, subtraction, multiplication, and comparisons like less-than or equal-to, with automatic bit-width extension to preserve precision. Use it to build combinational logic circuits that perform calculations or comparisons on fixed-width binary data, such as counters, arithmetic units, or control logic.",
      "description_length": 470,
      "index": 312,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Interface.Make.Of_signal",
      "library": "hardcaml",
      "description": "This module enables the construction and manipulation of hardware interfaces composed of signal vectors, supporting operations like packing/unpacking into bit vectors, multiplexing, concatenation, and width validation. It facilitates creating registers, pipelines, and hierarchical signal connections using operators like `<==`, with utilities for naming signals via prefixes/suffixes, ideal for structuring complex digital circuits and ensuring interface consistency in FPGA/ASIC designs.",
      "description_length": 489,
      "index": 313,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Scalar.Names_and_widths",
      "library": "hardcaml",
      "description": "This module defines lists of port names paired with their bit-widths, individual port names, port widths, and tags for hardware description in Hardcaml circuits. It supports static configuration of signal interfaces, enabling consistent signal naming and sizing across circuit components. Use cases include defining input/output ports for hardware modules and ensuring alignment between signal names and their bit-widths in generated HDL code.",
      "description_length": 443,
      "index": 314,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Flags_vector.Make.Flags",
      "library": "hardcaml",
      "description": "This module enables efficient manipulation of flag sets using bitwise operations like union, intersection, and subset checks, along with ordered operations such as comparison and clamping on a 63-bit integer-based type. It includes submodules for structured data handling with maps and sets, serialization through S-expressions and binary encoding, and property-based testing via Quickcheck integration. Users can manage hardware configurations, parse command-line flags, persist system states, and perform diff tracking or network transmission of flag data. Concrete operations include converting flag sets to integers or strings, comparing flag states, and building typed key-flag associations with strong type guarantees.",
      "description_length": 724,
      "index": 315,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Signal.Unoptimized.Sop",
      "library": "hardcaml",
      "description": "This module implements arithmetic and comparison operations for signed vectors, supporting addition, subtraction, multiplication, and comparisons like less than or equal. It operates directly on `Hardcaml.Signal.t`, automatically handling bit-width extension to prevent truncation during operations. Use this when designing combinational circuits that require signed arithmetic, such as digital signal processing or control logic with signed integer values.",
      "description_length": 457,
      "index": 316,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Interface.Empty.Unsafe_assoc_by_port_name",
      "library": "hardcaml",
      "description": "This module directly associates interface fields with values by port name using unsafe operations. It works with association lists mapping string keys to signal values. Use this module to quickly map or extract signals from an interface based on port names without runtime checks.",
      "description_length": 280,
      "index": 317,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.With_valid.Wrap.S-Of_bits",
      "library": "hardcaml",
      "description": "This module handles bit-level signal manipulation for hardware description, providing operations like packing/unpacking interfaces to vectors, multiplexing, and concatenation. It works with fixed-width bit vectors and supports validation of signal widths during simulation. Use cases include constructing and verifying digital circuit interfaces with precise control over signal widths and routing.",
      "description_length": 398,
      "index": 318,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Logic.Four_state_vector.Unsigned",
      "library": "hardcaml",
      "description": "This module implements arithmetic and comparison operations for unsigned four-state logic vectors, including addition, subtraction, multiplication, and comparisons like less than or equal. It works with the `v` type representing unsigned vectors, supporting operations between vectors of different widths and automatically extending results to prevent truncation. Concrete use cases include building digital circuits that require precise manipulation of unsigned binary values, such as counters, arithmetic logic units, or control logic in hardware designs.",
      "description_length": 557,
      "index": 319,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Comb.Make.Unsigned",
      "library": "hardcaml",
      "description": "This module provides operations for working with unsigned bit vectors, including arithmetic operations like addition, subtraction, and multiplication, where results are widened to avoid truncation. It supports comparison operations between vectors of different widths and includes a resize function for adjusting vector widths with appropriate extension. These functions are used to model combinational logic circuits that operate on unsigned binary numbers, such as arithmetic logic units or data path components in hardware designs.",
      "description_length": 534,
      "index": 320,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Enum.Make_one_hot.All",
      "library": "hardcaml",
      "description": "This module provides a function `all` that transforms a one-hot encoded enumeration of monadic values into a monadic value of a one-hot encoded enumeration. It operates on data structures produced by the `Make_one_hot` functor, which represent variants using a one-hot encoding. A concrete use case is combining multiple register fields in a hardware description, where each field is an optional value represented in one-hot form.",
      "description_length": 430,
      "index": 321,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Types.Cross_product.S-Of_always",
      "library": "hardcaml",
      "description": "This module provides functions to create and manipulate interface containers with register and wire variables within an always block. It supports operations like assigning signals to variables, creating registers with optional enable signals, and applying naming conventions to interface fields. Concrete use cases include building hardware interfaces with named signals, initializing wires to specific values, and managing register state in sequential logic blocks.",
      "description_length": 466,
      "index": 322,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Value.Of_signal",
      "library": "hardcaml",
      "description": "This module provides utilities for constructing and transforming hardware signal interfaces through operations like constant assignment, concatenation, multiplexing, and register creation, operating on combinatorial signal representations. It also supports connecting interfaces and applying naming conventions, which are essential for defining circuit inputs/outputs, linking components, and maintaining structured signal hierarchies in digital design workflows.",
      "description_length": 463,
      "index": 323,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Hardcaml.Types.Cross_product.Of_signal",
      "library": "hardcaml",
      "description": "This module enables manipulation of structured hardware signal interfaces through operations like packing/unpacking, concatenation, multiplexing, and pipeline creation. It operates on types representing fixed-width signal fields, supporting tasks such as connecting modules with named signals, generating input/output wires, and applying hierarchical naming conventions. These capabilities are used in building and interconnecting digital circuits with well-defined data paths and register stages.",
      "description_length": 497,
      "index": 324,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.With_valid.Wrap.S-Of_signal",
      "library": "hardcaml",
      "description": "This module enables the construction and validation of hardware interfaces by manipulating combinational and synchronous signals through operations like packing/unpacking, multiplexing, concatenation, and register/pipeline creation on `Of_signal.comb t` and `Of_signal.t` types. It supports wiring signals with directional connections (`<==`), generating named input/output interfaces, and validating signal widths to ensure correctness in circuit design. Use cases include building structured hardware pipelines, enforcing naming conventions for clarity, and managing complex signal interactions in synchronous and combinational logic.",
      "description_length": 636,
      "index": 325,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Value.Comb",
      "library": "hardcaml",
      "description": "This module implements combinational logic operations on structured hardware interfaces. It supports signal manipulation via functions like `pack`, `unpack`, `concat`, and various multiplexing operations including `mux`, `priority_select`, and `onehot_select`. These operations are used to build complex digital circuits such as arbiters, data routers, and control logic from fixed-width signal interfaces.",
      "description_length": 406,
      "index": 326,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.With_valid.Fields.S",
      "library": "hardcaml",
      "description": "This module provides operations for structured hardware interface manipulation, including mapping, zipping, equality checks, and bidirectional conversion to lists or bit-level representations. It works with validity-aware field structures (`'a t`) and tuples of signals (up to five elements), supporting transformations across combinational logic, signal pipelines, and register-based designs. Key use cases include constructing field-validity-aware interfaces, merging or splitting signal groups with error handling, and deriving default values for hardware description tasks like protocol binding or register layout generation.",
      "description_length": 629,
      "index": 327,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Enum.Make_binary.Of_signal",
      "library": "hardcaml",
      "description": "This module enables manipulation of binary-encoded enumeration types in hardware signals through operations like signal construction (wires, registers, pipelines), value assignment, integer-enum conversions, and multiplexing logic (priority/onehot selection). It operates on Hardcaml signal types (`comb t` and `t`), supporting digital circuit design patterns such as state machines, control logic, and binary decision routing where precise enum value handling is critical.",
      "description_length": 473,
      "index": 328,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Interface.Update.Names_and_widths",
      "library": "hardcaml",
      "description": "This module updates port names and widths in a Hardcaml interface, preserving the structure while modifying identifiers and sizes. It operates on lists of port names and widths, and works with tagged interface elements. Use it to programmatically rename ports or adjust signal widths in hardware descriptions.",
      "description_length": 309,
      "index": 329,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.List.Of_bits",
      "library": "hardcaml",
      "description": "This module provides functions to manipulate lists of bit vectors as structured interfaces. It supports operations like packing/unpacking interfaces to/from bit vectors, multiplexing, concatenation, and priority/one-hot selection with validation of signal widths. Concrete use cases include building register files, decoding instruction fields, and constructing complex digital circuits from named signal groups.",
      "description_length": 412,
      "index": 330,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.With_valid.Vector.Names_and_widths",
      "library": "hardcaml",
      "description": "This module defines port names and widths for hardware description in Hardcaml, providing direct access to lists of port names, widths, and associated tags. It works with basic string and integer lists, along with a custom `tag` type, to describe interface signals. Use this module when constructing or inspecting hardware modules with valid signal interfaces, such as defining pipeline stages or communication buses.",
      "description_length": 417,
      "index": 331,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Bits_list.Int_comb.Unsigned",
      "library": "hardcaml",
      "description": "This module implements arithmetic and comparison operations for unsigned binary vectors represented as lists of bits. It supports addition, subtraction, multiplication, and comparisons like less than or equal, with automatic bit-width extension to preserve precision. These operations are used to model digital circuits where bit vectors represent numerical values in hardware descriptions.",
      "description_length": 390,
      "index": 332,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Clocking.Make",
      "library": "hardcaml",
      "description": "This module structures and transforms hardware interfaces with named ports, widths, and tags, supporting operations like signal combination, register creation, and clock domain management. It enables bit-level composition, error propagation, and pipelined control logic using structured interfaces (`'a t`), `Signal.t` values, and clocking contexts. Child modules enhance this by adding combinational logic manipulation, clock crossing synchronization, bit vector operations, and monadic composition for sequential signal processing. Specific capabilities include building register files, decoding instruction fields, synchronizing signals across clock domains, and defining clocked logic with enable/reset behavior.",
      "description_length": 716,
      "index": 333,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.With_valid.Wrap.S-Of_always",
      "library": "hardcaml",
      "description": "This module provides functions to construct and manipulate hardware description interfaces using the Always API. It supports operations like assigning signals to variables, creating registers and wires with specified properties, and applying naming conventions to interface fields. It works with data types such as `Hardcaml.Always.Variable.t`, `Hardcaml.Signal.t`, and `Hardcaml.Reg_spec.t`, enabling concrete use cases like building named, configurable signal interfaces and managing synchronous logic with enable conditions.",
      "description_length": 527,
      "index": 334,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Signal.Type.Deps",
      "library": "hardcaml",
      "description": "This module processes dependencies of hardware signal types through traversal operations. It supports folding, mapping, and iteration over signal dependencies, enabling transformations and analyses of signal graphs. Use cases include generating ordered lists of dependent signals, applying functions to each dependency, or accumulating values across a signal's dependency tree.",
      "description_length": 377,
      "index": 335,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Logic.Std_logic_vector.Signed",
      "library": "hardcaml",
      "description": "This module implements arithmetic and comparison operations for signed fixed-width binary vectors. It supports addition, subtraction, multiplication, and comparisons like less than or equal, directly on signed vector values. These operations automatically handle sign extension and resizing to preserve correctness during computation.",
      "description_length": 334,
      "index": 336,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Bits_list.Bool_comb.Signed",
      "library": "hardcaml",
      "description": "This module implements arithmetic and comparison operations for signed binary vectors represented as lists of boolean values. It supports addition, subtraction, multiplication, and comparisons like less than or equal, operating on vectors of potentially different widths. These operations are used to build digital circuits that process signed integers in hardware descriptions.",
      "description_length": 378,
      "index": 337,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Logic.Std_logic_vector.Sop",
      "library": "hardcaml",
      "description": "This module implements arithmetic and comparison operations for signed logic vectors, supporting addition, subtraction, multiplication, and comparisons like less than or equal, greater than, and equality checks. It works directly with `Hardcaml.Logic.Std_logic_vector.t`, allowing operand width mismatch and automatically extending inputs as needed. Concrete use cases include building arithmetic circuits, implementing comparators, and handling signed value manipulations in hardware descriptions.",
      "description_length": 498,
      "index": 338,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Signal.Type.Uid_map",
      "library": "hardcaml",
      "description": "Maps values to signals by unique identifier, enabling efficient lookups and transformations based on signal UIDs. Works with `Signal.t` and user-defined data types stored per UID. Useful for tracking signal metadata or associating auxiliary information during simulation or netlist processing.",
      "description_length": 293,
      "index": 339,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Clocking.Of_bits",
      "library": "hardcaml",
      "description": "This module provides operations for constructing and manipulating clocked interfaces using bit vectors. It supports constant initialization, packing/unpacking interfaces to/from bit vectors, multiplexing, concatenation, and selection operations with support for validity signals. Concrete use cases include building register files, control logic, and hardware interfaces where signal widths and clocking domains must be explicitly managed.",
      "description_length": 439,
      "index": 340,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Logic.Four_state_vector.Sop",
      "library": "hardcaml",
      "description": "This module performs arithmetic and comparison operations on four-state logic vectors, supporting addition, subtraction, multiplication, and comparisons like less than or equal to. It works directly with `Hardcaml.Logic.Four_state_vector.t`, handling width extension automatically during operations to prevent truncation. Use this module to implement signed arithmetic circuits or comparisons in hardware descriptions where signal width safety and correctness are critical.",
      "description_length": 473,
      "index": 341,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Logic.Bit_vector.Signed",
      "library": "hardcaml",
      "description": "This module implements arithmetic and comparison operations for signed bit vectors, including addition, subtraction, multiplication, and comparisons like less than or equal. It works with the `v` type representing signed vectors, converting to and from standard bit vectors. Use cases include implementing arithmetic logic units (ALUs) and control logic in hardware designs where signed integer operations are required.",
      "description_length": 419,
      "index": 342,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Clocking.S-All",
      "library": "hardcaml",
      "description": "Lifts monadic values within an interface structure, transforming a monadic interface into an interface of monadic values. Works with polymorphic interface types `'a t` and monadic values `'a M.t`. Useful for composing hardware description computations where monadic effects need to be restructured outside the interface.",
      "description_length": 320,
      "index": 343,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Interface.Make_interface_with_conversion.Of_bits",
      "library": "hardcaml",
      "description": "This module defines operations to construct and manipulate hardware interfaces using bit vectors. It supports creating interfaces from integers, packing and unpacking signals, and multiplexing or concatenating interface values. Use cases include defining signal groups with specific widths, validating signal integrity, and implementing hardware logic such as register files or bus interfaces.",
      "description_length": 393,
      "index": 344,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Interface.Update.Unsafe_assoc_by_port_name",
      "library": "hardcaml",
      "description": "This module directly maps interface fields to and from an association list, using port names as keys. It supports converting an interface into a list of `(name, value)` pairs or building an interface from such a list. Use it when dynamically inspecting or reconstructing interfaces based on port names, such as during interface transformation or external configuration mapping.",
      "description_length": 377,
      "index": 345,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Signal.Unoptimized.Signed",
      "library": "hardcaml",
      "description": "This module provides operations for working with signed fixed-width binary vectors in hardware design. It supports arithmetic operations like addition, subtraction, and multiplication with automatic sign extension, as well as comparison operations between vectors of different widths. These operations are used to model and simulate digital circuits that require signed number representations, such as ALUs or control logic components.",
      "description_length": 435,
      "index": 346,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Interface.Make.Comb",
      "library": "hardcaml",
      "description": "This module provides combinational logic operations for manipulating signal interfaces, including packing/unpacking interfaces to/from vectors, multiplexing, concatenation, and selection functions like priority and one-hot selects. It works with signal interfaces defined over a combinational logic type, where each field has a specified bit width. Concrete use cases include building multiplexers, demultiplexers, and routing logic for hardware descriptions where signal groups need to be transformed or selected based on control signals.",
      "description_length": 539,
      "index": 347,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Array.Make_comb",
      "library": "hardcaml",
      "description": "This module implements combinational logic operations for array-like hardware interfaces. It supports signal packing/unpacking, multiplexing, concatenation, and selection operations with precise bit-width validation. Concrete uses include constructing register file read ports, decoding control signals, and assembling peripheral interfaces.",
      "description_length": 341,
      "index": 348,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Logic.Std_logic_vector.Unsigned",
      "library": "hardcaml",
      "description": "This module provides operations for manipulating unsigned fixed-width bit vectors, including arithmetic (addition, subtraction, multiplication), comparison (less than, greater than, equality), and resizing. It works directly with the `v` type, representing unsigned vectors, and supports conversions to and from standard logic vectors. Concrete use cases include implementing arithmetic logic units (ALUs), performing bit-width conversions, and building custom digital circuits requiring precise control over unsigned binary operations.",
      "description_length": 536,
      "index": 349,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.With_valid.Wrap.S-Unsafe_assoc_by_port_name",
      "library": "hardcaml",
      "description": "This module directly wraps an interface conversion that maps record fields to a list of key-value pairs using port names as keys. It supports converting structured hardware descriptions to and from associative lists, where each field in the record corresponds to a named port. Use this when interfacing with external systems that require named signal mappings, such as generating netlists or connecting components by port name.",
      "description_length": 427,
      "index": 350,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Signal.Type.Uid_set",
      "library": "hardcaml",
      "description": "This module represents a set of unique signal identifiers used in hardware design, providing operations to create and manipulate sets of signal UIDs. It supports standard set operations like union, intersection, and membership testing, specifically tailored for signal tracking and management. Concrete use cases include maintaining collections of distinct signals during simulation or netlist generation to prevent duplication and ensure signal integrity.",
      "description_length": 456,
      "index": 351,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Interface.Ast.Field",
      "library": "hardcaml",
      "description": "This module represents individual fields within an interface definition, capturing properties like name, type, sequence information, and documentation. It works with records containing signal or sub-module types, optionally annotated with array or list structure and documentation comments. It is used to define and manipulate hardware interface fields in a structured, serializable format.",
      "description_length": 390,
      "index": 352,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.With_valid.Fields.S-Unsafe_assoc_by_port_name",
      "library": "hardcaml",
      "description": "This module provides direct, unsafe access to fields of a Hardcaml interface using string keys, bypassing type checks. It works with association lists mapping field names to values of type `'a` and supports dynamic field manipulation. Use it when constructing or deconstructing interfaces from external data sources like configuration files or runtime inputs.",
      "description_length": 359,
      "index": 353,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Enum.Make_binary.Of_bits",
      "library": "hardcaml",
      "description": "This module supports bitwise case matching, packing/unpacking, and muxing operations on binary-encoded enumeration interfaces. It works with abstract interface structures backed by `Hardcaml.Bits.t` values to represent hardware signals, enabling synthesis of conditional logic like instruction decoders or state transition circuits. Key use cases include validating bit-width constraints and implementing combinatorial selection logic in hardware designs.",
      "description_length": 455,
      "index": 354,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Enum.Make_one_hot.Of_always",
      "library": "hardcaml",
      "description": "This module provides functions to manipulate and assign one-hot encoded enumeration interfaces within always blocks. It supports creating registers, wires, and named variables for one-hot signals, along with pattern matching and assignment operations tailored for use with the Always API. Concrete use cases include building state machines or multiplexed control logic where one-hot encoding is preferred for synthesis or timing reasons.",
      "description_length": 437,
      "index": 355,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Interface.Make.Make_comb",
      "library": "hardcaml",
      "description": "This module operates on signal interfaces with combinational logic, providing functions to pack, unpack, and manipulate grouped signals. It supports operations like multiplexing, concatenation, and priority or one-hot selection of interface fields. Use cases include building complex signal routing logic, validating signal widths, and constructing constant or dynamic interface values.",
      "description_length": 386,
      "index": 356,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Types.Cross_product.S-Of_bits",
      "library": "hardcaml",
      "description": "This module handles bit-level signal manipulation in hardware descriptions, providing operations to pack, unpack, concatenate, and multiplex structured interfaces. It works with fixed-width bit vectors and structured records of bit fields, enabling precise control over digital signal routing and transformation. Concrete uses include building register files, decoding instruction fields, and implementing bus multiplexing logic.",
      "description_length": 429,
      "index": 357,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Bits_list.X_comb.Typed_math",
      "library": "hardcaml",
      "description": "Implements arithmetic and comparison operations on variable-width bit lists using F, T, X as bit values. Works directly with the `v` type, which represents bit lists of implicit width. Useful for hardware simulation tasks requiring precise bit-level control, such as implementing custom ALUs or data path components.",
      "description_length": 316,
      "index": 358,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Cross_product.Of_bits",
      "library": "hardcaml",
      "description": "This module provides operations for constructing and manipulating hardware interfaces composed of bit vectors. It supports concrete tasks like packing and unpacking interfaces into bit vectors, multiplexing between interface values, concatenating interfaces, and validating signal widths. Use cases include building register files, decoding control signals, and managing structured hardware data paths.",
      "description_length": 402,
      "index": 359,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Types.Clocking.S-Of_always",
      "library": "hardcaml",
      "description": "This module provides functions to create and manipulate interface containers with register and wire variables within an always block. It supports operations like assigning signals to variables, creating registers with optional enable signals, and applying naming conventions to interface fields. Concrete use cases include building clocked hardware descriptions with named signals and managing signal assignments in a structured interface.",
      "description_length": 439,
      "index": 360,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Flags_vector.Make.Unsafe",
      "library": "hardcaml",
      "description": "Wraps a value of any type into a vector-like structure, enabling low-level bit manipulation and direct memory access. This operation is used to interface with hardware description constructs that require raw vector representations. Useful when implementing custom register transfers or memory-mapped I/O operations.",
      "description_length": 315,
      "index": 361,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Logic.Bit_vector.Unsigned",
      "library": "hardcaml",
      "description": "This module implements arithmetic and comparison operations for unsigned bit vectors, including addition, subtraction, multiplication, and comparisons like less-than or equal-to. It works with the `v` type representing unsigned vectors and supports operations between vectors of different widths. Concrete use cases include building digital circuits that require unsigned number manipulation, such as counters, arithmetic logic units, or data path components in hardware designs.",
      "description_length": 479,
      "index": 362,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Clocking.S-Make_comb",
      "library": "hardcaml",
      "description": "This module implements clocking operations for combinational logic interfaces, supporting signal manipulation via packing, unpacking, multiplexing, and concatenation. It works with typed signal interfaces (`comb t`) and bit vectors (`comb`), enabling precise width validation and dynamic signal routing. Concrete use cases include constructing multiplexers, validating signal widths at runtime, and serializing structured interfaces into flat bit vectors.",
      "description_length": 455,
      "index": 363,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.With_valid.Vector.Comb",
      "library": "hardcaml",
      "description": "This module provides operations for manipulating structured hardware interfaces with combinational logic. It supports creating constant values, packing/unpacking signals, multiplexing, concatenation, and selection operations with support for valid bits. It works with vector-like hardware descriptions where each field has a defined bit width, used for tasks like bus multiplexing, signal routing, or configuration decoding in digital circuits.",
      "description_length": 444,
      "index": 364,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Bits_list.Int_comb.Sop",
      "library": "hardcaml",
      "description": "This module implements arithmetic and comparison operations for signed integer vectors represented as bit lists, where each bit is either 0 or 1. It supports addition, subtraction, multiplication, and comparisons (less than, greater than, equal, etc.), automatically handling sign extension and width differences between operands. These operations are used to model and simulate digital circuits with signed integer values, such as ALUs or arithmetic pipelines, directly from OCaml code.",
      "description_length": 487,
      "index": 365,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Types.Value.All",
      "library": "hardcaml",
      "description": "Combines multiple monadic values within an interface into a single monadic interface, lifting the monad outside. Works with polymorphic interface types `'a M.t t` and transforms them into `'a t M.t`. Useful for aggregating results from multiple computations in a structured way.",
      "description_length": 278,
      "index": 366,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Signal.Unoptimized.Typed_math",
      "library": "hardcaml",
      "description": "This module provides arithmetic and comparison operations for hardware signals represented as type `v`. It supports addition, subtraction, multiplication, and comparisons like less than or equal, with automatic bit-width extension to prevent truncation. These operations are used to construct combinational logic circuits directly without optimization, enabling precise control over signal behavior in hardware designs.",
      "description_length": 419,
      "index": 367,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Types.Clocking.All",
      "library": "hardcaml",
      "description": "This module provides the `all` function, which lifts monadic values within a clocking interface to the outer monad. It operates on data structures of type `'a M.t Hardcaml.Types.Clocking.t`, transforming them into `'a Hardcaml.Types.Clocking.t M.t`. This enables sequencing monadic effects across clocked signals, useful when combining multiple clocked computations that must execute in lockstep.",
      "description_length": 396,
      "index": 368,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Signal.Type.Uid",
      "library": "hardcaml",
      "description": "This module implements a signal identifier system with unique integer values, supporting operations for creation, comparison, hashing, and conversion to integers or strings. It provides atomic signal generators for creating and resetting unique identifiers, ensuring distinct values across signal instances. Concrete use cases include managing signal identities in hardware simulations and netlist generation where uniqueness is critical.",
      "description_length": 438,
      "index": 369,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Interface.Empty.Comb",
      "library": "hardcaml",
      "description": "This module provides combinational logic operations for manipulating signal interfaces with empty combinational types. It supports packing/unpacking interfaces to/from vectors, multiplexing, concatenation, and selection operations like priority and one-hot encoding. Use cases include building complex signal routing logic, such as arbiters, multiplexers, and constant signal generators in hardware descriptions.",
      "description_length": 412,
      "index": 370,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Pair.M",
      "library": "hardcaml",
      "description": "This module provides core operations for working with pairs of values, enabling creation, transformation, and comparison of paired elements. It supports structured manipulation of hardware signals through named fields and bit widths, allowing tasks like mapping functions over pairs, aggregating errors, and restructuring interfaces. Submodules extend this foundation to handle combinational logic, signal packing, register pipelines, and dynamic record construction, with concrete applications in RTL design, interface wiring, and hardware signal routing. Key data types include pairs, records, and signal vectors, with operations like mapping, zipping, concatenation, and monadic lifting.",
      "description_length": 690,
      "index": 371,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Value.Of_always",
      "library": "hardcaml",
      "description": "This module provides functions to create and manipulate register and wire variables within an always block, specifically for signal interfaces. It includes operations to assign signals, generate registers with optional enable, create wire containers with default values, and apply naming conventions to interface fields. Concrete use cases include building synchronous logic blocks, defining interface connections with named signals, and managing signal defaults in hardware descriptions.",
      "description_length": 488,
      "index": 372,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Clocking.S-Of_signal",
      "library": "hardcaml",
      "description": "This module provides operations for constructing and manipulating hardware signal interfaces through packing, concatenation, and multiplexing, along with creating registers and assigning signals using `<==`. It works with structured signal types (`Of_signal.comb t` and `Of_signal.t`) that represent hardware signals with defined field widths and combinational logic. These utilities are used to define hardware components like registers, multiplexers, and structured input/output interfaces while applying naming conventions for clarity in hardware descriptions.",
      "description_length": 563,
      "index": 373,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.With_valid.Vector.Of_bits",
      "library": "hardcaml",
      "description": "This module provides operations to construct, manipulate, and validate bit vector interfaces. It supports packing and unpacking interfaces into bit vectors, multiplexing between interface values, concatenation, and selection operations like priority and one-hot decoding. Concrete use cases include building register files, decoding instruction fields, and managing signal routing in hardware descriptions.",
      "description_length": 406,
      "index": 374,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.With_valid.Fields.S-Of_signal",
      "library": "hardcaml",
      "description": "This module provides operations for constructing and manipulating hardware interfaces composed of signals, including constant assignment, multiplexing, concatenation, register pipelining, and structured wiring. It works with a structured interface (`t`) containing `Hardcaml.Signal.t` values, enforcing validation, width checking, and RTL-level signal assignment. Specific use cases include building register pipelines, connecting modular components via named signal wires, and managing hierarchical signal naming conventions with prefixes/suffixes during hardware synthesis.",
      "description_length": 575,
      "index": 375,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Cross_product.Unsafe_assoc_by_port_name",
      "library": "hardcaml",
      "description": "This module directly converts between a product type and an association list indexed by field names. It supports two primary operations: `to_alist` extracts fields into a string-keyed list, and `of_alist` builds a product from such a list. Useful for inspecting or constructing hardware interfaces by name, especially during debugging or dynamic configuration.",
      "description_length": 360,
      "index": 376,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.With_valid.Vector.Of_always",
      "library": "hardcaml",
      "description": "This module provides functions to manipulate and assign values to hardware description interfaces using the Always API. It supports operations on vector interfaces containing registers and wires, enabling direct assignment and naming of signals within always blocks. Concrete use cases include building and connecting register and wire interfaces with named signals in a hardware description.",
      "description_length": 392,
      "index": 377,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Interface.Make.Names_and_widths",
      "library": "hardcaml",
      "description": "This module generates signal interfaces with named ports and specified widths, enabling structured access and manipulation of hardware description data. It operates on lists of string-integer pairs representing port names and their bit widths, producing combinators for signal grouping and transformation. Concrete use cases include defining hardware module ports for simulation or synthesis, where precise signal naming and width tracking are required.",
      "description_length": 453,
      "index": 378,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Signal.Type.Is_a",
      "library": "hardcaml",
      "description": "This module includes functions to check the structural properties of hardware description signals, such as whether a signal is a register, memory, constant, or part of an operation like concatenation or multiplexing. It works directly with `Hardcaml.Signal.Type.t` values, which represent different types of hardware constructs. These checks are useful during signal analysis or transformation passes, such as optimizing or generating netlists from a hardware description.",
      "description_length": 472,
      "index": 379,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.List.Unsafe_assoc_by_port_name",
      "library": "hardcaml",
      "description": "Converts between a polymorphic record and an association list indexed by field names. Works with any record type `'a t` that has string-labeled fields. Useful for dynamically accessing or constructing record values by field name, such as in serialization or configuration parsing.",
      "description_length": 280,
      "index": 380,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.With_valid.Vector.Of_signal",
      "library": "hardcaml",
      "description": "This module provides operations for constructing and validating hardware interfaces through structural manipulation of signal vectors, including packing, concatenation, multiplexing, and pipeline creation. It works with `Of_signal.t` vectors to represent hardware interfaces, ensuring correct width alignment and constant assignment during composition. Specific use cases include connecting named signal interfaces with prefix/suffix conventions, wiring inputs/outputs using the `<==` operator, and building validated register stages for synchronous logic.",
      "description_length": 556,
      "index": 381,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Enum.Make_one_hot.Of_bits",
      "library": "hardcaml",
      "description": "This module enables efficient construction and manipulation of one-hot encoded enumeration interfaces using bit vectors, providing operations like packing/unpacking, multiplexing, and bitwise case matching. It operates on `Bits.t` values and enumerated interface types to facilitate hardware synthesis tasks such as state encoding, control signal generation, or priority-encoded selection logic. Key applications include implementing state machines with single-active-bit representations and synthesizing combinational logic that decodes specific bit patterns with optional fallback handling.",
      "description_length": 592,
      "index": 382,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Value.Make_comb",
      "library": "hardcaml",
      "description": "This module implements combinational logic operations for manipulating structured hardware values. It supports operations like packing/unpacking interfaces to vectors, multiplexing, concatenation, and priority/onehot selection, working with signal vectors and valid flags. Use cases include building complex signal routing logic, decoding instruction fields, and constructing testbenches with dynamic signal selection.",
      "description_length": 418,
      "index": 383,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Clocking.S-module-type-Comb",
      "library": "hardcaml",
      "description": "This module provides operations for constructing and manipulating combinatorial hardware interfaces. It supports signal packing, unpacking, multiplexing, and concatenation, along with validation and width assertion functions. Concrete use cases include building and verifying complex signal structures, selecting between multiple input interfaces using priority or one-hot encoding, and converting between integer values and signal representations.",
      "description_length": 448,
      "index": 384,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Comb.Make.Typed_math",
      "library": "hardcaml",
      "description": "This module provides arithmetic and comparison operations for fixed-width bit vectors, including addition, subtraction, multiplication, and comparisons like less-than or equal-to. It supports operations on the `v` type, which represents hardware signals with a defined bit width, allowing precise control over sign behavior and extension rules. Use it to implement combinational logic circuits such as ALUs, comparators, or data path elements where bit-level control and width-aware operations are required.",
      "description_length": 507,
      "index": 385,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Cross_product.S-module-type-Comb",
      "library": "hardcaml",
      "description": "This module provides operations for constructing and manipulating hardware interfaces composed of bit vectors. It supports concrete tasks like packing and unpacking fields into vectors, multiplexing between interface values, concatenating interfaces, and selecting between one-hot or priority-encoded inputs. Functions like `of_int`, `mux`, and `priority_select` enable direct synthesis of combinational logic for hardware description.",
      "description_length": 435,
      "index": 386,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Clocking.Unsafe_assoc_by_port_name",
      "library": "hardcaml",
      "description": "This module provides direct conversions between clocking interfaces and association lists indexed by field names. It supports the `to_alist` and `of_alist` functions for serializing and reconstructing clocking configurations. Use this when mapping clocking signals to named ports or dynamically constructing clocking interfaces from named value pairs.",
      "description_length": 351,
      "index": 387,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Cyclesim.Private.Step",
      "library": "hardcaml",
      "description": "This module defines the simulation phases used in a cycle-accurate hardware simulation, including reset, pre-clock, clock edge, and post-clock stages. It provides a type `t` representing these phases and a function to convert them to S-expressions for serialization or debugging. It is used to manage the precise timing and ordering of signal updates during simulation.",
      "description_length": 369,
      "index": 388,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Enum.Make_binary.Comb",
      "library": "hardcaml",
      "description": "This module provides operations to manipulate hardware interfaces with binary representations, supporting tasks like packing/unpacking signals, multiplexing, and concatenation. It works with enumerated types encoded as hardware interfaces, using `comb` and `t` types to represent signal values and their structure. Concrete use cases include building register file multiplexers, decoding instruction fields, and constructing state machine transitions using binary-encoded variants.",
      "description_length": 481,
      "index": 389,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Interface.Make.Of_bits",
      "library": "hardcaml",
      "description": "This module provides functions to convert interfaces to and from bit vectors, validate signal widths, and perform operations like packing, unpacking, multiplexing, and concatenation on interfaces composed of bit vectors. It works with record-like structures where each field is a `Hardcaml.Bits.t` value, representing hardware signals. Concrete use cases include constructing and deconstructing register interfaces, implementing bus multiplexers, and validating signal widths in hardware descriptions.",
      "description_length": 501,
      "index": 390,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Clocking.Of_always",
      "library": "hardcaml",
      "description": "This module provides functions to manipulate and assign clocked interface values using the Always API. It supports operations like assigning signals to clocked variables, creating registers and wires with specified properties, and applying naming conventions to interface fields. It works directly with clocked interfaces composed of signals and variables, enabling precise hardware description tasks like sequential logic and signal routing.",
      "description_length": 442,
      "index": 391,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.With_valid.Wrap.S-module-type-Comb",
      "library": "hardcaml",
      "description": "This module provides combinational logic operations for manipulating structured interfaces with valid signals. It supports operations like packing/unpacking interfaces to vectors, multiplexing, concatenation, and selection from one-hot or priority-encoded inputs. Concrete use cases include building complex signal routing logic, such as selecting between multiple data sources or assembling/disassembling compound signals in hardware designs.",
      "description_length": 443,
      "index": 392,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Interface.Make_interface_with_conversion.Of_signal",
      "library": "hardcaml",
      "description": "This module provides structural transformations and connection utilities for hardware signal interfaces, enabling operations like packing/unpacking, muxing, concatenation, and pipeline creation on `Of_signal.comb t` and `Of_signal.t` types. It emphasizes signal width management and hierarchical naming through combinational and registered signal manipulations, supporting complex hardware module composition. Specific use cases include building hierarchical designs with properly typed signal groups, connecting components via the `<==` operator, and applying naming conventions to ensure clarity in generated hardware descriptions.",
      "description_length": 633,
      "index": 393,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Clocking.S-Names_and_widths",
      "library": "hardcaml",
      "description": "This module defines clocking-related port names, widths, and tags used in hardware descriptions. It provides direct access to lists of port names, port widths, and associated tags, all derived from a base type. It is used to specify and manage clock domains and related signals in hardware designs.",
      "description_length": 298,
      "index": 394,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Rtl.Name.Verilog",
      "library": "hardcaml",
      "description": "This module defines rules and conventions for Verilog signal naming in hardware description code. It includes character validation for identifiers, a replacement character for invalid symbols, a prefix for generated names, case sensitivity settings, and a list of reserved Verilog keywords. It is used to ensure generated Verilog code adheres to language syntax requirements and avoids naming conflicts.",
      "description_length": 403,
      "index": 395,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Flags_vector.Make.Of_signal",
      "library": "hardcaml",
      "description": "This module provides operations for manipulating hardware signal interfaces through packing/unpacking, concatenation, multiplexing, register pipeline creation, and signal wiring, alongside naming transformations with prefixes/suffixes. It operates on structured signal types (`Of_signal.comb t` and `Of_signal.t`), emphasizing width validation, constant assignment, and structural transformations, particularly useful for organizing complex signal hierarchies and ensuring correct connectivity in digital circuit design.",
      "description_length": 520,
      "index": 396,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.List.Names_and_widths",
      "library": "hardcaml",
      "description": "This module defines lists of port names paired with their bit-widths, along with separate lists for names and widths. It provides direct access to these lists and a list of tags associated with the ports. Use this module to describe hardware port interfaces with explicit naming and sizing information.",
      "description_length": 302,
      "index": 397,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Enum.Make_binary.All",
      "library": "hardcaml",
      "description": "This module provides the `all` function, which lifts a monadic computation from inside an interface to the top level by combining all monadic actions across the interface's structure. It operates on interfaces containing values wrapped in a monad `M`, transforming a nested structure `'a M.t t` into a flattened form `'a t M.t`. This enables sequencing monadic effects across an entire hardware interface, such as wiring signals or propagating configuration values through a design.",
      "description_length": 482,
      "index": 398,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Types.Clocking.Names_and_widths",
      "library": "hardcaml",
      "description": "This module defines lists of port names and widths for clocking signals, along with associated tags. It provides direct access to these lists for use in hardware description contexts. The data structures are used to specify and manage signal attributes in circuit design flows.",
      "description_length": 277,
      "index": 399,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Bits_list.Int_comb.Typed_math",
      "library": "hardcaml",
      "description": "This module performs arithmetic and comparison operations on bit-list values interpreted as signed integers. It supports addition, subtraction, multiplication, and comparisons like less than or equal, greater than, and equality, with automatic sign extension. The result of arithmetic operations is widened by one bit to prevent truncation, and values can be explicitly resized to a target width.",
      "description_length": 396,
      "index": 400,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Flags_vector.Make.Comb",
      "library": "hardcaml",
      "description": "This module provides operations for constructing and manipulating hardware interfaces composed of bit vectors. It supports concrete tasks like packing and unpacking fields into vectors, multiplexing between interface values, concatenating interfaces, and selecting between one-hot or priority-encoded inputs. Functions like `of_int`, `mux`, and `priority_select` enable direct circuit construction with combinational logic on structured data.",
      "description_length": 442,
      "index": 401,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.With_valid.Wrap.S-Names_and_widths",
      "library": "hardcaml",
      "description": "This module defines operations to construct and manipulate Hardcaml interfaces with valid signals, specifically handling port names and widths. It provides values to retrieve lists of port names, widths, and tags associated with the interface. Concrete use cases include defining hardware components with named and sized ports for simulation or synthesis in digital design workflows.",
      "description_length": 383,
      "index": 402,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Clocking.Of_signal",
      "library": "hardcaml",
      "description": "This module supports structured manipulation of clocked signals through operations like packing, multiplexing, concatenation, and validation, while enabling register and wire creation with precise bit-width control. It works with clocked signal values (`t`) to facilitate field-level operations, signal assignment (`<==`), and interface construction via named input/output wires. Key use cases include hardware interface design, hierarchical signal naming with customizable prefixes/suffixes, and ensuring correct connectivity in synchronous logic circuits.",
      "description_length": 557,
      "index": 403,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Interface.Make_interface_with_conversion.All",
      "library": "hardcaml",
      "description": "This module provides the `all` function, which lifts monadic values within an interface to the monad outside the interface structure. It operates on interfaces parameterized by a monad `M`, transforming `'a M.t t` into `'a t M.t`. This enables sequencing monadic computations across all fields of an interface, such as collecting results from multiple signal transformations in a single pass.",
      "description_length": 392,
      "index": 404,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Interface.Update.Of_signal",
      "library": "hardcaml",
      "description": "This module provides functions to transform and manage structured signal groups, including concatenation, multiplexing, register pipelining, and bidirectional signal wiring via the `<==` operator. It operates on `comb t` and `t` types representing interfaces with named, width-defined ports, supporting use cases like hierarchical component adaptation, parameterized width adjustments, and structured signal interconnection with naming conventions.",
      "description_length": 448,
      "index": 405,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.With_valid.Wrap.S-Make_comb",
      "library": "hardcaml",
      "description": "This module implements combinational logic operations for wrapping and manipulating Hardcaml interfaces with valid signals. It provides functions like `pack`, `unpack`, `mux`, and `concat` to transform interfaces into vectors and multiplex signals, while ensuring correct bit widths via `assert_widths` and `validate`. Use cases include building complex signal routing logic, such as priority encoders or multiplexed data paths, directly from integer constants or existing combinational signals.",
      "description_length": 495,
      "index": 406,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Cross_product.S-Names_and_widths",
      "library": "hardcaml",
      "description": "This module defines a list of tuples representing port names and their corresponding widths, along with separate lists for port names and widths. It also includes a list of tags associated with these ports. It is used to describe the interface of hardware components in terms of signal names and bit widths.",
      "description_length": 307,
      "index": 407,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Enum.Make_one_hot.Comb",
      "library": "hardcaml",
      "description": "This module provides operations for working with one-hot encoded enumeration types in a hardware description context. It supports constructing and validating interfaces using one-hot vectors, with functions for packing/unpacking, multiplexing, concatenation, and selection based on priority or one-hot encoding. Concrete use cases include implementing state machines, control logic, and signal routing where distinct, non-overlapping bit representations are required.",
      "description_length": 467,
      "index": 408,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Bits_list.Make.Signed",
      "library": "hardcaml",
      "description": "This module implements arithmetic and comparison operations for signed binary vectors represented as lists of bits. It supports addition, subtraction, multiplication, and comparisons like less than or equal, with automatic sign extension and resizing to preserve precision. These operations are used to model and simulate signed integer arithmetic in hardware descriptions, such as in digital signal processing or ALU design.",
      "description_length": 425,
      "index": 409,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Signal.Type.Type",
      "library": "hardcaml",
      "description": "This module defines a hardware description signal type that supports operations like arithmetic, bitwise logic, multiplexing, and memory access. It works with signals represented as abstract syntax trees, including constants, operations, registers, and memory elements. Concrete use cases include constructing and manipulating digital circuits for simulation and synthesis, such as building combinational logic, defining state elements, and modeling memory behavior.",
      "description_length": 466,
      "index": 410,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Scalar.Make_comb",
      "library": "hardcaml",
      "description": "This module implements combinational logic operations for scalar signal interfaces, including packing/unpacking to vectors, multiplexing, concatenation, and selection from one-hot or priority-encoded inputs. It works with scalar types `comb` and structured interfaces `t`, supporting operations like constant assignment, width validation, and signal routing. Use cases include building register file read ports, ALU operand selectors, and control signal decoders directly from integer constants or other scalar signals.",
      "description_length": 519,
      "index": 411,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Enum.Make_one_hot.Unsafe",
      "library": "hardcaml",
      "description": "This module provides low-level, unsafe operations for working with one-hot encoded enumeration values, including the `wrap` function that converts a value into a one-hot encoded type. It operates directly on enumerated types represented as integers, ensuring efficient but unchecked conversions. Use cases include performance-critical hardware description code where safety checks are omitted for speed, such as in custom serialization or direct bit-level manipulation.",
      "description_length": 469,
      "index": 412,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Signal.Type.Uid_set-Uid",
      "library": "hardcaml",
      "description": "This module provides a set data structure specialized for `Uid.t` values, supporting efficient membership testing, insertion, and iteration. It works with unique identifier values generated by the `generator` function, which are used to track distinct hardware signal instances. Concrete use cases include managing sets of signal identifiers during netlist generation or simulation to avoid duplication and ensure consistency.",
      "description_length": 426,
      "index": 413,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Types.Cross_product.Names_and_widths",
      "library": "hardcaml",
      "description": "This module defines a list of port names paired with their widths, along with derived lists of names and widths. It works with tuples of strings and integers, and lists of a custom `tag` type. It is used to describe hardware interface ports in a hardware description context, where each port has a name and a bit width.",
      "description_length": 319,
      "index": 414,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Bits_list.Int_comb.Uop",
      "library": "hardcaml",
      "description": "This module implements arithmetic and comparison operations for unsigned bit vectors represented as lists of bits. It supports addition, subtraction, multiplication, and comparisons like less than or equal, greater than, and equality, with automatic bit width extension to preserve precision. These operations are used to build combinational circuits that process binary numbers, such as in digital signal processing or hardware arithmetic units.",
      "description_length": 446,
      "index": 415,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Bits_list.Make.Sop",
      "library": "hardcaml",
      "description": "This module implements signed arithmetic and comparison operations on lists of bits, supporting addition, subtraction, multiplication, and comparisons like less-than or equal-to. It works directly with bit vectors of type `t`, allowing variable-width operands and producing results with appropriate bit-width extensions. Use it to build combinational circuits for signed integer arithmetic and comparisons in hardware descriptions.",
      "description_length": 431,
      "index": 416,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Clocking.Make_comb",
      "library": "hardcaml",
      "description": "This module provides operations for constructing and manipulating clocking interfaces using a combinatorial logic type. It supports creating constant values, packing/unpacking interfaces to vectors, multiplexing, concatenation, and selection operations with support for validity signals. Concrete use cases include building register interfaces, managing signal routing in digital circuits, and handling bit-level data transformations.",
      "description_length": 434,
      "index": 417,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Interface.Make.Of_always",
      "library": "hardcaml",
      "description": "This module provides functions to create and manipulate interface containers of `Always.Variable.t` values, such as registers, wires, and named signals. It supports operations like assigning signal values to variables, extracting signal representations, and applying naming conventions to fields. Concrete use cases include building hardware descriptions with structured interfaces in an always block, such as connecting register banks or defining wire-based logic with initial values.",
      "description_length": 485,
      "index": 418,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Scalar.Comb",
      "library": "hardcaml",
      "description": "This module provides operations for constructing and manipulating scalar combinational logic interfaces. It supports data types like `comb` and `comb t`, enabling tasks such as packing/unpacking signals, multiplexing, concatenation, and validation of bit widths. Concrete use cases include building multiplexers, priority encoders, and constant signal generators in digital circuit design.",
      "description_length": 389,
      "index": 419,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.With_valid.Vector.All",
      "library": "hardcaml",
      "description": "Lifts monadic values within a vector to a monadic vector, combining all elements' effects. Works with polymorphic vectors containing monadic values. Useful for sequencing parallel computations in hardware description contexts.",
      "description_length": 226,
      "index": 420,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Interface.Make_interface_with_conversion.Unsafe_assoc_by_port_name",
      "library": "hardcaml",
      "description": "This module directly implements `to_alist` and `of_alist` functions for converting interface values to and from association lists indexed by field names. It operates on interface types, using strings as keys paired with signal values in the list. These functions enable programmatic access and construction of interface fields by name, particularly useful when interfacing with external systems or dynamically manipulating signal groups.",
      "description_length": 437,
      "index": 421,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Cross_product.S-Of_signal",
      "library": "hardcaml",
      "description": "This module provides operations to construct and manipulate hardware interfaces as signal bundles, including packing, unpacking, muxing, and creating pipelines or registers. It works with structured interfaces and signal vectors, enabling precise control over field widths and data-path organization. Additional utilities for connecting and naming signals support scalable circuit design through customizable naming strategies and interface wiring.",
      "description_length": 448,
      "index": 422,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Interface.Make_interface_with_conversion.Of_always",
      "library": "hardcaml",
      "description": "This module provides functions to manipulate interfaces within Hardcaml's Always API, enabling signal assignment, register and wire creation, and naming of interface fields. It operates on interface types containing `Hardcaml.Always.Variable.t` signals, allowing structured construction and modification of sequential and combinational logic. Concrete use cases include defining register interfaces with optional enable signals, assigning signal values to interface fields within always blocks, and applying consistent naming conventions to interface elements.",
      "description_length": 560,
      "index": 423,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Bits_list.Bool_comb.Unsigned",
      "library": "hardcaml",
      "description": "This module implements arithmetic and comparison operations for unsigned binary numbers represented as lists of boolean signals. It supports addition, subtraction, multiplication, and comparisons like less than or equal, greater than, and equality, with automatic width extension to preserve precision. These operations are used to construct combinational logic circuits for arithmetic computations on bit vectors in hardware descriptions.",
      "description_length": 439,
      "index": 424,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Enum.Make_enums.One_hot",
      "library": "hardcaml",
      "description": "This module transforms and manipulates one-hot encoded values for hardware design, supporting operations like mapping, folding, zipping, and scanning over `One_hot.t` structures backed by `Bits.t`. It enables structural manipulations, error-checked assignments, and combinational logic such as multiplexing and priority selection, with support for monadic transformations that combine signals in contexts like `Signal.t`. Child modules enhance this core functionality by generating enumerated types, implementing combinational logic, enabling register and wire manipulation in Always blocks, and providing low-level conversions for performance-critical or synthesis-safe workflows. Examples include building state machines with safe transitions, designing multiplexer arrays, and converting between one-hot signals and named signal interfaces for dynamic routing.",
      "description_length": 863,
      "index": 425,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Clocking.S",
      "library": "hardcaml",
      "description": "This module offers functions for transforming structured hardware interfaces through mapping, zipping, and list conversions, alongside utilities for signal tuple manipulation and clocked logic abstractions. It operates on interface types (`'a t`), signals (`Hardcaml.Signal.t`), and register specifications (`Reg_spec.t`), enabling use cases like RTL interface analysis, pipelined register implementation, and clock domain crossing management. Key operations include combinational logic construction, register instantiation with enable/clear controls, and feedback register handling.",
      "description_length": 583,
      "index": 426,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Logic.Std_logic_vector.Uop",
      "library": "hardcaml",
      "description": "This module implements arithmetic and comparison operations for unsigned logic vectors, including addition, subtraction, multiplication, and comparisons like less-than or equal-to. It operates directly on `Std_logic_vector.t` values, supporting operations between vectors of different widths and producing extended results to prevent truncation. These functions are used to build combinational logic circuits for operations like counters, arithmetic units, or control logic in hardware designs.",
      "description_length": 494,
      "index": 427,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Flags_vector.Make.Of_always",
      "library": "hardcaml",
      "description": "This module provides functions to create and manipulate interface containers with register and wire variables in the context of an `Always` block. It supports operations like assigning signals to variables, creating registers with optional enable signals, and applying naming conventions to signals within an interface. Concrete use cases include building hardware descriptions with structured interfaces, such as connecting module ports to internal signals or defining register banks with specific naming.",
      "description_length": 506,
      "index": 428,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.With_valid.Vector.Unsafe_assoc_by_port_name",
      "library": "hardcaml",
      "description": "This module provides direct conversions between a structured interface and an association list indexed by field names. It operates on data structures that map string keys to values, such as records or interfaces with named ports. Use this to serialize or deserialize port-based configurations, or to dynamically construct interfaces from named value pairs.",
      "description_length": 356,
      "index": 429,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Signal.Type.Make_deps",
      "library": "hardcaml",
      "description": "This module processes dependencies of hardware design signals through traversal operations. It provides functions to fold, iterate, and map over signal dependencies, enabling transformations and analyses of signal relationships. Use cases include dependency tracking, signal graph traversal, and custom processing of signal inputs during simulation or netlist generation.",
      "description_length": 371,
      "index": 430,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Cross_product.S-All",
      "library": "hardcaml",
      "description": "Lifts monadic values within a nested structure, transforming a monad of a product type into a product type of monads. Works with monadic values wrapped in a polymorphic type `t`, parameterized over another monad `M`. Useful for flattening nested monadic computations when handling multiple concurrent operations returning monadic results.",
      "description_length": 338,
      "index": 431,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Rtl.Deprecated.VerilogNames",
      "library": "hardcaml",
      "description": "Controls Verilog signal name generation with case sensitivity flag, reserved keyword list, and prefix configuration. Provides `legalize` to transform identifiers into valid Verilog names by escaping reserved words and applying naming rules. Useful when generating Verilog output to ensure signal names conform to language restrictions and project-specific conventions.",
      "description_length": 368,
      "index": 432,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Cross_product.S",
      "library": "hardcaml",
      "description": "This module supports structured manipulation of hardware interfaces through operations like mapping, zipping, and converting between signal collections and association lists. It works with hardware description types representing named ports and bit-widths (`'a t`, `Signal.t`), enabling introspection and transformation of circuit designs. Specific applications include generating combinational logic from always blocks, extracting signal metadata for analysis, and composing interfaces with precise bit-level control.",
      "description_length": 518,
      "index": 433,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Rtl.Deprecated.Vhdl",
      "library": "hardcaml",
      "description": "Converts a circuit into VHDL code, generating signal names based on input and output mappings. Works with circuits, signal maps, and boolean configuration flags. Used to produce synthesizable VHDL from hardware descriptions for FPGA or ASIC workflows.",
      "description_length": 251,
      "index": 434,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Rtl.Deprecated.Verilog",
      "library": "hardcaml",
      "description": "Writes a Verilog representation of a circuit to a file or standard output. It takes a boolean flag to control indentation, an I/O specification, and a circuit, then generates a mapping of signal names for the Verilog output. This function is used to produce synthesizable Verilog code from a Hardcaml circuit definition.",
      "description_length": 320,
      "index": 435,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Enum.Make_one_hot.Unsafe_assoc_by_port_name",
      "library": "hardcaml",
      "description": "This module provides `to_alist` and `of_alist` functions for converting between enumeration-based interface modules and association lists indexed by field names. It operates on types produced by one-hot enumeration functors, where each variant is represented as a single active bit. Use this to serialize or deserialize one-hot encoded interface values using string keys corresponding to field names.",
      "description_length": 400,
      "index": 436,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Cross_product.Of_always",
      "library": "hardcaml",
      "description": "This module provides functions to manipulate and assign values to hardware description interfaces within always blocks. It supports operations like creating register and wire variables, assigning signals, and applying naming conventions to interface fields. Concrete use cases include building and managing complex hardware interfaces with named signals in a structured way.",
      "description_length": 374,
      "index": 437,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Async_fifo.Make.O",
      "library": "hardcaml",
      "description": "This module enables transformation and composition of structured hardware interfaces through mapping, zipping, and bit-level operations on tuples of synchronous signals and interface types. It supports RTL interface construction, FIFO modeling with always blocks, and signal manipulation with safe naming and width management. Operations include combining records of monadic values, converting interfaces to and from bit vectors, and building combinational logic for signal routing and control. Submodules provide utilities for FIFO port definitions, signal packing/unpacking, unsafe interface inspection, and constructing asynchronous FIFOs with parameterized depth and bit-level precision.",
      "description_length": 691,
      "index": 438,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.List.Make_comb",
      "library": "hardcaml",
      "description": "This module implements combinational logic operations for manipulating hardware signal interfaces. It supports operations like packing/unpacking signals to vectors, multiplexing, concatenation, and priority/one-hot selection, working with lists of combinational signals. Use cases include building complex signal routing structures, validating signal widths, and constructing constant or dynamic multiplexed outputs.",
      "description_length": 416,
      "index": 439,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Interface.Make.Unsafe_assoc_by_port_name",
      "library": "hardcaml",
      "description": "This module directly maps fields of an interface to and from association lists keyed by port names, enabling straightforward conversion between interfaces and named signal groups. It operates on interface types generated by `Hardcaml.Interface` and supports values like signal groups with string keys. Use it to dynamically construct or inspect interfaces from external representations such as configuration files or runtime data.",
      "description_length": 430,
      "index": 440,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Interface.Empty.Of_always",
      "library": "hardcaml",
      "description": "This module provides functions to create and manipulate interface containers with register and wire variables in the context of the Always API. It supports operations like assigning signal values, extracting variable values, and applying naming conventions to interface fields. Concrete use cases include defining hardware registers and wires with structured interfaces, and setting up signal assignments within always blocks.",
      "description_length": 426,
      "index": 441,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Scalar.Unsafe",
      "library": "hardcaml",
      "description": "Converts a regular value into a scalar type, allowing it to be used in contexts that specifically require scalar values. Works with any data type `'a`, wrapping it into a scalar representation. Useful when interfacing with hardware description constructs that expect scalar inputs.",
      "description_length": 281,
      "index": 442,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Enum.Make_one_hot.Names_and_widths",
      "library": "hardcaml",
      "description": "This module generates port names and widths for a one-hot encoded enumeration type. It provides access to the list of port names, their corresponding widths, and the list of tags representing the enumeration cases. It is used to define hardware interfaces where each enumeration value is represented by a single active bit in a wider signal.",
      "description_length": 341,
      "index": 443,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.With_valid.Wrap",
      "library": "hardcaml",
      "description": "This module wraps Hardcaml interfaces with validity signals, transforming each into a tuple of the original data and a valid bit, ensuring safe handling of data-valid signaling in hardware pipelines. It provides core operations like `of_data_and_valid`, `data`, and `valid`, and supports structured interface manipulation through submodules that enable mapping, zipping, packing, and metadata extraction. Use it to build register files, multiplexers, and pipelined circuits with named ports and explicit validity tracking, or to convert between structured records and key-value lists for dynamic interface construction. Additional capabilities include combinational logic transformations, signal wiring with the Always API, and monadic aggregation of signal-valid pairs for simulation or synthesis.",
      "description_length": 798,
      "index": 444,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Vcd.Scope.Type",
      "library": "hardcaml",
      "description": "This module defines the hierarchical scope types used in VCD generation, including `Begin`, `Fork`, `Function`, `Module`, and `Task`. It provides conversions to S-expressions and strings for these scope types. These types are used to represent the structural hierarchy of variables in a VCD file.",
      "description_length": 296,
      "index": 445,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Parameter.Value.Variants",
      "library": "hardcaml",
      "description": "This module defines variant constructors for different types of hardware configuration values such as integers, strings, and bit vectors, along with operations to fold, iterate, map, and pattern match over these variants. It works with data types including boolean values, numeric types, string types, and specialized logic vector types like `std_logic_vector`. Use this module when building or manipulating parameterized RTL designs that require type-safe configuration values with direct hardware semantics.",
      "description_length": 509,
      "index": 446,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Bits_list.Bool_comb.Sop",
      "library": "hardcaml",
      "description": "This module implements arithmetic and comparison operations for lists of boolean values representing signed binary numbers. It supports addition, subtraction, multiplication, and comparisons like less than or equal, directly operating on these lists without requiring uniform widths. These operations are used to model combinational logic circuits where each list element corresponds to a bit in a signed integer representation.",
      "description_length": 428,
      "index": 447,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Hardcaml.Types.Cross_product.S-Unsafe_assoc_by_port_name",
      "library": "hardcaml",
      "description": "This module provides direct conversions between a polymorphic interface type and association lists indexed by string field names. It supports structured data manipulation for hardware description tasks where named ports or signals are mapped to values. Use cases include serializing hardware interfaces to key-value representations or dynamically constructing interfaces from configuration data.",
      "description_length": 395,
      "index": 448,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Logic.Four_state",
      "library": "hardcaml",
      "description": "This module models four-state logic with variants for unknown (`X`), high-impedance (`Z`), and driven (`L0`, `L1`) states, offering comparison, conversion, and state-check operations. It supports digital simulation through direct mapping to integers and characters, alongside pattern-matching helpers for logic analysis. Child modules extend this with mapping, folding, and iteration utilities, enabling circuit behavior modeling and signal state transformations. Examples include converting logic states to characters, evaluating signal behavior in hardware simulations, and transforming logic values across domains.",
      "description_length": 617,
      "index": 449,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Types.Scalar-Unsafe",
      "library": "hardcaml",
      "description": "This module provides a low-level `wrap` function that directly embeds a value into a scalar type without runtime checks. It operates on arbitrary types `'a`, producing a scalar representation suitable for hardware description contexts. Use this when safely bypassing type checks for performance or interface compatibility in hardware synthesis pipelines.",
      "description_length": 354,
      "index": 450,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Interface.Ast-Sequence",
      "library": "hardcaml",
      "description": "Handles sequences of hardware description signals with specific widths and lengths. Provides operations to manipulate and access elements within these sequences, such as indexing and slicing. Useful for working with arrays of registers or buses in hardware designs.",
      "description_length": 265,
      "index": 451,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Signal.Type",
      "library": "hardcaml",
      "description": "This module enables the construction and manipulation of hardware signals with support for arithmetic, logical, and memory operations, along with metadata management for names, attributes, and dependencies. It centers around UID-based identifiers defined in its submodules, which ensure uniqueness and support operations like comparison, hashing, and conversion, while dependency handling allows traversal, mapping, and analysis of signal graphs. The module includes structures for mapping signal identifiers to values and sets, facilitating efficient lookups and transformations during simulation, netlist generation, and optimization. Concrete capabilities include introspection for debugging, conversion to readable representations for visualization, and structural analysis to track drivers or generate ordered dependency lists.",
      "description_length": 832,
      "index": 452,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Always.State_machine",
      "library": "hardcaml",
      "description": "This module enables the construction and manipulation of state machines using registers to store state, supporting conditional transitions and enable signals for precise control over state updates. It provides core operations for defining state machines with symbolic identifiers, while child modules handle state representation and encoding schemes like Binary, Gray, and Onehot. You can define control logic for sequential circuits, such as protocol controllers, and serialize state machine configurations for synthesis or debugging. The API combines direct state transition definition with flexible encoding options to support both design and analysis tasks.",
      "description_length": 661,
      "index": 453,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Bits.Uop",
      "library": "hardcaml",
      "description": "This module performs arithmetic and comparison operations on bit vectors, including addition, subtraction, multiplication, and comparisons like less than or equal. It works directly with `Hardcaml.Bits.t` values, handling width mismatches by extending operands as needed and adjusting result widths to prevent truncation. Use this module to implement combinational logic circuits that perform unsigned arithmetic and comparisons on fixed-width bit vectors.",
      "description_length": 456,
      "index": 454,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Logic.Four_state-Variants",
      "library": "hardcaml",
      "description": "This module defines four-state logic values (x, z, l0, l1) and provides operations to fold, iterate, map, and match over these states. It works directly with the abstract type `t` representing four-state logic variants. Use cases include implementing digital circuit simulations and logic synthesis tools where precise handling of unknown (x), high-impedance (z), and binary (l0, l1) states is required.",
      "description_length": 403,
      "index": 455,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Interface.Ast-Sequence-Kind",
      "library": "hardcaml",
      "description": "This module defines the `t` type with variants `Array` and `List` to represent sequence kinds in signal interfaces. It includes the `sexp_of_t` function for converting sequence kind values to S-expressions. This enables precise specification and serialization of sequence structures when working with hardware description signals in Hardcaml.",
      "description_length": 342,
      "index": 456,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Scalar-All",
      "library": "hardcaml",
      "description": "Combines monadic values across a scalar interface, lifting the monad outside the structure. Works with any monad `M` and scalar types `'a M.t t`, transforming them into `'a t M.t`. Useful for handling computations where each scalar signal is wrapped in a monad, such as simulation or hardware description contexts.",
      "description_length": 314,
      "index": 457,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Value_arg",
      "library": "hardcaml",
      "description": "This module defines a type representing a port in a hardware design, with specific fields for the port's name and width. It is used to describe input and output interfaces in digital circuit components. Common use cases include specifying signal connections and generating hardware descriptions in a structured way.",
      "description_length": 315,
      "index": 458,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Interface.S_Of_signal-Of_signal",
      "library": "hardcaml",
      "description": "This module provides operations for structural manipulation and naming transformations of hardware signal interfaces, including validation, packing/unpacking, multiplexing, concatenation, pipeline creation, and prefix/suffix application to signal names. It operates on `Of_signal.t` values, which represent structured groups of named, typed signals with defined bit widths, enabling precise hardware description and connectivity. These capabilities are particularly useful for constructing hierarchical designs, managing signal name spaces in large circuits, and implementing register-transfer level (RTL) transformations.",
      "description_length": 622,
      "index": 459,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Fifo.Of_always",
      "library": "hardcaml",
      "description": "Implements FIFO operations within an `Always` block, providing variable assignment, signal registration, and named signal wiring. Works with `Hardcaml.Fifo.t` structures containing `Always.Variable.t` and `Signal.t` elements. Used to construct and manipulate synchronous FIFOs with precise control over enable signals, register specifications, and signal naming during hardware description.",
      "description_length": 390,
      "index": 460,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Flags_vector.S-Of_always",
      "library": "hardcaml",
      "description": "This module provides functions to create and manipulate interface containers with register and wire variables in the context of an always block. It supports operations like assigning signals to variables, creating registers with optional enable signals, and applying naming conventions to signals within an interface. Concrete use cases include building hardware interfaces with named, zero-initialized wires or conditional registers in a Hardcaml design.",
      "description_length": 455,
      "index": 461,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Interface.Create_fn",
      "library": "hardcaml",
      "description": "This module defines functions for implementing circuits that transform input interfaces into output interfaces, with types ensuring correct signal width and structure. It operates on input and output interface modules containing `Hardcaml.Signal.t` values, enforcing proper signal mapping and transformation. Concrete use cases include defining combinational logic blocks or sequential circuits where inputs and outputs are structured as named, typed interface modules.",
      "description_length": 469,
      "index": 462,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Interface.Ast",
      "library": "hardcaml",
      "description": "This module provides operations for constructing and manipulating abstract syntax trees representing hardware signal interfaces, with support for signal widths, hierarchical groupings, and RTL name annotations. It enables defining module ports, generating accessors, and driving code generation workflows through structured interface descriptions and transformations. The child modules extend this capability by introducing typed signal sequences, structured interface layouts, and serializable field definitions, allowing tasks like creating and mapping over fixed-length signal arrays, generating register specifications, and converting interface structures to S-expressions for debugging. Specific examples include defining a 4-element signal array, transforming its elements, and serializing the result for inspection or further processing.",
      "description_length": 844,
      "index": 463,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Enum.S_enums-Binary-Make_comb",
      "library": "hardcaml",
      "description": "This module provides operations for manipulating binary-encoded enumeration types in hardware description contexts, including multiplexing (via `mux`, `priority_select`, and `onehot_select`), validation, integer/S-expression conversion, and pattern-based comparison. It operates on combinational logic signals (`comb`) and binary-encoded enumeration values (`t`), using functions like `of_raw` for wrapping raw signals and `match_` for conditional case analysis. These utilities are particularly useful for implementing enum-driven control logic, data path selection, and validation checks in digital circuit designs.",
      "description_length": 617,
      "index": 464,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Comb.S-Unsigned",
      "library": "hardcaml",
      "description": "This module provides operations for manipulating unsigned bit vectors, including arithmetic operations like addition, subtraction, and multiplication, with automatic bit width extension to prevent truncation. It supports comparison operations between vectors of different widths and includes functions to convert to and from standard combinational logic signals. Use cases include implementing arithmetic logic units, performing bit vector comparisons, and managing unsigned data paths in hardware designs.",
      "description_length": 506,
      "index": 465,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Enum.S_enum-module-type-Comb",
      "library": "hardcaml",
      "description": "This module defines operations for working with combinational logic interfaces representing enumeration types. It supports creating, packing, unpacking, and multiplexing interfaces with bitvector fields, along with validation and width inspection. Concrete uses include building multiplexers, concatenating signal groups, and ensuring correct signal widths in hardware descriptions.",
      "description_length": 382,
      "index": 466,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Flags_vector.S-Names_and_widths",
      "library": "hardcaml",
      "description": "This module defines a list of named signal ports with associated bit widths, along with derived lists of just the names and widths. It works with basic string and integer lists, where each string represents a port name and each integer represents its bit width. This structure is used to describe hardware interface signals in a hardware description library, enabling consistent signal mapping and wiring in digital circuit design.",
      "description_length": 431,
      "index": 467,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Fifo.Comb",
      "library": "hardcaml",
      "description": "Implements combinational logic operations for FIFO structures with support for packing, unpacking, multiplexing, and priority/one-hot selection. Works directly with `comb` and `t` types representing combinational FIFO configurations. Enables precise control over dataflow in hardware designs, such as routing FIFO outputs based on dynamic conditions or constructing complex FIFO-based datapaths.",
      "description_length": 395,
      "index": 468,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Fifo.Make_comb",
      "library": "hardcaml",
      "description": "This module implements combinational logic operations for FIFO structures, including packing/unpacking values to/from a flat representation, multiplexing between multiple FIFOs, concatenation, and priority/one-hot selection with optional branching factors. It works directly with `comb` types from the provided module and `Fifo.t` structures parameterized by `comb`. Use this to build or manipulate hierarchical FIFO-based data paths in a combinational context, such as routing logic or data aggregation units.",
      "description_length": 510,
      "index": 469,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Flags_vector.S-Flags-Replace_polymorphic_compare",
      "library": "hardcaml",
      "description": "This module defines comparison operations and equality checks for a polymorphic type `t`, including standard operators like `(>=)`, `(<=)`, `(<>)`, and functions like `equal`, `compare`, `min`, and `max`. It works directly with values of type `t`, enabling ordering and equivalence judgments. Concrete use cases include comparing and sorting custom data types in a type-safe manner, such as numeric wrappers or enumerated structures.",
      "description_length": 433,
      "index": 470,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Flags_vector.Cases",
      "library": "hardcaml",
      "description": "This module represents a collection of flag vectors used to define and manipulate signal cases in hardware descriptions. It provides operations to compare flag vectors, generate S-expressions for serialization, and access all defined cases as a list. The primary use case is specifying input or output signal configurations in hardware simulation and synthesis tasks.",
      "description_length": 367,
      "index": 471,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Bits_list.Make",
      "library": "hardcaml",
      "description": "This module provides bitvector manipulation operations for combinational logic, including arithmetic, logical operations, comparisons, and bit-level transformations. It operates on fixed-width bit vectors represented as lists of boolean signals (`t`), supporting both signed and unsigned interpretations through dedicated conversion and arithmetic functions. The child modules refine these operations by specializing in signed or unsigned arithmetic, comparisons, and automatic width adjustments, enabling precise control over bit-level computations. Examples include building arithmetic logic units (ALUs), multiplexers, or testbenches that require direct manipulation of bit vectors, conversion between integer representations, and simulation of digital circuits with variable-width operands.",
      "description_length": 794,
      "index": 472,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Bits_list.X_comb",
      "library": "hardcaml",
      "description": "This module provides combinational logic operations on bit lists using F, T, and X as bit values, enabling precise manipulation of variable-width bit vectors for hardware design. It supports arithmetic operations like addition and multiplication, bitwise manipulation through masking and shifting, and type conversion between integers, strings, and booleans, with explicit control over endianness and sign extension. Submodules extend this functionality to handle both signed and unsigned binary vectors, implementing arithmetic logic units (ALUs), comparison-based control logic, and custom data path components with automatic width handling. Examples include modeling digital signal processing circuits, performing signed comparisons, and simulating hardware units requiring bit-level precision.",
      "description_length": 797,
      "index": 473,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Assertions.Violated_or_not",
      "library": "hardcaml",
      "description": "This module represents the result of assertion checks in Hardcaml simulations, distinguishing between violated and non-violated states. It works with integer lists to capture violation positions and provides a single value constructor for non-violated cases. Use this module to interpret simulation results and handle assertion outcomes programmatically during testing or debugging.",
      "description_length": 382,
      "index": 474,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Vcd.Timescale",
      "library": "hardcaml",
      "description": "This module defines and manipulates time units for VCD output, supporting operations to convert time values to strings and S-expressions. It works with integer values scaled by units like femtoseconds, picoseconds, nanoseconds, etc., as specified by the VCD standard. Concrete use cases include formatting simulation time stamps and ensuring correct time unit representation in generated VCD files.",
      "description_length": 398,
      "index": 475,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Logic.Std_logic_vector",
      "library": "hardcaml",
      "description": "This module provides functions for creating, manipulating, and converting bit vectors representing digital signals, with core operations including bitwise manipulation, logical and arithmetic operations, and conversions between integers, strings, and hardware-specific encodings. Its submodules extend this functionality with specialized support for signed and unsigned arithmetic, comparisons, and resizing, enabling precise control over bit-level computations in digital circuit design and simulation. The main data types include `std_logic_vector` and typed vector representations like `v`, with operations such as addition, subtraction, shifting, slicing, and comparisons that handle operand width mismatches and automatic sign or zero extension. Examples of use include implementing ALUs, counters, comparators, and data path components where exact bit-level behavior and signed or unsigned interpretations are critical.",
      "description_length": 925,
      "index": 476,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Constant.Make_bit_list",
      "library": "hardcaml",
      "description": "Converts between lists of `Bit.t` values and `Hardcaml.Constant.t` values. Works directly with `Bit.t` lists and `Hardcaml.Constant.t` for representing fixed-width constants. Useful for synthesizing or deconstructing constants in hardware descriptions using bit-level representations.",
      "description_length": 284,
      "index": 477,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Interface.Empty-Unsafe_assoc_by_port_name",
      "library": "hardcaml",
      "description": "This module provides unsafe operations for converting interfaces to and from association lists indexed by field names. It works with polymorphic interface types and string-keyed lists of values. Use this module to dynamically inspect or construct interfaces when field names are known and must be matched exactly, such as in serialization or configuration-driven signal mapping.",
      "description_length": 378,
      "index": 478,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Enum.S_enum-Of_always",
      "library": "hardcaml",
      "description": "This module provides functions to manipulate and assign signals within an always block using an interface-based approach. It supports creating registers, wires, and conditional logic that directly correspond to hardware description patterns like multiplexers and state machines. Key operations include signal assignment, register instantiation, wire creation, and pattern matching for enumerated types.",
      "description_length": 402,
      "index": 479,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Cyclesim.Reg",
      "library": "hardcaml",
      "description": "This module implements low-level register manipulation for a cycle-accurate simulation environment. It provides functions to read and write register data as integers, bit vectors, or raw bytes, supporting operations like `get64`, `set64`, `to_bits`, and `of_bits`. It is used to interface with hardware signals and memory-mapped registers in simulation, enabling precise control and observation of register state during testbenches or emulation.",
      "description_length": 445,
      "index": 480,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Async_fifo.S",
      "library": "hardcaml",
      "description": "Implements an asynchronous FIFO using distributed RAM with configurable data width and depth. Provides enqueue and dequeue operations with status flags for full and empty conditions. Designed for use in hardware description where precise control over memory resources and timing is required.",
      "description_length": 291,
      "index": 481,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Rtl.Digest",
      "library": "hardcaml",
      "description": "This module computes and manipulates digests of hardware circuits during RTL transformation. It supports creating digests from circuits and RTL languages, converting digests to strings or constants, and parsing digests from Verilog code. Use cases include tracking circuit transformations, generating unique identifiers for circuits, and embedding digest-based metadata in hardware descriptions.",
      "description_length": 395,
      "index": 482,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Structural.Lib",
      "library": "hardcaml",
      "description": "This module implements hardware generation primitives for registers with various control signals and tri-state buffer logic. It operates on `Hardcaml.Structural.signal` values, representing digital signals in a hardware design. Use it to describe sequential logic elements like clocked registers with enable, reset, and clear inputs, or to model tri-state bus behavior in structural hardware descriptions.",
      "description_length": 405,
      "index": 483,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Flags_vector.S-Flags-Set-Provide_bin_io",
      "library": "hardcaml",
      "description": "This module implements binary serialization and deserialization for a set of flags, enabling efficient storage and transmission of flag states. It works directly with `Flags.Set.t`, a set structure where elements are of the parameterized `Elt` type, typically representing individual flags. Concrete use cases include persisting configuration options to disk or sending flag-based state over a network wire format.",
      "description_length": 414,
      "index": 484,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Flags_vector.S-Flags",
      "library": "hardcaml",
      "description": "This module provides bitwise manipulation and comparison operations for 63-bit integer flags and bitvectors, supporting union, intersection, complement, and set-like queries. It works with private integer types and bitvector representations (`Flags.t`), enabling precise flag arithmetic and bounded value enforcement. Use cases include hardware modeling scenarios requiring compact bit-level representations, flag validation, and efficient conversions between integer/bitvector forms for serialization or debugging.",
      "description_length": 515,
      "index": 485,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Cyclesim_float_ops.Double",
      "library": "hardcaml",
      "description": "This module implements combinational logic operations for 64-bit double-precision floating-point arithmetic, including addition, multiplication, division, modulus, and advanced functions like exponentiation, logarithms, and trigonometric operations. It operates on `Hardcaml.Signal.t` values to model precise floating-point behavior in hardware simulation, supporting use cases such as prototyping arithmetic logic units (ALUs) or digital signal processing (DSP) components where accurate numerical computation is required.",
      "description_length": 523,
      "index": 486,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Enum.S_enums-Binary-Of_signal",
      "library": "hardcaml",
      "description": "This module provides operations for manipulating binary-encoded enumeration signals, including assignment, multiplexing, equality comparison, and interface construction. It operates on `Binary.Of_signal.t` values representing hardware signals and `Cases.t` structures for defining enum variants. These utilities are particularly useful for implementing control logic, state machines, or command decoders where enumeration values correspond to distinct hardware states or operations.",
      "description_length": 482,
      "index": 487,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Interface.S_Of_signal-Unsafe_assoc_by_port_name",
      "library": "hardcaml",
      "description": "This module associates signals with ports by name, enabling direct mapping between interface descriptions and signal lists. It provides functions to convert structured signal groups to and from association lists, where each entry pairs a port name with its corresponding signal. This is particularly useful when instantiating hardware modules where port connectivity must match by name, such as connecting hierarchical designs or generating top-level I/O.",
      "description_length": 455,
      "index": 488,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Signal.Signed",
      "library": "hardcaml",
      "description": "This module implements arithmetic and comparison operations for signed binary vectors, including addition, subtraction, multiplication, and comparisons like less-than or equal-to. It works with the `v` type representing signed signals, supporting variable-width operands and automatic sign extension. Concrete use cases include building arithmetic logic units (ALUs) or implementing fixed-point math in hardware designs.",
      "description_length": 420,
      "index": 489,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Enum.S_enums-One_hot-Unsafe",
      "library": "hardcaml",
      "description": "This module provides operations for working with one-hot encoded enumeration values, including wrapping raw values into a one-hot type. It is designed for use with hardware description code where enum values are represented as bit vectors with exactly one bit set. Use this module when implementing state machines or control signals in digital circuits where one-hot encoding improves synthesis or timing characteristics.",
      "description_length": 421,
      "index": 490,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Always.Variable",
      "library": "hardcaml",
      "description": "This module provides variables for use in Hardcaml's always blocks, supporting both combinational wires and synchronous registers. It allows creation of wires with default values, registers with optional enable signals, and pipelines of registers with specified depth. These variables are used to model stateful and combinational logic within Hardcaml's procedural DSL.",
      "description_length": 369,
      "index": 491,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Interface.Update",
      "library": "hardcaml",
      "description": "This module transforms Hardcaml interfaces by modifying port names and widths while preserving structural relationships, and integrates utilities for constructing, manipulating, and combining signal groups. It supports operations on `comb t` and `t` types to perform packing, multiplexing, concatenation, and register pipelining, enabling structured signal interconnection and hierarchical component adaptation. Use it to build multiplexers, register files, and control logic units, or to dynamically rename ports, adjust signal widths, and map interfaces to and from association lists for configuration or transformation purposes. Submodules extend functionality with combinational logic, monadic lifting, and bit-level manipulation, supporting simulation, synthesis, and interface validation workflows.",
      "description_length": 804,
      "index": 492,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Enum.S_enums-Binary-Of_always",
      "library": "hardcaml",
      "description": "This module provides functions to manipulate and assign signals within an always block, specifically for binary interface types. It supports operations like registering signals with optional enable, creating wire variables with default values, and pattern matching on signal values. Use cases include building state machines, connecting hardware modules, and managing signal assignments in a structured way.",
      "description_length": 407,
      "index": 493,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "Hardcaml.Cyclesim.Node",
      "library": "hardcaml",
      "description": "This module provides direct access to the underlying data and metadata of nodes in a cycle-accurate simulation. It supports operations to read and write binary data via bytes and bit-level representations, including conversion to and from mutable and immutable bit vectors. Concrete use cases include inspecting signal values during simulation, initializing nodes from existing bit storage, and extracting integer or 64-bit values for debugging or integration with external systems.",
      "description_length": 482,
      "index": 494,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Structural.Base2",
      "library": "hardcaml",
      "description": "This module provides low-level operations for constructing and manipulating hardware signals through bitwise logic, arithmetic (addition, subtraction, multiplication), and comparisons (equality, signed less-than). It operates on `t` values representing hardware signals with defined widths and values, enabling circuit design tasks like arithmetic logic units, data path elements, and signed comparison logic in simulation or synthesis workflows.",
      "description_length": 446,
      "index": 495,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Enum.S_enum-Unsafe",
      "library": "hardcaml",
      "description": "This module defines operations for working with enumeration types represented as packed values. It provides functions to convert between enumeration values and their integer representations, supporting direct access and manipulation of individual enum fields. Use cases include hardware description where specific bit patterns represent control signals or state machine values.",
      "description_length": 377,
      "index": 496,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Structural.With_interface",
      "library": "hardcaml",
      "description": "This module defines circuit instantiation and composition using structured interfaces composed of signals. It provides `create_circuit` to define new circuits with input, output, and tri-state signal interfaces, and `inst` to instantiate existing circuits with optional attributes and generics. It is used to build hierarchical hardware designs with well-defined signal connections between components.",
      "description_length": 401,
      "index": 497,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Flags_vector.S-module-type-Comb",
      "library": "hardcaml",
      "description": "This module provides operations for constructing and manipulating hardware interfaces composed of bit vectors. It supports creating constant values, packing and unpacking fields, multiplexing, concatenation, and selection operations with support for one-hot or priority-encoded control signals. These functions are used to build complex digital circuits by combining and routing signals based on fixed-width bit fields.",
      "description_length": 419,
      "index": 498,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Constant.Expert",
      "library": "hardcaml",
      "description": "This module provides low-level operations for manipulating constant values represented as integers, including bitwise operations and sign/zero extension. It works directly with integer values and offsets to represent fixed-width data, enabling precise control over bit-level representations. Concrete use cases include implementing custom constant folding logic and directly constructing hardware constants from integer values with specific bit widths.",
      "description_length": 452,
      "index": 499,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Types.With_valid",
      "library": "hardcaml",
      "description": "This module combines validity-aware interface manipulation with polymorphic vector operations to enable structured RTL design. It supports mapping, zipping, folding, and tuple transformations over vectors with 3-5 arguments, while tracking valid signals across combinational logic, register pipelines, and multiplexers. Core data types include `'a t` for tagged interfaces, `comb t` for combinational signals, and operations like `of_data_and_valid`, `data`, and `valid` for safe signal construction. You can build priority multiplexers, convert interfaces to bit vectors or association lists, perform field offset calculations, and wire signals using the Always API, with submodules enhancing these capabilities through monadic transformations, unsafe name-to-field conversions, and structured validation.",
      "description_length": 806,
      "index": 500,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Scalar",
      "library": "hardcaml",
      "description": "This module structures hardware interfaces with named, typed, and sized ports, enabling transformations like mapping, zipping, and metadata extraction for combinational logic and signal routing. It supports scalar values, signal wrappers, and bit-level representations, with operations to pack, unpack, concatenate, and validate signal widths, as well as dynamically adapt interfaces using named fields or runtime width checks. Submodules handle signal manipulation with bit vectors, interface-to-alist conversion, always block construction, structured signal routing, monadic interface aggregation, port configuration, combinational logic synthesis, and scalar value lifting. Examples include implementing ready/valid protocols, building multiplexers and priority encoders, constructing register pipelines, and generating HDL with consistent signal naming and sizing.",
      "description_length": 868,
      "index": 501,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Hierarchy.With_interface",
      "library": "hardcaml",
      "description": "This module supports creating and managing hierarchical circuit components with explicit input and output interfaces. It provides the `create` function to instantiate sub-circuits within a parent circuit, allowing for structured composition of hardware designs. Concrete use cases include building complex digital circuits such as CPUs or communication interfaces by organizing them into nested, reusable modules.",
      "description_length": 413,
      "index": 502,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Rtl.Signals_name_map",
      "library": "hardcaml",
      "description": "This module maps signal names to mangled RTL names using a dedicated type that pairs identifiers with indices, ensuring uniqueness and efficient comparison during Verilog generation. It provides operations to create, lookup, and manipulate these mappings, which are essential for translating signal names into stable, unique identifiers in the generated RTL. The bundled type supports ordering and serialization, enabling integration with data structures like sets and maps. Example usage includes tracking renamed signals in Verilog output or resolving name collisions during RTL elaboration.",
      "description_length": 593,
      "index": 503,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Types.Scalar-Unsafe_assoc_by_port_name",
      "library": "hardcaml",
      "description": "This module converts between scalar interfaces and association lists indexed by field names, using `to_alist` to extract named fields into a list and `of_alist` to build an interface from such a list. It operates on `'a t` values, which represent hardware description interfaces, and pairs them with strings as field identifiers. Use this when mapping hardware interface signals to a list of named values, such as for serialization or configuration purposes.",
      "description_length": 458,
      "index": 504,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Property.LTL",
      "library": "hardcaml",
      "description": "This module provides operations for constructing and transforming Linear Temporal Logic (LTL) formulas using boolean connectives (e.g., conjunction, implication) and temporal operators (e.g., next, until, globally). It works with the `path` type, which represents LTL formulas built from atomic propositions and logical operators, enabling tasks like formula simplification, depth analysis, and conversion to negative normal form. These capabilities are particularly useful in hardware verification for specifying temporal properties and extracting propositional constraints for formal analysis.",
      "description_length": 595,
      "index": 505,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Flags_vector.S-Unsafe",
      "library": "hardcaml",
      "description": "Converts a value into a vector of flags, enabling bitwise operations on individual flag values. Works with any type `'a` that can be represented as a vector of bits. Useful for efficiently managing and manipulating sets of boolean conditions or status flags in hardware description code.",
      "description_length": 287,
      "index": 506,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Rtl.Ast",
      "library": "hardcaml",
      "description": "This module provides core operations for constructing and transforming abstract syntax trees that model RTL hardware constructs such as variables, signals, assignments, and control flow. It supports synthesis, simulation, and analysis of register-transfer level designs, with utilities for tracking signal name associations and serializing AST nodes to S-expressions. A key submodule handles unique signal identification using UID and index pairs, enabling precise name mangling and comparison during Verilator compilation. Example use cases include mapping signals to unique RTL names and transforming AST structures for Verilog code generation.",
      "description_length": 646,
      "index": 507,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Parameter.Value",
      "library": "hardcaml",
      "description": "This module provides a unified polymorphic type `t` for representing hardware configuration values with strong type safety, supporting construction, validation, and serialization of values such as integers, strings, bit vectors, and logic vectors like `std_logic_vector`. It enables safe value extraction through typed accessors and integrates S-expression conversion for persistence and format interoperability, making it suitable for design instantiation and configuration parsing. The child module defines variant constructors and utilities for folding, mapping, and pattern matching over these values, enabling rich manipulation of parameterized RTL designs. Together, they form a cohesive system for handling Verilog/VHDL-like parameters with precise hardware semantics and flexible transformation capabilities.",
      "description_length": 816,
      "index": 508,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.With_valid.Vector",
      "library": "hardcaml",
      "description": "This module enables element-wise transformations, multi-vector folds, and structural conversions for vectors indexed by tags, supporting signal processing with validity flags, bit-level interface manipulation, and metadata-driven circuit design. It provides core operations like `map`, `zip`, and `to_list`, while child modules handle combinational logic, port configuration, structured interface manipulation, bit vector validation, register assignment, structural wiring, monadic sequencing, and interface serialization. Use it to build multiplexers, decode instruction fields, define pipeline stages, validate signal widths, or dynamically construct interfaces from named values. Key data types include tagged vectors, bit-width signals, port lists, and monadic interface descriptions.",
      "description_length": 788,
      "index": 509,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Constant.Bit",
      "library": "hardcaml",
      "description": "This module provides operations to create, compare, and manipulate single-bit constants, such as `vdd` for logic high and `gnd` for logic low. It supports the `t` type, which represents individual bits, and includes equality checks between bit values. Use cases include defining basic logic levels and performing bit-level comparisons in digital circuit simulations.",
      "description_length": 366,
      "index": 510,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Signal.Typed_math",
      "library": "hardcaml",
      "description": "This module provides arithmetic and comparison operations for hardware signals represented as values of type `v`. It supports addition, subtraction, multiplication, and comparisons such as less than, equal to, and greater than or equal, with automatic width extension as needed. These operations are used to construct digital logic circuits by performing bit-accurate computations on signal values.",
      "description_length": 398,
      "index": 511,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Rtl.Verilog",
      "library": "hardcaml",
      "description": "Converts a hardware description in RTL AST form into Verilog code, writing the result into a buffer. Works with the `Hardcaml__.Rtl_ast.t` type, which represents circuits in a structural form suitable for synthesis. Useful for generating synthesizable Verilog from OCaml-based hardware designs.",
      "description_length": 294,
      "index": 512,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Flags_vector.S-Flags-Set-Provide_of_sexp",
      "library": "hardcaml",
      "description": "Converts S-expressions into sets of flags, where each flag corresponds to an element of the `Elt` module. Works with `Sexplib0.Sexp.t` input and produces `Flags.Set.t` values. Useful for parsing configuration or input data that represents a collection of named flags in a type-safe manner.",
      "description_length": 289,
      "index": 513,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Enum.S_enum",
      "library": "hardcaml",
      "description": "This module provides mapping, zipping, and folding operations over structured hardware ports and signals, along with conversions between enumeration types and hardware representations like `Bits.t`. It supports manipulation of tuples (up to five elements), association lists, and metadata-rich port structures, enabling use cases such as hardware interface synthesis, testbench simulation, and enumerated signal transformation in digital design workflows.",
      "description_length": 455,
      "index": 514,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Signal.Unoptimized",
      "library": "hardcaml",
      "description": "This module provides combinational logic operations for fixed-width digital signals, enabling direct manipulation of `Hardcaml.Signal.t` values without optimization. It includes functions for bit selection, concatenation, comparisons, and tree-based reductions, supporting both signed and unsigned arithmetic through dedicated submodules that handle automatic width extension and operand alignment. Use it to build low-level hardware circuits such as counters, ALUs, or testbenches where explicit control over signal propagation and unoptimized structure is required. Specific operations include unoptimized constant creation, signed and unsigned addition, multiplication, and comparison, with support for resizing and sign/zero extension during computation.",
      "description_length": 758,
      "index": 515,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.With_valid.Fields",
      "library": "hardcaml",
      "description": "This module enables precise construction and manipulation of hardware interfaces with validity signals, centered around the `'a With_valid.t X.t` type. It provides operations to create, project, and combine fields with valid bits, supporting handshake protocols and dataflow control in RTL designs. Submodules handle bit-level transformations, monadic restructuring, combinational logic synthesis, and port metadata handling, enabling tasks like building AXI streams, decoding control signals, and generating register layouts. Users can manipulate fields directly via combinators, wire signals in always blocks, or dynamically access fields by name, all while ensuring signal width validation and structured composition.",
      "description_length": 720,
      "index": 516,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Enum.S_enums-Binary-Of_bits",
      "library": "hardcaml",
      "description": "This module provides bit-level manipulation and pattern-matching operations for binary-encoded enumeration interfaces, working with `Binary.Of_bits.comb`, `Binary.t`, and `Bits.t` types. It enables hardware-specific use cases like decoding instruction sets, implementing state machines, or routing data paths by validating bit patterns, performing conditional logic synthesis, and constructing signal interfaces. The pattern-matching functionality supports case-driven logic with explicit bit vector matching, ideal for control logic implementation.",
      "description_length": 549,
      "index": 517,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Vcd.Config",
      "library": "hardcaml",
      "description": "This module defines configuration parameters for VCD file headers, including date, version, optional comment, and timescale. It provides functions to serialize configurations to S-expressions, write them to output channels, and access a default configuration. Concrete use cases include setting up VCD file metadata before waveform data generation.",
      "description_length": 348,
      "index": 518,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Rtl_attribute.Vivado",
      "library": "hardcaml",
      "description": "This module provides Xilinx Vivado-specific RTL attributes to control synthesis and optimization, allowing precise specification of hardware behavior for registers, memory, and shift registers. It includes operations to apply attributes like `async_reg`, `fsm_encoding`, and `mark_debug` directly to signals or modules, ensuring correct handling of clock domains, state machine encoding, and debug visibility. The RAM submodule enables selection of implementation styles such as block RAM or distributed RAM, while the SRL submodule controls shift register LUT inference and placement. Examples include marking a register for debugging, enforcing a one-hot state encoding, or specifying distributed RAM for a memory block.",
      "description_length": 722,
      "index": 519,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Async_fifo.Make",
      "library": "hardcaml",
      "description": "This module implements an asynchronous FIFO with configurable depth using distributed RAM, providing `create` and `hierarchical` functions to instantiate FIFOs within a hardware scope using `Signal.t` ports. It handles clock domain crossings with optional synchronization stages and supports negedge sync chains, making it ideal for buffering data streams in communication bridges or pipeline stages. The module structures hardware interface manipulation through mapping, zipping, and folding over signal streams, enabling construction of parameterized FIFOs, signal transformations, and register management via combinational logic and stateful operations. Specific capabilities include control signal decoding, dynamic FIFO configuration, bit vector conversion with preserved semantics, and building synchronous logic with precise bit-widths and naming.",
      "description_length": 854,
      "index": 520,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Bits_list.Comb-Sop",
      "library": "hardcaml",
      "description": "This module implements arithmetic and comparison operations for signed bit vectors represented as lists of bits. It supports addition, subtraction, multiplication, and comparisons between vectors of potentially different widths, with automatic sign extension as needed. Concrete use cases include implementing fixed-point arithmetic circuits and comparison logic in hardware descriptions.",
      "description_length": 388,
      "index": 521,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Bits_list.Bool_comb",
      "library": "hardcaml",
      "description": "This module provides combinational logic operations on boolean lists representing bit vectors, enabling conversion between integers, strings, and bit sequences. It supports bitwise arithmetic (addition, multiplication), comparisons (signed/unsigned), and structural manipulations such as resizing, shifting, and priority encoding, allowing tasks like building arithmetic circuits or transforming bit-level data. Child modules refine these operations for signed and unsigned interpretations, handling automatic sign extension and width adjustments to model digital circuits with precise signal behavior. Specific uses include constructing adders, comparators, and data path components directly from boolean lists.",
      "description_length": 712,
      "index": 522,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Enum.S_enums-One_hot",
      "library": "hardcaml",
      "description": "This module provides functional transformations (mapping, folding, zipping), structural conversions (association lists, interface layouts), and simulation utilities for one-hot encoded values represented as `One_hot.t` types parameterized over `Bits.t` or signal types. It supports operations like equality checks, offset-based layout control, and safe/unsafe enum conversions, enabling tasks such as hardware interface design, combinational logic generation, and error-resilient value manipulation. Key use cases include converting between enumerated types and one-hot representations, simulating hardware signals with raw bit access, and managing port name/width associations in interface definitions.",
      "description_length": 703,
      "index": 523,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Fifo.Of_bits",
      "library": "hardcaml",
      "description": "This module implements synchronous FIFOs using bit vectors, providing operations for packing and unpacking FIFO states, multiplexing between FIFOs based on control signals, and concatenating multiple FIFOs. It supports priority and one-hot selection logic with optional valid signaling, and ensures correct bit-width validation. Concrete use cases include implementing hardware FIFOs in digital circuits, managing data streams with variable selection logic, and serializing FIFO state for storage or transmission.",
      "description_length": 513,
      "index": 524,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Flags_vector.S-Flags-Map-Provide_bin_io",
      "library": "hardcaml",
      "description": "This module provides binary serialization and deserialization functions for maps where keys are of a specified type and values are flag sets. It supports operations like `bin_write_t`, `bin_read_t`, and size calculation for efficient binary encoding and decoding. Concrete use cases include persisting or transmitting structured flag map data in binary format, such as configuration settings or hardware state representations.",
      "description_length": 426,
      "index": 525,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Rtl.Output_mode",
      "library": "hardcaml",
      "description": "This module defines output modes for RTL generation, specifying how generated Verilog or VHDL code should be written. It supports writing to a directory (with one file per circuit), a buffer, an output channel, or a single file. Use cases include directing synthesis output to different destinations depending on tooling or workflow requirements, such as writing to standard output, logging to a file, or organizing per-circuit files in a directory.",
      "description_length": 449,
      "index": 526,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Interface.Empty",
      "library": "hardcaml",
      "description": "This module enables structured manipulation of hardware signal groups through polymorphic operations like mapping, zipping, folding, and conversion to association lists, preserving metadata such as port names and bit-widths. It supports RTL interface construction, always block transformation, and circuit documentation, working with structured signal groups (`t`) and individual signals (`Signal.t`). Child modules extend this foundation with bit vector manipulation, combinational logic, monadic lifting, register and wire creation, and unsafe name-based signal mapping. Specific capabilities include packing/unpacking interfaces, multiplexing signals, defining port layouts, validating data paths, and combining monadic signals into a single interface for bulk processing.",
      "description_length": 775,
      "index": 527,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Interface.S_with_ast-Of_bits",
      "library": "hardcaml",
      "description": "This module defines operations for constructing and manipulating hardware interfaces composed of bit vectors. It supports creating constant interfaces from integers, packing and unpacking interfaces to and from bit vectors, and multiplexing or selecting between interface values using combinational logic. These operations are used to build digital circuits where interfaces represent groups of signals with defined widths and structure.",
      "description_length": 437,
      "index": 528,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Bits.Sop",
      "library": "hardcaml",
      "description": "This module performs arithmetic and comparison operations on fixed-width bit vectors, including addition, subtraction, multiplication, and comparisons like less than or equal. It supports resizing bit vectors to specified widths and converting between bit vectors and signals. Use cases include implementing digital circuits where precise control over bit-level operations and signed interpretations is required.",
      "description_length": 412,
      "index": 529,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Comb.S-Uop",
      "library": "hardcaml",
      "description": "This module defines arithmetic and comparison operations for fixed-width unsigned bit vectors, working directly with `t` values that represent hardware signals. It supports addition, subtraction, multiplication, and comparisons like less-than or equal-to, producing results with appropriate bit extensions to preserve correctness. These operations are used to model combinational logic circuits where precise control over bit-level representations and arithmetic behavior is required.",
      "description_length": 484,
      "index": 530,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Enum.S_enum-Names_and_widths",
      "library": "hardcaml",
      "description": "This module defines operations to work with enumeration types represented as hardware ports, providing access to their names, widths, and tags. It handles data types like strings for port names, integers for widths, and a list of tags for enumeration values. Concrete use cases include generating hardware interfaces from OCaml variants and mapping enum variants to signal widths in RTL descriptions.",
      "description_length": 400,
      "index": 531,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Interface.Empty-Make_comb",
      "library": "hardcaml",
      "description": "This module implements combinational logic operations for signal interfaces, including packing/unpacking vectors, multiplexing, concatenation, and selection functions. It operates on signal groups with defined bit widths, using integers to set constant values and validate structural correctness. Concrete use cases include building multiplexers, routing logic, and bit-level data manipulation in hardware descriptions.",
      "description_length": 419,
      "index": 532,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Comb.Make_primitives",
      "library": "hardcaml",
      "description": "The module provides low-level combinational logic operations on hardware signals, including bitwise logic (AND/OR/XOR/NOT), arithmetic (addition/subtraction/multiplication), multiplexing, and signal manipulation (concatenation, bit selection, naming). It operates on type `t`, representing hardware signals or wires, with explicit support for signed and unsigned operations through dedicated operators. These primitives are used to build fundamental hardware components like arithmetic logic units (ALUs), data path elements, and control logic circuits.",
      "description_length": 553,
      "index": 533,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Comb.Gates",
      "library": "hardcaml",
      "description": "Implements low-level bitwise operations and signal manipulations for hardware design. Provides functions for AND, OR, XOR, NOT, bit selection, concatenation, and constant creation. Works directly with signal values to build combinational logic circuits.",
      "description_length": 253,
      "index": 534,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Structural.Base",
      "library": "hardcaml",
      "description": "This module enables bit-level operations, arithmetic, and structural transformations on hardware signals represented by the `t` type, supporting tasks like concatenation, slicing, and combinatorial logic synthesis. It provides unsigned/signed multiplication, comparison primitives, and signal manipulation utilities for constructing digital circuits with precise control over data paths and tri-state logic. Typical applications include building arithmetic logic units, control logic, or custom hardware accelerators where fine-grained signal processing is required.",
      "description_length": 566,
      "index": 535,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Rtl_attribute.Value",
      "library": "hardcaml",
      "description": "This module defines a polymorphic type `t` that represents attribute values as integers, strings, or booleans. It provides equality checking and S-expression conversion for these values. Useful for encoding and comparing simple attribute data in RTL tooling workflows.",
      "description_length": 268,
      "index": 536,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Types.Scalar-Of_always",
      "library": "hardcaml",
      "description": "This module provides functions to create and manipulate interfaces composed of scalar variables within Hardcaml's Always blocks. It supports operations like assigning signals to variable interfaces, creating register and wire interfaces with initial values, and applying naming conventions to interface fields. Concrete use cases include building structured hardware descriptions with named registers and wires, and connecting interface signals in sequential logic blocks.",
      "description_length": 472,
      "index": 537,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Enum.S_enums-Binary",
      "library": "hardcaml",
      "description": "This module supports operations for transforming, combining, and analyzing hardware interface structures with named ports and widths, using types like `'a Binary.t` to represent both scalar and composite interfaces. It enables working with enumeration types through binary encoding conversions, pattern matching on tagged values, and simulating port behavior with error handling, while providing unsafe utilities for low-level signal manipulation. Key use cases include hardware interface composition, combinational logic synthesis, and bidirectional mapping between symbolic enums and their physical bit representations in digital circuits.",
      "description_length": 641,
      "index": 538,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Enum.S_enum-Unsafe_assoc_by_port_name",
      "library": "hardcaml",
      "description": "This module provides direct conversions between enumeration types and association lists indexed by field names, enabling straightforward serialization and deserialization of enum values. It operates on enumeration types (variants with no arguments) and string-keyed association lists, preserving field correspondence. Use this to map register fields or configuration values to and from string-indexed representations, such as when parsing or generating structured hardware descriptions.",
      "description_length": 486,
      "index": 539,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Bits_list.T",
      "library": "hardcaml",
      "description": "This module represents combinational logic as lists of bits, supporting bitwise operations like AND, OR, XOR, and inversion. It provides constants for high (vdd) and low (gnd) signals, and conversions to and from characters. It is used to construct and manipulate bit-level signals in a Hardcaml design, particularly for scenarios requiring explicit bit-level control or constant initialization.",
      "description_length": 395,
      "index": 540,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Value",
      "library": "hardcaml",
      "description": "This module enables the construction and transformation of hardware interfaces through typed values, supporting operations like mapping, zipping, and bit-level manipulation. It works with signals, combinational logic, and port-based representations, tracking names, widths, and tagged values for precise RTL design. Named ports can be inspected and transformed using association lists, while bit-level conversions support packing, unpacking, and multiplexing of signals. Combinational logic operations include priority and one-hot selection, register creation, and interface aggregation, enabling structured circuit design, signal routing, and simulation workflows.",
      "description_length": 665,
      "index": 541,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Enum.Make_one_hot",
      "library": "hardcaml",
      "description": "This module enables manipulation of one-hot encoded enumeration types for hardware design, offering operations for mapping, folding, and transforming combinational logic. It supports conversions between enumerated values and bit vectors, multiplexing over cases, and handling port metadata such as names and widths, with core data types including `'a t`, `comb`, and `Bits.t`. Submodules facilitate tasks like state machine implementation, priority-encoded logic, and interface serialization, with functions for packing, muxing, and unsafe conversions where performance is critical. Specific capabilities include constructing control paths, synthesizing combinational circuits, and managing register fields using one-hot representations.",
      "description_length": 737,
      "index": 542,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Fifo.Names_and_widths",
      "library": "hardcaml",
      "description": "This module defines port names and widths for FIFO implementations, including separate lists for port names, port widths, and FIFO tags. It works with strings, integers, and a custom tag type to describe FIFO interface signals. Use this module to configure or inspect FIFO signal interfaces in hardware descriptions.",
      "description_length": 316,
      "index": 543,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Types.Scalar-Make_comb",
      "library": "hardcaml",
      "description": "This module implements operations for manipulating scalar signal interfaces using a provided combinatorial logic module. It supports constant generation, packing/unpacking to vectors, multiplexing, concatenation, and selection operations with one-hot or priority-encoded inputs. These functions are used to build hardware circuits by composing and transforming signal interfaces with precise bit-level control.",
      "description_length": 410,
      "index": 544,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Bits_list.Int_comb",
      "library": "hardcaml",
      "description": "This module provides operations for manipulating signed and unsigned integer vectors represented as bit lists, supporting arithmetic and comparison operations with automatic sign or zero extension. It includes submodules focused on signed arithmetic with widened results, unsigned arithmetic for digital circuits, and mixed-width comparisons that return bit-encoded boolean results. Main data types are bit lists representing integers, with operations including addition, multiplication, and comparisons that handle width differences and produce extended or resized outputs. Examples include implementing fixed-point arithmetic, modeling ALUs, or building digital signal processing circuits directly from OCaml code.",
      "description_length": 716,
      "index": 545,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Enum.S_enums",
      "library": "hardcaml",
      "description": "This module defines operations for working with enumeration types represented as hardware signals. It supports converting between enumerated values and their binary or one-hot encoded signal representations. Concrete use cases include decoding and encoding finite state machine states or instruction opcodes in digital circuits.",
      "description_length": 328,
      "index": 546,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Structural.Config",
      "library": "hardcaml",
      "description": "This module defines configuration flags that control the structural representation of hardware primitives such as constants, multiplexers, concatenations, and selections. It works with boolean values to enable or disable structural elaboration of these primitives during hardware generation. Concrete use cases include customizing the structural output when generating Verilog or simulating hardware at a lower level of abstraction.",
      "description_length": 432,
      "index": 547,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Interface.Make",
      "library": "hardcaml",
      "description": "This module enables structural manipulation and functional transformation of hierarchical signal groups through operations like zipping, mapping, folding, and bit-width inference, working with tuples, association lists, and bit-offset tracked structures. It supports synthesizing named hardware interfaces, aggregating circuit components, and analyzing signal widths, while integrating monadic sequencing, vector operations, and combinational logic transformations across its submodules. You can build and manipulate hardware interfaces with signal vectors, pack/unpack interfaces to bit vectors, generate named ports with specified widths, and convert interfaces to and from association lists for dynamic construction. Specific capabilities include creating multiplexers, defining register banks, validating signal widths, and structuring complex digital circuits with named, typed fields.",
      "description_length": 890,
      "index": 548,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Enum.S_enums-One_hot-Of_always",
      "library": "hardcaml",
      "description": "This module provides functions to manipulate one-hot encoded signals within always blocks, including assignment, register and wire creation, name application, and pattern matching. It operates on `One_hot.t` interfaces containing `Always.Variable.t` values, enabling direct synthesis of state machines and control logic. Concrete use cases include implementing finite state machine transitions, decoding control signals, and managing register state in hardware descriptions.",
      "description_length": 474,
      "index": 549,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Cyclesim.With_interface",
      "library": "hardcaml",
      "description": "This module creates and manipulates cycle-accurate simulators with explicitly typed input and output interfaces. It works with circuit descriptions parameterized by input and output types, using `Hardcaml.Bits.t Base.ref` values to represent port signals. Use it to simulate hardware designs with well-defined I/O boundaries, such as testing register transfers or combinational logic under clocked conditions.",
      "description_length": 409,
      "index": 550,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Signal.Unsigned",
      "library": "hardcaml",
      "description": "This module implements arithmetic and comparison operations for unsigned binary vectors, including addition, subtraction, multiplication, and comparisons like less-than or equal-to. It supports fixed-width bit vectors, automatically handling width extension during operations and allowing explicit resizing. Typical uses include building arithmetic logic units, counters, and data path components in hardware designs.",
      "description_length": 417,
      "index": 551,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.With_valid.Wrap",
      "library": "hardcaml",
      "description": "This module wraps hardware interfaces with validity signals, enabling structured manipulation of data-valid pairs through combinational logic, register pipelines, and signal transformations. It provides core types like `'a t` for interfaces paired with valid bits and operations such as `map`, `valid`, and `of_tuple`, while supporting bit vector handling, always-block assignments, and metadata introspection through submodules. You can build pipelined datapaths, handshake protocols, and register files by composing named ports, routing signals, and validating widths, with concrete operations like `pack`, `unpack`, `mux`, and `concat` for bit-level control. Submodules further allow lifting monadic computations, converting interfaces to key-value mappings, and defining synchronous logic with enable conditions.",
      "description_length": 816,
      "index": 552,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Rtl.Blackbox",
      "library": "hardcaml",
      "description": "This module defines an enumerated type `t` with values `None`, `Top`, and `Instantiations` to control blackbox generation during RTL compilation. It includes a function `sexp_of_t` to convert these values to S-expressions. Use this module to specify whether and how blackboxes are used when generating hardware descriptions, such as turning the top-level circuit into a blackbox or only doing so for submodules.",
      "description_length": 411,
      "index": 553,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Flags_vector.S-Flags-Map-Provide_of_sexp",
      "library": "hardcaml",
      "description": "This module defines a function `t_of_sexp` that parses S-expressions into flag maps, converting each key using the provided function. It works with `Flags.Map.t` structures, where keys are of a type specified by the `Key` submodule. A typical use case is deserializing configuration data from S-expressions into typed flag maps for hardware description parameters.",
      "description_length": 364,
      "index": 554,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Instantiation.With_interface",
      "library": "hardcaml",
      "description": "Instantiates RTL designs with explicitly defined input and output interfaces, supporting parameterized configuration and attribute assignment. Works with interface modules I and O to define port mappings and data flow. Useful for integrating generated RTL blocks with customizable instance names, libraries, and synthesis directives.",
      "description_length": 333,
      "index": 555,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Circuit.Signal_map",
      "library": "hardcaml",
      "description": "Maps unique identifiers to Signal values within a circuit. Provides operations to serialize the mapping to S-expressions for debugging or storage. Useful for tracking and reconstructing signal relationships during circuit analysis or transformation tasks.",
      "description_length": 255,
      "index": 556,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Flags_vector.S-Flags-Set",
      "library": "hardcaml",
      "description": "This module supports creating and manipulating sets of flag-like elements, offering operations to construct sets from lists, arrays, sequences, trees, or hash tables, compute unions and intersections, and map or filter elements with type transformations. It handles comparator-based ordering and conversion from hash sets or hashtbl keys, while integrating serialization via S-expressions, binary formats, and hash functions. Use cases include testing workflows with Quickcheck-generated data, persisting set structures across sessions, and efficiently managing flag combinations with varying input sources.",
      "description_length": 607,
      "index": 557,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "Hardcaml.Types.Scalar-Of_signal",
      "library": "hardcaml",
      "description": "This module supports operations for manipulating hardware signal interfaces, including packing/unpacking, multiplexing, concatenation, register creation, and structural transformations like signal routing and validation. It works with combinatorial and sequential signal types (`Of_signal.comb t` and `Of_signal.t`), enabling use cases such as constructing circuit hierarchies, connecting input/output ports, and applying naming conventions to signals for clarity in synthesis and simulation. Specific behaviors ensure proper handling of constants and field-level transformations during hardware generation.",
      "description_length": 607,
      "index": 558,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Enum.Make_enums",
      "library": "hardcaml",
      "description": "This module provides tools for working with binary and one-hot encoded representations of enumerated types in hardware design contexts. It supports conversions between enums and bit vectors, element-wise operations on multi-bit interfaces, and structured signal manipulation with error tracking, using core types like `Binary.t` and `One_hot.t`. You can serialize hardware interfaces, build priority-encoded logic, simulate state machines, or construct multiplexer arrays with validated transitions. Specific operations include packing/unpacking enums, mapping over one-hot values, and generating port metadata from variants for dynamic signal routing.",
      "description_length": 652,
      "index": 559,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Enum.S_enums-Binary-All",
      "library": "hardcaml",
      "description": "This module provides a function `all` that takes a binary interface of monadic values and returns a monadic binary interface of combined values. It operates on data structures of type `'a M.t Binary.t`, where `M` is a monad, and lifts the monadic context outside the binary structure. A concrete use case is combining multiple monadic signals within a binary interface into a single monadic result, useful in hardware description contexts where signal dependencies must be explicitly managed.",
      "description_length": 492,
      "index": 560,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Cyclesim.Config",
      "library": "hardcaml",
      "description": "This module defines configuration options for the cycle-accurate simulator, controlling signal visibility, combinational operation substitution, signal deduplication, and circuit storage. It works with simulation signals, combinational operation databases, and circuit representations. Use it to customize simulation behavior, such as enabling waveform tracing, optimizing signal processing, or managing memory usage during simulation setup.",
      "description_length": 441,
      "index": 561,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Fifo.Unsafe_assoc_by_port_name",
      "library": "hardcaml",
      "description": "This module provides direct conversions between FIFO instances and association lists keyed by port names. It supports extracting a list of (port name, value) pairs from a FIFO or constructing a FIFO from such a list. Use this when interfacing with systems that require named signal mappings, such as generating Verilog or connecting to external hardware descriptions.",
      "description_length": 367,
      "index": 562,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Types.Cross_product",
      "library": "hardcaml",
      "description": "This module combines structured hardware interface transformations with cross-product constructions for bits, signals, and always blocks, enabling precise modeling and interconnection of digital circuits. It supports mapping, zipping, and conversions between association lists and tagged value lists, operating on parameterized structures (`'a t`) with metadata such as port names and bit widths. Child modules enhance this functionality with bit vector manipulation, combinational logic, monadic lifting, and interface serialization, allowing tasks like building multiplexers, packing/unpacking signals, and dynamically constructing interfaces from key-value data. Specific capabilities include signal routing, register management, width validation, and hierarchical naming for scalable circuit assembly.",
      "description_length": 805,
      "index": 563,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Bits.Expert",
      "library": "hardcaml",
      "description": "This module provides low-level operations for manipulating the internal byte representation of bit sequences, including direct memory access and bit-level transformations. It works with `Hardcaml.Bits.t` values, exposing their underlying byte array for custom serialization, optimized bit-packing, or hardware-specific data layout control. Concrete use cases include implementing custom I/O routines, optimizing performance-critical bit manipulations, and interfacing with external systems requiring precise memory layouts.",
      "description_length": 523,
      "index": 564,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Interface.Empty-Of_signal",
      "library": "hardcaml",
      "description": "This module provides operations for packing/unpacking signals, multiplexing, concatenation, register creation, and wiring, along with naming conventions for structured signal groups. It works with `Of_signal.comb t` and `Of_signal.t` types\u2014representing named, width-defined signal collections\u2014and is used for constructing register transfers, data paths, control logic, and hierarchical hardware modules with clear signal hierarchies.",
      "description_length": 433,
      "index": 565,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Interface.Ast-Type",
      "library": "hardcaml",
      "description": "This module defines the structure of hardware description abstract syntax trees (ASTs) used to represent signal and module hierarchies. It supports operations for constructing and deconstructing AST nodes, including signal declarations with bit widths and module instantiations with associated ASTs. Concrete use cases include building and analyzing digital circuit descriptions for simulation or synthesis.",
      "description_length": 407,
      "index": 566,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Interface.S_with_ast-Names_and_widths",
      "library": "hardcaml",
      "description": "This module defines operations for working with named signal interfaces that have associated widths. It provides functions to access and manipulate lists of signal names and widths, along with related tags. Concrete use cases include defining hardware module ports and generating signal groups for simulation or synthesis.",
      "description_length": 322,
      "index": 567,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Interface.S_Of_signal",
      "library": "hardcaml",
      "description": "This module provides operations to transform, combine, and traverse groups of signals using functions like `map`, `map2`, `iter`, and `fold`. It works with structured groups of `Hardcaml.Signal.t` values, identified by tags, allowing manipulation of hardware signals as named collections. Concrete use cases include building and connecting register interfaces, routing signal bundles in hardware generators, and applying transformations across related signals in a type-safe manner.",
      "description_length": 482,
      "index": 568,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Bits.Mutable",
      "library": "hardcaml",
      "description": "This module provides mutable bit vectors stored as byte-aligned 64-bit words, enabling efficient in-place bitwise operations, arithmetic, comparisons, and utilities like masking and multiplexing, with direct access to 64-bit words and conversion to immutable bit sequences. Its submodules extend this with specialized arithmetic and comparison operations for signed, unsigned, and mixed-width vectors, supporting automatic resizing and sign extension for simulating ALUs, control logic, and other digital components. Main data types include mutable bit vectors of fixed width, with operations for dynamic signal modification, concatenation, and bit-accurate computation in cycle-accurate simulations. Examples include performing bitwise XOR in-place, simulating register transfers, and modeling RTL components with changing signal widths.",
      "description_length": 838,
      "index": 569,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Interface.Empty-Of_always",
      "library": "hardcaml",
      "description": "This module provides functions to create and manipulate interface containers with register and wire variables in the context of an always block. It supports operations like assigning signal values, creating registers with optional enable signals, and applying naming conventions to interface fields. Concrete use cases include defining hardware registers and wires with specific behaviors in a Hardcaml design.",
      "description_length": 410,
      "index": 570,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Types.Array",
      "library": "hardcaml",
      "description": "This module provides tools for working with polymorphic arrays representing hardware signals and ports, enabling element-wise transformations, zipping, folding over multiple inputs, and conversions to and from lists. It supports tag-based association, equality checks, and combinational logic construction, with operations for handling bit-level interfaces and aggregating errors across multiple signals. Submodules enhance this functionality by enabling monadic tuple lifting, always block variable assignment, bit vector structuring, and combinatorial signal manipulation, with concrete applications in register file access, bus multiplexing, circuit validation, and hardware interface synthesis. Specific capabilities include named port array creation, signal concatenation, one-hot selection, and register pipeline construction, all while ensuring bit-width correctness and supporting customizable naming strategies.",
      "description_length": 920,
      "index": 571,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Interface.S_with_ast-Of_always",
      "library": "hardcaml",
      "description": "This module provides functions to create and manipulate hardware description interfaces using the Always API. It supports operations like assigning signals to variables, creating registers and wires with specified properties, and applying naming conventions to interface fields. It works with interfaces containing signals and variables, enabling structured hardware design with clear signal initialization and naming.",
      "description_length": 418,
      "index": 572,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Enum.S_enum-Cases",
      "library": "hardcaml",
      "description": "This module defines an interface for working with enumeration types that have no associated values. It provides operations to compare enumeration values, retrieve a list of all possible values, and convert values to S-expressions. It is used to implement type-safe enumerations with support for serialization and ordering.",
      "description_length": 322,
      "index": 573,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Interface.S_Of_signal-Names_and_widths",
      "library": "hardcaml",
      "description": "This module defines operations for working with named signal groups, providing access to signal names, widths, and tags. It supports data types like lists of string-integer pairs for port names and widths, and lists of tags. Concrete use cases include defining hardware module interfaces and extracting signal metadata for simulation or synthesis.",
      "description_length": 347,
      "index": 574,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Enum.S_enums-One_hot-Names_and_widths",
      "library": "hardcaml",
      "description": "This module defines operations for working with one-hot encoded enumeration types, providing access to port names, widths, and associated tags. It handles data types representing hardware ports and their configurations in a one-hot encoding scheme. Concrete use cases include generating interface signals and managing port mappings for hardware description and synthesis tasks.",
      "description_length": 377,
      "index": 575,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Flags_vector.S-Make_comb",
      "library": "hardcaml",
      "description": "This module implements operations for manipulating structured hardware interfaces as bit vectors using combinational logic. It supports packing and unpacking interfaces to and from bit vectors, multiplexing between interface values, concatenation, and priority/one-hot selection with validity signals. These operations are used to build complex digital circuits like register files, control units, and data paths where structured signal routing and selection is required.",
      "description_length": 471,
      "index": 576,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Bits_list.Comb-Signed",
      "library": "hardcaml",
      "description": "This module implements arithmetic and comparison operations for signed binary vectors represented as lists of bits. It supports addition, subtraction, multiplication, and comparisons like less than or equal, with automatic sign extension and proper result sizing. Use it to model fixed-point arithmetic or signed integer operations in hardware descriptions, such as implementing ALUs or data path components.",
      "description_length": 408,
      "index": 577,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Enum.Make_binary",
      "library": "hardcaml",
      "description": "This module constructs and manipulates hardware interfaces using binary-encoded enumeration types, enabling efficient simulation and synthesis of digital circuits. It provides operations for mapping, folding, and combining signal tuples, along with functions to convert enums to bit vectors, decode signals, and build combinatorial logic. Child modules extend this foundation with features like interface serialization, register and wire creation, case analysis, and low-level encoding control. Examples include modeling state machines, synthesizing control logic, and managing signal multiplexing with precise bit-level handling.",
      "description_length": 630,
      "index": 578,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Enum.S_enum-Make_comb",
      "library": "hardcaml",
      "description": "This module provides operations to convert integers to bitvector representations of enumeration types, multiplex signals using priority or onehot encoding, and validate or compare bitvector widths in combinational logic circuits. It works with `comb` and `t` types that model combinational hardware signals, along with `Cases.t` patterns for structured decoding. These tools are used to implement logic for routing, validation, and arithmetic operations in hardware designs where enumeration values are encoded as bitvectors.",
      "description_length": 525,
      "index": 579,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Structural.Base1",
      "library": "hardcaml",
      "description": "This API provides combinational logic primitives such as bitwise operations, arithmetic (addition, subtraction, signed multiplication), multiplexing (`mux`), signal concatenation (`concat_msb`), and bit selection (`select`). It operates on structural signal values representing digital circuit wires, enabling low-level hardware description with explicit signal naming and constant manipulation. These functions are used for constructing and transforming structural hardware representations in digital design workflows.",
      "description_length": 519,
      "index": 580,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Circuit.Port_checks",
      "library": "hardcaml",
      "description": "This module validates that the input and output ports of a hardware circuit match the ports defined in its interface. It supports checking for agreement in port sets and optionally their widths, based on the specified validation level. Use this when constructing or verifying circuits to ensure interface consistency.",
      "description_length": 317,
      "index": 581,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Comb.S-module-type-Typed_math",
      "library": "hardcaml",
      "description": "This module provides arithmetic and comparison operations for fixed-width bit vectors, including addition, subtraction, multiplication, and comparisons like less-than or equal-to. It works directly with the `v` type, representing typed bit vectors, allowing precise width manipulation and sign-aware operations. Concrete use cases include implementing hardware circuits for arithmetic logic units (ALUs) or comparison-based control logic in digital designs.",
      "description_length": 457,
      "index": 582,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Signal_graph.Deps_for_loop_checking",
      "library": "hardcaml",
      "description": "This module processes signal dependencies in a graph, allowing traversal and transformation of signals while accommodating loops through instantiations. It provides operations like `fold`, `iter`, `map`, and `to_list` to process dependencies in a defined order. Use cases include analyzing signal propagation paths and generating ordered signal lists for simulation or synthesis tasks.",
      "description_length": 385,
      "index": 583,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Property.CTL",
      "library": "hardcaml",
      "description": "This module represents Computation Tree Logic (CTL) formulas using algebraic data types for states and paths. It provides constructors for logical operations like conjunction, negation, and path quantifiers (existential and universal) combined with temporal operators such as next, until, finally, and globally. The module supports manipulation and inspection of CTL formulas, including extracting atomic propositions, mapping over them, and converting formulas to strings for debugging or output.",
      "description_length": 497,
      "index": 584,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Bits_list.Comb-Unsigned",
      "library": "hardcaml",
      "description": "This module performs arithmetic and comparison operations on unsigned bit vectors represented as lists of bits. It supports addition, subtraction, multiplication, and comparisons like less than or equal, directly on unsigned values. These operations handle implicit width extension to preserve value integrity during computations.",
      "description_length": 330,
      "index": 585,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Fifo.Config",
      "library": "hardcaml",
      "description": "This module defines configuration parameters for synchronous FIFOs, including data width, capacity, and whether showahead is enabled. It works with integer and boolean values to specify FIFO behavior in hardware designs. Used to customize FIFO instances with specific pipeline stages and buffering requirements for digital signal processing or data streaming applications.",
      "description_length": 372,
      "index": 586,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Flags_vector.S-Flags-Set-Elt",
      "library": "hardcaml",
      "description": "This module defines a type `t` representing elements of a flag set, along with serialization and deserialization functions for converting between S-expressions and flag values. It includes a comparator for ordering flag elements, ensuring consistent comparison operations. This module is used to manage sets of hardware configuration flags in a type-safe manner during circuit design and verification tasks.",
      "description_length": 407,
      "index": 587,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Ram.Collision_mode",
      "library": "hardcaml",
      "description": "This module defines comparison operations and ordering for collision resolution modes in RAM configurations, specifically handling the two possible modes: `Read_before_write` and `Write_before_read`. It supports standard comparison operators, equality checks, sorting functions, and value clamping between bounds, all directly applicable to collision mode values. These operations are used to determine and enforce ordering when configuring or analyzing memory behavior during RTL synthesis.",
      "description_length": 491,
      "index": 588,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Interface.S_with_ast",
      "library": "hardcaml",
      "description": "This module provides operations for transforming, combining, and converting structured signal groups through mappings, folds, and scans over tuples or lists of interfaces, while supporting bit-level and signal-level conversions. It works with tagged signal groups (`'a t`) containing port names and widths, abstract syntax trees (ASTs) for hardware descriptions, and specialized constructs like always blocks. Use cases include building hierarchical circuit interfaces, generating AST-based circuit representations, and manipulating signal groups for simulation or synthesis tasks.",
      "description_length": 581,
      "index": 589,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Enum.S_enum-Of_signal",
      "library": "hardcaml",
      "description": "This module provides operations for packing/unpacking, comparing, and conditionally routing hardware signal interfaces that represent enumeration types, with support for multiplexing, concatenation, and pipeline register creation. It works directly with `Signal.t` values structured as enum interfaces\u2014variant types with no arguments\u2014enabling precise control over signal naming, wiring, and validation. These capabilities are used to implement hardware logic circuits that require enum-based state encoding, signal routing, or register-staged transitions.",
      "description_length": 555,
      "index": 590,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "Hardcaml.Types.List",
      "library": "hardcaml",
      "description": "This module provides list-like operations for manipulating structured hardware data, such as port names, signal widths, and combinational logic, enabling transformations across interfaces, signals, and always blocks. It supports core data types like lists of monadic values, bit vectors, and records, with operations including mapping, zipping, folding, packing/unpacking, and multiplexing. You can sequence monadic computations over lists, build multiplexers and register files, assign signal values in always blocks, and convert between records and association lists for dynamic configuration. Submodules enhance these capabilities with specialized operations for combinational logic, interface validation, and structured signal manipulation.",
      "description_length": 744,
      "index": 591,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Caller_id.Mode",
      "library": "hardcaml",
      "description": "This module defines the modes for capturing callstack information in signal creation, with variants to disable tracing, capture only the top stack frame, or record a full trace. It works with the `t` sum type to control how much callstack data is embedded into signals. Use `Top_of_stack` to identify where signals are first created, or `Full_trace` to track full callstacks for debugging complex circuit construction issues.",
      "description_length": 425,
      "index": 592,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Cyclesim.Private",
      "library": "hardcaml",
      "description": "This module implements a cycle-accurate hardware simulation engine that manages signal propagation through nodes, registers, and memories across clock edges. It directly manipulates port lists, simulation tasks, and state elements to model hardware behavior, enabling the construction and modification of simulation pipelines and handling clock cycle transitions. The tracing submodule captures signal transitions and internal state changes over time, supporting waveform generation and debugging, while the simulation phases submodule defines and controls the timing stages\u2014reset, pre-clock, clock edge, and post-clock\u2014for precise signal update ordering. Example uses include simulating register updates on clock edges, tracing memory state changes, and generating signal histories for verification.",
      "description_length": 800,
      "index": 593,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Enum.S_enums-Binary-Names_and_widths",
      "library": "hardcaml",
      "description": "This module defines operations for working with enumeration types represented as binary signals in hardware descriptions. It provides access to port names and widths, tags for binary encoding, and facilitates mapping between symbolic enum values and their binary representations. Concrete use cases include generating register encodings, decoding instruction opcodes, and defining state machine transitions with explicit bit widths.",
      "description_length": 432,
      "index": 594,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Interface.S",
      "library": "hardcaml",
      "description": "This module supports structural manipulation of signal groups with named ports and bit widths through operations like mapping, zipping, and metadata extraction. It enables conversion between interfaces and association lists, error propagation across fields, and integration with always blocks, serving hardware design workflows that require precise signal composition and introspection.",
      "description_length": 386,
      "index": 595,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Interface.S-All",
      "library": "hardcaml",
      "description": "This module combines and lifts monadic values within an interface, transforming a structure of monadic signals into a monadic interface of signals. It operates on interfaces containing signals wrapped in a monad `M`, restructuring them so the monad applies to the entire interface. A typical use case is collecting results from multiple concurrent signal computations into a single interface once all individual computations complete.",
      "description_length": 434,
      "index": 596,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Flags_vector.S",
      "library": "hardcaml",
      "description": "This module provides operations for constructing, transforming, and inspecting hardware interfaces composed of structured port definitions and bit-level flag vectors. It works with typed vectors (`'a t`) representing hardware ports or flags, supporting operations like mapping, folding, bitwise manipulation, and associative lookups by port name or tag, along with conversions between flag vectors and bit-level representations. Specific use cases include defining and composing digital circuit interfaces, managing control signals via flag vectors, and implementing combinational logic transformations on port configurations.",
      "description_length": 626,
      "index": 597,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Hardcaml.Enum.S_enums-One_hot-Make_comb",
      "library": "hardcaml",
      "description": "This module provides operations for manipulating one-hot encoded enumeration types in hardware design contexts, including packing/unpacking, multiplexing, concatenation, and priority selection, alongside validation and width checks. It works with `comb` values and `One_hot.outer` types to enable safe case analysis using `Cases.t` patterns for exhaustive matching. These capabilities are particularly useful for implementing finite state machines, control logic, and priority-encoded signals where one-hot representations improve timing and reliability.",
      "description_length": 554,
      "index": 598,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Logic.Four_state_vector",
      "library": "hardcaml",
      "description": "This module provides a comprehensive framework for creating and manipulating four-state logic vectors (0, 1, X, Z), enabling precise modeling of digital signals in hardware design. It supports a full suite of operations\u2014bitwise, arithmetic, logical, and bit-level\u2014along with utilities for concatenation, slicing, and sign-aware resizing, making it suitable for tasks like circuit synthesis and testbench generation. Child modules specialize in arithmetic and comparison operations for signed, unsigned, and abstract vector types, automatically handling width extensions to ensure correctness during addition, multiplication, and comparisons. Specific applications include building ALUs, counters, and control logic where multi-valued logic and signal integrity are essential.",
      "description_length": 775,
      "index": 599,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Scope.Naming_scheme",
      "library": "hardcaml",
      "description": "This module defines naming strategies for signals in a hierarchical circuit design, supporting four modes: `Auto`, `Full_path`, `Local_path`, and `No_path`. Each mode controls how signal names are qualified with module hierarchy paths during generation. It is used to manage name uniqueness and readability in complex circuits, particularly when integrating with the Hierarchy module for automatic name rewriting.",
      "description_length": 413,
      "index": 600,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Enum.S_enum-Of_bits",
      "library": "hardcaml",
      "description": "This module offers functions to convert between enumeration types and bit vectors, along with operations like multiplexing, concatenation, and priority/one-hot selection on `Bits.t` values. It enables hardware synthesis tasks such as encoding control states, implementing conditional logic via bitwise case matches, and managing signal routing in digital circuits.",
      "description_length": 364,
      "index": 601,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Interface.Empty-module-type-Comb",
      "library": "hardcaml",
      "description": "This module provides combinational logic operations for manipulating signal interfaces, including packing/unpacking vectors, multiplexing, concatenation, and selection functions like priority and one-hot encoding. It works with interface types that define signal widths and names, and operates on values of type `comb t` representing hardware signals. Use cases include building complex signal routing logic, implementing register file read/write ports, and constructing control logic for CPUs or accelerators.",
      "description_length": 510,
      "index": 602,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Scope.Path",
      "library": "hardcaml",
      "description": "This module represents and manipulates hierarchical paths used for naming signals in a circuit design. It provides operations to convert paths to strings or lists, using a configurable separator, and supports hierarchical navigation. Use cases include managing signal names during circuit elaboration and generating flattened signal identifiers for simulation or synthesis.",
      "description_length": 373,
      "index": 603,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Fifo.Of_signal",
      "library": "hardcaml",
      "description": "This module enables the construction and transformation of synchronous FIFOs built from signal elements, featuring operations for multiplexing, concatenation, pipeline insertion, and width validation. It facilitates structural composition through input/output wiring and customizable signal naming, supporting complex data flow management in hardware pipelines. Key use cases include dynamic signal routing, synchronization across functional blocks, and scalable design of timing-c",
      "description_length": 481,
      "index": 604,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Clocking",
      "library": "hardcaml",
      "description": "This module structures and transforms clocking interfaces with combinational logic, bit vectors, and synchronization primitives, enabling precise control over clock domains, signal widths, and sequential elements. It provides core data types like `'a t` for structured interfaces, `Signal.t` for clocked signals, and combinational logic types (`comb`) with operations for packing, unpacking, multiplexing, and concatenation, alongside register creation with enable/reset behavior and clock domain crossing utilities. You can use it to define pipelined registers with custom reset values, convert structured interfaces to bit vectors or association lists for serialization, and synchronize signals across different clock domains using pulse stretching and async register annotations. Child modules enhance these capabilities with monadic lifting, always-block assignments, port metadata management, and combinational logic combinators for building complex hardware units like register files and control logic.",
      "description_length": 1008,
      "index": 605,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Flags_vector.S-Unsafe_assoc_by_port_name",
      "library": "hardcaml",
      "description": "This module provides functions to convert between a structured interface and an association list indexed by field names. It works with polymorphic interface types and string-keyed lists of values. Use cases include dynamically constructing interfaces from named value pairs or extracting field values for serialization and debugging.",
      "description_length": 333,
      "index": 606,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Interface.S-Names_and_widths",
      "library": "hardcaml",
      "description": "This module defines the structure and operations for working with named signal interfaces, where each signal has an associated width. It provides access to lists of port names, widths, and combined name-width pairs, along with tag information. It is used to describe and manipulate hardware signal interfaces in a structured, accessible way.",
      "description_length": 341,
      "index": 607,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Enum.S_enums-One_hot-Of_bits",
      "library": "hardcaml",
      "description": "This module provides operations for manipulating one-hot encoded enumeration values represented as bit vectors, including packing, unpacking, multiplexing, and validation. It supports case analysis over bit-level representations using pattern-matching logic with fallback defaults, operating directly on `Hardcaml.Bits.t` values. These utilities are particularly useful for synthesizing state machines or control logic where one-hot encoding ensures single-active-bit semantics in hardware designs.",
      "description_length": 498,
      "index": 608,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Rtl.Vhdl",
      "library": "hardcaml",
      "description": "Converts a hardware description in RTL AST form into VHDL code, writing the result directly to a buffer. Works with the `Hardcaml__.Rtl_ast.t` type, which represents the abstract syntax tree of a hardware design. Useful for generating synthesizable VHDL output from a Hardcaml circuit description.",
      "description_length": 297,
      "index": 609,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Rtl.Name",
      "library": "hardcaml",
      "description": "This module ensures valid identifier generation and transformation for hardware description languages by handling name legalization, mangling, and port management across Verilog and VHDL. It provides core operations for sanitizing identifiers, replacing invalid characters, managing case sensitivity, and avoiding reserved keywords, with support for multiport memories and module instantiation. The child modules define language-specific naming rules: one enforces identifier character constraints and case policies, another specializes in VHDL validation and sanitization, and a third handles Verilog-specific conventions including prefixing and keyword avoidance. Together, they enable concrete tasks like generating synthesizable signal names, handling special characters, and ensuring correct port declarations across HDL toolchains.",
      "description_length": 837,
      "index": 610,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Interface.S-Of_always",
      "library": "hardcaml",
      "description": "This module provides functions to create and manipulate hardware description interfaces using the Always API. It supports operations like assigning signals to variables, creating registers and wires with specified behaviors, and applying naming conventions to interface fields. These functions are used when defining synchronous logic blocks where structured signal groups are required.",
      "description_length": 386,
      "index": 611,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Rtl.Language",
      "library": "hardcaml",
      "description": "This module defines types and functions for working with hardware description languages. It includes a variant type for specifying Verilog or VHDL and provides a function to get the corresponding file extension. It is used to handle language-specific output formatting and file generation in synthesis flows.",
      "description_length": 308,
      "index": 612,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Signal_graph.Deps_for_simulation_scheduling",
      "library": "hardcaml",
      "description": "Computes dependencies of a signal for simulation scheduling by traversing the signal graph, breaking loops at sequential elements like registers and memories. It provides operations to fold, iterate, and map over dependencies in traversal order, with `rev_map` and `map` returning results in reversed or corrected order. Used to determine the evaluation order of signals during simulation, ensuring combinational logic is processed before dependent sequential elements.",
      "description_length": 469,
      "index": 613,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Flags_vector.S-Flags-Set-Provide_hash",
      "library": "hardcaml",
      "description": "This module implements hash functions for sets of flags, specifically for hashing entire sets and folding over their elements. It works with sets of flag values represented as `Flags.Set.t`. Concrete use cases include enabling efficient hashing of flag sets for use in hash tables or equality comparisons.",
      "description_length": 305,
      "index": 614,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Fifo.All",
      "library": "hardcaml",
      "description": "This module provides a function `all` that transforms a FIFO containing monadic values into a monadic FIFO of pure values, effectively sequencing effects across the FIFO's elements. It operates on `Hardcaml.Fifo.t` structures parameterized over a monad `M`, enabling controlled effect handling in synchronous FIFO pipelines. A concrete use case includes managing effectful data streams in hardware descriptions where effects must be explicitly sequenced through monadic actions.",
      "description_length": 478,
      "index": 615,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Cyclesim.Memory",
      "library": "hardcaml",
      "description": "This module provides functions to create and manipulate memory arrays with cycle-accurate read and write operations. It works with data types such as `Bits`, `Signal`, and `Int64`, supporting both mutable and read-only memory configurations. Concrete use cases include initializing memory from byte data, reading and writing values at specific addresses, and converting memory contents to and from bit representations for simulation purposes.",
      "description_length": 442,
      "index": 616,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Logic.Bit_vector",
      "library": "hardcaml",
      "description": "This module provides arithmetic and comparison operations for both signed and unsigned bit vectors, supporting addition, subtraction, multiplication, and comparisons across varying bit widths. It directly operates on `Hardcaml.Logic.Bit_vector.t` and a concrete `v` type, with automatic sign or zero extension during width conversions. The module enables precise bit-level computations for digital circuits such as ALUs, DSP blocks, and control logic, handling both signed and unsigned integer semantics. Specific operations include comparing two bit vectors for equality, performing arithmetic operations between vectors of different widths, and resizing vectors while preserving numeric value through sign or zero extension.",
      "description_length": 726,
      "index": 617,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Interface.Make_interface_with_conversion",
      "library": "hardcaml",
      "description": "This module creates and transforms structured hardware interfaces with typed fields, enabling conversions between signal representations like bits, signals, and always blocks. It supports mapping, combining, and error handling on interfaces composed of named ports, with operations for packing/unpacking to vectors, multiplexing, concatenation, and selection, working with signal groups by bit widths. Functions like `to_alist`/`of_alist` allow programmatic access by field names, while `all` lifts monadic computations across interface fields. Use cases include building control logic, register interfaces, routing structures, and interfacing with external systems using custom types and precise signal transformations.",
      "description_length": 720,
      "index": 618,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Enum.S_enums-Binary-module-type-Comb",
      "library": "hardcaml",
      "description": "This module provides operations for manipulating enumeration-based interfaces as binary data. It supports functions like packing/unpacking interfaces to/from bit vectors, multiplexing, concatenation, and priority/one-hot selection, all working with `comb Binary.t` types representing hardware signals. Use cases include building register files, decoding instruction sets, or implementing state machines with fixed-width binary fields.",
      "description_length": 434,
      "index": 619,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Rtl.Expert",
      "library": "hardcaml",
      "description": "Generates RTL output for a given circuit while producing a mapping of signal names to their corresponding identifiers. It supports customization through output modes, circuit databases, and blackbox configurations. This function is used when precise control over signal naming and output generation is required, such as in simulation or synthesis workflows.",
      "description_length": 357,
      "index": 620,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Comb.Make",
      "library": "hardcaml",
      "description": "This module enables the creation of constant signals and precise bit-level manipulations such as slicing, concatenation, shifting, and resizing, along with arithmetic and logical operations on hardware signals of type `t`. It includes combinational logic primitives for comparisons, multiplexing, encoding conversions, and reduction operations, supporting both signed and unsigned arithmetic through dedicated submodules that handle automatic sign or zero extension, widening, and width-aware comparisons. Specific operations include building arithmetic logic units (ALUs) with signed or unsigned addition, implementing control logic with comparison-based decisions, and constructing data path components like counters or encoders. The module and its submodules collectively allow modeling of complex combinational circuits with strict control over bit-level behavior and type conversions.",
      "description_length": 889,
      "index": 621,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Interface.S-Unsafe_assoc_by_port_name",
      "library": "hardcaml",
      "description": "This module directly maps interface fields to values using port names as keys, enabling unsafe but efficient association and lookup operations. It works with lists of string-value pairs to construct or deconstruct interfaces where field names correspond to signal ports. Use this when translating between interface values and external representations like JSON or configuration files, where port names must align exactly.",
      "description_length": 421,
      "index": 622,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Vcd.Scope",
      "library": "hardcaml",
      "description": "This module organizes hierarchical signal scopes for VCD generation, supporting creation, traversal, and header writing. It operates on `Scope.t` and `Var.t` structures, grouping variables under named scopes with optional subscopes, and includes operations to build and navigate hierarchical signal paths. The child module defines scope types like `Module`, `Task`, and `Fork`, providing string and S-expression representations used to structure simulation signals. Together, they enable structured waveform output by mapping variables to hierarchical scopes for VCD visualization.",
      "description_length": 581,
      "index": 623,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Flags_vector.S-All",
      "library": "hardcaml",
      "description": "This module combines a vector of monadic values into a monadic vector of values, effectively lifting the monad outside the vector structure. It operates on vectors containing elements wrapped in a monad, transforming them into a single monadic vector. A typical use case involves processing multiple concurrent hardware description computations, such as instantiating and wiring a set of registers or combinational logic blocks, where each element in the vector represents a separate hardware component or signal.",
      "description_length": 513,
      "index": 624,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Arg_with_length",
      "library": "hardcaml",
      "description": "This module defines a type for representing hardware ports with a name, width, and length. It includes values to access the port's identifier, bit width, and vector length. It is used to describe signal ports in hardware designs, particularly for defining interfaces with fixed-size bit vectors.",
      "description_length": 295,
      "index": 625,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Cyclesim_float_ops.Real",
      "library": "hardcaml",
      "description": "This module provides floating-point arithmetic operations (addition, multiplication, division, etc.) and mathematical functions (trigonometric, hyperbolic, logarithmic, exponentiation, modulus) alongside signal processing utilities (ceiling, floor, absolute value) for modeling and simulating digital circuits. It operates on `Hardcaml.Signal.t` values representing floating-point signals in combinational logic simulations, enabling precise behavioral verification of hardware designs involving floating-point computations. Specific use cases include prototyping arithmetic logic units (ALUs) and signal processing pipelines where floating-point precision is required during simulation.",
      "description_length": 687,
      "index": 626,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Comb.S-Sop",
      "library": "hardcaml",
      "description": "This module implements arithmetic and comparison operations for signed bit vectors, supporting addition, subtraction, multiplication, and comparisons like less than or equal, greater than, and equality. It operates directly on `t` values, which represent bit vectors, and includes resizing to adjust vector widths with appropriate sign extension. Concrete use cases include implementing arithmetic logic units (ALUs), performing signed comparisons in control logic, and managing variable-width signed data paths in hardware designs.",
      "description_length": 532,
      "index": 627,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Enum.S_enums-Binary-Unsafe",
      "library": "hardcaml",
      "description": "This module provides low-level, unsafe binary serialization and deserialization operations for enumeration types, converting values to and from their raw binary representations. It works directly with enumerated variant types that have no arguments, using their ordinal values for encoding and decoding. Use this module when implementing custom binary protocols or interfacing with hardware where direct memory manipulation or compact binary representation is required.",
      "description_length": 469,
      "index": 628,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Interface.S_with_ast-Unsafe_assoc_by_port_name",
      "library": "hardcaml",
      "description": "This module provides unsafe operations for associating interface fields by port name using an abstract syntax tree. It works with interface types and signal structures to enable direct mapping between interface fields and their corresponding port names. Concrete use cases include low-level manipulation of hardware description components where precise port naming and signal mapping are required.",
      "description_length": 397,
      "index": 629,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Bits.Unsigned",
      "library": "hardcaml",
      "description": "This module provides operations for manipulating unsigned bit vectors, including arithmetic operations like addition, subtraction, and multiplication, as well as comparison operations such as less than, greater than, and equality. It works with the immutable bit vector type `v`, which represents fixed-width unsigned integers, and supports conversions to and from the base `Hardcaml.Bits.t` type. These operations are used to build digital circuits that perform unsigned integer arithmetic and comparisons, such as in ALUs or data path components.",
      "description_length": 548,
      "index": 630,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Flags_vector.S-Flags-Map-Provide_hash",
      "library": "hardcaml",
      "description": "This module provides a function `hash_fold_t` for computing hash values for maps with flag-based keys. It works with types that support hashing and equality, specifically structured around flag-enabled map types. Use this module to enable efficient and consistent hashing of maps where keys are derived from a fixed set of flags.",
      "description_length": 329,
      "index": 631,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Structural.Base0",
      "library": "hardcaml",
      "description": "This module provides low-level signal manipulation operations including bitwise logic, arithmetic, concatenation, and multiplexing, alongside arithmetic comparisons like signed multiplication and equality checks. It operates on structural signal types, supporting both single-bit and multi-bit vector operations with utilities for structural analysis such as width validation. These capabilities enable functional-style digital circuit construction, particularly for hardware generation tasks involving tri-state logic and hierarchical module assembly.",
      "description_length": 552,
      "index": 632,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Comb.S-Signed",
      "library": "hardcaml",
      "description": "This module provides operations for working with signed two's complement vectors, including arithmetic operations like addition, subtraction, and multiplication that automatically handle sign extension and avoid truncation by returning a result one bit wider. It supports comparison operations between signed vectors of differing widths and includes a resize function for adjusting vector width with appropriate sign extension. Concrete use cases include implementing arithmetic logic units (ALUs) and performing signed comparisons in hardware designs.",
      "description_length": 552,
      "index": 633,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Enum.S_enums-One_hot-All",
      "library": "hardcaml",
      "description": "This module provides the `all` function, which transforms a one-hot encoded interface of monadic values into a monadic one-hot encoded interface. It operates on data types involving `One_hot.t` and is used to sequence monadic actions across each field of a one-hot signal. A concrete use case includes combining multiple concurrent one-hot signals into a single synchronized result within a hardware description context.",
      "description_length": 420,
      "index": 634,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Comb.Primitives",
      "library": "hardcaml",
      "description": "This module provides low-level combinational logic operations on signals, including bitwise logic (AND, OR, XOR, NOT), arithmetic calculations (addition, subtraction, signed and unsigned multiplication), and comparison operators (equality, less-than). It operates on hardware signals represented as type `t`, enabling circuit construction through bit",
      "description_length": 350,
      "index": 635,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Logic.Std_logic",
      "library": "hardcaml",
      "description": "This module models nine-state logic values used in digital simulations, including states like uninitialized, weak, and high-impedance, and supports operations to compare, convert, and inspect these values. It defines the core `std_logic` variant type and provides functions to map, fold, and iterate over its individual states such as `'0'`, `'1'`, `'Z'`, and `'X'`, enabling precise signal resolution and state transition logic. The module includes utilities for converting logic states to integers, characters, or S-expressions, supporting interoperability with HDLs like VHDL and Verilog. These capabilities allow tasks such as modeling tri-state buses, simulating signal conflicts, and serializing signal states for analysis or communication.",
      "description_length": 746,
      "index": 636,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Scalar-module-type-Comb",
      "library": "hardcaml",
      "description": "This module provides combinational logic operations for manipulating scalar values and interfaces, including packing/unpacking signals, multiplexing, concatenation, and selection functions. It works with scalar types (`comb`) and structured interfaces (`comb t`), supporting operations like constant assignment, bit-width validation, and vector conversion. Concrete use cases include building multiplexers, priority encoders, and signal routers in digital circuit designs.",
      "description_length": 472,
      "index": 637,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Interface.Pre_partial",
      "library": "hardcaml",
      "description": "This module supports partially applying functions to interface values, enabling the creation of new interfaces by fixing some inputs. It operates on interface types, which represent groups of signals with named fields and specified widths. Use it to build reusable interface transformations or to pre-apply configuration parameters when constructing hardware modules.",
      "description_length": 367,
      "index": 638,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Flags_vector.S-Flags-Set-Diff",
      "library": "hardcaml",
      "description": "This module represents differences between sets of flags, supporting operations to create, apply, and serialize flag set diffs. It works with sets of flag elements and optional diffs, enabling precise tracking of additions and removals. Concrete use cases include managing incremental changes to hardware configurations and synchronizing state between different stages of a hardware design.",
      "description_length": 390,
      "index": 639,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Rtl.Deprecated",
      "library": "hardcaml",
      "description": "This module manages signal naming and identifier mapping during RTL generation for VHDL and Verilog outputs. It provides core operations for creating and legalizing signal names, handling unique identifiers with integer indices, and serializing them according to language-specific rules. The VHDL naming submodule legalizes names by enforcing case rules and avoiding reserved keywords, while the Verilog submodule applies escaping and prefixing to meet language constraints. Combined with identifier indexing for ordered comparisons and RTL generation functions, it enables consistent signal naming across netlist and simulation code outputs.",
      "description_length": 642,
      "index": 640,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Signal.Uop",
      "library": "hardcaml",
      "description": "This module implements arithmetic and comparison operations for hardware signals representing unsigned integer vectors. It supports addition, subtraction, multiplication, and comparisons like less than or equal, directly on `Signal.t` values, automatically handling bit-width adjustments. Use this module to build combinational logic circuits for arithmetic computations or conditional branching in hardware designs.",
      "description_length": 416,
      "index": 641,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Flags_vector.S-Flags-Unstable",
      "library": "hardcaml",
      "description": "This module implements serialization and comparison operations for a flags type, supporting binary and S-expression encoding/decoding. It works directly with the `Flags.Unstable.t` type, which represents a set of flags, typically as a polymorphic variant. Concrete use cases include persisting flag states to disk, transmitting them over a network, or comparing and validating flag configurations in system settings or configuration files.",
      "description_length": 439,
      "index": 642,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Interface.S-module-type-Comb",
      "library": "hardcaml",
      "description": "This module provides combinational logic operations for manipulating signal interfaces, including packing/unpacking vectors, multiplexing, concatenation, and selection functions. It works with `comb` types representing hardware signals and `t` as a structured interface of those signals. Use it to build complex signal routing and control logic directly in hardware descriptions, such as selecting between multiple data sources or assembling/disassembling bit vectors.",
      "description_length": 468,
      "index": 643,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Enum.S_enums-Cases",
      "library": "hardcaml",
      "description": "This module defines a concrete enumeration type with a list of all possible values, a comparison function, and S-expression conversion. It represents an enumeration as a variant type with no arguments, supporting operations to list all cases, compare values, and serialize to S-expressions. Concrete use cases include modeling fixed sets of states or commands in hardware descriptions where exhaustive case handling and serialization are required.",
      "description_length": 447,
      "index": 644,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Enum.S_enums-One_hot-module-type-Comb",
      "library": "hardcaml",
      "description": "This module provides operations for working with one-hot encoded enumeration types represented as hardware signals. It supports construction from integers, packing/unpacking to bit vectors, multiplexing, concatenation, and selection operations with priority or one-hot encoding. These functions are used to implement and manipulate encoded control signals in digital circuit design.",
      "description_length": 382,
      "index": 645,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Flags_vector.S-Of_bits",
      "library": "hardcaml",
      "description": "This module handles bit-level manipulation of structured data interfaces, providing operations to pack, unpack, concatenate, and multiplex signals. It works with fixed-width bit vectors and structured interfaces composed of these vectors, enabling precise control over signal routing and transformation. Use cases include hardware description tasks like bus multiplexing, signal concatenation, and validation of interface widths during design synthesis.",
      "description_length": 453,
      "index": 646,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Cyclesim.Traced",
      "library": "hardcaml",
      "description": "This module traces input, output, and internal signals in a cycle-accurate simulation, capturing their values over time. It works with records containing signals and their associated names, such as `io_port` and `internal_signal`, and organizes them into a structured format for analysis. Use it to inspect signal behavior during simulation, debug hardware designs, or generate waveform data for specific test scenarios.",
      "description_length": 420,
      "index": 647,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Bits.Signed",
      "library": "hardcaml",
      "description": "This module provides operations for working with signed fixed-width bit vectors, including arithmetic (addition, subtraction, multiplication) and comparison operators that handle differing widths. It supports conversions to and from standard bit vectors and includes resizing functionality to adjust bit widths with appropriate sign extension. Concrete use cases include implementing arithmetic logic units (ALUs) and performing bit-accurate signed integer computations in hardware descriptions.",
      "description_length": 495,
      "index": 648,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Hierarchy.In_scope",
      "library": "hardcaml",
      "description": "This module provides functions to create and manage hierarchical Hardcaml designs by extending the interface creation pattern with a scope argument. It works with signal and circuit data types, enabling scoped signal naming and automatic design recording in a circuit database. Concrete use cases include building modular circuits for simulation or synthesis, where hierarchical structure is required for organization or optimization purposes.",
      "description_length": 443,
      "index": 649,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Cyclesim.Combine_error",
      "library": "hardcaml",
      "description": "This module defines a data structure for representing errors that occur during cycle-accurate simulation, specifically capturing mismatches between expected and actual signal values at specific ports and times. It includes functions for converting these error records into S-expressions for logging or debugging purposes. Use this module to track and report discrepancies in hardware simulation results, such as incorrect signal transitions on clock edges.",
      "description_length": 456,
      "index": 650,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Scalar-Of_bits",
      "library": "hardcaml",
      "description": "This module handles bit-level signal manipulation in hardware descriptions, providing operations to pack, unpack, concatenate, and multiplex structured interfaces. It works with scalar bit vectors and typed records mapping fields to bit widths, enabling precise control over digital signal routing and validation. Concrete uses include constructing register files, decoding instruction fields, and implementing bus multiplexers with static width checks.",
      "description_length": 453,
      "index": 651,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Interface.S-Make_comb",
      "library": "hardcaml",
      "description": "This module implements combinational logic operations over signal interfaces, providing functions like packing/unpacking interfaces to vectors, multiplexing, concatenation, and priority/one-hot selection. It works with interface values parameterized by a combinational logic type, supporting operations that manipulate signal groups based on their declared widths. Concrete use cases include building multiplexers, constant signal generators, and dynamic signal routing logic in hardware descriptions.",
      "description_length": 501,
      "index": 652,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Interface.Ast-Ast",
      "library": "hardcaml",
      "description": "This module represents the abstract syntax tree (AST) structure of an interface, capturing how it is composed from fields, arrays, lists, and sub-modules. It provides a `t` type as a list of `Field.t` values and supports S-expression conversion via `sexp_of_t`. It is used primarily for code generation tasks, such as creating register interface specifications, when enabled in the PPX.",
      "description_length": 386,
      "index": 653,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Interface.S_with_ast-Make_comb",
      "library": "hardcaml",
      "description": "This module operates on structured signal groups defined by an interface, providing functions to pack, unpack, concatenate, and multiplex these groups. It supports operations like constant assignment, width validation, and priority/one-hot selection across lists of interfaces. Use cases include building complex signal routing logic, validating signal widths in hardware descriptions, and transforming structured data paths in digital circuits.",
      "description_length": 445,
      "index": 654,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Bits_list.Comb-Uop",
      "library": "hardcaml",
      "description": "This module performs arithmetic and comparison operations on lists of Bits representing unsigned integers. It supports addition, subtraction, multiplication, and comparisons like less than or equal, directly on bit vectors of varying widths. Operations automatically handle sign extension and resizing, making it suitable for tasks like ALU design or bit-level computations in hardware description.",
      "description_length": 398,
      "index": 655,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Interface.Empty-Of_bits",
      "library": "hardcaml",
      "description": "This module provides operations to convert, pack, and unpack interfaces of bit vectors, enabling direct manipulation of signal groups as fixed-width binary data. It supports concrete tasks like concatenating multiple interfaces, multiplexing between interface values, and validating signal widths to ensure correct hardware composition. Specific use cases include constructing register inputs from constants, routing data paths using multiplexers, and serializing interface values for testing or external interfaces.",
      "description_length": 516,
      "index": 656,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Flags_vector.Make",
      "library": "hardcaml",
      "description": "This module enables structured manipulation of hardware interfaces and signal vectors through a combination of bit-level operations, combinational logic, and tagged data handling. It supports direct operations like mapping, zipping, and bitwise manipulation alongside conversion between structured and flat representations, with key data types including tuples of signals, bit vectors, and flag-tagged interfaces. Child modules enhance this functionality by providing named field associations, port configuration utilities, bit vector construction and validation, monadic vector transformation, flag set arithmetic, low-level vector wrapping, signal wiring and naming, and register management within simulation blocks. Examples include building register interfaces from integers, multiplexing control signals based on priority or one-hot encoding, converting named port configurations to signal vectors, and combining concurrent monadic actions into structured results.",
      "description_length": 969,
      "index": 657,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Interface.Ast-Field",
      "library": "hardcaml",
      "description": "This module represents individual fields within an interface, capturing their name, type, sequence information, and documentation. It works with records containing signal or sub-module types, along with optional array/list annotations and OCaml documentation strings. It is used to define and manipulate structured hardware interfaces in Hardcaml, particularly when generating signal groups or handling hierarchical module connections.",
      "description_length": 435,
      "index": 658,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Flags_vector.S-Of_signal",
      "library": "hardcaml",
      "description": "This module provides operations for constructing and manipulating structured hardware interfaces represented as vectors of signals, including packing/unpacking, concatenation, multiplexing, and implementing selection logic like priority or one-hot encoders. It operates on signal interfaces with defined bit widths, supporting register pipelining and validation, and is used in scenarios such as building bus interfaces, pipeline stages, or signal routing logic where precise control over signal connections and naming conventions is required.",
      "description_length": 543,
      "index": 659,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Interface.Pre",
      "library": "hardcaml",
      "description": "This module defines combinators for building and transforming hardware interfaces, focusing on operations like mapping, folding, and iterating over signal groups. It works with product types representing hardware signals, enabling precise manipulation of signal widths and names. Concrete use cases include defining register interfaces, bus structures, and hierarchical module ports in digital circuit design.",
      "description_length": 409,
      "index": 660,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Interface.S_with_ast-module-type-Comb",
      "library": "hardcaml",
      "description": "This module implements combinational logic operations for signal interfaces, including packing/unpacking signals to vectors, multiplexing, concatenation, and selection from one-hot or priority-encoded inputs. It operates on interface types that define signal groups with specific widths and supports concrete operations like `mux`, `concat`, and `priority_select` for hardware description. Use cases include building complex signal routing logic, such as bus multiplexers, priority encoders, and signal aggregations in digital circuit designs.",
      "description_length": 543,
      "index": 661,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Fifo.With_interface",
      "library": "hardcaml",
      "description": "This module builds FIFO structures by combining interface-based input/output definitions with bit-level manipulation and monadic composition, enabling precise control over hardware semantics. It introduces FIFO interfaces as signal bundles and supports operations like packing, mapping, and synchronous register assignment, with modes for normal and showahead behavior. Using `create` and `classic`, you can build custom FIFOs with configurable RAM behavior or pipelined designs with extra register stages. Examples include constructing synchronized buffering pipelines, transforming FIFO signals through combinational logic, and generating hardware descriptions from structured interface definitions.",
      "description_length": 701,
      "index": 662,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Interface.S_with_ast-Of_signal",
      "library": "hardcaml",
      "description": "This module provides operations for constructing and transforming hardware interfaces composed of signal vectors with explicit bit-width annotations. It supports key manipulations like packing/unpacking, multiplexing, concatenation, and pipeline register insertion, operating on signal representations (`Of_signal.comb t` and `Of_signal.t`) that encode hardware signal groups. These capabilities are used to define, validate, and wire hierarchical hardware interfaces while applying naming conventions or structural transformations during circuit design.",
      "description_length": 554,
      "index": 663,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Enum.S_enums-Binary-Unsafe_assoc_by_port_name",
      "library": "hardcaml",
      "description": "This module provides direct conversions between enumeration-based binary interfaces and association lists indexed by field names. It operates on types involving `Binary.t` and string-keyed lists, enabling structured data mapping. Use it to serialize or deserialize binary representations of enumerations using named fields as keys.",
      "description_length": 331,
      "index": 664,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Flags_vector.S-Flags-Map-Key",
      "library": "hardcaml",
      "description": "This module defines a key type for maps that uses `Flags` values, providing serialization to and from S-expressions and a comparator for ordering. It supports operations like key comparison and sexp conversion, specifically tailored for use with `Flags`-based data. Concrete use cases include building maps where keys are flag sets, enabling efficient lookups and ordered traversals based on flag combinations.",
      "description_length": 410,
      "index": 665,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Pair",
      "library": "hardcaml",
      "description": "This module enables structured manipulation of pairs and product types for hardware description, combining mapping, zipping, and folding with bit-level composition and signal conversion. It supports key data types such as bit vectors, signals, and records, allowing tasks like combinational logic synthesis, interface aggregation, and type-safe signal decomposition. Operations include mapping functions over pairs, concatenation, multiplexing, and monadic transformations, enabling concrete use cases such as bus multiplexers, signal routing, and register pipelines. Additional utilities for port naming and dynamic record construction provide fine-grained control over interface layout and metadata during synthesis.",
      "description_length": 718,
      "index": 666,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Cyclesim_float_ops.Float",
      "library": "hardcaml",
      "description": "This module implements 32-bit floating-point arithmetic (addition, subtraction, multiplication, division, modulus, exponentiation) and mathematical operations (trigonometric, hyperbolic, logarithmic) alongside ceiling, floor, and absolute value functions. It operates on `Hardcaml.Signal.t` values, which model hardware signals in simulation contexts. Designed for hardware components requiring precise floating-point computation, such as digital signal processors or numerical accelerators, it enables cycle-accurate simulation of floating-point data paths using combinational logic.",
      "description_length": 584,
      "index": 667,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Logic.Std_logic-Variants",
      "library": "hardcaml",
      "description": "This module defines a set of standard logic values such as `u`, `x`, `l0`, `l1`, `z`, and others, each representing distinct states in digital simulation. It provides operations like `fold`, `iter`, `map`, and `make_matcher` to process these logic values, enabling precise control over state transitions and pattern matching. These functions are used in digital circuit simulation and verification to handle signal states and evaluate logic behavior.",
      "description_length": 450,
      "index": 668,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Cyclesim.Port_list",
      "library": "hardcaml",
      "description": "Handles lists of named ports in a cycle-accurate simulation environment, providing operations to access and manipulate port values as mutable references. Works with strings for port names and `Bits.t` references for port values. Used to manage input and output port states during simulation steps, enabling dynamic updates and value tracking.",
      "description_length": 342,
      "index": 669,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Types.Scalar-Names_and_widths",
      "library": "hardcaml",
      "description": "This module defines a list of port names paired with their bit widths, along with separate lists for port names and widths. It provides direct access to these lists and a list of tags associated with scalar types. Concrete use cases include inspecting signal interfaces for simulation, generating documentation, or validating hardware descriptions against expected port configurations.",
      "description_length": 385,
      "index": 670,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Bits_list.Comb-module-type-Typed_math",
      "library": "hardcaml",
      "description": "This module implements arithmetic and comparison operations for fixed-width bit vectors represented as lists of bits. It supports addition, subtraction, multiplication, and comparisons (less than, greater than, equal, etc.), with automatic sign extension for operands of different widths. The operations produce results in the same bit-vector format, with resizing capabilities to adjust widths explicitly.",
      "description_length": 406,
      "index": 671,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Circuit.Config",
      "library": "hardcaml",
      "description": "This module defines configuration options for circuit construction, controlling combinational loop detection, UID normalization, port validation, and output signal modification. It works with hardware circuits composed of signals and interfaces, allowing customization of circuit behavior during synthesis or simulation. Use this to enable strict port checking, normalize signal identifiers for consistent output, or modify circuit outputs before finalization.",
      "description_length": 460,
      "index": 672,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Bits_list.X",
      "library": "hardcaml",
      "description": "This module represents ternary logic values (false, true, undefined) and supports logical operations such as AND, OR, XOR, and NOT. It works directly with the custom `t` type that encodes these three states. Use this module when modeling digital circuits with unknown or uninitialized signal states, particularly during simulation or synthesis where handling undefined behavior is required.",
      "description_length": 390,
      "index": 673,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Bits.Typed_math",
      "library": "hardcaml",
      "description": "This module provides arithmetic and comparison operations for fixed-width bit vectors, including addition, subtraction, multiplication, and comparisons like less than or equal. It operates on the `v` type, representing bit vectors, and supports resizing and width-aware operations. Use cases include hardware description and simulation tasks requiring precise bit-level manipulation and integer interpretations.",
      "description_length": 411,
      "index": 674,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Enum.S_enums-One_hot-Of_signal",
      "library": "hardcaml",
      "description": "This module provides operations for manipulating one-hot encoded hardware signals, including packing/unpacking, multiplexing, priority selection, register creation, and conversion from enumeration values. It operates on `One_hot.Of_signal.t` values\u2014representing one-hot encoded bit vectors\u2014and standard signal types, enabling use cases like state machine design, control logic implementation, and priority-encoded signal routing in digital circuits.",
      "description_length": 449,
      "index": 675,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Interface.Empty-Names_and_widths",
      "library": "hardcaml",
      "description": "This module defines the structure and operations for handling signal interfaces with named ports and specified bit widths. It provides access to port names, widths, and associated tags as lists, enabling direct manipulation and inspection of hardware signal groups. Use it to define and work with hardware module interfaces where explicit signal naming and sizing are required.",
      "description_length": 377,
      "index": 676,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Interface.Empty-All",
      "library": "hardcaml",
      "description": "Combines monadic values within an interface structure, lifting the monad outside the interface. Works with polymorphic interface types where each field is wrapped in a monad. Useful for aggregating results from multiple signal computations into a single monadic interface.",
      "description_length": 272,
      "index": 677,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Signal.Sop",
      "library": "hardcaml",
      "description": "This module implements arithmetic and comparison operations for signed vectors, supporting addition, subtraction, multiplication, and comparisons like less than or equal, greater than, and equality. It operates directly on `Hardcaml.Signal.t`, handling width mismatches by appropriate sign extension and ensuring results avoid truncation by increasing bit width when necessary. Use cases include building arithmetic logic units (ALUs), implementing control logic with signed comparisons, and constructing datapaths that require precise signed vector manipulation.",
      "description_length": 563,
      "index": 678,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Vcd.Var",
      "library": "hardcaml",
      "description": "This module manages variable declarations in VCD files, mapping names to unique identifiers and defining their types, widths, and output behavior. It supports creating, inspecting, and serializing variables, along with writing value changes in formats like bits, strings, or four-state vectors, enabling tracking of signal changes in digital simulations and generating waveform dumps. The child modules handle generation of unique string identifiers for signals and define supported variable types such as `Wire`, `Reg`, `Integer`, and `Real`, which map directly to VCD format codes. Together, they provide a complete interface for declaring, manipulating, and dumping typed variables with unique identifiers in VCD output.",
      "description_length": 723,
      "index": 679,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Fifo.Kinded_fifo",
      "library": "hardcaml",
      "description": "This module implements synchronous FIFOs with support for both classic and showahead modes, providing distinct interfaces for writing and reading operations. It works with signals and tagged types to manage data flow, capacity, and clock domains. Concrete use cases include buffering data between clock domains or pipeline stages in hardware designs.",
      "description_length": 350,
      "index": 680,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Enum.S_enum-All",
      "library": "hardcaml",
      "description": "Lifts monadic values from within an interface structure to the outer monad, combining them into a single result. Works with polymorphic interface types parameterized by a monad. Useful for aggregating results from multiple monadic computations structured within an interface.",
      "description_length": 275,
      "index": 681,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Enum.S_enums-One_hot-Unsafe_assoc_by_port_name",
      "library": "hardcaml",
      "description": "This module directly maps enumeration values to and from association lists, where each field name corresponds to a value in a one-hot encoded interface. It operates on `One_hot.t` types, which represent enumeration variants as hardware signals. Use this module to convert between one-hot encoded hardware interfaces and string-indexed data structures for configuration or dynamic lookup.",
      "description_length": 387,
      "index": 682,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Interface.S-Of_signal",
      "library": "hardcaml",
      "description": "This module provides operations for transforming and connecting hardware signal interfaces through packing/unpacking, muxing, concatenation, and pipeline creation, alongside utilities for assigning hierarchical names with prefixes/suffixes and validating signal connections. It operates on structured groups of signals represented by `Of_signal.t` and `Of_signal.comb t`, which model hardware interfaces with combinational or registered behavior. These capabilities are used to construct complex digital circuits, enforce naming conventions in hierarchical designs, and manage signal routing with type-safe transformations.",
      "description_length": 623,
      "index": 683,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Circuit.With_interface",
      "library": "hardcaml",
      "description": "This module creates hardware circuits from input and output interface definitions, automatically labeling ports based on those interfaces. It directly works with `Hardcaml.Interface.Create_fn(I)(O).t` as the circuit definition and produces `Hardcaml.Circuit.t` values. It is used to construct circuits with well-defined input and output ports, ensuring correct signal mapping and clear port names in generated hardware descriptions.",
      "description_length": 432,
      "index": 684,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Interface.S-Of_bits",
      "library": "hardcaml",
      "description": "This module handles bit-level signal manipulation for hardware description, providing operations like packing/unpacking interfaces to/from bit vectors, multiplexing, concatenation, and validation of signal widths. It works with fixed-width bit vectors and structured interfaces composed of named fields. Concrete uses include constructing and validating hardware components from integers, combining multiple signal groups, and implementing selection logic in digital circuits.",
      "description_length": 476,
      "index": 685,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Assertions.Always",
      "library": "hardcaml",
      "description": "This module adds assertions to Hardcaml simulations by integrating them into always blocks. It works with simulation scopes, string identifiers, and signal values to define and track assertion conditions. Use it to embed runtime checks directly in hardware simulation logic, ensuring signal behaviors meet expected constraints during simulation steps.",
      "description_length": 351,
      "index": 686,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Bits_list.Comb",
      "library": "hardcaml",
      "description": "This module provides combinational logic operations for bit vector manipulation, including bitwise operations, arithmetic, comparisons, and conversions between integers, strings, and structured bit representations. It operates on a variable-width `t` type encoded as a list of bits, supporting both signed and unsigned interpretations, with utilities for resizing, shifting, and endianness control. Specific applications include hardware circuit design, bit-level protocol implementation, and digital signal processing tasks requiring precise control over binary data and logical reductions.",
      "description_length": 591,
      "index": 687,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Flags_vector.S-Flags-Map-Diff",
      "library": "hardcaml",
      "description": "This module handles serialization and manipulation of flag-based differences in map structures. It provides functions to convert between S-expressions and difference types, extract specific differences, apply changes to base values, and construct composite differences from lists. Use cases include tracking and applying incremental changes to sets of named flags in configuration or state management systems.",
      "description_length": 409,
      "index": 688,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Instantiation.Expert",
      "library": "hardcaml",
      "description": "Handles low-level instantiation of sub-modules in generated RTL, specifically for integrating non-Hardcaml modules. Works directly with module names and ports, validating and mapping them during instantiation. Useful when embedding external RTL components or black boxes into a Hardcaml design.",
      "description_length": 294,
      "index": 689,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Interface.S_with_ast-All",
      "library": "hardcaml",
      "description": "This module combines and lifts monadic values within an interface structure, transforming a nested monad-inside-interface into an interface-inside-monad. It operates on signal groups defined by interface types, where each field is wrapped in a monad. Use it to sequence operations across all signals in an interface, such as collecting results after running simulations or propagating effects through a set of connected signals.",
      "description_length": 428,
      "index": 690,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Constant.Raw",
      "library": "hardcaml",
      "description": "This module converts constants to and from raw bit patterns stored in strings and byte buffers. It supports padding and resizing during conversion, ensuring data compatibility with external representations. Use it when interfacing with low-level data formats or hardware descriptions requiring precise bit-level control.",
      "description_length": 320,
      "index": 691,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Property_manager",
      "library": "hardcaml",
      "description": "Manages the creation and tracking of LTL (Linear Temporal Logic) properties in hardware designs. It stores named LTL properties and provides access to the underlying atomic propositions as signals. Used to define and organize formal verification properties for signal behaviors in digital circuits.",
      "description_length": 298,
      "index": 692,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Rtl",
      "library": "hardcaml",
      "description": "This module translates hardware circuits described in a domain-specific language into Verilog or VHDL, supporting top-level circuits and recursive sub-circuit instantiation with configurable output modes. It provides core data types like `Rtl_ast.t` for representing hardware constructs and `Uid.t` for unique signal identification, along with operations for signal name mangling, digest computation, and language-specific code generation. You can generate synthesizable HDL code, track circuit transformations via digests, manage signal naming through indexed identifiers, and direct output to files, buffers, or directories. Submodules handle blackbox configuration, identifier legalization, and language-specific formatting, enabling precise control over synthesis and simulation workflows.",
      "description_length": 793,
      "index": 693,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Enum",
      "library": "hardcaml",
      "description": "This module provides functors for creating interface modules that represent enumeration types using binary or one-hot encoded signals, enabling precise control over hardware interface design for state machines and control logic. It includes operations for encoding and decoding enums to bit vectors, multiplexing signals, performing case analysis, and validating signal widths, with support for both combinational and sequential logic through modules handling `comb`, `Signal.t`, and register types. Child modules extend this functionality with specialized tools for one-hot encoding, binary packing, interface serialization, and structured signal manipulation, enabling tasks like instruction decoding, state transition modeling, and signal routing with explicit bit-level control. Examples include synthesizing control paths, building multiplexers, validating signal encodings, and mapping enum variants to register fields or configuration values.",
      "description_length": 949,
      "index": 694,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Vcd",
      "library": "hardcaml",
      "description": "This module generates VCD files for digital circuit simulations by managing time stamps, signal changes, and hierarchical scopes. It provides core functions to write VCD headers, track simulation time, declare variables with unique identifiers, and output value changes, working with submodules that handle time units, configuration headers, hierarchical scopes, and variable declarations. You can define simulation time scales in units like nanoseconds, set up hierarchical signal groups using scopes like `Module` or `Task`, declare variables of types `Wire` or `Reg`, and write timestamped value changes in bit or vector formats. These features combine to produce structured VCD output compatible with waveform viewers, capturing and visualizing signal behavior over time.",
      "description_length": 775,
      "index": 695,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Comb",
      "library": "hardcaml",
      "description": "This module provides combinational logic operations for manipulating bit vectors as hardware signals, supporting both signed and unsigned arithmetic, bitwise logic, comparisons, and signal transformations like concatenation, selection, and multiplexing. It works directly with signal types (`t` and `v`) to enable precise control over bit-level behavior, including sign-aware operations, width adjustments, and dataflow management through valid signals. Concrete capabilities include building arithmetic logic units (ALUs) with signed or unsigned addition, implementing control logic with comparison-based decisions, and constructing data path components like counters or encoders using low-level primitives such as AND, OR, XOR, bit slicing, and constant creation. Submodules extend this functionality with dedicated support for fixed-width arithmetic, signed vector operations, and width-aware comparisons, enabling modeling of complex digital circuits with strict control over type conversions and bit-level representations.",
      "description_length": 1027,
      "index": 696,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Architecture",
      "library": "hardcaml",
      "description": "This module defines a type `t` representing hardware architecture configurations with three variants: `Small`, `Balanced`, and `Fast`. It provides functions to convert between string representations and the `t` type, along with S-expression serialization. Use this module to specify and serialize architecture trade-offs in hardware design workflows.",
      "description_length": 350,
      "index": 697,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.With_valid",
      "library": "hardcaml",
      "description": "This module manipulates data structures paired with validity bits, supporting transformations, combinations, and conversions while preserving validity semantics across structured data like vectors and tuples. It enables element-wise operations, signal processing, and bit-level interface manipulation through tagged vectors and port lists, with key operations like `map`, `zip`, and `to_list`. Users can build multiplexers, pipeline stages, AXI streams, and register layouts using combinators, always-block assignments, and structured wiring. Submodules provide bit vector validation, monadic sequencing, interface serialization, and metadata-driven design, supporting tasks like decoding instruction fields, validating signal widths, and dynamically constructing interfaces from named values.",
      "description_length": 793,
      "index": 698,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Signal",
      "library": "hardcaml",
      "description": "This module provides a rich set of operations for constructing and manipulating bitvector signals in hardware designs, supporting both combinational and sequential logic. It centers around a polymorphic signal type that encodes bitvector widths, signedness, and structural relationships, enabling precise control over simulation behavior and netlist generation. Arithmetic, logical, and bit-level operations are available for both signed and unsigned vectors, including addition, multiplication, comparison, concatenation, slicing, and shifting, with automatic width and sign extension. Use it to implement arithmetic units, control logic, FIFOs, and synthesizable Verilog for FPGA/ASIC flows, with support for introspection, dependency tracking, and structural analysis through UID-based identifiers and mapping structures.",
      "description_length": 824,
      "index": 699,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Design_rule_checks",
      "library": "hardcaml",
      "description": "Verifies that all sequential elements in a circuit use only specified clock pins. Works with `Circuit.t` and string lists, ensuring clock inputs match expected names. Useful for enforcing clock domain constraints in hardware designs.",
      "description_length": 233,
      "index": 700,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Ram",
      "library": "hardcaml",
      "description": "This module models random access memory with configurable read and write ports, enabling precise control over memory size, port attributes, and collision handling during RTL synthesis. It supports operations to define and manipulate memory configurations, including collision resolution modes such as `Read_before_write` and `Write_before_read`, which determine behavior during simultaneous access. The module provides utilities to compare, sort, and clamp these modes, facilitating consistent configuration and analysis of memory behavior in hardware designs. With signal arrays and port configurations, it allows modeling complex memory interactions and synthesizing efficient RAM blocks.",
      "description_length": 690,
      "index": 701,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "Hardcaml.Bits_list",
      "library": "hardcaml",
      "description": "This module represents fixed-width bit vectors as lists of `Bit.t` values, enabling direct construction and evaluation of combinational logic circuits through a rich set of bitwise and arithmetic operations. It supports both signed and unsigned interpretations with automatic sign or zero extension, and provides conversions to and from integers, booleans, and strings, along with bit-level transformations such as shifting, masking, and resizing. Submodules refine this functionality to handle signed and unsigned arithmetic separately, implement comparison logic, and manage width adjustments explicitly, making it suitable for modeling ALUs, multiplexers, and data path components. Examples include simulating gate-level circuits, performing fixed-point arithmetic, and constructing testbenches with precise control over signal behavior.",
      "description_length": 840,
      "index": 702,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Combinational_ops_database",
      "library": "hardcaml",
      "description": "This module manages a collection of custom combinational operations for use with Cyclesim-based simulators. It supports inserting operations, looking them up by name, folding over or iterating through the stored operations, and combining multiple databases into one. Use cases include extending simulation environments with user-defined logic operations and organizing reusable combinational logic definitions.",
      "description_length": 410,
      "index": 703,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Side",
      "library": "hardcaml",
      "description": "Represents temporal phases for scheduling operations relative to clock edges in hardware descriptions. It provides comparison and S-expression conversion functions for the `Before` and `After` values. Used to define precise timing behavior in synchronous circuits, such as specifying when register updates or combinational logic should occur relative to a clock signal.",
      "description_length": 369,
      "index": 704,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Read_port",
      "library": "hardcaml",
      "description": "This module represents a memory read port with operations to map, iterate, and combine values. It works with polymorphic data types through a record-like structure that holds read port information. Concrete use cases include defining and transforming memory read interfaces in hardware descriptions, such as extracting port names or applying functions to read port values.",
      "description_length": 372,
      "index": 705,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Parameter",
      "library": "hardcaml",
      "description": "This module manages named configuration parameters for RTL designs, combining core operations for creating, comparing, and querying parameters with a rich child module for handling structured parameter values. The main data types include `t` for parameter records with named accessors and a polymorphic type in the child module for values like integers, strings, and bit vectors with safe extraction and serialization. Operations allow extracting specific values, validating consistency across components, and sorting parameters for deterministic output in synthesis. Together, they support tasks like parsing design configurations, ensuring type-safe value manipulation, and generating S-expressions for interoperability.",
      "description_length": 722,
      "index": 706,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "Hardcaml.Types",
      "library": "hardcaml",
      "description": "This module forms the foundation for hardware description in OCaml, defining core data types for signals, ports, and clock domains, along with structured interfaces for managing signal validity, width, and naming. It supports operations like signal packing, multiplexing, and combinational logic synthesis, with direct functions for unsafe value wrapping, monadic lifting, and port-based interface construction. Child modules extend these capabilities with bit vector manipulation, always block integration, polymorphic array transformations, and clock domain control, enabling concrete tasks like building register pipelines, priority multiplexers, and structured RTL components. Together, the module and its submodules provide a comprehensive system for modeling, transforming, and validating digital circuits with precise type and structure guarantees.",
      "description_length": 855,
      "index": 707,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Caller_id",
      "library": "hardcaml",
      "description": "This module tracks signal creation sites by embedding optional callstack information directly into signals, helping to debug issues like dangling wires by showing where signals were constructed rather than where the error was detected. It supports three tracing modes\u2014disabled, top-frame, and full-trace\u2014controlled via a mode type, with the ability to convert callstack data to S-expressions for detailed error reporting. You can enable tracing globally through the HARDCAML_DEBUG environment variable or manage the caller ID context directly to capture specific construction points during simulation or compilation. Submodules allow fine-grained control over tracing depth, letting you capture just the origin or a full stack trace for complex circuit debugging.",
      "description_length": 763,
      "index": 708,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Build_mode",
      "library": "hardcaml",
      "description": "This module defines a type `t` with two variants, `Simulation` and `Synthesis`, used to configure hardware behavior. It provides functions for comparison, equality checks, conversion to s-expressions, and parsing from strings. This module is used to distinguish between simulation and synthesis contexts in hardware design flows.",
      "description_length": 329,
      "index": 709,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Structural",
      "library": "hardcaml",
      "description": "This module enables hardware generation with tri-state logic, offering structural synthesis capabilities for HDL creation. It provides signal manipulation operations like concatenation, selection, and multiplexing, working with inputs, outputs, wires, and module instantiations represented in a circuit state database. Use it to describe sequential logic elements like clocked registers with enable, reset, and clear inputs, or to model tri-state bus behavior in structural hardware descriptions. It supports hierarchical design through structured interfaces and instantiation, with low-level operations for arithmetic, bitwise logic, and signal transformations, enabling tasks like building arithmetic logic units, control logic, or custom accelerators with precise data path control.",
      "description_length": 785,
      "index": 710,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Mangler",
      "library": "hardcaml",
      "description": "This module maps identifiers to unique mangled names, ensuring uniqueness within a collection of strings. It supports operations to add identifiers, check for duplicates, and retrieve mangled names. Useful when generating unique signal names in hardware description workflows.",
      "description_length": 276,
      "index": 711,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Hierarchy",
      "library": "hardcaml",
      "description": "This module enables structured construction of hierarchical Hardcaml circuits by composing nested modules with explicit input and output interfaces. It operates on `Circuit.t`, `Scope.t`, and interface types, supporting instantiation of sub-circuits and scoped signal naming for clear, modular design. Functions like `create` allow building complex digital systems such as CPUs or communication blocks by organizing components into reusable, hierarchical modules. It integrates with submodules that extend interface creation with scoping and support automatic design recording for simulation or synthesis workflows.",
      "description_length": 615,
      "index": 712,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Dedup",
      "library": "hardcaml",
      "description": "Transforms a circuit by identifying and merging combinatorial nodes that perform identical computations, reducing redundancy. Works directly with `Hardcaml.Circuit.t` structures. Useful when optimizing synthesized circuits for area by eliminating duplicate logic gates.",
      "description_length": 269,
      "index": 713,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Level",
      "library": "hardcaml",
      "description": "Represents digital signal levels with values `High` and `Low`. Provides conversion to integers, equality checking, and S-expression serialization. Useful for hardware simulation and testing where binary signal states need to be explicitly modeled and compared.",
      "description_length": 260,
      "index": 714,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Signal_graph",
      "library": "hardcaml",
      "description": "The module constructs and analyzes directed acyclic graphs of digital circuit signals, starting from output signals and tracing backward to identify inputs and structural dependencies. It supports depth-first traversal, topological sorting, combinational loop detection, and fan-in/fan-out analysis, enabling circuit validation, simulation scheduling, and structural optimization. Submodules provide ordered processing of signal dependencies, including `fold`, `map`, and `iter` operations for transformations and analysis, while another handles simulation scheduling by breaking loops at sequential elements and determining evaluation order. Specific uses include extracting signal propagation paths, generating ordered signal lists for simulation, and validating RTL designs for combinational loops.",
      "description_length": 801,
      "index": 715,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Signedness",
      "library": "hardcaml",
      "description": "Represents and converts signedness annotations for hardware signals. Supports serialization to S-expressions for configuration or debugging purposes. Used when defining arithmetic operations or interfaces that require explicit signedness handling, such as signal width conversions or comparison logic.",
      "description_length": 301,
      "index": 716,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Constant",
      "library": "hardcaml",
      "description": "This module handles the creation, manipulation, and conversion of fixed-width constants used in hardware descriptions. It supports operations on bit-level representations through `Bit.t` lists, integers, and raw byte strings, enabling precise control over constant values in digital circuits. Main data types include `t` for multi-bit constants, `Bit.t` for single bits, and integer-based representations for low-level manipulation. Examples include converting between bit lists and constants, performing bitwise arithmetic, defining logic high/low signals, and serializing constants to byte buffers for external interfaces.",
      "description_length": 624,
      "index": 717,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Scope",
      "library": "hardcaml",
      "description": "This module coordinates hierarchical circuit generation by managing scopes, which track instantiated modules and control signal naming through hierarchical paths and configurable naming strategies. It supports operations to create and manipulate scopes, generate hierarchical signal names, and attach LTL properties with scoped identifiers. The main data types\u2014`t`, `Path.t`, and `Naming_scheme.t`\u2014enable use cases such as building structured designs with controlled naming, inlining modules, and ensuring signal uniqueness across hierarchies. Submodules refine naming behavior and path manipulation, supporting tasks like flattening identifiers for synthesis or navigating hierarchical designs.",
      "description_length": 695,
      "index": 718,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Cyclesim",
      "library": "hardcaml",
      "description": "This module orchestrates cycle-accurate simulation of digital circuits, managing clock transitions, reset sequences, and signal propagation across registers, memories, and combinatorial logic. It provides core data types such as `Bits`, `Signal`, and `Int64` for representing and manipulating signal values, along with structured interfaces for inputs, outputs, and internal nodes. Users can simulate register updates on clock edges, trace signal transitions over time, and validate expected behavior against actual results using precise introspection and error reporting tools. Submodules enable memory initialization, register access, signal tracing, and configuration tuning, supporting tasks like waveform generation, testbench execution, and verification of complex state transitions.",
      "description_length": 789,
      "index": 719,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Circuit_utilization",
      "library": "hardcaml",
      "description": "Tracks and summarizes circuit resource usage, including gates, arithmetic components, multiplexers, and memories, by aggregating bit counts and identifying critical dimensions like largest node sizes. It organizes utilization data into structured groups for detailed yet concise reporting. Useful for analyzing hardware complexity and guiding optimization efforts in digital design workflows.",
      "description_length": 392,
      "index": 720,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Circuit",
      "library": "hardcaml",
      "description": "This module enables the creation, analysis, and transformation of hardware circuits by managing structural manipulation, signal relationships, and RTL generation. It centers around the `t` type representing circuits, along with supporting constructs like signal maps, instantiations, and configuration settings, allowing tasks such as optimization, signal integrity verification, and synthesis from functional interfaces. Submodules handle key aspects: one tracks signal mappings and supports serialization for debugging, another validates port consistency between interfaces, a third configures circuit behavior during construction, and a fourth synthesizes circuits directly from interface definitions. Together, they provide a streamlined flow from circuit definition and validation to customizable synthesis and analysis.",
      "description_length": 825,
      "index": 721,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Wave_format",
      "library": "hardcaml",
      "description": "This module defines how to format and display signal values in waveforms, supporting binary, hexadecimal, integer, and custom representations. It operates on `Bits.t` values, with variants like `Bit`, `Hex`, and `Custom` enabling precise control over visualization. Use it to specify how signals should be rendered in waveform viewers, such as displaying control signals as bit lines or memory contents as hex values.",
      "description_length": 417,
      "index": 722,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Combinational_op",
      "library": "hardcaml",
      "description": "This module defines custom combinational operations using mutable bit vectors, allowing users to implement and integrate arbitrary logic functions into a simulation. It supports operations that transform lists of input signals into output signals, with functions to create, name, and instantiate these operations within a design. Concrete use cases include implementing arithmetic units, encoders, or custom logic blocks that map directly to hardware primitives.",
      "description_length": 462,
      "index": 723,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Logic",
      "library": "hardcaml",
      "description": "This module provides types and operations for modeling digital logic and bit vectors with precise signal behavior, supporting both two-state and multi-state logic systems. It includes core data types like `std_logic`, `std_logic_vector`, and `v`, along with operations for bitwise manipulation, arithmetic, comparison, conversion, and signal state inspection. Submodules extend this with utilities for mapping, folding, and iterating over logic states, handling signed and unsigned arithmetic with automatic width extension, and modeling complex signal behaviors like tri-state and nine-state logic. Examples include simulating register transfers, implementing ALUs with exact bit-level semantics, resolving signal conflicts on buses, and converting logic values for HDL interoperability.",
      "description_length": 788,
      "index": 724,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Cyclesim_float_ops",
      "library": "hardcaml",
      "description": "This module provides floating-point arithmetic operations for simulation environments, supporting both single-precision and double-precision computations using `Hardcaml.Signal.t` values. It includes combinational logic for addition, multiplication, division, modulus, and advanced functions like logarithms, exponentials, and trigonometric operations, enabling accurate modeling of hardware components such as ALUs and DSP pipelines. Submodules focus on 32-bit and 64-bit floating-point operations, offering signal processing utilities like ceiling, floor, and absolute value for cycle-accurate simulation of numerical accelerators and digital circuits. Examples include simulating arithmetic logic units, verifying signal processing pipelines, and modeling hardware with precise floating-point behavior.",
      "description_length": 805,
      "index": 725,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Edge",
      "library": "hardcaml",
      "description": "Represents and manipulates signal edges, specifically rising or falling transitions, typically used for clock signals. Provides conversion to S-expressions, equality checks, and integer representation. Useful in hardware description for specifying clock edge behavior in synchronous logic circuits.",
      "description_length": 298,
      "index": 726,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Hardcaml.Reg_spec",
      "library": "hardcaml",
      "description": "This module defines specifications for hardware registers, including clock, reset, clear, and enable signals with associated edges and levels. It provides operations to create and modify register configurations, set default values, and access individual signal components. Use cases include defining synchronous register behavior in digital circuits, such as configuring clock edges, reset conditions, and clear signals for FPGA or ASIC design.",
      "description_length": 444,
      "index": 727,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Reserved_words",
      "library": "hardcaml",
      "description": "This module provides direct access to lists of reserved keywords for Verilog, VHDL, and OCaml languages. It includes separate values for each language, allowing checks or filtering against reserved terms. Useful for code generation or parsing tasks where language-specific keyword conflicts must be avoided.",
      "description_length": 307,
      "index": 728,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Parameter_name",
      "library": "hardcaml",
      "description": "This module represents parameter names used in RTL modules, providing operations to create, compare, and convert them to and from strings and S-expressions. It supports use cases like tracking and serializing module parameter names during hardware compilation or debugging. Key functions include `of_string`, `to_string`, `compare`, and S-expression conversion for persistence and inspection.",
      "description_length": 392,
      "index": 729,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Property",
      "library": "hardcaml",
      "description": "This module represents and manipulates logical propositions over digital signals using the `atomic_proposition` type, which corresponds to hardware signals, and supports formal verification tasks through its submodules for Linear Temporal Logic (LTL) and Computation Tree Logic (CTL). The LTL submodule constructs and transforms path-based formulas with boolean and temporal operators like next, until, and globally, enabling simplification and constraint extraction for hardware verification. The CTL submodule defines state and path formulas with path quantifiers and temporal operators, supporting formula inspection, manipulation, and string conversion. Together, they allow specifying and verifying complex temporal properties of hardware designs, such as signal stability and sequence correctness over time.",
      "description_length": 813,
      "index": 730,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Circuit_database",
      "library": "hardcaml",
      "description": "This module manages a collection of Hardcaml circuits, indexed by unique names, enabling structural deduplication and efficient instantiation mapping. It supports inserting circuits with optional sharing, looking up circuits by name, and retrieving all stored circuits. It is used to build RTL module hierarchies by tracking and reusing equivalent circuit implementations.",
      "description_length": 372,
      "index": 731,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Write_port",
      "library": "hardcaml",
      "description": "This module represents a memory write port with operations to map, iterate, and combine values. It works with write ports containing arbitrary data types, supporting transformations and side effects. Concrete use cases include defining memory write behavior in hardware descriptions and integrating with interface specifications for signal updates.",
      "description_length": 348,
      "index": 732,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Rtl_attribute",
      "library": "hardcaml",
      "description": "This module defines attributes for annotating RTL signals and modules, primarily used to control synthesis behavior in tools like Xilinx Vivado. It supports creating and comparing attributes with optional string values, and provides access to attribute names and values. The Xilinx-specific submodule allows applying synthesis directives such as `async_reg` for register pipelining, `fsm_encoding` for state machine optimization, and `mark_debug` for visibility during debugging. Additionally, a polymorphic value type enables representing attribute data as integers, strings, or booleans, with support for equality checks and S-expression serialization.",
      "description_length": 654,
      "index": 733,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Always",
      "library": "hardcaml",
      "description": "This module provides a DSL for describing digital circuits using imperative-style blocks, similar to Verilog always blocks, with support for if, elif, else, switch, and assignment operations. It works with signals and variables to model sequential and combinational logic, enabling the definition of state machines and register transfers, such as CPU control logic or peripheral controllers. Child modules enhance this capability by offering state machine construction with configurable transitions and encodings like Binary, Gray, and Onehot, along with variables for modeling combinational wires and synchronous registers, including pipelines and registers with enable signals. Together, they support precise control over logic design, from high-level state definitions to low-level signal manipulation.",
      "description_length": 805,
      "index": 734,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Interface",
      "library": "hardcaml",
      "description": "This module provides structures and operations for defining and manipulating hardware signal interfaces with named ports and specified bit widths. It supports grouped signal operations like packing, unpacking, multiplexing, and concatenation, and integrates with ppx_hardcaml for deriving interface types from records. Concrete use cases include defining module I/O, transforming signal groups, and constructing hierarchical digital circuits with precise signal naming and structural control. Submodules extend this functionality with typed signal sequences, combinational logic, AST manipulation, and serialization capabilities, enabling tasks such as building multiplexers, register files, and control logic units, or converting interfaces to and from association lists for dynamic construction and inspection.",
      "description_length": 812,
      "index": 735,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Flags_vector",
      "library": "hardcaml",
      "description": "This module manages bit-level state with atomic flag operations and structured hardware interfaces, combining atomic bit manipulation with signal routing and serialization. It provides a flag vector type supporting set, clear, and toggle operations alongside submodules for interface construction, bitvector manipulation, flag set arithmetic, and binary/S-expression serialization. You can build register interfaces with enable controls, define port configurations with named signals, compare and serialize flag states, and route signals using multiplexers or priority encoders. Additional capabilities include hashing flag sets, tracking incremental flag changes, and lifting monadic operations over vectors for concurrent hardware modeling.",
      "description_length": 742,
      "index": 736,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Async_fifo",
      "library": "hardcaml",
      "description": "This module implements a parameterizable asynchronous FIFO using distributed RAM, enabling high-speed buffering across independent clock domains without block RAM. It provides push and pop operations alongside full and empty status flags, supporting configurable data width, depth (up to 2^LUT_SIZE), and synchronization stages for glitch-free addressing. Child modules enhance this core with hierarchical instantiation, signal mapping, and combinational logic for register management, bit vector conversion, and dynamic configuration. Use cases include cross-clock data transfer in communication bridges, pipeline buffering, and FPGA designs requiring precise timing and resource control.",
      "description_length": 689,
      "index": 737,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml.Fifo",
      "library": "hardcaml",
      "description": "This module orchestrates the creation, transformation, and inspection of synchronous FIFO structures with support for showahead behavior, pipelining, and configurable data widths. It enables functional composition across FIFOs through mapping, zipping, and monadic sequencing, while preserving metadata such as port names and signal widths, and allows conversion to and from association lists for integration with external systems. Submodules handle low-level signal manipulation within `Always` blocks, combinational logic for multiplexing and selection, bit-vector representations for hardware serialization, and configuration of FIFO parameters like capacity and showahead mode. Use it to build hierarchical data paths, manage synchronized buffering across clock domains, or generate structured hardware descriptions with named signal interfaces and validated bit widths.",
      "description_length": 874,
      "index": 738,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Instantiation",
      "library": "hardcaml",
      "description": "This module enables the integration of non-Hardcaml components into generated RTL designs by mapping inputs and outputs by name, supporting parameterized modules and synthesis attributes. It provides data types for defining module instantiations with explicit interfaces, configurable instance names, and library mappings. Operations include validating port connections, applying synthesis directives, and embedding external IP blocks or black boxes into a design. Specific uses include instantiating generated RTL blocks with customizable parameters and integrating third-party modules through low-level port mapping.",
      "description_length": 618,
      "index": 739,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Assertions",
      "library": "hardcaml",
      "description": "This module enables runtime assertions in digital circuit simulations, allowing designers to monitor signal conditions and detect violations during execution. It provides functions to enable assertion tracing, capture results, and integrate with simulation tools for debugging, using scopes and simulation configurations to control assertion behavior. The result module distinguishes between violated and non-violated states, using integer lists to capture violation positions for precise debugging. The assertion module integrates checks directly into simulation logic, using always blocks and string identifiers to define conditions on signal values and ensure correct circuit behavior during simulation steps.",
      "description_length": 712,
      "index": 740,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Wave_data",
      "library": "hardcaml",
      "description": "This module represents and manipulates fixed-width, fixed-length waveforms as collections of bit vectors. It supports creating, initializing, and accessing waveform samples, with direct mutation capabilities and byte-level data transfer. Typical uses include simulation data storage, waveform visualization, and testbench generation where precise bit-level control and efficient data access are required.",
      "description_length": 404,
      "index": 741,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml.Bits",
      "library": "hardcaml",
      "description": "This module represents fixed-width immutable bit sequences that support precise integer interpretations and bit-level manipulation. It provides core operations for slicing, shifting, resizing, and performing bitwise and arithmetic computations, with support for both signed and unsigned semantics. Child modules extend this foundation with specialized arithmetic for signed and unsigned vectors, low-level memory access, and mutable bit vector operations for performance-critical tasks. Use it to model digital circuits, implement ALUs, perform bit-accurate computations, or interface with hardware through custom memory layouts and signal transformations.",
      "description_length": 656,
      "index": 742,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml",
      "library": "hardcaml",
      "description": "This system provides a comprehensive framework for hardware design and verification, centered around signal manipulation, circuit construction, and formal analysis. Core data types include polymorphic bit vectors, signals with validity and clock domains, enumerated configurations, and structured interfaces for hierarchical design. Operations span combinational logic, sequential elements, memory modeling, LTL property tracking, and HDL generation, enabling tasks like building arithmetic units, verifying temporal properties, simulating waveforms, and synthesizing Verilog or VHDL. Specific applications include constructing register pipelines, optimizing circuit redundancy, modeling tri-state buses, and generating testbenches with runtime assertions for digital verification workflows.",
      "description_length": 791,
      "index": 743,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Ppx_hardcaml0",
      "library": "ppx_hardcaml0",
      "description": "The module offers no functionality, as it consists solely of an empty child module with no defined types, functions, or documentation. There are no data types or operations available for use. As a result, no meaningful operations or examples can be provided.",
      "description_length": 258,
      "index": 744,
      "embedding_norm": 0.9999999403953552
    }
  ],
  "filtering": {
    "total_modules_in_package": 751,
    "meaningful_modules": 745,
    "filtered_empty_modules": 6,
    "retention_rate": 0.9920106524633822
  },
  "statistics": {
    "max_description_length": 1027,
    "min_description_length": 101,
    "avg_description_length": 476.32348993288593,
    "embedding_file_size_mb": 2.7059707641601562
  }
}