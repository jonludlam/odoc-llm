{
  "package": "orec",
  "embedding_model": "Qwen/Qwen3-Embedding-8B",
  "embedding_dimension": 4096,
  "total_modules": 7,
  "creation_timestamp": "2025-08-14T23:08:34.344368",
  "modules": [
    {
      "module_path": "Orec.Namespace.Make",
      "library": "orec",
      "description": "This module enables type-safe construction and manipulation of open records with typed fields, supporting operations like field creation, value assignment, deletion, and composable updates. It handles both immutable and mutable fields, leveraging bijections to facilitate type conversions during field access and enabling safe field transmutation. Key use cases include dynamic record evolution with strict type guarantees and scenarios requiring chained field transformations via functional composition or exception-safe access patterns.",
      "description_length": 538,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Orec.Bijection",
      "library": "orec",
      "description": "This module defines a bijection type representing invertible mappings between two types. It supports inversion with `flip` and composition using the `%` operator. Useful for managing bidirectional transformations, such as encoding/decoding or converting between data representations.",
      "description_length": 283,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Orec.Namespace",
      "library": "orec",
      "description": "Defines operations to create and manage namespaces for open record fields, enabling field name resolution and scope control. Works with string-based identifiers and abstract namespace values. Useful for implementing modular record systems where field names must be disambiguated across different contexts.",
      "description_length": 305,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Orec.Default",
      "library": "orec",
      "description": "This namespace supports building, modifying, and transforming extensible records with typed fields through operations like field assignment, type-safe transmutation via bijections, and functional composition of record transformations. It works with abstract record types that track mutable and return type parameters, enabling safe field dereferencing, optional access, and exception-aware updates. Common use cases include incrementally constructing records with mixed immutable/mutable fields, safely converting field types using reversible mappings, and composing chains of field operations with guaranteed type consistency.",
      "description_length": 627,
      "index": 3,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Orec.Type_data",
      "library": "orec",
      "description": "This module defines core type constructors for representing and manipulating type-level data, including mutable, immutable, top, and bottom types. It provides foundational types used to encode type information in a structured hierarchy. Concrete use cases include building type systems, implementing type checkers, or modeling type relationships in domain-specific languages.",
      "description_length": 375,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Orec.Univ",
      "library": "orec",
      "description": "This module implements a type-safe heterogeneous map where values of arbitrary types can be stored and retrieved using type-specific keys. It supports creating unique type identifiers, binding values to those types, and safely or unsafely extracting values based on type. Concrete use cases include dynamic service registries, plugin systems with typed interfaces, and generic configuration stores.",
      "description_length": 398,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Orec",
      "library": "orec",
      "description": "This module provides bijections for invertible mappings, extensible record manipulation with type-safe transformations, namespaces for managing field scopes, type-level data constructors, and a type-safe heterogeneous map. It works with abstract records, string identifiers, type representations, and arbitrary value maps. Use cases include bidirectional data conversion, modular record construction, type system implementation, and typed dynamic storage.",
      "description_length": 455,
      "index": 6,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 7,
    "meaningful_modules": 7,
    "filtered_empty_modules": 0,
    "retention_rate": 1.0
  },
  "statistics": {
    "max_description_length": 627,
    "min_description_length": 283,
    "avg_description_length": 425.85714285714283,
    "embedding_file_size_mb": 0.10190010070800781
  }
}