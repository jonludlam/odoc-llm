{
  "package": "diffast-langs-cpp",
  "embedding_model": "Qwen/Qwen3-Embedding-8B",
  "embedding_dimension": 4096,
  "total_modules": 27,
  "creation_timestamp": "2025-08-15T12:38:12.942214",
  "modules": [
    {
      "module_path": "Cpp_base.Cpp_fact.F.FB",
      "library": "diffast-langs-cpp.base",
      "description": "This module supports creation and manipulation of nodes representing C++ abstract syntax tree elements, offering functions to construct typed entities, literals, and resources with specific semantic markers. It provides operations to traverse and query node properties\u2014including labels, source locations, and hierarchical relationships like parent-child or sibling links\u2014for structural analysis. The module also includes utilities to search upward through ancestor chains to locate contextually relevant nodes, enabling contextual or scope-based analyses in tree-structured data.",
      "description_length": 579,
      "index": 0,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Cpp_base.Cpp_lib_base.Fact.FB",
      "library": "diffast-langs-cpp.base",
      "description": "This module enables constructing and manipulating fact graph nodes for entities, literals, and resources using string inputs, with typed constructors like `mkent` and `mklit`. It provides hierarchical traversal capabilities for C++ AST structures through labeled node queries, supporting operations to access parents, children, metadata, and versioned digests. Specific use cases include building semantic representations of code elements, resolving scope hierarchies via upward label traversal, and extracting structured data from C++ abstract syntax trees with language-specific metadata.",
      "description_length": 590,
      "index": 1,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Cpp_base.Cpp_fact.F",
      "library": "diffast-langs-cpp.base",
      "description": "This module enables constructing, analyzing, and navigating C++ abstract syntax trees (ASTs) to model semantic relationships and structural properties, with support for hierarchical traversal, label extraction, and context-sensitive queries. It operates on AST nodes (via `Diffast_core.Triple.node`) representing C++ constructs like declarations, control structures, function calls, and preprocessor directives, offering accessors for components such as parameters, return values, and type metadata. These tools are used for code differencing, semantic analysis, and transformation workflows requiring precise AST manipulation, fact extraction, or metadata-driven filtering.",
      "description_length": 674,
      "index": 2,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Cpp_base.Cpp_tree.FB",
      "library": "diffast-langs-cpp.base",
      "description": "This module constructs and manipulates abstract syntax tree nodes for C++ code analysis, focusing on entity declarations, literals, and resource types. It operates on hierarchical node structures with parent references and metadata (e.g., digests, locations), enabling precise tree traversal and property-based filtering. Typical applications include building AST representations for static analysis, querying code structure relationships, and locating contextual ancestors during semantic traversal tasks.",
      "description_length": 506,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cpp_base.Cpp_tree.Tree",
      "library": "diffast-langs-cpp.base",
      "description": "This module constructs and manipulates tree nodes with labeled data, annotations, and optional original labels. It supports creating nodes with varying numbers of children, handling unique identifiers, and extracting structural information like labels and annotations. Concrete use cases include building abstract syntax trees with metadata for comparison and unparsing in a diffing or transformation pipeline.",
      "description_length": 410,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cpp_base.Cpp_unparsing.Fmtr",
      "library": "diffast-langs-cpp.base",
      "description": "This module provides direct access to a shared formatter object used for generating output in a controlled format. It supports operations like `fprintf`, `printf`, and `asprintf` through the exposed `formatter` value. This is useful when multiple functions need to write to the same output stream without reinitializing the formatter each time.",
      "description_length": 344,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cpp_base.Cpp_label.Annotation",
      "library": "diffast-langs-cpp.base",
      "description": "This module represents annotations for labels in C++ code, supporting operations to create and manipulate `Require`, `Provide`, and `Type` specifications. It works with lists of `spec` values, each representing a semantic annotation, and provides functions to construct, combine, and convert these annotations into string form. Concrete use cases include tracking dependencies and type information in a C++ abstract syntax tree during analysis or transformation passes.",
      "description_length": 469,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cpp_base.Cpp_lib_base.Tree",
      "library": "diffast-langs-cpp.base",
      "description": "This module implements tree construction and manipulation operations for abstract syntax trees, focusing on node creation with annotations, identifiers, and ordinal tables. It works with objects representing tree nodes, labels, annotations, and XML data structures. Functions like `mknode`, `mkleaf`, and `get_lab` are used to build and extract node components during parsing and transformation tasks in compiler pipelines.",
      "description_length": 423,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cpp_base.Cpp_unparsing.Tree",
      "library": "diffast-langs-cpp.base",
      "description": "This module constructs and manipulates abstract syntax trees with labeled nodes and annotations, supporting operations like node creation, comparison, and annotation extraction. It works with tree structures composed of nodes containing data such as labels, identifiers, and ordinal tables, primarily used for un-parsing or converting internal tree representations back into source-like text. Concrete use cases include building AST nodes during unparsing, comparing tree nodes for equality, and extracting or setting node metadata like labels and annotations during transformation or serialization tasks.",
      "description_length": 605,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cpp_base.Cpp_unparsing.UPB",
      "library": "diffast-langs-cpp.base",
      "description": "This module provides low-level text formatting and syntax generation capabilities for C++ code, focusing on precise control of layout through indentation, spacing, and punctuation insertion. It operates on primitive values like strings, numbers, and unit types while managing complex formatting contexts with boxes to handle alignment and structural elements. Typical applications include generating well-formatted C++ expressions, type declarations, and control structures with proper operator spacing, bracket placement, and array/list formatting.",
      "description_length": 549,
      "index": 9,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Cpp_base.Cpp_lib_base.Fact",
      "library": "diffast-langs-cpp.base",
      "description": "This module enables semantic analysis and transformation of C++ code through operations that construct typed fact graphs over abstract syntax trees (ASTs), navigate hierarchical parent-child relationships, and apply label-based queries to extract structured metadata. It works with AST nodes and types from `Diffast_core` and `Diffast_misc`, supporting tasks like identifying syntactic patterns (e.g., conditionals, function calls), filtering declarations by properties (e.g., static/extern), and converting source code elements into structured facts for analysis or transformation workflows. Specific use cases include preprocessor directive analysis, code pattern matching, and generating warnings or structured outputs during refactoring.",
      "description_length": 741,
      "index": 10,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cpp_base.Cpp_fact",
      "library": "diffast-langs-cpp.base",
      "description": "This module provides operations for constructing and analyzing C++ abstract syntax trees (ASTs), enabling hierarchical traversal, label extraction, and context-sensitive queries over AST nodes. It works directly with `Diffast_core.Triple.node` representations of C++ constructs such as declarations, control structures, and function calls, offering access to parameters, return types, and semantic metadata. It supports concrete use cases like code differencing, semantic fact extraction, and transformation pipelines requiring precise AST manipulation and metadata filtering.",
      "description_length": 576,
      "index": 11,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cpp_base.Cpp_tree",
      "library": "diffast-langs-cpp.base",
      "description": "This module processes C++ abstract syntax trees with operations to construct, annotate, and traverse nodes carrying metadata such as locations and unique identifiers. It supports precise manipulation of tree structures through functions like `getlab`, `apply_child`, and `get_nth_children`, and integrates AST data with control flow setup via `set_control_flow`. Specific applications include static analysis tooling, code diffing pipelines, and transformation systems requiring structural fidelity with C++ source code.",
      "description_length": 520,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cpp_base.Cpp_unparsing",
      "library": "diffast-langs-cpp.base",
      "description": "This module un-parses C++ abstract syntax trees into formatted source code by combining tree manipulation, shared formatting state, and low-level layout control. It processes tree nodes with labels, annotations, and ordinal relationships, applying precise indentation, spacing, and punctuation to generate valid C++ syntax. Concrete uses include converting AST nodes to text with `pr_node`, managing formatter state via `Fmtr`, and emitting structured C++ elements like expressions and declarations using `UPB` primitives.",
      "description_length": 522,
      "index": 13,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cpp_base.Cpp_lib_base",
      "library": "diffast-langs-cpp.base",
      "description": "This module provides tree construction and semantic analysis capabilities for C++ abstract syntax trees. It includes functions for creating and manipulating tree nodes with annotations and identifiers, as well as building and querying typed fact graphs over ASTs to support code analysis and transformation. It is used for tasks such as parsing, pattern recognition, declaration filtering, and structured metadata extraction in C++ compiler pipelines and refactoring tools.",
      "description_length": 473,
      "index": 14,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cpp_base.Cpp_label",
      "library": "diffast-langs-cpp.base",
      "description": "This module provides classification, introspection, and manipulation capabilities for C++ abstract syntax tree (AST) nodes and preprocessor constructs through labeled representations. It operates on structured label data encoding C++ syntax elements (statements, expressions, declarations), macro definitions, and semantic annotations like dependency tracking markers (`Require`, `Provide`) or type metadata. Key use cases include static analysis of code structure, transformation of AST nodes during refactoring, and extraction of semantic relationships (e.g., identifier resolution, macro expansion contexts) via predicate-driven pattern recognition.",
      "description_length": 652,
      "index": 15,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cpp_base",
      "library": "diffast-langs-cpp.base",
      "description": "This module processes C++ abstract syntax trees with functions for construction, traversal, and annotation of nodes carrying semantic metadata, identifiers, and location information. It supports precise tree manipulation through operations like child access, control flow setup, and node labeling, working directly with structured representations of C++ constructs such as declarations, expressions, and macros. Concrete applications include static analysis, code differencing, semantic fact extraction, and transformation pipelines that require structural fidelity and precise manipulation of C++ ASTs.",
      "description_length": 603,
      "index": 16,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mcpp.Cpp_lib.Change.CB",
      "library": "diffast-langs-cpp",
      "description": "This module provides functions to retrieve a label from an object and check if an object is a phantom. It operates on objects with a `_label` field in their data structure. Use cases include label inspection and determining if an object represents a placeholder or transient entity.",
      "description_length": 282,
      "index": 17,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mcpp.Cpp_change.F.CB",
      "library": "diffast-langs-cpp",
      "description": "This module provides functions to retrieve a label from an object and check if an object is marked as a phantom. It operates on objects with a nested `data` field containing a `_label`. Use cases include tracking object identities and filtering out phantom objects in data processing pipelines.",
      "description_length": 294,
      "index": 18,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Mcpp.Cpp_lib.Change.F",
      "library": "diffast-langs-cpp",
      "description": "This module provides operations to extract a label from an object and check if it is phantom. It works with objects that have a nested `data` field containing a `_label`. Useful for analyzing or transforming labeled data structures where label presence and identity are significant.",
      "description_length": 282,
      "index": 19,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mcpp.Cpp_change.F",
      "library": "diffast-langs-cpp",
      "description": "This module provides operations for representing and analyzing changes in C++ abstract syntax trees (ASTs), including deletions, insertions, and modifications with varying significance levels. It works with AST nodes, semantic identifiers for RDF-like triples, and labeled subtrees to support tasks like code diffing, merging, and transformation analysis. Utilities for node labeling, subtree comparison, and semantic change tracking enable applications in program structure analysis, refactoring tools, and version control systems requiring precise edit detection and transformation.",
      "description_length": 584,
      "index": 20,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Mcpp.Cpp_lib.Analyzing",
      "library": "diffast-langs-cpp",
      "description": "This module provides functions for analyzing and comparing abstract syntax trees during code differencing, focusing on operations like subtree matching, pruning, and boundary detection. It works with tree structures represented as `Diffast_core.Spec.tree_t` and node types with metadata such as `Diffast_core.Spec.node_t` and `Diffast_core.Spec.SB.Otree.GI.t`. Concrete use cases include identifying isomorphic subtrees, classifying node mappings, and performing detailed tree comparison with pruning and expansion operations tailored for C++ code analysis.",
      "description_length": 557,
      "index": 21,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mcpp.Cpp_lib.Change",
      "library": "diffast-langs-cpp",
      "description": "This module provides operations for representing and manipulating abstract syntax tree (AST) changes in C++ code, including change kinds (insertion, deletion, modification), tagging, hashing, and semantic representation via RDF triples. It operates on AST nodes, structured node types from `Diffast_core`, source locations, and versioned entities to enable semantic diffing and",
      "description_length": 377,
      "index": 22,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mcpp.Cpp_change",
      "library": "diffast-langs-cpp",
      "description": "This module represents and analyzes changes in C++ ASTs, supporting operations to track deletions, insertions, and modifications with varying significance levels. It works with AST nodes, semantic identifiers for RDF-like triples, and labeled subtrees to enable precise edit detection and transformation analysis. Use cases include code diffing, merging, refactoring tools, and version control systems requiring structural analysis of C++ code.",
      "description_length": 444,
      "index": 23,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Mcpp.Cpp_lib",
      "library": "diffast-langs-cpp",
      "description": "This module implements precise AST differencing for C++ code by performing subtree matching, node mapping, and change detection with customizable thresholds. It operates on structured AST nodes and trees, supporting operations like mapping, locking, pruning, and edit generation. Concrete use cases include semantic code comparison, refactoring detection, and generating detailed edit scripts for versioned C++ source files.",
      "description_length": 424,
      "index": 24,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mcpp",
      "library": "diffast-langs-cpp",
      "description": "This module provides precise C++ AST differencing with subtree matching, node mapping, and edit detection. It works with structured AST nodes and trees, enabling operations like change tracking, refactoring analysis, and detailed edit script generation. Use cases include semantic code diffing, refactoring tools, and structural version control systems.",
      "description_length": 353,
      "index": 25,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Mcpp_p",
      "library": "diffast-langs-cpp.p",
      "description": "This module implements preprocessing logic for C++ code, including tokenization, macro expansion, and conditional compilation. It operates on abstract syntax trees and token streams, handling directives like `#include`, `#define`, and `#ifdef`. Concrete use cases include parsing C++ headers, resolving preprocessor symbols, and preparing source code for further analysis or transformation.",
      "description_length": 390,
      "index": 26,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 62,
    "meaningful_modules": 27,
    "filtered_empty_modules": 35,
    "retention_rate": 0.43548387096774194
  },
  "statistics": {
    "max_description_length": 741,
    "min_description_length": 282,
    "avg_description_length": 489.74074074074076,
    "embedding_file_size_mb": 0.39173030853271484
  }
}