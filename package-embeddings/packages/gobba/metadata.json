{
  "package": "gobba",
  "embedding_model": "Qwen/Qwen3-Embedding-8B",
  "embedding_dimension": 4096,
  "total_modules": 32,
  "creation_timestamp": "2025-08-15T12:25:36.469491",
  "modules": [
    {
      "module_path": "Gobba.Completion.Trie",
      "library": "gobba",
      "description": "This module implements a trie data structure for efficient prefix-based string completion. It supports operations to insert strings, retrieve subtrees matching a prefix, and generate completion suggestions. The trie nodes store boolean flags to mark valid word endings and associate characters with child nodes. Use cases include auto-completing user input in a REPL or command-line interface based on previously inserted command histories.",
      "description_length": 440,
      "index": 0,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Gobba.Parser.MenhirInterpreter",
      "library": "gobba",
      "description": "This component facilitates incremental parsing by enabling step-by-step token consumption, state transitions, and stack management through operations like `offer`, `resume`, and `loop`. It interacts with tokens, checkpoints, parsing stacks, and LR(1) states to support interactive parsing scenarios, error recovery, and dynamic grammar analysis by inspecting or modifying parser environments and reductions. Key capabilities include resuming halted parses, introspecting active productions, and controlling reduction actions during incremental processing.",
      "description_length": 555,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Gobba.Util.Dict",
      "library": "gobba",
      "description": "This module implements a dictionary-like structure using lists of key-value pairs, supporting operations such as insertion, deletion, lookup, and filtering. It provides functions to manipulate associations between keys and values, including bulk insertion, key or value extraction, and checking for key presence or duplicates. Concrete use cases include managing configuration mappings, handling symbol tables, and processing associative data where order or multiple entries may be significant.",
      "description_length": 494,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Gobba.Parser.Incremental",
      "library": "gobba",
      "description": "This module provides an incremental parsing interface for processing input step by step, starting from a given lexical position. It produces a checkpointed parser state that allows resuming parsing after each command in a list of structured commands. It is used to implement interactive or streaming parsers where input arrives in chunks and needs to be parsed incrementally without reprocessing.",
      "description_length": 396,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Gobba.Repl.StringSet",
      "library": "gobba",
      "description": "This module implements a string set structure with ordered elements, supporting standard set operations like union, intersection, and difference, along with ordered traversal, filtering, and extremal value extraction. It works with sets of strings and sequences, enabling deterministic processing through ordered iteration and conversion between sets and lists or sequences. Typical use cases include managing unique string collections with ordered semantics, transforming string data through set operations, and bridging sequence-based workflows with set membership checks.",
      "description_length": 574,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Gobba.Primitives",
      "library": "gobba",
      "description": "This module provides direct access to primitive functions, their purity information, and environment mappings. It operates on primitive values, converting them to executable functions or lambda expressions, and maintaining global tables for primitive lookups. Concrete use cases include evaluating built-in operations, generating function representations, and managing purity-aware environments during interpretation.",
      "description_length": 417,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Gobba.Errors",
      "library": "gobba",
      "description": "This module defines error types and location tracking for parsing and evaluation errors, including detailed variants for specific failure modes like type errors, variable binding issues, and file not found errors. It provides functions to raise and print errors with optional source locations, stack traces, and colored output, using lexbuf to extract position information. Concrete use cases include reporting syntax errors during parsing, type mismatches during evaluation, and uncaught exceptions with structured location data.",
      "description_length": 530,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Gobba.Repl",
      "library": "gobba",
      "description": "This module implements a REPL environment for parsing and evaluating expressions, managing state, and handling command-line interaction. It provides functions to evaluate expressions from strings or files, read and parse input lines, and maintain dynamic sets of strings for completion and environment tracking. Concrete use cases include embedding an interactive Gobba interpreter in applications, executing script files with stateful evaluation, and generating keyword lists from evaluation environments.",
      "description_length": 506,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Gobba.Dictp",
      "library": "gobba",
      "description": "This module implements dictionary manipulation operations including insertion, deletion, key lookup, and key/value extraction. It works with dictionaries represented as key-value pairs, using `Gobba.Types.evt` for values and handling string keys. Concrete use cases include building dictionaries from key and value lists, filtering entries, and transforming dictionary contents with custom logic.",
      "description_length": 396,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Gobba.Util",
      "library": "gobba",
      "description": "This module offers list slicing, tuple projection, and zipping/unzipping functions, alongside dictionary operations for insertion, lookup, and filtering. It works with lists, tuples, and associative key-value pairs, including utilities to convert character sequences into strings. Specific applications include processing sequential data, transforming structured data, and constructing string values from character streams.",
      "description_length": 423,
      "index": 9,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Gobba.Estack",
      "library": "gobba",
      "description": "This module manipulates a stack structure used to track abstract syntax tree (AST) expressions during evaluation. It supports pushing and popping expressions, measuring stack depth, and generating string representations of the stack up to a given limit. It is used to manage execution context in interpreters or virtual machines handling functional languages.",
      "description_length": 359,
      "index": 10,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Gobba.Parser",
      "library": "gobba",
      "description": "Parses structured input into typed tokens and command sequences using a lexer, supporting incremental parsing through state checkpoints and interactive error recovery. Works with lexical buffers, token streams, and command lists, handling arithmetic, logic, and control-flow constructs. Used for implementing REPLs, streaming parsers, and interactive language processing tools.",
      "description_length": 377,
      "index": 11,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Gobba.Testing",
      "library": "gobba",
      "description": "Implements basic testing primitives for asserting equality and unit testing. Works with arrays of `Gobba.Types.evt` values and maintains a list of named primitive functions for test execution. Used to validate correctness of expressions and primitives in test suites.",
      "description_length": 267,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Gobba.Charp",
      "library": "gobba",
      "description": "This module provides functions to convert event arrays to uppercase or lowercase, working directly with `Gobba.Types.evt` values. It includes a table mapping strings to primitive values, enabling direct lookups for character transformations. Use cases include normalizing input events and mapping character actions to primitives in a language interpreter.",
      "description_length": 355,
      "index": 13,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Gobba.Types",
      "library": "gobba",
      "description": "This module supports equality, comparison, and pretty-printing operations for types modeling identifiers, expressions, primitives, and evaluation state in a functional language interpreter. It works with algebraic data types for language constructs (e.g., booleans, lists, lambdas), structured types for purity environments, runtime events, and vectors, and interpreter state components like stack frames and evaluation contexts. These operations enable type checking, abstract syntax tree manipulation, and runtime management of environments and effect tracking during program execution.",
      "description_length": 588,
      "index": 14,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Gobba.Optimizer",
      "library": "gobba",
      "description": "Performs normalization and optimization of abstract syntax tree expressions, including recursive reduction until fully optimized. It operates directly on `Gobba.Types.expr` values, applying transformations like let-binding optimization and iterative simplification. This module is used to prepare expressions for evaluation by reducing them to their simplest form through repeated optimization passes.",
      "description_length": 401,
      "index": 15,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Gobba.Completion",
      "library": "gobba",
      "description": "This module implements a trie-based completion system for string prefix matching and suggestion generation. It provides functions to insert strings into a trie structure, retrieve completions for a given prefix, and generate formatted suggestions with optional color hints. It is specifically designed for use in interactive REPL environments to auto-complete user input based on stored command histories.",
      "description_length": 405,
      "index": 16,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Gobba.Stringp",
      "library": "gobba",
      "description": "This module implements low-level string operations including character conversion, case manipulation, and string-to-list conversion. It works directly with `Gobba.Types.evt` arrays and strings, providing primitives for string mapping, concatenation, and comparison. These functions are used to process and transform string data within the interpreter's evaluation loop.",
      "description_length": 369,
      "index": 17,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Gobba.Typep",
      "library": "gobba",
      "description": "This module implements string manipulation operations and type inspection primitives. It provides functions to determine the type of a value, display values as strings, and trigger failures with custom error messages. These operations work with arrays of event values, handling structured data like strings, primitives, and typed values. Concrete use cases include debugging evaluations, validating input types, and formatting output for interactive environments.",
      "description_length": 463,
      "index": 18,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Gobba.Numericalp",
      "library": "gobba",
      "description": "This module handles numerical operations on event values, including unpacking lists of integers, floats, and complex numbers. It provides arithmetic primitives for addition, subtraction, multiplication, division, and modulus, supporting both real and complex numbers. Functions like `dynamic_binop` enable polymorphic numeric operations, while helpers like `makecomplex` and `flatnum` construct and simplify numerical values for evaluation.",
      "description_length": 440,
      "index": 19,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Gobba.Eval",
      "library": "gobba",
      "description": "This module evaluates expressions and executes commands using a state-based environment, handling operations like variable lookup, function application, and assignments. It works with expressions, directives, and commands, producing events paired with updated evaluation states. Concrete use cases include interpreting arithmetic and boolean operations, managing variable bindings, and executing sequences of commands with state transitions.",
      "description_length": 441,
      "index": 20,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Gobba.Primutil",
      "library": "gobba",
      "description": "This module provides a parser function that processes input from a lexing buffer and returns a list of commands. It also includes a helper for converting strings into lambda expressions, used to define closures for the standard library. These operations are critical for interpreting function definitions from text input and embedding them into the language's evaluation context.",
      "description_length": 379,
      "index": 21,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Gobba.Expr",
      "library": "gobba",
      "description": "This module provides operations to analyze, transform, and construct lambda and apply expressions, working directly with `Gobba.Types.expr` and related structures like lists and arrays of identifiers. It supports tasks such as extracting or replacing lambda bodies, building nested lambdas from parameter lists, and generating symbolic representations. Concrete use cases include expression normalization, lambda lifting, and constructing expression trees from structured inputs.",
      "description_length": 479,
      "index": 22,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Gobba.Lexer",
      "library": "gobba",
      "description": "This module implements lexical analysis for parsing source code, providing functions to process input buffers and generate tokens. It handles operations like advancing through lines, parsing strings and characters, and managing comments using lexing tables. Concrete use cases include reading and transforming raw input into structured tokens for further parsing, such as identifying string literals, characters, and comment blocks during language processing.",
      "description_length": 459,
      "index": 23,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Gobba.Complexp",
      "library": "gobba",
      "description": "This module implements complex number operations including extraction of real and imaginary parts, conjugation, inversion, and conversion from polar form. It operates on arrays of `Gobba.Types.evt` values, which represent evaluated expressions. These functions are used to perform mathematical computations on complex numbers within the interpreter's evaluation context.",
      "description_length": 370,
      "index": 24,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Gobba.Parsedriver",
      "library": "gobba",
      "description": "Parses input from a lexing buffer or string into a list of commands using a specified parser. It handles both file and string inputs, producing structured command lists for further processing. Useful for interpreting script files or inline code snippets into executable command sequences.",
      "description_length": 288,
      "index": 25,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Gobba.Puritycheck",
      "library": "gobba",
      "description": "This module enforces purity constraints during expression evaluation by analyzing and combining purity levels of values and environments. It operates on expressions, identifiers, assignments, and commands, using purity types to track side effects and environments to maintain purity context. Concrete use cases include determining purity of variable lookups, assignments, and command sequences to ensure safe evaluation in a restricted context.",
      "description_length": 444,
      "index": 26,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Gobba.Listp",
      "library": "gobba",
      "description": "This module implements list processing operations for event arrays, including element access, length calculation, membership checks, and array transformations. It provides functions like `head`, `tail`, `getat`, `length`, and `mem` for manipulating event arrays, along with string representations of higher-order operations such as `map`, `filter`, and folds. The module is used to support list abstractions in the Gobba language runtime, enabling direct manipulation of event-based data structures in a scripting context.",
      "description_length": 522,
      "index": 27,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Gobba.Values",
      "library": "gobba",
      "description": "This module handles the representation and manipulation of events and lambda parameters in a structured type system. It provides operations to convert events to human-readable strings and extract parameter lists from nested lambda closures. These functions are used primarily during evaluation and compilation phases to manage function parameters and event introspection.",
      "description_length": 371,
      "index": 28,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Gobba.Iop",
      "library": "gobba",
      "description": "This module implements formatted output operations and program termination for event streams. It processes arrays of event values to produce readable output lines or structured displays, and includes a command to exit the program. The module is used to visualize event streams in a human-readable format or terminate execution cleanly.",
      "description_length": 335,
      "index": 29,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Gobba.Typecheck",
      "library": "gobba",
      "description": "This module implements type checking and value extraction operations for a custom type system, handling numeric type promotion, dynamic type verification, and structured value unpacking. It works with event types (`evt`) and type information structures to enforce type constraints during evaluation or transformation passes. Concrete use cases include determining the minimal compatible numeric type for a list, safely extracting primitive values like integers or strings from typed events, and flattening heterogeneous numeric lists into a uniform type.",
      "description_length": 554,
      "index": 30,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Gobba",
      "library": "gobba",
      "description": "This module supports lexical analysis, expression evaluation, and data transformation through operations on expressions, dictionaries, complex numbers, and event arrays. It facilitates language interpretation with REPL infrastructure, error handling, and type-safe value manipulation for structured data like algebraic types and tuples. Key use cases include implementing interpreters, interactive shells, and testing frameworks with robust debugging and assertion mechanisms.",
      "description_length": 476,
      "index": 31,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 32,
    "meaningful_modules": 32,
    "filtered_empty_modules": 0,
    "retention_rate": 1.0
  },
  "statistics": {
    "max_description_length": 588,
    "min_description_length": 267,
    "avg_description_length": 433.53125,
    "embedding_file_size_mb": 0.46419525146484375
  }
}