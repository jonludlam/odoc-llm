{
  "package": "shell",
  "embedding_model": "Qwen/Qwen3-Embedding-8B",
  "embedding_dimension": 4096,
  "total_modules": 31,
  "creation_timestamp": "2025-08-15T12:31:05.070626",
  "modules": [
    {
      "module_path": "Low_level_process.Status",
      "library": "shell.low_level_process",
      "description": "This module represents the status of a low-level process, encoding outcomes such as timeout, exit code, or termination signal. It provides `sexp_of_t` for serializing status values and `to_string` for human-readable string representations. Use this module to inspect and report the final state of processes managed through low-level interfaces, especially when debugging or logging process termination details.",
      "description_length": 410,
      "index": 0,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Low_level_process.Command_result",
      "library": "shell.low_level_process",
      "description": "Handles results from executing low-level processes, capturing exit status and truncated output. It stores stdout and stderr tails as strings, alongside a status indicating success or failure. Useful for inspecting outcomes of direct process invocations when detailed output logging is unnecessary.",
      "description_length": 297,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Low_level_process",
      "library": "shell.low_level_process",
      "description": "This module directly manages process execution and termination with fine-grained control, including sending signals, handling timeouts, and capturing truncated output. It works with process IDs, environment variables, and low-level status codes, returning structured results with stdout/stderr tails. Concrete use cases include running external programs with custom environment settings, enforcing timeouts on subprocesses, and forcibly terminating misbehaving processes.",
      "description_length": 471,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Filename_extended",
      "library": "shell.filename_extended",
      "description": "This module manipulates file paths with operations like normalization, absolute/relative conversion, and path component splitting. It handles string-based paths and provides functions to compare, construct, and work with temporary files and directories. Concrete use cases include resolving relative paths between files, creating temporary files with specific content, and checking directory hierarchies.",
      "description_length": 404,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Shell_internal",
      "library": "shell.shell_internal",
      "description": "This module handles system shell operations and path manipulations. It provides functions to check executable status, resolve command paths, expand paths using an extended search list, and retrieve the current user. Typical uses include locating executables in custom search paths and determining user context for process execution.",
      "description_length": 332,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "String_extended",
      "library": "shell.string_extended",
      "description": "This module enhances string manipulation with specialized sorting, unescaping, and formatting capabilities. It handles operations like human-friendly string collation, unescaping OCaml-style escaped strings, and word-wrapping or squeezing whitespace. It is useful for tasks like processing filenames, preparing text for display, or calculating string similarity with edit distance.",
      "description_length": 381,
      "index": 5,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Shell.Process",
      "library": "shell",
      "description": "This module enables structured execution of local and remote processes with precise control over input/output handling, error propagation, and status evaluation. It operates on command specifications, argument sequences, and host connection parameters, while supporting custom stream processing through callbacks to parse stdout/stderr incrementally during execution. Typical applications include automated system administration workflows, distributed command orchestration via SSH, and robust process pipelines requiring detailed error diagnostics or structured output parsing.",
      "description_length": 578,
      "index": 6,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Shell",
      "library": "shell",
      "description": "The module enables secure execution of local and remote shell commands with structured error handling, supporting operations like process spawning, output parsing (line-based, single/multi-line), and file manipulation (copying, moving, deletion). It works with command representations (`Shell.cmd`, `Shell.sh_cmd`), process handles (`Process.t`), and system primitives like file paths and environment variables. Typical applications include automated deployment pipelines, system administration scripts, and cross-host file synchronization via SSH.",
      "description_length": 548,
      "index": 7,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Unix_extended.Inet_port.Stable.V1.Map.Diff",
      "library": "shell.unix_extended",
      "description": "This module represents differences between maps keyed by stable IPv4 port values, supporting operations to serialize and deserialize diffs in both S-expression and binary formats. It provides functions to apply diffs to base values, construct diffs from lists, and retrieve specific diffs between two derived map states. Concrete use cases include persisting and transmitting incremental changes to port-based configurations or stateful network resources.",
      "description_length": 455,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Unix_extended.Inet_port.Stable.V1.Set.Diff",
      "library": "shell.unix_extended",
      "description": "This module represents differences between sets of Internet ports, enabling the serialization and deserialization of these differences using S-expressions and binary protocols. It supports operations to compute and apply changes between two port sets, producing a structured diff that can be used for configuration synchronization or audit logging. The module is used in scenarios like tracking changes in network service configurations or generating delta updates for firewall rules.",
      "description_length": 484,
      "index": 9,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Unix_extended.Inet_port.Stable.V1.Set",
      "library": "shell.unix_extended",
      "description": "This module represents ordered sets of Internet port values, supporting standard set operations like union, intersection, and difference. It provides binary and S-expression serialization for persistent storage or transmission, with typed readers and writers for safe deserialization. Concrete use cases include managing allowed port ranges in network services, synchronizing firewall configurations, and auditing port usage across systems.",
      "description_length": 440,
      "index": 10,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Unix_extended.Inet_port.Stable.V1.Map",
      "library": "shell.unix_extended",
      "description": "This module implements a map keyed by stable IPv4 port values, providing standard map operations like lookup, insertion, and traversal. It supports serialization and deserialization in both S-expression and binary formats, with versioned reading capabilities. Concrete use cases include managing configurations or stateful resources tied to specific network ports, such as tracking service bindings or port-based access controls.",
      "description_length": 429,
      "index": 11,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Unix_extended.Inet_port.Map.Diff",
      "library": "shell.unix_extended",
      "description": "This module computes and applies differences between maps of Internet ports and associated values, supporting operations to serialize diffs, retrieve specific changes, apply diffs to base maps, and construct diffs from lists. It works with `Inet_port.t` keys and arbitrary value types, along with their corresponding diff types. Concrete use cases include tracking configuration changes across service restarts and synchronizing network state between distributed nodes.",
      "description_length": 469,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Unix_extended.Inet_port.Map.Provide_bin_io",
      "library": "shell.unix_extended",
      "description": "This module provides binary serialization and deserialization functions for maps where keys are wrapped inet ports and values are arbitrary. It supports concrete operations like `bin_write_t` and `bin_read_t` to convert map values to and from binary format, enabling efficient storage or transmission. Use cases include persisting port-to-value mappings to disk or sending them over a network in a binary protocol.",
      "description_length": 414,
      "index": 13,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Unix_extended.Inet_port.Set.Diff",
      "library": "shell.unix_extended",
      "description": "This module computes and applies differences between sets of internet port values. It works with sets of a specific port type, supporting operations to derive, serialize, and apply changes between port sets. Concrete use cases include tracking changes in allowed or reserved port ranges across configuration updates.",
      "description_length": 316,
      "index": 14,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Unix_extended.Inet_port.Set.Elt",
      "library": "shell.unix_extended",
      "description": "This module represents individual elements in a set of Internet ports, providing comparison and serialization functions. It works with `Unix_extended.Inet_port.t`, a type that wraps integers to represent network ports explicitly. It supports creating and manipulating sets of ports using type-safe operations.",
      "description_length": 309,
      "index": 15,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Unix_extended.Inet_port.Map.Provide_hash",
      "library": "shell.unix_extended",
      "description": "This module provides a function `hash_fold_t` that computes a hash for a map of values indexed by Internet ports. It works with maps where keys are `Unix_extended.Inet_port.t` and values are of any type supporting a hash operation. A concrete use case is enabling efficient hashing of port-to-service mappings for network configuration tracking.",
      "description_length": 345,
      "index": 16,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Unix_extended.Inet_port.Set.Provide_of_sexp",
      "library": "shell.unix_extended",
      "description": "Converts S-expressions into sets of Internet ports. It parses a list of port numbers or ranges (e.g., \"80\", \"1024-2048\") and constructs a set representing those ports. This is useful for configuring network services that accept port ranges in configuration files.",
      "description_length": 263,
      "index": 17,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Unix_extended.Inet_port.Map.Key",
      "library": "shell.unix_extended",
      "description": "This module represents a key type for maps keyed by Internet port numbers. It provides comparison and S-expression conversion functions for use in map structures. It is used to ensure type-safe handling of port numbers as map keys in networking applications.",
      "description_length": 258,
      "index": 18,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Unix_extended.Inet_port.Stable.V1",
      "library": "shell.unix_extended",
      "description": "This module defines a stable, versioned IPv4 port type with support for binary and S-expression serialization and deserialization. It provides comparison, hashing, and type-safe readers and writers for persistent storage or inter-process communication. Concrete use cases include reliably representing service ports across system boundaries, enforcing port consistency in distributed configurations, and serializing port information in versioned data formats.",
      "description_length": 459,
      "index": 19,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Unix_extended.Inet_port.Set.Provide_hash",
      "library": "shell.unix_extended",
      "description": "This module implements hash functions for sets of `Unix_extended.Inet_port` values. It provides `hash_fold_t` and `hash` for computing hash values of port sets, enabling their use in hash-based data structures like hash tables. The operations directly support efficient equality checks and hashing of port set collections.",
      "description_length": 322,
      "index": 20,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Unix_extended.Inet_port.Map.Provide_of_sexp",
      "library": "shell.unix_extended",
      "description": "This module provides a function to convert S-expressions into maps where keys are wrapped in an `Inet_port` type, specifically parsing and constructing map values from S-expression input. It operates on data structures involving key-value pairs with integer-based port identifiers as keys. A concrete use case includes deserializing network configuration data stored in S-expressions into structured maps for runtime use.",
      "description_length": 421,
      "index": 21,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Unix_extended.Inet_port.Set.Provide_bin_io",
      "library": "shell.unix_extended",
      "description": "This module provides binary serialization and deserialization operations for sets of inet ports. It includes functions to compute binary size, read and write sets in binary format, and supports efficient encoding/decoding via the Bin_prot library. Concrete use cases include persisting port sets to disk or transmitting them over a network.",
      "description_length": 340,
      "index": 22,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Unix_extended.Inet_port.Replace_polymorphic_compare",
      "library": "shell.unix_extended",
      "description": "This module replaces polymorphic comparison operators with type-specific ones for `Unix_extended.Inet_port.t`, ensuring correct and efficient comparisons. It provides standard comparison functions like `(=)`, `(<)`, `(>)`, `compare`, and utilities like `min` and `max` tailored to work directly on port values. These operations enable precise ordering and equality checks when managing network port numbers in system-level networking code.",
      "description_length": 439,
      "index": 23,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Unix_extended.Inet_port.Set",
      "library": "shell.unix_extended",
      "description": "This module provides operations for constructing, transforming, and comparing sets of Internet ports from lists, hashtables, and S-expressions, supporting set differences, mapping, and filtering with type-safe comparator consistency. It enables serialization via binary I/O and hashing, alongside Quickcheck-based testing, making it suitable for network configuration management, efficient data exchange, and property-based validation of port number constraints.",
      "description_length": 462,
      "index": 24,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Unix_extended.Inet_port.Stable",
      "library": "shell.unix_extended",
      "description": "This module defines a stable, versioned IPv4 port type with support for binary and S-expression serialization and deserialization. It provides comparison, hashing, and type-safe readers and writers for persistent storage or inter-process communication. Concrete use cases include reliably representing service ports across system boundaries, enforcing port consistency in distributed configurations, and serializing port information in versioned data formats.",
      "description_length": 459,
      "index": 25,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Unix_extended.Inet_port.Map",
      "library": "shell.unix_extended",
      "description": "This module provides operations for creating, transforming, and comparing maps with Internet port numbers as keys, supporting conversions from lists, sequences, and hashtables while handling duplicate keys through customizable strategies. It works with maps pairing `Unix_extended.Inet_port.t` keys and arbitrary values, offering structured manipulation for network configuration management, port-based routing, or service discovery scenarios. Additional capabilities include binary serialization, hashing, and property-based testing for robust network state persistence and validation.",
      "description_length": 586,
      "index": 26,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Unix_extended.Inet_port",
      "library": "shell.unix_extended",
      "description": "This module provides type-safe handling of Internet port numbers through a dedicated `t` type wrapping integers, supporting conversions to/from integers and strings, range validation, comparison operations (`min`, `max`, `clamp`), and integration with maps, sets, and S-expression serialization. It is designed for system-level networking applications requiring precise port management, such as command-line argument parsing, port range checks, and configuration of network services using typed collections.",
      "description_length": 507,
      "index": 27,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Unix_extended.Quota",
      "library": "shell.unix_extended",
      "description": "This module provides operations to query and set disk quotas for users or groups on a filesystem path, retrieving or modifying limits and usage for both disk space (in bytes) and inode counts. It works with strongly-typed representations of bytes and inodes, wrapped as `limit` and `usage` values, ensuring correct handling of quota-related data. Concrete use cases include enforcing storage limits in multi-user environments, monitoring filesystem usage per user/group, and implementing automated quota adjustments in system management tools.",
      "description_length": 543,
      "index": 28,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Unix_extended.Extended_passwd",
      "library": "shell.unix_extended",
      "description": "This module provides functions to parse individual lines or entire files in the passwd format, returning structured user information as `Unix.Passwd.t` values. It supports operations for converting string-based passwd entries into typed records, with both safe and exception-raising variants. Use cases include reading and processing custom or system passwd files for user management or authentication workflows.",
      "description_length": 412,
      "index": 29,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Unix_extended.Mount_entry",
      "library": "shell.unix_extended",
      "description": "This module parses and represents filesystem mount entries, typically from configuration files like `fstab` or `mtab`. It provides accessors to retrieve fields such as filesystem name, mount point, type, and options, and supports parsing lines into structured data. A concrete use case is inspecting or modifying system mount configurations programmatically.",
      "description_length": 358,
      "index": 30,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 32,
    "meaningful_modules": 31,
    "filtered_empty_modules": 1,
    "retention_rate": 0.96875
  },
  "statistics": {
    "max_description_length": 586,
    "min_description_length": 258,
    "avg_description_length": 416.48387096774195,
    "embedding_file_size_mb": 0.4496269226074219
  }
}