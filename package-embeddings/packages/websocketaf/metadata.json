{
  "package": "websocketaf",
  "embedding_model": "Qwen/Qwen3-Embedding-0.6B",
  "embedding_dimension": 1024,
  "total_modules": 8,
  "creation_timestamp": "2025-07-15T23:06:17.179660",
  "modules": [
    {
      "module_path": "Websocketaf.Websocket.Close_code",
      "library": "websocketaf",
      "description": "This module defines types and functions for working with WebSocket close codes, including standard symbolic representations and arbitrary integer values. It provides conversions between close code values and their integer encodings, along with safe and unsafe lookup functions. Concrete use cases include handling WebSocket connection closures with specific error codes like `Normal_closure` or parsing close codes received over a WebSocket connection.",
      "description_length": 452,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Websocketaf.Websocket.Frame",
      "library": "websocketaf",
      "description": "This module handles WebSocket frame parsing and serialization, providing direct access to frame properties like fin, opcode, mask, and payload length. It works with `Bigstringaf.t` and `Bytes.t` for efficient payload manipulation, supporting in-place masking and unmasking operations. Concrete use cases include parsing incoming WebSocket frames, constructing control frames, and serializing application data frames with proper masking and framing.",
      "description_length": 448,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Websocketaf.Websocket.Opcode",
      "library": "websocketaf",
      "description": "This module defines types and functions for working with WebSocket opcodes, including standard non-control (`Continuation`, `Text`, `Binary`) and control (`Connection_close`, `Ping`, `Pong`) codes. It provides conversions between opcode values and their integer representations, along with safe and unsafe lookup functions. Use cases include parsing and serializing WebSocket frame headers during message transmission and handling protocol-level operations like connection termination or heartbeat signals.",
      "description_length": 506,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Websocketaf.Client_handshake",
      "library": "websocketaf",
      "description": "This module manages the WebSocket handshake process for clients, handling the transition from HTTP to WebSocket. It provides functions to create a handshake context, process incoming data, and manage read and write operations during the handshake phase. Concrete use cases include initiating WebSocket connections with custom headers, handling handshake responses, and managing I/O operations during the upgrade sequence.",
      "description_length": 421,
      "index": 3,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Websocketaf.Client_connetion",
      "library": "websocketaf",
      "description": "This module manages WebSocket client connections, handling the lifecycle of sending and receiving frames. It provides functions to create connections, process reads and writes, and handle errors during the handshake or communication. Concrete use cases include implementing WebSocket clients that send and receive binary or text messages, such as real-time chat applications or live data feeds.",
      "description_length": 394,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Websocketaf.Websocket",
      "library": "websocketaf",
      "description": "This module provides core functionality for working with WebSocket protocol primitives, enabling low-level manipulation of connection states, message framing, and control operations. It defines key data types for close codes, opcodes, and frame structures, with operations to encode, decode, and inspect WebSocket frames, including handling control messages like ping and close. You can use it to parse incoming frames, construct and mask outgoing data frames, or manage connection closure with standard or custom error codes. Specific tasks include extracting payload data from a `Text` frame, sending a `Pong` response, or closing a connection with `Normal_closure`.",
      "description_length": 668,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Websocketaf.Wsd",
      "library": "websocketaf",
      "description": "This module manages WebSocket data transmission for clients and servers. It provides functions to send text or binary messages, pings, and pongs, and to handle connection lifecycle events like closing and flushing. Use it to implement WebSocket communication logic where messages are sent and received using bigstrings or bytes.",
      "description_length": 328,
      "index": 6,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "Websocketaf",
      "library": "websocketaf",
      "description": "This module suite handles WebSocket communication from initial handshake through data transmission, supporting both client and server implementations. Key data types include frame structures, opcodes, and close codes, with operations for encoding, decoding, and inspecting WebSocket protocol primitives. It enables tasks like initiating connections with custom headers, sending and receiving text or binary messages, responding to pings, and closing connections gracefully. Concrete applications include real-time chat systems and live data streaming services.",
      "description_length": 560,
      "index": 7,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 8,
    "meaningful_modules": 8,
    "filtered_empty_modules": 0,
    "retention_rate": 1.0
  },
  "statistics": {
    "max_description_length": 668,
    "min_description_length": 328,
    "avg_description_length": 472.125,
    "embedding_file_size_mb": 0.02945995330810547
  }
}