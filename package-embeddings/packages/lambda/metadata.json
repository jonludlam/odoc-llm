{
  "package": "lambda",
  "embedding_model": "Qwen/Qwen3-Embedding-0.6B",
  "embedding_dimension": 1024,
  "total_modules": 7,
  "creation_timestamp": "2025-07-15T23:05:26.429868",
  "modules": [
    {
      "module_path": "Lambda.L",
      "library": "lambda",
      "description": "This module represents lambda calculus terms with variables, abstractions, and applications. It supports operations such as free variable extraction, substitution, alpha and eta conversions, and various forms of beta-reduction including stepwise and timeout-limited reduction. Use cases include symbolic manipulation of lambda terms, normalization, and evaluation in lambda calculus.",
      "description_length": 383,
      "index": 0,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lambda.Parser",
      "library": "lambda",
      "description": "Parses lambda calculus expressions into abstract syntax trees using a token stream from a lexer. It handles function application, variable binding, and parenthesized expressions. Concrete use cases include interpreting lambda terms from textual input and building compilers or interpreters for functional languages.",
      "description_length": 315,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lambda.Bool",
      "library": "lambda",
      "description": "This module defines lambda calculus representations of boolean values and conversions between them. It provides operations to construct true and false lambda terms, convert lambda terms to and from boolean values, and check if a term represents a boolean. Use cases include encoding logical values in lambda calculus and evaluating boolean expressions within a lambda calculus interpreter.",
      "description_length": 389,
      "index": 2,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Lambda.Lexer",
      "library": "lambda",
      "description": "This module implements a lexer for parsing Lambda language tokens from a lexing buffer. It provides the main `lexer` function that processes input and returns the next token, along with internal functions like `__ocaml_lex_lexer_rec` that handle state transitions during lexing. It works directly with `Lexing.lexbuf` and produces tokens consumed by the parser, enabling concrete tasks like reading lambda expressions, identifiers, and punctuation from source code.",
      "description_length": 465,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lambda.Parse",
      "library": "lambda",
      "description": "Parses lambda calculus expressions from string representations into abstract syntax trees. Works with strings and the `Lambda.L.term` data type to represent variables, abstractions, and applications. Used to convert human-readable lambda terms into a structured format for evaluation or analysis.",
      "description_length": 296,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lambda.Church",
      "library": "lambda",
      "description": "This module provides functions to encode integers as lambda terms and decode them back, along with checks for Church numeral validity. It operates directly on lambda terms represented by `Lambda.L.term`. Use cases include working with lambda calculus encodings of natural numbers and verifying term structure for numerical operations.",
      "description_length": 334,
      "index": 5,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lambda",
      "library": "lambda",
      "description": "This module suite provides a complete framework for working with lambda calculus, enabling the representation, manipulation, and evaluation of lambda terms. Core data types include lambda terms composed of variables, abstractions, and applications, along with tokens for lexical elements and boolean and integer encodings as lambda terms. Key operations include parsing from strings or lexing buffers, free variable analysis, substitution, reduction strategies, and conversions to and from boolean and integer values. Examples include evaluating lambda expressions stepwise, encoding logic and arithmetic in lambda terms, and building interpreters or compilers that process lambda calculus input.",
      "description_length": 696,
      "index": 6,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 7,
    "meaningful_modules": 7,
    "filtered_empty_modules": 0,
    "retention_rate": 1.0
  },
  "statistics": {
    "max_description_length": 696,
    "min_description_length": 296,
    "avg_description_length": 411.14285714285717,
    "embedding_file_size_mb": 0.02581787109375
  }
}