{
  "package": "ocaml-sat-solvers",
  "embedding_model": "Qwen/Qwen3-Embedding-8B",
  "embedding_dimension": 4096,
  "total_modules": 6,
  "creation_timestamp": "2025-08-14T23:03:43.690047",
  "modules": [
    {
      "module_path": "Timing",
      "library": "ocaml-sat-solvers",
      "description": "This module manages timing data for named tasks, allowing execution time tracking and reporting. It provides functions to create and manipulate a timetable, time task executions, retrieve recorded times, and generate time reports. Concrete use cases include profiling function performance and generating time summaries for benchmarking.",
      "description_length": 336,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Pseudosatwrapper",
      "library": "ocaml-sat-solvers",
      "description": "This module provides a function `get_pseudo_factory` that returns a solver factory for creating pseudo-Boolean constraint solvers. It works with pseudo-Boolean formulas, which are logical expressions involving Boolean variables and integer coefficients. A concrete use case is generating and solving bounded model checking instances in formal verification tasks.",
      "description_length": 362,
      "index": 1,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Satsolvers",
      "library": "ocaml-sat-solvers",
      "description": "This module manages a registry of SAT solver factories, allowing users to register, retrieve, and iterate over available solvers. It supports operations to check existence, find by name, set a default solver, and collect all registered solvers. Concrete use cases include dynamically selecting and switching between different SAT solving implementations at runtime.",
      "description_length": 365,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Satsolutionlexer",
      "library": "ocaml-sat-solvers",
      "description": "This module implements a lexer for parsing input into tokens used by a SAT solution parser. It provides the `lexer` function, which processes a `lexbuf` to produce tokens, and internal functions for handling lexical analysis. It works directly with `Lexing.lexbuf` and produces tokens consumed by the SAT solution parser.",
      "description_length": 321,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Satsolutionparser",
      "library": "ocaml-sat-solvers",
      "description": "Parses SAT solver output into structured solutions using a token-based grammar. It processes lexed input streams into a solution type containing variable assignments and status. Useful for extracting and analyzing results from SAT solver logs.",
      "description_length": 243,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Satwrapper",
      "library": "ocaml-sat-solvers",
      "description": "This module provides functions to interact with a SAT solver, including formatting the result of a solve operation. It works with the `solve_result` and `state` types to represent solver outcomes and lifecycle states. Concrete use cases include checking whether a logical formula is satisfiable and managing the solver's initialization and disposal.",
      "description_length": 349,
      "index": 5,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 16,
    "meaningful_modules": 6,
    "filtered_empty_modules": 10,
    "retention_rate": 0.375
  },
  "statistics": {
    "max_description_length": 365,
    "min_description_length": 243,
    "avg_description_length": 329.3333333333333,
    "embedding_file_size_mb": 0.08740425109863281
  }
}