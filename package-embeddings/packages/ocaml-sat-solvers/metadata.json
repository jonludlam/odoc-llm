{
  "package": "ocaml-sat-solvers",
  "embedding_model": "Qwen/Qwen3-Embedding-0.6B",
  "embedding_dimension": 1024,
  "total_modules": 6,
  "creation_timestamp": "2025-07-15T23:05:31.223915",
  "modules": [
    {
      "module_path": "Satsolvers",
      "library": "ocaml-sat-solvers",
      "description": "This module manages a registry of SAT solver factories, allowing users to register, retrieve, iterate over, and select default solvers. It provides operations to check existence, find by name, enumerate, fold over registered factories, and manage a default solver by name. Concrete use cases include dynamically selecting and switching between different SAT solving backends in a toolchain.",
      "description_length": 390,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Satsolutionparser",
      "library": "ocaml-sat-solvers",
      "description": "Parses SAT solver output into structured solutions using a token-based grammar. It processes lexed input streams into a solution type containing variable assignments and status. Useful for extracting and analyzing SAT solver results from files or process output.",
      "description_length": 262,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Pseudosatwrapper",
      "library": "ocaml-sat-solvers",
      "description": "This module provides a function `get_pseudo_factory` that returns a solver factory for creating pseudo-boolean constraint solvers. It works with pseudo-boolean formulas, which are logical expressions involving boolean variables and integer coefficients. A concrete use case is generating and solving bounded model checking instances in formal verification tasks.",
      "description_length": 362,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Satwrapper",
      "library": "ocaml-sat-solvers",
      "description": "This module implements a SAT solver interface with functions to manage solver state and interpret results. It defines a `solve_result` type to represent outcomes of solving operations and a `state` type to track the solver's lifecycle. The `format_solve_result` function converts result values into human-readable strings for diagnostics or logging.",
      "description_length": 349,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Timing",
      "library": "ocaml-sat-solvers",
      "description": "This module manages timing data for named operations, allowing execution times to be recorded and retrieved. It provides functions to create and manipulate a timetable structure, time a function's execution, and generate a report of recorded times. Concrete use cases include profiling specific code sections and analyzing performance bottlenecks.",
      "description_length": 347,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Satsolutionlexer",
      "library": "ocaml-sat-solvers",
      "description": "This module implements a lexer for parsing input into tokens used by a SAT solution parser. It defines a main entry point `lexer` that processes a `lexbuf` and returns the next token, along with internal lexing tables and a recursive helper function. It is used to break down input streams into structured tokens for further parsing of SAT solver output data.",
      "description_length": 359,
      "index": 5,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 16,
    "meaningful_modules": 6,
    "filtered_empty_modules": 10,
    "retention_rate": 0.375
  },
  "statistics": {
    "max_description_length": 390,
    "min_description_length": 262,
    "avg_description_length": 344.8333333333333,
    "embedding_file_size_mb": 0.022212982177734375
  }
}