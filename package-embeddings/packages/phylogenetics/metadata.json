{
  "package": "phylogenetics",
  "embedding_model": "Qwen/Qwen3-Embedding-0.6B",
  "embedding_dimension": 1024,
  "total_modules": 142,
  "creation_timestamp": "2025-07-15T23:33:35.848261",
  "modules": [
    {
      "module_path": "Phylogenetics.Codon.Universal_genetic_code.NS.Vector",
      "library": "phylogenetics",
      "description": "This module supports arithmetic and transformation operations on vectors of codon-encoded data, such as addition, scalar multiplication, element-wise products, logarithmic/exponential mappings, and tolerance-aware comparisons. It operates on codon-indexed vectors of float values, enabling folding, summation, normalization, and array conversions while preserving associations between codons and their numerical attributes. These capabilities are tailored for computational biology tasks like codon frequency analysis, evolutionary modeling, and phylogenetic inference where precise numerical manipulation of genetic code data is required.",
      "description_length": 639,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Codon.Universal_genetic_code.NS.Table",
      "library": "phylogenetics",
      "description": "This module implements a fixed-size table structure for representing codon-specific data, such as nucleotide or amino acid properties, across the 64 possible codons in the universal genetic code. It supports operations like initialization, value retrieval and modification per codon, mapping over codon entries, folding, counting, and weighted random selection based on codon values. Concrete use cases include modeling codon substitution probabilities, managing codon usage frequencies, and simulating sequence evolution under genetic code constraints.",
      "description_length": 553,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Codon.Universal_genetic_code.NS.Matrix",
      "library": "phylogenetics",
      "description": "This module provides numerical operations for codon substitution matrices and vectors, including arithmetic, diagonalization, and eigenvector normalization tailored for phylogenetic analysis. It works with matrices and vectors indexed by codon symbols, enabling tasks like substitution matrix initialization, element-wise computation, and equilibrium state determination for genetic code modeling. Specific applications include analyzing codon usage bias, constructing transition probability matrices, and solving for stationary distributions in evolutionary models.",
      "description_length": 566,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Codon.Universal_genetic_code.NS",
      "library": "phylogenetics",
      "description": "This module analyzes and transforms codons under the universal genetic code, offering operations for codon comparison, decomposition into nucleotide triplets, synonymy checks, and representation conversion. It supports numerical profiling and neighbor detection for phylogenetic analysis using codon frequency vectors and substitution matrices. The module enables constructing codon substitution models, identifying synonymous codon pairs, and converting sequences into numerical features for evolutionary studies. Submodules handle vector arithmetic, fixed-size codon table operations, and matrix manipulations, enabling tasks like frequency normalization, substitution probability modeling, and eigenvector-based equilibrium analysis.",
      "description_length": 736,
      "index": 3,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Phylogenetics.Alphabet.Make.Matrix",
      "library": "phylogenetics",
      "description": "This module supports matrix arithmetic (addition, multiplication, exponentiation), transformations (transpose, inverse, diagonalization), and element-wise operations (logarithm, tolerance-based comparisons) tailored for phylogenetic analysis. It operates on matrices represented as `Phylogenetics.Linear_algebra.mat` with vector manipulation capabilities, enabling in-place modifications, array initialization, and eigen vector computations. These tools are commonly applied to tasks like modeling sequence evolution, computing transition probabilities, and performing eigen decomposition on rate matrices.",
      "description_length": 606,
      "index": 4,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Phylogenetics.Alphabet.Make.Table",
      "library": "phylogenetics",
      "description": "Implements array-based lookup tables with fixed-size, integer-indexed storage for efficient retrieval and mutation of elements. Supports operations like initialization with index-dependent values, mapping over elements, folding with accumulators, and conditional counting. Useful for representing and manipulating discrete sequence data, such as nucleotide or amino acid frequencies in phylogenetic models.",
      "description_length": 406,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.MCMC.M.Alignment",
      "library": "phylogenetics",
      "description": "Handles alignment data in a phylogenetic MCMC context, providing direct access to sequences and individual bases. Works with DNA sequences stored as strings and alignment structures containing named sequences. Enables reading from FASTA files, converting lists to alignments, and writing alignments to files, with utilities for querying sequence length, number of sequences, and comparing alignments for equality.",
      "description_length": 413,
      "index": 6,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Phylogenetics.Linear_algebra_tools.Lacaml.Vec",
      "library": "phylogenetics",
      "description": "This module provides vector arithmetic operations such as addition, element-wise multiplication, and exponentiation, along with statistical functions like sum, min, and max. It works specifically with dense float vectors, supporting initialization from index functions and element access. Concrete use cases include numerical computations in phylogenetic analysis, such as manipulating probability distributions or rate matrices.",
      "description_length": 429,
      "index": 7,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Phylogenetics.Linear_algebra_tools.Lacaml.Mat",
      "library": "phylogenetics",
      "description": "This module implements matrix operations including creation, multiplication, exponentiation, inversion, and diagonalization, working with matrices represented as `mat` types. It supports tasks like initializing diagonal matrices from vectors, computing matrix powers with scaling, and comparing matrices with tolerance thresholds. Specific use cases include phylogenetic model computations requiring matrix exponentiation, likelihood calculations using matrix inversion, and spectral decomposition for rate matrix analysis.",
      "description_length": 523,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.MCMC.M.Felsenstein",
      "library": "phylogenetics",
      "description": "Implements Felsenstein's algorithm for phylogenetic likelihood calculation under the K80 substitution model. It supports site-specific and whole-alignment likelihood evaluations, with and without branch length shift adjustments. Useful for Bayesian inference in phylogenetic analysis using MCMC methods.",
      "description_length": 303,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Sigs.BASE",
      "library": "phylogenetics",
      "description": "This module defines operations for converting between base types (like DNA nucleotides) and their integer and string representations. It includes functions for mapping characters and integers to the base type, printing bases, and retrieving the size of the base alphabet. Concrete use cases include parsing sequence data and encoding bases for computational processing.",
      "description_length": 369,
      "index": 10,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Alphabet.S-Vector",
      "library": "phylogenetics",
      "description": "This module provides arithmetic operations, element-wise transformations, and logarithmic/exponential functions for float-based vectors representing phylogenetic symbol probabilities. It supports normalization, summation, and conversion from arrays or other vector types, with index-aware iteration and folding patterns for tasks like likelihood calculations or frequency distribution adjustments. These operations target symbol-labeled vectors used in phylogenetic models to manipulate evolutionary rate parameters or character state probabilities.",
      "description_length": 549,
      "index": 11,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Phylogenetics.Linear_algebra.Vector",
      "library": "phylogenetics",
      "description": "This module implements basic linear algebra operations on vectors of floats, including element-wise transformations, arithmetic operations, and statistical functions. It supports operations such as mapping a function over elements, scalar and vector addition, element-wise multiplication, computing the sum, min, max, and applying logarithmic or exponential functions. Use cases include numerical computations in phylogenetic algorithms, such as likelihood calculations or parameter transformations.",
      "description_length": 499,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Simulator.Make",
      "library": "phylogenetics",
      "description": "This module simulates evolutionary processes on phylogenetic trees using continuous-time Markov chain models. It provides functions for generating state transitions across tree branches via methods like the Gillespie algorithm and matrix exponentiation, supporting both single-site and sequence-level evolution. Operations include simulating root states, propagating states down branches, and handling site-specific or position-dependent rate models, making it suitable for tasks like synthetic phylogeny generation or likelihood evaluation in Bayesian inference.",
      "description_length": 563,
      "index": 13,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Codon.Genetic_code-NS-Vector",
      "library": "phylogenetics",
      "description": "This module provides numerical vector operations for codon and nucleotide sequences, supporting arithmetic, element-wise transformations, and aggregation over fixed-size vectors. It works with `NS.vector` structures that pair codon-related symbols (e.g., nucleotides or amino acids) with associated floating-point values, enabling tasks like codon frequency normalization, probabilistic modeling, or phylogenetic signal processing. Specific use cases include analyzing codon usage bias, integrating with linear algebra libraries via array conversions, and robust equality checks for numerical stability in evolutionary sequence comparisons.",
      "description_length": 640,
      "index": 14,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Sequence_simulator.Alphabet-Vector",
      "library": "phylogenetics",
      "description": "Implements vector operations over a biological sequence alphabet, supporting weighted random sampling and probability distribution manipulations. Works with float arrays and a defined alphabet type to generate stochastic sequences. Useful for simulating phylogenetic sequences with specified base frequencies or mutation probabilities.",
      "description_length": 335,
      "index": 15,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Mutsel.NSCodon_rate_matrix",
      "library": "phylogenetics",
      "description": "This module implements codon-level mutation-selection models with functions to construct and manipulate transition rate matrices and stationary distributions. It operates on codon types and vectors, supporting concrete models like Jukes-Cantor (JC69) and General Time-Reversible (GTR) for phylogenetic analysis. Use cases include modeling codon substitution rates under selective constraints and computing equilibrium frequencies for sequence evolution studies.",
      "description_length": 461,
      "index": 16,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Seq.Make",
      "library": "phylogenetics",
      "description": "Implements sequence storage and manipulation using arrays, with support for base types conforming to the BASE signature. Provides operations to convert sequences to and from lists and strings, access elements by index, and determine sequence length. Useful for handling genetic or molecular sequences efficiently in array form.",
      "description_length": 327,
      "index": 17,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Site_evolution_model.K80_numerical",
      "library": "phylogenetics",
      "description": "Implements the Kimura 2-parameter (K80) model with numerical computation of transition probability matrices, rate matrices, and stationary distributions for nucleotide sequences. Provides direct calculations for substitution probabilities and equilibrium frequencies, supporting phylogenetic inference tasks such as likelihood computation and parameter estimation. Exposes matrix decomposition routines useful for spectral analysis of nucleotide evolution dynamics.",
      "description_length": 465,
      "index": 18,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Phylogenetics.Codon.Genetic_code-NS-Matrix",
      "library": "phylogenetics",
      "description": "This module provides numerical matrix operations\u2014including addition, multiplication, inversion, and diagonalization\u2014alongside specialized tools for nucleotide substitution matrix manipulation, such as eigen vector computation and matrix initialization from functional definitions. It operates on matrices and vectors of type `NS.Matrix.t` and `NS.vector`, designed for tasks like modeling codon substitution patterns and analyzing phylogenetic relationships. Applications include genetic code analysis with numerical stability ensured through tolerance-based equality checks and in-place transformations.",
      "description_length": 604,
      "index": 19,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Codon.Matrix",
      "library": "phylogenetics",
      "description": "This module provides linear algebra operations for codon-structured matrices, including multiplication, inversion, exponentiation, and element-wise transformations, alongside tools to construct and analyze codon substitution matrices. It works with dense matrices (`t`) and vectors indexed by codons, supporting tasks like eigenvalue decomposition for stationary distribution calculations. Key applications include modeling codon substitution rates, computing transition probability matrices for phylogenetic inference, and analyzing genetic code optimization landscapes.",
      "description_length": 571,
      "index": 20,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Amino_acid.Vector",
      "library": "phylogenetics",
      "description": "This module implements numerical operations and linear algebra primitives for fixed-size vectors where each element corresponds to an amino acid symbol (0\u201319). It supports arithmetic operations like scalar multiplication, element-wise transformations, folding, and normalization, working with arrays indexed by integer-encoded amino acid types. These vectors are used in evolutionary analysis tasks such as modeling substitution rates and calculating probabilities across phylogenetic trees.",
      "description_length": 491,
      "index": 21,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Phylogenetics.Sigs.SEQUENCE",
      "library": "phylogenetics",
      "description": "This module defines operations for handling sequences of biological bases, such as DNA. It supports construction from lists and strings, indexing, length retrieval, and pretty-printing. Concrete use cases include representing and manipulating genetic sequences in phylogenetic analysis.",
      "description_length": 286,
      "index": 22,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Site_evolution_model.K80",
      "library": "phylogenetics",
      "description": "Implements the Kimura 1980 (K80) nucleotide substitution model with analytical diagonalization. Provides functions to compute the rate matrix, transition probability matrix, stationary distribution, and eigendecomposition components for a given kappa parameter. Useful for phylogenetic analysis requiring accurate modeling of transitional and transversional nucleotide changes over time.",
      "description_length": 387,
      "index": 23,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Phylogenetics.Seq.Base",
      "library": "phylogenetics",
      "description": "Implements core operations for manipulating biological sequence data, including conversion between base types and characters. Works with polymorphic sequence types and character encodings to support DNA, RNA, or protein sequences. Used to build typed sequence modules from character-based input, such as parsing FASTA files or constructing aligned sequence datasets.",
      "description_length": 366,
      "index": 24,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Seq.Make_list",
      "library": "phylogenetics",
      "description": "Implements list-backed biological sequence storage with constant-time indexing and conversion to/from strings. Operates on base elements from a parameter module, supporting sequence construction from lists or strings with strict validation. Useful for handling genetic sequences like DNA or protein strings where direct access and string serialization are required.",
      "description_length": 365,
      "index": 25,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Site_evolution_model.S",
      "library": "phylogenetics",
      "description": "This module defines core data types for parameters, vectors, and matrices used in phylogenetic evolution models. It provides functions to compute the rate matrix, transition probability matrix over time, and stationary distribution from model parameters. These operations support likelihood calculations and ancestral state reconstructions in phylogenetic analysis.",
      "description_length": 365,
      "index": 26,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Phylogenetics.Alphabet.S-Table",
      "library": "phylogenetics",
      "description": "Implements a compact lookup table for fixed-size alphabets, supporting constant-time access and in-place updates. Works with integer-based symbols and arbitrary associated values like probabilities or counts. Used to represent substitution models, character frequencies, and emission profiles in phylogenetic inference.",
      "description_length": 319,
      "index": 27,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Alphabet.S_int",
      "library": "phylogenetics",
      "description": "Implements integer-based alphabet symbols with comparison, equality, and conversion operations. Provides vector and matrix modules for numerical computations over alphabet elements. Used to represent and manipulate discrete character states in phylogenetic models, such as nucleotide or amino acid sequences.",
      "description_length": 308,
      "index": 28,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Linear_algebra.Matrix",
      "library": "phylogenetics",
      "description": "This module enables creating and manipulating square float matrices and vectors through arithmetic operations, element-wise transformations, and linear algebra routines like eigen-decomposition, inversion, and matrix-vector products. Optimized for symmetric matrices and in-place updates, it supports phylogenetic tasks such as modeling evolutionary transitions, computing pairwise distances, and solving systems for tree inference.",
      "description_length": 432,
      "index": 29,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Newick.Tree_repr",
      "library": "phylogenetics",
      "description": "This module defines core tree and branch structures for representing parsed Newick format phylogenetic trees, including node metadata and optional branch lengths. It provides operations to convert between abstract syntax trees and concrete tree representations, and to transform or extract data from internal tree structures. Use cases include manipulating tree topologies, annotating nodes, and extracting subtree information for analysis or serialization.",
      "description_length": 457,
      "index": 30,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Iupac_nucleotide.Vector",
      "library": "phylogenetics",
      "description": "This module implements numerical operations on fixed-size vectors mapping IUPAC nucleotide symbols to float values, supporting arithmetic (addition, multiplication, logarithmic/exponential transforms), comparisons (min/max), and transformations (folding, mapping, normalization). It provides in-place and functional variants for tasks like probability distribution manipulation, frequency spectrum analysis, and handling ambiguous nucleotide positions in phylogenetic data. Key applications include statistical modeling of nucleotide state probabilities and computational operations on genomic sequence uncertainty.",
      "description_length": 615,
      "index": 31,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Phylogenetics.Alphabet.S-Matrix",
      "library": "phylogenetics",
      "description": "This module implements matrix and vector operations tailored for phylogenetic models, supporting arithmetic, element-wise transformations, and linear algebra routines like diagonalization and inversion. It operates on dense matrices and vectors, with specialized functions to initialize substitution rate matrices from symbol mappings, enforce constraints like unit-sum eigenvectors for stationary distributions, and handle numerical precision in evolutionary model computations. Use cases include parameterizing transition probability matrices, solving differential equations for sequence evolution, and performing likelihood calculations under phylogenetic models.",
      "description_length": 666,
      "index": 32,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Phylo_ctmc.Path_sampler",
      "library": "phylogenetics",
      "description": "This module provides algorithms for sampling substitution paths in continuous-time Markov chains on phylogenetic trees. It supports rejection sampling and uniformization-based path generation, working with transition rate matrices and branch lengths. It is used to simulate state transitions along tree edges, conditioned on start and end states, with applications in evolutionary modeling and ancestral state reconstruction.",
      "description_length": 425,
      "index": 33,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Phylogenetics.Rate_matrix.Make",
      "library": "phylogenetics",
      "description": "This module constructs and manipulates continuous-time Markov chain rate matrices over a state space provided by module A. It supports creating general and symmetric rate matrices, standard models like JC69 and GTR, and computing stationary distributions. Concrete use cases include modeling nucleotide substitution rates in phylogenetic analysis and rescaling matrices for time-normalized evolutionary simulations.",
      "description_length": 415,
      "index": 34,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Phylogenetics.Simulator.Branch_info",
      "library": "phylogenetics",
      "description": "Represents branch information in phylogenetic trees with a focus on branch lengths. Provides access to the length of a branch as a float. Used to model evolutionary distances between nodes in a tree structure.",
      "description_length": 209,
      "index": 35,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Codon.Genetic_code-NS",
      "library": "phylogenetics",
      "description": "This module provides operations for manipulating codons and genetic codes, including codon comparison, integer/string conversion, synonymy checks, and neighbor detection. It works with nucleotide sequences (`NS.t`), codon triplets, and numerical abstractions like vectors and matrices to model codon profiles and substitution rates. These tools are particularly useful for phylogenetic analysis tasks such as modeling codon usage bias, constructing evolutionary matrices, and translating sequences under variant genetic codes.",
      "description_length": 526,
      "index": 36,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Phylogenetics.Felsenstein.Make",
      "library": "phylogenetics",
      "description": "Implements Felsenstein's pruning algorithm for computing the likelihood of phylogenetic trees given aligned sequences at the leaves. It supports both single-site and multi-site likelihood calculations, with and without underflow prevention, using evolutionary parameters from module E and alignment data from module Align. This module is used to evaluate the probability of observed sequence data under a given tree and substitution model.",
      "description_length": 439,
      "index": 37,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Sequence_generation.Make",
      "library": "phylogenetics",
      "description": "Implements sequence simulation over phylogenetic trees using a specified alphabet and evolutionary model. It generates raw sequences, aligned sequences, or string representations based on substitution probabilities and tree topology. Useful for simulating genetic data under specific evolutionary parameters for analysis or testing inference tools.",
      "description_length": 348,
      "index": 38,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Sequence_generation.Base",
      "library": "phylogenetics",
      "description": "Implements base operations for sequence generation in phylogenetic simulations. Provides conversion between base types and integers with `to_int` and `of_int_exn`. Used to generate and manipulate DNA or amino acid sequences during evolutionary tree simulations.",
      "description_length": 261,
      "index": 39,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Sequence_simulator.Alphabet",
      "library": "phylogenetics",
      "description": "Defines operations for converting characters to and from a fixed-size enumerated type, including cardinality retrieval, integer-to-type conversion, and character encoding. Works with a polymorphic type `t` representing alphabet symbols and a vector module for sequence manipulation. Used to simulate character evolution over phylogenetic trees by mapping states to characters.",
      "description_length": 376,
      "index": 40,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Phylogenetics.Linear_algebra.S-Vector",
      "library": "phylogenetics",
      "description": "This module implements vector operations for numerical computations, including initialization, element-wise transformations, arithmetic operations, and statistical reductions. It works with dense vectors of type `vec`, supporting operations like scalar multiplication, vector addition, element-wise logarithm and exponential, and comparison with tolerance. Concrete use cases include processing evolutionary trait data, optimizing phylogenetic likelihood calculations, and implementing numerical algorithms requiring vector arithmetic.",
      "description_length": 535,
      "index": 41,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Phylogenetics.Alignment.Fasta",
      "library": "phylogenetics",
      "description": "Reads and writes sequence alignments to FASTA files, handling both successful and error cases. Works directly with alignment data structures, which consist of named sequences of equal length. Used to persist alignments to disk or load them for analysis tasks like phylogenetic tree reconstruction.",
      "description_length": 297,
      "index": 42,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Phylogenetics.Nucleotide.Table",
      "library": "phylogenetics",
      "description": "This module implements a table structure indexed by DNA bases, supporting initialization from functions, arrays, or vectors. It provides operations to get and set values, map over entries, fold with or without indices, and count elements based on predicates. It is used to model nucleotide-specific properties like mutation rates, base frequencies, or scoring matrices in phylogenetic analysis.",
      "description_length": 394,
      "index": 43,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Seq.S",
      "library": "phylogenetics",
      "description": "This module represents sequences of bases such as DNA, providing operations to access elements by index, convert to and from lists and strings, and print sequences. It works with a specified base type and an abstract sequence type, supporting concrete tasks like parsing sequence data from strings and serializing sequences for output. Use cases include handling genetic data in formats like FASTA and performing sequence alignment.",
      "description_length": 432,
      "index": 44,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Phylogenetics.Alignment.Phylip",
      "library": "phylogenetics",
      "description": "This module provides functions to convert sequence alignments to and from the Phylip file format. It supports parsing alignments from Phylip-formatted files, with options for strict parsing, and converting existing alignments into Phylip representations. The primary data structures involved are sequence alignments and Phylip-formatted data, used for interoperability with phylogenetic analysis tools that consume or produce Phylip files.",
      "description_length": 439,
      "index": 45,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Simulator.NSCodon",
      "library": "phylogenetics",
      "description": "This module simulates codon sequence evolution across phylogenetic trees using continuous-time Markov models. It provides functions to generate sequences at tree nodes via exponential-time and Gillespie stochastic simulation methods, supporting per-site and per-branch mutation events. It works with codon states represented as arrays or individual nodes, and uses rate matrices parameterized by a user-defined BI module to model mutation-selection balance. Concrete use cases include simulating coding sequence alignments under selection, modeling site-specific evolutionary trajectories, and generating synthetic phylogenetic data for testing inference algorithms.",
      "description_length": 666,
      "index": 46,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Nucleotide.Vector",
      "library": "phylogenetics",
      "description": "This module implements arithmetic and transformation operations for fixed-size vectors indexed by DNA nucleotide symbols (A, C, G, T), supporting scalar and vector addition/multiplication, element-wise logarithmic/exponential functions, and normalization. It works with vectors storing float values per nucleotide, enabling tasks like probability distribution manipulation or substitution rate matrix operations in phylogenetic models. Key utilities include folding over nucleotide-value pairs, converting arrays to vectors, and tolerance-based equality checks for numerical stability in evolutionary analyses.",
      "description_length": 610,
      "index": 47,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Site_evolution_model.Diagonalizable_rate_matrix",
      "library": "phylogenetics",
      "description": "Implements diagonalization of rate matrices for phylogenetic models, providing functions to compute eigenvalues, eigenvectors, and matrix exponentials. Operates on parametric models, matrices, and vectors to enable likelihood calculations and ancestral state reconstructions. Useful for time-dependent transition probability computations in phylogenetic tree analysis.",
      "description_length": 368,
      "index": 48,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Codon.S-Matrix",
      "library": "phylogenetics",
      "description": "This module implements matrix operations tailored for codon-based phylogenetic models, supporting arithmetic (addition, multiplication), transformations (transpose, inverse), and numerical stability checks for floating-point matrices. It provides codon-specific functionality like constructing rate matrices from biochemical properties, computing eigen vectors for stationary distributions, and visualizing substitution probability patterns. These tools are used to model codon evolution dynamics, estimate transition probabilities in genetic sequences, and analyze phylogenetic relationships through matrix diagonalization and exponentiation techniques.",
      "description_length": 654,
      "index": 49,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Site_evolution_model.Rate_matrix",
      "library": "phylogenetics",
      "description": "Implements operations for computing and manipulating rate matrices used in phylogenetic models. Provides functions to calculate matrix exponentials, eigenvalues, and transition probabilities over time. Works directly with numeric types and matrix structures to model evolutionary changes at specific sites.",
      "description_length": 306,
      "index": 50,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Codon.Genetic_code",
      "library": "phylogenetics",
      "description": "This module implements the universal genetic code and NCBI-defined variants, providing functions to map codons to amino acids and identify stop codons. It supports operations such as checking whether a codon encodes a stop signal, translating codons to amino acids, and determining codon synonymy. Concrete use cases include parsing genomic sequences, analyzing coding regions for stop mutations, and comparing codon usage across species.",
      "description_length": 438,
      "index": 51,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Nucleotide.Matrix",
      "library": "phylogenetics",
      "description": "This module supports matrix arithmetic, element-wise transformations, and structural analysis for DNA base matrices, including addition, multiplication, inversion, logarithmic operations, and eigenvector computation under sum-to-one constraints. It operates on matrices and vectors representing DNA bases, enabling symmetric initialization, normalization, and visualization for phylogenetic models. Key use cases include evolutionary rate matrix analysis, equilibrium distribution calculation, and symmetric transition probability modeling in molecular evolution studies.",
      "description_length": 571,
      "index": 52,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Rate_matrix.Nucleotide",
      "library": "phylogenetics",
      "description": "This module constructs and manipulates nucleotide substitution rate matrices for continuous-time Markov models used in phylogenetics. It supports specific models like JC69, K80, HKY85, and GTR, allowing definition of symmetric or general transition rates, scaling matrices to desired evolutionary rates, and computing stationary distributions. Concrete use cases include setting up model parameters for sequence evolution simulations, likelihood calculations, and phylogenetic tree inference.",
      "description_length": 492,
      "index": 53,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Alphabet.Make",
      "library": "phylogenetics",
      "description": "This module provides integer-based alphabets for representing biological sequence characters, supporting safe and unsafe conversions, comparisons, and enumeration of valid values. It includes data structures for mutable float-based counts, profiles, and matrices, enabling in-place updates and access via float accessors, which are essential for frequency estimation and substitution matrix modeling in phylogenetics. The module supports matrix arithmetic, eigen decomposition, and element-wise operations through its matrix submodule, allowing for transition probability calculations and rate matrix analysis. Additionally, it offers array-based lookup tables for efficient storage and manipulation of indexed biological data, such as nucleotide or amino acid frequencies, with mapping, folding, and conditional counting capabilities.",
      "description_length": 835,
      "index": 54,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Alignment.Make",
      "library": "phylogenetics",
      "description": "This module constructs a sequence alignment from various input formats, supporting operations to access individual bases, determine alignment dimensions, and serialize alignments to files. It works with textual sequence data where each sequence has a unique index and associated description. Concrete use cases include parsing FASTA files into alignments, comparing alignment equality, and printing alignments in a readable format.",
      "description_length": 431,
      "index": 55,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Codon.Genetic_code-NS-Table",
      "library": "phylogenetics",
      "description": "This module provides operations for creating and manipulating tables indexed by nucleotide sequences (codons), supporting initialization, mapping, folding, and probabilistic selection based on codon values. It works directly with codon-based data structures such as `NS.table` and `NS.vector`, enabling concrete tasks like building genetic code mappings, computing codon usage frequencies, or sampling codons according to specified probabilities. Specific use cases include modeling genetic code variations, simulating codon evolution, and analyzing sequence-specific mutation rates.",
      "description_length": 583,
      "index": 56,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Phylogenetics.Site_evolution_model.Nucleotide_S_with_reduction",
      "library": "phylogenetics",
      "description": "Implements nucleotide substitution models with state reduction, handling transition matrices, rate matrices, and stationary distributions. Provides operations to compute matrix exponentials for transition probabilities and reduce model complexity via matrix decomposition. Useful for phylogenetic analysis where model simplification improves computational efficiency in likelihood calculations.",
      "description_length": 394,
      "index": 57,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Alphabet.S",
      "library": "phylogenetics",
      "description": "Implements integer-based DNA, RNA, and protein alphabets with associated comparison, enumeration, and cardinality operations. Provides functions to convert symbols to integers, count symbol frequencies in sequences, and construct flat or random frequency profiles. Includes table, vector, and matrix modules for managing substitution rates and probability distributions over alphabet symbols.",
      "description_length": 392,
      "index": 58,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Codon.Table",
      "library": "phylogenetics",
      "description": "This module implements a lookup table for codon-specific data, supporting operations like initialization, value retrieval, mutation, and mapping over codons. It works with codons as keys and associates arbitrary values with them, enabling tasks like probability sampling and aggregation. Concrete use cases include modeling codon substitution probabilities and encoding genetic code mappings.",
      "description_length": 392,
      "index": 59,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Linear_algebra.S",
      "library": "phylogenetics",
      "description": "This module implements core linear algebra operations for vectors and matrices, including dot products, matrix multiplication, and vector transformations. It defines types `vec` and `mat` to represent vectors and matrices, supporting numerical computations required for phylogenetic analysis. Specific use cases include computing evolutionary distance metrics and manipulating sequence data through matrix operations.",
      "description_length": 417,
      "index": 60,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Phylogenetics.Phylo_ctmc.SV",
      "library": "phylogenetics",
      "description": "This module provides vector arithmetic operations such as addition, multiplication, scaling, and matrix-vector multiplication, specifically for shifted vectors used in phylogenetic likelihood calculations. It supports operations tailored for continuous-time Markov chain models on trees, including specialized multiplication and decomposition-based transformations. These functions are used to manipulate conditional likelihoods and substitution mappings during phylogenetic analysis.",
      "description_length": 484,
      "index": 61,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Phylogenetics.Amino_acid.Table",
      "library": "phylogenetics",
      "description": "This module provides operations for working with fixed-size tables indexed by amino acid values, supporting initialization, access, modification, and transformations of table elements. It handles tables mapping amino acids to arbitrary values, enabling use cases like probability distributions over amino acids, scoring matrices, or frequency counters. Functions include mapping, folding, counting, and sampling operations, with direct conversions from arrays and vectors for numerical computations.",
      "description_length": 499,
      "index": 62,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Site_evolution_model.Make",
      "library": "phylogenetics",
      "description": "Implements site-specific evolutionary models by computing transition probability matrices and stationary distributions from model parameters. Operates on matrix and vector data structures provided by the A module, using model-specific parameters from the M module. Enables concrete use cases such as calculating nucleotide substitution probabilities over time and determining equilibrium frequency distributions for phylogenetic analysis.",
      "description_length": 438,
      "index": 63,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Linear_algebra_tools.Lacaml",
      "library": "phylogenetics",
      "description": "This module provides core linear algebra operations for matrices and vectors, including matrix-vector multiplication, scalar multiplication, and in-place arithmetic. It supports advanced operations such as computing stationary distributions and matrix exponentiation, working directly with `mat` and `vec` types. The vector submodule offers arithmetic and statistical operations on dense float vectors, enabling tasks like probability distribution manipulation, while the matrix submodule handles matrix creation, inversion, diagonalization, and exponentiation with support for numerical stability techniques such as scaling. Together, these components enable complex numerical computations used in phylogenetic analysis, such as likelihood calculations, spectral decomposition, and transition matrix exponentiation.",
      "description_length": 816,
      "index": 64,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Codon.S-Vector",
      "library": "phylogenetics",
      "description": "This module provides numerical operations for manipulating codon frequency distributions represented as float vectors indexed by codon symbols. It supports linear algebra operations like scalar multiplication, element-wise arithmetic, and tolerance-aware comparisons, alongside statistical functions for normalization, summation, and extremum detection. These tools are designed for phylogenetic applications such as modeling codon usage biases, analyzing sequence evolution, and computing genetic distance metrics.",
      "description_length": 515,
      "index": 65,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Rate_matrix.Amino_acid",
      "library": "phylogenetics",
      "description": "This module constructs and manipulates amino acid substitution rate matrices for continuous-time Markov models in phylogenetics. It supports creating matrices using arbitrary rate functions, symmetric models like Jukes-Cantor (JC69), and generalized time-reversible (GTR) models with specified exchangeabilities and stationary distributions. Functions also compute stationary distributions numerically and rescale matrices to control transition rates or enforce expected time scaling.",
      "description_length": 484,
      "index": 66,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Amino_acid.Matrix",
      "library": "phylogenetics",
      "description": "This module provides matrix operations for phylogenetic analysis, including arithmetic (addition, multiplication, inversion), eigenvalue computations, and substitution matrix construction, tailored for 20\u00d720 matrices representing amino acid transitions. It works with matrices and vectors indexed by amino acid integers (0\u201319) to model evolutionary substitution rates and equilibrium frequencies. These tools are used to compute transition probabilities, infer evolutionary relationships, and perform linear algebra operations critical for phylogenetic tree inference and molecular evolution modeling.",
      "description_length": 601,
      "index": 67,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Phylogenetics.Rate_matrix.S",
      "library": "phylogenetics",
      "description": "This module implements continuous-time Markov chain rate matrices with operations to construct and manipulate them. It supports creating matrices from transition rate functions, symmetric matrices, and standard models like JC69 and GTR, as well as computing stationary distributions and scaling matrices. It works with symbols representing states, vectors for distributions, and matrices for rate and exchangeability structures. Use cases include modeling nucleotide or amino acid substitutions in phylogenetic analysis and computing transition probabilities over time.",
      "description_length": 569,
      "index": 68,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Phylogenetics.Codon.S-Table",
      "library": "phylogenetics",
      "description": "This module implements a lookup table for codon-specific data, supporting operations like initialization, value retrieval and modification, mapping over codon entries, and statistical sampling. It works with codons as keys and stores values like probabilities or rates for each codon triplet, often used in phylogenetic models. Concrete use cases include modeling codon substitution biases, assigning site-specific amino acid frequencies, and simulating sequence evolution under a given genetic code.",
      "description_length": 500,
      "index": 69,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Phylogenetics.Site_evolution_model.Make_diag",
      "library": "phylogenetics",
      "description": "Implements diagonalizable evolution models by computing transition probability matrices and stationary distributions from model parameters. Uses matrix and vector operations defined in the A module to represent transitions and distributions, enabling concrete calculations for phylogenetic analysis. Useful for simulating and inferring evolutionary processes on trees using diagonalizable rate matrices.",
      "description_length": 403,
      "index": 70,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Phylogenetics.Bppsuite.Cmd",
      "library": "phylogenetics",
      "description": "This module provides functions to execute the `bppml` and `bppseqgen` commands for phylogenetic analysis. It works with biological sequence data, using specified models and tree files to infer maximum likelihood trees or generate synthetic sequences. Concrete use cases include running phylogenetic tree inference with `bppml` and simulating sequence evolution with `bppseqgen`.",
      "description_length": 378,
      "index": 71,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Site_evolution_model.JC69",
      "library": "phylogenetics",
      "description": "Implements the Jukes-Cantor DNA substitution model with analytical diagonalization. Provides functions to compute the rate matrix, transition probability matrix, stationary distribution, and matrix decomposition for nucleotide evolution. Useful for phylogenetic analysis requiring exact solutions for the JC69 model.",
      "description_length": 316,
      "index": 72,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Phylo_ctmc.Uniformized_process",
      "library": "phylogenetics",
      "description": "This module represents a uniformized continuous-time Markov chain process on phylogenetic trees. It provides operations to construct and query transition rate matrices and probability matrices at specific branch lengths. It is used to compute likelihoods and sample substitution mappings efficiently by discretizing the state space over time.",
      "description_length": 342,
      "index": 73,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Codon.Vector",
      "library": "phylogenetics",
      "description": "This module implements numerical operations for codon frequency or probability vectors, enabling arithmetic, logarithmic/exponential transformations, and statistical reductions (e.g., sum, max) with numerical stability. It works with float vectors indexed by codon symbols to represent distributions, supporting normalization, array conversions, and element-wise manipulations with tolerance-aware comparisons. These tools are used for analyzing codon usage biases, modeling genetic code evolution, and preparing input data for phylogenetic inference algorithms.",
      "description_length": 562,
      "index": 74,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Phylogenetics.Alphabet.S_int-Matrix",
      "library": "phylogenetics",
      "description": "This module provides a suite of linear algebra operations tailored for phylogenetic analysis, including matrix creation, arithmetic (addition, multiplication, exponentiation), transformations (transpose, inverse, diagonalization), and element-wise manipulations (logarithm, tolerance-based comparisons). It operates on dense matrices and vectors of floating-point values, with specialized functions for initializing matrices via symbol-pair mappings and computing normalized eigenvectors associated with zero eigenvalues. These capabilities are particularly useful for constructing and analyzing probabilistic evolutionary models, such as deriving equilibrium frequency distributions or transforming substitution rate matrices.",
      "description_length": 727,
      "index": 75,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Phylogenetics.TKF91.Make_simulator",
      "library": "phylogenetics",
      "description": "Simulates sequence alignments with insertions and deletions on a phylogenetic tree using the TKF91 model. It generates sites via a Gillespie direct method, using a rate matrix and insertion rates per branch, and converts the simulated sites into aligned sequences. Works with labeled trees where nodes carry site data and branch-specific information.",
      "description_length": 350,
      "index": 76,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Phylogenetics.Newick_parser.Incremental",
      "library": "phylogenetics",
      "description": "Parses Newick format phylogenetic trees incrementally, starting from a given lexing position. It constructs abstract syntax trees representing the parsed tree structure. Useful for streaming or partial parsing of large tree files.",
      "description_length": 230,
      "index": 77,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Nucleotide_process.Random",
      "library": "phylogenetics",
      "description": "This module generates random nucleotide substitution processes using probabilistic models. It provides functions like `hky85` and `gtr` that sample rate matrices based on Dirichlet and Gamma distributions, producing instances of nucleotide processes with randomized parameters. These are used to simulate realistic evolutionary models by assigning stochastic rate variations across transitions, transversions, and nucleotide frequencies.",
      "description_length": 437,
      "index": 78,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Alphabet.S_int-Table",
      "library": "phylogenetics",
      "description": "This module implements a lookup table for fixed-size integer-based alphabets, supporting operations like initialization, value retrieval and update, mapping over elements, and folding with or without indices. It works with integer keys (`t`) and associated values of arbitrary type `'a`, typically used for representing and manipulating biological sequence data. Concrete use cases include scoring residue substitutions, computing site likelihoods, and sampling characters based on probability distributions.",
      "description_length": 508,
      "index": 79,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Codon.Universal_genetic_code",
      "library": "phylogenetics",
      "description": "This module implements the universal genetic code, mapping codons to amino acids and identifying stop signals in DNA sequences. It provides core operations to translate codons, check for synonymous variants, and analyze coding regions, supporting applications such as sequence validation and phylogenetic modeling. The child module extends this functionality by enabling codon decomposition, substitution modeling, and numerical feature extraction, facilitating advanced tasks like codon frequency normalization and equilibrium analysis. Together, they allow both basic translation queries and complex evolutionary comparisons using codon-level transformations and matrix-based methods.",
      "description_length": 686,
      "index": 80,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Alphabet.S_int-Vector",
      "library": "phylogenetics",
      "description": "This module provides arithmetic operations (addition, multiplication, logarithmic and exponential transformations), element-wise manipulations, and aggregation functions (folding, summing, normalization) for float-valued vectors indexed by phylogenetic alphabet symbols. It operates on two core representations: dense float arrays (`Vector.t`) and symbol-indexed maps (`vector`), enabling efficient numerical computations and error-resilient conversions between data structures. These capabilities support tasks like probabilistic model calibration, evolutionary distance calculations, and numerical stabilization in phylogenetic tree inference.",
      "description_length": 645,
      "index": 81,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Iupac_nucleotide.Table",
      "library": "phylogenetics",
      "description": "This module implements a lookup table indexed by IUPAC nucleotide symbols, supporting operations like initialization, value retrieval, and in-place updates. It provides mapping, folding, and counting functions that operate over IUPAC symbols and their associated values, enabling efficient manipulation of nucleotide-related data. Concrete use cases include modeling nucleotide substitution probabilities, managing ambiguity codes in sequence alignments, and sampling nucleotides based on weighted distributions.",
      "description_length": 512,
      "index": 82,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Sigs.EVOL_MODEL",
      "library": "phylogenetics",
      "description": "This module defines an evolution model interface with operations to compute transition probabilities between base states, diagonalize transition matrices, and retrieve stationary distributions. It works with base types representing nucleotides or amino acids and uses linear algebra structures like matrices and vectors for calculations. Concrete use cases include modeling DNA sequence evolution over time and computing likelihoods for phylogenetic tree inference.",
      "description_length": 465,
      "index": 83,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Rejection_sampling.Make",
      "library": "phylogenetics",
      "description": "This module implements rejection sampling for phylogenetic trees using a specified alignment module. It generates candidate trees, filters them based on alignment criteria, and computes statistics on tree branches. Key operations include tree generation, sample rejection using alignment scores, and calculating mean branch lengths.",
      "description_length": 332,
      "index": 84,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Sequence_generation.Sequence",
      "library": "phylogenetics",
      "description": "Implements sequence simulation for phylogenetic analysis, supporting operations to generate and manipulate biological sequences. Works with abstract sequence types (`t`) composed of base elements (`base`, typically nucleotides or amino acids), enabling creation from lists and conversion to string representations. Used to model genetic sequence evolution along phylogenetic trees, particularly for simulating ancestral and descendant sequences under specified mutation models.",
      "description_length": 477,
      "index": 85,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Iupac_nucleotide.Matrix",
      "library": "phylogenetics",
      "description": "This module provides matrix arithmetic (addition, multiplication, inversion), element-wise operations (logarithms, multiplication), and transformations (transposition, diagonalization) tailored for nucleotide substitution modeling. It operates on matrices and vectors representing IUPAC nucleotide symbols, enabling precise handling of ambiguous nucleotide states through tolerance-based comparisons and eigen vector computations. Key applications include phylogenetic analysis workflows requiring probabilistic modeling of nucleotide evolution and ambiguity-aware sequence alignment processing.",
      "description_length": 595,
      "index": 86,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Phylogenetics.Sequence_simulator.Make",
      "library": "phylogenetics",
      "description": "This module simulates biological sequences using probabilistic profiles and position weight matrices. It generates random profiles and PWMs, draws symbols from these distributions, and converts profiles to vectors. It is used to create synthetic sequence data for testing phylogenetic inference or alignment algorithms.",
      "description_length": 319,
      "index": 87,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Felsenstein.Alignment",
      "library": "phylogenetics",
      "description": "Implements likelihood calculations for phylogenetic trees using sequence alignments. Provides functions to retrieve base values at specific positions in a sequence and determine alignment length. Designed for use with phylogenetic tree inference where leaf sequences are known and likelihoods must be computed site-by-site.",
      "description_length": 323,
      "index": 88,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.MCMC.M",
      "library": "phylogenetics",
      "description": "This module provides tools for handling phylogenetic alignment data and computing likelihoods under a K80 substitution model. It supports reading, constructing, and writing alignments of DNA sequences, along with querying sequence properties and comparing alignment structures. The core functionality includes Felsenstein's algorithm for likelihood calculation, accommodating both site-specific and full-alignment evaluations with optional branch length adjustments. Example uses include loading an alignment from a FASTA file, modifying sequence data, and computing the likelihood of a phylogeny during MCMC inference.",
      "description_length": 619,
      "index": 89,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Phylogenetics.Seq.DNA",
      "library": "phylogenetics",
      "description": "This module represents DNA sequences using nucleotide bases, supporting operations to construct sequences from lists or strings, access individual bases by index, and convert sequences to strings. It works with the `t` type for DNA sequences and `base` type for individual nucleotides. Use this module to parse and manipulate DNA data from biological datasets, such as reading FASTA files or performing sequence alignments.",
      "description_length": 423,
      "index": 90,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.MG94.NSCodon_rate_matrix",
      "library": "phylogenetics",
      "description": "This module constructs and manipulates codon-level rate matrices under the Muse-Gaut 1994 model, supporting both general and symmetric rate functions between codons. It works directly with codon types (`NSCodon.t`), codon vectors, and matrices to represent evolutionary rates and stationary distributions. Concrete use cases include creating Jukes-Cantor (JC69) and General Time-Reversible (GTR) codon rate matrices, scaling matrices by codon frequencies, and computing stationary distributions from rate matrices.",
      "description_length": 514,
      "index": 91,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Site_evolution_model.S_with_reduction",
      "library": "phylogenetics",
      "description": "Implements evolution models with support for state space reduction via aggregation. Provides operations to compute reduced-rate matrices, transition probabilities, and stationary distributions after state merging. Useful for simplifying models in phylogenetic inference where state space size impacts computational efficiency.",
      "description_length": 326,
      "index": 92,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Phylo_ctmc.Ambiguous",
      "library": "phylogenetics",
      "description": "This module computes likelihoods and samples ancestral states for phylogenetic trees with ambiguous leaf observations. It supports continuous-time Markov chain models by allowing leaf states to be partially specified through a boolean predicate, with unobserved or multiply allowed states treated probabilistically. Concrete use cases include handling uncertain taxon assignments in phylogenetic inference and simulating plausible substitutions consistent with ambiguous data.",
      "description_length": 476,
      "index": 93,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Codon.S",
      "library": "phylogenetics",
      "description": "This module provides codon comparison, conversion, and counting operations, along with matrix and vector functions for codon transitions that handle invalid cases using optional return types. It works with codons, codon pairs, and nucleotide sequences, supporting phylogenetic tasks like substitution analysis, transition probability modeling, and genetic code variation handling. The `neighbours` and `nucleotides` functions enable precise nucleotide-level analysis for evolutionary studies.",
      "description_length": 492,
      "index": 94,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Sigs.ALIGNMENT",
      "library": "phylogenetics",
      "description": "This module represents alignments of biological sequences, such as DNA or protein sequences, using a structured format that supports access by sequence index and position. It provides operations to construct alignments from string lists, association lists, or FASTA files, and to retrieve individual bases, measure alignment dimensions, and serialize alignments to files. Concrete use cases include parsing sequence data for phylogenetic analysis, comparing genetic variation across species, and preparing input for evolutionary tree inference.",
      "description_length": 544,
      "index": 95,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Newick_parser.MenhirInterpreter",
      "library": "phylogenetics",
      "description": "This module provides low-level parsing control and state manipulation capabilities for incremental Newick format processing, including token feeding, stack traversal, and environment inspection. It operates on parser checkpoints, stacks, and environments to enable precise handling of lexical input, state transitions, and error recovery during phylogenetic tree parsing. These operations are particularly useful for implementing custom parsing strategies, debugging parser behavior, or extending Newick format support in bioinformatics applications.",
      "description_length": 550,
      "index": 96,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Site_evolution_model.JC69_numerical",
      "library": "phylogenetics",
      "description": "Implements the Jukes-Cantor DNA substitution model using numerical methods to compute transition probabilities. Provides functions to calculate the rate matrix, transition probability matrix for a given time, stationary distribution, and eigen decomposition of the rate matrix. Useful for phylogenetic analysis where nucleotide evolution follows equal rates across all sites.",
      "description_length": 375,
      "index": 97,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Birth_death",
      "library": "phylogenetics",
      "description": "Simulates phylogenetic trees under birth-death models with specified speciation and extinction rates. Works with tree structures where nodes have integer IDs and branches are annotated with lengths. Useful for generating synthetic phylogenies conditioned on time and number of taxa, or simulating trees with specific age and taxon count constraints.",
      "description_length": 349,
      "index": 98,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Newick",
      "library": "phylogenetics",
      "description": "This module parses and constructs phylogenetic trees in the Newick format, supporting trees with named nodes, tags, and branch lengths, and providing detailed parse error messages. It handles input from files or strings, converts to and from an internal tree structure, and supports serialization back to Newick format. The core data structures represent trees and branches with metadata and optional lengths, enabling operations such as topology manipulation, node annotation, and subtree extraction. Example uses include reading and validating tree data from disk, transforming tree structures, and serializing them for downstream analysis or visualization.",
      "description_length": 659,
      "index": 99,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Phylogenetic_tree",
      "library": "phylogenetics",
      "description": "This module supports operations for building, modifying, and analyzing hierarchical tree structures with annotated nodes and weighted edges. It works with trees composed of nodes and leaves containing metadata, numerical branch lengths, and unique indices, offering utilities for structural manipulation, equality checks, and formatted output. Typical applications include evolutionary biology studies requiring tree topology analysis, parameter adjustments, or visualization in Newick format.",
      "description_length": 493,
      "index": 100,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Simulator",
      "library": "phylogenetics",
      "description": "This module simulates sequence evolution along phylogenetic trees using non-stationary codon models, combining tree traversal with mutation modeling to generate ancestral and extant sequences. It supports operations like root state sampling, state propagation via matrix exponentiation or Gillespie algorithms, and computation of substitution probabilities across branches with variable rates. The module handles codon-level evolution through customizable rate matrices and integrates branch length data to model evolutionary distances. Users can simulate coding sequence alignments under selection, generate synthetic phylogenies, or evaluate model fit in complex evolutionary scenarios.",
      "description_length": 688,
      "index": 101,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Codon",
      "library": "phylogenetics",
      "description": "This module handles codon analysis and genetic code translation, offering tools to validate codons, translate them into amino acids, and model codon-based evolutionary processes using NCBI and universal genetic codes. It supports numerical operations through vector and matrix structures, enabling codon frequency normalization, substitution matrix construction, and eigenvalue analysis for phylogenetic modeling. Key data types include codon triplets, translation tables, and float-indexed vectors and matrices tailored for statistical and algorithmic processing. Specific applications include analyzing codon usage bias, simulating sequence evolution, computing transition probabilities, and modeling genetic code variations using numerical stability-aware operations and codon-specific lookups.",
      "description_length": 797,
      "index": 102,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.ID_monad",
      "library": "phylogenetics",
      "description": "This module provides a state monad for generating unique integer identifiers. It supports operations to bind computations sequentially (`let*`), map results (`let+`), and generate fresh IDs (`new_id`). The monad maintains an internal integer state that increments with each new ID, ensuring uniqueness. Use it when building systems that require fresh identifiers, such as labeling nodes in a tree or tracking unique elements in a data structure.",
      "description_length": 445,
      "index": 103,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Newick_lexer",
      "library": "phylogenetics",
      "description": "This module implements a lexer for parsing Newick format phylogenetic trees. It provides functions to convert character streams into lexical tokens recognized by the Newick parser, handling input buffering and state transitions. The lexer processes strings and buffers using Lexing's infrastructure, producing tokens such as identifiers, numbers, and structural symbols required for tree representation.",
      "description_length": 403,
      "index": 104,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Phylogenetics.Site_evolution_model",
      "library": "phylogenetics",
      "description": "This module implements site evolution models for phylogenetic analysis, focusing on nucleotide substitution processes using models like JC69 and K80. It provides data types for parameters, vectors, and matrices, along with operations to compute rate matrices, matrix exponentials, transition probabilities, and stationary distributions. The module supports both numerical and analytical approaches, enabling tasks such as likelihood computation, ancestral state reconstruction, and spectral analysis of evolution dynamics. Submodules handle specialized functions including diagonalization, state reduction, and model simplification, enhancing flexibility for phylogenetic inference and parameter estimation.",
      "description_length": 707,
      "index": 105,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Phylogenetics.Fitch",
      "library": "phylogenetics",
      "description": "This module implements the Fitch algorithm for phylogenetic inference by parsimony, computing ancestral states on evolutionary trees based on observed leaf states. It processes trees with node and branch data, using cost functions to determine minimal state transition costs during a forward pass and selecting optimal ancestral states during a backward pass. Concrete use cases include reconstructing ancestral genetic traits and minimizing evolutionary change assumptions in cladistics analysis.",
      "description_length": 497,
      "index": 106,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Mutsel",
      "library": "phylogenetics",
      "description": "This module implements a mutation-selection model for codon evolution, combining parameterization of nucleotide rates, fitness effects, and gene conversion bias with functions to compute transition rate matrices, stationary distributions, and time-dependent transition probabilities. It supports concrete models like JC69 and GTR, enabling analysis of codon substitution rates under selection and computation of equilibrium frequencies for phylogenetic studies. The API operates on codon types and vectors, allowing simulation of sequence evolution or inference of parameters from genomic alignments. Submodules extend this functionality by providing specialized tools for constructing and manipulating transition matrices and stationary distributions.",
      "description_length": 752,
      "index": 107,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Newick_ast",
      "library": "phylogenetics",
      "description": "This module defines an abstract syntax tree for representing phylogenetic trees in Newick format, including node attributes and branch lengths. It provides functions for constructing and formatting parse errors with positional information from lexing buffers. Use cases include parsing and manipulating tree structures with labeled nodes and weighted branches.",
      "description_length": 360,
      "index": 108,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Rejection_sampling",
      "library": "phylogenetics",
      "description": "This module performs rejection sampling on phylogenetic trees by generating candidates and filtering them based on alignment scores from a provided alignment module. It supports operations such as tree generation, sample rejection based on alignment criteria, and computation of statistics like mean branch lengths. The core data types include trees and alignment scores, with operations to evaluate and filter tree samples. For example, it can generate a set of candidate trees, reject those with low alignment scores, and compute the average branch length of the accepted trees.",
      "description_length": 580,
      "index": 109,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Felsenstein",
      "library": "phylogenetics",
      "description": "This module implements Felsenstein's pruning algorithm to compute the likelihood of phylogenetic trees given fixed sequences at the leaves, using dynamic programming to efficiently traverse the tree and calculate probabilities at internal nodes. It operates on tree structures and sequence alignments, leveraging evolutionary parameters and alignment data to evaluate the likelihood of observed sequences under a given tree and substitution model. The child modules extend this functionality by supporting both single-site and multi-site likelihood calculations, with utilities to access individual sequence positions and alignment lengths, enabling detailed phylogenetic inference tasks such as likelihood computation and model comparison. Specific operations include traversing a tree to compute node probabilities, calculating site-wise likelihoods, and handling numerical underflow during likelihood summation.",
      "description_length": 914,
      "index": 110,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Wag",
      "library": "phylogenetics",
      "description": "This module parses WAG matrices from strings or files into a structured format containing a rate matrix and frequency vector for amino acid substitutions. It processes raw data into numerical representations used in phylogenetic analysis. Direct use cases include loading WAG matrices from standard input or files for model-based tree inference or sequence evolution simulations.",
      "description_length": 379,
      "index": 111,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Phylogenetics.Iupac_nucleotide",
      "library": "phylogenetics",
      "description": "This module represents IUPAC nucleotide symbols as a compact enumerated type and provides validation, comparison, and conversion operations. It supports efficient counting in sequences and includes specialized vector and matrix modules for numerical computations on nucleotide profiles and substitution models. The vector module handles arithmetic, transformations, and statistical modeling of nucleotide states, while the lookup table enables weighted sampling and ambiguity-aware data manipulation. These tools facilitate tasks like parsing ambiguous sequences, computing substitution probabilities, and modeling evolutionary relationships with uncertainty-aware operations.",
      "description_length": 676,
      "index": 112,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Stat_tools",
      "library": "phylogenetics",
      "description": "This module provides functions for sampling branch lengths in phylogenetic trees using custom samplers and handles lists of numerical samples from distributions. It supports operations like reading sample lists from files, computing extrema, and calculating means. Concrete use cases include statistical analysis of evolutionary distances and generating randomized tree branch lengths for simulation studies.",
      "description_length": 408,
      "index": 113,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Discrete_pd",
      "library": "phylogenetics",
      "description": "This module implements an updatable discrete probability distribution with operations to initialize, modify category weights, sample categories, and retrieve total weight. It works with a distribution type `t` and uses standard types like `int`, `float`, and `Gsl.Rng.t` for random number generation. Concrete use cases include stochastic simulations, MCMC sampling, and probabilistic modeling where dynamic probability distributions are required.",
      "description_length": 447,
      "index": 114,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Phylip",
      "library": "phylogenetics",
      "description": "This module parses and writes data in the PHYLIP format, a text-based format for representing multiple biological sequence alignments. It operates on a structured type `t` containing a list of sequence items, each with a name and sequence string, and validates consistent sequence lengths. It supports reading from and writing to files with options for strict or relaxed format handling, ensuring correct formatting and data integrity during phylogenetic analysis workflows.",
      "description_length": 474,
      "index": 115,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Sequence_simulator",
      "library": "phylogenetics",
      "description": "This module simulates biological sequences with customizable alphabets and mutation models, supporting nucleotide or amino acid evolution through direct API functions. It provides core data types for representing sequence alphabets and probability distributions, with operations for weighted random sampling, character encoding, and profile-based sequence generation. Submodules enable vector manipulations over alphabets, conversions between characters and enumerated types, and simulation using position weight matrices. Example uses include generating synthetic datasets for phylogenetic testing, modeling sequence evolution with custom base frequencies, and encoding states for tree-based simulations.",
      "description_length": 705,
      "index": 116,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Phylo_ctmc",
      "library": "phylogenetics",
      "description": "This module computes likelihoods and samples substitution mappings for continuous-time Markov chains on phylogenetic trees using pruning algorithms and path samplers. It supports conditional simulation of internal states, ancestral state imputation, and likelihood evaluation with branch-specific transition probabilities, root frequencies, and shifted vectors for numerical stability. The path sampling submodule simulates state transitions along edges using rejection sampling and uniformization, while the vector submodule provides arithmetic tailored for shifted vectors in likelihood calculations. Additional functionality handles ambiguous leaf observations through probabilistic treatment of unobserved states, enabling analysis with uncertain or partially specified data.",
      "description_length": 779,
      "index": 117,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Nucleotide_process",
      "library": "phylogenetics",
      "description": "This module represents classical parametric models of nucleotide substitution, including JC69, K80, HKY85, and GTR, each defining evolutionary dynamics through structured rate matrices. It directly supports computation of transition rates and stationary distributions, enabling simulation and inference in phylogenetic contexts\u2014such as calculating the probability of A\u2192G substitutions over time. The child module extends this by generating randomized instances of these models, using functions like `hky85` and `gtr` to sample rate matrices based on probabilistic priors like Dirichlet and Gamma distributions. This combination allows both deterministic setup of nucleotide processes and stochastic generation of model parameters for simulation studies.",
      "description_length": 753,
      "index": 118,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Phylogenetics.Zipper",
      "library": "phylogenetics",
      "description": "This module enables efficient navigation and modification of phylogenetic trees through operations like directional movement, branch editing, structural queries, and conversion between tree and zipper representations. It works with tree structures and zipper types that track positional and directional state, supporting use cases such as evolutionary biology analyses where large trees require precise traversal, visualization, or iterative adjustments to branch lengths and topology. Key functions like sliding by distance or orienting nodes cater to tasks like reconstructing evolutionary pathways or analyzing tree robustness.",
      "description_length": 630,
      "index": 119,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Sequence_generation",
      "library": "phylogenetics",
      "description": "This module simulates biological sequence data under evolutionary models, combining tree structures with sequence generation to produce aligned sequences for taxa. It supports mutation rates, base frequencies, and phylogenetic relationships, with core operations for creating, converting, and manipulating sequences. Submodules handle alphabet-specific conversions, raw sequence generation, and abstract sequence modeling, enabling simulations of genetic data for analysis or tool testing. Example uses include generating DNA sequences for a given tree topology or simulating amino acid evolution with custom substitution probabilities.",
      "description_length": 636,
      "index": 120,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Phylogenetics.Rate_matrix",
      "library": "phylogenetics",
      "description": "This module provides tools to construct and manipulate rate matrices for continuous-time Markov processes, enabling modeling of state transitions over time in phylogenetics. It supports creating custom and standard matrices (e.g., JC69, GTR) using transition functions or symmetric definitions, computing stationary distributions, and scaling matrices to control evolutionary rates. Submodules specialize in nucleotide and amino acid substitutions, offering model-specific functions for HKY85, K80, and time-reversible models, with applications in sequence evolution simulations, likelihood calculations, and phylogenetic tree inference. Operations include matrix rescaling, transition probability computation, and numerical estimation of stationary distributions over user-defined state spaces.",
      "description_length": 795,
      "index": 121,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Dna",
      "library": "phylogenetics",
      "description": "This module provides functions to create and analyze DNA sequences represented as strings. It supports creating sequences from raw strings, validated strings, or arrays of codons, and calculates the GC content of a sequence. Use cases include parsing genetic data from files, validating sequence correctness, and performing compositional analysis for bioinformatics applications.",
      "description_length": 379,
      "index": 122,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Alphabet",
      "library": "phylogenetics",
      "description": "This module encodes biological sequence alphabets as integers, enabling efficient storage and manipulation of genetic or amino acid sequences. It supports symbol-to-integer conversion, validation, and complement mapping, with direct applications in sequence preprocessing and alignment. Submodules provide vector and matrix operations for phylogenetic modeling, including probability normalization, substitution rate calculations, and eigen decomposition, while compact lookup tables enable fast, in-place updates for frequency profiles and site likelihood computations. Together, these features facilitate tasks such as constructing transition matrices, estimating evolutionary parameters, and performing likelihood-based tree inference.",
      "description_length": 738,
      "index": 123,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Phylogenetics.Alignment",
      "library": "phylogenetics",
      "description": "This module represents and manipulates sequence alignments, ensuring all sequences are of equal length and paired with descriptive metadata. It provides core operations for accessing sequences and columns, validating alignment integrity, and transforming alignment data for analysis tasks such as identifying conserved sites. The module integrates file-handling submodules for FASTA and Phylip formats, enabling alignment persistence and interoperability with phylogenetic tools. You can load an alignment from a FASTA file, convert it to Phylip format, analyze sequence conservation, and export the results for downstream analysis.",
      "description_length": 632,
      "index": 124,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Newick_parser_errors",
      "library": "phylogenetics",
      "description": "This module defines error codes and their corresponding message strings for parsing Newick format phylogenetic trees. It maps integer error codes to descriptive strings to aid in debugging and error handling during tree parsing. Use this module when interpreting or reporting errors from a Newick parser, particularly in tree file validation or syntax checking.",
      "description_length": 361,
      "index": 125,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Phylogenetics.Amino_acid",
      "library": "phylogenetics",
      "description": "This module encodes the 20 standard amino acids as integers from 0 to 19, enabling efficient numerical manipulation and conversion to character representations. It supports equality checks, comparisons, and the construction of vectors and matrices indexed by amino acid types, with JSON serialization and profile generation. The associated submodules provide linear algebra operations for amino acid vectors and matrices, fixed-size tables mapping amino acids to values, and specialized matrix arithmetic for phylogenetic analysis, such as substitution rate modeling and eigenvalue computations. These tools facilitate sequence alignment, evolutionary modeling, probability distributions, and transition matrix calculations in molecular evolution studies.",
      "description_length": 755,
      "index": 126,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.TKF91",
      "library": "phylogenetics",
      "description": "This module simulates sequence alignments on phylogenetic trees under the TKF91 model, incorporating insertions and deletions. It uses a Gillespie direct method with a rate matrix and branch-specific insertion rates to generate aligned sequences. Nodes in the tree carry site data, enabling accurate tracking of evolutionary events. Example usage includes simulating alignments for a given labeled tree and extracting insertion/deletion histories.",
      "description_length": 447,
      "index": 127,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Phylogenetics.MG94",
      "library": "phylogenetics",
      "description": "This module implements the Muse-Gaut 1994 model for codon evolution, generating rate matrices parameterized by nucleotide substitution rates, codon frequencies, and a single selection coefficient (omega). It supports operations on codon types (`NSCodon.t`), including construction of general and symmetric rate matrices, scaling by codon frequencies, and computation of stationary distributions. Submodules extend this functionality to specific use cases such as building Jukes-Cantor (JC69) and General Time-Reversible (GTR) codon models, enabling simulation of codon evolution under varying selective pressures and estimation of transition probabilities for phylogenetic analysis. Example applications include modeling synonymous and non-synonymous substitution rates under different omega values and inferring evolutionary relationships using codon-based likelihoods.",
      "description_length": 870,
      "index": 128,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Nelder_mead",
      "library": "phylogenetics",
      "description": "This module implements the Nelder-Mead simplex algorithm for minimizing a cost function over an array of floating-point parameters. It provides the `minimize` function, which takes a cost function, an initial parameter sampler, and optional tuning parameters like tolerance and iteration limit. It is suitable for optimizing non-linear, potentially non-differentiable functions in applications such as model fitting or parameter estimation in scientific computing.",
      "description_length": 464,
      "index": 129,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Bppsuite",
      "library": "phylogenetics",
      "description": "This module provides types for representing biological sequence alphabets and substitution models, such as `alphabet` for DNA, RNA, protein, and codon sequences, and `model` for evolutionary models like JC69 and K80. It includes functions to convert these types to string representations, enabling configuration of Bio++ programs through command-line interfaces. The child module extends this functionality by executing `bppml` for phylogenetic tree inference and `bppseqgen` for sequence simulation, using the defined models and tree files. Together, they support tasks like configuring evolutionary analyses, inferring trees from sequence data, and generating synthetic sequences based on specified models.",
      "description_length": 708,
      "index": 130,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Linear_algebra_tools",
      "library": "phylogenetics",
      "description": "This module provides direct access to core linear algebra operations on matrices and vectors, including multiplication, exponentiation, inversion, and spectral decomposition. It supports in-place arithmetic, scalar operations, and advanced numerical methods like computing stationary distributions and matrix exponentials with numerical stability. The `mat` and `vec` types enable precise manipulation of dense linear algebra structures, suitable for tasks such as phylogenetic likelihood computation and transition matrix analysis. Example uses include exponentiating rate matrices to compute transition probabilities and performing spectral decomposition for dimensionality reduction.",
      "description_length": 686,
      "index": 131,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Sigs",
      "library": "phylogenetics",
      "description": "This module establishes a foundational framework for phylogenetic analysis by defining core type aliases and standardized interfaces for handling biological data and evolutionary models. It includes data types for bases, sequences, alignments, and evolution models, with operations for encoding bases, manipulating sequences, computing transition probabilities, and parsing alignment files. Users can convert DNA characters to internal representations, construct and query sequence data, model evolutionary changes using matrices, and work with aligned biological sequences from common formats. The combination of direct type definitions and submodule functionality supports end-to-end processing of genetic data for tree inference and sequence analysis.",
      "description_length": 754,
      "index": 132,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Utils",
      "library": "phylogenetics",
      "description": "This module provides functions for string formatting with colorization, robust floating-point comparisons, and array manipulation including summing values and generating order indices. It defines printers and string representations for float arrays and matrices, supporting pretty-printing in logs or interactive sessions. Specific use cases include formatting phylogenetic data output, comparing numerical results with tolerance, and generating random profiles using GSL random number generators.",
      "description_length": 497,
      "index": 133,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Linear_algebra",
      "library": "phylogenetics",
      "description": "This module provides vector and matrix operations for numerical computations, wrapping the Lacaml library to support tasks like solving linear systems, eigenvalue decomposition, and matrix inversion. It defines core types `vec` and `mat` for dense vectors and matrices, with operations including arithmetic, element-wise transformations, dot products, and decompositions. Submodules focus on specialized vector and matrix routines, enabling efficient manipulation of phylogenetic data such as evolutionary distances, trait modeling, and likelihood optimization. Specific capabilities include in-place updates, statistical reductions, and numerical transformations tailored to computational biology workflows.",
      "description_length": 708,
      "index": 134,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Seq",
      "library": "phylogenetics",
      "description": "This module handles sequence data for phylogenetic analysis, offering operations to manipulate and analyze biological sequences using customizable base types. It supports array-based, list-based, and string-backed sequence storage with direct access, conversion, and serialization, enabling tasks like sequence alignment, mutation tracking, and evolutionary distance calculation. Specific operations include parsing FASTA data, converting between base types and characters, and constructing typed sequences from strings or lists. Modules provide efficient indexing, strict validation, and concrete DNA sequence handling using nucleotide bases.",
      "description_length": 643,
      "index": 135,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Newick_parser",
      "library": "phylogenetics",
      "description": "This module parses Newick-format phylogenetic trees into abstract syntax trees, supporting nested parentheses, branch lengths, and labeled taxa. It enables incremental parsing from arbitrary lexing positions, allowing streaming or partial processing of large tree files. Low-level operations let you manipulate parser state, feed tokens manually, and inspect stacks or environments for custom parsing strategies or error recovery. Use it to build structured representations of phylogenetic trees for analysis, transformation, or custom format extensions in bioinformatics workflows.",
      "description_length": 582,
      "index": 136,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.MCMC",
      "library": "phylogenetics",
      "description": "This module implements a basic Monte Carlo Markov Chain (MCMC) algorithm for phylogenetic inference, combining tree topology and model parameter sampling with support for alignment data handling and likelihood computation. It operates on a vector type that pairs phylogenetic trees with DNA sequence alignments, enabling likelihood evaluations via Felsenstein's algorithm and parameter updates during the MCMC process. The core functionality includes running MCMC chains, computing likelihoods under a K80 substitution model, and modifying sequence data or tree structures during inference. Example uses include sampling tree topologies and substitution rates given sequence data, or refining branch lengths and model parameters using a fixed base tree and alignment.",
      "description_length": 767,
      "index": 137,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Nucleotide",
      "library": "phylogenetics",
      "description": "This module represents DNA nucleotides with typed symbols and supports equality, comparison, and mutation operations, including transversion checks and random generation. It uses vectors and matrices to model nucleotide frequency profiles and transition probabilities, enabling efficient indexed access and numerical computation for phylogenetic analysis. Submodules provide table-based nucleotide indexing, arithmetic operations on nucleotide-indexed vectors, and matrix transformations for evolutionary modeling. Examples include building mutation rate tables, normalizing probability distributions, and computing equilibrium states in substitution models.",
      "description_length": 658,
      "index": 138,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.List1",
      "library": "phylogenetics",
      "description": "This module offers type-safe operations for non-empty lists, ensuring at least one element is always present through construction, transformation, and iteration functions like `cons`, `map`, and `fold`. It works with non-empty lists as the core data structure, providing safe conversions to and from standard lists, while supporting operations such as filtering, sorting, and S-expression serialization. It is particularly useful in domains like phylogenetics where empty collections are invalid, enabling robust processing of biological data and structured data exchange.",
      "description_length": 572,
      "index": 139,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Tree",
      "library": "phylogenetics",
      "description": "This module supports operations for building, transforming, and analyzing phylogenetic trees with annotated nodes, leaves, and branches, including traversal, mapping, and serialization to S-expressions. It enables tasks like collapsing single-child nodes by merging branch annotations, extracting subtrees from leaf sets, and propagating state changes across hierarchical structures, which are critical for modeling evolutionary relationships and processing biological data.",
      "description_length": 474,
      "index": 140,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Phylogenetics",
      "library": "phylogenetics",
      "description": "This module suite provides an integrated framework for phylogenetic analysis, enabling simulation, parsing, manipulation, and inference of evolutionary trees and associated biological sequences. Core data types include phylogenetic trees with annotated nodes and weighted edges, sequence alignments in formats like FASTA and PHYLIP, and numerical structures such as rate matrices, vectors, and probability distributions for modeling evolution. Key operations span tree simulation under birth-death models, sequence evolution using codon and nucleotide substitution models, likelihood computation via pruning algorithms, and MCMC-based inference for tree and parameter estimation. Users can, for example, simulate a phylogeny with specified speciation rates, evolve sequences along its branches, compute alignment likelihoods, and infer ancestral states using parsimony or probabilistic methods.",
      "description_length": 894,
      "index": 141,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 144,
    "meaningful_modules": 142,
    "filtered_empty_modules": 2,
    "retention_rate": 0.9861111111111112
  },
  "statistics": {
    "max_description_length": 914,
    "min_description_length": 209,
    "avg_description_length": 514.1267605633802,
    "embedding_file_size_mb": 0.5162181854248047
  }
}