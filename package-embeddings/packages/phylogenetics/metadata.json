{
  "package": "phylogenetics",
  "embedding_model": "Qwen/Qwen3-Embedding-8B",
  "embedding_dimension": 4096,
  "total_modules": 103,
  "creation_timestamp": "2025-08-18T18:48:12.746671",
  "modules": [
    {
      "module_path": "Phylogenetics.Codon.Universal_genetic_code.NS.Table",
      "library": "phylogenetics",
      "description": "This module implements a specialized table structure for managing mappings from codons to arbitrary values, supporting operations like initialization, lookup, mutation, and transformation of these mappings. It works with codon types defined in the universal genetic code module, enabling precise handling of 64 possible codon entries. Concrete use cases include modeling codon-specific properties such as substitution rates, amino acid assignments, or probabilities for codon selection during sequence evolution.",
      "description_length": 512,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Codon.Universal_genetic_code.NS.Matrix",
      "library": "phylogenetics",
      "description": "The module provides linear algebra operations for codon substitution matrices under the universal genetic code, including matrix addition, multiplication (both element-wise and full matrix), inversion, diagonalization, and element-wise transformations like logarithms. It works with matrices and vectors tailored to represent genetic code transformations or codon-level evolutionary models, enabling numerical analysis of phylogenetic processes. Specific applications include computing stationary distributions (via zero eigen vectors satisfying $ m \\cdot v = 0 $ and $ \\sum v = 1 $) and initializing substitution matrices from functional or array-based definitions in probabilistic evolutionary models.",
      "description_length": 703,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Codon.Universal_genetic_code.NS.Vector",
      "library": "phylogenetics",
      "description": "This module provides numerical operations on codon-indexed vectors, supporting element-wise arithmetic, statistical reductions (summing, maxima), and normalization tailored for codon usage frequency analysis. It works with specialized float vectors indexed by codon symbols (nucleotide triplets) under the universal genetic code, enabling efficient computation of synonymous codon comparisons and stop codon-aware phylogenetic models. Specific use cases include codon bias quantification, evolutionary distance calculations, and probabilistic modeling of sequence evolution where codon-specific rates or frequencies require vectorized numerical operations.",
      "description_length": 656,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.MCMC.M.Felsenstein",
      "library": "phylogenetics",
      "description": "Implements Felsenstein's algorithm for phylogenetic likelihood calculation under the K80 substitution model. It supports per-site likelihood computation with optional branch length shifting and thresholding. Designed for use in MCMC frameworks to evaluate tree likelihoods given nucleotide alignments.",
      "description_length": 301,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Alphabet.Make.Vector",
      "library": "phylogenetics",
      "description": "This module provides numerical vector operations for phylogenetic analysis, including arithmetic (addition, multiplication), statistical aggregation (sum, min, max), and element-wise transformations (mapping, folding) over float arrays. It works with typed vectors represented as `Vector.t` (float arrays) and supports initialization from raw arrays, normalization for probability distributions, and indexed operations for sequence alignment scoring or evolutionary model calculations. These functions are particularly useful for handling genetic sequence data, computing evolutionary distances, and manipulating probabilistic models of molecular evolution.",
      "description_length": 657,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Linear_algebra_tools.Lacaml.Vec",
      "library": "phylogenetics",
      "description": "This module implements vector arithmetic and transformations using Lacaml's vector type. It supports operations like element-wise addition, multiplication, logarithm, and exponential, along with aggregation functions for sum, min, and max. These operations are used for numerical computations on phylogenetic data, such as scaling branch lengths or computing likelihoods.",
      "description_length": 371,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Codon.Universal_genetic_code.NS",
      "library": "phylogenetics",
      "description": "This module implements codon-centric operations for phylogenetic analysis, focusing on numerical modeling and sequence comparison tasks. It provides typed representations for codons (`type t`), alongside vector and matrix structures to support substitution rate analysis, codon bias quantification, and evolutionary distance calculations. Core functionalities include codon decomposition into nucleotide triplets, amino acid translation, synonym detection, and integer encoding, enabling applications in comparative genomics and molecular evolution studies.",
      "description_length": 557,
      "index": 6,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Phylogenetics.Alphabet.Make.Matrix",
      "library": "phylogenetics",
      "description": "This module supports linear algebra operations (addition, multiplication, inversion, exponentiation), eigenvalue decomposition, and symmetric matrix initialization for analyzing phylogenetic models. It operates on dense matrices and vectors represented as `Phylogenetics.Linear_algebra.mat` and `vec`, enabling tasks like constructing transition probability matrices and computing evolutionary distance metrics. Specific applications include modeling nucleotide or amino acid substitution rates and solving differential equations for continuous-time Markov processes in phylogenetics.",
      "description_length": 584,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.MCMC.M.Alignment",
      "library": "phylogenetics",
      "description": "Handles alignment data in a deprecated MCMC implementation, providing functions to construct alignments from string lists, association lists, or FASTA files. Exposes operations to access individual bases, alignment length, and sequence count, along with file input/output and equality checks. Designed for phylogenetic analysis tasks involving DNA sequences.",
      "description_length": 358,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Linear_algebra_tools.Lacaml.Mat",
      "library": "phylogenetics",
      "description": "This module provides matrix creation, manipulation, and decomposition operations, including multiplication, exponentiation, diagonalization, and inversion. It works with matrices and vectors represented as `mat` and `vec` types, supporting element-wise operations, power calculations, and logarithms. Concrete use cases include phylogenetic model computations, numerical linear algebra tasks, and scientific computing workflows requiring matrix analysis and transformations.",
      "description_length": 474,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Alphabet.Make.Table",
      "library": "phylogenetics",
      "description": "Implements array-based lookup tables with fixed-size, integer-indexed mappings for alphabet symbols. Provides operations to initialize, access, modify, and transform elements using integer keys, including mapping, folding, and comparison functions. Useful for representing substitution matrices, frequency counts, and probability distributions over discrete sequence alphabets.",
      "description_length": 377,
      "index": 10,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Seq.Make_list",
      "library": "phylogenetics",
      "description": "Implements list-based sequences of bases with operations to convert to and from lists and strings, access elements by index, and format for output. Works directly with base type elements from the provided module and concrete list and string representations. Useful for constructing and manipulating biological sequences from string encodings or list data.",
      "description_length": 355,
      "index": 11,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Iupac_nucleotide.Vector",
      "library": "phylogenetics",
      "description": "This module implements vector operations for IUPAC nucleotide symbols, where each symbol maps to a float value, enabling arithmetic (addition, scalar multiplication), element-wise transformations (log, exp), and aggregation (min, max). It operates on vectors that represent nucleotide uncertainty data, supporting tasks like probability distribution manipulation and normalization in phylogenetic analysis. Key use cases include handling ambiguous nucleotide sequences and computing normalized vectors for evolutionary model parameters.",
      "description_length": 536,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Seq.Make",
      "library": "phylogenetics",
      "description": "This module implements sequence storage and manipulation using arrays, with support for base types defined by the BASE signature. It provides operations to convert sequences to and from lists and strings, access elements by index, and format sequences for output. Concrete use cases include handling genetic sequences efficiently in memory for alignment and analysis tasks.",
      "description_length": 373,
      "index": 13,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Phylogenetics.Newick_parser.MenhirInterpreter",
      "library": "phylogenetics",
      "description": "This module enables low-level parsing operations such as token ingestion, checkpoint manipulation, and stack inspection, alongside environment control mechanisms like state popping and reduction forcing to guide parsing decisions. It operates on Menhir parser components\u2014including checkpoints, LR(1) states, and lexical tokens\u2014to support precise parsing workflows for structured data like Newick-format phylogenetic trees, particularly in incremental or error-resilient scenarios.",
      "description_length": 480,
      "index": 14,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Phylo_ctmc.SV",
      "library": "phylogenetics",
      "description": "This module provides operations for manipulating shifted vectors, including arithmetic operations like addition, scalar and matrix multiplication, and specialized decomposition-based multiplications. It works with the `t` type, which represents shifted vectors, and supports transformations involving matrices and linear algebra operations. Concrete use cases include likelihood computations and conditional sampling in phylogenetic models using continuous-time Markov chains.",
      "description_length": 476,
      "index": 15,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Linear_algebra_tools.Lacaml",
      "library": "phylogenetics",
      "description": "This module implements numerical operations for linear algebra computations using Lacaml's matrix and vector types. It supports matrix-vector multiplication, scalar multiplication, in-place vector scaling, scalar-vector addition, and computation of stationary distributions from matrices. These functions are used for phylogenetic model analysis, including transition matrix manipulations and likelihood calculations.",
      "description_length": 417,
      "index": 16,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.TKF91.Make_simulator",
      "library": "phylogenetics",
      "description": "This module simulates sequence alignments with insertions and deletions on a phylogenetic tree using the TKF91 model. It generates individual sites via a Gillespie direct method, using a rate matrix and insertion/deletion rates per branch, and supports folding over alignment positions or converting sites into string arrays. It operates on trees annotated with branch information and site-specific data, using types from the A and BI modules for states and branch parameters. Concrete use cases include generating synthetic alignments for testing phylogenetic inference methods or simulating evolutionary divergence under specific indel dynamics.",
      "description_length": 647,
      "index": 17,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Newick_parser.Incremental",
      "library": "phylogenetics",
      "description": "Parses Newick format phylogenetic trees incrementally, starting from a given lexing position. It constructs abstract syntax trees representing the tree structure, including branches and labels. Useful for reading and processing large phylogenetic tree files in a streaming fashion.",
      "description_length": 281,
      "index": 18,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Nucleotide_process.Random",
      "library": "phylogenetics",
      "description": "This module samples parametric nucleotide mutation models using random number generators. It provides functions to generate rate matrices and stationary distributions for models like HKY85 and GTR, using Dirichlet and Gamma distributions to sample parameters. Concrete use cases include simulating mutation processes with specified statistical properties, such as generating transition/transversion rates or exchangeability matrices under different evolutionary assumptions.",
      "description_length": 474,
      "index": 19,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Phylogenetics.Sequence_generation.Make",
      "library": "phylogenetics",
      "description": "This module simulates biological sequence evolution across a phylogenetic tree using a given evolutionary model. It generates sequences at tree nodes by applying substitution probabilities and sampling bases based on those probabilities. The module produces aligned sequences in various formats, including raw lists and string-based representations, suitable for downstream analysis or simulation studies.",
      "description_length": 405,
      "index": 20,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.MG94.NSCodon_rate_matrix",
      "library": "phylogenetics",
      "description": "This module constructs and manipulates codon-level rate matrices under the Muse-Gaut 1994 model, supporting both symmetric and general rate functions between codons. It works directly with codon types (`NSCodon.t`), codon vectors, and matrices to compute scaled rate matrices, stationary distributions, and standard models like JC69 and GTR. Concrete use cases include modeling codon substitution rates for phylogenetic analysis, estimating evolutionary distances, and simulating sequence evolution under specified nucleotide or codon exchangeabilities.",
      "description_length": 553,
      "index": 21,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Sequence_simulator.Make",
      "library": "phylogenetics",
      "description": "Implements functions to create and manipulate sequence profiles and position weight matrices (PWMs) using a specified alphabet module. It supports generating random profiles, drawing symbols from profiles, and simulating sequences based on PWMs using GSL random number generators. This module is useful for simulating biological sequences with controlled compositional biases.",
      "description_length": 376,
      "index": 22,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Rejection_sampling.Make",
      "library": "phylogenetics",
      "description": "This module implements rejection sampling for phylogenetic trees and alignment data. It generates candidate trees, filters them based on alignment constraints, and computes statistics on tree branches. Key operations include sampling trees, rejecting invalid configurations, and calculating mean branch lengths.",
      "description_length": 311,
      "index": 23,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Phylogenetics.Site_evolution_model.JC69_numerical",
      "library": "phylogenetics",
      "description": "Implements the Jukes-Cantor DNA substitution model using numerical methods to compute transition probabilities. Provides functions to calculate the rate matrix, transition probability matrix, stationary distribution, and eigendecomposition of the rate matrix. Useful for phylogenetic analysis where nucleotide evolution follows equal substitution rates across sites.",
      "description_length": 366,
      "index": 24,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Iupac_nucleotide.Matrix",
      "library": "phylogenetics",
      "description": "This module supports creation and manipulation of substitution matrices for nucleotide sequence analysis, focusing on operations like diagonalization, arithmetic transformations, and eigenvector computation for zero eigenvalues. It works with matrices and vectors of IUPAC nucleotide symbols, which represent ambiguous nucleotide states, enabling both standard and in-place modifications. These tools are particularly useful in phylogenetic analyses for modeling nucleotide substitution patterns and deriving equilibrium frequencies from ambiguous sequence data.",
      "description_length": 562,
      "index": 25,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Mutsel.NSCodon_rate_matrix",
      "library": "phylogenetics",
      "description": "This module implements codon-level mutation-selection models by constructing transition rate matrices and computing stationary distributions for nucleotide site codon models. It supports general time-reversible (GTR) and Jukes-Cantor (JC69) parameterizations, with functions to scale matrices by codon-specific rates or equilibrium frequencies. Concrete use cases include modeling codon substitution rates under selection, simulating sequence evolution, and inferring evolutionary parameters from aligned genomic data.",
      "description_length": 518,
      "index": 26,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Linear_algebra.Vector",
      "library": "phylogenetics",
      "description": "This module implements vector operations such as element-wise transformations, arithmetic between vectors and scalars, summation, extremum extraction, and direct element access. It works with dense float vectors represented by the type `t`, supporting initialization from functions or arrays, conversion to arrays, and formatted printing. Concrete use cases include numerical computations in phylogenetic algorithms requiring efficient vector manipulations, such as likelihood calculations or parameter transformations.",
      "description_length": 519,
      "index": 27,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Felsenstein.Make",
      "library": "phylogenetics",
      "description": "Implements Felsenstein's pruning algorithm for computing phylogenetic tree likelihoods. It supports single-site and multi-site likelihood calculations with optional underflow prevention, operating on phylogenetic trees and sequence alignments. Directly computes likelihoods for given evolutionary parameters, site positions, and tree topologies.",
      "description_length": 345,
      "index": 28,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Phylo_ctmc.Path_sampler",
      "library": "phylogenetics",
      "description": "This module provides algorithms for sampling substitution paths in continuous-time Markov chains on phylogenetic trees. It supports rejection sampling, uniformization, and hybrid strategies, producing state transition histories between start and end states over a branch. The sampled paths are represented as arrays of (state, time) pairs, suitable for downstream analysis or visualization of evolutionary trajectories.",
      "description_length": 419,
      "index": 29,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Site_evolution_model.JC69",
      "library": "phylogenetics",
      "description": "Implements the Jukes-Cantor DNA substitution model with analytical diagonalization. Provides functions to compute the rate matrix, transition probability matrix, stationary distribution, and eigendecomposition components. Useful for phylogenetic likelihood calculations and evolutionary distance estimation.",
      "description_length": 307,
      "index": 30,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Rate_matrix.Make",
      "library": "phylogenetics",
      "description": "This module constructs and manipulates continuous-time Markov chain rate matrices, supporting operations like creating matrices from transition rate functions, building symmetric matrices, and implementing models such as Jukes-Cantor (JC69) and General Time-Reversible (GTR). It works with abstract matrix and vector types provided by the parameter module `A`, allowing state transitions between typed elements. Concrete use cases include computing stationary distributions, scaling matrices for numerical stability, and modeling nucleotide or amino acid substitution rates in phylogenetic analysis.",
      "description_length": 599,
      "index": 31,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Nucleotide.Table",
      "library": "phylogenetics",
      "description": "Implements a table structure for DNA bases with operations to initialize, access, and modify values associated with each nucleotide. Supports transformations, folds, and statistical operations over nucleotide data. Useful for building substitution models and handling base-specific probabilities or counts.",
      "description_length": 306,
      "index": 32,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Phylogenetics.Site_evolution_model.Make",
      "library": "phylogenetics",
      "description": "Implements site-specific evolutionary models using transition matrices and model parameters. Provides functions to compute transition probability matrices over time and stationary distributions for nucleotide or amino acid states. Useful for phylogenetic analysis tasks such as likelihood calculation and ancestral state reconstruction.",
      "description_length": 336,
      "index": 33,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Codon.Table",
      "library": "phylogenetics",
      "description": "This module provides a mutable table structure for associating codons with arbitrary values, supporting initialization, lookup, modification, and aggregation operations. It works with codons as keys and supports operations like mapping, folding, and weighted random selection using a codon table. Concrete use cases include modeling codon-specific properties such as amino acid translations, mutation probabilities, or fitness values in evolutionary simulations.",
      "description_length": 462,
      "index": 34,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Iupac_nucleotide.Table",
      "library": "phylogenetics",
      "description": "This module implements a fixed-size table indexed by IUPAC nucleotide symbols, supporting operations like initialization, value retrieval and assignment, mapping, folding, and counting. It works with IUPAC nucleotide symbols as keys and arbitrary values, enabling efficient per-symbol computations. Concrete use cases include scoring nucleotide ambiguity in sequence alignments, modeling nucleotide substitution probabilities, and selecting random nucleotides based on weighted distributions.",
      "description_length": 492,
      "index": 35,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Phylo_ctmc.Ambiguous",
      "library": "phylogenetics",
      "description": "This module computes likelihoods and simulates ancestral states for phylogenetic trees with ambiguous leaf observations, where each leaf can be compatible with multiple states. It works with trees parameterized by node and branch data, using transition probability matrices derived from CTMC models and root state frequencies. Concrete use cases include calculating the likelihood of observed sequence data under a substitution model with uncertain leaf states and generating conditional ancestral reconstructions given those ambiguities.",
      "description_length": 538,
      "index": 36,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Site_evolution_model.K80",
      "library": "phylogenetics",
      "description": "Implements the Kimura 2-parameter (K80) model for nucleotide sequence evolution with analytical diagonalization. Provides functions to compute the rate matrix, transition probability matrix, stationary distribution, and matrix decomposition for a given kappa parameter. Used to model DNA substitution patterns with distinct transition and transversion rates in phylogenetic analysis.",
      "description_length": 383,
      "index": 37,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Codon.Matrix",
      "library": "phylogenetics",
      "description": "This module supports numerical and comparative analyses of codon-encoded data through matrix operations like arithmetic, element-wise transformations, and eigenvector computation. It works with codon-specific matrices and vectors to model phylogenetic relationships, enabling tasks like constructing substitution matrices, normalizing genetic code representations, and diagonalizing codon frequency data for evolutionary studies. Key use cases include building transition probability matrices for codon evolution models and analyzing nucleotide triplet patterns in genetic sequences.",
      "description_length": 583,
      "index": 38,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.MCMC.M",
      "library": "phylogenetics",
      "description": "Implements core MCMC operations for phylogenetic inference, including tree proposal moves, acceptance ratio calculations, and chain state management. Works with DNA sequence alignments and phylogenetic trees to estimate posterior distributions through iterative sampling. Directly supports Bayesian analysis workflows by integrating likelihood evaluation and tree space exploration.",
      "description_length": 382,
      "index": 39,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Phylo_ctmc.Uniformized_process",
      "library": "phylogenetics",
      "description": "This module represents a uniformized continuous-time Markov chain process on phylogenetic trees, enabling efficient likelihood computation and substitution mapping. It works with transition rate matrices and probability matrices over states, parameterized by branch length. Concrete use cases include computing the likelihood of observed character states at tree leaves and sampling internal node states or substitution histories along branches.",
      "description_length": 445,
      "index": 40,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Codon.Universal_genetic_code",
      "library": "phylogenetics",
      "description": "Implements the universal genetic code with functions to identify stop codons, translate codons to amino acids, and check codon synonymy. Operates on codon and amino acid types, supporting precise genetic code mapping and analysis. Useful for tasks like decoding DNA sequences into proteins, detecting synonymous substitutions, and analyzing codon usage patterns in genomic data.",
      "description_length": 378,
      "index": 41,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Codon.Vector",
      "library": "phylogenetics",
      "description": "This module supports arithmetic operations, logarithmic transformations, and aggregation functions (e.g., summation, normalization, max detection) tailored for codon frequency or probability vectors. It operates on codon-indexed vectors\u2014dense arrays mapping codon symbols to numerical values\u2014and provides safe/unsafe conversions to and from array representations. These tools are particularly useful in phylogenetic analyses requiring codon usage bias quantification, probabilistic model comparisons, or evolutionary rate calculations across genetic sequences.",
      "description_length": 560,
      "index": 42,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Simulator.Make",
      "library": "phylogenetics",
      "description": "This module simulates evolutionary processes on phylogenetic trees using continuous-time Markov chain models. It provides functions to generate state transitions across tree branches via methods like matrix exponentiation, Gillespie's direct method, and the first reaction method, supporting both single-site and sequence-level evolution. It works with annotated trees containing branch information and site or sequence data types, enabling concrete use cases such as simulating DNA sequence evolution under varying rate matrices or sampling hidden states in phylogenetic HMMs.",
      "description_length": 577,
      "index": 43,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Newick.Tree_repr",
      "library": "phylogenetics",
      "description": "This module defines core tree and branch structures for representing parsed Newick format phylogenetic trees. It provides operations to convert between abstract syntax trees and concrete tree representations, map over or extract inner tree values. It works directly with node_info records, tree and branch types parameterized with node data and optional branch lengths, and the t type wrapping trees or branches. Use cases include manipulating tree topology, extracting node metadata, and transforming trees after parsing from Newick strings.",
      "description_length": 542,
      "index": 44,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Rate_matrix.Nucleotide",
      "library": "phylogenetics",
      "description": "This module constructs and manipulates nucleotide rate matrices for continuous-time Markov models of DNA sequence evolution. It supports specific models like JC69, K80, HKY85, and GTR, allowing specification of symmetric or asymmetric transition rates, stationary distributions, and exchangeabilities. Concrete use cases include simulating sequence evolution, inferring phylogenetic trees, and computing transition probabilities between nucleotides under various substitution models.",
      "description_length": 483,
      "index": 45,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Phylogenetics.Nucleotide.Matrix",
      "library": "phylogenetics",
      "description": "This module offers arithmetic operations (addition, multiplication, inversion), element-wise transformations (logarithm, tolerance-aware comparisons), and structural manipulations (transposition, diagonalization) on DNA nucleotide matrices. It supports matrix construction from functions or arrays, scalar scaling, zero eigen vector computation, and formatted output, operating on `Phylogenetics.Nucleotide.Matrix.t` structures and associated vectors. These capabilities are critical for phylogenetic substitution modeling, evolutionary rate analysis, and numerical validation of nucleotide sequence data.",
      "description_length": 605,
      "index": 46,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Phylogenetics.Alignment.Phylip",
      "library": "phylogenetics",
      "description": "This module converts sequence alignments to and from the PHYLIP file format. It supports parsing PHYLIP data into typed alignments and serializing alignments into PHYLIP structures. Use it when reading legacy PHYLIP files or preparing data for phylogenetic analysis tools that require this format.",
      "description_length": 297,
      "index": 47,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Rate_matrix.Amino_acid",
      "library": "phylogenetics",
      "description": "This module constructs and manipulates rate matrices for amino acid substitutions in continuous-time Markov models. It supports creating arbitrary and symmetric rate matrices, standard models like Jukes-Cantor (JC69) and General Time-Reversible (GTR), and scaling matrices to control evolutionary rates. Concrete use cases include modeling protein sequence evolution, inferring phylogenetic trees, and simulating sequence data under specific substitution dynamics.",
      "description_length": 464,
      "index": 48,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Bppsuite.Cmd",
      "library": "phylogenetics",
      "description": "This module provides functions to execute Bio++ command-line tools for phylogenetic analysis. It supports operations like maximum likelihood tree inference with `bppml` and sequence generation with `bppseqgen`, using phylogenetic trees and sequence data. It works directly with file paths for input and output, handling data such as trees and biological sequences.",
      "description_length": 364,
      "index": 49,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Amino_acid.Matrix",
      "library": "phylogenetics",
      "description": "The module supports numerical operations on fixed-size 20\u00d720 matrices and vectors designed to model amino acid substitution patterns. It provides linear algebra primitives like multiplication, inversion, and eigen analysis alongside utilities for matrix initialization, serialization, and equilibrium probability computation. These structures specifically represent evolutionary rate matrices and frequency distributions for the 20 standard amino acids in phylogenetic inference tasks.",
      "description_length": 485,
      "index": 50,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Alignment.Fasta",
      "library": "phylogenetics",
      "description": "Handles reading and writing of sequence alignments in FASTA format. It provides functions to parse alignments from FASTA files, write alignments to FASTA files or output channels, and works directly with `Phylogenetics.Alignment.t` values. This module is used when importing or exporting multiple sequence alignments for phylogenetic analysis, ensuring all sequences maintain equal length and carry associated descriptions.",
      "description_length": 423,
      "index": 51,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Phylogenetics.Amino_acid.Table",
      "library": "phylogenetics",
      "description": "This module provides a fixed-size table structure indexed by amino acid values, supporting operations like initialization, element access, mutation, and transformations via functions such as `map`, `mapi`, and `map2`. It works with amino acid- indexed tables holding arbitrary values, typically used for scoring matrices, frequency counts, or probabilistic models. Concrete use cases include storing substitution scores between amino acids, maintaining per-amino-acid counts in sequence alignments, and sampling amino acids based on weighted distributions.",
      "description_length": 556,
      "index": 52,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Site_evolution_model.K80_numerical",
      "library": "phylogenetics",
      "description": "Implements the Kimura 80 (K80) nucleotide substitution model with numerical computation of transition probability matrices. Provides functions to calculate the rate matrix, transition probabilities over time, stationary distribution, and spectral decomposition of the rate matrix. Designed for phylogenetic analysis tasks such as likelihood calculation and ancestral state reconstruction under the K80 model.",
      "description_length": 408,
      "index": 53,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Site_evolution_model.Make_diag",
      "library": "phylogenetics",
      "description": "Implements diagonalizable evolution models by computing transition probability matrices and stationary distributions from model parameters. Uses matrix and vector operations defined in associated modules to calculate the exponential of transition matrices and equilibrium frequencies. Useful for phylogenetic analysis where closed-form solutions for substitution probabilities and steady-state distributions are required.",
      "description_length": 421,
      "index": 54,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Phylogenetics.Nucleotide.Vector",
      "library": "phylogenetics",
      "description": "This module supports numerical operations on fixed-size nucleotide-indexed vectors, which represent DNA base data as floating-point arrays. It provides element-wise arithmetic, aggregation (sum, max), transformation (log, exp), and normalization functions, along with conversions to standard data structures. These capabilities are particularly useful in phylogenetic analysis for modeling nucleotide frequency distributions and probabilistic evolutionary processes.",
      "description_length": 466,
      "index": 55,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Alphabet.Make",
      "library": "phylogenetics",
      "description": "Implements integer-based alphabet representations with fixed cardinality, supporting safe and unsafe integer conversions, equality checks, and comparison operations. Provides utilities for generating alphabet symbol lists and computing frequency counts from sequences. Used for constructing substitution matrices, probability profiles, and evolutionary models over discrete sequence alphabets.",
      "description_length": 393,
      "index": 56,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Seq.DNA",
      "library": "phylogenetics",
      "description": "This module represents DNA sequences using nucleotide bases, supporting operations to construct sequences from lists or strings, access individual bases by index, and convert sequences to strings. It works with the `t` type for DNA sequences and `base` type for individual nucleotides. Concrete use cases include parsing FASTA files into DNA sequences, comparing sequence lengths, and printing sequences in string format for output.",
      "description_length": 432,
      "index": 57,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Alignment.Make",
      "library": "phylogenetics",
      "description": "Implements sequence alignment operations for phylogenetic analysis, providing functions to construct alignments from string lists, FASTA files, or associative lists indexed by sequence identifiers. It supports querying individual bases by sequence index and position, determining alignment length and sequence count, and serializing alignments to files. This module handles alignments of sequences composed of bases defined by the parameter module S, ensuring all sequences maintain uniform length for accurate phylogenetic comparisons.",
      "description_length": 536,
      "index": 58,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Amino_acid.Vector",
      "library": "phylogenetics",
      "description": "This module provides arithmetic operations (addition, multiplication), element-wise transformations (logarithm, exponential), normalization, and aggregation (sum, min, max) for fixed-size float vectors indexed by amino acid symbols. It operates on vectors of length 20, where each",
      "description_length": 280,
      "index": 59,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Simulator.NSCodon",
      "library": "phylogenetics",
      "description": "This module simulates codon sequence evolution across phylogenetic trees using continuous-time Markov models. It provides functions for generating sequences at tree nodes via exponential time or Gillespie methods, handling per-branch and per-site mutations with customizable rate matrices. Concrete use cases include simulating coding sequence alignments for inference or testing evolutionary hypotheses under specific mutational models.",
      "description_length": 437,
      "index": 60,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Birth_death",
      "library": "phylogenetics",
      "description": "This module simulates phylogenetic trees under constant-rate birth-death processes. It defines a parameter type with birth and death rates, and offers two main simulation functions: one that runs for a fixed time duration, and another conditioned on tree age and number of taxa. These functions are used to generate trees for studying evolutionary dynamics, such as modeling species diversification with known extinction and speciation rates.",
      "description_length": 442,
      "index": 61,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Phylogenetics.Linear_algebra_tools",
      "library": "phylogenetics",
      "description": "This module wraps Lacaml to perform numerical linear algebra operations such as matrix-vector multiplication, scalar multiplication, vector scaling, and addition. It also includes specialized functions like matrix exponentiation and stationary distribution computation. These operations directly support phylogenetic model analysis, particularly for manipulating transition matrices and calculating likelihoods.",
      "description_length": 411,
      "index": 62,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.MCMC",
      "library": "phylogenetics",
      "description": "Implements Markov Chain Monte Carlo for phylogenetic inference with functions to propose and accept tree modifications, compute likelihoods, and run sampling chains. Operates on phylogenetic trees and DNA sequence alignments to estimate posterior distributions. Used for Bayesian analysis of evolutionary relationships by iteratively sampling and evaluating tree topologies and parameters.",
      "description_length": 389,
      "index": 63,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Phylogenetics.Alphabet",
      "library": "phylogenetics",
      "description": "Implements integer-based alphabet representations with fixed cardinality, enabling safe and unsafe integer conversions, equality checks, and comparisons. Provides utilities to generate symbol lists and compute frequency counts from sequences. Used for constructing substitution matrices, probability profiles, and evolutionary models over discrete sequence alphabets.",
      "description_length": 367,
      "index": 64,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Newick_parser",
      "library": "phylogenetics",
      "description": "Parses Newick format phylogenetic trees into abstract syntax trees, handling tokens like strings, numbers, and structural symbols. It processes input incrementally or from a given position, supporting streaming workflows for large tree files. Concrete use cases include reading and analyzing phylogenetic data with precise branch and label representation.",
      "description_length": 355,
      "index": 65,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Felsenstein",
      "library": "phylogenetics",
      "description": "Implements Felsenstein's pruning algorithm to calculate the likelihood of phylogenetic trees given fixed sequences at leaf nodes. Operates on tree structures and sequence alignments, using dynamic programming to traverse the tree and compute probabilities at internal nodes. Useful for evaluating the likelihood of a given tree topology under a specified substitution model.",
      "description_length": 374,
      "index": 66,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Phylip",
      "library": "phylogenetics",
      "description": "This module parses and writes the PHYLIP file format used in phylogenetic analysis. It handles reading files into a structured representation containing sequence data and metadata, and writing structured data back to files, with support for strict or relaxed format variants. Key operations include `read`, `read_exn`, `make_exn`, and `write`, which process lists of sequence items with consistent lengths.",
      "description_length": 406,
      "index": 67,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Simulator",
      "library": "phylogenetics",
      "description": "Simulates codon sequence evolution on phylogenetic trees using continuous-time Markov models. It supports sequence generation via exponential time or Gillespie algorithms, with per-branch and per-site mutation handling under customizable rate matrices. Used for generating coding sequence alignments to test evolutionary hypotheses or validate inference methods under specific mutational models.",
      "description_length": 395,
      "index": 68,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Phylo_ctmc",
      "library": "phylogenetics",
      "description": "This module implements likelihood calculations and conditional sampling for continuous-time Markov chains on phylogenetic trees. It provides pruning algorithms for computing the likelihood of observed leaf states, handling missing or ambiguous data, and simulating ancestral states and substitution mappings. The core data types include matrices, vectors, and shifted vectors used to represent transition probabilities and likelihoods, with concrete applications in phylogenetic inference and evolutionary trajectory analysis.",
      "description_length": 526,
      "index": 69,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Phylogenetics.Fitch",
      "library": "phylogenetics",
      "description": "This module implements the Fitch algorithm for parsimony-based phylogenetic inference. It provides functions to perform both the forward and backward passes on a tree, assigning ancestral states to internal nodes based on observed leaf states. The forward pass computes minimum costs for possible states at each node, while the backward pass resolves the most parsimonious state assignments. Use cases include reconstructing ancestral genetic traits and analyzing evolutionary relationships with known tree topologies.",
      "description_length": 518,
      "index": 70,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Phylogenetics.Seq",
      "library": "phylogenetics",
      "description": "This module handles sequences of biological bases using array- or list-based storage, supporting conversion to and from lists and strings, indexed access, and string formatting. It works with base types defined by the BASE signature and provides efficient representations for DNA sequences. Concrete use cases include parsing sequence data from FASTA files, comparing sequence lengths, and preparing sequences for alignment or analysis tasks.",
      "description_length": 442,
      "index": 71,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Stat_tools",
      "library": "phylogenetics",
      "description": "This module provides functions for sampling branch lengths in phylogenetic trees using custom samplers and handles empirical distributions through sample lists. It supports operations such as loading sample lists from files, computing extrema, and calculating means. Concrete use cases include rescaling tree branch lengths based on empirical data and analyzing statistical properties of sampled values.",
      "description_length": 403,
      "index": 72,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.List1",
      "library": "phylogenetics",
      "description": "This module ensures safe manipulation of guaranteed non-empty lists through operations like construction (`singleton`, `cons`), indexed transformations (`map`, `mapi`), and folds (`reduce`, `fold_right`), while supporting conversions to standard lists and error-aware variants (`map2`, `map2_exn`). It works with non-empty lists (`t`) and pairs, enabling use cases like processing biological datasets where emptiness is invalid, sorting with `sort`, and safely unzipping paired data. Functions like `filter` and `filter_map` maintain non-emptiness during element removal, and `init`/`of_list` handle conversions with explicit error handling for edge cases.",
      "description_length": 656,
      "index": 73,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Utils",
      "library": "phylogenetics",
      "description": "This module provides functions for string formatting with colorization, robust floating-point comparisons, and array manipulation including summing values and generating order indices. It defines custom data types for float arrays and matrices along with pretty-printing and string conversion functions. Specific use cases include visualizing numerical data structures, comparing floating-point values with tolerance, and generating random profiles using GSL random number generators.",
      "description_length": 484,
      "index": 74,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Sequence_simulator",
      "library": "phylogenetics",
      "description": "Implements sequence simulation using customizable alphabets, generating random profiles, drawing symbols based on weights, and creating sequences from position weight matrices (PWMs). Works with biological sequence data through user-defined alphabet modules and GSL-based random number generation. Enables simulation of DNA, protein, or other symbolic sequences with controlled composition and motif patterns.",
      "description_length": 409,
      "index": 75,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Iupac_nucleotide",
      "library": "phylogenetics",
      "description": "This module represents IUPAC nucleotide symbols as compact integers, supporting direct comparisons, ambiguity checks, and conversions from characters. It provides operations for counting symbol occurrences in sequences, and for working with vectors and matrices indexed by nucleotide symbols. These features enable precise handling of ambiguous nucleotide data in phylogenetic analysis, such as modeling substitution rates, computing equilibrium frequencies, and generating random nucleotide profiles.",
      "description_length": 501,
      "index": 76,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Codon",
      "library": "phylogenetics",
      "description": "This module provides codon manipulation operations like translation, synonymy checks, and mutation modeling using matrices, alongside numerical methods for phylogenetic analysis on codon-indexed data. It works with codons, genetic codes, and nucleotide sequences through structured representations like tables and vectors, enabling use cases such as evolutionary relationship inference and codon usage bias analysis.",
      "description_length": 416,
      "index": 77,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Sigs",
      "library": "phylogenetics",
      "description": "Defines core abstractions for phylogenetic analysis, including index identifiers, sequence representations, alignment structures, and evolutionary models. It standardizes interfaces for working with biological sequences, multiple sequence alignments, and probabilistic models of evolution. Enables consistent implementation of tree inference algorithms and sequence analysis tools.",
      "description_length": 381,
      "index": 78,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Site_evolution_model",
      "library": "phylogenetics",
      "description": "This module implements DNA substitution models for phylogenetic analysis, including Jukes-Cantor (JC69) and Kimura 2-parameter (K80) models, both analytically and numerically. It provides functions to compute rate matrices, transition probability matrices, stationary distributions, and eigendecompositions, supporting tasks like phylogenetic likelihood calculation and evolutionary distance estimation. Each model handles nucleotide sequence evolution under specific rate assumptions, such as equal substitution rates in JC69 or distinct transition/transversion rates in K80.",
      "description_length": 576,
      "index": 79,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.MG94",
      "library": "phylogenetics",
      "description": "This module implements the Muse-Gaut 94 codon substitution model, providing functions to construct rate matrices and compute stationary distributions based on nucleotide exchangeabilities, a nucleotide stationary vector, and a single omega parameter. It operates on codon types (`NSCodon.t`), codon vectors, and matrices, enabling precise modeling of synonymous and nonsynonymous substitution rates. Use cases include phylogenetic inference, evolutionary distance estimation, and simulation of coding sequence evolution under varying selective pressures.",
      "description_length": 554,
      "index": 80,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Newick",
      "library": "phylogenetics",
      "description": "This module parses and serializes phylogenetic trees in Newick format, handling tree structures with optional node names, tags, and branch lengths. It supports reading from and writing to files or strings, and converting between Newick trees and custom tree representations. Use cases include importing/exporting phylogenetic data, annotating nodes with metadata, and integrating parsed trees into larger analysis workflows.",
      "description_length": 424,
      "index": 81,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Phylogenetics.Amino_acid",
      "library": "phylogenetics",
      "description": "This module supports conversion between integer indices and amino acid characters using safe and error-raising parsers, along with equality, comparison, and frequency counting. It provides fixed-size data structures like tables, vectors, and matrices indexed by amino acids, optimized for numerical operations in phylogenetic tasks such as substitution scoring and profile generation.",
      "description_length": 384,
      "index": 82,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Phylogenetics.ID_monad",
      "library": "phylogenetics",
      "description": "This module provides a state monad for generating unique integer identifiers. It supports operations to bind computations sequentially (`let*`), map results (`let+`), and produce fresh identifiers (`new_id`). The monad maintains an internal integer state that increments with each new identifier, ensuring uniqueness. Use cases include generating temporary IDs for nodes in a tree or tracking unique labels during recursive data structure construction.",
      "description_length": 452,
      "index": 83,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Rejection_sampling",
      "library": "phylogenetics",
      "description": "Implements rejection sampling for phylogenetic trees and alignment data. Generates candidate trees, filters them based on alignment constraints, and computes statistics like mean branch lengths. Used to sample valid tree configurations under specific evolutionary constraints.",
      "description_length": 276,
      "index": 84,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Nucleotide_process",
      "library": "phylogenetics",
      "description": "This module computes rate matrices and stationary distributions for nucleotide mutation models, supporting parameterized processes like JC69, K80, HKY85, and GTR. It operates on nucleotide vectors and matrices, enabling concrete tasks such as simulating mutation models with specific transition rates or sampling GTR exchangeability matrices. Use cases include generating evolutionary models for phylogenetic simulations and analyzing nucleotide substitution patterns under defined statistical assumptions.",
      "description_length": 506,
      "index": 85,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Alignment",
      "library": "phylogenetics",
      "description": "This module enables manipulation and analysis of biological sequence alignments, where sequences of uniform length are paired with descriptive metadata. It provides operations for mapping over sequences, folding with accumulators, querying by description, and analyzing residue composition\u2014such as counting unique residues,",
      "description_length": 323,
      "index": 86,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.TKF91",
      "library": "phylogenetics",
      "description": "Simulates sequence alignments with insertions and deletions under the TKF91 probabilistic model. Operates on biological sequences and evolutionary trees to generate indel patterns and homologous alignments. Useful for testing phylogenetic inference methods and simulating realistic sequence evolution scenarios.",
      "description_length": 311,
      "index": 87,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Bppsuite",
      "library": "phylogenetics",
      "description": "This module defines data types for biological alphabets and substitution models used in phylogenetics, including DNA, RNA, Protein, Binary, Word, and Codon variants. It provides functions to convert these types to string representations and supports specifying model parameters like kappa for the K80 model. These features are used to configure and run phylogenetic analyses with Bio++ command-line tools through the `Cmd` submodule.",
      "description_length": 433,
      "index": 88,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Wag",
      "library": "phylogenetics",
      "description": "This module parses WAG matrices from strings or files into a structured format containing a rate matrix and frequency vector for amino acid substitutions. It processes raw input into typed data structures used for phylogenetic analysis. Direct use cases include loading WAG matrices from external sources for evolutionary modeling or sequence alignment tasks.",
      "description_length": 359,
      "index": 89,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Dna",
      "library": "phylogenetics",
      "description": "This module provides functions to create and analyze DNA sequences represented as strings. It supports creating sequences from raw strings (with or without validation) or arrays of codons, and calculates the GC content of a sequence. Use cases include parsing DNA data from external sources, validating sequence integrity, and performing compositional analysis for biological studies.",
      "description_length": 384,
      "index": 90,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Nelder_mead",
      "library": "phylogenetics",
      "description": "Implements the Nelder-Mead simplex algorithm for minimizing a cost function over a vector of parameters. Accepts a function to minimize, an initial parameter generator, and optional convergence settings. Useful for numerical optimization in parameter estimation or model fitting tasks where gradient information is unavailable.",
      "description_length": 327,
      "index": 91,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Newick_parser_errors",
      "library": "phylogenetics",
      "description": "This module defines error messages for parsing Newick format phylogenetic trees. It maps integer error codes to descriptive strings to aid in debugging malformed tree inputs. Use this module when handling or reporting errors during the parsing of Newick-formatted tree data.",
      "description_length": 274,
      "index": 92,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Newick_ast",
      "library": "phylogenetics",
      "description": "This module defines an abstract syntax tree for representing phylogenetic trees in Newick format, including node attributes and branch lengths. It provides functions for constructing and formatting parser errors with positional information from lexing buffers. The module is used during parsing to model tree structures and report syntactic errors with precise location details.",
      "description_length": 378,
      "index": 93,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Rate_matrix",
      "library": "phylogenetics",
      "description": "This module implements continuous-time Markov chain rate matrices with operations to construct, scale, and compute transition probabilities for models like JC69, GTR, HKY85, and K80. It works with typed states such as nucleotides or amino acids, using abstract matrix and vector types to represent transition rates and stationary distributions. Concrete use cases include simulating sequence evolution, inferring phylogenetic trees, and computing substitution probabilities for DNA or protein sequences.",
      "description_length": 503,
      "index": 94,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Newick_lexer",
      "library": "phylogenetics",
      "description": "This module implements a lexer for parsing Newick format phylogenetic trees. It converts character streams into lexical tokens recognized by the Newick parser, handling elements like branch lengths, node labels, and tree structure. It operates directly on `Lexing.lexbuf` input and produces tokens consumable by the associated parser to build tree data structures.",
      "description_length": 364,
      "index": 95,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Nucleotide",
      "library": "phylogenetics",
      "description": "This module provides functions to represent and manipulate DNA bases, including conversions between characters and nucleotide types, equality checks, and classification (e.g., transversion detection). It operates on individual nucleotides as well as structured collections like vectors and matrices, supporting statistical operations and transformations used in phylogenetic analysis, such as modeling base substitution probabilities and evolutionary relationships.",
      "description_length": 465,
      "index": 96,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Mutsel",
      "library": "phylogenetics",
      "description": "This module implements the mutation-selection model for codon evolution, providing operations to compute transition rate matrices, stationary distributions, and transition probability matrices. It works with codon-based data using nucleotide rates, codon frequencies, and selection parameters such as omega and scaled fitness. It is used to model codon substitution under selection, simulate sequence evolution, and infer evolutionary parameters from genomic alignments.",
      "description_length": 470,
      "index": 97,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Linear_algebra",
      "library": "phylogenetics",
      "description": "This module provides vector and matrix operations including element-wise transformations, arithmetic, summation, and extremum extraction for dense float vectors and matrices. It supports initialization from functions or arrays, conversion to arrays, and formatted printing. Concrete use cases include numerical computations in phylogenetic algorithms such as likelihood calculations and parameter transformations.",
      "description_length": 413,
      "index": 98,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Zipper",
      "library": "phylogenetics",
      "description": "This module provides a zipper structure for efficient traversal, directional navigation, and modification of phylogenetic trees, supporting operations to convert trees into zippers, retrieve branch data, and manage directional context using oriented zippers. It is designed for handling large tree datasets, enabling tasks such as evolutionary analysis, structural visualization, and precise tree manipulation through functions like node relocation, branch length adjustment, and random node sampling.",
      "description_length": 501,
      "index": 99,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Sequence_generation",
      "library": "phylogenetics",
      "description": "This module simulates biological sequence data under various evolutionary models. It provides functions for generating sequences with specified properties, such as length and mutation rates, using base alphabets defined in related modules. It is used to create synthetic datasets for testing phylogenetic inference algorithms or simulation-based studies.",
      "description_length": 354,
      "index": 100,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics.Discrete_pd",
      "library": "phylogenetics",
      "description": "This module implements an updatable discrete probability distribution with operations to initialize, update category weights, sample categories, and retrieve total weight. It works with a mutable internal representation of category probabilities and supports direct manipulation by index. It is suitable for dynamic probabilistic modeling scenarios such as adaptive MCMC sampling or evolving stochastic processes where category probabilities change over time.",
      "description_length": 459,
      "index": 101,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Phylogenetics",
      "library": "phylogenetics",
      "description": "This module offers operations for phylogenetic tree manipulation, sequence alignment analysis, and evolutionary model simulation. It works with biological sequences (DNA, amino acids, codons), tree structures in Newick/PHYLIP formats, discrete probability distributions, and substitution matrices. Specific applications include ancestral state inference, likelihood computation under models like JC69/K80, MCMC sampling, and efficient tree traversal using zippers for evolutionary hypothesis testing.",
      "description_length": 500,
      "index": 102,
      "embedding_norm": 0.9999999403953552
    }
  ],
  "filtering": {
    "total_modules_in_package": 106,
    "meaningful_modules": 103,
    "filtered_empty_modules": 3,
    "retention_rate": 0.9716981132075472
  },
  "statistics": {
    "max_description_length": 703,
    "min_description_length": 274,
    "avg_description_length": 444.3495145631068,
    "embedding_file_size_mb": 1.4930553436279297
  }
}