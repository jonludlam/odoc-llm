{
  "package": "elpi",
  "embedding_model": "Qwen/Qwen3-Embedding-8B",
  "embedding_dimension": 4096,
  "total_modules": 147,
  "creation_timestamp": "2025-08-15T17:13:28.574166",
  "modules": [
    {
      "module_path": "Elpi_runtime.Data.BuiltInPredicate.ADT",
      "library": "elpi.runtime",
      "description": "This module handles construction, deconstruction, and conversion of algebraic data types (ADTs) in the context of term manipulation and logic programming. It provides functions to build terms from ADT constructors, read back terms into structured values, compile constructors and matchers, and document ADT schemas. Key operations include embedding ADTs into terms, pattern matching on them, and extracting type information for documentation, used when implementing or inspecting custom data structures in Elpi.",
      "description_length": 511,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_runtime.Data.Term.C",
      "library": "elpi.runtime",
      "description": "This module facilitates type-safe conversion and embedding of basic OCaml types (`int`, `float`, `string`, and source locations) into a unified `CData.t` structure, enabling their representation within Elpi terms. It includes dedicated utilities for bidirectional conversion with a focus on precise source code position tracking via `Loc.t`, which is critical for tasks like term manipulation and error reporting that require contextual location metadata. The consistent function patterns simplify handling of primitive data and source annotations in Elpi's runtime environment.",
      "description_length": 578,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_runtime.Data.Conversion",
      "library": "elpi.runtime",
      "description": "This module handles the conversion and manipulation of terms and types in the context of a logic programming runtime. It provides functions to pretty-print and serialize type abstract syntax trees, manage extra goals like unification constraints, and format terms with proper precedence and parentheses. Concrete use cases include generating human-readable representations of complex terms, inserting unification checks into goal lists, and parsing type expressions with correct operator associativity.",
      "description_length": 502,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_runtime.Data.CalcHooks",
      "library": "elpi.runtime",
      "description": "This module manages a collection of evaluation hooks for arithmetic and symbolic computations, where each hook is associated with a constant and implements a `run` function that processes a list of terms into a result term. It maintains a descriptor mapping constants to their evaluation logic and type declarations, supporting dynamic registration and lookup of custom operations. Concrete use cases include extending the runtime with domain-specific calculations like integer arithmetic or symbolic simplification rules.",
      "description_length": 522,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_runtime.Data.Global_symbols",
      "library": "elpi.runtime",
      "description": "This module provides operations to manage a bidirectional mapping between strings and terms for global symbols, supporting declaration, retrieval, and locking of symbols. It works with predefined constants for logical constructs like connectives, quantifiers, list constructors, and control-flow predicates (e.g., `declare_constraintc`, `findall_solutionsc`), enabling tasks such as constraint handling, solution aggregation, and execution control in logic programming. The symbol table serves as a foundational structure for interpreting and manipulating logical terms within the runtime.",
      "description_length": 589,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_runtime.Discrimination_tree.Internal",
      "library": "elpi.runtime",
      "description": "This module defines constants and predicates for classifying and inspecting cells in a discrimination tree structure. It provides operations to retrieve the kind, arity, and data fields of a cell, along with boolean checks for specific cell properties such as variable status, input/output roles, and list structure markers. These functions are used to analyze and match terms during logic programming execution.",
      "description_length": 412,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_runtime.Discrimination_tree.Path",
      "library": "elpi.runtime",
      "description": "This module represents and manipulates paths in a discrimination tree using a list of cells. It provides operations to construct paths incrementally with a builder, retrieve specific cells by position, and format paths for debugging. Concrete use cases include tracking term structures during unification and indexing logic program clauses based on their shape.",
      "description_length": 361,
      "index": 6,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Elpi_runtime.Data.CHR",
      "library": "elpi.runtime",
      "description": "This module implements a constraint handling rule (CHR) system for managing and applying logical rules over terms. It provides operations to create and manipulate rule sets (cliques), add rules to cliques, and query which rules apply to specific constraints. The system works with terms, sequents (comprising eigenvariables, context, and conclusion), and structured rule definitions, supporting concrete tasks like constraint simplification and propagation in logic programming.",
      "description_length": 478,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_runtime.Data.Term",
      "library": "elpi.runtime",
      "description": "This module provides operations for constructing and manipulating logic programming terms, including lambda abstractions, applications, and unification variable handling, alongside utilities for embedding OCaml values as CData. It works with terms, clauses, types (`ttype`), argument modes (`arg_mode`), and unification constraints, supporting program representation, execution state debugging, and mode-aware logic operations. Specific use cases include managing stuck goals during execution, comparing and pretty-printing terms for diagnostics, and building mode-annotated program clauses for logic inference.",
      "description_length": 611,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_runtime.Data.BuiltInPredicate",
      "library": "elpi.runtime",
      "description": "This module provides utilities for defining and manipulating built-in predicates with type signatures, supporting algebraic data types (ADTs) for term construction, deconstruction, and type conversion in logic programs. It operates on hash tables mapping integers to predicates and structured ADT representations, enabling use cases like logic program analysis, custom data type implementation, and serialization of predicate metadata for tooling or debugging purposes. The module also includes formatting and documentation tools to enhance readability and integration with development environments.",
      "description_length": 599,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_runtime.Data.HoasHooks",
      "library": "elpi.runtime",
      "description": "This module manages a mutable descriptor that holds an optional postprocessing function for extra goals during HOAS (Higher-Order Abstract Syntax) conversion. It allows setting and updating the postprocessing logic used to transform or analyze extra goals generated during the conversion process. Concrete use cases include customizing how additional constraints or subgoals are handled after parsing HOAS terms in theorem proving or logic programming contexts.",
      "description_length": 461,
      "index": 10,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_runtime.Runtime_trace_off.Pp",
      "library": "elpi.runtime",
      "description": "This module provides functions for pretty-printing terms, constants, and references in a runtime environment. It operates on data types such as `term`, `env`, `constant`, and object references with UUIDs, using OCaml's Format module for output. Concrete use cases include displaying evaluated terms during debugging, logging constant values, and formatting opaque references for inspection.",
      "description_length": 390,
      "index": 11,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_runtime.Data.State",
      "library": "elpi.runtime",
      "description": "This module manages state components with lifecycle-aware operations, allowing declaration and manipulation of state elements that evolve during compilation and execution phases. It supports typed state components via descriptors, enabling initialization, merging, and scoped updates with callbacks triggered at specific stages like clause compilation or execution end. Concrete use cases include tracking compiler state such as variable mappings, type information, or accumulated constraints across different compilation stages.",
      "description_length": 529,
      "index": 12,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Elpi_runtime.Data.ContextualConversion",
      "library": "elpi.runtime",
      "description": "This module handles contextual conversions between different representation types, particularly managing typed abstract syntax trees (`ty_ast`) and structured data with context dependencies. It provides functions to pretty-print and convert contextual values, along with operators to embed and transform conversion functions within specific contexts. Concrete use cases include parsing and printing higher-order abstract syntax terms with associated hypotheses and constraints.",
      "description_length": 477,
      "index": 13,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_runtime.Runtime.CompileTime",
      "library": "elpi.runtime",
      "description": "This module handles index manipulation and clause compilation for logic programs. It provides operations to update indexing strategies, add clauses to an index, and convert terms into executable clauses with source tracking. It works directly with terms, clauses, and index structures to support compilation of logic programs into an executable format. Use cases include building and maintaining the index during program loading and compiling structured terms into clauses with correct mode and source information.",
      "description_length": 514,
      "index": 14,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Elpi_runtime.Runtime.Pp",
      "library": "elpi.runtime",
      "description": "This module provides functions for pretty-printing terms, constants, and object references in a formatted output. It operates on data types such as `term`, `env`, `constant`, and UUID-object pairs, using a formatter from the standard library. Concrete use cases include displaying parsed terms with proper indentation, printing constants during debugging, and rendering object references with associated metadata.",
      "description_length": 413,
      "index": 15,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_runtime.Runtime_trace_off.CompileTime",
      "library": "elpi.runtime",
      "description": "This module handles index manipulation and clause generation during compilation. It provides operations to update indexing strategies, add clauses to the index, and convert terms into executable clauses with source tracking. It works directly with terms, clauses, and index structures, supporting tasks like predicate indexing and mode-based compilation. Use cases include compiling logic programs into an indexed form suitable for execution and managing insertion of clauses during parsing.",
      "description_length": 491,
      "index": 16,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_runtime.Data",
      "library": "elpi.runtime",
      "description": "This module provides facilities for representing and manipulating logic programming constructs such as terms, types, and clauses, with support for unification, constraint handling, and term construction/deconstruction. It operates on data structures like `term`, `ttype`, `uvar_body`, and `clause`, alongside utilities for debugging (e.g., pretty-printing stuck goals), managing stateful computations, and processing constraint rules. Specific use cases include implementing logic programming runtime features, handling higher-order abstract syntax, and optimizing term indexing or arithmetic operations in embedded Prolog-like programs.",
      "description_length": 637,
      "index": 17,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Elpi_runtime.Ptmap",
      "library": "elpi.runtime",
      "description": "This module implements a persistent trie-based map with integer keys, supporting efficient insertion, lookup, and deletion. It provides operations for mapping, folding, and comparing values, along with utilities for converting to lists and formatting for display. Use cases include managing sparse integer-indexed data and enabling efficient incremental updates in logic programming contexts.",
      "description_length": 392,
      "index": 18,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Elpi_runtime.Discrimination_tree",
      "library": "elpi.runtime",
      "description": "This module supports operations for structuring and querying hierarchical term representations through discrimination trees, focusing on term indexing and structural pattern matching. It manipulates tree structures (`t`) and individual nodes (`cell`), with dedicated utilities for path construction (handling term components like constants, variables, and lists) and efficient value retrieval during logic unification. Additional capabilities include predicate-based filtering, string conversion for inspection, and low-level term analysis for classification tasks in program execution.",
      "description_length": 586,
      "index": 19,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_runtime.Bl",
      "library": "elpi.runtime",
      "description": "This module implements a bidirectional list structure that supports efficient insertion, removal, and replacement of elements based on predicates. It provides operations for constructing and modifying lists, as well as scanning through elements in both directions, with concrete use cases including managing ordered data that requires frequent updates and traversal. The module works with elements of any type `'a` and exposes functions to convert between scans and standard lists, measure length, and format output.",
      "description_length": 516,
      "index": 20,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_runtime.Runtime_trace_off",
      "library": "elpi.runtime",
      "description": "This module provides term manipulation and compilation utilities for logic programming, including substitution, unification variable resolution, environment transformations, and clause indexing. It operates on terms, environments, unification variables, and index structures, enabling tasks like pretty-printing stuck goals, goal suspension, and clause optimization. These operations support runtime execution control, debugging output generation, and compilation-time predicate analysis for efficient logic program evaluation.",
      "description_length": 527,
      "index": 21,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_runtime",
      "library": "elpi.runtime",
      "description": "This module implements core runtime components for logic programming, supporting term manipulation, unification, and environment management. It includes bidirectional lists for dynamic data handling, discrimination trees for term indexing, and persistent maps for efficient key-value operations. Concrete use cases include executing and debugging Prolog-like programs, managing logic variable bindings, and optimizing clause resolution during program evaluation.",
      "description_length": 462,
      "index": 22,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Trace_ppx_runtime.Runtime",
      "library": "trace_ppx_runtime",
      "description": "This module implements runtime support for tracing and logging structured events, primarily used in conjunction with a tracing preprocessor. It provides operations to record entry into and exit from traced regions, log intermediate values, and manage trace metadata such as steps and goals. Concrete use cases include instrumenting functions to generate execution traces in TTY or JSON format, debugging performance-critical code sections, and associating log entries with specific runtime contexts.",
      "description_length": 499,
      "index": 23,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Trace_ppx_runtime",
      "library": "trace_ppx_runtime",
      "description": "This module implements runtime support for tracing and logging structured events, primarily used with a tracing preprocessor. It provides operations to record function entry and exit, log intermediate values, and manage trace metadata such as steps and goals. Concrete use cases include instrumenting functions to generate execution traces in TTY or JSON format, debugging performance-critical code sections, and associating log entries with specific runtime contexts.",
      "description_length": 468,
      "index": 24,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi.API.RawData.Constants.Set",
      "library": "elpi",
      "description": "This module enables efficient manipulation of constant sets through operations like union, intersection, and difference, alongside conversions between sets and ordered sequences. It operates on collections of constants using a comparison-based ordered structure, supporting both functional transformations and physical identity-preserving operations. Typical applications include managing unique constants during program analysis, maintaining ordered dependencies, or enabling efficient membership checks and filtered traversals in symbolic computation tasks.",
      "description_length": 559,
      "index": 25,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi.API.Ast.Scope.Map",
      "library": "elpi",
      "description": "This module provides scoped map operations for managing key-value associations where keys are tuples of names and language identifiers, supporting ordered traversal, bulk transformations, and list-accumulating updates. It enables use cases like tracking variable bindings across different language scopes during program analysis or query evaluation, with utilities for safely merging, filtering, or decomposing hierarchical data structures. The ordered key design facilitates deterministic processing in tasks such as interpreter state management or structured data serialization.",
      "description_length": 580,
      "index": 26,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi.API.Utils.Map.Make",
      "library": "elpi",
      "description": "This module implements an immutable map structure with ordered keys, supporting functional operations like insertion, deletion, merging, and querying. It provides traversal, transformation, and filtering capabilities, along with conversions to sequences and ordered lists, enabling efficient manipulation of structured data and ordered iteration for applications such as environment management or persistent state handling.",
      "description_length": 423,
      "index": 27,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi.API.Utils.Set.Make",
      "library": "elpi",
      "description": "This module implements a finite set data structure for ordered elements, supporting operations like union, intersection, and difference alongside element-wise transformations and comparisons. It works with sets of elements constrained by a total ordering relation, enabling efficient membership tests, subset checks, and ordered traversals. The structure is particularly useful in symbolic computation contexts, such as tracking unique terms in logic programs or managing ordered constraints during interpretation.",
      "description_length": 514,
      "index": 28,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi.API.RawData.Constants.Map",
      "library": "elpi",
      "description": "This module provides ordered associative map operations for key-value pairs where keys are Elpi logic constants and values are arbitrary data. It supports precise key ordering for traversal, filtering, and transformation, with utilities to merge maps using custom combination rules and convert between maps and ordered sequences of bindings. The structure is particularly useful in logic programming contexts for managing term substitutions, environment tracking, or ordered data aggregation during program analysis and execution.",
      "description_length": 530,
      "index": 29,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi.API.Ast.Name.Set",
      "library": "elpi",
      "description": "This module supports standard set operations\u2014union, intersection, difference, and membership checks\u2014alongside transformations, ordered element traversal, and extremal element retrieval for sets of names. It operates on ordered name sets, providing functions for cardinality computation, conversion to lists or sequences, and pretty-printing while maintaining consistent element ordering. These capabilities are suited for managing program identifiers, analyzing name relationships, or handling ordered name collections in Elpi programs.",
      "description_length": 536,
      "index": 30,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi.API.Ast.Name.Map",
      "library": "elpi",
      "description": "This module implements ordered finite maps for associating values with `Elpi.API.Ast.Name.t` keys, supporting efficient insertion, deletion, lookup, and set-theoretic operations like union and merge. It enables ordered traversal, filtering, and transformation of key-value pairs while maintaining key ordering, and provides utilities for converting maps to lists or sequences for external processing. Typical use cases include managing symbol tables, variable bindings, or configuration data in Elpi programs and queries, where name-based access and ordered iteration are critical.",
      "description_length": 581,
      "index": 31,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi.API.RawPp.Debug",
      "library": "elpi",
      "description": "This module provides low-level pretty-printing functions for Elpi terms, primarily used for debugging. It allows printing terms with customizable indentation levels to a formatter or as a string. Concrete use cases include inspecting intermediate or final results during program execution for diagnostic purposes.",
      "description_length": 313,
      "index": 32,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi.API.Utils.LocSet",
      "library": "elpi",
      "description": "This module implements an ordered set abstraction for source code location data, supporting efficient insertion, deletion, and algebraic operations like union and intersection while preserving element ordering. It operates on immutable collections of location elements, providing ordered traversal, membership testing, and transformations through functions like map and filter. Typical applications include tracking unique source positions during parsing or analysis, comparing location sets for subset relationships, and converting structured location data to textual representations for debugging or output.",
      "description_length": 609,
      "index": 33,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi.API.Ast.Opaque",
      "library": "elpi",
      "description": "This module represents abstract syntax trees (ASTs) in an opaque form, preventing direct inspection while allowing parsing, pretty-printing, and string conversion. It works with the `t` type, which encapsulates Elpi programs or queries after parsing. Concrete use cases include safely handling parsed Elpi code without exposing internal structure, enabling interpretation or result extraction through restricted operations like `pp` and `show`.",
      "description_length": 444,
      "index": 34,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi.API.Ast.Name",
      "library": "elpi",
      "description": "This module represents and manipulates names in the Elpi abstract syntax tree, providing conversion from strings, pretty-printing, and name comparison operations. It supports managing global and local identifiers through name constants and checks, enabling precise handling of variable binding and resolution in Elpi programs. Use cases include constructing and analyzing program terms, managing variable scopes, and ensuring correct name resolution during interpretation.",
      "description_length": 472,
      "index": 35,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi.API.Ast.Scope",
      "library": "elpi",
      "description": "This module manages scoped identifiers and language-specific contexts during program parsing and interpretation. It supports operations to track and manipulate variable bindings across different language scopes using structured key-value associations. Concrete use cases include handling variable capture during query evaluation and maintaining interpreter state with precise language scoping.",
      "description_length": 393,
      "index": 36,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Elpi.API.BuiltInPredicate.Notation",
      "library": "elpi",
      "description": "This module defines operators for constructing and deconstructing terms in Elpi, specifically supporting pattern matching and term manipulation during parsing and query execution. It works with Elpi's abstract syntax tree (AST) structures, enabling direct manipulation of terms and their annotations. Concrete use cases include writing custom parsers, implementing term transformations, and handling Elpi program analysis tasks.",
      "description_length": 428,
      "index": 37,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi.API.Setup.StrMap",
      "library": "elpi",
      "description": "This module provides operations for manipulating string-keyed maps with values of arbitrary type, supporting insertion, deletion, lookup, merging, and ordered traversal. It works with polymorphic maps (`'a t`) and sequences of key-value pairs, offering transformations like filtering, partitioning, and custom-order iteration. Typical use cases include managing configuration settings, processing symbol tables with string identifiers, and converting between associative maps and ordered data representations like lists or sequences.",
      "description_length": 533,
      "index": 38,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi.API.Compile.StrSet",
      "library": "elpi",
      "description": "This module provides set operations such as union, intersection, and difference, along with transformations like mapping and filtering, and ordered traversal capabilities for string collections. It works with a concrete string set type (`t`) that enforces lexicographical ordering, supporting efficient membership checks, element selection, and iterative processing. Typical use cases include managing ordered string collections where set-theoretic operations are required, converting between sets and sequences for ordered traversal, or incrementally constructing and modifying sets from external data sources.",
      "description_length": 611,
      "index": 39,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi.API.Utils.IntSet",
      "library": "elpi",
      "description": "This module supports standard set operations, transformations, and sequence-based manipulations for integer collections, using an abstract type `t` that enforces ordered traversal and efficient membership checks. It provides utilities for predicate-driven element selection, bulk conversions to and from lists or sequences, and string representations, with predictable handling of empty sets and duplicates. These features are suited for scenarios requiring precise set semantics, such as query analysis, constraint management, or ordered data processing in logic programming workflows.",
      "description_length": 586,
      "index": 40,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi.API.Ast.Term",
      "library": "elpi",
      "description": "This module provides operations for constructing and manipulating logic programming terms, including constants, variables, lambda abstractions, and list structures, alongside utilities for unification variables, type casting, and opaque terms. It bridges OCaml lists with Elpi's non-empty list representation, supports term embedding in Coq-Elpi quotations, and manages spilled hypotheses during logical term interpretation.",
      "description_length": 424,
      "index": 41,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi.API.Ast.Type",
      "library": "elpi",
      "description": "This module represents and manipulates type expressions in the Elpi language, supporting operations like pretty-printing and string conversion. It works with algebraic data types that model type constructors, applications, and function types. Concrete use cases include inspecting and formatting types during program analysis or error reporting in the Elpi interpreter.",
      "description_length": 369,
      "index": 42,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi.API.Utils.Set",
      "library": "elpi",
      "description": "This module implements a finite set data structure for ordered elements, supporting operations like union, intersection, and difference alongside element-wise transformations and comparisons. It works with sets of elements constrained by a total ordering relation, enabling efficient membership tests, subset checks, and ordered traversals. The structure is particularly useful in symbolic computation contexts, such as tracking unique terms in logic programs or managing ordered constraints during interpretation.",
      "description_length": 514,
      "index": 43,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi.API.BuiltInPredicate.HOAdaptors",
      "library": "elpi",
      "description": "This module provides higher-order adaptors for building and manipulating predicates with 1 to 3 arguments, enabling direct integration of OCaml functions into Elpi logic programs. It supports operations like filtering, mapping, and folding over structured data using predicate-based transformations, with explicit control over evaluation depth and multiplicity. Concrete use cases include embedding domain-specific filters or transformations into Elpi's logic engine, such as processing abstract syntax trees or constraint sets during program analysis.",
      "description_length": 552,
      "index": 44,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Elpi.API.Ast.Loc",
      "library": "elpi",
      "description": "This module represents and manipulates source code locations with precise positional and line information. It supports operations for creating, comparing, and printing location data, including fields like source name, start and stop positions, and line numbers. It is used to track where specific elements appear in parsed Elpi programs or queries, enabling accurate error reporting and source navigation.",
      "description_length": 405,
      "index": 45,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi.API.RawData.Constants",
      "library": "elpi",
      "description": "This module provides operations to declare and manipulate global logic constants, including predefined constants for logical connectives and control operators. It works directly with the `constant` and `builtin` types, which represent named entities in the Elpi term language. Concrete use cases include defining custom logic symbols, comparing constants for equality, and using built-in control structures like cut and implication in program analysis or transformation tasks.",
      "description_length": 476,
      "index": 46,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi.API.FlexibleData.Elpi",
      "library": "elpi",
      "description": "This module manages unification variables in Elpi by providing operations to create, retrieve, and compare them. It works with the `state` type from `Elpi.API.Data` and a custom `t` type representing flexible data. Concrete use cases include tracking and manipulating logic variables during program parsing and interpretation, such as generating fresh names with `fresh` or persisting variable state across operations.",
      "description_length": 418,
      "index": 47,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi.API.Pp.Ast",
      "library": "elpi",
      "description": "This module provides functions to pretty-print Elpi programs and queries using OCaml's Format module. It operates on abstract syntax trees defined in Elpi.API.Ast, specifically the program and query types. Use this module to display parsed Elpi code or query results in a human-readable form during debugging or interactive sessions.",
      "description_length": 333,
      "index": 48,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Elpi.API.Utils.Map",
      "library": "elpi",
      "description": "This module implements an immutable map structure with ordered keys, supporting insertion, deletion, merging, and querying operations. It provides functions for traversing, transforming, and filtering key-value pairs, along with conversions to sequences and ordered lists. Use cases include managing environments, handling persistent state, and performing ordered iterations over structured data.",
      "description_length": 396,
      "index": 49,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi.API.FlexibleData.Map",
      "library": "elpi",
      "description": "This module implements a bidirectional map between Elpi unification variables and host language values, supporting operations to add, remove, and filter associations. It provides efficient lookups in both directions\u2014mapping host values to Elpi variables and vice versa\u2014and allows folding over the entries with optional term metadata. Concrete use cases include tracking variable bindings during program interpretation and maintaining synchronized state between Elpi and the host language during unification.",
      "description_length": 507,
      "index": 50,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi.API.BuiltInPredicate",
      "library": "elpi",
      "description": "This module defines built-in predicates and utilities for handling input-output arguments with support for unification variables and structured data. It works with Elpi's term and predicate representations, enabling precise control over argument modes (input, output, or mixed) during logic program execution. Concrete use cases include defining custom predicates like `typecheck` that interact with Elpi's interpreter for tasks such as type inference, error diagnosis, or constraint solving.",
      "description_length": 492,
      "index": 51,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Elpi.API.FlexibleData",
      "library": "elpi",
      "description": "This module handles unification variables in Elpi by enabling creation, comparison, and state management through the `Elpi` and `Map` submodules. It operates on the `state` type from `Elpi.API.Data` and uses a custom `t` type to represent flexible data, linking Elpi variables with host language values. Use cases include managing logic variables during parsing and interpretation, such as generating fresh variables with `fresh` or maintaining synchronized variable mappings across Elpi and the host.",
      "description_length": 501,
      "index": 52,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi.API.RawData",
      "library": "elpi",
      "description": "This module provides low-level term manipulation operations, including smart constructors for building lambda abstractions (`mkLam`), applications (`mkAppGlobal`), and list cells (`mkCons`), alongside deconstructors that operate on opaque `term` values through substitution-aware views. It works with unification variables, built-in constants, hypotheses, constraints, and HOAS descriptors, enabling precise control over term representation and logic programming tasks like goal suspension and constraint management. Specific use cases include constructing complex terms for interpreter input, inspecting applied terms during execution, and handling raw hypotheses or suspended goals in logic program analysis.",
      "description_length": 710,
      "index": 53,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi.API.BuiltInData",
      "library": "elpi",
      "description": "This module defines conversions between OCaml and Elpi built-in data types, including integers, floats, strings, lists, and location information. It enables direct manipulation of Elpi terms as OCaml values, supporting concrete use cases like embedding OCaml integers into Elpi programs or extracting string results from Elpi queries. Functions like `poly` and `closed` handle higher-order terms and closures, while `loc` supports source location tracking during parsing and execution.",
      "description_length": 485,
      "index": 54,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi.API.Execute",
      "library": "elpi",
      "description": "This module runs Elpi programs and queries. It provides `once` to execute a program up to a solution or failure, and `loop` to continue searching for solutions interactively, similar to Prolog's REPL. It works with compiled Elpi programs and handles outcomes like success, failure, or step limits. Use it to integrate Elpi execution into tools that need to process logic programs step-by-step or retrieve solutions incrementally.",
      "description_length": 429,
      "index": 55,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi.API.Quotation",
      "library": "elpi",
      "description": "This module processes and manages quotations and anti-quotations for embedding object-language code within Elpi. It supports parsing quoted strings into terms, registering named and default quotation handlers, and defining custom delimiters like backticks and single quotes. Concrete use cases include integrating domain-specific syntax, handling string-like identifiers with custom semantics, and extending the Elpi parser for new quotation languages.",
      "description_length": 452,
      "index": 56,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi.API.RawQuery",
      "library": "elpi",
      "description": "This module provides functions to construct and compile queries using raw terms, enabling direct manipulation of terms for querying the Elpi interpreter. It works with Elpi's abstract syntax trees, terms, and interpreter state, allowing precise control over query generation and execution. Concrete use cases include embedding custom logic for program analysis, transforming typed terms into executable queries, and manually constructing terms for theorem proving tasks.",
      "description_length": 470,
      "index": 57,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi.API.OpaqueData",
      "library": "elpi",
      "description": "This module handles the declaration and conversion of opaque data types, such as integers, that have no syntactic representation in Elpi. It provides the `declare` function to register these types, allowing them to be used in Elpi programs and queries. Use cases include embedding host language values like integers or custom handles into Elpi logic without exposing their internal structure.",
      "description_length": 392,
      "index": 58,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi.API.ContextualConversion",
      "library": "elpi",
      "description": "This module supports contextual conversions between OCaml and Elpi data types, enabling functions to operate on values embedded with program context such as hypotheses and constraints. It provides operators to lift and lower contextual computations, apply functions within context, and compose context-aware transformations. Use cases include manipulating Elpi terms that depend on logical context during parsing, interpretation, or result extraction.",
      "description_length": 451,
      "index": 59,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi.API.Pp",
      "library": "elpi",
      "description": "This module provides functions to format and print Elpi terms, constraints, states, programs, and goals using OCaml's Format module. It works with data types such as `term`, `constraints`, `state`, `program`, and `query` from the Elpi.API.Data and Elpi.API.Compile modules. Use it to display evaluation results, debug programs, or log intermediate states in a readable textual representation.",
      "description_length": 392,
      "index": 60,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi.API.Ast",
      "library": "elpi",
      "description": "This module provides functions to parse Elpi programs and queries from text, execute the interpreter, and output results. It operates on `program` and `query` types, enabling concrete use cases such as loading Elpi source files, evaluating interactive queries, and extracting interpreted results in a structured form.",
      "description_length": 317,
      "index": 61,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Elpi.API.Parse",
      "library": "elpi",
      "description": "This module parses Elpi programs and queries from files or strings, producing abstract syntax trees. It supports file resolution with customizable search paths and handles lexing and parsing errors. Use it to load Elpi code from disk, embed Elpi scripts in applications, or integrate Elpi with build systems and REPLs.",
      "description_length": 318,
      "index": 62,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi.API.Conversion",
      "library": "elpi",
      "description": "This module handles the conversion between OCaml values and Elpi terms, enabling the embedding of OCaml data into Elpi and the readback of Elpi terms into OCaml. It works with Elpi's abstract syntax trees, represented by `ty_ast`, and supports operations like unification through the `Unify` constructor in `extra_goal`. Concrete use cases include transforming OCaml integers or strings into Elpi terms and extracting results from Elpi computations back into OCaml data structures.",
      "description_length": 481,
      "index": 63,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi.API.Calc",
      "library": "elpi",
      "description": "This module handles arithmetic and logical operations within the Elpi interpreter by defining and registering custom operations. It works with terms represented as `Elpi.API.Data.term` and uses operation declarations to specify symbols, argument patterns, and evaluation logic. Concrete use cases include extending the interpreter with new mathematical functions or custom evaluation rules for terms.",
      "description_length": 400,
      "index": 64,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi.API.RawPp",
      "library": "elpi",
      "description": "This module provides low-level pretty-printing functions for Elpi terms, primarily used for debugging. It allows printing terms with customizable indentation levels to a formatter or as a string. Concrete use cases include inspecting intermediate or final results during program execution for diagnostic purposes.",
      "description_length": 313,
      "index": 65,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi.API.State",
      "library": "elpi",
      "description": "This module manages a purely functional state that tracks changes across backtracking branches in the interpreter. It allows declaring components with initialization, pretty-printing, and update functions, each tied to a specific data type such as custom constraints or application-specific data. Use it to store and modify data that must persist across interpreter steps but roll back on failure, like solver state or execution context.",
      "description_length": 437,
      "index": 66,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Elpi.API.AlgebraicData",
      "library": "elpi",
      "description": "This module enables declaring algebraic data types with constructors that carry type information via GADTs, supporting typed construction and pattern matching. It works with user-defined data structures like `option a`, handling their syntax and semantics within the Elpi interpreter. Use it to define custom data types with explicit constructors and to build or match terms in a type-safe way during program analysis or transformation.",
      "description_length": 436,
      "index": 67,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi.API.Compile",
      "library": "elpi",
      "description": "This module compiles parsed Elpi programs and queries into executable forms, handling scoping, type checking, and optimization. It operates on program, query, and compilation unit types, supporting incremental construction and extension of programs with builtins or signatures. Concrete use cases include building scoped Elpi programs from ASTs, compiling and optimizing queries for execution, and managing compilation flags to control variable definitions and type checking behavior.",
      "description_length": 484,
      "index": 68,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Elpi.API.Utils",
      "library": "elpi",
      "description": "This module includes functions for handling errors, warnings, and type errors with optional source locations. It provides utilities for converting between OCaml and LP lists, manipulating terms with operations like beta-reduction and lifting, and working with assignments and clauses. The module also includes data structure implementations such as ordered maps, sets, integer sets, and location sets, which support operations like insertion, traversal, transformation, and algebraic operations, tailored for use cases like environment management, constraint handling, and source location tracking.",
      "description_length": 598,
      "index": 69,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi.API.Setup",
      "library": "elpi",
      "description": "This module initializes and configures the Elpi interpreter with built-in components, state, quotation handling, and file resolution. It supports setting diagnostic handlers for errors, warnings, and anomalies, along with formatters for output. Concrete use cases include embedding Elpi in an application with custom error reporting, managing interpreter settings, and enabling trace options for debugging specific components.",
      "description_length": 426,
      "index": 70,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Elpi.API.BuiltIn",
      "library": "elpi",
      "description": "This module handles the setup and documentation of built-in data types and predicates for the Elpi interpreter. It provides functions to declare built-in operations and generate documentation in LP syntax, including support for formatting and file output. It works directly with Elpi's built-in declarations, context-aware conversions, and formatter utilities, enabling the integration of OCaml-defined logic into Elpi programs.",
      "description_length": 428,
      "index": 71,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Elpi.API.RawOpaqueData",
      "library": "elpi",
      "description": "This module offers low-level utilities for manipulating opaque data values, focusing on type-safe conversions between abstract `t` values and primitive types like integers, floats, strings, and location data. It supports operations such as equality checks, hashing, and bidirectional conversions (e.g., `to_float`, `of_string`), while enabling inspection of data structure invariants. These capabilities are critical when integrating domain-specific literals or metadata (e.g., source code positions) into the Elpi AST during program parsing or analysis.",
      "description_length": 554,
      "index": 72,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi.API.Data",
      "library": "elpi",
      "description": "This module represents terms, constraints, and proof states manipulated by the Elpi interpreter, including data structures like hypotheses and solutions. It provides operations for inspecting and transforming logic variables, constraints, and proof contexts during program execution. Concrete use cases include extracting assignments after query evaluation, managing runtime environments, and handling term relocations during program compilation.",
      "description_length": 446,
      "index": 73,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi.API",
      "library": "elpi",
      "description": "This module provides operations for parsing, compiling, and executing logic programs, along with bidirectional data conversion between OCaml and Elpi terms, management of interpreter state and logic variables, and definition of built-in predicates. It works with terms, source locations, maps, sets, and OCaml values, supporting tasks like embedding Elpi in OCaml applications, transforming object-language code, and debugging via low-level term pretty-printing. Specific use cases include running Elpi queries, handling term unification, and integrating custom state or host-language data into logic programs.",
      "description_length": 610,
      "index": 74,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi.Builtin",
      "library": "elpi",
      "description": "This module provides operations for converting OCaml data structures (maps, sets, booleans, options, and pairs) into Elpi-compatible representations, managing logic programming constructs, and handling input/output via stream-based utilities. It employs diagnostic types to track success or error states and supports unspecified values for flexible data handling. These capabilities enable seamless OCaml-Elpi interoperability, structured error reporting in API interactions, and stream processing for I/O-bound tasks.",
      "description_length": 518,
      "index": 75,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi",
      "library": "elpi",
      "description": "This module provides operations for parsing, compiling, and executing logic programs, along with bidirectional data conversion between OCaml and Elpi terms, management of interpreter state and logic variables, and definition of built-in predicates. It works with terms, source locations, maps, sets, and OCaml values, supporting tasks like embedding Elpi in OCaml applications, transforming object-language code, and debugging via low-level term pretty-printing. Specific use cases include running Elpi queries, handling term unification, and integrating custom state or host-language data into logic programs.",
      "description_length": 610,
      "index": 76,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Trace_ppx",
      "library": "trace_ppx",
      "description": "The module enables structured tracing and logging in OCaml programs through compile-time AST transformations, supporting operations like conditional value spying, function call interception, and scoped event logging. It works directly with OCaml abstract syntax trees (ASTs) and compiler cookies (`Ppxlib.Driver.Cookies.t`) to inject trace statements and manage configuration. This is particularly useful for debugging complex computations or monitoring program execution flows without runtime instrumentation overhead.",
      "description_length": 519,
      "index": 77,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_parser.Parse.Make.Internal",
      "library": "elpi.parser",
      "description": "This module defines functions for parsing infix, prefix, and postfix operators in a logic programming language. It processes input using a lexer that produces tokens and constructs abstract syntax tree nodes representing operator applications. These functions are used during the parsing phase to handle operator notation in expressions.",
      "description_length": 337,
      "index": 78,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_parser.Ast.Func.Map",
      "library": "elpi.parser",
      "description": "This module implements ordered map operations for associations between function symbols and arbitrary values, supporting functional updates while preserving total key ordering. It provides ordered traversal (e.g., `iter`, `fold`), structural transformations (`map`, `filter`, `split`), and sequence conversions (`to_seq`, `of_list`) over maps where keys are `Elpi_parser.Ast.Func.t` instances. Designed for scenarios requiring ordered key handling\u2014such as symbolic computation or structured data processing\u2014it enables efficient lookups, ordered iteration, and ordered-aware merging of maps.",
      "description_length": 590,
      "index": 79,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_parser.Ast.Func.Set",
      "library": "elpi.parser",
      "description": "This module provides ordered, immutable set operations for `Elpi_parser.Ast.Func.t` elements, including union, intersection, difference,",
      "description_length": 136,
      "index": 80,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Elpi_parser.Ast.TypeExpression",
      "library": "elpi.parser",
      "description": "This module provides functions to pretty-print, convert to strings, and compare type expressions with attributes. It operates on the `t_` and `t` types representing structured type expressions. These utilities are used to display and compare complex type information in a structured format.",
      "description_length": 290,
      "index": 81,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_parser.Ast.Structured",
      "library": "elpi.parser",
      "description": "This module provides utilities for formatting and structural comparison of Elpi program components. It operates on data structures representing program elements like macros, type definitions, blocks, and attributes, offering precise string serialization and equality checks. These operations support use cases such as pretty-printing for debugging, generating human-readable representations in toolchains, and validating structural consistency during program analysis.",
      "description_length": 468,
      "index": 82,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_parser.Ast.Mode",
      "library": "elpi.parser",
      "description": "This module defines a type `t` with two variants, `Input` and `Output`, representing directional modes in a parsing context. It provides functions `pp` for pretty-printing, `show` for converting to string, and `compare` for ordering values of type `t`. These operations support tasks like formatting error messages, logging, or implementing mode-sensitive logic in parsers.",
      "description_length": 373,
      "index": 83,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Elpi_parser.Grammar.Make",
      "library": "elpi.parser",
      "description": "This module defines parsing functions for constructing ELPI abstract syntax trees from token streams, including handling programs, goals, and operator declarations. It processes lexed input using a custom lexer function to produce terms, functions, and program structures. Concrete use cases include parsing ELPI source files into executable programs or evaluating goal expressions from string input.",
      "description_length": 400,
      "index": 84,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_parser.Ast.Func",
      "library": "elpi.parser",
      "description": "This module represents logical and structural functions with operations for equality, comparison, and pretty-printing, alongside predefined constants for logical connectives (e.g., conjunction, implication) and data constructors. It includes named symbols like `propf` and `typef`, combined with Map and Set modules for ordered, immutable collections to support symbolic computation. These features enable logic programming tasks such as term manipulation, functional updates, and traversal with ordered keys.",
      "description_length": 509,
      "index": 85,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_parser.Ast.Goal",
      "library": "elpi.parser",
      "description": "This module represents logical goals as terms and provides functions to pretty-print and convert them to strings. It works directly with the `Term.t` type, treating goals as a specialized form of terms. Use it when manipulating or displaying logic programming goals in a parsed form, such as for debugging or output in a REPL.",
      "description_length": 326,
      "index": 86,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Elpi_parser.Ast.TypeAbbreviation",
      "library": "elpi.parser",
      "description": "This module handles type abbreviations in the Elpi parser's abstract syntax tree, providing functions to pretty-print, convert to strings, and compare closed type expressions and type abbreviation definitions. It operates on data types representing type abbreviations, including closed type expressions and their associated names and types. These functions are used when processing and manipulating type definitions during parsing or analysis of Elpi code.",
      "description_length": 456,
      "index": 87,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Elpi_parser.Ast.Chr",
      "library": "elpi.parser",
      "description": "This module handles pretty-printing and comparison operations for sequents and CHR (Constraint Handling Rules) structures parameterized over attribute and term types. It provides functions to format sequents and CHR rules for display or debugging, and to compare these structures based on custom comparison functions for attributes and terms. These operations are essential when implementing or analyzing CHR-based logic programs where structured representation and equality checks are needed.",
      "description_length": 493,
      "index": 88,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_parser.Ast.Program",
      "library": "elpi.parser",
      "description": "This module represents and manipulates the abstract syntax tree for a program in the Elpi language. It includes declarations for clauses, types, macros, and program structure markers like Begin and End, all annotated with source locations. Functions are provided to pretty-print and convert these program elements to strings for debugging or output purposes.",
      "description_length": 358,
      "index": 89,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_parser.Ast.Macro",
      "library": "elpi.parser",
      "description": "This module provides functions to format and convert macro definitions into strings, using custom printers for names and terms. It operates on the `('name, 'term) t` type, representing macros in the Elpi abstract syntax tree. Concrete use cases include pretty-printing macros for debugging or generating human-readable output from parsed Elpi code.",
      "description_length": 348,
      "index": 90,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_parser.Ast.Clause",
      "library": "elpi.parser",
      "description": "This module defines operations for pretty-printing, converting to strings, and comparing structured clause data with customizable formatting and comparison behaviors. It works with a polymorphic clause type that includes terms, attributes, and spill data. Concrete use cases include rendering and comparing clauses during parsing or transformation stages in a logic programming context.",
      "description_length": 386,
      "index": 91,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_parser.Ast.Type",
      "library": "elpi.parser",
      "description": "This module provides functions for pretty-printing, converting to strings, and comparing abstract syntax tree (AST) nodes representing types in the Elpi language. It operates on the polymorphic `Type.t` type, which carries attributes at both the type and inner type levels. These functions are used when displaying type information during compilation or error reporting, ensuring attributes are properly formatted or compared.",
      "description_length": 426,
      "index": 92,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_parser.Parse.Make",
      "library": "elpi.parser",
      "description": "Parses logic programs and goals from files or strings into abstract syntax trees. Works with lex buffers and location information to produce program declarations or goal expressions. Used to read and process source code input into structured Elpi AST elements.",
      "description_length": 260,
      "index": 93,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_parser.Error_messages",
      "library": "elpi.parser",
      "description": "This module maps integer error codes to descriptive error messages. It provides a `message` function that takes an integer code and returns the corresponding string message. Useful for converting internal error codes into user-readable diagnostics during parsing or compilation stages.",
      "description_length": 285,
      "index": 94,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_parser.Parser_config",
      "library": "elpi.parser",
      "description": "This module manages parsing configurations for a custom language, handling operations like substring extraction, symbol lookups, and precedence levels for operators. It works with strings, hashtables mapping strings to arbitrary values, and mixfix operator definitions from the lexer config. Concrete use cases include resolving operator precedences during parsing, formatting token lists for debugging, and enforcing compatibility rules for legacy parser behavior.",
      "description_length": 465,
      "index": 95,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Elpi_parser.Grammar",
      "library": "elpi.parser",
      "description": "This module defines parsing functions that convert token streams into ELPI abstract syntax trees, handling programs, goals, and operator declarations. It works with lexed input through a custom lexer to construct terms and program structures. It is used to parse ELPI source files into executable code or evaluate goal expressions from strings.",
      "description_length": 344,
      "index": 96,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_parser.Ast",
      "library": "elpi.parser",
      "description": "This module defines core components of the Elpi abstract syntax tree, including logical functions, type expressions, clauses, and program elements. It provides operations for pretty-printing, converting to strings, and comparing these structures, working with types like terms, attributes, type abbreviations, and program blocks. Concrete use cases include parsing, debugging, and generating human-readable Elpi code during compilation or interactive sessions.",
      "description_length": 460,
      "index": 97,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_parser.Parse",
      "library": "elpi.parser",
      "description": "Parses logic programs and goals from files or strings into abstract syntax trees. Works with lex buffers and location information to produce program declarations or goal expressions. Used to read and process source code input into structured Elpi AST elements.",
      "description_length": 260,
      "index": 98,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_parser.Lexer",
      "library": "elpi.parser",
      "description": "This module provides lexing operations for handling comments (line, multi-line, conditional), string literals, quoted content, and lookahead assertions, using recursive state transitions and conditional skipping. It operates on lexing buffers (lexbuf) and string maps, incorporating version-specific configuration data to manage tokenization of complex syntax. These capabilities support parsing nested quotes, conditional code blocks, and lookahead",
      "description_length": 449,
      "index": 99,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_parser",
      "library": "elpi.parser",
      "description": "This module implements a complete parser for the Elpi language, transforming raw text into executable abstract syntax trees. It includes a lexer for tokenizing complex syntax elements like nested quotes and conditional blocks, a grammar module for structuring token streams into terms and program blocks, and configuration handling for operator precedence and legacy parsing rules. It is used to load and evaluate Elpi source files, process goal expressions, and generate readable output for debugging or interactive sessions.",
      "description_length": 526,
      "index": 100,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Elpi_compiler.Compiler_data.ScopedTypeExpression.SimpleType",
      "library": "elpi.compiler",
      "description": "This module defines a type `t_` representing simple type expressions, including base types, applications, and function types. It provides pretty-printing and string conversion functions for these types. Use cases include type representation in compilers or interpreters where type expressions need to be manipulated or displayed.",
      "description_length": 329,
      "index": 101,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_compiler.Compiler_data.Scope.Set",
      "library": "elpi.compiler",
      "description": "This module implements a set abstraction for managing collections of identifier-language pairs, enabling operations like union, intersection, difference, and membership checks to handle scope relationships in compiler contexts. It supports transformations between sets, lists, and sequences, along with filtering, folding, and pretty-printing, facilitating tasks such as merging scope hierarchies, extracting contextual elements, or validating language-specific identifiers during compilation phases.",
      "description_length": 500,
      "index": 102,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_compiler.Compiler_data.ScopedTerm.QTerm",
      "library": "elpi.compiler",
      "description": "This module supports the creation and manipulation of terms in a scoped lambda calculus, featuring logical primitives, LP-style lists, and quoted constructs via functions like `mkApp`, `mkCons`, and quotation handlers.",
      "description_length": 218,
      "index": 103,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_compiler.Compiler_data.Scope.Map",
      "library": "elpi.compiler",
      "description": "This module provides map operations for managing scoped data in a compiler context, using keys composed of file identifiers and language enums paired with arbitrary values. It supports functional transformations, filtering, and conversions to sequences, along with utilities for handling optional values and extracting bounds. Typical use cases include tracking symbol bindings across multiple source files and language variants, merging partial scope information, and serializing scope state for debugging.",
      "description_length": 507,
      "index": 104,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_compiler.Compiler_data.ScopedTerm.SimpleTerm",
      "library": "elpi.compiler",
      "description": "This module provides operations for constructing and manipulating terms in a lambda calculus extended with implication, constants, and logic programming (LP) list structures. It works with scoped terms (`t_`) and LP lists, offering utilities to build applications, lambda abstractions, equality constraints, and to convert between OCaml lists and LP list representations. Specific use cases include term assembly for compilation tasks, deconstructing LP lists into OCaml lists, and handling list-based data in logic programming contexts.",
      "description_length": 537,
      "index": 105,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_compiler.Compiler_data.ScopedTerm",
      "library": "elpi.compiler",
      "description": "This module suite provides operations for constructing, transforming, and analyzing terms in an extended lambda calculus with logic programming constructs like implications and LP lists, using data structures such as scoped (`ScopedTerm.t`) and simple terms (`SimpleTerm.t`). These tools support compilation workflows in logic programming systems, enabling tasks like variable scope management, type handling, and term normalization through beta reduction or unlocking.",
      "description_length": 469,
      "index": 106,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Elpi_compiler.Compiler_data.MutableOnce",
      "library": "elpi.compiler",
      "description": "This module implements a mutable cell that can be set exactly once, supporting operations to create, set, unset, and retrieve a value. It provides pretty-printing and string conversion utilities for the stored value. Useful for managing optional configuration values or one-time initialized resources.",
      "description_length": 301,
      "index": 107,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Elpi_compiler.Compiler_data.Scope",
      "library": "elpi.compiler",
      "description": "This module defines scoped identifiers for compiler data, supporting operations to create, compare, and format language-specific and globally bound identifiers. It works with strings for language tags and integers for type declaration IDs, offering functions to generate fresh IDs, check dummy IDs, and manage escape namespace flags. Concrete use cases include managing symbol visibility across compilation units, tracking type declarations in different languages, and ensuring correct identifier scoping during parsing and type checking.",
      "description_length": 538,
      "index": 108,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Elpi_compiler.Compiler_data.ScopeContext",
      "library": "elpi.compiler",
      "description": "This module manages variable and unification variable contexts during compilation, providing operations to compare and manipulate scoped identifiers. It works with tuples and lists of variables, unification variables, and language-specific data using the `F.t` type. Concrete use cases include tracking variable bindings, checking equality of variables within a scope, and purging outdated or irrelevant entries from context lists.",
      "description_length": 431,
      "index": 109,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_compiler.Compiler_data.TypeList",
      "library": "elpi.compiler",
      "description": "This module handles lists of scoped type expressions, providing operations for pretty-printing, comparison, mapping, and list manipulation. It includes functions for appending and merging type lists, folding over elements, and generating string representations. Concrete use cases include processing and transforming sequences of type annotations during compilation.",
      "description_length": 366,
      "index": 110,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_compiler.Compiler_data.QuotationHooks",
      "library": "elpi.compiler",
      "description": "This module manages quotation mechanisms for compiling custom syntax into terms. It provides operations to register named quotations, set default quotation handlers, and define special compilation rules for single-quoted and backtick-quoted strings. It works with scoped terms, language definitions, and parsing states, enabling use cases like embedding domain-specific languages or custom string processing directly in term syntax.",
      "description_length": 432,
      "index": 111,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_compiler.Compiler_data.TypeAssignment",
      "library": "elpi.compiler",
      "description": "This module provides utilities for type schema manipulation, overloading resolution, and type assignment in the context of type inference systems. It operates on polymorphic variant types representing type schemas (`skema`, `skema_w_id`), overloading structures, and mutable type assignments, supporting operations like substitution, equality checks, arity handling, and level management. These tools enable use cases such as compiler-level type checking, polymorphic type variable management, and structured pretty-printing of complex type expressions with contextual formatting.",
      "description_length": 580,
      "index": 112,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Elpi_compiler.Compiler_data.Arity",
      "library": "elpi.compiler",
      "description": "This module represents and manipulates function arities with source location tracking. It provides comparison, pretty-printing, and string conversion operations for arity values, which are pairs of an integer and a location. Used to handle argument counts in compiler data structures with precise error reporting.",
      "description_length": 313,
      "index": 113,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_compiler.Compiler_data.ScopedTypeExpression",
      "library": "elpi.compiler",
      "description": "This module provides operations for constructing, comparing, and transforming scoped type expressions, with support for structural equality checks, context-aware mappings, and pretty-printing. It operates on simple types, expressions, and values, as well as structured types enriched with scoping information, enabling precise type-level manipulations like function type construction or level extraction. These capabilities are particularly valuable in compiler or interpreter implementations for managing type representations and ensuring semantically aware transformations.",
      "description_length": 575,
      "index": 114,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_compiler.Compiler_data",
      "library": "elpi.compiler",
      "description": "This module handles compiler data structures and operations for managing scoped identifiers, type expressions, and term representations in a logic programming context. It works with scoped variables, type expressions, and term data structures, supporting concrete tasks like type checking, term normalization, and symbol visibility management. Use cases include compiling logic programs with proper scoping, handling type declarations with language-specific tags, and embedding domain-specific syntax through quotation mechanisms.",
      "description_length": 530,
      "index": 115,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_compiler.Determinacy_checker",
      "library": "elpi.compiler",
      "description": "This module analyzes logic program clauses to determine predicate functionality by tracking which predicates can be treated as functions. It processes scoped terms and maintains a function map to ensure deterministic behavior during compilation. The checker enforces determinacy constraints and merges function maps across program components.",
      "description_length": 342,
      "index": 116,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_compiler.Type_checker",
      "library": "elpi.compiler",
      "description": "This module implements type checking for scoped terms and type declarations in a logic programming context. It provides functions to validate type abbreviations, check type consistency against declared kinds, and manage undeclared type variables during compilation. Key operations include `check`, which verifies a term against an expected type in a given environment, and `check_types`, which handles overloaded type schemas for declarations.",
      "description_length": 443,
      "index": 117,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_compiler",
      "library": "elpi.compiler",
      "description": "This module compiles logic programs by managing scoped identifiers, type expressions, and term representations. It supports type checking, term normalization, and determinacy analysis for predicates, working with scoped variables, type declarations, and logic terms. Concrete use cases include compiling programs with proper scoping, enforcing deterministic predicate behavior, and validating type correctness during compilation.",
      "description_length": 429,
      "index": 118,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_lexer_config.Lexer_config",
      "library": "elpi.lexer_config",
      "description": "This module defines data structures and functions for configuring lexical parsing rules, specifically handling operator fixities (infix, prefix, etc.) and mixfix token definitions. It supports two main configurations: `fixed` for static token definitions with optional comments, and `extensible` for dynamic token generation with customizable properties. Functions like `mkFix` and `mkExt` allow creating mixfix symbols used in parsing expressions with specific precedence and associativity, such as arithmetic or logical operators in a custom language.",
      "description_length": 553,
      "index": 119,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_lexer_config.Tokens",
      "library": "elpi.lexer_config",
      "description": "This module defines a comprehensive set of lexical tokens used for parsing a domain-specific language. It includes tokens for structural elements (parentheses, braces), operators (arithmetic, logical), keywords (control structures, type declarations), and literals (strings, integers, floats). These tokens are used by a lexer to convert input text into a structured format for further processing by a parser or interpreter.",
      "description_length": 424,
      "index": 120,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_lexer_config",
      "library": "elpi.lexer_config",
      "description": "This module provides operations to define and manage lexical parsing rules, including operator fixities and mixfix token definitions. It works with token configurations for structural elements, operators, keywords, and literals used in domain-specific languages. Concrete use cases include setting up custom arithmetic or logical operators with specific precedence and parsing control structures or type declarations in a DSL.",
      "description_length": 426,
      "index": 121,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_util.Util.Digest.BLAKE256",
      "library": "elpi.util",
      "description": "This module computes BLAKE2b 256-bit cryptographic hashes for strings, byte sequences, files, and channels. It supports digest comparison, equality checks, hexadecimal encoding/decoding, and input/output operations. Concrete use cases include verifying data integrity, generating unique identifiers for content, and securely fingerprinting files or streams.",
      "description_length": 357,
      "index": 122,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_util.Util.Constants.Set",
      "library": "elpi.util",
      "description": "This module implements an ordered set data structure for elements of type `Elpi_util.Util.constant`, supporting standard operations like union, intersection, difference, and membership tests. It includes functions for ordered traversal, transformation (e.g., mapping, filtering, partitioning), and conversion to and from lists and sequences, ensuring compatibility with ordered iteration and sequence-based workflows. This structure is particularly useful for maintaining element ordering during set manipulations, enabling efficient set-theoretic computations, and integrating with ordered data processing pipelines.",
      "description_length": 617,
      "index": 123,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_util.Util.Digest.MD5",
      "library": "elpi.util",
      "description": "This module implements the MD5 hash function for generating 128-bit digests from strings, byte sequences, and input channels. It supports operations to compute hashes from memory buffers, files, and channels, as well as converting digests to and from hexadecimal strings. It is suitable for non-security use cases like checksums or legacy system interoperability where cryptographic strength is not required.",
      "description_length": 408,
      "index": 124,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_util.Util.Digest.BLAKE512",
      "library": "elpi.util",
      "description": "This module computes BLAKE512 cryptographic hashes of strings, byte sequences, files, and channels. It supports digest comparison, equality checks, hexadecimal encoding/decoding, and input/output operations. Use cases include verifying data integrity, generating unique identifiers for files or messages, and securely hashing sensitive information.",
      "description_length": 348,
      "index": 125,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Elpi_util.Util.Constants.Map",
      "library": "elpi.util",
      "description": "This module implements finite maps with ordered keys of type `constant`, supporting insertion, deletion, ordered traversal, and merging operations. It provides transformations like filtering and mapping, along with structural queries such as cardinality checks and key existence tests. Use cases include managing key-value associations requiring strict ordering, converting between maps and sequences for interoperability, and processing data with guaranteed key uniqueness and sorted iteration.",
      "description_length": 495,
      "index": 126,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_util.Util.Digest.BLAKE128",
      "library": "elpi.util",
      "description": "This module computes 128-bit cryptographic hashes using the BLAKE2b algorithm. It supports hashing strings, byte sequences, files, and channels, with utilities to compare, serialize, and convert digests to and from hexadecimal format. Concrete use cases include generating unique identifiers for data chunks, verifying file integrity, and producing compact fingerprints for network transmission.",
      "description_length": 395,
      "index": 127,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Elpi_util.Util.Map.Make",
      "library": "elpi.util",
      "description": "This module implements ordered key-value maps with deterministic traversal and manipulation, supporting operations like insertion, deletion, merging, and key-based queries. It works with polymorphic map structures (`'a t`) where keys adhere to a total order via an `Ord` module, enabling precise navigation (e.g., `find_first`, `split`) and transformations preserving key order. Typical use cases include managing sorted associative data, filtering or mapping values conditionally, and converting between maps and sequences for iteration or serialization.",
      "description_length": 555,
      "index": 128,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_util.Util.Hashtbl.Make",
      "library": "elpi.util",
      "description": "This module provides imperative hash table operations with custom equality and hashing logic, enabling creation, modification, and iteration over tables mapping keys of type `H.t` to arbitrary values. It supports bulk conversions between hash tables and sequences, allowing efficient population or extraction of key-value pairs via `Stdlib.Seq.t`. It is suited for scenarios requiring precise control over hashing strategies (e.g., domain-specific keys) or batch processing of table data, while requiring external synchronization for concurrent access.",
      "description_length": 552,
      "index": 129,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_util.Util.Map",
      "library": "elpi.util",
      "description": "This module implements ordered key-value maps with deterministic traversal and manipulation, supporting operations like insertion, deletion, merging, and key-based queries. It works with polymorphic map structures (`'a t`) where keys adhere to a total order via an `Ord` module, enabling precise navigation (e.g., `find_first`, `split`) and transformations preserving key order. Typical use cases include managing sorted associative data, filtering or mapping values conditionally, and converting between maps and sequences for iteration or serialization.",
      "description_length": 555,
      "index": 130,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_util.Util.IntMap",
      "library": "elpi.util",
      "description": "The module provides functions for manipulating immutable maps with integer keys, supporting operations like insertion, deletion, merging, and extraction of specific bindings based on predicates or key order. It includes utilities for transforming and querying these maps, such as filtering, partitioning, ordered traversal (ascending/descending), and converting between maps and sequences or lists. These operations are particularly useful for integer-indexed data processing, structured configuration management, and scenarios requiring efficient ordered key-value manipulation or human-readable formatting of map contents.",
      "description_length": 624,
      "index": 131,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_util.Util.Int",
      "library": "elpi.util",
      "description": "This module provides comparison, pretty-printing, and string conversion operations for integer values. It defines an integer type and supports formatting integers for output in debugging or logging contexts. Concrete use cases include displaying integer identifiers or counters in error messages and comparing integer-based indices or keys.",
      "description_length": 340,
      "index": 132,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Elpi_util.Util.Digest",
      "library": "elpi.util",
      "description": "This module offers cryptographic hash operations for generating fixed-size digests from strings, byte sequences, files, and input channels using BLAKE and MD5 algorithms. It supports data integrity checks, unique identifier creation, and hexadecimal encoding for applications like content fingerprinting or secure checksum verification. The `show` function specifically converts digest values into readable hex strings for display or logging purposes.",
      "description_length": 451,
      "index": 133,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_util.Util.Constants",
      "library": "elpi.util",
      "description": "This module defines operations for working with constants, including pretty-printing, string conversion, and comparison functions. It provides ordered map and set structures keyed by constants, enabling efficient lookups, ordered traversals, and set-theoretic operations. These are used for managing symbol tables, tracking unique identifiers, and processing ordered collections in compiler or interpreter contexts.",
      "description_length": 415,
      "index": 134,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_util.Util.Bool",
      "library": "elpi.util",
      "description": "This module provides comparison, pretty-printing, and string conversion operations for boolean values. It works directly with the `bool` type, enabling ordering checks and readable output formatting. Concrete use cases include logging boolean states, comparing truth values in ordered contexts, and generating user-friendly string representations of booleans.",
      "description_length": 359,
      "index": 135,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_util.Util.Fork",
      "library": "elpi.util",
      "description": "This module manages forked processes with thread-local storage. It allows creating local references, forking a new process with isolated state, and performing get/set operations on those references within the process. Concrete use cases include managing per-process configuration or state in concurrent Elpi programs.",
      "description_length": 317,
      "index": 136,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_util.Util.Set",
      "library": "elpi.util",
      "description": "This module implements a set data structure with operations for adding, removing, and querying elements, based on a provided ordering. It works with any ordered type that satisfies the `OrderedType` signature, such as integers or strings. Concrete use cases include maintaining collections of unique elements with efficient membership checks and ordered traversal, such as tracking visited nodes in a graph or managing a sorted list of identifiers.",
      "description_length": 448,
      "index": 137,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Elpi_util.Util.StrMap",
      "library": "elpi.util",
      "description": "This module implements a string-keyed map with comprehensive operations for creation, modification, and querying, supporting associative data manipulation with custom conflict resolution during merges. It provides utilities for ordered traversal, filtering, and bidirectional conversion to lists/sequences, along with structural comparison and formatted output capabilities. Typical applications include managing key-value configurations, accumulating data with string identifiers, and enabling ordered processing of associative collections in compilers or dataflow analyses.",
      "description_length": 575,
      "index": 138,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_util.Util.Loc",
      "library": "elpi.util",
      "description": "This module handles source code location tracking with operations to create, merge, and extend location data. It works with a record type containing source name, byte positions, line numbers, and client-specific payloads. Use cases include precise error reporting in parsers and maintaining source mappings during code transformations.",
      "description_length": 335,
      "index": 139,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_util.Util.String",
      "library": "elpi.util",
      "description": "This module offers string manipulation operations spanning character-level transformations, byte-oriented processing, and structural analysis. It works with OCaml's native `string` type as both text and byte arrays, enabling tasks like Unicode decoding, case conversion, substring validation, and endianness-aware integer extraction. Specific use cases include parsing binary formats, normalizing textual data, generating hash keys, and handling UTF-8/UTF-16 encoded content with explicit index control.",
      "description_length": 503,
      "index": 140,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Elpi_util.Util.Hashtbl",
      "library": "elpi.util",
      "description": "This module supports standard hash table operations\u2014creation, insertion, lookup, deletion, and iteration\u2014alongside unsynchronized batch processing via functions like `add`, `find`, `fold`, `add_seq`, and `to_seq`, all requiring external synchronization for concurrent access. It manipulates key-value pairs stored in `Hashtbl.t` structures, enabling customizable hashing strategies through seed-based functions (`seeded_hash`) and parameters, while providing utilities to convert tables to sequences or format them for display. Typical applications include managing performance-critical data with bulk operations, implementing type-specific hashing logic, or integrating hash tables into workflows that require sequential traversal or external concurrency control via mutexes.",
      "description_length": 776,
      "index": 141,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_util.Util.UUID",
      "library": "elpi.util",
      "description": "This module implements UUIDs with operations for creation, comparison, hashing, and string formatting. It provides a type `t` for UUID values, functions to generate fresh UUIDs, and utilities to convert, compare, and hash them. A concrete use case is uniquely identifying objects in a symbolic computation system without collisions.",
      "description_length": 332,
      "index": 142,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Elpi_util.Util.StrSet",
      "library": "elpi.util",
      "description": "This module provides a sorted set structure for strings, supporting set-theoretic operations like union, intersection, and difference, alongside element-wise manipulations such as membership checks, filtering, and ordered traversal. It works with a lexicographically ordered collection of strings, enabling use cases such as constructing sequential data from sets, transforming text collections with functional operations, and validating hierarchical relationships through subset checks or comparisons. Functions for bidirectional conversion with lists and formatted string output further",
      "description_length": 588,
      "index": 143,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_util.Util.CData",
      "library": "elpi.util",
      "description": "This module handles typed constant data manipulation, providing operations for creating, comparing, and transforming constants with associated types. It supports data structures like `t` for representing constants and `cdata` for type-specific metadata, enabling type-safe morphing and mapping operations. Concrete use cases include managing symbolic expressions, performing type-preserving transformations, and implementing custom constant handling in a typed intermediate representation.",
      "description_length": 489,
      "index": 144,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_util.Util",
      "library": "elpi.util",
      "description": "This module offers operations for manipulating ordered associative structures (maps, sets) and sequences (lists) with deterministic traversal, structural comparison, and serialization, alongside utilities for handling options, UUIDs, and cyclic data. It works with primitive types like integers and strings, algebraic types like lists and pairs, and custom abstractions such as spaghetti printers and logic programming state trackers (`arg_mode`, `mode_aux`). Key use cases include error reporting with contextual formatting, logic program analysis with mode tracking, and system-level tasks like process forking and version parsing.",
      "description_length": 633,
      "index": 145,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_util",
      "library": "elpi.util",
      "description": "This module implements deterministic traversal and structural comparison for maps, sets, and lists, with support for serialization and cycle detection. It handles integers, strings, lists, pairs, and custom types like `arg_mode` and `mode_aux`, offering operations for option manipulation, UUID generation, and state tracking. It is used for error reporting with contextual formatting, logic program analysis, and system tasks such as process forking and version parsing.",
      "description_length": 471,
      "index": 146,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 155,
    "meaningful_modules": 147,
    "filtered_empty_modules": 8,
    "retention_rate": 0.9483870967741935
  },
  "statistics": {
    "max_description_length": 776,
    "min_description_length": 136,
    "avg_description_length": 461.4013605442177,
    "embedding_file_size_mb": 2.130948066711426
  }
}