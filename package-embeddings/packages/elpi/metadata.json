{
  "package": "elpi",
  "embedding_model": "Qwen/Qwen3-Embedding-0.6B",
  "embedding_dimension": 1024,
  "total_modules": 175,
  "creation_timestamp": "2025-07-15T23:42:37.504498",
  "modules": [
    {
      "module_path": "Elpi_runtime.Data.Term.C",
      "library": "elpi.runtime",
      "description": "This module provides conversion and type-checking operations between OCaml's primitive types (`int`, `float`, `string`) and the `CData.t` representation used for Elpi terms, along with utilities to handle source code locations via `Loc.t`. It enables embedding and extraction of values like integers or strings into Elpi-compatible terms, as well as precise location tracking within terms for debugging or error reporting. Use cases include passing OCaml data to Elpi programs, validating term types during runtime, and associating terms with source code positions for tooling like linters or compilers.",
      "description_length": 603,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_runtime.Data.BuiltInPredicate.ADT",
      "library": "elpi.runtime",
      "description": "This module handles construction, deconstruction, and conversion of algebraic data types (ADTs) in Elpi, providing functions to build terms from constants and arguments, read back terms into structured values, and compile ADT constructors and matchers. It works with terms, conversion contexts, and state management structures to support embedding and extracting ADT values during runtime. Concrete use cases include defining and manipulating custom data types like lists, options, or sum types directly within Elpi programs.",
      "description_length": 525,
      "index": 1,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Elpi_runtime.Data.ContextualConversion",
      "library": "elpi.runtime",
      "description": "This module handles contextual conversions between abstract syntax trees and their representations, supporting operations like pretty-printing and transformation. It works with typed abstract syntax trees (`ty_ast`) and contextual data structures involving hypotheses and constraints. Concrete use cases include converting and displaying complex type structures in compilers or interpreters, particularly when managing type-level computations with context-sensitive information.",
      "description_length": 478,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_runtime.Data.Term",
      "library": "elpi.runtime",
      "description": "This module provides core operations for building, analyzing, and transforming logic programming terms, including support for higher-order constructs such as lambdas and unification variables. It works with terms like constants, applications, and suspended goals, along with environments, clauses, and metadata structures such as blockers and indexing strategies, enabling precise manipulation of logic programs. A companion module handles conversion between OCaml primitives (`int`, `float`, `string`) and Elpi's `CData.t`, along with source location tracking via `Loc.t`, supporting tasks like embedding values into terms, runtime type validation, and associating terms with source positions. Together, these facilities enable building constraint logic programming engines, term rewriting systems, and tooling such as debuggers, linters, and compilers that require term inspection, transformation, or integration with OCaml data.",
      "description_length": 931,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_runtime.Data.CalcHooks",
      "library": "elpi.runtime",
      "description": "This module manages custom evaluation hooks for terms during runtime, allowing registered functions to be invoked based on term structure. It works with terms, constants, and maps from constants to evaluation functions. Concrete use cases include extending the evaluator with domain-specific operations like arithmetic or symbolic manipulations directly from term syntax.",
      "description_length": 371,
      "index": 4,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Elpi_runtime.Data.HoasHooks",
      "library": "elpi.runtime",
      "description": "This module manages a descriptor for handling extra goals during HOAS (Higher-Order Abstract Syntax) processing. It provides operations to create a descriptor reference and set a postprocessing function for extra goals. It is used to customize how additional goals generated during term conversion are processed.",
      "description_length": 312,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_runtime.Discrimination_tree.Internal",
      "library": "elpi.runtime",
      "description": "This module defines constants and predicates for classifying and inspecting cells in a discrimination tree structure. It provides operations to retrieve kinds, arities, and data fields from cells, as well as boolean checks for various cell types such as variables, constants, and list components. These functions are used to implement pattern matching and term analysis in logic programming contexts.",
      "description_length": 400,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_runtime.Runtime.Pp",
      "library": "elpi.runtime",
      "description": "This module provides functions for pretty-printing terms, constants, and references in a structured format. It operates on data types such as `term`, `env`, `constant`, and UUID-object pairs, using a formatter for output. Concrete use cases include displaying parsed logic programs, debugging term structures, and rendering constants during evaluation or error reporting.",
      "description_length": 371,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_runtime.Data.BuiltInPredicate",
      "library": "elpi.runtime",
      "description": "This module organizes built-in predicates along with their documentation and declarations, using types like `t`, `doc_spec`, and `declaration` to structure metadata. It includes a hash table mapping integers to predicates and supports serialization for generating readable output, such as formatted predicate signatures and comments. The child module extends this by enabling the construction and manipulation of algebraic data types (ADTs) like lists and options, converting between Elpi terms and structured values. Together, they support generating predicate documentation and embedding complex data types directly into Elpi programs.",
      "description_length": 637,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_runtime.Data.Global_symbols",
      "library": "elpi.runtime",
      "description": "The module provides a mutable symbol table for bidirectional mapping between strings and constants, supporting operations to declare symbols, lock the table, and predefine primitives for logical operations (e.g., implication, equality), type handling, and structural constructs (e.g., lists, variadic terms). It works with global constants representing core language features like propositional logic atoms, constraint management directives, and solution collection mechanisms. This structure is used to manage runtime representations of built-in predicates and control flow constructs in Elpi programs, such as constraint declaration, type checking, and variadic argument handling.",
      "description_length": 682,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_runtime.Data.Conversion",
      "library": "elpi.runtime",
      "description": "This module handles conversion between terms and abstract syntax trees, supporting operations like pretty-printing, term representation, and precedence-based formatting. It works with term data structures, type ASTs, and goal unification primitives. Concrete use cases include rendering terms for debugging, parsing type expressions, and managing goal constraints during program analysis.",
      "description_length": 388,
      "index": 10,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_runtime.Discrimination_tree.Path",
      "library": "elpi.runtime",
      "description": "This module implements discrimination tree paths, which are sequences of cells used to navigate and construct discrimination trees. It provides operations to build paths incrementally, access their elements by position, and convert lists of cells into paths. These paths are used to represent term structures in logic programming, enabling efficient indexing and retrieval of clauses based on term patterns.",
      "description_length": 407,
      "index": 11,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_runtime.Runtime.CompileTime",
      "library": "elpi.runtime",
      "description": "This module handles the compilation of terms into indexed clauses, supporting operations like adding clauses to an index, updating indexing modes, and converting terms into clausal form. It works with data structures such as terms, clauses, indexing modes, and constants, primarily from the Elpi_runtime and Elpi_util modules. It is used during the compilation phase to prepare logic programs for execution by organizing clauses based on their structure and mode information.",
      "description_length": 475,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_runtime.Data.CHR",
      "library": "elpi.runtime",
      "description": "This module represents and manipulates constraint handling rules (CHRs) in a logical context, providing operations to create and manage cliques of related rules. It works with terms and sequents\u2014structured combinations of eigenvariables, contexts, and conclusions\u2014to model logical derivations. Use cases include defining custom constraint solvers and implementing logic-based transformations directly within the runtime.",
      "description_length": 420,
      "index": 13,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_runtime.Runtime_trace_off.Pp",
      "library": "elpi.runtime",
      "description": "This module provides functions for pretty-printing terms, constants, and object references in a runtime environment. It operates on data types such as `term`, `env`, `constant`, and UUID-Obj pairs, using format specifiers and context options. Concrete use cases include displaying evaluated terms during debugging, logging constant values, and formatting runtime object references for inspection.",
      "description_length": 396,
      "index": 14,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_runtime.Runtime_trace_off.CompileTime",
      "library": "elpi.runtime",
      "description": "This module handles index updates and clause generation during compilation. It operates on data structures like terms, clauses, and indexing tables, using constants, modes, and insertion strategies. It is used to build and maintain the program database, transforming high-level terms into executable clauses with source tracking.",
      "description_length": 329,
      "index": 15,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Elpi_runtime.Data.State",
      "library": "elpi.runtime",
      "description": "This module manages state components with lifecycle tracking, supporting operations to declare, merge, and manipulate state descriptors. It provides typed access to state elements through components, allowing initialization, retrieval, modification, and cleanup at various stages of compilation and execution. Concrete use cases include managing per-clause or per-goal data in a logic programming engine, where state evolves across compilation and execution phases.",
      "description_length": 465,
      "index": 16,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_runtime.Discrimination_tree",
      "library": "elpi.runtime",
      "description": "The module organizes discrimination trees around cells that represent constants, variables, and structured data, using paths to navigate and index terms efficiently. It supports operations like inserting and replacing values, removing entries by predicate, and formatting trees as strings, all while working with arbitrary data types. The cell module classifies and queries individual nodes\u2014checking types, extracting data, and inspecting structure\u2014while the path module constructs and manipulates sequences of cells to represent term patterns. Together, they enable fast term indexing and pattern-based retrieval, useful for logic programming engines and compilers needing efficient clause matching and symbolic manipulation.",
      "description_length": 726,
      "index": 17,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_runtime.Runtime_trace_off",
      "library": "elpi.runtime",
      "description": "This module provides low-level operations for term manipulation, unification variable handling, and execution control in logic programming environments. It works directly with terms, executables, and unification variable bodies to implement substitutions, full term dereferencing, and environment transformations, supporting Prolog-style goal suspension, term expansion, and runtime management of logic variables. The first child module enables pretty-printing of terms, constants, and object references using format specifiers and context options, with applications in debugging and logging. The second child module manages index updates and clause generation during compilation, transforming high-level terms into executable clauses with source tracking, using constants, modes, and insertion strategies.",
      "description_length": 806,
      "index": 18,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_runtime.Ptmap",
      "library": "elpi.runtime",
      "description": "This module implements a persistent trie-based map with integer keys and supports efficient insertion, lookup, and traversal operations. It provides functions for adding, removing, and finding elements, as well as mapping, folding, and comparing map contents. Use cases include managing sparse integer-indexed data, such as symbol tables or dynamic environments in logic programming interpreters.",
      "description_length": 396,
      "index": 19,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_runtime.Data",
      "library": "elpi.runtime",
      "description": "This module forms the core of a logic programming system, enabling the construction, manipulation, and analysis of terms, clauses, and constraints with support for higher-order abstract syntax and custom evaluation. It operates on data types like typed terms, environments, constraints, and program descriptors, offering operations for unification, goal suspension, and state management, while child modules extend its capabilities with contextual AST transformations, term conversion, custom evaluators, and constraint rule processing. You can use it to build logic engines that embed OCaml values, define domain-specific predicates, or implement compilers that track source locations and manage complex type-level computations. Facilities for pretty-printing, symbol mapping, and state lifecycle tracking support tooling like debuggers and linters alongside runtime systems for constraint solving and term rewriting.",
      "description_length": 918,
      "index": 20,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Elpi_runtime.Bl",
      "library": "elpi.runtime",
      "description": "This module implements a bidirectional list structure that supports efficient insertion, removal, and replacement of elements based on predicates or positional keys. It provides operations like `cons`, `rcons`, `insert`, `remove`, and `replace` for modifying the list, along with scanning functions to iterate and convert to or from standard lists. Use cases include managing ordered collections where elements need to be dynamically updated or queried based on specific conditions or positions.",
      "description_length": 495,
      "index": 21,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Elpi_runtime.Runtime",
      "library": "elpi.runtime",
      "description": "This module manages term manipulation and execution control in a logic programming environment, combining runtime operations like unification variable dereferencing, environment management, and term substitution with structured output and term compilation. It directly supports key data types including `term`, `env`, and logic variables, allowing tasks such as suspended goal retrieval and integer list merging, while its child modules enable term pretty-printing and indexed clause compilation. The module facilitates dynamic logic program execution, term transformation, and debugging through both direct API calls and submodules that handle rendering and compilation tasks. Example uses include executing programs with evolving variable bindings, displaying term structures during evaluation, and preparing logic clauses for efficient execution via indexing.",
      "description_length": 862,
      "index": 22,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Elpi_runtime",
      "library": "elpi.runtime",
      "description": "This module provides a comprehensive framework for logic programming with support for term manipulation, unification, and execution control over structured data. It features discrimination trees for efficient term indexing, persistent integer maps for sparse data management, bidirectional lists for dynamic collections, and low-level operations for variable handling and environment transformations. Users can build and analyze logic programs using typed terms and constraints, compile clauses with source tracking, and perform pattern-based retrieval or term rewriting. Example applications include logic engines with embedded OCaml values, domain-specific compilers, and runtime systems for constraint solving or symbolic computation.",
      "description_length": 737,
      "index": 23,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Trace_ppx",
      "library": "trace_ppx",
      "description": "This system enables code instrumentation through syntactic extensions that insert logging, value inspection, and execution tracing into OCaml programs. It operates on abstract syntax trees (ASTs) and compiler cookies to transform annotated expressions into instrumented code, supporting conditional execution paths based on trace configurations. Key applications include debugging recursive computations, inspecting runtime values non-intrusively, and controlling trace output granularity during development.",
      "description_length": 508,
      "index": 24,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Trace_ppx_runtime.Runtime",
      "library": "trace_ppx_runtime",
      "description": "This module implements runtime support for tracing and logging structured events, with operations to record entry into and exit from traced regions, log intermediate values, and manage trace state. It works with formatter objects, polymorphic j values that encapsulate values and their printers, and trace formats like TTY or JSON. Concrete use cases include generating human-readable or machine-parseable execution traces for debugging or performance analysis.",
      "description_length": 461,
      "index": 25,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Trace_ppx_runtime",
      "library": "trace_ppx_runtime",
      "description": "This module provides runtime support for tracing structured events, enabling the recording of function entry and exit, intermediate values, and trace state management. It works with formatters, polymorphic j values that bundle data and printers, and supports output formats like TTY and JSON. Use it to generate detailed execution traces for debugging or performance analysis, such as logging function calls with arguments and return values in a structured format.",
      "description_length": 464,
      "index": 26,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_lexer_config.Lexer_config",
      "library": "elpi.lexer_config",
      "description": "This module defines data structures and functions for configuring lexical parsing rules, specifically handling operator fixities (infix, prefix, etc.) and mixfix token definitions. It supports two main configurations: `fixed` for predefined tokens with optional comments, and `extensible` for customizable token patterns with dynamic token generation. Functions like `mkFix` and `mkExt` construct mixfix symbol definitions used to extend the lexer with custom syntax, such as user-defined operators or domain-specific notations.",
      "description_length": 528,
      "index": 27,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Elpi_lexer_config.Tokens",
      "library": "elpi.lexer_config",
      "description": "This module defines a comprehensive set of lexical tokens used for parsing a domain-specific language. It includes tokens for structural elements (parentheses, brackets, braces), operators (arithmetic, logical, comparison), keywords (type, module, rule, pred), literals (string, integer, float), and special symbols (VDASH, QDASH, IO annotations). These tokens are used to represent the concrete syntax of input files during lexical analysis, enabling precise recognition of language constructs during parsing.",
      "description_length": 510,
      "index": 28,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_lexer_config",
      "library": "elpi.lexer_config",
      "description": "This module manages lexical parsing configurations and token definitions for a domain-specific language. It provides data types for specifying operator fixities and mixfix symbols, along with a rich set of predefined tokens for structural elements, operators, keywords, and literals. Operations like `mkFix` and `mkExt` allow users to define custom syntax, such as infix operators or extensible token patterns, which the lexer uses to recognize constructs like arithmetic expressions, type declarations, or annotated rules. Example uses include extending the lexer to support user-defined operators or configuring comment handling in source files.",
      "description_length": 647,
      "index": 29,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_compiler.Compiler_data.Scope.Set",
      "library": "elpi.compiler",
      "description": "This module offers functional set operations for managing collections of scope elements, specifically pairs of `F.t` and `language` types, with support for union, intersection, filtering, and membership checks. It provides utilities to convert sets to and from lists or sequences, iterate over elements, and generate string representations for debugging. These operations are particularly useful in compiler contexts for tracking and manipulating scoped identifiers alongside their associated language contexts.",
      "description_length": 511,
      "index": 30,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_compiler.Compiler_data.Scope.Map",
      "library": "elpi.compiler",
      "description": "This module implements a map structure with keys composed of `F.t` and a `language` enum pair, supporting insertion, lookup, deletion, and merging operations alongside ordered traversal, filtering, and transformation of key-value pairs. It operates on polymorphic maps binding `Scope.Map.key` to arbitrary values, enabling use cases like managing compiler scopes, merging contextual data, or processing hierarchical symbol tables. Additional utilities for sequence conversion, debugging output, and comparison-based queries facilitate tasks such as logging, serialization, and structural analysis of scoped data.",
      "description_length": 612,
      "index": 31,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Elpi_compiler.Compiler_data.ScopedTerm.SimpleTerm",
      "library": "elpi.compiler",
      "description": "This module provides operations for constructing and manipulating terms in a lambda calculus extended with logic programming features like implications, conjunctions, and equality. It works with a term type that supports embedded data structures (e.g., LP-style linked lists via `Cons` cells), location tracking, and scoping information, offering utilities to convert between OCaml lists and logic programming lists. Specific use cases include term building for compilers or proof assistants, handling logical formulas with `mkImplication` or `mkEq`, and embedding opaque data structures into terms.",
      "description_length": 599,
      "index": 32,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_compiler.Compiler_data.ScopedTypeExpression.SimpleType",
      "library": "elpi.compiler",
      "description": "This module defines a type `t_` representing simple type expressions, including base types, applications, and function types. It provides pretty-printing and string conversion functions for these types. Useful for type checking and error reporting in a compiler frontend.",
      "description_length": 271,
      "index": 33,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_compiler.Compiler_data.ScopedTerm.QTerm",
      "library": "elpi.compiler",
      "description": "This module provides operations for constructing and manipulating terms in a scoped lambda calculus with logical primitives, supporting term creation (applications, lambdas, variables), type annotations, and logical connectives (implication, equality). It works with scoped terms (`t_` type), logic programming (LP) lists, and their conversions to/from OCaml lists, alongside utilities for variable handling and term quotation. Use cases include building and transforming formal logic expressions, managing scoped bindings in compilers, and interfacing between functional and logic programming paradigms via list structures.",
      "description_length": 624,
      "index": 34,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_compiler.Compiler_data.TypeList",
      "library": "elpi.compiler",
      "description": "This module handles lists of scoped type expressions, providing operations for mapping, appending, merging, and folding over these lists. It includes functions for pretty-printing, comparison, and string conversion, specifically tailored for working with type-level data structures in a compiler context. Use cases include type list manipulation during type checking or code generation phases in a compiler or interpreter.",
      "description_length": 422,
      "index": 35,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_compiler.Compiler_data.ScopedTerm",
      "library": "elpi.compiler",
      "description": "This module combines scoped term manipulation with logical and functional programming features, enabling construction and transformation of typed lambda terms enriched with implications, conjunctions, and equality. It centers on data types like `ScopedTerm.t` and `t_`, supported by `Scope.t` for binding management and `CData.t` for type metadata, while integrating logic programming constructs such as `Cons` cells and LP lists. Operations include beta-reduction, type annotation, scoped variable handling, and conversions between OCaml and logic-style lists, with utilities for embedding data and building logical formulas via functions like `mkImplication` and `mkEq`. It supports tasks like compiler IR generation, symbolic computation, and formal verification through unified functional-logic term manipulation.",
      "description_length": 817,
      "index": 36,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_compiler.Compiler_data.QuotationHooks",
      "library": "elpi.compiler",
      "description": "This module manages quotation mechanisms for compiling custom syntax into terms, supporting named and default quotation handlers. It works with descriptors mapping string tags to quotation functions, which process input strings and context into structured terms. Concrete use cases include defining custom syntax extensions like embedded domain-specific languages or parsing quoted expressions with specific semantics.",
      "description_length": 418,
      "index": 37,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Elpi_compiler.Compiler_data.Scope",
      "library": "elpi.compiler",
      "description": "This module manages scope identifiers and type declarations in a compiler, providing data types and operations for handling language identifiers with comparison, printing, and equality functions. It supports tracking bound and global scopes, generating fresh and dummy type IDs, and controlling namespace escaping, while its child modules offer structured manipulation through sets and maps keyed by identifier-language pairs. The set module enables union, intersection, and filtering of scoped elements, and the map module allows keyed lookups, transformations, and ordered traversals, facilitating tasks like symbol table management and contextual data merging. Examples include tracking declared variables in different language scopes, merging type environments, and generating debug representations of scoped data structures.",
      "description_length": 829,
      "index": 38,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Elpi_compiler.Compiler_data.MutableOnce",
      "library": "elpi.compiler",
      "description": "This module implements a mutable cell that can be set exactly once, supporting operations to create, set, unset, retrieve, and check the value's presence. It works with any data type `'a` and provides pretty-printing and string conversion utilities. Concrete use cases include managing optional configuration values, one-time initialization flags, or deferred computations requiring single assignment semantics.",
      "description_length": 411,
      "index": 39,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_compiler.Compiler_data.ScopedTypeExpression",
      "library": "elpi.compiler",
      "description": "This module provides utilities for constructing and manipulating scoped type expressions with lambda abstractions, arrows, and applications, supporting equality checks, recursive mappings, and pretty-printing. It works with algebraic types like `t`, `e`, `t_`, and `v_` to enable transformations and comparisons that preserve scoping discipline, aiding tasks like type inference and normalization during compiler processing. The child module enhances this functionality by defining `t_` for simple type expressions\u2014such as base types, function types, and applications\u2014and includes utilities for pretty-printing and string conversion, which are essential for type checking and error reporting. Together, they support precise, scoping-aware type manipulation and diagnostics in compiler pipelines.",
      "description_length": 795,
      "index": 40,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_compiler.Compiler_data.ScopeContext",
      "library": "elpi.compiler",
      "description": "This module manages variable and unification variable contexts during compilation, providing operations to compare and manipulate scoped identifiers. It works with tuples and lists of variables, unification variables, and language-specific data via the `F.t` type. Concrete use cases include tracking variable equality, purging outdated context entries, and extending contexts with new scoped variables.",
      "description_length": 403,
      "index": 41,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_compiler.Compiler_data.Arity",
      "library": "elpi.compiler",
      "description": "This module represents and manipulates function arities with their source locations. It provides comparison, pretty-printing, and string conversion operations for arity values. Useful for tracking function argument counts and their positions in source code during compilation.",
      "description_length": 276,
      "index": 42,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_compiler.Compiler_data",
      "library": "elpi.compiler",
      "description": "This module coordinates language-specific data and scoping constructs during compilation, managing type expressions, terms, and arity within scoped contexts. It supports type assignment, scoped term manipulation, and quotation hooks, working alongside submodules that handle scoped type lists, logical-functional terms, custom syntax quotation, scoped identifiers, one-time mutable cells, scoped type expressions, variable contexts, and arity tracking. Key data types include `ScopedTerm.t`, `Scope.t`, `CData.t`, `F.t`, and arity values, with operations like beta-reduction, type annotation, scoped variable handling, quotation parsing, and scoped list manipulation. Examples include type-checking Elpi code with proper scope tracking, embedding domain-specific languages via custom syntax, and managing symbol tables with scoped sets and maps.",
      "description_length": 845,
      "index": 43,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_compiler.Type_checker",
      "library": "elpi.compiler",
      "description": "This module performs type checking and validation for scoped type expressions and terms in a compiler context. It ensures type disjointness, checks type correctness against type abbreviations and arities, and validates term expressions against expected types while managing undeclared type assignments. Concrete use cases include verifying type consistency during compilation and enforcing type constraints in rule-based term processing.",
      "description_length": 437,
      "index": 44,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_compiler.Determinacy_checker",
      "library": "elpi.compiler",
      "description": "This module analyzes logic program clauses to determine predicate functionality by tracking which predicates can be treated as functions. It processes scoped terms and maintains a function map to ensure consistent determinacy across clauses. The checker enforces that each predicate yields at most one result when used in functional contexts, aiding compilation to efficient executable code.",
      "description_length": 391,
      "index": 45,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_compiler.Compiler",
      "library": "elpi.compiler",
      "description": "This module orchestrates the compilation of Elpi source code into executable logic programs through a pipeline that includes parsing, scoping, type-checking, optimization, and linking. It manipulates abstract syntax trees, terms, and programs alongside runtime components like symbol tables, state descriptors, and hooks to manage compilation behavior. Key use cases include transforming scoped terms into optimized queries, resolving cross-unit references during linking, and supporting configurable features like variable tracking or pretty-printing for debugging and execution efficiency.",
      "description_length": 591,
      "index": 46,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Elpi_compiler",
      "library": "elpi.compiler",
      "description": "This module coordinates compilation of Elpi code by managing scoped terms, types, and arity within structured contexts, enabling type assignment, variable tracking, and custom syntax embedding. It supports operations like beta-reduction, scoped term manipulation, and quotation parsing, with core data types including `ScopedTerm.t`, `Scope.t`, and arity values, used for tasks like type-checking with scope tracking or DSL integration. The system ensures type consistency, validates terms against expected types, and compiles logic programs into executable form through a pipeline that includes parsing, optimization, and linking. Specific applications include embedding domain-specific languages, enforcing functional determinacy in predicates, and generating optimized queries with proper symbol resolution and debugging support.",
      "description_length": 832,
      "index": 47,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_util.Util.Hashtbl.HashedType",
      "library": "elpi.util",
      "description": "This module defines the interface for key types used in hash tables, requiring an equality predicate and a hash function. It ensures consistent behavior for keys stored in unsynchronized hash tables. Concrete use cases include implementing custom key types for efficient lookups in data structures like symbol tables or caches.",
      "description_length": 327,
      "index": 48,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_util.Util.Map.OrderedType",
      "library": "elpi.util",
      "description": "This module defines a key type for maps with a total ordering function `compare`, which determines the structure of the map. It includes functions `pp` and `show` for pretty-printing and converting keys to strings. This type is used when creating ordered maps where keys must be comparable, such as in finite maps implemented via balanced trees.",
      "description_length": 345,
      "index": 49,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_util.Util.Hashtbl.S",
      "library": "elpi.util",
      "description": "This module supports imperative key-value operations including adding, removing, and retrieving entries, along with iteration, folding, and sequence conversion. It works with hash tables (`'a t`) parameterized by a key type and uses sequences (`Seq.t`) of key-value pairs for bulk updates like adding or replacing multiple entries at once. These functions are designed for single-threaded contexts or require explicit synchronization (e.g., Mutex.t) to prevent corruption from concurrent modifications.",
      "description_length": 502,
      "index": 50,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_util.Util.Set.Make",
      "library": "elpi.util",
      "description": "This module implements ordered set operations with efficient membership checks, unions, intersections, and ordered element traversal, leveraging comparison logic from an external ordering module. It manipulates sets of arbitrary elements alongside sequences and lists, supporting transformations like filtering, mapping, and partitioning based on predicates or ordering constraints. Typical applications include managing sorted collections, implementing symbolic computation rules, or processing hierarchical data where ordered uniqueness and set algebra are critical.",
      "description_length": 568,
      "index": 51,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_util.Util.Digest.S",
      "library": "elpi.util",
      "description": "This module implements a hash function for generating fixed-length digests from strings, byte sequences, channels, and files. It supports operations like hashing substrings, partial byte sequences, and reading/writing digests to channels, along with converting digests to and from hexadecimal strings. Concrete use cases include verifying data integrity, content-based hashing, and persisting digests in a human-readable format.",
      "description_length": 428,
      "index": 52,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_util.Util.Digest.MD5",
      "library": "elpi.util",
      "description": "This module computes MD5 hashes for strings, byte sequences, files, and channels, producing 128-bit digests as string values. It supports digest comparison, equality checks, hexadecimal encoding and decoding, and reading/writing digests to channels. Concrete use cases include generating checksums for file integrity verification, creating unique identifiers from data content, and maintaining backward compatibility with systems requiring MD5 hashes.",
      "description_length": 451,
      "index": 53,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Elpi_util.Util.Map.Make",
      "library": "elpi.util",
      "description": "This module implements ordered maps with user-defined keys, supporting efficient insertion, deletion, and lookup operations. It offers advanced transformations like mapping, filtering, and folding over key-sorted bindings, along with utilities for converting maps to sequences, lists, or formatted strings. Typical applications include managing hierarchical data structures, processing ordered key-value pairs, and implementing caches or symbol tables requiring predictable iteration order.",
      "description_length": 490,
      "index": 54,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Elpi_util.Util.Constants.Map",
      "library": "elpi.util",
      "description": "This module implements ordered associative containers mapping immutable keys of type `Elpi_util.Util.constant` to polymorphic values, supporting efficient insertion, lookup, and transformation with ordered key traversal. It offers operations like merging, filtering, and bidirectional iteration, along with utilities for converting maps to sequences or string representations, leveraging physical equality for performance-critical updates. Typical applications include managing configuration settings, symbol tables, or ordered metadata where key-based access and structural manipulation are required.",
      "description_length": 601,
      "index": 55,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_util.Util.Digest.BLAKE512",
      "library": "elpi.util",
      "description": "This module computes BLAKE512 cryptographic hashes of strings, byte sequences, files, and channels. It provides functions to generate digests, compare and check equality of existing digests, and convert between hexadecimal representations and raw digest values. Use cases include verifying data integrity, generating unique identifiers for large data blocks, and securely hashing sensitive information.",
      "description_length": 402,
      "index": 56,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_util.Util.Constants.Set",
      "library": "elpi.util",
      "description": "This ordered set implementation operates on constant elements, supporting efficient membership tests, ordered iteration, and set algebra operations like union and intersection. It enables safe element retrieval through optional queries, transformation via mapping and filtering, and conversion between lists or ordered sequences while preserving element order. Ideal for applications requiring ordered collection manipulation, such as symbolic constant management or ordered data analysis pipelines.",
      "description_length": 499,
      "index": 57,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_util.Util.Hashtbl.SeededS",
      "library": "elpi.util",
      "description": "This module offers imperative and functional hash table operations, including creation, insertion, deletion, lookup, and iteration over key-value pairs, alongside bulk initialization and updates using sequences. It works with a hash table type that employs a seeded hash function, supporting keys of a specified type and values of arbitrary type. It is suited for scenarios requiring custom hashing strategies or efficient bulk processing of key-value data from sequential sources.",
      "description_length": 481,
      "index": 58,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_util.Util.Map.S",
      "library": "elpi.util",
      "description": "This module provides ordered key-value map operations including insertion, deletion, merging, and predicate-based queries, along with ordered traversal and aggregation. It works with map structures that enforce key ordering, supporting conversions to and from lists/sequences, bidirectional iteration, and customizable value formatting. These features are useful for maintaining sorted associative data, processing hierarchical configurations, or bridging between ordered collections and other data representations.",
      "description_length": 515,
      "index": 59,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_util.Util.Set.S",
      "library": "elpi.util",
      "description": "This module provides operations for constructing, transforming, and querying sets with ordered elements, supporting set-theoretic operations like union, intersection, and difference, as well as functional transformations such as map, fold, and filter. It operates on a set type `t` containing elements of type `elt`, which are ordered using `Ord.compare`, enabling efficient membership checks, extremal element retrieval, and ordered sequence conversions. Specific use cases include managing dynamic collections of ordered data, processing streams via sequence interoperability, and implementing algorithms requiring precise set manipulation or textual representation of sets.",
      "description_length": 676,
      "index": 60,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Elpi_util.Util.Set.OrderedType",
      "library": "elpi.util",
      "description": "This module defines a set element type `t` with a total ordering function `compare` and functions `pp` and `show` for formatting and converting elements to strings. It is used to create and manipulate sets where elements can be compared, printed, and displayed. Concrete use cases include managing collections of ordered values like integers, strings, or custom data types in set operations such as union, intersection, and difference.",
      "description_length": 435,
      "index": 61,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_util.Util.UUID.Htbl",
      "library": "elpi.util",
      "description": "This module offers hash table operations for managing key-value pairs where keys are UUIDs and values are arbitrary. It supports standard manipulations like insertion, deletion, iteration, and folding, along with sequence-based bulk updates (`add_seq`, `replace_seq`) and hash table construction from sequences (`of_seq`). It is useful for scenarios requiring efficient UUID-indexed data management, such as tracking unique entities or batch-processing identifier-value mappings.",
      "description_length": 479,
      "index": 62,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_util.Util.Digest.BLAKE256",
      "library": "elpi.util",
      "description": "This module computes BLAKE2b-256 hashes for strings, byte sequences, files, and channels, producing 32-byte cryptographic digests. It supports digest comparison, equality checks, hexadecimal encoding/decoding, and input/output operations. Use cases include verifying data integrity, generating unique identifiers for content, and securely fingerprinting files or network data.",
      "description_length": 376,
      "index": 63,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_util.Util.Hashtbl.Make",
      "library": "elpi.util",
      "description": "This module implements hash tables with customizable hashing and equality, supporting operations like insertion, lookup, iteration, and conversion to sequences. It manages tables mapping keys of a specific type to arbitrary values, ideal for scenarios requiring precise control over hash behavior or integrating with sequential data workflows. Use cases include handling non-standard key types or efficiently bulk-loading data from sequences.",
      "description_length": 442,
      "index": 64,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_util.Util.Hashtbl.SeededHashedType",
      "library": "elpi.util",
      "description": "This module defines a hash table key type with a seeded hashing function and equality predicate. It ensures consistent hashing behavior by requiring that equal keys produce the same hash value for any seed. It is used when creating hash tables that need deterministic hashing, such as when reproducibility across runs or controlled variation in hash values is required.",
      "description_length": 369,
      "index": 65,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Elpi_util.Util.Digest.BLAKE128",
      "library": "elpi.util",
      "description": "This module computes 128-bit cryptographic hashes using the BLAKE2b algorithm. It operates on strings, byte sequences, and input/output channels, offering functions to generate, compare, and serialize digests. It is suitable for scenarios requiring compact hash values, such as checksums for small data or identifiers in systems where collision resistance is less critical.",
      "description_length": 373,
      "index": 66,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Elpi_util.Util.Hashtbl.MakeSeeded",
      "library": "elpi.util",
      "description": "This module supports creating, modifying, and converting hash tables that use custom seeded hashing and equality functions for keys, enabling operations like insertion, lookup, iteration, and bulk updates from sequences. It works with hash tables (`'a t`) mapping keys (from module `H`) to arbitrary values, and sequences of key-value pairs (`'a Seq.t`), emphasizing thread-unsafe scenarios where manual synchronization is required. Specific use cases include handling keys with domain-specific equality, integrating with streaming data via sequences, and enabling deterministic randomization through seeded hashing when needed.",
      "description_length": 628,
      "index": 67,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Elpi_util.Util.Digest",
      "library": "elpi.util",
      "description": "This module provides cryptographic hashing capabilities using BLAKE and MD5 algorithms, enabling the generation of fixed-size digests from strings, bytes, files, and channels. It includes functions for hashing arbitrary data ranges, serializing digests to hexadecimal strings, and comparing or persisting hash values efficiently. Submodules specialize in specific hash variants\u2014producing 128-bit, 256-bit, and 512-bit digests\u2014supporting use cases such as content-based identifiers, data integrity verification, and checksum generation. The module also includes utilities for organizing digests into sets and maps, enabling efficient lookups and equality testing across large datasets.",
      "description_length": 684,
      "index": 68,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_util.Util.Constants",
      "library": "elpi.util",
      "description": "This module handles constants with operations for comparison, string conversion, and pretty-printing, while providing specialized map and set structures for efficient key-based access and ordered manipulation. The map submodule supports ordered associative storage with operations like merge, filter, and traversal, ideal for symbol tables and configuration management, while the set submodule enables ordered collections with membership tests and algebraic operations, suited for symbolic constant tracking and ordered data processing. Together, they allow tasks like managing unique identifiers, performing equality checks in logic programs, and transforming structured metadata with physical equality optimizations. Direct APIs include map and set construction, bidirectional iteration, and conversion to sequences or strings.",
      "description_length": 829,
      "index": 69,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_util.Util.Bool",
      "library": "elpi.util",
      "description": "This module defines standard operations on boolean values, including comparison, pretty-printing, and string conversion. It works directly with the built-in `bool` type. Concrete use cases include formatting boolean values for debugging output and comparing boolean states in logic-driven computations.",
      "description_length": 302,
      "index": 70,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_util.Util.Fork",
      "library": "elpi.util",
      "description": "This module manages forked processes with thread-local storage. It allows creating local references, forking a new process with isolated state, and performing get/set operations on local variables within that process. Concrete use cases include managing per-process configuration or state in concurrent Elpi programs.",
      "description_length": 317,
      "index": 71,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_util.Util.Show1",
      "library": "elpi.util",
      "description": "This module provides functions for converting values of type `'a t` to human-readable string representations using a provided formatter function. It includes `pp` for direct formatting to a formatter and `show` for generating strings. It is useful when inspecting or logging structured data like abstract syntax trees or configuration values.",
      "description_length": 342,
      "index": 72,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_util.Util.StrSet",
      "library": "elpi.util",
      "description": "This module offers set algebra (union, intersection, difference), ordered traversal, and transformation operations for string collections. It works with an ordered set data structure (`StrSet.t`) that supports efficient membership checks, predicate-based filtering, and conversions to/from lists and sequences. Designed for tasks like managing unique string identifiers, analyzing textual data, or implementing domain-specific languages where ordered string sets enable efficient querying and manipulation.",
      "description_length": 506,
      "index": 73,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Elpi_util.Util.StrMap",
      "library": "elpi.util",
      "description": "This module implements a string-keyed map with efficient operations for creation, modification, and querying, supporting functional updates and physical equality optimizations. It provides ordered traversal, filtering, partitioning, and transformations via functions like `map` and `filter_map`, along with conversions to lists, sequences, and formatted strings. Use cases include managing hierarchical data, processing string-indexed collections, and building pipelines that require ordered key-value manipulations or structured comparisons.",
      "description_length": 542,
      "index": 74,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_util.Util.Show2",
      "library": "elpi.util",
      "description": "This module provides functions for pretty-printing and converting structured values to strings, specifically handling values of type `('a, 'b) t`. It takes custom printers for `'a` and `'b` to format nested or composite data. Useful for debugging or logging structured data with user-defined representations.",
      "description_length": 308,
      "index": 75,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_util.Util.CData",
      "library": "elpi.util",
      "description": "This module handles typed constant data manipulation, providing operations for creating, comparing, and transforming constants with type-safe morphing and mapping functions. It works with a polymorphic type `t` representing constants and supports operations like `declare` for defining new constants, `morph1` and `morph2` for applying functions over constant values, and `map` for converting between typed constants. Concrete use cases include embedding and manipulating domain-specific values within a typed intermediate representation, such as in compilers or theorem provers.",
      "description_length": 579,
      "index": 76,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Elpi_util.Util.Loc",
      "library": "elpi.util",
      "description": "This module handles source code location tracking with operations to create, merge, and extend location data. It works with a record type containing source name, byte positions, line numbers, and optional client payloads. Concrete use cases include managing parser error locations, tracking macro expansions, and preserving source metadata during code transformations.",
      "description_length": 368,
      "index": 77,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Elpi_util.Util.IntSet",
      "library": "elpi.util",
      "description": "This module implements a purely functional set abstraction for integers, offering operations for set construction, modification (union, intersection, difference), element queries (membership, cardinality, min/max), and transformations (filtering, mapping, folding). It supports efficient iteration over ordered elements, conversion to and from lists and sequences, and safe existence checks via optional return types. Typical applications include managing collections of unique integers in algorithms requiring set operations, such as dependency tracking, graph traversal, or data processing pipelines where ordered traversal and functional purity are desired.",
      "description_length": 660,
      "index": 78,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_util.Util.Map",
      "library": "elpi.util",
      "description": "This module implements finite maps using balanced binary trees, organizing key-value pairs according to a total ordering on keys. It supports core operations like insertion, lookup, deletion, and traversal, along with advanced transformations such as mapping, filtering, and merging, enabling efficient management of ordered associative data. The key type defines comparison and formatting functions, while submodules provide extended functionality for structured iteration, conversion to sequences or lists, and customizable value display. Example uses include symbol table management, hierarchical configuration processing, and cache implementations requiring ordered key access.",
      "description_length": 681,
      "index": 79,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Elpi_util.Util.UUID",
      "library": "elpi.util",
      "description": "This module provides a UUID type `t` with operations for generating unique identifiers, comparing them, and converting them to strings. It supports direct creation and manipulation of UUIDs, enabling tasks like checking equality, ordering, and string formatting. The `Htbl` submodule builds on this by offering hash tables keyed by UUIDs, allowing efficient storage and retrieval of values indexed by unique identifiers. Together, they facilitate managing mappings from UUIDs to arbitrary data, ideal for applications like tracking AST nodes or handling entity relationships.",
      "description_length": 575,
      "index": 80,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Elpi_util.Util.Hashtbl",
      "library": "elpi.util",
      "description": "This module provides hash tables for dynamic key-value mappings with support for custom key types, seeded hashing, and bulk operations via sequences. It enables insertion, lookup, deletion, iteration, and resizing, while requiring external synchronization for thread safety. Child modules define key interfaces, imperative operations, and seeded hash customization, allowing precise control over equality and hashing behavior. Examples include building symbol tables with custom keys, bulk-loading data from sequences, and ensuring deterministic hash values across runs using seeded functions.",
      "description_length": 593,
      "index": 81,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_util.Util.Show",
      "library": "elpi.util",
      "description": "This module defines a type `t` and provides functions `pp` and `show` for converting values of type `t` into string representations, primarily used for debugging and logging. It works directly with the `Format.formatter` type to enable pretty-printing in a structured format. Concrete use cases include displaying internal data structures during development and generating readable error messages.",
      "description_length": 397,
      "index": 82,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Elpi_util.Util.Int",
      "library": "elpi.util",
      "description": "This module defines an integer type and provides comparison, pretty-printing, and string conversion operations. It works with standard integer values. Useful for handling integer keys in maps, generating readable integer output, and debugging.",
      "description_length": 243,
      "index": 83,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Elpi_util.Util.Set",
      "library": "elpi.util",
      "description": "This module implements a set data structure based on a balanced binary tree, supporting operations like adding, removing, and querying elements with efficient performance. It works with any type that has a total ordering, defined through a comparison function, enabling use cases such as maintaining unique collections, checking membership, and performing set operations like union and intersection. The child modules enhance this functionality by adding ordered set operations, transformations like map and filter, and support for custom element types with comparison and formatting functions. Together, they enable managing sorted collections, symbolic computation, and dynamic data processing with precise set manipulation and readable representations.",
      "description_length": 755,
      "index": 84,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Elpi_util.Util",
      "library": "elpi.util",
      "description": "This module offers efficient, structure-preserving manipulation of lists and maps, with operations optimized for functional updates, ordered traversal, and physical equality checks. It includes direct APIs for list transformations, map and set construction, and pretty-printing, while submodules extend functionality with cryptographic hashing, UUID handling, source location tracking, and specialized set operations over integers and strings. You can hash data with BLAKE or MD5, manage concurrent process state, compare and format constants, and build efficient associative structures keyed by strings, integers, or UUIDs. Additional utilities support set algebra, structured value logging, and custom hash table configurations with seeded hashing and bulk operations.",
      "description_length": 770,
      "index": 85,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Elpi_util",
      "library": "elpi.util",
      "description": "This module provides efficient, functional data manipulation for lists, maps, and sets, optimized for performance-critical operations like ordered traversal, physical equality checks, and bulk updates. It supports cryptographic hashing with BLAKE and MD5, UUID handling, source location tracking, and specialized set operations for integers and strings, enabling tasks like concurrent state management and structured logging. Users can build associative structures with custom hash tables, perform set algebra, and format or compare constants with precision. Example uses include hashing configuration data, tracking unique identifiers in distributed processes, and efficiently transforming large collections during compilation or analysis tasks.",
      "description_length": 746,
      "index": 86,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi.API.Ast.Name.Set",
      "library": "elpi",
      "description": "This module supports functional-style set manipulation of ordered collections of names, including union, intersection, difference, and element queries, alongside transformations like mapping and filtering. It operates on sets of `Elpi.API.Ast.Name.t` values, maintaining order and supporting predicate-based operations, with utilities for converting to and from lists and sequences. These capabilities are particularly useful for managing name bindings during program parsing or analysis, such as tracking declared variables, resolving scopes, or processing ordered name sets in interpreter workflows.",
      "description_length": 601,
      "index": 87,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi.API.Utils.Map.Make",
      "library": "elpi",
      "description": "This module implements an ordered map abstraction with polymorphic keys and values, supporting efficient insertion, lookup, and modification operations under a total ordering constraint. It provides bidirectional transformations with lists and sequences, along with ordered traversal, filtering, and pretty-printing capabilities for structured data manipulation. Typical applications include maintaining symbol tables during program analysis, processing ordered key-value associations in interpreters, and debugging through human-readable map representations.",
      "description_length": 559,
      "index": 88,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi.API.Utils.Map.OrderedType",
      "library": "elpi",
      "description": "This module defines the interface for ordered key types used in map implementations, specifying comparison and printing operations. It works with any type `t` that supports a total ordering via `compare` and pretty-printing via `pp` and `show`. Concrete use cases include using custom key types\u2014such as symbols or structured data\u2014in maps where keys must be compared and displayed.",
      "description_length": 380,
      "index": 89,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi.API.Utils.Map.S",
      "library": "elpi",
      "description": "The module implements operations for managing ordered-key dictionaries with polymorphic values, including insertion, deletion, lookup, aggregation (merge, union), ordered traversal, and value transformation. It operates on finite maps (`'a t`) with ordered keys, supporting efficient structural manipulation, sequence conversion, and predicate-based filtering while preserving key ordering. These maps are used to handle structured data in logic programs, such as variable bindings or configuration settings, during parsing and interpretation workflows.",
      "description_length": 553,
      "index": 90,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi.API.RawData.Constants.Map",
      "library": "elpi",
      "description": "This module provides persistent key-value maps where keys are ordered Elpi constants, supporting operations like insertion, deletion, bulk transformation, and ordered traversal. It enables efficient querying with ordered key constraints, sequence-based construction/iteration, and structural manipulation (e.g., merging, filtering, and splitting maps). Typical use cases include managing constant-indexed metadata during term processing, optimizing ordered data transformations in interpreters, and handling symbolic mappings in logic programming workflows.",
      "description_length": 557,
      "index": 91,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Elpi.API.Ast.Name.Map",
      "library": "elpi",
      "description": "This module provides a suite of ordered associative data operations centered on `Name` keys, supporting additions, deletions, conditional queries, bulk transformations like `map` and `filter`, and ordered traversals. It manages maps pairing `Name` keys with generic values, enabling structured conversions to lists/sequences and ordered comparisons. These maps are particularly suited for",
      "description_length": 388,
      "index": 92,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Elpi.API.Utils.Set.OrderedType",
      "library": "elpi",
      "description": "This module defines a set element type with a total ordering and pretty-printing capabilities. It supports creating and manipulating sets of elements of type `t` using comparison-based operations. Concrete use cases include managing collections of ordered elements like integers, strings, or structured data where a strict ordering is required for efficient set operations.",
      "description_length": 373,
      "index": 93,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Elpi.API.RawData.Constants.Set",
      "library": "elpi",
      "description": "This module implements ordered sets of constants with efficient membership checks and relational operations like union, intersection, and difference. It works with sorted collections of `Elpi.API.RawData.constant` elements, using a comparator to maintain order, and supports transformations through mapping, filtering, and sequence conversions. Typical applications include managing unique symbolic identifiers in compilers or interpreters where ordered traversal and set-theoretic operations are required.",
      "description_length": 506,
      "index": 94,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi.API.Utils.Set.Make",
      "library": "elpi",
      "description": "This implementation provides ordered set operations for creating, manipulating, and transforming collections with unique elements, supporting efficient union, intersection, difference, and ordered traversal via a comparator. It works with elements adhering to a total ordering, enabling structural queries (subset checks, equality) and conversions to/from sequences for processing. Such a structure is ideal for managing ordered unique data like logic program variables or terms, where sorted traversal and precise set operations are critical for analysis or unification.",
      "description_length": 571,
      "index": 95,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi.API.Utils.Set.S",
      "library": "elpi",
      "description": "This module implements a functional set abstraction for ordered elements, supporting operations like union, intersection, difference, and membership checks, while maintaining invariants through a provided comparison function. It works with sets of parametric elements (`elt`) and sequences (`Stdlib.Seq.t`), enabling ordered traversal, filtering, and transformations via functions like `map`, `filter`, and `partition`. Use cases include processing ordered collections, building sets from sequences, and generating human-readable representations of sets for debugging or output.",
      "description_length": 578,
      "index": 96,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Elpi.API.FlexibleData.Show",
      "library": "elpi",
      "description": "This module provides functions to convert unification variable data into string representations. It supports pretty-printing with `pp` and direct string conversion with `show`. Useful for debugging and displaying the contents of flexible data during program execution.",
      "description_length": 268,
      "index": 97,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Elpi.API.Ast.Type",
      "library": "elpi",
      "description": "This module defines and manipulates type expressions in the Elpi language, supporting operations like pretty-printing and string conversion. It works with algebraic data types representing type constructors, applications, and function types. Concrete use cases include inspecting and displaying types during program analysis or debugging.",
      "description_length": 338,
      "index": 98,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi.API.Setup.StrMap",
      "library": "elpi",
      "description": "This module supports functional updates, queries, and transformations on maps with string keys and arbitrary value types, offering operations like `add`, `remove`, `find`, `merge`, and `union` alongside ordered iteration and structural manipulation via `map`, `filter`, and `partition`. It maintains key order during traversal, enabling use cases like configuration management, ordered data processing, and structured data transformation with predictable traversal semantics. Additional utilities for sequence conversion, bulk binding updates, and customizable pretty-printing facilitate tasks such as serializing maps to text formats or analyzing hierarchical data.",
      "description_length": 666,
      "index": 99,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Elpi.API.FlexibleData.Map",
      "library": "elpi",
      "description": "This module implements a bidirectional map to track associations between Elpi unification variables and host language values. It supports operations to add, remove, and filter mappings, as well as to convert between Elpi and host representations. Use cases include managing variable bindings during program analysis or maintaining correspondences between logical variables and runtime values.",
      "description_length": 392,
      "index": 100,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi.API.Utils.Show1",
      "library": "elpi",
      "description": "This module provides functions for converting values into string representations or formatting them for output. It works with any data type `'a t`, using a provided formatter function to handle the internal structure of the data. Concrete use cases include printing complex data structures like terms or program elements in a readable format during debugging or result output.",
      "description_length": 376,
      "index": 101,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Elpi.API.BuiltInPredicate.Notation",
      "library": "elpi",
      "description": "This module defines operators for constructing and deconstructing tuples and optional values in a concise syntax. It works with tuples and `option` types, enabling idiomatic pattern matching and value assembly. Concrete use cases include unpacking results from parsing or interpreter steps where optional or paired values are returned.",
      "description_length": 335,
      "index": 102,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi.API.Utils.IntSet",
      "library": "elpi",
      "description": "This module offers operations for constructing, modifying, and performing algebraic operations on integer sets represented by an abstract type `t`, where elements are ordered increasingly. It supports iteration, transformation via folding and mapping, safe element access with optional variants, and conversion between sequences and sets, alongside set-theoretic operations like union, intersection, and subset checks. These capabilities are particularly useful for handling term variables, constraints, or structured data in Elpi programs where ordered set manipulation and efficient traversal are required.",
      "description_length": 608,
      "index": 103,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi.API.Ast.Name",
      "library": "elpi",
      "description": "This module manages names within the abstract syntax tree, offering operations to construct names from strings, determine global status relative to constants, and format or display names. It includes core data types like `t` for individual names and supports set and map structures through its submodules for handling ordered collections and associative data. The set submodule enables functional manipulation of name collections with union, intersection, and filtering, ideal for tracking variables or resolving scopes during analysis. The map submodule provides ordered associative operations with `Name` keys, supporting efficient lookups, transformations, and structured conversions, particularly useful for symbol tables or environment management in interpreters.",
      "description_length": 768,
      "index": 104,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Elpi.API.Utils.LocSet",
      "library": "elpi",
      "description": "This module implements ordered sets of source code location objects (`Loc.t`), supporting standard set operations like union, intersection, and difference alongside transformations such as filtering, mapping, and partitioning. It maintains strict ordering and uniqueness based on location comparisons, with utilities for ordered iteration, sequence conversion, and precise set decomposition. These capabilities are particularly useful for tracking ranges in source code, analyzing program structure, or processing ordered collections of locations during compilation or error reporting.",
      "description_length": 585,
      "index": 105,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi.API.Utils.Set",
      "library": "elpi",
      "description": "This module provides an ordered set abstraction with efficient insertion, membership, and union operations, backed by a balanced tree structure. It supports elements of any type with a total ordering, enabling set operations like union, intersection, and difference, along with ordered traversal and conversion to and from sequences. Submodules define element types with ordering and printing, implement comparator-based set operations, and provide functional transformations such as `map` and `filter`. Examples include tracking unique variables in a compiler or analyzing distinct terms in a logic program.",
      "description_length": 608,
      "index": 106,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Elpi.API.Utils.Map",
      "library": "elpi",
      "description": "This module implements finite maps using a balanced tree structure, supporting efficient key-based operations like insertion, lookup, and deletion over ordered keys. It provides core data types for maps (`'a t`) and key interfaces with comparison and pretty-printing, enabling structured manipulation of symbol tables and environment mappings. Operations include ordered traversal, filtering, merging, and conversion to and from lists, with support for custom key types that satisfy a total order. Example uses include tracking variable bindings during interpretation, processing ordered configurations, and debugging through human-readable map representations.",
      "description_length": 661,
      "index": 107,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi.API.Ast.Loc",
      "library": "elpi",
      "description": "This module handles source code location tracking with precise position and line information. It provides operations to create, compare, and format location data, including the file name, character range, and line numbers. Use cases include error reporting with exact source positions and maintaining location metadata during parsing and interpretation.",
      "description_length": 353,
      "index": 108,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi.API.Pp.Ast",
      "library": "elpi",
      "description": "This module provides functions to pretty-print Elpi programs and queries using OCaml's Format module. It operates on abstract syntax trees defined in Elpi.API.Ast, specifically the program and query types. Use it to display parsed Elpi code or queries in a human-readable form, such as for debugging or outputting results to users.",
      "description_length": 331,
      "index": 109,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi.API.Ast.Opaque",
      "library": "elpi",
      "description": "This module represents abstract syntax trees as opaque values, providing functions to pretty-print (`pp`) and convert to strings (`show`). It works with the abstract type `t`, which encapsulates Elpi AST nodes. Use this module when handling parsed Elpi programs or queries, allowing inspection and display of their structure without direct manipulation.",
      "description_length": 353,
      "index": 110,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi.API.RawPp.Debug",
      "library": "elpi",
      "description": "This module provides low-level pretty-printing functions for Elpi terms, primarily for debugging purposes. It allows direct control over the output format using OCaml's `Format.formatter` and includes a function to convert terms into their string representation. Useful for inspecting intermediate or final results during program execution, especially when tracing evaluation steps or analyzing term structure.",
      "description_length": 410,
      "index": 111,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi.API.Utils.Show",
      "library": "elpi",
      "description": "This module implements pretty-printing and string conversion for a type `t`, primarily used to format and display structured data such as parsed programs or interpreter results. It provides `pp` for formatting output to a `formatter` stream and `show` for converting values directly to strings. These functions are essential when rendering diagnostic messages, query outputs, or program structures in a human-readable form.",
      "description_length": 423,
      "index": 112,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Elpi.API.Ast.Scope",
      "library": "elpi",
      "description": "This module manages scoped identifiers and language-specific parsing rules for abstract syntax trees. It provides direct operations to pretty-print scopes, convert language tags to strings, and manipulate scoped contexts, with core data types including `scope`, `language`, and `t` for structured representations. The `Map` submodule extends this functionality by enabling identifier mappings within scoped environments, allowing for efficient lookups and transformations during parsing. Example uses include tracking variable bindings in nested scopes and preserving language-specific metadata across AST nodes.",
      "description_length": 612,
      "index": 113,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi.API.FlexibleData.Elpi",
      "library": "elpi",
      "description": "This module manages unification variables in Elpi by providing operations to create, retrieve, compare, and display them. It works with the `t` type representing Elpi unification variables and interacts with the interpreter's state to maintain variable bindings. Concrete use cases include generating fresh variables for logic programming and tracking variable identity during program execution.",
      "description_length": 395,
      "index": 114,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi.API.BuiltInPredicate.HOAdaptors",
      "library": "elpi",
      "description": "This module provides adaptors for higher-order predicates and functions, enabling operations like mapping, filtering, and folding over structured data within the Elpi interpreter. It works with conversion types and built-in predicates of arity 1 to 3, along with Elpi terms and state. Concrete use cases include transforming or filtering elements in a list based on a predicate, accumulating values with a fold, or applying a function across multiple arguments in a structured and reusable way.",
      "description_length": 494,
      "index": 115,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi.API.Ast.Term",
      "library": "elpi",
      "description": "This module constructs and manipulates abstract syntax trees for Elpi logic programs, supporting elements like lambda abstractions, logical connectives, and list structures. It operates on OCaml lists and Elpi-specific terms, enabling seamless conversion between the two and handling Coq-Elpi quotation mechanics. Typical applications include embedding Elpi expressions within OCaml code and programmatically generating logical constraints or term transformations.",
      "description_length": 464,
      "index": 116,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi.API.Compile.StrSet",
      "library": "elpi",
      "description": "This module implements a specialized ordered set structure for strings with operations like membership testing, union/intersection, filtering, and ordered traversal, preserving physical equality for efficiency. It works with an abstract type representing string sets, leveraging comparison-based ordering for extremal element retrieval and sequence conversions. Typical use cases include managing collections of unique identifiers, processing ordered string data in compilation tasks, and interfacing with list or sequence-based APIs through bidirectional conversions.",
      "description_length": 568,
      "index": 117,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi.API.FlexibleData.Host",
      "library": "elpi",
      "description": "This module defines operations for handling unification variables in the Elpi interpreter, providing comparison, pretty-printing, and string conversion functions. It works with the abstract type `t` representing host-level unification variables. Concrete use cases include managing variable identity during program parsing and query execution, and displaying variable information for debugging or user feedback.",
      "description_length": 411,
      "index": 118,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi.API.RawData.Constants",
      "library": "elpi",
      "description": "This module defines built-in logical constants and control structures used throughout Elpi programs, enabling the representation and manipulation of symbolic logic elements. It supports global symbol declarations, constant comparison, and integration with term construction via the RawData API, forming the foundation for symbolic computation. The associated map module handles ordered, persistent mappings from constants to values, supporting efficient updates, queries, and transformations over symbolic data. The set module provides ordered collections of constants with fast membership checks and relational operations, ideal for managing unique identifiers and symbolic constraints in logic programs.",
      "description_length": 705,
      "index": 119,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi.API.OpaqueData",
      "library": "elpi",
      "description": "This module handles the declaration and conversion of opaque data types, such as integers, that have no associated syntax. It allows embedding host application data into Elpi values without exposing their internal structure. Use cases include passing and retrieving primitive values like integers or custom identifiers between OCaml and Elpi code.",
      "description_length": 347,
      "index": 120,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi.API.FlexibleData",
      "library": "elpi",
      "description": "This module coordinates the handling of Elpi unification variables alongside their host language counterparts, enabling creation, comparison, and conversion between representations. It centers around the `t` type, which models unification variables, and supports operations like variable generation, identity checks, and state-aware binding management. Child modules extend this functionality with bidirectional mappings between Elpi and host values, string conversion, and pretty-printing, facilitating tasks like program analysis, logic programming, and debugging. For example, one can generate a fresh unification variable, associate it with a host value, convert it to a string for logging, or track its usage across transformations.",
      "description_length": 737,
      "index": 121,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Elpi.API.Pp",
      "library": "elpi",
      "description": "This module formats and prints Elpi terms, constraints, states, programs, and goals using OCaml's formatting library, converting internal structures into human-readable strings. It directly supports data types like `term`, `constraints`, `state`, `program`, and `query`, and integrates with child modules that handle abstract syntax trees from Elpi.API.Ast. Use it to display parsed Elpi programs or queries, such as for debugging or generating output for users. The API combines direct formatting functions with submodules focused on program and query display.",
      "description_length": 561,
      "index": 122,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi.API.Utils",
      "library": "elpi",
      "description": "This module handles error reporting, term manipulation, and data conversion between OCaml and LP, while organizing structured data through Map, Set, IntSet, and LocSet. It supports low-level term operations like beta reduction and lifting, and clause processing, with utilities to format and print complex data structures using customizable formatters. Child modules enhance integer and location set handling with ordered traversal, safe access, and set operations, while providing efficient map implementations for key-based data. Examples include tracking term variables, rendering interpreter outputs, and managing source location ranges during analysis.",
      "description_length": 657,
      "index": 123,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi.API.RawData",
      "library": "elpi",
      "description": "This module provides low-level access to Elpi's abstract term representation, allowing direct manipulation of opaque `term` values through smart constructors like `mkLam` and `mkAppGlobal`, and structured inspection via the `look` function that resolves unification variables. It supports operations on logical contexts (`hyps`) and suspended goals, enabling term construction, hypothesis conversion, and constraint transformation in unification and higher-order syntax handling. The built-in constants module defines core logical primitives and control forms, supporting symbol declarations, comparisons, and integration with term APIs for symbolic computation. Maps and sets over constants provide efficient, ordered, persistent data structures for managing symbolic identifiers and constraints in logic programs.",
      "description_length": 815,
      "index": 124,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi.API.RawQuery",
      "library": "elpi",
      "description": "This module compiles queries and terms directly from raw data structures, allowing precise control over query construction. It operates on Elpi AST and raw terms, converting them into executable queries while managing interpreter state transitions. It is used to build and manipulate logic program queries programmatically, such as embedding preprocessed terms or dynamically generating goals for execution.",
      "description_length": 407,
      "index": 125,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi.API.BuiltIn",
      "library": "elpi",
      "description": "This module handles the declaration and documentation of built-in data types and predicates for the Elpi interpreter. It processes lists of declarations, including ML-defined types and predicates, and generates corresponding LP syntax documentation. It is used to construct the prelude that forms the initial context for Elpi programs, and to output built-in definitions to files or formatters.",
      "description_length": 394,
      "index": 126,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Elpi.API.Compile",
      "library": "elpi",
      "description": "This module compiles Elpi programs and queries into executable forms, handling scoping, type checking, and optimization, while its child module provides an efficient ordered set structure for strings. The core functionality operates on abstract syntax trees and scoped programs to produce runnable queries, supporting program extension, optimization, and signature extraction. The child module enhances this process by managing unique identifiers and ordered string data through operations like membership testing, union, intersection, and ordered traversal. Together, they enable tasks such as compiling source code into executables, tracking type checking time, and interfacing with list-based APIs using set operations.",
      "description_length": 722,
      "index": 127,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Elpi.API.Parse",
      "library": "elpi",
      "description": "This module parses Elpi programs and queries from files or strings, producing abstract syntax trees. It supports file resolution with customizable search paths and handles lexical analysis through standard or custom resolvers. Use it to load and parse Elpi source files or inline queries for interpretation.",
      "description_length": 307,
      "index": 128,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Elpi.API.Setup",
      "library": "elpi",
      "description": "This module initializes and configures the Elpi interpreter with custom builtins, state, and parsing behavior, enabling tailored runtime environments and debugging support. It provides operations to set up error handlers, formatters, and file resolvers, allowing applications to embed Elpi with specific semantics for program loading and execution. Alongside these capabilities, it includes a submodule for manipulating ordered maps with string keys, supporting functional updates, queries, and transformations with predictable traversal order. Use cases include embedding Elpi in a host application, managing configuration data, and processing structured information with custom formatting and error handling.",
      "description_length": 710,
      "index": 129,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi.API.Conversion",
      "library": "elpi",
      "description": "This module handles the conversion between OCaml and Elpi data representations, enabling the embedding of OCaml values into Elpi terms and the readback of Elpi terms into OCaml values. It works with Elpi's abstract syntax trees, represented by `ty_ast`, and supports operations like unification through the `Unify` constructor in `extra_goal`. Concrete use cases include transforming OCaml data structures into Elpi terms for query execution and extracting results from Elpi back into OCaml after computation.",
      "description_length": 509,
      "index": 130,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Elpi.API.State",
      "library": "elpi",
      "description": "This module manages a purely functional state that is synchronized with the interpreter's backtracking, allowing storage and retrieval of custom data such as constraints or application-specific values. It provides operations to declare state components with initialization, pretty-printing, and update functions, and to manipulate these components within the interpreter's state. Concrete use cases include tracking solver constraints, maintaining per-branch application data, and implementing custom logic that requires persistence across interpreter steps.",
      "description_length": 558,
      "index": 131,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Elpi.API.RawOpaqueData",
      "library": "elpi",
      "description": "This module provides low-level operations for manipulating opaque data values, including type-safe conversions between OCaml primitives (floats, strings, locations) and Elpi's abstract representation, along with comparison, hashing, and structural transformations. It centers on the `t` type, which represents opaque data within the Elpi AST, enabling direct inspection and modification of term contents. These capabilities are essential for integrating OCaml-level data into Elpi programs, validating term types during interpretation, or implementing custom data marshaling logic between the host and embedded languages.",
      "description_length": 621,
      "index": 132,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi.API.Calc",
      "library": "elpi",
      "description": "This module handles arithmetic and logical operations within the Elpi interpreter by defining and registering custom operations. It works with `operation_declaration` and `calc_descriptor` to register symbols, argument patterns, and evaluation logic for terms. Use cases include extending the interpreter with domain-specific calculations or custom evaluation rules that integrate with Elpi's term structure.",
      "description_length": 408,
      "index": 133,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi.API.BuiltInData",
      "library": "elpi",
      "description": "This module defines conversions between OCaml's primitive types (integers, floats, strings) and their representations in Elpi's abstract syntax tree. It supports structured data like lists, source code locations, and polymorphic terms, enabling precise marshaling of values to and from Elpi's internal term format. Use cases include embedding OCaml values directly into Elpi programs or extracting results from evaluated Elpi terms into native OCaml data.",
      "description_length": 455,
      "index": 134,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Elpi.API.Data",
      "library": "elpi",
      "description": "This module represents terms, constraints, and proof states for logic programs. It defines core data structures like `term`, `constraints`, `state`, and `hyps` used to model program elements and execution context. It supports operations for building and manipulating logic program terms, managing proof states during execution, and handling constraints and hypotheses in logic programming tasks.",
      "description_length": 395,
      "index": 135,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi.API.ContextualConversion",
      "library": "elpi",
      "description": "This module supports contextual conversion between terms and OCaml values, handling data types that depend on logical context information like hypotheses and constraints. It provides operators to lift and lower functions and values between contextual and non-contextual representations, enabling precise embedding and readback of structured data. Concrete use cases include converting between Elpi terms and OCaml data during program parsing, query execution, and result serialization.",
      "description_length": 485,
      "index": 136,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Elpi.API.BuiltInPredicate",
      "library": "elpi",
      "description": "This module enables interaction with Elpi's interpreter by defining built-in predicates that handle argument conversion between OCaml and Elpi, supporting FFI registration, groundness management, and unification control. It provides core operations for implementing logic like type checking and error diagnostics, where predicates distinguish between variables, constants, and structured data. The first child module introduces operators for working with tuples and optional values, streamlining pattern matching and result handling from parsing or interpreter steps. The second child module offers adaptors for higher-order operations such as map, filter, and fold, allowing structured transformations over Elpi terms and state with predicates of arity 1 to 3.",
      "description_length": 761,
      "index": 137,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Elpi.API.Quotation",
      "library": "elpi",
      "description": "This module handles parsing and processing of quoted terms in Elpi, supporting custom syntax for embedding object-language expressions. It provides functions to define and register quotation mechanisms, including named and default quotations, as well as special handling for backtick and single-quote delimiters. These operations are used to integrate domain-specific syntax into Elpi programs, such as representing strings with custom semantics or embedding other logical constructs.",
      "description_length": 484,
      "index": 138,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi.API.AlgebraicData",
      "library": "elpi",
      "description": "This module allows declaring algebraic data types with constructors that have associated syntax, such as `option a`, `list a`, or `pair a b`, by defining their type name, documentation, and structure using a GADT-based interface. It supports building and pattern-matching on such data with correct typing, enabling integration of custom data structures into the Elpi interpreter. Concrete use cases include defining the representation of higher-level data types used in Elpi programs and queries, such as lists or optional values, with proper type-level encoding.",
      "description_length": 563,
      "index": 139,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi.API.Execute",
      "library": "elpi",
      "description": "This module runs Elpi programs and queries. It provides `once` to execute a program up to a solution or failure, and `loop` to continue searching for solutions interactively, such as in a REPL. It works with compiled Elpi programs and handles outcomes like success, failure, or step limits.",
      "description_length": 290,
      "index": 140,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Elpi.API.Ast",
      "library": "elpi",
      "description": "The module defines the abstract syntax tree for Elpi programs and queries, combining core constructs like terms, types, and opaque expressions with utilities for building, traversing, and transforming them. It includes submodules for handling type expressions, name management with sets and maps, source location tracking, pretty-printing of AST nodes, scoped identifiers, and logic program construction. Main data types include terms, types, names, and locations, with operations to create variables, applications, lambda abstractions, and to inspect or display structure with precise source information. Example uses include programmatically generating Elpi code, analyzing expressions during parsing, and managing scoped environments for interpreters.",
      "description_length": 754,
      "index": 141,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi.API.RawPp",
      "library": "elpi",
      "description": "This module combines high-level pretty-printing for terms, constraints, and polymorphic lists with low-level term formatting tools. It supports customizable output through formatters and string conversions, handling complex structures with binder depth awareness, truncation, and user-defined printers. Use it to display Elpi terms during debugging, render constraint sets, or format nested lists with controlled detail. The integration of direct formatting functions and child module utilities enables both flexible inspection and structured output customization.",
      "description_length": 564,
      "index": 142,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi.API",
      "library": "elpi",
      "description": "This module provides a comprehensive interface for embedding, executing, and interacting with Elpi logic programs from OCaml. It supports parsing Elpi source code into abstract syntax trees, constructing and manipulating terms with rich context handling, and executing queries with backtracking-aware state management. Key data types include `term`, `constraints`, `state`, and `program`, with operations for term building (`mkLam`, `mkAppGlobal`), unification variable handling, type-safe data conversion, and custom predicate registration. Users can compile and run Elpi programs, inspect execution results, generate documentation for built-in constructs, and format complex structures for debugging or user output.",
      "description_length": 717,
      "index": 143,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi.Builtin",
      "library": "elpi",
      "description": "This module provides type conversion utilities for bridging OCaml and Elpi representations, focusing on standard types (int, string, option), collections (Map, Set), and logic programming constructs (diagnostic handling, stream processing). It supports use cases like integrating OCaml libraries with Elpi code, managing I/O operations through channel-string conversions, and implementing error-aware logic workflows via diagnostic types and contextual conversion patterns.",
      "description_length": 473,
      "index": 144,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Elpi",
      "library": "elpi",
      "description": "This module enables seamless interaction between OCaml and Elpi logic programs, offering structured parsing, term manipulation, and query execution with context-aware state handling. It centers around data types like `term`, `state`, and `constraints`, supporting operations such as term construction (`mkLam`, `mkAppGlobal`), unification, and custom predicate registration. It also provides type-safe conversion utilities for standard OCaml types, collections, and logic constructs, facilitating integration of OCaml libraries with Elpi, handling I/O through channels, and implementing error-aware logic workflows. Users can compile and run Elpi programs, process streams, generate documentation, and format complex terms for debugging or output.",
      "description_length": 747,
      "index": 145,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_parser.Parse.Make.Internal",
      "library": "elpi.parser",
      "description": "This module provides functions to parse infix, prefix, and postfix operators from a lexing buffer, converting them into abstract syntax tree nodes. It operates on lexbuf streams and token streams defined by the Elpi lexer and parser libraries. These functions are used to handle operator parsing in Elpi source code, such as interpreting arithmetic or logical operators in expressions.",
      "description_length": 385,
      "index": 146,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Elpi_parser.Ast.Func.Map",
      "library": "elpi.parser",
      "description": "Provides operations for inserting, removing, and querying key-value pairs with ordered keys, supporting transformations like merging, filtering, and ordered traversal. The module works with functional maps storing `Elpi_parser.Ast.Func.t` keys, enabling use cases such as symbol table management, AST node grouping, and ordered data aggregation. Additional utilities include bidirectional iteration, list/sequence conversion, and customizable pretty-printing for structured analysis or debugging.",
      "description_length": 496,
      "index": 147,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_parser.Ast.Func.Set",
      "library": "elpi.parser",
      "description": "This interface offers operations for managing immutable, ordered collections of elements, including union, intersection, difference, and transformations like mapping or filtering, while preserving sorted order. It works with sets of a specific element type, supporting efficient membership checks, iteration, and conversions to and from lists or ordered sequences. Typical applications include processing ordered data structures where immutability is critical, such as symbolic computation or compiler intermediate representations requiring deterministic traversal.",
      "description_length": 565,
      "index": 148,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Elpi_parser.Ast.Type",
      "library": "elpi.parser",
      "description": "This module provides functions for pretty-printing, converting to strings, and comparing abstract syntax tree (AST) nodes representing types in the Elpi language. It operates on the polymorphic `Type.t` type, which carries attributes at different levels of the type structure. These functions are used when displaying or comparing type expressions during parsing, type checking, or error reporting in Elpi tooling.",
      "description_length": 414,
      "index": 149,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Elpi_parser.Parse.Parser_w_Internals-Internal",
      "library": "elpi.parser",
      "description": "This module defines functions for parsing infix, prefix, and postfix operators in the Elpi language. It processes input using a lexer function and constructs corresponding abstract syntax tree (AST) nodes for operator expressions. These functions are used during the parsing phase to correctly interpret operator notation in Elpi source code.",
      "description_length": 342,
      "index": 150,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_parser.Parser_config.ParseFile",
      "library": "elpi.parser",
      "description": "This module provides functions to parse files into a list of program parser outputs, supporting customizable working directory paths. It includes operations to retrieve and set a client location payload, enabling contextual tracking during parsing. Concrete use cases include processing Elpi source files with location-aware error reporting and managing per-client state in multi-user environments.",
      "description_length": 398,
      "index": 151,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_parser.Ast.Structured",
      "library": "elpi.parser",
      "description": "This module provides utilities for manipulating structured Elpi programs composed of macros, types, blocks, and attributes, with core operations focused on pretty-printing, string conversion, and structural comparison of AST nodes. It handles fine-grained elements like `shorthand`, `functionality`, and `variadic` types, alongside composite structures such as `program` and `block`, enabling precise analysis and transformation. These capabilities are critical for tasks like parsing logic programs, implementing compiler toolchains, or enforcing constraints during program manipulation.",
      "description_length": 588,
      "index": 152,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_parser.Ast.TypeAbbreviation",
      "library": "elpi.parser",
      "description": "This module handles type abbreviations in the Elpi parser's abstract syntax tree. It provides functions to pretty-print, convert to string, and compare both closed type expressions and type abbreviations with custom name and type parameters. These operations are used when processing and manipulating type definitions during parsing or analysis of Elpi code.",
      "description_length": 358,
      "index": 153,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_parser.Parse.Make",
      "library": "elpi.parser",
      "description": "This module parses Elpi programs and goals from files or strings, producing abstract syntax trees, and includes submodules for handling operator parsing. It supports loading entire programs from a file path or lex buffer and evaluating individual goals from user input. The main data types are abstract syntax trees, and key operations include parsing Elpi source code into declarations and processing operator expressions. Examples include loading an Elpi source file into AST declarations or parsing and evaluating a goal like \"X + Y\" from a string.",
      "description_length": 551,
      "index": 154,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_parser.Ast.Term",
      "library": "elpi.parser",
      "description": "This module enables the creation and transformation of abstract syntax trees for terms, types, and quoted expressions in a logic programming language, using algebraic data types like `t_`, `typ`, and `quote`. It provides utilities to construct structured terms (e.g., lambda abstractions, type casts, unification variables) with metadata such as source locations, alongside operations for pretty-printing, comparison, and serialization. These tools are essential for tasks like term manipulation, code generation, and analysis in logic programming systems.",
      "description_length": 556,
      "index": 155,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_parser.Ast.Mode",
      "library": "elpi.parser",
      "description": "This module defines a type `t` with two variants, `Input` and `Output`, representing directional modes in a parsing context. It provides functions `pp` for pretty-printing, `show` for string conversion, and `compare` for ordering between mode values. These operations support tasks like logging, debugging, and comparison-based logic in parser configuration or analysis tools.",
      "description_length": 376,
      "index": 156,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Elpi_parser.Parse.Parser",
      "library": "elpi.parser",
      "description": "Parses logic programs and goals from files or string input into abstract syntax trees. It processes input using lexing buffers and location tracking to produce structured program declarations or goal terms. Useful for loading and interpreting Elpi source code or evaluating expressions from external input sources.",
      "description_length": 314,
      "index": 157,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Elpi_parser.Ast.Func",
      "library": "elpi.parser",
      "description": "This module manages functional, ordered data structures with support for key-value mappings and element sets, enabling efficient insertion, transformation, and traversal. It provides direct operations on maps with `Elpi_parser.Ast.Func.t` keys for symbol tables and AST grouping, while its submodules handle ordered sets with union, intersection, and mapping capabilities. You can perform bidirectional iteration, convert between lists and ordered structures, and apply custom transformations or filters while maintaining immutability. Use cases include symbolic computation, compiler IR processing, and structured data analysis with deterministic traversal and customizable output formatting.",
      "description_length": 693,
      "index": 158,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_parser.Grammar.Make",
      "library": "elpi.parser",
      "description": "This module defines parsing functions for constructing Elpi programs, terms, and function symbols from token streams. It processes input using a lexer function and produces AST nodes such as programs, goals, and function declarations with specific fixity. It is used to parse Elpi source code into structured representations for further processing or evaluation.",
      "description_length": 362,
      "index": 159,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_parser.Ast.Program",
      "library": "elpi.parser",
      "description": "This module represents and manipulates the abstract syntax tree for a program in the Elpi language. It defines declarations such as clauses, constraints, macros, and type definitions, along with their locations and attributes. It is used to parse, pretty-print, and analyze Elpi source code structures during compilation or tooling tasks.",
      "description_length": 338,
      "index": 160,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_parser.Parse.Config",
      "library": "elpi.parser",
      "description": "Stores version information for various units and resolves unit paths. Uses a string map to associate unit names with version tuples and provides a function to determine the path of a unit, optionally relative to a given directory. Useful for managing versioned modules and resolving their locations during parsing.",
      "description_length": 314,
      "index": 161,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_parser.Ast.Chr",
      "library": "elpi.parser",
      "description": "This module handles pretty-printing and comparison operations for sequents and CHR (Constraint Handling Rules) structures parameterized over attribute and term types. It provides functions to format sequents and CHR rules to strings or output streams, and to compare these structures based on custom comparison functions for attributes and terms. These operations are used when displaying or logging CHR-based logic programs, or during testing and debugging of constraint systems.",
      "description_length": 480,
      "index": 162,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_parser.Ast.Macro",
      "library": "elpi.parser",
      "description": "This module provides functions for pretty-printing and converting macro definitions to strings, using custom formatting functions for names and terms. It operates on the `('name, 'term) t` type, representing macros in the Elpi abstract syntax tree. Concrete use cases include displaying macro expansions during debugging or logging, and generating human-readable representations of macros for error messages or tool output.",
      "description_length": 423,
      "index": 163,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_parser.Ast.Clause",
      "library": "elpi.parser",
      "description": "This module provides functions for pretty-printing, converting to strings, and comparing structured clause data with customizable formatting and comparison behaviors for terms, attributes, and spill data. It operates on clauses parameterized by term, attribute, and spill types, allowing integration of user-defined data structures into standard rendering and comparison workflows. Concrete use cases include displaying or diffing parsed logic clauses with custom term representations.",
      "description_length": 485,
      "index": 164,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Elpi_parser.Ast.Goal",
      "library": "elpi.parser",
      "description": "This module represents logical goals as terms and provides functions to pretty-print and convert them to strings. It works directly with the `Term.t` type from the `Elpi_parser.Ast` module. Use this module when displaying or debugging logical goals in a parser or interactive system.",
      "description_length": 283,
      "index": 165,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_parser.Parse.Parser_w_Internals",
      "library": "elpi.parser",
      "description": "Parses Elpi source code into abstract syntax trees, handling both program declarations and goals. It processes input from files or lex buffers, producing structured data like `decl list` and `Goal.t`. Useful for loading Elpi programs or evaluating inline goals from strings or streams.",
      "description_length": 285,
      "index": 166,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_parser.Ast.TypeExpression",
      "library": "elpi.parser",
      "description": "This module provides functions to pretty-print, convert to strings, and compare type expressions with attributes. It operates on the `t_` and `t` data types, which represent structured type expressions. These operations are used to display and analyze type information in ELPI programs, such as for debugging or error reporting.",
      "description_length": 328,
      "index": 167,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Elpi_parser.Error_messages",
      "library": "elpi.parser",
      "description": "This module maps integer error codes to descriptive error messages. It provides a `message` function that takes an integer code and returns the corresponding string message. Useful for converting internal error codes into user-readable diagnostics during parsing or compilation tasks.",
      "description_length": 284,
      "index": 168,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_parser.Grammar",
      "library": "elpi.parser",
      "description": "This module provides parsing functionality to convert token streams into structured Elpi AST elements such as programs, goals, and function declarations. It processes input using a lexer and constructs abstract syntax trees with support for operator fixity. Key operations include parsing Elpi source code into executable terms and extracting function symbols with their associated syntax properties. Example uses include loading Elpi programs from files and evaluating Elpi expressions from strings.",
      "description_length": 500,
      "index": 169,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_parser.Parse",
      "library": "elpi.parser",
      "description": "This module implements a parser combinator library for building recursive descent parsers with support for custom token types and error reporting. It provides core functionality for defining grammars, parsing input streams, and constructing abstract syntax trees, with data types including parsers, lex buffers, and AST nodes. Submodules handle operator parsing, loading and evaluating Elpi programs and goals, and resolving versioned unit paths using string maps. Examples include parsing and evaluating a goal like \"X + Y\" from a string, loading an Elpi source file into structured declarations, and resolving module paths during parsing based on version information.",
      "description_length": 669,
      "index": 170,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Elpi_parser.Ast",
      "library": "elpi.parser",
      "description": "This module defines the core data structures and operations for constructing and manipulating Elpi abstract syntax trees, including types like `raw_attribute`, `Term.t`, `Clause.t`, and `Program.t`. It supports parsing, pretty-printing, comparison, and transformation of logic programs, with structured handling of terms, types, macros, and attributes across submodules. You can build and analyze Elpi code with precise control over type abbreviations, directional modes, sequents, and CHR rules, while utilities for maps and ordered sets enable efficient symbol table management and AST grouping. Use cases include custom term representation, program transformation, constraint system debugging, and compiler toolchain development.",
      "description_length": 732,
      "index": 171,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_parser.Parser_config",
      "library": "elpi.parser",
      "description": "This module manages parsing configurations for Elpi, defining operator precedences and handling mixfix token formatting, while also supporting file parsing with customizable working directories and location-aware error reporting. It provides operations to retrieve and set client-specific state, format token lists, and manage legacy parser compatibility. Key data types include configurations for operator precedence and parser outputs with location payloads. Examples include configuring custom syntax parsing behavior and processing Elpi source files with contextual error tracking.",
      "description_length": 585,
      "index": 172,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elpi_parser.Lexer",
      "library": "elpi.parser",
      "description": "This module provides functions for tokenizing source code, handling comments (single-line, multi-line, conditional), string literals, quoted content, and line number tracking. It operates on `Lexing.lexbuf` input buffers and `Buffer.t` for character stream management, using state integers and version-specific configuration maps to control lexing behavior. The module supports conditional compilation directives and customizable parsing through recursive token extraction routines and lookahead operations, enabling flexible source code analysis with version-dependent rules.",
      "description_length": 576,
      "index": 173,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Elpi_parser",
      "library": "elpi.parser",
      "description": "This module processes Elpi source code into executable logic programs by combining lexical analysis, configurable parsing, and abstract syntax tree manipulation. It supports tokenization with comment handling, operator-aware parsing, and structured program construction using types like `Term.t`, `Clause.t`, and `Program.t`. You can load and evaluate Elpi code from strings or files, customize syntax rules, and resolve module paths during parsing. Examples include parsing and executing goals like \"X + Y\", transforming logic programs with custom term representations, and configuring operator precedence for domain-specific syntax.",
      "description_length": 634,
      "index": 174,
      "embedding_norm": 0.9999999403953552
    }
  ],
  "filtering": {
    "total_modules_in_package": 180,
    "meaningful_modules": 175,
    "filtered_empty_modules": 5,
    "retention_rate": 0.9722222222222222
  },
  "statistics": {
    "max_description_length": 931,
    "min_description_length": 243,
    "avg_description_length": 513.4914285714286,
    "embedding_file_size_mb": 0.6360692977905273
  }
}