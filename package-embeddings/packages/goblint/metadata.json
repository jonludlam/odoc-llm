{
  "package": "goblint",
  "embedding_model": "Qwen/Qwen3-Embedding-0.6B",
  "embedding_dimension": 1024,
  "total_modules": 2040,
  "creation_timestamp": "2025-07-16T02:16:40.494545",
  "modules": [
    {
      "module_path": "Goblint_sites",
      "library": "goblint_sites_js",
      "description": "This module defines lists of file paths for organizing library and configuration resources. It includes separate fields for library source files, stubs, runtime components, and configuration files, all represented as `Fpath.t` values. These lists are used to locate and manage different parts of a project's structure, such as including headers or linking source files during compilation or analysis.",
      "description_length": 400,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ConcDomain.ThreadCreation.UNames",
      "library": "goblint_cdomain_value",
      "description": "This module manages unique thread identifiers, providing constants for boolean thread names and a string identifier. It works with string values to represent thread states and identities. Concrete use cases include labeling threads with unique names for debugging and tracking execution flow in concurrent programs.",
      "description_length": 315,
      "index": 1,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Offset.Index.Printable",
      "library": "goblint_cdomain_value",
      "description": "This module defines a printable index type with operations for comparison, hashing, serialization, and conversion to integers. It works with abstract index values represented as type `t`, supporting concrete use cases like tracking array indices or struct fields in symbolic execution. Functions like `show`, `printXml`, and `to_yojson` enable direct representation in logs, XML, and JSON formats.",
      "description_length": 397,
      "index": 2,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "ConcDomain.ThreadCreation.DirtyExit",
      "library": "goblint_cdomain_value",
      "description": "This module supports lattice-based analysis of thread termination states by providing operations to compare, combine, and analyze abstract values tracking whether threads exit in a \"dirty\" (abrupt or error-prone) manner. It works with an abstract type representing thread creation states in dataflow analysis, structured as a boolean lattice with explicit top/bottom elements to model definite or unknown exit conditions. The functionality is particularly useful in static analysis frameworks for reasoning about concurrency correctness, such as ensuring proper resource cleanup or identifying unhandled exceptions in parallel execution paths.",
      "description_length": 643,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ThreadIdDomain.FlagConfiguredTID.D",
      "library": "goblint_cdomain_value",
      "description": "This module provides lattice-theoretic operations (join, meet, widen, narrow) alongside equality, ordering, and serialization capabilities for an abstract thread ID domain type. It manipulates values representing thread identifiers within a structured lattice hierarchy, including distinguished top elements that signify maximal information in static analysis contexts. The functionality supports program verification tasks requiring precise abstraction of thread states through algebraic reasoning and domain combination.",
      "description_length": 522,
      "index": 4,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "AddressDomain.AddressSet.Addr",
      "library": "goblint_cdomain_value",
      "description": "This module provides abstractions for handling address values with operations to convert between addresses and strings, variables, or mvalues, along with offset manipulation and type inspection. It works with abstract address representations (`t`) that include pointers, null values, and string literals, integrating lattice operations like join, meet, and widening for domain analysis. These capabilities are used in static analysis to track pointer semantics, resolve address equivalences, and model memory state transitions.",
      "description_length": 527,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "AddressDomain.AddressLatticeRepr.VariableRepr",
      "library": "goblint_cdomain_value",
      "description": "This module represents variables in a memory address lattice without value offsets, providing operations for equality, comparison, hashing, and pretty-printing. It works with a type `t` that identifies variables uniquely via a tag and supports serialization to XML and JSON formats. Concrete use cases include tracking variable identifiers during static analysis and enabling efficient comparisons in lattice-based computations.",
      "description_length": 428,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "NullByteSet.MustSet.M",
      "library": "goblint_cdomain_value",
      "description": "This module provides lattice-based abstract interpretation operations for sets of big integers, representing potential NULL byte positions in C arrays. It supports standard set operations (union, intersection, difference), element queries (min, max, membership), and domain transformations (widening/narrowing) over a data structure that combines concrete big integer sets with top/bottom elements for over/under-approximation. The design enables static analysis tools to track null byte propagation in C programs, particularly for detecting buffer overflow vulnerabilities or string handling errors during program analysis.",
      "description_length": 624,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ThreadIdDomain.Thread.D",
      "library": "goblint_cdomain_value",
      "description": "This module provides lattice-based abstractions for thread identifiers, supporting operations like join, meet, widen, narrow, and partial order comparisons (leq) to model thread state relationships. It works with an abstract type representing thread ID domains, including distinguished elements like bottom (bot) and top (is_top) for lattice boundaries. These abstractions are used in static analysis tools to reason about concurrent program behavior, such as tracking thread creation, synchronization, or termination patterns in abstract interpretation frameworks.",
      "description_length": 565,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ConcDomain.ThreadCreation.DirtyExitNames",
      "library": "goblint_cdomain_value",
      "description": "This module defines string constants representing names for dirty exit scenarios in thread creation. It works with string values to identify special thread names associated with unexpected termination. Concrete use cases include labeling threads that exit abnormally for debugging or logging purposes.",
      "description_length": 301,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Offset.Index.Unit",
      "library": "goblint_cdomain_value",
      "description": "This module represents indices as a unit type, providing equality, comparison, and conversion operations. It works with abstract index values that carry no data, used to model arbitrary or symbolic indices in offset domains. Concrete use cases include serving as a placeholder in array or struct field indexing when the specific index value is irrelevant or semantically uniform.",
      "description_length": 379,
      "index": 10,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ThreadIdDomain.History.D",
      "library": "goblint_cdomain_value",
      "description": "This module implements a lattice structure with operations for comparison (`equal`, `compare`, `leq`), algebraic combinations (`join`, `meet`, `widen`, `narrow`), and extremal value handling (`bot`, `top`, `is_bot`, `is_top`), tailored for abstract analysis of thread execution histories. It operates on an abstract type `D.t` that models thread ID domains, enabling static analysis of concurrent programs by tracking and reasoning about thread interactions and state transitions. The lattice supports domain-specific representations for debugging and integration with analysis frameworks, such as XML or JSON serialization.",
      "description_length": 624,
      "index": 11,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "AddressDomain.AddressLatticeRepr.UnitOffsetRepr",
      "library": "goblint_cdomain_value",
      "description": "This module represents address lattice elements without offset indices, providing equality, comparison, and serialization operations. It works with a single abstract type `t` that encapsulates unit offset representatives, supporting concrete use cases such as tracking pointer identities in static analysis without considering memory offsets. Functions like `tag`, `show`, and `to_yojson` enable debugging, logging, and integration with analysis frameworks requiring unique identifiers and structured output.",
      "description_length": 508,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ValueDomain.ValueInvariant.VS",
      "library": "goblint_cdomain_value",
      "description": "This module supports set-theoretic operations (union, intersection, difference), functional transformations (mapping, filtering, folding), and sequence conversions (ordered traversal, bulk additions) over variable sets. It operates on sets of variables (`Basetype.Variables.t`) and sequences, enabling use cases like static analysis passes that require tracking and manipulating variable relationships through precise set semantics and ordered processing.",
      "description_length": 455,
      "index": 13,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Offset.Index.Z",
      "library": "goblint_cdomain_value",
      "description": "This module defines a concrete index type based on arbitrary-precision integers, supporting equality checks, hashing, comparison, and conversion to integers. It is used to represent and manipulate precise array indices or struct field offsets in a program analysis context. Operations include semantic equality testing against integers, pretty-printing, XML and JSON serialization, and generation of arbitrary values for testing.",
      "description_length": 429,
      "index": 14,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Offset.Index.Exp",
      "library": "goblint_cdomain_value",
      "description": "This module implements index domains for array and struct offsets using expressions, supporting comparisons, hashing, and semantic checks against integers. It works directly with `GoblintCil.exp` values, enabling precise index tracking and symbolic reasoning in static analysis. Concrete use cases include handling unknown indices during global initialization and representing all indices for strong array updates in analysis invariants.",
      "description_length": 437,
      "index": 15,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Offset_intf.Index.Printable",
      "library": "goblint_cdomain_value",
      "description": "This module defines operations for comparing, hashing, and converting index values to strings or XML, specifically for use in printable representations. It works with an abstract type `t` that represents an offset index, supporting semantic equality checks against integers and conversion to exact integers when possible. Concrete use cases include pretty-printing offset values in debugging tools and serializing them for logging or analysis.",
      "description_length": 443,
      "index": 16,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ConcDomain.ThreadCreation.ParentThreadSet",
      "library": "goblint_cdomain_value",
      "description": "This abstraction provides standard set-theoretic operations (union, intersection, difference) and lattice operations (join, meet, bot, top) for managing immutable collections of thread identifiers. It is specifically designed for concurrency analysis tasks, enabling precise representation of parent-child thread relationships and domain-specific lattice manipulations to track thread creation hierarchies in static program analysis. The type-safe interface supports functional transformations, comparisons, and serialization, facilitating integration with abstract interpretation frameworks analyzing concurrent systems.",
      "description_length": 621,
      "index": 17,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ThreadIdDomain.Unit.D",
      "library": "goblint_cdomain_value",
      "description": "This module supports lattice-based analysis of thread identifiers through operations like join, meet, widen, and narrowing, alongside equality checks and ordering relations on an abstract type modeling thread states. It is designed for concurrent systems analysis, enabling static approximation of thread interactions and integration with verification tools. The domain includes utilities for structured serialization, pretty-printing, and test framework compatibility to support practical analysis workflows.",
      "description_length": 509,
      "index": 18,
      "embedding_norm": 1.0
    },
    {
      "module_path": "NullByteSet.MustMaySet.Set",
      "library": "goblint_cdomain_value",
      "description": "This module implements a specialized set structure for tracking nullable byte positions in C arrays using arbitrary-precision integers. It supports standard set operations like union, intersection, and difference, along with lattice operations (join, meet, widen, narrow) for static analysis. The type-safe API includes utilities for partitioning sets based on byte value predicates, extracting element ranges, and handling universal set states, primarily serving abstract interpretation tasks to model null byte propagation in string buffers and detect truncation risks.",
      "description_length": 571,
      "index": 19,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "NullByteSet.MaySet.M",
      "library": "goblint_cdomain_value",
      "description": "This module provides lattice operations (join, meet, widen) and a full-featured immutable set interface for tracking potential NULL byte positions in C arrays. It operates on sets of integers (`IntOps.BigIntOps.t`) represented as either a finite set (`Lifted of SetDomain`) or an unbounded top element, enabling precise static analysis of string buffer properties. The design supports use cases like abstract interpretation of C programs to detect out-of-bounds accesses or malformed string operations, with tooling integration for testing and serialization.",
      "description_length": 558,
      "index": 20,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Offset_intf.Offset-Index-Z",
      "library": "goblint_cdomain_value",
      "description": "This module defines a concrete index type based on arbitrary-precision integers (Z.t) with operations for equality, comparison, hashing, and conversion to and from integers. It supports serialization through XML printing, pretty printing, and Yojson encoding, along with generating arbitrary values for testing. It is used to represent and manipulate definite integer indices in contexts requiring unique identification and semantic equality checks.",
      "description_length": 449,
      "index": 21,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ValueDomain.Blob",
      "library": "goblint_cdomain_value",
      "description": "This module provides lattice operations and tuple manipulation utilities for analyzing blob values represented as triples of value, size, and zero-initialization status. It operates on structured combinations of these components, enabling transformations, comparisons, and invalidation of abstract values. The domain supports static analysis use cases like tracking uninitialized data or memory regions with precise size and initialization constraints.",
      "description_length": 452,
      "index": 22,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "ThreadIdDomain.ThreadLifted",
      "library": "goblint_cdomain_value",
      "description": "This module provides lattice operations and utilities for a lifted thread ID type that models abstract thread states with three levels: bottom (Bot), wrapped thread identifiers (Lifted), and top (Top). It supports merging (join), refinement (narrow), and extremal state checks (is_bot, is_top) within abstract interpretation frameworks, particularly for analyzing concurrent programs where thread identity tracking requires hierarchical approximations. The type integrates with serialization formats and testing tools, enabling use cases like static analysis of thread lifecycles and synchronization behavior.",
      "description_length": 609,
      "index": 23,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ThreadIdDomain.FlagConfiguredTID",
      "library": "goblint_cdomain_value",
      "description": "This module manages thread identifiers with configuration flags, enabling comparison, hashing, and relationship analysis in concurrent programs. It supports lattice operations like join, meet, and widen for abstract thread ID domains, allowing algebraic reasoning over structured hierarchies with top elements representing maximal information. You can model thread initialization constraints, analyze dynamic creation patterns, and perform context-sensitive static analysis by tracking creation events and querying active threads. The combined interface facilitates domain combination and precise abstraction of thread states during program verification.",
      "description_length": 654,
      "index": 24,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Offset.Index",
      "library": "goblint_cdomain_value",
      "description": "This module manages offset indices for arrays and structs, combining direct operations on index domains with specialized submodules for different index representations. It supports symbolic and concrete indices through types like `t`, unit indices, integer-based indices, and expression-based indices, enabling precise tracking and symbolic reasoning in static analysis. Operations include comparison, hashing, serialization, and conversion, with concrete examples like modeling struct field positions, handling unknown array indices, and generating test values. Expression-based indices integrate directly with `GoblintCil.exp` for advanced symbolic analysis, while integer-based and unit indices provide lightweight models for uniform or arbitrary offsets.",
      "description_length": 758,
      "index": 25,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ThreadIdDomain.Stateful",
      "library": "goblint_cdomain_value",
      "description": "This module provides operations for comparing and manipulating thread identifiers (TIDs) with support for stateful tracking of thread creation and hierarchical relationships. It works with TIDs (represented via type `D.t`) and a state type `t` to enable queries about thread ancestry, uniqueness, and creation history. Specific capabilities include determining parent-child thread relationships, checking if a thread is the main or unique thread, and optionally reconstructing creation traces for analysis or debugging in concurrent systems.",
      "description_length": 541,
      "index": 26,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "ArrayDomain.AttributeConfiguredArrayDomain",
      "library": "goblint_cdomain_value",
      "description": "This module provides lattice-based abstract domain operations for analyzing C arrays, including element access with bounds checking, context-aware partitioning strategies, and domain transformations like join, widen, and leq. It works with abstract arrays represented through variable-dependent partitioning schemes, index-value pairs, and metadata such as length and context tags. It is particularly useful in static analysis scenarios where array handling must adapt to variable-specific properties, type constraints, or configuration flags to balance precision and performance.",
      "description_length": 580,
      "index": 27,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "WrapperFunctionAnalysis0.MallocUniqueCount",
      "library": "goblint_cdomain_value",
      "description": "This module provides lattice-based operations for tracking unique memory allocation counts in abstract interpretation, featuring comparison, merging, and extremum detection functions over an integer domain extended with top/bottom states. It supports dataflow analysis by modeling allocation site uniqueness through join-semilattice structures with widening/narrowing for convergence, handling uninitialized states via a dedicated top value. The design enables precise counting of distinct malloc calls within wrapper function analysis while maintaining compatibility with functor chains.",
      "description_length": 588,
      "index": 28,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mval.Unit",
      "library": "goblint_cdomain_value",
      "description": "This module represents mvalues with unit indices in their offsets, combining a CIL variable with an offset structure. It supports operations like equality checks, hashing, comparison, and string representation, along with conversion to CIL lvalues and expressions. It is used to track and manipulate simplified lvalues during pointer analysis, particularly when dealing with variables and their offsets in a structured, comparable way.",
      "description_length": 435,
      "index": 29,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "ThreadIdDomain.ThreadLiftNames",
      "library": "goblint_cdomain_value",
      "description": "Lifts thread names into a domain with boolean flags to control expansion behavior and string constants for bottom and top elements. It operates on thread identifiers and string representations, enabling precise tracking and abstraction of thread states. Useful in static analysis to manage thread naming conventions and hierarchy in concurrent programs.",
      "description_length": 353,
      "index": 30,
      "embedding_norm": 1.0
    },
    {
      "module_path": "IntDomain.Integers",
      "library": "goblint_cdomain_value",
      "description": "This module provides lattice operations (join, meet, widen), arithmetic (addition, multiplication, division), bitwise operations (shifts, logical ops), and domain construction from intervals or congruences for abstract integer values. It operates on a type `t` representing integer ranges, inclusion/exclusion sets, and congruence classes, with utilities for comparison, serialization, and conversion to concrete values. Designed for static analysis in Goblint, it supports reasoning about integer overflows, value constraints, and invariants under C semantics.",
      "description_length": 561,
      "index": 31,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ArrayDomain.NullByte",
      "library": "goblint_cdomain_value",
      "description": "This module provides lattice operations and abstract array manipulations to track null byte positions and array sizes, specifically designed for analyzing null-terminated strings in C. It models potential buffer overflows by tracking string operations like copying, concatenation, and substring extraction while maintaining bounds on null byte locations. The domain works with abstract values representing string states and indexes, enabling static analysis of safety-critical string manipulations.",
      "description_length": 498,
      "index": 32,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Invariant.N",
      "library": "goblint_cdomain_value",
      "description": "This module enforces invariants for type-level witnesses, ensuring correctness in type hierarchies. It works with boolean flags and string identifiers to represent bottom and top types. Use it to validate type relationships and prevent invalid type constructions in complex type systems.",
      "description_length": 287,
      "index": 33,
      "embedding_norm": 1.0
    },
    {
      "module_path": "AddressDomain.AddressLatticeRepr",
      "library": "goblint_cdomain_value",
      "description": "This module organizes a lattice structure for abstract memory addresses used in pointer analysis, integrating core operations like `join`, `meet`, and `widen` with submodules that model variables and unit offset representatives. It manipulates data types such as variables tagged for uniqueness, abstract addresses without offsets, and offset arithmetic components, enabling precise tracking of pointer identities and memory accesses. With functions to compare, serialize, and display lattice elements, it supports static analysis tasks like identifying NULL pointers, analyzing string literals, and managing disjoint domains. Submodules refine the lattice by handling variable-specific and offset-free address representations, extending the module's ability to model pointer behavior in diverse program contexts.",
      "description_length": 813,
      "index": 34,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lval.Set",
      "library": "goblint_cdomain_value",
      "description": "This module provides lattice operations (join, meet, widen, narrow) and standard set manipulations (union, subset, map, fold) for abstract values representing sets of CIL l-values. It operates on structured collections of `CilType.Lval.t` elements, which model memory locations or variables in C programs, and includes utilities for querying, transforming, and serializing these sets. The functionality supports static analysis tasks like points-to analysis or dataflow tracking, where precise representation of memory state is critical.",
      "description_length": 537,
      "index": 35,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Offset_intf.Printable",
      "library": "goblint_cdomain_value",
      "description": "The module provides typed and hash-consed representations of structured offsets, modeling paths into data structures via field accesses, indexing, and nested component manipulations. It supports equality, comparison, serialization, conversion to C Intermediate Language (CIL) representations, and transformations like appending or truncating offset paths. These operations are used in program analysis to track precise access patterns in C data structures, enabling integration with static analysis frameworks that require canonicalized offset representations for fields, array indices, or composite types.",
      "description_length": 606,
      "index": 36,
      "embedding_norm": 1.0
    },
    {
      "module_path": "IntDomain.DefExc",
      "library": "goblint_cdomain_value",
      "description": "This domain combines default integer values with exclusion sets to model possible and impossible values during abstract interpretation. It supports lattice operations like join/meet, arithmetic and bitwise manipulations, and domain-specific refinements for tracking integer ranges and exceptions across program branches. Designed for static analysis of C code, it handles integer type constraints, overflow behaviors, and invariant generation in control flow paths by leveraging exclusion-based precision.",
      "description_length": 505,
      "index": 37,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "AddressDomain_intf.AddressDomain-AddressBase",
      "library": "goblint_cdomain_value",
      "description": "This module defines a type `t` representing abstract memory pointers, including address values, null pointers, unknown pointers, and string literals. It provides operations to convert between pointers and strings, determine pointer equality, hashing, and comparison, and extract string content from pointers when possible. Concrete use cases include tracking memory locations in static analysis, modeling string pointers in C programs, and managing abstract values during symbolic execution.",
      "description_length": 491,
      "index": 38,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Offset_intf.Offset-Index-module-type-Printable",
      "library": "goblint_cdomain_value",
      "description": "This module defines operations for a printable index type, including equality, comparison, and conversion to and from integers. It supports structured output through pretty printing, XML serialization, and Yojson encoding, along with generating arbitrary values for testing. It is used to represent and manipulate integer-like values with context-sensitive identity and semantic equality checks.",
      "description_length": 395,
      "index": 39,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ThreadIdDomain.Thread",
      "library": "goblint_cdomain_value",
      "description": "This module manages thread identifiers and their relationships through direct operations like creation, comparison, and serialization, while its child module introduces lattice abstractions to model thread states using join, meet, and partial order relations. It supports analysis of concurrent programs by tracking thread hierarchies, execution contexts, and domain-specific data, such as distinguishing top and bottom elements for abstract interpretation. Example uses include modeling thread creation dependencies and analyzing synchronization points by combining concrete thread management with abstract state reasoning.",
      "description_length": 624,
      "index": 40,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "AddressDomain.AddressPrintable",
      "library": "goblint_cdomain_value",
      "description": "This module provides operations for abstract address manipulation, including conversions between address representations and CIL structures (variables, expressions, types), offset arithmetic on memory-value pointers, and serialization/comparison for analysis. It works with abstract address values, string literals, null/unknown pointers, and integrates with CIL's type system to support use cases like static analysis of pointer behavior and memory model approximations.",
      "description_length": 471,
      "index": 41,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "IntDomain.Arith",
      "library": "goblint_cdomain_value",
      "description": "This module provides arithmetic operations (addition, subtraction, multiplication, division, remainder), comparison operators (less than, greater than, equality checks), and bitwise manipulations (AND, OR, XOR, shifts) alongside logical negation. It operates on an abstract integer type `t` designed to model C integers within a domain-specific arithmetic context. These capabilities are particularly useful in static analysis, symbolic execution, or abstract interpretation frameworks where precise representation of integer behaviors is critical.",
      "description_length": 548,
      "index": 42,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Mval.Z",
      "library": "goblint_cdomain_value",
      "description": "Handles mvalues with arbitrary-precision integer indices in offsets, providing equality, comparison, and conversion to CIL structures. Works with GoblintCil variables and offset-based types to represent memory locations with precise indexing. Used for analyzing pointer accesses and memory layouts in C programs where exact offset tracking is required.",
      "description_length": 352,
      "index": 43,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Offset_intf.Offset",
      "library": "goblint_cdomain_value",
      "description": "This module defines a parameterized type `t` representing offsets, along with equality, comparison, and hashing operations for use in data structures requiring such invariants. It includes submodules that provide lattice structures, printable instances, unit offsets, exponential offsets, and integer-based offsets. Concrete use cases include modeling memory addresses, array indices, and symbolic offsets in compilers or analysis tools.",
      "description_length": 437,
      "index": 44,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "ArrayDomain.StrWithDomain",
      "library": "goblint_cdomain_value",
      "description": "This module combines array domain and string analysis operations, offering lattice operations (join, meet, widen), array manipulation (element assignment,",
      "description_length": 154,
      "index": 45,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ValueDomain.Blobs",
      "library": "goblint_cdomain_value",
      "description": "This module supports operations for analyzing blob values represented as abstract domains, focusing on lattice-based manipulations like joins, meets, and widening, alongside equality checks and structured comparisons. It works with blob values encapsulated in a compound type tracking size, zero-initialization state, and nested data, providing utilities to map, invalidate, or extract components. Designed for static analysis frameworks, it aids in reasoning about memory layouts, uninitialized data propagation, and symbolic value differentiation in program analysis tasks.",
      "description_length": 575,
      "index": 46,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ValueDomain.AddrSetDomain",
      "library": "goblint_cdomain_value",
      "description": "This module implements a lattice-based abstract domain for representing sets of memory addresses with lifted semantics, supporting operations like union, intersection, difference, and extremal element selection. It provides functional set manipulation with persistent data structures, including membership checks, filtering, and iteration, while adhering to lattice properties for static analysis tasks. The domain is particularly useful in program analysis scenarios requiring precise tracking of address ranges or points-to information, such as memory safety verification or data flow analysis.",
      "description_length": 596,
      "index": 47,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MutexAttrDomain.MutexKind",
      "library": "goblint_cdomain_value",
      "description": "This module defines a concrete type `t` with two variants, `NonRec` and `Recursive`, representing kinds of mutex attributes. It includes standard operations for equality, comparison, hashing, and conversion to string and JSON formats. This module is used to distinguish between non-recursive and recursive mutex behavior in synchronization primitives.",
      "description_length": 351,
      "index": 48,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ArrayDomain.Str",
      "library": "goblint_cdomain_value",
      "description": "This module provides lattice operations (join, meet, widen) for abstract domains modeling strings as null-terminated character arrays, alongside array manipulation functions (creation, element updates, length adjustments) and string-specific operations like concatenation, substring checks, and comparison. It operates on an abstract type representing string values, with auxiliary constructs for analysis states and substring tracking, designed for static program analysis where precise modeling of string transformations, bounded byte limits, and array partitioning are critical. Use cases include tracking variables in array expressions, enforcing domain invariants, and approximating string behavior under memory constraints.",
      "description_length": 729,
      "index": 49,
      "embedding_norm": 1.0
    },
    {
      "module_path": "NullByteSet.MaySet",
      "library": "goblint_cdomain_value",
      "description": "This module combines lattice and set-theoretic operations with a full-featured immutable set interface to model and analyze potential NULL byte positions in C arrays using arbitrary-precision integers. It supports key operations like union, intersection, filtering, and widening over sets of integers, enabling precise static analysis for detecting buffer overflows and verifying string manipulations. The design includes both direct manipulation of set domains and abstractions for tracking null-terminated string boundaries, integrating testing and serialization tools for analysis workflows. Example uses include modeling array index states during abstract interpretation and enforcing size constraints on string buffers.",
      "description_length": 724,
      "index": 50,
      "embedding_norm": 1.0
    },
    {
      "module_path": "IntDomain.ArithIkind",
      "library": "goblint_cdomain_value",
      "description": "This module provides arithmetic, bitwise, and comparison operations on abstract integer values represented in a domain-specific type `t`, tailored for a specific C integer kind (`ikind`). It handles logical operations like AND/OR on abstracted integer expressions, enabling precise static analysis of C code behavior. These operations are critical for modeling integer manipulations and control-flow decisions during abstract interpretation.",
      "description_length": 441,
      "index": 51,
      "embedding_norm": 1.0
    },
    {
      "module_path": "StructDomain.S",
      "library": "goblint_cdomain_value",
      "description": "This module implements lattice operations (join, meet, widen, narrow) and structural manipulations (create, get, replace, map, fold) for abstract domains modeling C structs. It operates on an abstract type representing structured data with field-level precision, enabling analysis of compound data layouts. Key use cases include static analysis of C programs to track struct field values, enforce data integrity invariants, and compute fixpoints over hierarchical data structures, with support for pretty-printing and serialization for debugging or persistence.",
      "description_length": 561,
      "index": 52,
      "embedding_norm": 1.0
    },
    {
      "module_path": "FloatDomain.FloatDomain",
      "library": "goblint_cdomain_value",
      "description": "This module provides lattice operations, arithmetic, and comparison functions for abstract floating-point intervals, supporting static analysis of programs with floating-point computations. It works with abstract values representing intervals, extremal values (like NaN, infinity), and rounded/trigonometric operations, while interacting with integer abstractions for type conversions. Specific use cases include analyzing floating-point safety, handling edge cases in mathematical operations, and generating invariants for expressions involving floats.",
      "description_length": 553,
      "index": 53,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "IntDomain.Flattened",
      "library": "goblint_cdomain_value",
      "description": "This module provides lattice operations (join, meet, widen, narrow), arithmetic (addition, multiplication, division), bitwise (AND, OR, shifts), and logical operations on abstract integer values represented as either unbounded (`Top`), empty (`Bot`), or concrete 64-bit integer sets (`Lifted`). It supports static analysis tasks like constant propagation and invariant generation by enabling comparisons, value testing, and conversions to concrete forms (e.g., intervals, booleans). Key applications include program verification and abstract interpretation, particularly for reasoning about C integer expressions and their possible value ranges.",
      "description_length": 645,
      "index": 54,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "ThreadIdDomain.History",
      "library": "goblint_cdomain_value",
      "description": "This module models thread creation events and maintains domain-specific state across concurrent analyses, using thread identifiers and domain states (`D.t`) to track parent-child relationships and record historical thread data. It supports operations like spawning threads with contextual metadata, querying hierarchy information, and integrating with analysis frameworks via structured serialization. The lattice submodule provides algebraic and comparison operations for abstract analysis, enabling precise reasoning about thread interactions and state transitions through constructs like `join`, `meet`, and extremal values. Together, they facilitate static analysis of concurrent programs by combining structural history tracking with domain-aware abstract interpretation.",
      "description_length": 776,
      "index": 55,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mval.MakePrintable",
      "library": "goblint_cdomain_value",
      "description": "This module creates printable mvalues by combining a CIL variable with an offset structure from the `Offs` module, enabling operations like comparison, hashing, and conversion to CIL lvalues. It supports concrete use cases such as tracking memory locations in static analysis, generating human-readable representations of mvalues, and serializing mvalues for analysis outputs or communication. Key functions include appending offsets, checking prefix relationships, and converting to CIL expressions or types.",
      "description_length": 509,
      "index": 56,
      "embedding_norm": 1.0
    },
    {
      "module_path": "JmpBufDomain.NodeSet",
      "library": "goblint_cdomain_value",
      "description": "This module provides lattice operations (join, meet, widen) and set manipulations (union, intersection, map) for managing control-flow graph nodes in static analysis of non-local jumps. It operates on sets of `Node.t` values, supporting queries like membership and size, and conversions between sets and lists. This enables tracking potential control-flow disruptions caused by `setjmp`/`longjmp` calls in program analysis.",
      "description_length": 423,
      "index": 57,
      "embedding_norm": 1.0
    },
    {
      "module_path": "AddressDomain_intf.AddressDomain-AddressPrintable",
      "library": "goblint_cdomain_value",
      "description": "This module provides operations for manipulating pointer abstractions, including offset adjustments, string conversions, and serialization, while facilitating conversions between address representations, program variables, and CIL expressions. It works with memory values (`Mval.t`), abstract domains (`t`), and CIL types to enable static analysis of memory and string operations. The support for both precise (`must`) and approximate (`may`) conversions indicates use cases in abstract interpretation frameworks like Goblint for program analysis.",
      "description_length": 547,
      "index": 58,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "PreValueDomain.Mval",
      "library": "goblint_cdomain_value",
      "description": "This module supports lattice operations (`join`, `meet`, `widen`, `narrow`) and domain-specific manipulations of abstract memory values modeled as tuples of variable information and offset indices. It provides utilities for composing and comparing offsets, converting values to CIL expressions or lvalues, and semantic analysis, alongside serialization and pretty-printing tools. These operations are used in abstract interpretation to track program states, analyze memory behavior, and optimize code transformations in static analysis workflows.",
      "description_length": 546,
      "index": 59,
      "embedding_norm": 1.0
    },
    {
      "module_path": "IntDomain.Congruence",
      "library": "goblint_cdomain_value",
      "description": "This module implements arithmetic, bitwise, and lattice operations on abstract integer values modeled through congruence relations, combining modular arithmetic with interval representations. It manipulates values represented as `t` (built on `Z.t` integers) and integer types (`ikind`), supporting symbolic reasoning with exclusion sets, inclusion lists, and precision-controlled projections. Designed for static analysis, it enables tracking of integer properties like parity, divisibility, and bounded ranges while balancing abstraction precision through domain refinements and constraint-based narrowing.",
      "description_length": 608,
      "index": 60,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "ArrayDomain.AttributeConfiguredAndNullByteArrayDomain",
      "library": "goblint_cdomain_value",
      "description": "This module provides abstract interpretation operations for analyzing byte arrays with null-terminated string semantics, supporting string copy, concatenation, substring extraction, and comparison while tracking null byte positions. It operates on an abstract array domain (`t`) that combines configurable attributes with null byte analysis, using lattice operations (join/meet/widen) and index-based manipulation to model array states in C programs. The domain is particularly useful for static analysis of string-handling code (e.g., buffer overflows, string termination bugs) where null byte propagation and substring invariants are critical.",
      "description_length": 645,
      "index": 61,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Offset_intf.Index",
      "library": "goblint_cdomain_value",
      "description": "This module provides an abstraction for managing offset-based indices in data structures like ropes or gap buffers, supporting creation, comparison, and manipulation of integer positions. It includes operations for semantic equality checks against integers, conversion to exact integers, and representations in strings or XML for debugging and serialization. You can use it to efficiently track and modify positions during buffer edits or log index states in a human-readable format. The module combines direct access to index operations with submodules that enhance its utility in both functional and diagnostic contexts.",
      "description_length": 622,
      "index": 62,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "IntDomain.Y",
      "library": "goblint_cdomain_value",
      "description": "This domain provides lattice operations (join, meet, widen), arithmetic and bitwise manipulations (add, mul, shifts), and precision-aware conversions for abstract integer values that track C integer kind (ikind) information. It operates on abstract types `t` and `int_t` representing constrained integer ranges and exclusion sets, supporting static analysis tasks like invariant generation and overflow detection. Key use cases include abstract interpretation of C programs to model integer constraints, handle type-specific semantics, and derive extremal value bounds.",
      "description_length": 569,
      "index": 63,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "ArrayDomain.LatticeWithInvalidate",
      "library": "goblint_cdomain_value",
      "description": "This module provides lattice operations augmented with invalidation support for abstract array domains, enabling join, meet, widen, narrow, and comparison (leq) while tracking invalidated states. It operates on an abstract type `t` representing array elements, incorporating version tagging to manage state transitions and lifting for higher-order abstractions. Specific use cases include static analysis of C arrays where invalidation tracks stale values after modifications, and versioned states model array evolution across program execution paths.",
      "description_length": 551,
      "index": 64,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "UnionDomain.S",
      "library": "goblint_cdomain_value",
      "description": "This module provides lattice-based operations for analyzing abstract C union values, including equality checks, ordering relations, and join/meet/widen/narrow operators for domain refinement. It works with a recursive data structure of type `t` that represents abstract program values in a lattice hierarchy, supporting static analysis tasks like invariant generation and value set propagation. Key use cases include tracking possible union field states across program points and deriving semantic invariants for code locations through recursive domain traversal.",
      "description_length": 563,
      "index": 65,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "StructDomain.Simple",
      "library": "goblint_cdomain_value",
      "description": "This module provides lattice operations (join, meet, widen, narrow, leq) and structural manipulations (field access, modification, folding, mapping) over abstract representations of C structs. It models structs as mappings from CIL field descriptors (`GoblintCil.fieldinfo`) to abstract values (`Val.t`), encapsulated in a type `t` derived from `MapDomain.InfMap`. It is particularly useful for static analysis tasks requiring precise tracking of struct field states, such as merging diverging control-flow paths or analyzing field dependencies in C programs.",
      "description_length": 559,
      "index": 66,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ThreadIdDomain.Lift",
      "library": "goblint_cdomain_value",
      "description": "This module defines a lattice-based domain for thread IDs with three states (`Bot`, `Lifted`, `Top`), supporting lattice operations like `join`, `meet`, `widen`, and `narrow` to model abstract thread state transitions. It operates on values of type `Thread.t` wrapped in these states, enabling abstract interpretation for concurrent program analysis. Use cases include static analysis of thread interactions, such as tracking thread creation, synchronization, or data flow across threads using domain combinator patterns.",
      "description_length": 521,
      "index": 67,
      "embedding_norm": 1.0
    },
    {
      "module_path": "IntDomain.IntDomWithDefaultIkind",
      "library": "goblint_cdomain_value",
      "description": "This module provides arithmetic, bitwise, and logical operations on abstract integer values, along with lattice-based analysis for static program verification. It operates on abstract integer domains represented as bounded ranges and exclusion lists, leveraging `int_t` for concrete values and `ikind` to handle C-specific integer types. Designed for static analysis tasks like detecting overflows, verifying type conversions, or inferring integer constraints in C programs.",
      "description_length": 474,
      "index": 68,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "IntDomain.IkindUnawareS",
      "library": "goblint_cdomain_value",
      "description": "This module provides abstract integer analysis capabilities through lattice operations (join, meet, widen) and arithmetic/bitwise manipulations (addition, shifts, logical ops) over abstract values (`t`) and concrete integers (`int_t`). It supports static analysis tasks like invariant generation and value property queries while abstracting away integer kind (`ikind`) distinctions in arithmetic operations. Key use cases include domain construction from congruences, expression analysis, and testing via arbitrary value generation for C-like integer representations.",
      "description_length": 567,
      "index": 69,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Offset_intf.Offset-Unit",
      "library": "goblint_cdomain_value",
      "description": "This module provides arithmetic operations for composing and decomposing offsets with unit-indexed components, along with serialization and comparison capabilities. It operates on an abstract type representing unit-indexed offsets, enabling structural manipulation and conversion to/from CIL/Goblint intermediate representations like `GoblintCil.exp` and `GoblintCil.offset`. These utilities are particularly useful in program analysis scenarios requiring precise offset tracking within memory models or compilation pipelines.",
      "description_length": 526,
      "index": 70,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Offset.Poly",
      "library": "goblint_cdomain_value",
      "description": "Transforms indexing functions over polymorphic offset domains, enabling structured manipulation of array indices and struct fields. Works directly with offset representations parameterized by index types. Useful for adapting index mappings when reindexing arrays or restructuring struct layouts.",
      "description_length": 295,
      "index": 71,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Offset.MakePrintable",
      "library": "goblint_cdomain_value",
      "description": "This module provides functions to construct and manipulate structured offset values derived from index sequences, supporting equality checks, hashing, serialization to formats like XML/Yojson, and conversion to CIL representations. It operates on a polymorphic offset type composed of hierarchical index steps, enabling use cases such as symbolic analysis of array indices, struct field traversal, and integration with CIL-based toolchains where offset definiteness or zero checks are required.",
      "description_length": 494,
      "index": 72,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "ValueDomainQueries.LS",
      "library": "goblint_cdomain_value",
      "description": "This module provides lattice operations (join, meet, widen, narrow) and set manipulations (union, intersection, membership checks) over lifted sets of expressions (`Mval.Exp.t`), supporting abstract interpretation tasks like program value domain analysis. It models finite collections with a lifted top element, enabling precise representation of value sets and extremal element extraction for static analysis scenarios.",
      "description_length": 420,
      "index": 73,
      "embedding_norm": 1.0
    },
    {
      "module_path": "AddressDomain_intf.AddressDomain-AddressLatticeRepr",
      "library": "goblint_cdomain_value",
      "description": "This module provides operations for manipulating abstract memory addresses with support for pointer arithmetic, type inspection, and symbolic offset tracking. It defines a lattice type `t` with constructors for pointers, null, unknown values, and string literals, while interacting with submodules like `VariableRepr` and `UnitOffsetRepr` to represent symbolic variables and unit offsets. These capabilities are used in abstract interpretation to model memory states, resolve pointer aliasing, and analyze low-level code properties such as memory safety and buffer boundaries.",
      "description_length": 576,
      "index": 74,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ValueDomain.S",
      "library": "goblint_cdomain_value",
      "description": "The module provides lattice-based abstract interpretation operations such as join, meet, widen, and leq for comparing and combining analysis values, alongside utilities for initializing and manipulating structured data like integers and pointers. It operates on abstract values (`t`) in conjunction with GoblintCil types, expressions, and variable definitions, supporting context-sensitive analysis through precision-based projections and type-aware transformations. Specific use cases include nullability checks, integer kind handling, and value propagation during static analysis of programs.",
      "description_length": 594,
      "index": 75,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mval.MakeLattice",
      "library": "goblint_cdomain_value",
      "description": "This module provides lattice operations (join, meet, widen, narrow) and extremal values (bottom, top) for mvalues, which pair CIL variables with offset paths to model abstract memory states after pointer dereference resolution. It supports static analysis tasks like merging memory state approximations and tracking data flow relationships by leveraging an underlying",
      "description_length": 367,
      "index": 76,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mval_intf.Printable",
      "library": "goblint_cdomain_value",
      "description": "This module defines operations for handling and manipulating mvalues, which represent variable information paired with an offset structure. It provides equality checks, hashing, comparison, and conversion to string and XML formats, along with utilities for offset manipulation, type retrieval, and CIL representation. Use cases include tracking memory values in static analysis, managing variable offsets during symbolic execution, and generating unique identifiers for context-sensitive analysis.",
      "description_length": 497,
      "index": 77,
      "embedding_norm": 1.0
    },
    {
      "module_path": "IntDomain.Lift",
      "library": "goblint_cdomain_value",
      "description": "This module provides lattice operations (join, meet, widen, narrow), arithmetic (add, sub, mul, div), and bitwise operations (shifts, logical ops) on an abstract integer domain that preserves ordering. It works with a sum type `t` representing integers as constants, exclusion sets, or bounded ranges, alongside bottom/top elements to model possible value sets. Designed for static analysis, it enables reasoning about integer properties in C programs, such as tracking value constraints, handling overflows, and verifying invariants through domain-specific constructions like interval and congruence-based abstractions.",
      "description_length": 620,
      "index": 78,
      "embedding_norm": 1.0
    },
    {
      "module_path": "IntDomain.FlatPureIntegers",
      "library": "goblint_cdomain_value",
      "description": "This domain implements a flat lattice structure for 64-bit integers with strict ordering constraints, where operations like join, meet, and comparisons enforce total ordering by raising exceptions when combining incomparable values (e.g., non-equal constants or mixing top/bot). It supports arithmetic operations (addition, multiplication, division), bitwise manipulations (AND, shifts), and logical operators, working with abstract values that represent constants, top, or bottom states. Designed for abstract interpretation in static analysis, it ensures precise handling of integer ranges and edge cases in C programs, particularly where extremal values must not mix safely during lattice computations.",
      "description_length": 705,
      "index": 79,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Offset_intf.Offset-Poly",
      "library": "goblint_cdomain_value",
      "description": "Performs polymorphic offset operations by applying a function to all indices of a data structure, transforming each element's position while preserving the overall shape. Works with indexed data structures like arrays or lists where elements are accessed by integer positions. Useful for scenarios like reindexing elements in a custom container or adjusting positions in a sparse data representation.",
      "description_length": 400,
      "index": 80,
      "embedding_norm": 1.0
    },
    {
      "module_path": "WrapperFunctionAnalysis0.MakeUniqueCount",
      "library": "goblint_cdomain_value",
      "description": "This module provides lattice operations and value-tracking capabilities for integers, enabling analysis of distinct instance counts in program contexts. It works with integer-based lattice elements to support comparisons, extremal value checks (like top/bottom), and serialization, while facilitating abstract interpretation tasks. Its design addresses use cases in static analysis where precise tracking of unique call occurrences or distinct value flows is required.",
      "description_length": 468,
      "index": 81,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Offset_intf.Offset-Index-Unit",
      "library": "goblint_cdomain_value",
      "description": "This module implements index operations for unit values, providing equality checks, hashing, comparison, and conversion to strings or integers. It supports semantic checks between unit indices and integers, along with serialization to XML, JSON, and pretty-printed documents. Concrete use cases include representing arbitrary indices in data structures and enabling context identification through unique tags.",
      "description_length": 409,
      "index": 82,
      "embedding_norm": 1.0
    },
    {
      "module_path": "JmpBufDomain.JmpBufSetTaint",
      "library": "goblint_cdomain_value",
      "description": "This module combines setjmp buffer sets with may-boolean taint flags in a lattice-based domain, providing operations like join, meet",
      "description_length": 132,
      "index": 83,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Offset.MakeLattice",
      "library": "goblint_cdomain_value",
      "description": "Implements lattice-based analysis for structured offsets like array indices and struct fields, supporting operations such as composition, comparison, semantic equality checks, and conversion to CIL expressions. It manipulates a concrete type representing hierarchical indices through lattice primitives (`join`, `meet`, `widen`) and utilities for traversal, type validation, and pretty-printing differences. Useful in static analysis for tracking offset relationships, merging symbolic states, or approximating memory accesses in program verification tasks.",
      "description_length": 557,
      "index": 84,
      "embedding_norm": 1.0
    },
    {
      "module_path": "AddressDomain_intf.AddressDomain",
      "library": "goblint_cdomain_value",
      "description": "This module defines operations for representing, printing, and manipulating address values in a lattice structure. It includes functions for converting addresses to strings, comparing address ranges, and performing lattice-based analysis on memory addresses. Concrete use cases include static analysis of memory accesses and address space modeling in program analysis tools.",
      "description_length": 374,
      "index": 85,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ArrayDomain.S",
      "library": "goblint_cdomain_value",
      "description": "This module provides lattice operations (join, meet, widen, narrow) and array-specific manipulations (indexing, length updates, mapping) over abstract domain elements representing array states. It works with abstract arrays and their associated invariants, supporting static analysis tasks like buffer overflow detection or array bounds tracking through parameterized comparisons and variable-aware transformations. Key use cases include data flow analysis and program verification scenarios requiring precise array property modeling.",
      "description_length": 534,
      "index": 86,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "WrapperFunctionAnalysis0.ThreadCreateUniqueCount",
      "library": "goblint_cdomain_value",
      "description": "This module provides lattice operations (join, meet, widen, narrow) over integers to model thread creation counts and includes functions for managing thread-local counter states, such as retrieving the current thread's value or comparing against it. It operates on integer-based lattice values and supports serialization to XML/JSON, enabling static analysis tools to track unique thread creation sites and perform state comparisons during program analysis. The design facilitates dependency-free querying while maintaining precision in concurrent program analysis.",
      "description_length": 565,
      "index": 87,
      "embedding_norm": 1.0
    },
    {
      "module_path": "FloatDomain.FloatDomainBase",
      "library": "goblint_cdomain_value",
      "description": "This module provides abstract interpretation operations for floating-point values through a lattice structure (`t`) that combines interval arithmetic, arithmetic-trigonometric computations, and domain refinement. It supports precise reasoning about floating-point approximations via lattice operations (join/meet/widen), inverse mathematical functions, and classification predicates (e.g., `isfinite`, `isnan`), while enabling conversions to intervals, integers, and symbolic representations. Key use cases include static analysis of numerical code, safety verification under floating-point imprecision, and constraint propagation in program analysis.",
      "description_length": 651,
      "index": 88,
      "embedding_norm": 1.0
    },
    {
      "module_path": "AddressDomain_intf.AddressDomain-AddressLatticeRepr-UnitOffsetRepr",
      "library": "goblint_cdomain_value",
      "description": "This module defines operations for handling address domain elements without mvalue offset indices, including equality, hashing, comparison, and various serialization functions. It works with the abstract type `t` representing address domain values and supports conversion from an element type via `of_elt`. Concrete use cases include managing and comparing memory addresses in static analysis, generating XML or JSON representations for logging or inter-process communication, and supporting property-based testing with QCheck.",
      "description_length": 527,
      "index": 89,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Offset.Z",
      "library": "goblint_cdomain_value",
      "description": "This provides operations for handling structured offsets like array indices and struct fields using arbitrary-precision integers, including comparison, transformation, and context-aware inspection. It works with offset values that integrate type analysis and Goblint-compatible representations, enabling precise variable tracking in CIL-based program analysis for memory modeling and field access scenarios.",
      "description_length": 407,
      "index": 90,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ValueDomain.InvariantArg",
      "library": "goblint_cdomain_value",
      "description": "Implements invariant generation for base analysis values by analyzing function contexts and variable scopes. It processes CIL function definitions and variable information to derive compound value invariants. Used during static analysis to infer value constraints within a function's control flow.",
      "description_length": 297,
      "index": 91,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ArrayDomain.LatticeWithNull",
      "library": "goblint_cdomain_value",
      "description": "This module provides lattice operations for abstract interpretation tasks involving nullable integers and array indices, combining nullability tracking with numeric analysis. It works with abstract values that represent integer ranges, null states, and array size constraints, supporting operations like join, widen, and equality checks enhanced with expression evaluation for array bounds. It is particularly useful for analyzing C arrays where null pointers and index arithmetic require precise fixpoint computation and constraint propagation.",
      "description_length": 545,
      "index": 92,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "JmpBufDomain.LocallyModifiedMap",
      "library": "goblint_cdomain_value",
      "description": "This module manages maps associating buffer entries with variable sets, providing operations for insertion, removal, filtering, and lattice-based aggregation to model locally modified variables in static analysis. It supports advanced state manipulation through join, meet, and widening operations, essential for analyzing setjmp/longjmp behavior in abstract interpretation. Submodules extend functionality with serialization, comparison, and testing tools, enabling seamless integration into verification pipelines. Example uses include merging variable states across control flow paths and approximating program behavior under different execution contexts.",
      "description_length": 658,
      "index": 93,
      "embedding_norm": 1.0
    },
    {
      "module_path": "IntDomain.IntDomLifter",
      "library": "goblint_cdomain_value",
      "description": "This module provides operations for manipulating abstract integer domains, including lattice operations (join, meet, widen), arithmetic and bitwise computations (addition, division, shifts), and domain-specific conversions (casting, interval projections). It operates on integer abstractions represented as constrained ranges, congruences, and precision-bound values, supporting static analysis tasks like overflow detection and type inference. The functionality is designed for program analysis scenarios requiring precise integer value tracking under C semantics.",
      "description_length": 565,
      "index": 94,
      "embedding_norm": 1.0
    },
    {
      "module_path": "AddressDomain_intf.AddressDomain-AddressLattice",
      "library": "goblint_cdomain_value",
      "description": "This module structures abstract memory addresses for static analysis using a lattice model that combines symbolic and concrete pointer representations. It operates on a tagged union type with distinct sublattices for memory value pointers (Addr), null pointers (NullPtr), unknown pointers (UnknownPtr), and string pointers (StrPtr), where string pointer treatment varies based on domain configuration. The lattice supports operations like partial ordering comparisons, joins/meets for abstraction refinement, offset manipulation, and semantic equivalence checks, making it suitable for analyzing pointer arithmetic, memory safety, and string handling in C programs through abstract interpretation.",
      "description_length": 697,
      "index": 95,
      "embedding_norm": 1.0
    },
    {
      "module_path": "PreValueDomain.Addr",
      "library": "goblint_cdomain_value",
      "description": "This module provides operations for manipulating memory addresses with lattice-based abstractions, supporting creation, conversion, comparison, and offset arithmetic on symbolic and concrete address types like `Addr`, `NullPtr`, and `StrPtr`. It works with type-annotated address representations and facilitates program analysis tasks such as merging divergent control-flow states (via join/meet), simplifying symbolic address expressions, and serializing analysis results to JSON. Specific use cases include tracking pointer values in static analyzers, resolving memory access patterns, and integrating abstract domain results into analysis frameworks.",
      "description_length": 653,
      "index": 96,
      "embedding_norm": 1.0
    },
    {
      "module_path": "AddressDomain.AddressSet",
      "library": "goblint_cdomain_value",
      "description": "This module manages symbolic address collections with lattice operations for pointer analysis, supporting membership tests, set transformations, and null-pointer checks. It works with address sets (`t`) containing pointers, symbolic values (`elt`), and unknown or top values, using HConsed tags for efficient identity tracking and bidirectional conversions with numeric, string, and variable types. Child modules extend this functionality by providing abstractions to convert addresses to and from strings, variables, and mvalues, while supporting offset manipulation and lattice operations like widening. Together, they enable precise modeling of memory states, resolution of address equivalences, and tracking of pointer semantics in static analysis.",
      "description_length": 752,
      "index": 97,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ValueDomain.Structs",
      "library": "goblint_cdomain_value",
      "description": "This module provides lattice operations (join, meet, widen, narrow) and structural manipulation functions for abstract values representing C structs in static analysis. It operates on structured data modeled as mappings from C struct fields (`fieldinfo`) to abstract values (`Compound.t`), enabling domain-specific tasks like invariant generation, state merging, and hierarchical analysis. Key features include comparison, serialization, and folding over struct fields to support analysis precision tuning and result reporting.",
      "description_length": 527,
      "index": 98,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mval_intf.Mval-Unit",
      "library": "goblint_cdomain_value",
      "description": "This module implements mvalues with unit indices for offset tracking, providing operations to manipulate and compare these values. It supports concrete use cases like analyzing memory accesses in C code by tracking variable offsets and their definiteness. Functions include appending offsets, checking prefixes, converting to CIL representations, and generating unique identifiers or JSON/Yojson encodings for analysis artifacts.",
      "description_length": 429,
      "index": 99,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ValueDomainQueries.ID",
      "library": "goblint_cdomain_value",
      "description": "This module supports lattice operations (join, meet, widening) and domain manipulations (relifting, narrowing) over a polymorphic variant type encompassing bottom, top, and lifted integer values. It works with integer kinds and abstract domains to enable static analysis tasks like interval/congruence construction, exclusion tracking, and boolean conversions, while providing comparison, serialization, and pretty-printing utilities for analysis workflows.",
      "description_length": 457,
      "index": 100,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mval_intf.Mval",
      "library": "goblint_cdomain_value",
      "description": "This module provides operations for representing and manipulating abstract values in a lattice structure, including functions for printing, comparison, and arithmetic operations. It works with data types such as integers (Z), expressions (Exp), and unit values (Unit), organizing them within lattice frameworks derived from MakeLattice and printable representations from MakePrintable. Concrete use cases include static analysis domains where values must be combined, compared, or displayed during program analysis.",
      "description_length": 515,
      "index": 101,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Offset.Unit",
      "library": "goblint_cdomain_value",
      "description": "This module provides operations to manipulate and convert offsets with unit indices, including structural transformations like adding or removing components, equality checks, and serialization to formats such as CIL and Yojson. It operates on `Offset.Unit.t` types alongside CIL and Goblint-specific representations, enabling precise analysis of array indices and struct fields. These capabilities are particularly valuable in static analysis for tracking memory accesses or transforming intermediate code representations.",
      "description_length": 522,
      "index": 102,
      "embedding_norm": 1.0
    },
    {
      "module_path": "IntDomain.SOverflowUnlifter",
      "library": "goblint_cdomain_value",
      "description": "This module supports arithmetic and bitwise operations on integers with overflow management, lattice operations (join, meet, widen), and type-aware conversions between integer representations. It operates on abstract integer values (`t`) and C-specific integer types (`ikind`), leveraging intervals, congruences, and exclusion lists to balance precision and performance. Key applications include static analysis for detecting overflows, refining value ranges, and generating invariants in program verification.",
      "description_length": 510,
      "index": 103,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ThreadIdDomain.Unit",
      "library": "goblint_cdomain_value",
      "description": "This module manages thread identifiers and their relationships, providing operations for equality, comparison, hashing, and string representation, along with thread initialization and parent-child checks. It supports static analysis of concurrent programs by tracking thread lifecycles and spawns using types like domain values, analysis nodes, and variable information. The child module extends this with lattice operations\u2014join, meet, widen, and narrowing\u2014for abstract thread state analysis, enabling approximation of thread interactions in verification workflows. Together, they allow precise modeling and analysis of thread behavior across concrete and abstract domains.",
      "description_length": 674,
      "index": 104,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "WrapperFunctionAnalysis0.NodeFlatLattice",
      "library": "goblint_cdomain_value",
      "description": "This module defines a flat lattice structure with three states (`Bot`, `Lifted` of `Node.t`, and `Top`) to support abstract interpretation tasks. It provides lattice operations like `join`, `meet`, `widen`, and `narrow`, alongside utilities for comparison, serialization, and testing, enabling analysis of program states through approximation and combination of values. The design facilitates queries in static analysis scenarios where hierarchical state merging is required, such as tracking lifted node values in a wrapper function context.",
      "description_length": 542,
      "index": 105,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ArrayDomain.PartitionedWithLength",
      "library": "goblint_cdomain_value",
      "description": "This domain combines lattice-based abstract interpretation with precise management of partitioned arrays, where each segment maintains explicit length metadata. It supports operations to manipulate array partitions (e.g., creation, length updates, element assignment), lattice-theoretic queries (join, widen, meet), and bounds-checked element access, all while tracking relationships between partitioned regions and their sizes. The module is particularly useful in static analysis of C programs for verifying array safety properties, such as preventing buffer overflows or ensuring valid index accesses through tracked length constraints.",
      "description_length": 639,
      "index": 106,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Offset_intf.Lattice",
      "library": "goblint_cdomain_value",
      "description": "This module provides lattice-theoretic operations for analyzing memory offsets, including joins, meets, widening/narrowing, and comparisons (e.g., definiteness checks, semantic equality). It works with an abstract type representing offset values, supporting conversions to/from expressions, index representations, and CIL. These operations enable static analysis tasks like tracking memory access paths, deriving offset properties, and integrating with program analysis frameworks for tasks such as buffer overflow detection or field-sensitive dataflow analysis.",
      "description_length": 562,
      "index": 107,
      "embedding_norm": 1.0
    },
    {
      "module_path": "NullByteSet.MustMaySet",
      "library": "goblint_cdomain_value",
      "description": "This module combines precise and approximate analysis of NULL byte positions in C arrays using a product domain that pairs definite (must) and possible (may) sets. It supports lattice operations for domain combination, set manipulations for element tracking, and constraint-based filtering, operating on data structures including big integers and mode-controlled sets. The child module provides a specialized set structure using arbitrary-precision integers for tracking nullable byte positions, supporting union, intersection, difference, and lattice operations like join and widen. Together, they enable buffer overflow detection, null-termination verification, and abstract interpretation tasks through type-safe set partitioning, range extraction, and universal set handling.",
      "description_length": 779,
      "index": 108,
      "embedding_norm": 1.0
    },
    {
      "module_path": "IntDomain.Size",
      "library": "goblint_cdomain_value",
      "description": "Handles integer value ranges and type properties for C integer kinds. Provides operations to determine bounds, bit sizes, and safe casting between types. Useful for analyzing and transforming C expressions involving integer types.",
      "description_length": 230,
      "index": 109,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ThreadIdDomain.FunNode",
      "library": "goblint_cdomain_value",
      "description": "Represents and manipulates abstract thread IDs with support for equality, hashing, comparison, and serialization. Provides operations to create, identify, and relate thread IDs, including checking parent-child relationships and thread creation possibilities. Used to track and analyze thread behavior in concurrent programs, particularly for static analysis of thread creation and synchronization patterns.",
      "description_length": 406,
      "index": 110,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ValueDomain.Offs",
      "library": "goblint_cdomain_value",
      "description": "This module provides offset arithmetic (addition, prefixing, index mapping), lattice operations (join, meet, widening), and conversions to CIL representations for analyzing memory offsets in pointer arithmetic. It operates on index (`idx`) and offset (`offs`) types within a lattice structure, enabling semantic comparisons and type-aware equality checks. These capabilities support static analysis tasks like determining definite offset values, checking containment in memory regions, and modeling pointer manipulations in program verification.",
      "description_length": 545,
      "index": 111,
      "embedding_norm": 1.0
    },
    {
      "module_path": "IntDomain.Reverse",
      "library": "goblint_cdomain_value",
      "description": "This module provides a lattice structure with reversed order semantics for abstract integer domains, enabling operations like inverted comparisons (`leq`), join/meet swaps, and arithmetic transformations. It works with integer types represented as intervals, congruences, or inclusion/exclusion sets, supporting standard arithmetic, bitwise operations, and conversions between concrete and abstract values. Designed for static analysis of C integers, it facilitates scenarios requiring inverted constraint propagation or reverse-order domain manipulations, such as analyzing loops with descending counters or optimizing signed/unsigned conversions.",
      "description_length": 648,
      "index": 112,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "IntDomain.S",
      "library": "goblint_cdomain_value",
      "description": "This module provides abstract interpretation operations for analyzing integer values with arithmetic, bitwise, and comparison capabilities, focusing on lattice-based analysis and domain refinement. It manipulates abstract integer domains parameterized by C integer kinds (`ikind`), supporting interval arithmetic, congruence tracking, and exclusion/inclusion sets to model value ranges and constraints. Key use cases include static analysis of C programs for overflow detection, invariant generation, and precise bitwise operation modeling during abstract interpretation.",
      "description_length": 571,
      "index": 113,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ArrayDomain.TrivialWithLength",
      "library": "goblint_cdomain_value",
      "description": "This module supports creation, modification, and analysis of arrays represented as single abstract cells with explicit length tracking. It operates on arrays where elements are uniformly treated as a single value while maintaining integer-length state, enabling operations like bounded element access, length-aware joins, and symbolic invariant checks. Useful in static analysis scenarios requiring simplified array modeling with length constraints, such as buffer overflow detection or size propagation.",
      "description_length": 504,
      "index": 114,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "StructDomain.FlagConfiguredStructDomain",
      "library": "goblint_cdomain_value",
      "description": "This module provides lattice-based abstract interpretation operations for structured data, including field-aware manipulation (access, update, folding), domain combination with function-driven lattice operations (widen_with_fct, join_with_fct), and invariant generation. It operates on struct-like values represented using `GoblintCil.fieldinfo` and `Val.t`, enabling precise analysis of compound C data structures. The design supports static analysis use cases such as tracking field-level invariants, propagating structured value flows, and configuring domain behavior through customizable lattice combinators.",
      "description_length": 612,
      "index": 115,
      "embedding_norm": 1.0
    },
    {
      "module_path": "FloatDomain.F64Interval",
      "library": "goblint_cdomain_value",
      "description": "This module offers lattice-based operations (join, meet, widen, narrow) and arithmetic/trigonometric functions (addition, multiplication, sine, square root) for analyzing intervals of 64-bit floating-point numbers. It operates on abstract intervals (`t`) that represent over-approximations of possible numeric values, supporting tasks like static analysis of floating-point computations, constraint solving, and symbolic reasoning. Key applications include program verification tools and numerical abstract interpreters where precise bounds on floating-point behavior are required.",
      "description_length": 581,
      "index": 116,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Invariant.ExpLat",
      "library": "goblint_cdomain_value",
      "description": "This lattice structure provides operations like `join`, `meet`, `widen`, and `narrow` for symbolic expressions, enabling syntactic manipulation and invariant preservation. It works with `GoblintCil.exp` expressions, offering comparison, hashing, and serialization alongside precision adjustments through widening and narrowing. This supports static analysis scenarios requiring hierarchical expression abstraction, such as verifying program properties via abstract interpretation or refining expression invariants during witness validation.",
      "description_length": 540,
      "index": 117,
      "embedding_norm": 1.0
    },
    {
      "module_path": "IntDomain.IntervalFunctor",
      "library": "goblint_cdomain_value",
      "description": "This module implements abstract interpretation operations for tracking integer ranges with arithmetic, bitwise, and logical manipulations, specifically designed for analyzing C integer behaviors. It operates on abstract intervals (`t`) parameterized by integer kinds (`ikind`), supporting precise min/max bounds, overflow detection, and conversions between concrete integers and domain-specific representations. Key applications include static analysis of numerical properties in C programs, such as range propagation, overflow checking, and bit-level constraint refinement.",
      "description_length": 574,
      "index": 118,
      "embedding_norm": 1.0
    },
    {
      "module_path": "PreValueDomain.Offs",
      "library": "goblint_cdomain_value",
      "description": "This module provides operations for managing abstract offsets, including arithmetic manipulation, comparison, and conversion to CIL representations, alongside lattice-theoretic functions like join, meet, and widening. It operates on abstract offset values tied to index domains, enabling semantic reasoning and serialization via utilities such as `to_yojson` and `semantic_equal`. These capabilities are applied in static program analysis to model memory offsets, array indices, or pointer arithmetic in abstract interpretation frameworks.",
      "description_length": 539,
      "index": 119,
      "embedding_norm": 1.0
    },
    {
      "module_path": "AddressDomain_intf.AddressDomain-AddressSet-Addr",
      "library": "goblint_cdomain_value",
      "description": "This module provides operations for manipulating abstract address values in a C-like memory model, including lattice operations (join, meet, widen), offset arithmetic, and type inspection. It works with abstract addresses (`t`), memory values (`Mval.t`), and CIL variables (`varinfo`), supporting tasks like semantic analysis and pointer comparison in static analysis frameworks. Specific use cases include abstract interpretation for program verification and symbolic reasoning about memory states.",
      "description_length": 499,
      "index": 120,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "IntDomain.Lifted",
      "library": "goblint_cdomain_value",
      "description": "This module supports lattice-based analysis of bounded integers through operations like join, meet, widen, and narrowing, combined with arithmetic (addition, multiplication, division), bitwise (AND, shifts), and logical comparisons (equality, ordering). It manipulates abstract values represented as `Bot` (empty), `Top` (unbounded), or `int64` ranges, alongside lifted domains for static analysis tasks such as invariant generation, constraint propagation, and abstract interpretation of integer variables in programs. Key utilities include domain refinement via exclusion lists, congruence-based construction, and diagnostics for value tracking in static analysis workflows.",
      "description_length": 676,
      "index": 121,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Offset_intf.Offset-Exp",
      "library": "goblint_cdomain_value",
      "description": "This module enables structured manipulation and conversion of expression-based offsets, supporting operations like comparison, hashing, and structural analysis to handle indexing and field access in a type-safe way. It operates on `Exp.t` and `GoblintCil.offset` types, ensuring precise type checking and normalization of indices. These capabilities are critical for abstract domains like `ArrayDomain`, where accurate index handling is required for tasks such as zero comparison and domain-specific transformations.",
      "description_length": 516,
      "index": 122,
      "embedding_norm": 1.0
    },
    {
      "module_path": "PreValueDomain.AD",
      "library": "goblint_cdomain_value",
      "description": "This module provides lattice-based abstractions for analyzing address and pointer values, combining set-theoretic operations with integer and string transformations. It supports address sets built from memory locations, pointer sets with null tracking, and scalar values, offering operations like union, intersection, widening, narrowing, and type conversion. Submodules extend these abstractions to structured data representations, memory models, and domain-specific analyses. Example uses include verifying memory safety, tracking data flow through pointers, and performing abstract interpretation of program behavior.",
      "description_length": 620,
      "index": 123,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ValueDomain.ZeroInit",
      "library": "goblint_cdomain_value",
      "description": "This module provides lattice operations (leq, join, meet, widen, narrow) and memory allocation state tracking to model uninitialized or heap-allocated values in static analysis. It operates on an abstract type `t` with standard elements like `bot` (uninitialized) and `top` (arbitrary value), supporting use cases such as detecting uninitialized variable usage and tracking memory allocation origins (malloc/calloc) through comparison, serialization, and difference explanation functions.",
      "description_length": 488,
      "index": 124,
      "embedding_norm": 1.0
    },
    {
      "module_path": "AddressDomain.AddressBase",
      "library": "goblint_cdomain_value",
      "description": "This module defines a type `t` representing abstract pointers, including addresses, null pointers, unknown pointers, and string literals. It provides operations to convert between pointers and strings, compare and hash pointers, and serialize or pretty-print them. Concrete use cases include tracking memory values and string literals in static analysis, such as identifying null dereferences or extracting string contents during program analysis.",
      "description_length": 447,
      "index": 125,
      "embedding_norm": 1.0
    },
    {
      "module_path": "IntDomain.IntervalSetFunctor",
      "library": "goblint_cdomain_value",
      "description": "This module provides lattice operations (comparison, equality, constants), arithmetic and bitwise manipulations with overflow handling, interval refinement, and conversion utilities for abstract integer domains. It operates on interval representations of integers as lists of range pairs, exclusion sets, and parameterized integer kinds, supporting both concrete and symbolic integer modeling. Key use cases include static analysis of C integer behavior, overflow-safe arithmetic, constraint-based interval narrowing, and serialization for analysis tooling.",
      "description_length": 557,
      "index": 126,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mval.Exp",
      "library": "goblint_cdomain_value",
      "description": "This module represents mvalues with expressions as offset indices, supporting operations like equality checks, hashing, comparison, and conversion to CIL lvalues or expressions. It works with tuples of variable info and offset structures, enabling precise tracking of memory locations through expression-based indexing. Concrete use cases include analyzing pointer accesses and generating accurate memory representations in static analysis.",
      "description_length": 440,
      "index": 127,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "IntDomain.SOverflow",
      "library": "goblint_cdomain_value",
      "description": "This module offers arithmetic and bitwise operations with overflow tracking, comparisons, and conversions for abstract integer values, alongside lattice-like operations for static analysis. It manipulates an abstract type `t` representing C integers under various signedness and bitwidth configurations (`ikind`), supporting interval/congruence refinements and overflow-aware transformations. Designed for static program analysis, it enables precise modeling of integer behavior in C, including edge cases like extremal values and overflow conditions, while providing utilities for constraint refinement and domain-specific optimizations.",
      "description_length": 638,
      "index": 128,
      "embedding_norm": 1.0
    },
    {
      "module_path": "IntDomain.Enums",
      "library": "goblint_cdomain_value",
      "description": "This module manipulates integer domains through arithmetic, bitwise, and interval operations on abstract values, supporting inclusion/exclusion constraints and congruence relations. It works with typed intervals and extremal markers (`bot`, `top`) to model C integer semantics, including overflow handling and type conversion. Used for abstract interpretation in program analysis, it enables invariant generation, value refinement, and property checking over integer variables.",
      "description_length": 477,
      "index": 129,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ConcDomain.MustThreadSet",
      "library": "goblint_cdomain_value",
      "description": "This module provides a functional interface for managing sets of thread identifiers with core set-theoretic operations like union, intersection, difference, and membership checks, alongside lattice operations (join, meet, widen) tailored for abstract interpretation. It works with immutable thread sets (`ConcDomain.ThreadSet.t`) containing elements representing concurrent threads, supporting transformations to/from lists, extremal element extraction, and hash-based comparisons. These capabilities enable static analysis of concurrent programs, particularly for tracking thread interactions, resolving synchronization dependencies, and modeling possible runtime behaviors in abstract domains.",
      "description_length": 695,
      "index": 130,
      "embedding_norm": 1.0
    },
    {
      "module_path": "PreValueDomain.IndexDomain",
      "library": "goblint_cdomain_value",
      "description": "This module provides lattice operations (joins, meets, widening) and arithmetic/bitwise manipulations for abstract integer indices, working with types like `ID.t` and `IndexDomain.t` that model integer ranges, discrete values, and bounded symbolic indices. It supports static analysis of C code by enabling precise tracking of array indices, loop variables, and pointer arithmetic through operations like range projections, exclusion lists, and invariant derivation from expressions.",
      "description_length": 483,
      "index": 131,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "WrapperFunctionAnalysis0.UniqueCountArgs",
      "library": "goblint_cdomain_value",
      "description": "Counts unique function call arguments in wrapper function analysis. Uses a chain functor to track argument occurrences and provides a query interface for analysis. Enables detecting distinct argument patterns in function calls without direct dependency on the analysis module.",
      "description_length": 276,
      "index": 132,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mval_intf.Mval-MakeLattice",
      "library": "goblint_cdomain_value",
      "description": "The module provides lattice operations (join, meet, widen, narrow), comparison functions (leq, semantic_equal), and extremal value representations (bot, top) for memory values modeled as variable-offset pairs parameterized by an offset lattice. These operations enable static analysis and abstract interpretation tasks, where precise approximation and visualization of memory state behaviors are required during program analysis.",
      "description_length": 429,
      "index": 133,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ArrayDomain.Partitioned",
      "library": "goblint_cdomain_value",
      "description": "This module provides lattice operations and array manipulation utilities for abstract interpretation, focusing on partitioned array representations divided into three segments relative to an index expression. It works with arrays composed of left/at/right value triples from the `Val` module, indexed by a domain from `Idx`, supporting dynamic partitioning adjustments and bounds-aware element access. Key use cases include fixpoint analysis with variable tracking, maintaining domain invariants during array length changes, and explaining differences in partitioned array states through expression-driven joins and narrowing.",
      "description_length": 626,
      "index": 134,
      "embedding_norm": 1.0
    },
    {
      "module_path": "FloatDomain.FloatArith",
      "library": "goblint_cdomain_value",
      "description": "This module provides arithmetic operations (addition, multiplication, square roots), comparison operators (less than, equality), and classification functions (isfinite, isnan) for an abstract type representing C floating-point numbers. It returns comparison and classification results as domain-aware integer representations, enabling precise static analysis of numerical code and verification of edge cases like infinities or NaNs.",
      "description_length": 432,
      "index": 135,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "IntDomain.BISet",
      "library": "goblint_cdomain_value",
      "description": "This module provides lattice operations (join, meet, widen, narrow) and set algebra (union, intersection, difference) for bounded integer sets, combined with equality checks, extremal element retrieval, and serialization. It operates on a pure functional set-like structure (`t`) over arbitrary-precision integers (`Z.t`), supporting both standard set operations (membership, addition, filtering) and domain-specific features like `top`/`is_top` for abstract interpretation. The design enables static analysis of C integer ranges in program verification, where precise tracking of bounded integer values and fixed-point computations over control-flow graphs are required.",
      "description_length": 671,
      "index": 136,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Offset.Exp",
      "library": "goblint_cdomain_value",
      "description": "Supports manipulation of structured offsets with `GoblintCil.exp`-based indices, including equality checks, prefix transformations, and index mapping, alongside conversions to and from CIL offsets. Operates on a concrete type representing hierarchical offsets with symbolic or definite indices, enabling precise tracking of array indices and struct fields in C code. Useful for static analysis tasks like symbolic evaluation of memory accesses, type-aware offset normalization, and transformation of CIL-based offset representations during program analysis.",
      "description_length": 557,
      "index": 137,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Offset_intf.Offset-Index",
      "library": "goblint_cdomain_value",
      "description": "This module defines domains for offset indices used in formal verification tasks, particularly in reasoning about memory addresses and program analysis. It includes submodules for unit-based offsets, exponential arithmetic, and integer-based offset calculations. Concrete use cases include modeling pointer arithmetic, memory layout verification, and static analysis of low-level code.",
      "description_length": 385,
      "index": 138,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "ThreadIdDomain.Stateless",
      "library": "goblint_cdomain_value",
      "description": "This module implements thread ID state management for static analysis, providing operations to create, compare, and identify thread IDs with support for hierarchical relationships. It works with thread IDs (`t`) and integrates with variables, nodes, and XML/Yojson serialization. Concrete use cases include tracking thread creation, determining parent-child relationships, and generating unique identifiers for analysis contexts.",
      "description_length": 429,
      "index": 139,
      "embedding_norm": 1.0
    },
    {
      "module_path": "IntDomain.Ikind",
      "library": "goblint_cdomain_value",
      "description": "This module defines abstract domains for integer kinds in C, such as `IInt`, `IBool`, `IChar`, and `ILong`. It provides operations to classify and manipulate integer types based on their signedness, size, and representation. Concrete use cases include type analysis and constraint propagation in static analysis of C programs.",
      "description_length": 326,
      "index": 140,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "JmpBufDomain.BufferEntry",
      "library": "goblint_cdomain_value",
      "description": "This module defines operations for handling buffer entries used in setjmp/longjmp analysis, working with tuples of `Node.t` and `ControlSpecC.t`. It provides equality checks, comparison, hashing, string representation, and serialization functions for these entries. Concrete use cases include tracking jump buffer states during static analysis and comparing control flow contexts in a constraint solver.",
      "description_length": 403,
      "index": 141,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "IntDomain.Interval32",
      "library": "goblint_cdomain_value",
      "description": "The domain provides lattice operations (join, meet, widen), arithmetic (add, sub, mul, div), bitwise (shifts, logical ops), and comparison operations (lt, eq) for bounded 32-bit integer intervals. It works with interval values representing ranges of integers, integrating C semantics for conversions and overflow handling, and interacts with types like integer kinds and 64-bit integer operations. This supports static analysis of C programs to track value ranges, detect overflows, and reason about arithmetic expressions under precise or widened contexts.",
      "description_length": 557,
      "index": 142,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Offset_intf.Offset-Z",
      "library": "goblint_cdomain_value",
      "description": "This module supports arithmetic and structural transformations on offsets using arbitrary-precision integer indices (`Z.t`), enabling operations like prefix manipulation, index mapping, and zero-checking. It integrates with GoblintCil's type system to convert offsets into CIL expressions and analyze type-level displacements. Specific use cases include serializing/deserializing offset data, pretty-printing for debugging, and validating offset neutrality in program analysis workflows.",
      "description_length": 487,
      "index": 143,
      "embedding_norm": 1.0
    },
    {
      "module_path": "UnionDomain.Arg",
      "library": "goblint_cdomain_value",
      "description": "This module implements abstract domain operations for analyzing C unions, featuring equality checks, lattice operations (join, meet, widen), and top element handling. It operates on an abstract type representing union values, supporting lattice hierarchies and type casting. These capabilities are used in static analysis for approximating program states, comparing abstract values, and explaining discrepancies in union representations.",
      "description_length": 437,
      "index": 144,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ConcDomain.ThreadSet",
      "library": "goblint_cdomain_value",
      "description": "This module provides set-theoretic operations (union, intersection, difference, membership checks) and lattice-based operations (join, meet, widen, narrow) for managing thread identifier sets. It operates on sets of thread IDs (`ThreadIdDomain.Thread.t`) and is designed for static analysis of concurrent systems, enabling abstract interpretation to model thread interactions and analyze program behavior under concurrency. Use cases include tracking thread reachability, merging execution paths, and approximating thread set properties in domain-specific analyses.",
      "description_length": 565,
      "index": 145,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "ValueDomain.CArrays",
      "library": "goblint_cdomain_value",
      "description": "This module supports lattice operations (join, meet, widen), array abstractions (element access, length tracking, mapping), and string manipulation (concatenation, substring extraction) for analyzing C arrays in static analysis contexts. It operates on abstract arrays represented by type `t`, which model symbolic or approximated elements and indices with bounds-aware access. Key use cases include tracking variable dependencies in array operations, enforcing conditional array partitioning, and generating invariants for arrays with dynamic or symbolic lengths.",
      "description_length": 564,
      "index": 146,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "AddressDomain.AddressLattice",
      "library": "goblint_cdomain_value",
      "description": "This module structures abstract addresses into a lattice combining distinct pointer types (Addr, NullPtr, UnknownPtr) and context-dependent string pointers (StrPtr) with operations for lattice comparisons (`leq`), joins/meets, offset arithmetic, and semantic equality checks. It organizes Addr values into sublattices based on equivalence modulo index expressions, while StrPtr instances form singleton or flat sublattices depending on analysis configuration. Designed for static analysis tools, it enables precise pointer reasoning in domains like memory value tracking, string handling, and CIL expression integration, supporting context-sensitive tagging and extremal value checks for analysis workflows.",
      "description_length": 707,
      "index": 147,
      "embedding_norm": 1.0
    },
    {
      "module_path": "JmpBufDomain.JmpBufSet",
      "library": "goblint_cdomain_value",
      "description": "This module provides a set domain for analyzing jump buffer states, supporting standard set operations like union and difference alongside lattice operations such as join and meet. It works with sets of `BufferEntryOrTop` elements, enabling precise tracking of buffer lifetimes and aliasing in static analysis. Key use cases include modeling `setjmp`/`longjmp` behavior, combining abstract domains during analysis, and querying buffer state relationships via membership and comparison checks.",
      "description_length": 492,
      "index": 148,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ArrayDomain.Trivial",
      "library": "goblint_cdomain_value",
      "description": "This implementation provides abstract interpretation operations for arrays using a single-cell representation, where all indices map to a unified abstract value. It supports lattice operations (join, meet, widen), element access/modification via `get`/`set`, and domain-specific transformations while working with abstract array values of type `t` paired with expression-based indexing (`Basetype.CilExp.t`) and value domains (`VDQ.t`). Designed for static analysis of C arrays, it enables variable-dependent partitioning, invariant generation, and constraint solving in scenarios like buffer overflow detection or uninitialized memory tracking.",
      "description_length": 645,
      "index": 149,
      "embedding_norm": 1.0
    },
    {
      "module_path": "IntDomain.IntDomTuple",
      "library": "goblint_cdomain_value",
      "description": "This module provides arithmetic, bitwise, and logical operations on abstract integer tuples that model properties like ranges, exclusion sets, and congruences. It manipulates `IntDomTuple.t` values and arbitrary-precision integers (`Z.t`), enabling static analysis of C code through interval analysis, precision-controlled lattice operations (join/meet/widen), and abstract interpretation of integer semantics such as overflow handling and type casting.",
      "description_length": 453,
      "index": 150,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ValueDomain.Compound",
      "library": "goblint_cdomain_value",
      "description": "This module provides lattice operations (leq, join, meet, widen, narrow), value creation (top, bottom, zero, null), and manipulation functions for compound values including arrays, structs, unions, and concurrency-related types. It operates on abstract domains like VDQ and AD, integrates with CIL types and expressions, and supports static analysis tasks such as value tracking, type casting in C-based code analysis, and abstract interpretation with precision control for properties like null states and jump buffer handling.",
      "description_length": 527,
      "index": 151,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mval_intf.Mval-MakePrintable",
      "library": "goblint_cdomain_value",
      "description": "This module implements printable mvalues built from a base offset type, supporting operations to compare, hash, and serialize values. It works with tuples of CIL variable info and offset types, enabling manipulation of memory locations with precise offset tracking. Concrete use cases include constructing and comparing memory locations for static analysis, serializing them for output or storage, and converting to CIL expressions for further processing.",
      "description_length": 455,
      "index": 152,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mval_intf.Lattice",
      "library": "goblint_cdomain_value",
      "description": "This module supports lattice operations like join, meet, widen, and narrow, along with semantic comparisons and offset manipulation for abstract memory values structured as variable-index pairs. It works with abstract types `t` (representing memory values) and `idx` (tracking offset indices), enabling operations such as prefix checks, type equality, and conversion to CIL representations. These capabilities are used in static analysis for approximating fixpoints, comparing abstract values semantically, and managing offset-based dataflow computations.",
      "description_length": 555,
      "index": 153,
      "embedding_norm": 1.0
    },
    {
      "module_path": "UnionDomain.Field",
      "library": "goblint_cdomain_value",
      "description": "This module provides lattice operations (join, meet, widen, narrow) and comparison utilities for a polymorphic variant type modeling abstracted union fields with three states: bottom (uninitialized), top (over-approximated), and lifted (containing concrete CIL field metadata). It operates on a domain-specific type that encapsulates field information from CIL, enabling static analysis of C union types by tracking possible field values during abstract interpretation. The operations support merging, comparing, and transforming these abstract states while preserving domain semantics for use in program analysis frameworks.",
      "description_length": 625,
      "index": 154,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ValueDomain.Unions",
      "library": "goblint_cdomain_value",
      "description": "This module provides lattice operations (join, meet, widen) and domain-specific utilities for handling union values composed of fields and compound data, alongside serialization, equality checks, and arbitrary value generation. It operates on structured values combining offsets, lvalues, and nested compound domains, enabling abstract interpretation tasks like constraint enforcement and witness generation. Typical use cases include modeling memory layouts with tagged unions and tracking value domains under structural invariants during static analysis.",
      "description_length": 556,
      "index": 155,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "JmpBufDomain.BufferEntryOrTop",
      "library": "goblint_cdomain_value",
      "description": "This module represents values that are either a specific setjmp buffer entry or a top element denoting all possible targets. It provides operations for equality checking, comparison, hashing, and string representation of these values. It is used to track and reason about control flow targets in setjmp/longjmp analyses.",
      "description_length": 320,
      "index": 156,
      "embedding_norm": 1.0
    },
    {
      "module_path": "FloatDomain.FloatDomTupleImpl",
      "library": "goblint_cdomain_value",
      "description": "This module provides abstract interpretation operations for analyzing floating-point computations, including arithmetic, comparisons, rounding, and lattice operations (join, meet, widen). It manipulates abstract values represented as intervals or bounded ranges of floating-point numbers, along with classifications like NaN or infinity, and interacts with integer domains for boolean outcomes. Designed for static analysis, it enables tracking floating-point precision, overflow behavior, and numerical invariants in programs through interval arithmetic and domain-specific constructors.",
      "description_length": 588,
      "index": 157,
      "embedding_norm": 1.0
    },
    {
      "module_path": "UnionDomain.Simple",
      "library": "goblint_cdomain_value",
      "description": "This module provides lattice operations (join, meet, widen, narrow) and constants (top, bot) for analyzing abstract values in C union domains. It operates on structured data represented as pairs of union fields and values, supporting tasks like XML printing, JSON serialization, and lattice-based reasoning through functions such as invariant and arbitrary value generation.",
      "description_length": 374,
      "index": 158,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mval_intf.Mval-Z",
      "library": "goblint_cdomain_value",
      "description": "This module represents memory values with offsets indexed by integers, supporting operations like equality checking, hashing, comparison, and conversion to CIL representations. It works with variable information and offset structures to model memory accesses in program analysis. Concrete use cases include tracking memory locations during static analysis, comparing memory references for equivalence, and generating XML or JSON representations for debugging or external tools.",
      "description_length": 477,
      "index": 159,
      "embedding_norm": 1.0
    },
    {
      "module_path": "FloatDomain.F32Interval",
      "library": "goblint_cdomain_value",
      "description": "This module supports interval arithmetic, lattice operations (join, meet, widen, narrow), and numerical analysis for 32-bit floating-point intervals (`F32Interval.t`), including arithmetic, trigonometric, and unary operations alongside comparisons and classification (e.g., NaN, infinity checks). It enables precise bounded range analysis and abstract interpretation for static program verification, handling uncertainty in floating-point computations through interval-based approximations and inverse operations for constraints.",
      "description_length": 529,
      "index": 160,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "ConcDomain.ThreadStringSet",
      "library": "goblint_cdomain_value",
      "description": "This module provides a lattice-based abstraction for thread-concurrent string sets with operations like join, meet, and widening to model program state relationships, alongside standard set algebra (union, intersection, difference) and thread-safe modification primitives. It works with immutable string sets where elements are printable strings, supporting analyses that require precise tracking of string values across concurrent execution paths. Typical use cases include static analysis of concurrent programs to infer string value dependencies or enforce security policies in multi-threaded contexts.",
      "description_length": 605,
      "index": 161,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "ArrayDomain.LatticeWithSmartOps",
      "library": "goblint_cdomain_value",
      "description": "This module provides lattice operations for analyzing C arrays through abstract interpretation, supporting precise comparisons (`leq`), merges (`join`/`meet`), and convergence checks (`widen`/`narrow`) on abstract values of type `t`. It handles hierarchical data structures representing array states, including extremal elements like top and bottom, with smart operations that leverage expression resolution to big integers for refined analysis. These capabilities are used in static analysis to track array properties, invalidate stale values, and diagnose incomparable states during program verification tasks.",
      "description_length": 612,
      "index": 162,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "ConcDomain.ThreadCreation",
      "library": "goblint_cdomain_value",
      "description": "This module enables static analysis of thread creation and management in concurrent programs through lattice-based abstractions and structured data representations. It provides composite types to track thread uniqueness, parent-child relationships, and dirty exit statuses, supporting operations like comparison, combination, and serialization for analysis and debugging. Submodules handle unique thread identification, boolean lattice modeling of termination states, and set-theoretic manipulations of thread collections, enabling precise reasoning about thread lifecycles and concurrency constraints. Example uses include labeling threads for execution tracing, analyzing dirty exits for error handling, and modeling thread hierarchies in abstract interpretation frameworks.",
      "description_length": 776,
      "index": 163,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Offset_intf.Offset-Index-Exp",
      "library": "goblint_cdomain_value",
      "description": "This module defines operations for handling index expressions represented as `GoblintCil.exp`. It includes equality, comparison, and conversion functions, as well as utilities to check semantic equality with integers, generate unique IDs, and produce special index values for unknown or all indices. These operations support precise array analysis and invariant generation in static analysis tasks.",
      "description_length": 398,
      "index": 164,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "IntDomain.Interval",
      "library": "goblint_cdomain_value",
      "description": "This module provides lattice operations (join, meet, widen, narrow), arithmetic (addition, multiplication, division), and bitwise manipulations (AND, OR, XOR) for abstract integer intervals and exclusion sets. It operates on intervals represented with arbitrary-precision bounds (`Z.t`) and exclusion sets, supporting C-style type-aware casting, overflow tracking, and precision-controlled computations. These capabilities enable static analysis tasks like range propagation, overflow detection, and bitwise property inference in program analysis.",
      "description_length": 547,
      "index": 165,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Offset_intf.Offset-MakePrintable",
      "library": "goblint_cdomain_value",
      "description": "This module provides structured offset manipulation operations, including equality checks, comparison, hashing, serialization, and index transformations. It works with offsets composed of printable indices and interacts with CIL types through conversion and type determination utilities. Specific use cases include analyzing or transforming hierarchical offset structures in contexts like GoblintCil, where precise index manipulation and type-aware comparisons are required.",
      "description_length": 474,
      "index": 166,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "ValueDomain.ValueInvariant",
      "library": "goblint_cdomain_value",
      "description": "This module generates invariants for value domains by analyzing lvalues and their offsets in C code, producing constraints over abstract values, blobs, and C arrays. It supports operations like `ad_invariant`, `blob_invariant`, and `vd_invariant` to capture variable access paths, with `deref_invariant` and `key_invariant` handling pointers and array indices. The module also includes a child module for set-theoretic and sequence-based manipulations of variables, enabling precise tracking and transformation of variable sets during static analysis. Examples include deriving invariants for pointer dereferences and transforming variable sets through union, mapping, or ordered traversal.",
      "description_length": 690,
      "index": 167,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "JmpBufDomain.ActiveLongjmps",
      "library": "goblint_cdomain_value",
      "description": "This module provides lattice operations and structured data representation for tracking sets of active jump buffers alongside control flow graph nodes. It works with tuples of `JmpBufSet.t` and `NodeSet.t` to model relationships between setjmp invocations and their CFG positions, supporting analyses that require precise propagation of buffer states. The domain enables use cases like static analysis of error-handling paths and property testing of buffer state transitions through XML/JSON serialization and QCheck generators.",
      "description_length": 528,
      "index": 168,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "ThreadIdDomain.S",
      "library": "goblint_cdomain_value",
      "description": "This module defines operations for managing and comparing thread identifiers, including creation, equality checks, hashing, and serialization. It works with the abstract type `t` representing thread IDs, supporting concrete operations like checking if a thread is the main thread, determining parent-child relationships, and overapproximating thread creation possibilities. Use cases include tracking thread creation in static analysis, identifying unique threads, and comparing thread IDs during analysis of concurrent programs.",
      "description_length": 529,
      "index": 169,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ArrayDomain.Null",
      "library": "goblint_cdomain_value",
      "description": "This module tracks whether array elements are null, not null, or possibly null. It provides operations to create and check null states, along with integer kind handling for zero and non-zero values. It is used to analyze C arrays where nullness of pointers is significant, such as in buffer or string processing.",
      "description_length": 312,
      "index": 170,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Mval_intf.Mval-Exp",
      "library": "goblint_cdomain_value",
      "description": "This module represents memory values with expression-based indices and offsets, supporting operations like equality checks, hashing, comparison, and conversion to CIL lvalues. It works with variables paired with offset structures that include expressions, enabling precise tracking of memory locations in analysis. Concrete use cases include symbolic execution, points-to analysis, and generating CIL expressions for program analysis tasks.",
      "description_length": 440,
      "index": 171,
      "embedding_norm": 1.0
    },
    {
      "module_path": "IntDomain.Flat",
      "library": "goblint_cdomain_value",
      "description": "This domain models integers as flat abstract values with three states: `Bot`, `Lifted` (wrapping concrete integers), and `Top`, where arithmetic and bitwise operations are lifted to preserve only equality information. It supports lattice operations, comparisons, and type conversions for C integers with overflow handling, using `Bot` to represent unreachable states and `Top` for unknown values. It is particularly useful in static analysis when precise integer range tracking is unnecessary, such as approximating values in unreachable code paths or unknown inputs.",
      "description_length": 567,
      "index": 172,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "IntDomain.B",
      "library": "goblint_cdomain_value",
      "description": "This module provides lattice-based abstract interpretation capabilities for C integers, featuring operations like join, meet, widen, and narrowing to model value ranges and properties. It works with abstract domain elements (`t`) and integer lists, enabling static analysis tasks such as overflow detection, boolean condition verification, and inclusion checks in integer ranges. Key patterns include value analysis, type casting, and set-like manipulations for program analysis contexts requiring precise integer domain approximations.",
      "description_length": 536,
      "index": 173,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "ThreadIdDomain.Stateful-D",
      "library": "goblint_cdomain_value",
      "description": "This module provides lattice operations (join, meet, widen, narrow) and comparison primitives (equal, compare, leq) for an abstract type `D.t` representing thread ID domains. It includes distinguished top and bottom elements to model hierarchical states in abstract interpretation, with utilities for pretty-printing and XML/JSON serialization. The structure supports static analysis tasks like merging thread state abstractions or tracking approximations in concurrent program analysis.",
      "description_length": 487,
      "index": 174,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ArrayDomain.S0",
      "library": "goblint_cdomain_value",
      "description": "This module provides lattice-theoretic operations for comparing and combining abstract array values, along with symbolic manipulation of array elements and indices. It works with abstract arrays that track variable dependencies and dynamic partitions, supporting operations like element assignment, invariant checking, and structural transformations. The functionality is designed for static analysis tasks such as verifying array properties, propagating constraints, and managing unbounded or symbolic array states in program analysis.",
      "description_length": 536,
      "index": 175,
      "embedding_norm": 1.0
    },
    {
      "module_path": "StructDomain.Arg",
      "library": "goblint_cdomain_value",
      "description": "This module provides lattice operations such as ordering, join, meet, widening, and narrowing for abstract struct domain values, alongside utilities to manage and query top and bottom elements in the lattice hierarchy. It operates on type `t`, representing structured abstract domains, and includes tools for pretty-printing, serialization, and QCheck-based testing. These capabilities are particularly useful in static analysis scenarios where lattice extremities and type-specific value properties must be rigorously validated during abstract interpretation of C structs.",
      "description_length": 573,
      "index": 176,
      "embedding_norm": 1.0
    },
    {
      "module_path": "IntDomain.Z",
      "library": "goblint_cdomain_value",
      "description": "This module provides arithmetic, bitwise, and lattice operations (join, meet, widen) on an abstract integer type `t` that tracks numeric ranges, congruences, and precision. It supports C-like semantics for overflow handling, type casting, and invariant generation, operating on values constrained by lower/upper bounds or exclusion sets. Designed for static analysis of low-level code, it enables precise modeling of integer behaviors in scenarios like overflow detection, range propagation, and constraint solving during program verification.",
      "description_length": 543,
      "index": 177,
      "embedding_norm": 1.0
    },
    {
      "module_path": "StructDomain.KeyedSets",
      "library": "goblint_cdomain_value",
      "description": "This module combines lattice operations (join, meet, widen, narrow) with keyed set manipulations (creation, mapping, folding, and invariant checks) to model structured data domains. It operates on keyed sets where keys are C struct fields (from CIL) and values belong to an abstract domain `Val.t`, enabling precise tracking of struct field relationships. It is particularly useful in static analysis for inferring and propagating constraints on C struct fields during abstract interpretation.",
      "description_length": 493,
      "index": 178,
      "embedding_norm": 1.0
    },
    {
      "module_path": "IntDomain.PtrDiffIkind",
      "library": "goblint_cdomain_value",
      "description": "Handles pointer difference operations for C integers by providing functions to compute and reason about differences between pointers in memory. Works with abstract integer domains and C intermediate language types like `ikind`. Useful for analyzing pointer arithmetic in C code to ensure correct memory access and bounds checking.",
      "description_length": 330,
      "index": 179,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "NullByteSet.MustSet",
      "library": "goblint_cdomain_value",
      "description": "This module combines abstract interpretation of integer sets with lattice operations to model NULL byte positions in C arrays. It supports creation, membership testing, union, intersection, and lattice operations like `join` and `meet`, using `Z.t` values within a domain that includes `Top` and `Bot` for approximated states. Submodules extend this foundation with utilities for filtering, iteration, and serialization, enabling analysis of array state transformations and memory safety. Specific uses include detecting buffer overflows and tracking string termination through static approximation of array contents.",
      "description_length": 617,
      "index": 180,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "AddressDomain_intf.AddressDomain-AddressLatticeRepr-VariableRepr",
      "library": "goblint_cdomain_value",
      "description": "This module defines a representation for variables with operations for equality, hashing, comparison, and serialization. It works with a concrete type `t` that represents variables, supporting conversion to strings, XML, and JSON formats, as well as generating arbitrary values for testing. It is used in contexts requiring unique variable identification and projection from an element type.",
      "description_length": 391,
      "index": 181,
      "embedding_norm": 1.0
    },
    {
      "module_path": "StructDomain.Sets",
      "library": "goblint_cdomain_value",
      "description": "This module provides lattice and set-theoretic operations for analyzing structural properties of C structs, including meet/join for combining abstract values and mapping/folding over struct fields. It manipulates an abstract type representing struct field-value associations, augmented with domain-specific combination logic via higher-order functions like `join_with_fct`. The operations enable static analysis tasks such as tracking potential struct layouts, merging divergent field states, and propagating value constraints through struct manipulations in C code.",
      "description_length": 566,
      "index": 182,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ValueDomain",
      "library": "goblint_cdomain_value",
      "description": "This module represents values in dataflow analysis, including scalars, arrays, and compound types like structs and unions, with operations to manipulate and query these values through field extraction, offset application, and invariant checking. It supports lattice-based abstract domains for memory addresses, blobs, and structured data, enabling transformations, comparisons, and constraint generation across submodules. You can track uninitialized data with abstract memory states, enforce value constraints at global variables, and model pointer arithmetic with offset tracking and type-aware conversions. Structs and unions are analyzed through field mappings and domain-specific invariants, while arrays support symbolic element access, length tracking, and string manipulation for precise static analysis of C code.",
      "description_length": 822,
      "index": 183,
      "embedding_norm": 1.0
    },
    {
      "module_path": "StructDomain",
      "library": "goblint_cdomain_value",
      "description": "This module implements abstract domains for analyzing C structs, modeling struct layouts and field values with precise lattice operations and structural manipulations. It provides core data types representing structs as mappings from field descriptors to abstract values, supporting operations like field access, modification, join, meet, widen, and narrow, often customized through higher-order combinators. Submodules extend this foundation with specialized lattice behaviors, keyed set manipulations, and invariant-preserving transformations, enabling tasks such as merging struct states across control-flow paths, enforcing field-level constraints, and propagating structured value flows during static analysis. Examples include tracking struct field invariants, analyzing struct-based data structures, and validating domain properties through serialization and testing tools.",
      "description_length": 880,
      "index": 184,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ConcDomain",
      "library": "goblint_cdomain_value",
      "description": "This module manages thread identifiers and string sets using set-theoretic and lattice-based operations, supporting static analysis of concurrent programs. It provides immutable data structures like `ThreadSet.t` and string sets with operations including union, intersection, join, meet, and widen, enabling precise modeling of thread interactions and program state relationships. The module tracks thread lifecycles, synchronization, and string value dependencies, supporting analyses such as reachability, error handling, and security policy enforcement. Example uses include merging thread sets during abstract interpretation, analyzing string flow across threads, and tracing thread hierarchies with unique identifiers.",
      "description_length": 723,
      "index": 185,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "NullByteSet",
      "library": "goblint_cdomain_value",
      "description": "This module models NULL byte positions in C arrays using abstract domains based on integer sets and lattice operations. It provides data types for precise and approximated sets of indices, supporting union, intersection, filtering, and widening, with underlying representation using arbitrary-precision integers. Operations enable static analysis tasks such as buffer overflow detection, null-termination verification, and abstract interpretation of array states. Example uses include tracking string boundaries, enforcing size constraints, and analyzing memory safety through set-theoretic transformations.",
      "description_length": 607,
      "index": 186,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ThreadIdDomain",
      "library": "goblint_cdomain_value",
      "description": "This module defines thread identifiers with support for concrete IDs and unknown threads, enabling equality, comparison, and hashing operations. It models abstract thread states through lattice operations like join, meet, widen, and narrow, with extremal states (Bot, Top) for hierarchical approximations in static analysis. You can track thread creation, parent-child relationships, and thread lifecycles, with support for serialization and integration into abstract interpretation frameworks. Use cases include analyzing synchronization behavior, modeling thread hierarchies, and combining concrete and abstract reasoning for concurrent program verification.",
      "description_length": 660,
      "index": 187,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "IntDomain",
      "library": "goblint_cdomain_value",
      "description": "This module provides abstract domains and operations for analyzing C integers, combining lattice-based reasoning with arithmetic, bitwise, and comparison operations over abstract values. It supports multiple representations such as intervals, congruences, exclusion sets, and flat domains, enabling precise modeling of integer ranges, overflow behaviors, and type-specific semantics. Key data types include `t` for abstract integers, `int_t` for concrete representations, and structures like `IntDomTuple` and `BISet` for composite domain modeling. Users can perform join/meet/widen operations, arithmetic and bitwise manipulations, overflow detection, domain construction from intervals or congruences, and invariant generation, making it suitable for static analysis tasks like program verification, constant propagation, and abstract interpretation of C code.",
      "description_length": 862,
      "index": 188,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Offset_intf",
      "library": "goblint_cdomain_value",
      "description": "This module organizes a family of types and operations for managing structured offsets and indices, combining low-level arithmetic with high-level semantic transformations. It defines core data types like `'i t` and `'i offs` for representing offsets and indices, with operations including `equal`, `compare`, and `hash`, while submodules extend these with lattice structures, unit-based arithmetic, XML/Yojson serialization, and CIL integration. You can model memory addresses, track field accesses in C structs, reindex elements in custom containers, or normalize symbolic offsets in static analysis. Additional utilities support pretty printing, arbitrary value generation, and type-safe index transformations, unifying direct API access with modular extensions for program analysis and data structure manipulation.",
      "description_length": 818,
      "index": 189,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "StringDomain",
      "library": "goblint_cdomain_value",
      "description": "This module provides lattice operations for abstract string values, including semantic comparisons (`leq`, `join`, `meet`), conversions between OCaml/C strings, and JSON serialization. It manipulates abstract string literals represented as `t` values, designed for static analysis contexts where symbolic string representations are required. The operations support use cases like analyzing string manipulations in C code (via CIL integration) and exchanging abstract domain data with external systems using JSON.",
      "description_length": 512,
      "index": 190,
      "embedding_norm": 1.0
    },
    {
      "module_path": "PreValueDomain",
      "library": "goblint_cdomain_value",
      "description": "This module combines lattice-based abstractions for analyzing memory values, addresses, and indices, enabling precise modeling of program state in static analysis. It supports key operations like join, meet, widen, and narrow across abstract domains including memory values, pointers, offsets, and integer indices, with utilities for conversion to CIL representations, semantic comparison, and serialization. Concrete data types include `Addr`, `NullPtr`, `StrPtr`, `ID.t`, and `IndexDomain.t`, used to track pointer arithmetic, array bounds, and memory access patterns. Example applications include verifying memory safety, resolving symbolic addresses, and optimizing array index analysis in abstract interpretation frameworks.",
      "description_length": 729,
      "index": 191,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "InvariantCil",
      "library": "goblint_cdomain_value",
      "description": "This module provides functions to manipulate and analyze CIL expressions and variables during transformations, such as replacing variable names, deep unrolling of types, and checking variable scope. It works with CIL expressions, variable information, and function definitions, supporting tasks like identifying temporary or heap variables and excluding variables based on regex patterns. Concrete use cases include normalizing expressions for comparison, filtering out temporary variables in analysis, and ensuring expressions do not reference out-of-scope variables.",
      "description_length": 568,
      "index": 192,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MutexAttrDomain",
      "library": "goblint_cdomain_value",
      "description": "This module provides a lattice structure for analyzing mutex attributes with three states: uninitialized, specific mutex kind, and unknown. It supports lattice operations like join, meet, widen, and narrow, along with conversions from integers to represent mutex kinds during abstract interpretation. The child module defines a concrete type with `NonRec` and `Recursive` variants to distinguish mutex behavior in synchronization primitives. You can use this module to track possible mutex states in concurrent programs and handle system-level integer encodings.",
      "description_length": 562,
      "index": 193,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mval",
      "library": "goblint_cdomain_value",
      "description": "This module models mvalues as combinations of CIL variables and structured offsets, supporting precise tracking of memory locations during pointer analysis. It provides core operations for comparison, hashing, conversion to CIL structures, and lattice-based abstraction, accommodating offsets represented as unit indices, integers, or expressions. Concrete uses include static analysis tasks like memory state merging, pointer resolution, and generating readable or serializable representations of lvalues. Examples include appending offsets, checking prefix relationships, and converting mvalues to CIL expressions for analysis or output.",
      "description_length": 639,
      "index": 194,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lval",
      "library": "goblint_cdomain_value",
      "description": "This module defines abstract domains for sets of CIL l-values with lattice operations and set manipulations. It supports analysis of memory states by tracking variables and locations through joins, meets, and transformations. Operations include union, subset checks, mapping, and folding over structured collections of `CilType.Lval.t`. Example uses include points-to analysis and dataflow tracking in static analysis of C programs.",
      "description_length": 432,
      "index": 195,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Invariant",
      "library": "goblint_cdomain_value",
      "description": "This module manages polymorphic variant invariants with lattice operations over tagged types embedding symbolic expressions, supporting static analysis through lifting, comparison, and context-aware refinement of abstract values. It combines path-sensitive analysis with expression-level invariants, enabling operations like join, meet, widen, and narrow on `GoblintCil.exp`-based values to track and validate logical constraints during witness checking. The type-level enforcement submodule ensures correct invariant hierarchies using boolean and string tags, while the expression lattice submodule provides syntactic manipulation and precision control for abstract interpretation tasks. Example uses include lifting values to abstract domains, comparing invariant states across analysis paths, and formatting expression differences to debug constraint violations.",
      "description_length": 865,
      "index": 196,
      "embedding_norm": 1.0
    },
    {
      "module_path": "PrecisionUtil",
      "library": "goblint_cdomain_value",
      "description": "This module enables configuration and management of precision-related boolean flags for numerical operations, stored in mutable references to control behaviors like exception handling and interval analysis. It processes precision settings for integers and floating-point values by extracting configurations from nodes or global parameters, incorporating checks for congruence activation. These capabilities support use cases such as dynamically adjusting numerical attribute handling during program analysis or enforcing specific precision constraints in computational workflows.",
      "description_length": 579,
      "index": 197,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "WrapperFunctionAnalysis0",
      "library": "goblint_cdomain_value",
      "description": "This module organizes functors and instantiations for tracking unique function calls in static analysis, enabling precise counting of distinct invocations such as `malloc` and `thread_create`. It defines configuration-driven argument extraction and builds counting modules over function call data, supporting queries that avoid circular dependencies in the analysis. Child modules implement lattice-based tracking for memory allocations, integer instances, thread creation, and lifted node values, each enabling specific analyses through join operations, extremum detection, and serialization. These components collectively allow tracking and querying of unique call sites and argument patterns in both sequential and concurrent programs.",
      "description_length": 738,
      "index": 198,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "ValueDomainQueries",
      "library": "goblint_cdomain_value",
      "description": "This module evaluates integer expressions within a domain, determining relationships like equality, ordering, and arithmetic constraints through domain-specific evaluation. It includes submodules for lattice operations over lifted expression sets and polymorphic integer domains, supporting abstract interpretation tasks such as interval analysis and value set manipulation. Main data types include lifted expressions and polymorphic variants representing integer values with bottom and top elements. You can use it to check if expressions may be equal, compare their potential values, or analyze program behavior using abstract domains like intervals or congruences.",
      "description_length": 667,
      "index": 199,
      "embedding_norm": 1.0
    },
    {
      "module_path": "UnionDomain",
      "library": "goblint_cdomain_value",
      "description": "This module analyzes C unions by tracking field layouts and value ranges through lattice-based abstract domains. It supports operations like merging, comparing, and projecting union states across program points, using data types such as `t` and polymorphic variants to represent abstract values with states like bottom, top, and lifted. These capabilities enable static analysis tasks such as detecting type confusion vulnerabilities, deriving semantic invariants, and approximating program states during abstract interpretation. Submodules refine these operations with domain-specific lattice functions, type casting, and serialization support for structured union field analysis.",
      "description_length": 681,
      "index": 200,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "JmpBufDomain",
      "library": "goblint_cdomain_value",
      "description": "This module family analyzes setjmp/longjmp behavior in control flow by combining lattice-based domains for buffer states, variable tracking, and taint information. It centers on sets of control flow nodes and buffer entries, with operations for join, meet, widen, and set manipulation, enabling precise modeling of non-local jumps and their effects on program state. Users can track buffer lifetimes, merge variable states across paths, and represent control flow disruptions using structured tuples and taint-aware domains. Example applications include static analysis of error handling, buffer aliasing detection, and abstract interpretation of programs with non-local control flow.",
      "description_length": 684,
      "index": 201,
      "embedding_norm": 1.0
    },
    {
      "module_path": "AddressDomain",
      "library": "goblint_cdomain_value",
      "description": "This module organizes a lattice-based model for abstract memory addresses, supporting precise pointer analysis through operations like `join`, `meet`, `widen`, and offset arithmetic. It defines core data types including abstract pointers, string literals, null and unknown pointers, and symbolic address sets, each with comparison, serialization, and conversion functions. Submodules refine address representations using variable tags, offset-free forms, and HConsed identities to enable context-sensitive tracking and equivalence resolution. Examples include detecting null dereferences, modeling string literals, and approximating memory states during static analysis.",
      "description_length": 670,
      "index": 202,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mval_intf",
      "library": "goblint_cdomain_value",
      "description": "This module defines type classes for printable values, lattice structures, and abstract value operations, enabling static analysis domains with precise semantic and display behaviors. It supports data types such as integers, expressions, and variable-offset pairs, with operations including meet/join, comparison, hashing, and conversion to formats like CIL, XML, and JSON. The child modules refine these abstractions with concrete implementations for memory values indexed by unit, integer, or expression-based offsets, supporting tasks like symbolic execution, points-to analysis, and context-sensitive static analysis. Specific capabilities include tracking memory accesses, approximating fixpoints with widening/narrowing, and serializing analysis artifacts for external consumption.",
      "description_length": 787,
      "index": 203,
      "embedding_norm": 1.0
    },
    {
      "module_path": "WideningThresholds",
      "library": "goblint_cdomain_value",
      "description": "This module manages numeric thresholds used for widening operations in abstract interpretation. It provides access to predefined lists of integer thresholds, including variations for multiplication and octagon domains. These thresholds are used to control precision and performance in static analysis by setting bounds for value approximations.",
      "description_length": 344,
      "index": 204,
      "embedding_norm": 1.0
    },
    {
      "module_path": "AddressDomain_intf",
      "library": "goblint_cdomain_value",
      "description": "This module provides a comprehensive framework for representing and manipulating abstract memory addresses and variables in static analysis contexts. It defines core data types like `t` for abstract addresses with constructors for pointers, null, unknown values, and string literals, alongside operations for comparison, hashing, pointer arithmetic, and lattice-based abstraction refinement. Submodules extend this foundation with support for symbolic offset tracking, memory value integration, CIL expression conversions, and structured variable handling. Specific applications include modeling pointer behavior in C programs, analyzing memory safety, and enabling semantic equivalence checks during abstract interpretation.",
      "description_length": 725,
      "index": 205,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Offset",
      "library": "goblint_cdomain_value",
      "description": "This module organizes domains for variable offsets\u2014such as array indices and struct fields\u2014into a structured framework that supports symbolic and concrete reasoning. It defines core types like `t` and index representations including integers, units, and expressions, enabling operations such as comparison, hashing, lattice manipulation, and conversion to CIL. Submodules refine these capabilities for specific use cases: symbolic index tracking with `GoblintCil.exp`, polymorphic index transformations, structured offset construction, lattice-based analysis, arbitrary-precision integer handling, unit-index manipulation, and CIL integration. Examples include modeling struct field positions, analyzing unknown array indices, merging symbolic offset states, and transforming intermediate representations in static analysis.",
      "description_length": 824,
      "index": 206,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ArrayDomain",
      "library": "goblint_cdomain_value",
      "description": "This module defines abstract domains for analyzing C arrays, combining lattice-based operations with specialized submodules to model array properties like null-terminated strings, partitioned segments, and null byte positions. It supports domain transformations such as join, meet, widen, and leq, alongside array manipulations including element access, length updates, and index tracking, with concrete types representing abstract array states, string values, and index expressions. Specific capabilities include detecting buffer overflows through string analysis, tracking array initialization with versioned states, and enforcing length constraints during dynamic partitioning. Submodules extend these operations to handle null-terminated strings, nullable indices, and single-cell array representations, enabling precise static analysis of array and string manipulations under memory and domain-specific constraints.",
      "description_length": 920,
      "index": 207,
      "embedding_norm": 1.0
    },
    {
      "module_path": "FloatDomain",
      "library": "goblint_cdomain_value",
      "description": "This module analyzes C floating-point computations using interval arithmetic, combining abstract domains for 32-bit and 64-bit floats with lattice operations for static analysis. It supports arithmetic, comparisons, and classification (e.g., NaN, infinity) through domain-aware integer results, enabling precise tracking of floating-point behavior across operations like addition, multiplication, and trigonometric functions. Submodules refine this with inverse operations, symbolic conversions, and constraint propagation, handling rounding, overflow, and precision loss in numerical code. Examples include verifying floating-point safety, generating expression invariants, and analyzing edge cases in mathematical functions.",
      "description_length": 726,
      "index": 208,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LibraryDesc.MathPrintable",
      "library": "goblint.library",
      "description": "This module defines operations for comparing, hashing, and converting mathematical descriptors to strings or XML. It works with the `LibraryDesc.math` type, providing concrete functionality for pretty-printing, serialization, and structural equality checks. Use this module when you need to display, log, or persist mathematical function descriptors in a readable format.",
      "description_length": 371,
      "index": 209,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LibraryDesc.MathLifted",
      "library": "goblint.library",
      "description": "This module introduces a lattice structure over polymorphic variant values representing mathematical expressions with distinguished bottom, top, and lifted intermediate states. It provides operations for comparison, conversion, and lattice manipulations (join, meet, widening, narrowing) to model abstract interpretation domains, particularly for static analysis of mathematical computations. The type supports serialization, pretty-printing, and diffing to aid in debugging and integration with analysis frameworks.",
      "description_length": 516,
      "index": 210,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LibraryDesc.Accesses",
      "library": "goblint.library",
      "description": "This module processes lists of CIL expressions representing pointer arguments, mapping them to access specifications. It provides operations to find, iterate over, and fold across expressions based on access types or kinds. Use it to analyze or transform function call arguments according to their pointer access behavior.",
      "description_length": 322,
      "index": 211,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LibraryDesc.Access",
      "library": "goblint.library",
      "description": "This module defines the behavior for accessing pointer arguments in function descriptors, specifying whether the access is shallow or deep. It works with pointer types and associated access kinds to control how deeply values are dereferenced during analysis. Concrete use cases include configuring static analysis tools to track direct pointer usage or fully traverse reachable memory structures.",
      "description_length": 396,
      "index": 212,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LibraryFunctions",
      "library": "goblint.library",
      "description": "This module manages a database of library function specifications with operations to register functions, check if a function is special or safe to uncalled, and retrieve its descriptor. It works with CIL variables and string identifiers, providing direct access to transfer functions and atomic variable handling. Concrete use cases include determining special treatment for function calls during analysis and resetting lazy state during reinitialization.",
      "description_length": 455,
      "index": 213,
      "embedding_norm": 1.0
    },
    {
      "module_path": "AccessKind",
      "library": "goblint.library",
      "description": "This module defines a type `t` representing different kinds of memory accesses, including read, write, free, call, and spawn operations. It provides functions for equality checks, comparison, hashing, string conversion, pretty printing, XML serialization, and JSON encoding of these access types. Concrete use cases include tracking memory usage in program analysis, enforcing memory safety, and generating reports or logs for memory-related operations in a compiler or static analysis tool.",
      "description_length": 491,
      "index": 214,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LibraryDsl",
      "library": "goblint.library",
      "description": "This module provides a domain-specific language for constructing library function descriptors with precise argument handling and access annotations. It supports defining special and unknown functions by specifying how arguments are captured, dropped, or accessed (read, write, free, spawn) with shallow or deep semantics. Concrete use cases include modeling library functions in static analysis to track memory accesses and side effects accurately.",
      "description_length": 448,
      "index": 215,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LibraryDesc",
      "library": "goblint.library",
      "description": "This module defines algebraic data types for modeling mathematical operations, memory manipulation, threading primitives, and string handling in library functions, with support for comparison, equality, and hashing. It provides core constructors for describing function semantics in static analysis, including precise modeling of C library behaviors, memory effects, and thread interactions. The math submodule extends these types with pretty-printing, serialization, and structural comparison, while the lattice submodule introduces abstract interpretation capabilities through join, meet, and widening operations over mathematical expressions. Additional submodules handle pointer argument analysis and access specification, enabling deep or shallow traversal of memory structures during function call processing.",
      "description_length": 815,
      "index": 216,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_backtrace",
      "library": "goblint.backtrace",
      "description": "This module extends exception handling with custom marks, allowing additional context to be attached to exceptions. It provides operations to register mark printers, add marks to exceptions, and print or retrieve mark traces. Use cases include debugging and error analysis where structured context improves diagnostics.",
      "description_length": 319,
      "index": 217,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Control.AnalyzeCFG.CompareGlobSys.Sys.G.CSet",
      "library": "goblint.lib",
      "description": "This module provides lattice and set operations for analyzing abstract program states represented as `CSet.t` values, which are immutable sets of elements of type `SpecSys.Spec.C.t`. It supports static analysis tasks like abstract interpretation by enabling comparisons, combinations (union, intersection, difference), and lattice-based approximations (widen, narrow) of state sets. These operations are critical for tracking and merging program states during constraint-solving analysis of control flow graphs.",
      "description_length": 511,
      "index": 218,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Control.AnalyzeCFG.CompareGlobSys.GH.Exceptionless",
      "library": "goblint.lib",
      "description": "This module provides operations to safely query and update a global system state by key, handling potential exceptions during modification. It works with typed global state containers and key-based access, ensuring modifications are applied only when keys exist. Concrete use cases include managing analysis state during constraint solving in CFG traversal, where safe key-based updates and lookups are critical.",
      "description_length": 412,
      "index": 219,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.YamlWitness.Validator.Locator.LocM.Exceptionless",
      "library": "goblint.lib",
      "description": "This module provides operations for safely accessing and traversing key-value structures without raising exceptions. It works with map-like structures parameterized over a key type and a value type, supporting optional retrieval through functions like `find`, `choose`, and `any`. These functions enable robust querying and inspection of structured data, particularly useful when processing partial or uncertain inputs such as configuration files or witness traces.",
      "description_length": 465,
      "index": 220,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Control.AnalyzeCFG.SpecSys.LHT.Labels",
      "library": "goblint.lib",
      "description": "This module provides labeled versions of standard hash table operations, enhancing readability and argument order flexibility. It works with labeled hash tables (`SpecSys.LHT.t`) and keys (`SpecSys.LHT.key`), supporting transformations, filtering, iteration, and merging based on key-value pairs. Concrete use cases include managing analysis state during constraint solving and tracking labeled data in program analysis workflows.",
      "description_length": 430,
      "index": 221,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Control.AnalyzeCFG.SpecSys.GHT.Labels",
      "library": "goblint.lib",
      "description": "This module provides labeled versions of standard hash table operations, enhancing readability and argument order flexibility. It works with labeled hash tables (`SpecSys.GHT.t`) and keys (`SpecSys.GHT.key`). Concrete use cases include safely adding, replacing, filtering, and transforming key-value pairs in hash tables with improved argument labeling for clarity.",
      "description_length": 365,
      "index": 222,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Witness.Result.ArgTool.NHT.Labels",
      "library": "goblint.lib",
      "description": "This module provides operations for manipulating key-value maps with typed keys, supporting insertion, modification, iteration, filtering, and merging. It works with maps parameterized over their value type and uses a typed key structure to ensure type-safe access and updates. Concrete use cases include tracking and transforming analysis results in a graph-based representation, where keys correspond to graph nodes and values represent associated metadata or properties.",
      "description_length": 473,
      "index": 223,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Control.AnalyzeCFG.CompareGlobSys.PP.Labels",
      "library": "goblint.lib",
      "description": "This module provides operations for manipulating key-value maps where keys are labels from a control flow graph (CFG) and values represent analysis data. It supports transformations, filtering, iteration, and in-place modifications of these maps during static analysis. Concrete use cases include tracking variable states across CFG nodes and merging analysis results from different paths.",
      "description_length": 389,
      "index": 224,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.UnassumeAnalysis.Spec.Locator.LocM.Exceptionless",
      "library": "goblint.lib",
      "description": "This module provides operations for querying and retrieving key-value pairs from a map-like structure, specifically working with values of type `'a LocM.t`. It includes functions to find a value by key, choose any key-value pair, or select any entry in the map. These operations support analyses that need to process or react to specific unassume events derived from YAML witness invariants.",
      "description_length": 391,
      "index": 225,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.UnassumeAnalysis.Spec.Locator.FileH.Infix",
      "library": "goblint.lib",
      "description": "This module defines bidirectional mapping operations between a typed structure and keys specific to file-based locators. It provides the `-->` and `<--` operators to associate values with keys in a structured context, enabling precise tracking and retrieval of analysis data tied to specific file locations. This supports emitting and handling unassume events based on structured invariants from YAML witnesses.",
      "description_length": 411,
      "index": 226,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ExtractPthread.Codegen.AdjacencyMatrix.HashtblN.Exceptionless",
      "library": "goblint.lib",
      "description": "This module provides operations to safely query and update a nested hash table structure that maps keys to optional values. It supports retrieving values with `find` and applying transformations with `modify`, handling missing keys without raising exceptions. It is used to manage adjacency matrices in Promela extraction, where precise control over thread state transitions is required.",
      "description_length": 387,
      "index": 227,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Control.AnalyzeCFG.CompareGlobSys.Sys.LVar",
      "library": "goblint.lib",
      "description": "This module defines operations for comparing, hashing, and pretty-printing labeled variables represented as pairs of control flow nodes and specification contexts. It provides utilities to extract locations, generate variable identifiers, and determine write-only status directly from node-spec pairs. These functions support analysis of control flow graphs by enabling precise tracking and comparison of variable states during abstract interpretation.",
      "description_length": 452,
      "index": 228,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Control.AnalyzeCFG.Slvr.EqSys.Dom",
      "library": "goblint.lib",
      "description": "This domain provides lattice operations including join, meet, widening, and narrowing over a polymorphic variant type combining two abstract value representations (`G.t` and `D.t`) with explicit bottom and top elements. It supports constraint solving in static analysis by enabling fixed-point computations over program control flow graphs through equation system lifting. The structured domain is specifically designed for solving interdependent constraints arising from abstract interpretation of C programs, with utilities for value comparison, serialization, and domain-specific type manipulation.",
      "description_length": 601,
      "index": 229,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Control.AnalyzeCFG.SpecSys.LHT.Exceptionless",
      "library": "goblint.lib",
      "description": "This module provides exception-safe operations for interacting with a custom hashtbl-like structure, specifically offering `find` to retrieve values safely and `modify` to update values with a function. It works directly with the `SpecSys.LHT.t` hashtbl-like type and uses the `key` type defined in `SpecSys.LHT`. These functions are used during constraint solving in static analysis to manipulate abstract state mappings without raising exceptions, ensuring robust handling of missing keys during analysis steps.",
      "description_length": 513,
      "index": 230,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Control.AnalyzeCFG.CompareGlobSys.LH.Infix",
      "library": "goblint.lib",
      "description": "This module provides infix operators for manipulating and querying a global system of constraints represented as a directed graph. It works with types involving `CompareGlobSys.LH.t`, keys, and arbitrary values `'a`, enabling direct access and updates to constraint nodes. Concrete use cases include navigating and modifying control flow graph (CFG)-based constraint systems during static analysis, such as setting and retrieving values at specific nodes during fixed-point computation.",
      "description_length": 486,
      "index": 231,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Control.AnalyzeCFG.SpecSys.GHT.Exceptionless",
      "library": "goblint.lib",
      "description": "This module provides safe lookup and in-place modification operations for hash tables, returning optional values or result types instead of raising exceptions. It works with hash tables (`Hashtbl`) where keys and values have specific types determined by the `SpecSys.GHT` module. Concrete use cases include managing analysis state during constraint solving in a Cfg-based abstract interpreter, where exception-free operations are required for robustness and predictable error handling.",
      "description_length": 485,
      "index": 232,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.YamlWitness.Validator.Locator.FileH.Labels",
      "library": "goblint.lib",
      "description": "This module provides operations for manipulating key-value maps where keys are file handles with positional labels and values can be of arbitrary type. It supports transformations, filtering, iteration, and in-place modification of map entries, as well as merging two maps using a custom strategy. It is used for tracking and modifying structured data associated with specific source code locations during YAML witness validation.",
      "description_length": 430,
      "index": 233,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ExtractPthread.Codegen.AdjacencyMatrix.HashtblN.Labels",
      "library": "goblint.lib",
      "description": "This module implements a labeled adjacency matrix using a hash table with custom key types and value manipulation functions. It supports operations for adding, modifying, filtering, and transforming key-value pairs, as well as merging and folding over the structure. It is used to represent and manipulate control-flow or state-transition graphs in the context of pthread program analysis.",
      "description_length": 389,
      "index": 234,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Control.AnalyzeCFG.Slvr.EqSys.Var",
      "library": "goblint.lib",
      "description": "This module defines and manipulates variables used in the constraint system for abstract interpretation. It supports operations like equality checking, hashing, comparison, and pretty-printing for variables, which are either global (`G`) or local (`L`) types tied to specific nodes in the control flow graph. These variables are used to track and solve dataflow equations during static analysis of C programs.",
      "description_length": 409,
      "index": 235,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.UnassumeAnalysis.Spec.Locator.FileH.Labels",
      "library": "goblint.lib",
      "description": "This module implements a labeled key-value store for managing unassume analysis data tied to file-specific locations. It supports operations like adding, modifying, filtering, and merging entries based on keys that identify positions within source files. Typical use cases include tracking and transforming per-file analysis metadata during witness-based verification.",
      "description_length": 368,
      "index": 236,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ExtractPthread.Codegen.AdjacencyMatrix.HashtblN.Infix",
      "library": "goblint.lib",
      "description": "This module provides infix operators `(-->)` and `(<--)` for accessing and modifying entries in a hash table-based adjacency matrix structure. It works with directed graph representations where nodes are identified by keys and edges store associated data. These operations enable concise edge traversal and mutation, particularly useful in control flow graph analysis during Promela extraction for pthread programs.",
      "description_length": 415,
      "index": 237,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Control.AnalyzeCFG.CompareGlobSys.LH.Labels",
      "library": "goblint.lib",
      "description": "This module provides dictionary-like operations for manipulating keyed data structures, including insertion, modification, iteration, filtering, and merging. It works with labeled hash tables where keys are of type `CompareGlobSys.LH.key` and values are polymorphic. Concrete use cases include tracking and transforming analysis results per program point during static analysis.",
      "description_length": 378,
      "index": 238,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.YamlWitness.Validator.Locator.ES.Labels",
      "library": "goblint.lib",
      "description": "This module processes sets of labeled elements within YAML witness validation, enabling precise traversal and transformation of label-based data structures. It supports operations like filtering, mapping, and partitioning over collections of labels to enforce validation rules or extract specific label subsets. Concrete use cases include validating function entry points, checking label consistency across YAML nodes, and transforming label metadata during witness generation.",
      "description_length": 477,
      "index": 239,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.YamlWitness.Validator.Locator.ES.Exceptionless",
      "library": "goblint.lib",
      "description": "This module provides functions to retrieve elements from a set, including the minimum, maximum, arbitrary, and specific elements. It operates on sets represented by `Locator.ES.t` and their elements of type `Locator.ES.elt`. These functions are used to extract values during YAML witness validation when handling element selection without raising exceptions.",
      "description_length": 358,
      "index": 240,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Control.AnalyzeCFG.CompareGlobSys.GH.Infix",
      "library": "goblint.lib",
      "description": "This module defines bidirectional mappings between keys and values within a global system comparison context. It provides the `(-->)` and `(<--)` operators to query and update associations in a `CompareGlobSys.GH.t` structure, which represents a key-value store for analysis purposes. These operations are used to track and retrieve relationships between abstract values during constraint solving in the analysis of control flow graphs.",
      "description_length": 436,
      "index": 241,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Control.AnalyzeCFG.CompareGlobSys.Sys.D",
      "library": "goblint.lib",
      "description": "This module provides lattice operations and domain utilities for abstract interpretation in dataflow analysis, including join, meet, widen, and narrowing operations to manipulate abstract states. It operates on a specialized abstract domain type representing program state information, supporting comparisons, serialization, and order checks against top/bottom elements. These capabilities enable constraint solving and fixed-point computations in static analysis of program control flow graphs.",
      "description_length": 495,
      "index": 242,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Control.AnalyzeCFG.CompareGlobSys.Sys.G",
      "library": "goblint.lib",
      "description": "This module combines lattice operations with context-aware state sets to enable abstract interpretation of program constraints. It defines polymorphic variants tagged with `Lifted1` and `Lifted2` to merge specification states and `CSet.t` contexts, supporting join, meet, widen, and narrow operations. The child module extends this by implementing set-theoretic and lattice operations on `CSet.t`, allowing precise manipulation of abstract program states during analysis. Together, they facilitate merging and approximating states across different analysis dimensions while preserving contextual distinctions.",
      "description_length": 609,
      "index": 243,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MutexAnalysis.Spec.Arg.MakeP.Write",
      "library": "goblint.lib",
      "description": "This module implements lattice operations including join, meet, widen, and narrow, alongside equality checks, hashing, and pretty-printing for an abstract interpretation domain. It operates on values of type `Write.t`, structured as a lattice with distinguished top and bottom elements. These capabilities support static analysis of concurrent programs, particularly for tracking dataflow dependencies and lock-protected state transitions.",
      "description_length": 439,
      "index": 244,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Witness.Result.ArgTool.NHT.Infix",
      "library": "goblint.lib",
      "description": "This module provides infix operators for interacting with a non-thread-safe hash table (`ArgTool.NHT.t`). It supports direct key-value access using `-->` for retrieval and `<--` for insertion. These operations are useful when building or querying argument graphs where keys are symbolic identifiers and values represent analysis results or metadata.",
      "description_length": 349,
      "index": 245,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Control.AnalyzeCFG.CompareGlobSys.Sys.GVar",
      "library": "goblint.lib",
      "description": "This module defines operations for comparing, hashing, and pretty-printing global system variables represented as either specification variables or CIL function declarations. It provides functions to extract identifiers, determine write-only status, and convert values to various formats like XML or Yojson. Concrete use cases include tracking and analyzing global variables during abstract interpretation and constraint solving in a C program analysis context.",
      "description_length": 461,
      "index": 246,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Control.AnalyzeCFG.SpecSys.GHT.Infix",
      "library": "goblint.lib",
      "description": "This module defines infix operators for interacting with a BatHashtbl-based global heap table (GHT) in the context of static analysis. It provides `-->` to retrieve the current binding of a key or raise `Not_found`, and `<--` to add a binding that hides previous entries without removing them. These operations support path-sensitive analysis by enabling temporary state modifications during constraint solving.",
      "description_length": 411,
      "index": 247,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.YamlWitness.Validator.Locator.LocM.Infix",
      "library": "goblint.lib",
      "description": "This module provides infix operators for manipulating location-based monadic values in YAML witness validation. It supports operations to bind keys and values within a location context, specifically for navigating and modifying structured YAML data. Concrete use cases include building and validating paths within a YAML document to ensure correct node relationships and value placements.",
      "description_length": 388,
      "index": 248,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.UnassumeAnalysis.Spec.Locator.ES.Exceptionless",
      "library": "goblint.lib",
      "description": "This module provides operations to query and retrieve elements from a set-like structure, including functions to get the minimum, maximum, arbitrary, or any element, as well as lookup by value. It works with the `t` type representing the collection and `elt` as the element type. Concrete use cases include selecting specific elements for unassume event emission based on invariant data from YAML witnesses.",
      "description_length": 407,
      "index": 249,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.UnassumeAnalysis.Spec.Locator.LocM.Labels",
      "library": "goblint.lib",
      "description": "This module implements a key-value map for `LocM.key` keys and arbitrary data values, supporting standard transformations and inspections. It provides operations to add entries, iterate over key-data pairs, map values with or without keys, filter by value or key and value, fold into aggregate results, and compare or check equality of maps using custom functions. Concrete use cases include tracking and transforming location-specific analysis data during unassume event processing in static analysis workflows.",
      "description_length": 512,
      "index": 250,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Control.AnalyzeCFG.CompareGlobSys.GH.Labels",
      "library": "goblint.lib",
      "description": "This module provides operations for manipulating keyed collections with functions like `add`, `replace`, `iter`, `map`, `filter`, and `fold`, supporting transformations, queries, and in-place modifications. It works with a generic data structure `CompareGlobSys.GH.t` that associates keys of type `CompareGlobSys.GH.key` with arbitrary data values. Concrete use cases include tracking and transforming analysis state during constraint solving, such as updating variable bindings, filtering unreachable paths, or merging analysis results across control flow branches.",
      "description_length": 566,
      "index": 251,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.UnassumeAnalysis.Spec.Locator.FileH.Exceptionless",
      "library": "goblint.lib",
      "description": "Works with file-handling specifications to locate and modify data associated with keys in a structured context. Provides `find` to retrieve values by key and `modify` to update them, returning results that handle potential errors. Useful for managing and manipulating file-based analysis data in unassume workflows, such as adjusting invariants or extracting specific entries from YAML witnesses.",
      "description_length": 396,
      "index": 252,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.YamlWitness.Validator.Locator.FileH.Infix",
      "library": "goblint.lib",
      "description": "This module provides infix operators for navigating and modifying YAML witness data structures using file-based locators. It supports operations to get (`-->`) and set (`<--`) values at specific keys within a file locator context. Concrete use cases include validating and updating YAML witness files during static analysis workflows.",
      "description_length": 334,
      "index": 253,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.YamlWitness.Validator.Locator.LocM.Labels",
      "library": "goblint.lib",
      "description": "This module implements a labeled location map for managing key-value pairs associated with specific locations in a YAML witness structure. It provides operations to add, filter, map, iterate over, and fold entries, where keys are location identifiers and values can be arbitrary data. Concrete use cases include tracking variable annotations, error positions, or metadata across YAML validation processes.",
      "description_length": 405,
      "index": 254,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Control.AnalyzeCFG.CompareGlobSys.PP.Exceptionless",
      "library": "goblint.lib",
      "description": "Works with abstract interpretation frameworks to analyze control flow graphs by solving constraints without exception handling. It provides operations to find and modify values associated with keys in a system of equations derived from the control flow graph. This is used in static analysis to compute program invariants and detect potential runtime errors.",
      "description_length": 358,
      "index": 255,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Control.AnalyzeCFG.CompareGlobSys.LH.Exceptionless",
      "library": "goblint.lib",
      "description": "This module provides operations for safely modifying and querying a map-like structure that tracks analysis results during control flow graph processing. It works with typed maps (`'a CompareGlobSys.LH.t`) keyed by a specific key type used in constraint solving. Concrete use cases include updating and retrieving abstract values during path-sensitive analysis without exception handling overhead.",
      "description_length": 397,
      "index": 256,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Control.AnalyzeCFG.Slvr.VH.Exceptionless",
      "library": "goblint.lib",
      "description": "This module provides operations to safely query and update values associated with keys in a map structure, handling potential errors explicitly through result types. It works with key-value maps where keys are of type `Slvr.VH.key` and values are polymorphic. Concrete use cases include managing analysis state during constraint solving, where modifications must be applied atomically and safely without raising exceptions.",
      "description_length": 423,
      "index": 257,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.UnassumeAnalysis.Spec.Locator.ES.Labels",
      "library": "goblint.lib",
      "description": "This module processes collections of elements representing unassume event labels, supporting iteration, transformation, and conditional selection. It operates on a specific data structure `t` containing elements of type `elt`, which correspond to labeled unassume events derived from YAML witness invariants. Use cases include filtering events by label, mapping transformations over event data, and partitioning event streams for targeted analysis in verification workflows.",
      "description_length": 474,
      "index": 258,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MutexAnalysis.Spec.Arg.MakeP.P",
      "library": "goblint.lib",
      "description": "This module combines a product domain of read-write and write-only states with lattice operations to model mutex locking behavior, supporting abstract interpretation through meet, join, widen, and narrow operations. It provides structured serialization to XML and JSON, along with differential analysis for comparing mutex states, enabling precise tracking of lock dependencies and access patterns. These capabilities are particularly useful in static analysis of concurrent programs to verify correct mutex usage and identify race conditions.",
      "description_length": 543,
      "index": 259,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.UnassumeAnalysis.Spec.Locator.LocM.Infix",
      "library": "goblint.lib",
      "description": "This module defines infix operators for manipulating location-based monadic values in the unassume analysis. It provides `-->` to extract a value associated with a key from a location monad and `<--` to insert a key-value pair into a location monad. These operations are used to track and propagate unassume events tied to specific program locations during invariant processing.",
      "description_length": 378,
      "index": 260,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Witness.Result.ArgTool.NHT.Exceptionless",
      "library": "goblint.lib",
      "description": "This module provides operations to safely query and update values in a nested hash table structure without raising exceptions. It works with typed nested hash tables (`ArgTool.NHT.t`) and supports key-based lookups and function-based modifications. Concrete use cases include managing hierarchical state data and performing conditional updates in analysis tools where error handling must be explicit and non-throwing.",
      "description_length": 417,
      "index": 261,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Control.AnalyzeCFG.SpecSys.LHT.Infix",
      "library": "goblint.lib",
      "description": "This module defines infix operators for interacting with a BatHashtbl-based table structure, specifically for managing key-value bindings. It provides `-->` to retrieve the current value associated with a key (raising `Not_found` if absent) and `<--` to add or update a binding, preserving previous values for later restoration. These operations are used to manipulate a hierarchical table during constraint solving in a static analysis context.",
      "description_length": 445,
      "index": 262,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.YamlWitness.Validator.Locator.FileH.Exceptionless",
      "library": "goblint.lib",
      "description": "Performs key-based lookup and modification in a file handle locator structure, handling errors via result types instead of exceptions. Works with `'a Locator.FileH.t` maps and their associated keys. Useful for safely accessing and updating file handle data in witness validation workflows without exception handling overhead.",
      "description_length": 325,
      "index": 263,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Control.AnalyzeCFG.Slvr.VH.Infix",
      "library": "goblint.lib",
      "description": "This module provides functions for manipulating and querying a hash table-based solver structure, specifically designed for constraint solving in abstract interpretation. It supports operations to bind keys to values and retrieve values associated with keys within a solver context. These operations facilitate the incremental computation and tracking of abstract states during program analysis.",
      "description_length": 395,
      "index": 264,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Control.AnalyzeCFG.CompareGlobSys.PP.Infix",
      "library": "goblint.lib",
      "description": "This module defines bidirectional mapping operations between values and keys in a comparison-based global system. It provides the `(-->)` and `(<--)` operators to associate and retrieve values with keys in a structured context. These operations are used to manipulate mappings during static analysis of program control flow.",
      "description_length": 324,
      "index": 265,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Control.AnalyzeCFG.Slvr.VH.Labels",
      "library": "goblint.lib",
      "description": "This module provides hash table operations for managing labeled analysis data during control flow graph traversal in a constraint solver. It supports keyed insertion, modification, filtering, and folding over hash tables mapping labels to analysis states, with in-place and functional variants. Concrete use cases include tracking variable abstractions at specific program points and merging path-sensitive states during fixed-point computation.",
      "description_length": 445,
      "index": 266,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MutexAnalysis.Spec.Arg.MakeP.ReadWrite",
      "library": "goblint.lib",
      "description": "This module provides lattice operations for analyzing read/write states in concurrent programs, including equality checks, ordering relations, and merge operations over a `ReadWrite.t` type that models access permissions. It supports abstract interpretation by structuring states as a lattice with distinguished bottom and top elements, enabling analysis of mutex-protected data. The operations facilitate tracking and comparing access modes (read/write) across program points to infer locking discipline and potential race conditions.",
      "description_length": 535,
      "index": 267,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Server.Locator.FileH.Infix",
      "library": "goblint.lib",
      "description": "This module defines infix operators `(-->)` and `(<--)` for accessing and updating values associated with keys in a file-based locator structure. It works with typed key-value pairs where keys identify specific file resources and values are retrieved or stored on demand. These operations are used to implement efficient, type-safe file lookups and updates within an interactive server context.",
      "description_length": 394,
      "index": 268,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.SymbLocks.Spec.A.E",
      "library": "goblint.lib",
      "description": "This module defines a polymorphic variant type `t` that represents either a symbolic lock (`PLock.t`) or an integer lock (`ILock.t`), primarily used for tracking and comparing lock states in static race detection. It includes operations for equality checking, comparison, hashing, and pretty-printing, along with utilities for XML and JSON serialization. Concrete use cases include analyzing locking patterns in device drivers to detect potential concurrency issues during static analysis.",
      "description_length": 489,
      "index": 269,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.WitnessUtil.Locator.FileH.Exceptionless",
      "library": "goblint.lib",
      "description": "This module provides operations to safely locate and modify values in a file handle structure without raising exceptions. It works with `'a FileH.t`, a map-like structure indexed by `FileH.key`, and returns results in a `BatPervasives.result` type. Concrete use cases include querying or updating file-specific data during witness generation when processing program analyses.",
      "description_length": 375,
      "index": 270,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.WitnessUtil.Locator.ES.Exceptionless",
      "library": "goblint.lib",
      "description": "This module provides functions to retrieve specific elements from a set without raising exceptions. It works with sets of type `ES.t` and elements of type `ES.elt`, offering operations like `min_elt`, `max_elt`, `choose`, `any`, and `find` that return `option` values. These functions are useful when querying set contents in a safe, exception-free manner, such as selecting representative elements or checking for the presence of specific values.",
      "description_length": 447,
      "index": 271,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Base.MainFunctor.VarMap.Infix",
      "library": "goblint.lib",
      "description": "This module provides infix operators for manipulating variable maps in a base analysis context. It supports operations to retrieve a value by key (`-->`) and update a map with a key-value pair (`<--`). These operators are used to efficiently access and modify variable bindings during static analysis of program variables.",
      "description_length": 322,
      "index": 272,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.YamlWitness.Make.FCMap.Labels",
      "library": "goblint.lib",
      "description": "This module provides operations for manipulating finite maps with string keys and arbitrary data values, supporting common transformations like mapping, filtering, and merging. It includes functions for both in-place and functional updates, enabling precise modifications based on keys and values, such as adding or replacing entries, applying functions across entries, or conditionally removing or transforming elements. Use cases include managing structured YAML witness data where key-based access and transformation are required, such as updating specific fields or validating and restructuring map contents during analysis.",
      "description_length": 628,
      "index": 273,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.SymbLocks.Spec.A.PLock",
      "library": "goblint.lib",
      "description": "This module represents symbolic lock identifiers tied to memory offsets, used for tracking per-element locking in data structures. It supports operations like equality checking, hashing, comparison, and pretty-printing, along with generating arbitrary values for testing and serializing to various formats. It is used in static race detection to associate locks with specific memory locations in device drivers.",
      "description_length": 411,
      "index": 274,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.PrecCompareUtil.Util.RH.Infix",
      "library": "goblint.lib",
      "description": "This module defines infix operators for interacting with a hash table, providing direct access to bindings and adding new key-value pairs while preserving previous values. It works specifically with `BatHashtbl` structures, using `-->` to retrieve values and `<--` to insert key-value pairs. These operators simplify hash table manipulations in precision comparison workflows, such as tracking and restoring variable bindings during analysis.",
      "description_length": 442,
      "index": 275,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.YamlWitness.Make.NH.Exceptionless",
      "library": "goblint.lib",
      "description": "This module provides operations for safely accessing and modifying values in a key-value store backed by a nested hash table structure. It supports functions like `find` to retrieve values by key and `modify` to update values, handling potential exceptions internally and returning results in a `result` type. It is used for managing hierarchical YAML-based witness data where keys map to values within a structured, nested context.",
      "description_length": 432,
      "index": 276,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.CompareConstraints.CompareNode.NH.Labels",
      "library": "goblint.lib",
      "description": "This module manages labeled nodes in a constraint graph, supporting operations like adding, replacing, and modifying node labels with associated data. It provides functions for iterating, filtering, and transforming nodes based on their keys and values, enabling precise control over constraint propagation. Use cases include tracking variable constraints during static analysis and managing dependencies between analysis nodes.",
      "description_length": 428,
      "index": 277,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.YamlWitness.Validator.Locator.ES",
      "library": "goblint.lib",
      "description": "This module combines set-theoretic operations and ordered traversal capabilities to manipulate collections of variables and labeled elements, supporting union, intersection, difference, filtering, and mapping. It enables efficient querying and transformation of structured data such as YAML-based witnesses, with direct access to elements via selection functions like minimum, maximum, or arbitrary extraction. The module handles both sorted and exception-agnostic sets, offering conversions to sequences, lists, and arrays while ensuring precise validation of hierarchical structures. Submodules extend its functionality to label-based set processing and element retrieval, enabling tasks like validation rule enforcement, label metadata transformation, and non-exceptional value selection during witness analysis.",
      "description_length": 815,
      "index": 278,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Control.AnalyzeCFG.Slvr.EqSys",
      "library": "goblint.lib",
      "description": "This module solves systems of equations over lifted lattices by integrating constraint variables with control flow graph analysis, enabling fixed-point computations for static analysis tasks like constant propagation and reaching definitions. It combines global and local variables with lattice operations such as join, meet, widening, and narrowing over a polymorphic variant type that includes bottom and top elements. The system supports value comparison, serialization, and domain-specific manipulation, allowing analysis of variable states as they evolve across CFG nodes. Specific operations include solving interdependent constraints from C program analysis, tracking variable equality and ordering, and pretty-printing variable states during constraint resolution.",
      "description_length": 772,
      "index": 279,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.WitnessUtil.Locator.ES.Labels",
      "library": "goblint.lib",
      "description": "This module processes sets of elements with operations like iteration, folding, filtering, and mapping. It supports set manipulation for tasks like label tracking and condition checking during witness generation. Use cases include analyzing program paths and extracting relevant element subsets based on custom predicates.",
      "description_length": 322,
      "index": 280,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Control.AnalyzeCFG.Result.Exceptionless",
      "library": "goblint.lib",
      "description": "This module provides operations to safely query and update analysis results stored in a hash table indexed by result keys. It works with result values wrapped in a result type that handles potential exceptions during modifications. Concrete use cases include retrieving and transforming intermediate analysis data without propagating exceptions, ensuring safe access during constraint solving.",
      "description_length": 393,
      "index": 281,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MutexAnalysis.Spec.GM.Infix",
      "library": "goblint.lib",
      "description": "This module defines bidirectional mapping operations between a polymorphic type `'a` and a key type using the `-->` and `<--` operators. It facilitates direct association and retrieval of values with specific keys within a mutex analysis context. Concrete use cases include tracking lock ownership and associated data in concurrent program analysis.",
      "description_length": 349,
      "index": 282,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Server.Locator.ES.Exceptionless",
      "library": "goblint.lib",
      "description": "Works with a set-like structure to retrieve specific elements without raising exceptions. Provides safe lookup operations including minimum, maximum, arbitrary choice, and key-based find, returning `option` values. Useful for querying JSON-RPC server data where element presence isn't guaranteed.",
      "description_length": 296,
      "index": 283,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.UnassumeAnalysis.Spec.Locator.LocM",
      "library": "goblint.lib",
      "description": "This module implements a polymorphic ordered map with CIL locations as keys, supporting standard dictionary operations, ordered traversal, and monadic transformations for structured data manipulation. It provides key operations like `min_binding`, `fold`, and exceptionless utilities, enabling use cases such as merging YAML witness invariants and ordered processing of source code annotations. Submodules extend functionality with query operations, map transformations, and infix syntax for location-based value extraction and insertion, supporting analyses that track and propagate unassume events tied to specific program locations. Together, they form a cohesive interface for location-aware, effectful data processing in static analysis workflows.",
      "description_length": 752,
      "index": 284,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.RaceAnalysis.Spec.OffsetTrie.Trie",
      "library": "goblint.lib",
      "description": "This module implements a trie-based lattice structure for managing hierarchical memory access paths in data race analysis. It provides operations for equality checks, lattice joins/meets, and traversal to handle prefix/suffix relationships between memory locations, while storing access sets at nodes keyed by offset paths. The trie enables efficient race detection across complex type hierarchies and pointer indirections by systematically comparing access sets from prefixes, type suffixes, and their intersections during static analysis of concurrent C programs.",
      "description_length": 565,
      "index": 285,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.WitnessUtil.Locator.FileH.Infix",
      "library": "goblint.lib",
      "description": "This module provides infix operators for accessing and updating values in a file handle structure using keys. It works with `FileH.t` and `FileH.key` types, enabling direct manipulation of file-associated data. Concrete use cases include reading from or writing to specific positions in a file during witness generation or invariant tracking.",
      "description_length": 342,
      "index": 286,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Control.AnalyzeCFG.CompareGlobSys.Sys",
      "library": "goblint.lib",
      "description": "The module manages a system of local and global variables for constraint solving in static analysis, enabling precise dataflow analysis over control flow graphs through operations to build, iterate, and query variable states. It supports abstract interpretation by integrating lattice operations for fixed-point computations and context-aware state manipulation, with utilities for comparing, hashing, and serializing variables, including global variables derived from specification contexts or CIL function declarations. Direct APIs allow variable state tracking and constraint evaluation, while submodules handle lattice transformations, context merging, and variable identity extraction, facilitating advanced analysis such as merging abstract states across different analysis dimensions or serializing variable data for external processing. Example uses include tracking variable modifications during abstract interpretation and solving constraints using labeled variable comparisons or lattice-based approximations.",
      "description_length": 1020,
      "index": 287,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MutexAnalysis.Spec.Arg.G",
      "library": "goblint.lib",
      "description": "This module provides lattice operations and domain manipulation utilities for concurrency analysis, including join/meet operations, widening/narrowing, and projection between abstract domains. It works with polymorphic variant types representing mutex states (`Bot`, `Top`, `Lifted1`, `Lifted2`) and combined abstract domains for tracking protecting/protected locksets. These capabilities enable static analysis of thread synchronization patterns and lock dependencies in concurrent programs.",
      "description_length": 492,
      "index": 288,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.CompareConstraints.CompareEqSys.Compare.Var",
      "library": "goblint.lib",
      "description": "This module defines operations for comparing, identifying, and pretty-printing variable representations in a constraint system. It works with the `t` type, which is an alias for `Sys.Var.t`, representing variables in a system of constraints. Concrete use cases include tracking variable identities via `var_id`, comparing variables for equality and ordering, and generating human-readable output for debugging with `pretty_trace` and `show`.",
      "description_length": 441,
      "index": 289,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.PrivPrecCompareUtil.Util.RH.Infix",
      "library": "goblint.lib",
      "description": "This module defines two operations, `(-->)` and `(<--)`, for interacting with a resource handle (`RH.t`) using a key-value interface. It allows retrieving a value of type `'a` associated with a key from a resource handle, and associating a key-value pair with a resource handle. These operations are used to manage per-key precision settings in static analysis contexts, where resource handles track analysis state for different program elements.",
      "description_length": 446,
      "index": 290,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Base.MainFunctor.VarMap.Labels",
      "library": "goblint.lib",
      "description": "This module implements a labeled map structure for variables, providing operations to add, iterate, map, filter, fold, compare, and check equality over variable bindings. It works with variable keys and arbitrary data values, supporting transformations and queries specific to variable environments. Concrete use cases include tracking variable values during static analysis and managing per-variable metadata.",
      "description_length": 410,
      "index": 291,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Control.AnalyzeCFG.Slvr.Sol'",
      "library": "goblint.lib",
      "description": "This module provides functions for copying, relifting, and solving constraint systems over a value domain. It operates on a marshaled solver state and a system of equations involving variables and domain elements. Concrete use cases include resuming or modifying abstract interpretation analyses from saved states and computing fixed points for program analysis.",
      "description_length": 362,
      "index": 292,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Server.Locator.LocM.Labels",
      "library": "goblint.lib",
      "description": "This module manages a labeled mapping structure where each entry is associated with a key and data. It provides operations to add entries, iterate over key-data pairs, transform data values with or without key context, filter entries based on data or key and data, and fold over the structure. It is used to maintain and manipulate structured server-side data with labeled keys, such as tracking source code locations or managing contextual analysis data in Goblint's interactive server.",
      "description_length": 487,
      "index": 293,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Goblint_lib.Server.Locator.FileH.Labels",
      "library": "goblint.lib",
      "description": "This module manages labeled data associated with source code files in an interactive server environment. It provides operations to add, modify, filter, and transform labeled data entries using file-specific keys. Use cases include tracking analysis results, error annotations, or code navigation markers during static analysis sessions.",
      "description_length": 336,
      "index": 294,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.CompareConstraints.CompareNode.Compare.Var",
      "library": "goblint.lib",
      "description": "This module defines operations for comparing, identifying, and pretty-printing variable-like entities tied to control flow nodes. It supports equality checks, hashing, and total ordering via `compare`, along with extracting node information and string representations. Concrete use cases include tracking variable identities across analyses and formatting variables for diagnostic output or XML serialization.",
      "description_length": 409,
      "index": 295,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Server.Locator.LocM.Exceptionless",
      "library": "goblint.lib",
      "description": "This module provides operations for querying and selecting entries in a key-value structure without raising exceptions. It supports data types with keys and associated values, allowing safe lookup, selection of any entry, and retrieval of matching pairs. Concrete use cases include handling optional results when navigating or inspecting structured data in interactive server contexts.",
      "description_length": 385,
      "index": 296,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Base.MainFunctor.VarH.Exceptionless",
      "library": "goblint.lib",
      "description": "Implements variable map operations with exception-safe modifications. Works with variable maps (`VarH.t`) for analysis contexts where key absence must not raise exceptions. Use to safely update variable bindings during static analysis passes without handling `Not_found`.",
      "description_length": 271,
      "index": 297,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Base.MainFunctor.VarMap.Exceptionless",
      "library": "goblint.lib",
      "description": "Implements variable map operations for exceptionless value analysis. Provides functions to safely retrieve values (`find`), select an arbitrary binding (`choose`), and access any element (`any`) from maps keyed by variables. Useful in static analysis phases where variable bindings must be queried without raising exceptions.",
      "description_length": 325,
      "index": 298,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.YamlWitness.Validator.Locator.LocM",
      "library": "goblint.lib",
      "description": "This module manages ordered maps keyed by source code locations, enabling precise association of values with positions in structured data like YAML. It supports safe access and traversal through non-raising operations like `find`, `choose`, and `any`, while infix operators allow binding and transforming location-annotated values within monadic contexts. Submodules extend this foundation to handle YAML-specific validation tasks, such as path construction, node relationship checks, and metadata tracking across witness traces. Use cases include error reporting with positional context, configuration parsing, and validating structured documents with location-aware transformations.",
      "description_length": 684,
      "index": 299,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Server.Locator.ES.Labels",
      "library": "goblint.lib",
      "description": "This module processes sets of elements representing code locations in a JSON-RPC server context. It supports iteration, transformation, filtering, and logical checks over these location sets. Typical uses include querying specific subsets of code locations or applying actions to all elements in a set.",
      "description_length": 302,
      "index": 300,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Control.AnalyzeCFG.Result.Labels",
      "library": "goblint.lib",
      "description": "This module provides operations for manipulating hashtables keyed by result nodes, supporting transformations, filtering, and aggregation over analysis results. It works with generic data types stored in hashtables where keys are of type `Result.key` and values can be of any type `'a`. Concrete use cases include updating analysis data per node, filtering nodes based on computed values, merging results from different analysis passes, and folding over node-value pairs to compute summaries.",
      "description_length": 492,
      "index": 301,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Witness.Result.ArgTool.NHT",
      "library": "goblint.lib",
      "description": "This module provides imperative hash table operations for node-keyed stores, supporting efficient insertion, lookup, and in-place modification alongside higher-order transformations like `map` and `fold`. It enables functional manipulations such as conditional updates, filtering, and merging, and integrates with submodules that extend its capabilities for typed key-value maps, infix operator access, and safe nested updates. It supports conversions to sequences, lists, and formatted representations, making it suitable for graph analysis workflows requiring dynamic, node-centric data management. Specific uses include tracking metadata, refining analysis results, and managing hierarchical state with explicit error handling.",
      "description_length": 730,
      "index": 302,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Control.AnalyzeCFG.SpecSys.EQSys",
      "library": "goblint.lib",
      "description": "Implements a system for solving equality constraints over lattice variables (`LVar.t`) and global variables (`GVar.t`) during abstract interpretation. Provides functions to build, iterate, and update constraint systems based on changes in variable states. Used to compute fixed points for program analysis by resolving dependencies in the control flow graph.",
      "description_length": 358,
      "index": 303,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.UnassumeAnalysis.Spec.Locator.ES",
      "library": "goblint.lib",
      "description": "This module manages collections of `Node.t` elements with set-like operations, supporting membership checks, union/intersection/difference, and ranked element retrieval such as min, max, and arbitrary selection. It combines these capabilities with submodules that enable querying and transforming structured collections, including label-based filtering and mapping of unassume events derived from YAML witnesses. The `t` type serves as the primary data structure, allowing efficient set manipulations and ordered access for tasks like emitting unassume events based on invariant constraints. Specific operations include selecting a minimal node, transforming event labels, and partitioning event streams for verification workflows.",
      "description_length": 731,
      "index": 304,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.YamlWitness.Make.NH.Infix",
      "library": "goblint.lib",
      "description": "This module provides infix operators for accessing and modifying values in a nested hash table structure using a specified key type. It supports operations to retrieve a value by key (`-->`) and to insert or update a key-value pair (`<--`). These operations are specifically designed for working with hierarchical data representations, such as configuration settings or structured logs, where nested key-value access is required.",
      "description_length": 429,
      "index": 305,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MutexAnalysis.Spec.GM.Labels",
      "library": "goblint.lib",
      "description": "This module implements a labeled map structure for managing key-value pairs with support for atomic updates, filtering, and transformation operations. It provides functions like `add`, `modify`, and `iter` for precise manipulation of entries, along with higher-order operations such as `map`, `filter_map`, and `fold` for bulk processing and aggregation. It is used to track and analyze mutex-related state in concurrent programs, where keys represent synchronization points and values capture associated analysis data.",
      "description_length": 519,
      "index": 306,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ArgTools.Make.NHT.Infix",
      "library": "goblint.lib",
      "description": "This module provides infix operators for interacting with a nested hash table structure, allowing values to be retrieved using a key chain with `-->` and inserted with `<--`. It works directly with `NHT.t`, a nested hash table type, and keys of type `NHT.key`. These operators simplify accessing and modifying deeply nested values in the table, particularly useful when constructing and manipulating abstract reachability graphs from constraint solutions.",
      "description_length": 455,
      "index": 307,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.YamlWitness.Make.LH.Exceptionless",
      "library": "goblint.lib",
      "description": "Implements key-based lookup and modification operations for YAML witness data structures. Works with associative maps (`LH.t`) that store typed values under string keys (`LH.key`). Used to safely access and update witness entries during analysis without raising exceptions, returning result types instead.",
      "description_length": 305,
      "index": 308,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Control.AnalyzeCFG.CompareGlobSys.GH",
      "library": "goblint.lib",
      "description": "This module manages a global system state with typed key-based access, enabling safe queries and updates while handling exceptions during modification. It supports bidirectional mappings through intuitive operators and provides standard collection operations like `map`, `filter`, and `fold` for transforming and querying state. The `CompareGlobSys.GH.t` structure serves as the central data type, representing a key-value store used to track relationships and analysis results during CFG traversal. Specific operations include adding variable bindings, updating analysis state conditionally by key, and merging results across control flow branches.",
      "description_length": 649,
      "index": 309,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.WitnessUtil.Locator.FileH.Labels",
      "library": "goblint.lib",
      "description": "This module operates on labeled file-based data structures, enabling precise manipulation of key-value pairs with functions like `add`, `replace`, and `modify`. It supports transformations and queries with key-aware functions such as `map`, `filteri`, and `fold`, ensuring fine-grained control over file-located data. Concrete use cases include tracking and updating per-file metadata, enforcing per-file invariants, and merging file-specific information from multiple sources.",
      "description_length": 477,
      "index": 310,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Control.AnalyzeCFG.Slvr.VH",
      "library": "goblint.lib",
      "description": "This module manages constraint variables and analysis data using imperative hash tables that support key-based transformations, filtering, and merging. It operates on polymorphic key-value pairs stored in `Slvr.VH.t` structures, where keys represent constraint system variables (`Slvr.EqSys.v`) and values hold analysis results, enabling efficient in-place updates and exception-safe traversal during abstract interpretation. The module allows atomic modifications through result-typed operations, binds keys to values in solver contexts, and supports both functional and in-place manipulation of labeled analysis data during control flow traversal. Specific use cases include tracking variable abstractions at program points, merging path-sensitive states, and incrementally computing abstract states in a constraint solver.",
      "description_length": 825,
      "index": 311,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Deadlock.Spec.Arg.G",
      "library": "goblint.lib",
      "description": "This module provides map-based operations for tracking may-lock event pairs associated with memory addresses, supporting insertion, transformation, and custom merging of maps. It works with key-value structures mapping `ValueDomain.Addr.t` to `MayLockEventPairs.t`, alongside lattice operations for abstract domain analysis in deadlock detection. Use cases include combining lock event data across program paths, filtering address-specific locking behavior, and applying widening/narrowing during static analysis to model concurrent resource contention.",
      "description_length": 553,
      "index": 312,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.PrivPrecCompareUtil.Util.RH.Labels",
      "library": "goblint.lib",
      "description": "This module provides operations for manipulating hash tables with keys of type `key` and arbitrary data values. It supports standard imperative operations like `add`, `replace`, `modify`, and `iter`, as well as higher-order functions such as `map`, `filter`, `fold`, and `exists` that operate on both keys and values. These functions are used for precise in-place or functional transformations and queries of hash table entries during static analysis precision comparisons.",
      "description_length": 473,
      "index": 313,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.CompareConstraints.CompareNode.NH.Infix",
      "library": "goblint.lib",
      "description": "This module provides infix operators for interacting with a named handle (`NH.t`) structure, allowing values to be retrieved using a key with `-->` and inserted or updated with `<--`. It works directly with named handles and their associated keys and values. Concrete use cases include managing scoped or named state where keys are symbols or strings, such as configuration settings or environment variables.",
      "description_length": 408,
      "index": 314,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ExtractPthread.Codegen.PmlResTbl.FunTbl",
      "library": "goblint.lib",
      "description": "This module maintains a bidirectional mapping between function names and unique integer identifiers, used to label edges in Promela code generation. It provides operations to retrieve an integer ID for a given function name, fetch the function name from an ID, and list all mappings. The table is essential for translating function references into stable numeric identifiers during resource tracking.",
      "description_length": 400,
      "index": 315,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.MutexAnalysis.Spec.Arg.D",
      "library": "goblint.lib",
      "description": "The module provides lattice operations (join, meet, widen, narrow, leq) and standard constants (top, bot) for a domain combining must-lockset and multiplicity analysis. It operates on pairs of MustLocksetRW and MustMultiplicity types, structured as a product domain, to track required locks and their acquisition counts in concurrent program analysis. This enables use cases such as deadlock detection, lock order verification, and ensuring correct mutex usage in statically analyzed code regions.",
      "description_length": 497,
      "index": 316,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Server.Locator.LocM.Infix",
      "library": "goblint.lib",
      "description": "This module defines infix operators for manipulating location-based monadic values. It provides `-->` to retrieve a value associated with a key from a location monad and `<--` to update or insert a key-value pair within it. These operations are used to manage contextual information during server-side analysis, such as tracking source code positions or error locations in JSON-RPC responses.",
      "description_length": 392,
      "index": 317,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Control.AnalyzeCFG.SpecSys.LHT",
      "library": "goblint.lib",
      "description": "This module enhances hash table operations with labeled, exception-safe, and infix-based interfaces, centered around the `t` hashtbl-like type and `key` identifiers. It supports transformations, filtering, and merging through labeled functions, while offering safe `find` and `modify` operations that avoid exceptions during constraint solving. Infix operators `-->` and `<--` enable concise value retrieval and binding updates, particularly useful in hierarchical table management. Together, these features facilitate robust, readable manipulation of labeled state mappings in static analysis workflows.",
      "description_length": 604,
      "index": 318,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.YamlWitness.Make.FCMap.Exceptionless",
      "library": "goblint.lib",
      "description": "This module provides operations for safely accessing and modifying values in a key-value map with string keys, specifically handling cases where keys may be absent or invalid. It supports data structures used in YAML witness generation and validation, such as maps that track configuration or analysis results. Concrete use cases include looking up optional configuration entries and updating mapped values without raising exceptions.",
      "description_length": 434,
      "index": 319,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.CompareConstraints.CompareGlobSys.PP.Exceptionless",
      "library": "goblint.lib",
      "description": "This module provides operations to safely query and update a system of constraints associated with keys in a map-like structure. It supports finding values by key and modifying them with a function, returning results in a `result` type that handles potential exceptions without raising. It is used for managing constraint systems where operations must be performed without interruption, such as during static analysis passes where error recovery is critical.",
      "description_length": 458,
      "index": 320,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.YamlWitnessType.ViolationSequence.Constraint.Value",
      "library": "goblint.lib",
      "description": "This module defines a polymorphic type `t` with variants `String` and `Int`, representing constraint values in a violation sequence. It includes functions to compare values, convert them to YAML format, and parse them from YAML input. These operations directly support handling string and integer constraint data in witness files used for program analysis.",
      "description_length": 356,
      "index": 321,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MutexAnalysis.Spec.GM.Exceptionless",
      "library": "goblint.lib",
      "description": "Implements exception-safe operations for modifying and querying a lockset analysis structure. It provides `find` to retrieve values associated with keys and `modify` to update values, returning a result type to handle failures explicitly. Designed for use in static analysis passes where lock states must be tracked and updated without unwinding or exception handling.",
      "description_length": 368,
      "index": 322,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.UnassumeAnalysis.Spec.Locator.FileH",
      "library": "goblint.lib",
      "description": "This component manages key-value mappings with raw string keys, supporting both functional and imperative manipulation of hash tables through insertion, lookup, iteration, and folding. It enables key-aware transformations like filtering, merging, and conditional updates, with utilities to handle multiple values per key and default lookups, facilitating efficient data association and conversion between hash tables, sequences, and lists. The child modules extend this functionality to file-specific contexts, using structured keys to track analysis data tied to file locations, supporting bidirectional mappings, labeled storage, and precise retrieval or modification of entries using operations like `-->`, `<--`, `find`, and `modify`. Examples include tracking invariants across YAML witnesses, integrating structured data transformations, and managing unassume events during verification workflows.",
      "description_length": 903,
      "index": 323,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.WitnessUtil.Locator.LocM.Labels",
      "library": "goblint.lib",
      "description": "This module operates on labeled data structures associated with location keys, providing functions to manipulate and traverse data mapped to these keys. It supports operations like adding entries, filtering based on key and data, mapping transformations, and folding over key-data pairs. It is used for managing location-annotated values, such as tracking source code positions or associating metadata with program elements.",
      "description_length": 424,
      "index": 324,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.MutexAnalysis.Spec.Arg.GProtecting",
      "library": "goblint.lib",
      "description": "This analysis framework provides lattice operations and querying functions to track variable protection by mutexes in concurrent programs. It operates on a lattice structure `t` that models read/write protection states, combined with `MustLockset.t` sets to associate variables with their required mutexes. These mechanisms support static analysis tasks such as verifying correct lock acquisition for shared variables and ensuring thread-safe access patterns.",
      "description_length": 459,
      "index": 325,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.PrecCompareUtil.Util.RH.Labels",
      "library": "goblint.lib",
      "description": "This module provides labeled argument versions of standard hash table operations, enhancing readability and argument order flexibility. It works with hash tables where keys are of type `RH.key` and data can be any type. Concrete use cases include adding or replacing key-value pairs, iterating over entries with key-value pairs, mapping and filtering values based on keys, and merging two hash tables with key-aware combination logic.",
      "description_length": 434,
      "index": 326,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.YamlWitness.Validator.Locator.FileH",
      "library": "goblint.lib",
      "description": "This module organizes file handle-based data using structured maps that associate keys with arbitrary values, enabling transformations, filtering, and in-place updates. It supports merging maps with custom strategies and provides infix operators for navigating and modifying YAML witness data through file-based locators. Submodules enable safe key-based access and error-aware manipulation of locator structures, particularly for validating and updating source code annotations. Example uses include tracking structured metadata across files and performing precise edits in static analysis workflows.",
      "description_length": 601,
      "index": 327,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.CompareConstraints.CompareNode.NH.Exceptionless",
      "library": "goblint.lib",
      "description": "This module provides operations to safely modify values associated with keys in a hash table, handling potential exceptions during modification. It works with hash tables (`NH.t`) and keys of type `NH.key`, returning a result type that captures success or failure. A concrete use case is updating values in a thread-safe hash table without risking unhandled exceptions, ensuring robustness in concurrent or error-prone contexts.",
      "description_length": 428,
      "index": 328,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.YamlWitness.Make.NH.Labels",
      "library": "goblint.lib",
      "description": "This module operates on labeled hierarchical data structures, specifically `NH.t` containers with typed keys and values. It provides functions to manipulate and traverse these structures, such as adding, replacing, filtering, and mapping over entries, with support for in-place updates and conditional modifications. Use cases include constructing and transforming YAML-based witness data with precise label control, merging hierarchical data from multiple sources, and validating or enriching structured configurations.",
      "description_length": 520,
      "index": 329,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.YamlWitness.Make.FMap.Exceptionless",
      "library": "goblint.lib",
      "description": "This module provides operations for safely accessing and modifying values in a finite map with string keys, returning results in an exception-safe manner. It supports data types such as `'a FMap.t` for maps and `FMap.key` for string-based keys. Concrete use cases include querying and updating YAML witness data structures without risking unhandled exceptions during key lookups or modifications.",
      "description_length": 396,
      "index": 330,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.CompareConstraints.CompareGlobSys.PP.Labels",
      "library": "goblint.lib",
      "description": "This module manages a parameterized map structure with keys of type `PP.key` and arbitrary data values. It supports precise modifications, filtering, and transformations of entries using key-based predicates and functions. Typical uses include tracking and updating labeled constraints or configurations in analysis passes where key-specific behavior is critical.",
      "description_length": 363,
      "index": 331,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.CompareConstraints.CompareNode.Compare.CompareD",
      "library": "goblint.lib",
      "description": "Implements comparison logic for constraint nodes, specifically handling the `D.t` type. Provides a `compare` function that evaluates two constraint nodes with optional verbosity and naming, returning a comparison result and a pretty-printed document. Used to determine equivalence or differences between constraint states during analysis.",
      "description_length": 338,
      "index": 332,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Witness.Result.ArgTool.Node",
      "library": "goblint.lib",
      "description": "This module defines operations for manipulating and comparing nodes in an abstract reachability graph (ARG), specifically handling tuples of control flow graph nodes, specification contexts, and path identifiers. It provides functions for equality checks, hashing, string representation, and determining node liveness, along with utilities for node transformation based on control flow. These operations directly support analysis and traversal of program paths in static analysis workflows.",
      "description_length": 490,
      "index": 333,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.RaceAnalysis.Spec.OffsetTrie.ChildMap",
      "library": "goblint.lib",
      "description": "This module provides map operations for managing hierarchical memory access data in tries, using a structure that maps offsets (`OneOffset.t`) to sub-tries (`OffsetTrie.Trie.t`). It supports lattice operations like join, meet, and widening for abstract interpretation, enabling efficient tracking of memory access patterns across prefix and type suffix relationships in data race analysis. Used to handle complex scenarios where accesses to nested structs, type-based pointers, or overlapping memory regions must be checked for races at the most precise level of the trie hierarchy.",
      "description_length": 582,
      "index": 334,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.YamlWitness.Make.LH.Labels",
      "library": "goblint.lib",
      "description": "This module provides operations for manipulating labeled hierarchical maps with keys of type `LH.key` and values of a polymorphic type. It supports adding, replacing, modifying, and filtering key-value pairs, as well as mapping, folding, and merging operations over the structure. Concrete use cases include managing structured YAML witness data with nested key-based access and transformations.",
      "description_length": 395,
      "index": 335,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Control.AnalyzeCFG.Slvr.Splitter",
      "library": "goblint.lib",
      "description": "Splits a solution into two parts based on the structure of the equation system. It handles lifted and base values, separating results for different variable types. Useful for extracting and managing analysis results in constraint-based static analysis.",
      "description_length": 252,
      "index": 336,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Deadlock.Spec.Arg.V",
      "library": "goblint.lib",
      "description": "This module provides operations for analyzing pointer values and lattice-based abstract interpretation. It works with pointer types encompassing addresses, null, unknown, and string values, along with lattice structures supporting join, meet, widening, and narrowing operations to model hierarchical relationships between states. These capabilities are used in static analysis to track memory values, resolve pointer arithmetic, and detect deadlocks through abstract domain transitions.",
      "description_length": 486,
      "index": 337,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Control.AnalyzeCFG.Result.Infix",
      "library": "goblint.lib",
      "description": "This module provides direct access to analysis results stored in a hash table indexed by control flow graph nodes. It defines operators for retrieving (`-->`) and updating (`<--`) values associated with specific nodes. These operations are used to query and modify the state of abstract interpretation during static analysis of programs.",
      "description_length": 337,
      "index": 338,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.YamlWitness.Make.LH.Infix",
      "library": "goblint.lib",
      "description": "This module provides infix operators for interacting with a labeled hash table (`LH.t`), allowing values to be retrieved using a key with `-->` and inserted or updated with `<--`. It works directly with labeled hash tables and key-value pairs where keys are of type `LH.key`. Concrete use cases include managing configuration settings or state mappings in a concise, readable syntax during witness generation or validation tasks.",
      "description_length": 429,
      "index": 339,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ArgTools.Make.NHT.Exceptionless",
      "library": "goblint.lib",
      "description": "This module provides operations for safely modifying and querying a nested hash table structure with exception handling. It works with `'a NHT.t`, a nested hash table type, and handles key-based access where modifications return a result type indicating success or failure. Concrete use cases include updating and retrieving values in a hierarchical key-value store without raising exceptions, suitable for constraint system solutions in analysis tools.",
      "description_length": 453,
      "index": 340,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.PrivPrecCompareUtil.Util.RH.Exceptionless",
      "library": "goblint.lib",
      "description": "This module provides operations for safely modifying values associated with keys in a map structure, returning a result type that handles potential errors without raising exceptions. It works with map-like structures parameterized over keys and values, specifically those in `Goblint_lib.PrivPrecCompareUtil.Util.RH`. A concrete use case is updating a value in a map only if the key exists, allowing for error propagation in a functional style.",
      "description_length": 444,
      "index": 341,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.YamlWitness.Make.FCMap.Infix",
      "library": "goblint.lib",
      "description": "This module provides infix operators for working with functional concurrent maps (FCMap), enabling thread-safe access and modification of key-value pairs. It supports operations to retrieve values by key (`-->`) and insert or update key-value pairs (`<--`). These operations are particularly useful in concurrent contexts where multiple threads interact with shared map instances without side effects.",
      "description_length": 401,
      "index": 342,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Control.AnalyzeCFG.CompareGlobSys.PP",
      "library": "goblint.lib",
      "description": "This module manages polymorphic per-node data in control flow graph analysis using a map-like structure keyed on `Node.t`, supporting imperative operations such as insertion, lookup, iteration, and bulk transformations like filtering and merging. It enables efficient manipulation of analysis data during CFG traversal, with direct support for converting maps to sequences or lists for traversal. Submodules extend this functionality by providing label-based key-value manipulations, abstract interpretation for constraint solving, and bidirectional mapping operators to associate and retrieve values in structured contexts. Examples include tracking variable states across CFG nodes, computing program invariants, and merging analysis results from different control flow paths.",
      "description_length": 778,
      "index": 343,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ResultQuery.Make.FileCfg.Cfg",
      "library": "goblint.lib",
      "description": "Implements operations for analyzing control flow graphs (CFGs) by tracking skipped statements between nodes. Provides functions to retrieve predecessor and successor CFG nodes and to determine the list of AST statements skipped during CFG creation. Useful for precise mapping between CFG nodes and the original source code structure during analysis.",
      "description_length": 349,
      "index": 344,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Witness.Result.ArgTool.Query",
      "library": "goblint.lib",
      "description": "This module provides functions to query local and global analysis results within an abstract reachability graph (ARG). It operates on graph structures representing program analysis states, using node identifiers and specification contexts to retrieve computed results for specific queries. Concrete use cases include extracting variable values at program points or checking properties of analyzed code paths.",
      "description_length": 408,
      "index": 345,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Svcomp.StackTaskResult.Arg.Edge",
      "library": "goblint.lib",
      "description": "This module defines operations for handling edges in a control flow graph specific to SV-COMP tasks. It provides functions to embed raw CFG edges into a task-specific edge type and convert them to string representations. It works with `MyCFG.edge` and `Arg.Edge.t` data types, enabling precise tracking and display of control flow transitions during program analysis.",
      "description_length": 367,
      "index": 346,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MutexAnalysis.Spec.Arg.V",
      "library": "goblint.lib",
      "description": "This module defines operations for handling mutex-related values represented as either a variable (`Left`) or a variable with an offset (`Right`). It provides equality checks, comparison, hashing, and conversion to various output formats like strings, XML, and JSON. These functions are used to analyze and manipulate mutex locking behavior in C code, specifically tracking variables and their offsets in lockset analyses.",
      "description_length": 422,
      "index": 347,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ThreadId.Spec.Created.Current",
      "library": "goblint.lib",
      "description": "This module provides lattice-theoretic operations (join, meet, widen, etc.) and structural utilities (hashing, comparison) for analyzing thread identifiers represented as type `t` (internally `TD.t`). It supports reasoning about thread state relationships in concurrent programs, including determining if a thread is the main thread (`is_top`) and retrieving thread names for diagnostic purposes. These operations are critical for static analysis of thread creation and interaction patterns in CIL-based code.",
      "description_length": 509,
      "index": 348,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ExtractPthread.Codegen.AdjacencyMatrix.HashtblN",
      "library": "goblint.lib",
      "description": "This module manages nested hash tables and adjacency matrices with safe, exception-free access and transformation of values. It supports key-based lookups, value modifications, and graph-like edge manipulations through both direct functions and infix operators. Main data types include hash tables with optional values and labeled adjacency matrices, with operations such as `find`, `modify`, `-->`, and `<--` enabling precise control over thread state transitions and graph structures. It is particularly used in Promela extraction and pthread analysis for modeling control flow and state transitions.",
      "description_length": 602,
      "index": 349,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Svcomp.StackTaskResult.Arg.Node",
      "library": "goblint.lib",
      "description": "This module operates on a list of `Arg.Node.t` values, providing equality, comparison, and hashing functions for use in collections. It exposes accessors to retrieve associated CFG nodes, context IDs, path IDs, and string representations of nodes. These operations support precise tracking and manipulation of abstract interpretation states during SV-COMP task execution.",
      "description_length": 371,
      "index": 350,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MutexAnalysis.Spec.Arg.MakeP",
      "library": "goblint.lib",
      "description": "This module combines two domain instances into a product lattice for abstract interpretation, operating on pairs of values to track interdependent states like mutex usage and dataflow. It supports core lattice operations\u2014join, meet, widen\u2014and provides serialization, pretty-printing, and test generation for analysis and debugging. The first child module implements these operations for a single domain with top and bottom elements, enabling dataflow and concurrency analysis through equality, hash, and pretty-printing on `Write.t`. The second child models mutex locking by combining read-write and write-only states, offering structured serialization and differential analysis to detect race conditions and verify lock usage.",
      "description_length": 727,
      "index": 351,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.ArgTools.Make.NHT.Labels",
      "library": "goblint.lib",
      "description": "This module provides operations for manipulating hash tables with labeled keys and associated data values. It supports insertion, modification, iteration, filtering, mapping, and folding over hash table entries, where each entry is accessed by a key of type `NHT.key`. These operations are used to construct and transform attribute-rich graphs by processing constraint system solutions with precise key-based updates and traversals.",
      "description_length": 432,
      "index": 352,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Control.AnalyzeCFG.CompareGlobSys.LH",
      "library": "goblint.lib",
      "description": "This module orchestrates constraint manipulation and analysis tracking through a directed graph system, combining direct access to constraint nodes with dictionary-like and map-like operations. It centers on `CompareGlobSys.LH.t`, a structure keyed by `CompareGlobSys.LH.key`, supporting polymorphic values and typed maps for safe, efficient updates and queries. Infix operators enable graph navigation and modification, while submodules handle data transformation and analysis state tracking during static and path-sensitive analysis. Example uses include setting abstract values at CFG nodes, merging analysis results across program points, and iterating over filtered constraint subsets during fixed-point computation.",
      "description_length": 721,
      "index": 353,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.CompareConstraints.CompareEqSys.Compare.CompareD",
      "library": "goblint.lib",
      "description": "This module implements precise comparison operations for constraint systems, specifically handling equality checks between two `Sys.Dom.t` domains. It provides a `compare` function that evaluates structural and semantic equivalence, returning a comparison result along with a detailed pretty-printed document. Useful for analyzing and verifying consistency between abstract domains in static analysis workflows.",
      "description_length": 411,
      "index": 354,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.WitnessUtil.Locator.LocM.Infix",
      "library": "goblint.lib",
      "description": "This module provides infix operators for manipulating located values within a monadic context. It supports operations to bind and retrieve values associated with keys in a located monad structure. Useful for threading location information through computations while accessing or updating key-value pairs.",
      "description_length": 304,
      "index": 355,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Base.MainFunctor.VarH.Labels",
      "library": "goblint.lib",
      "description": "This module provides operations for manipulating variable-labeled hashtables with keys of type `VarH.key` and values of a polymorphic type `'a`. It supports standard imperative and functional transformations such as `add`, `replace`, `map`, `filter`, `fold`, and `merge`, all operating directly on `VarH.t` tables. Concrete use cases include tracking and transforming variable bindings during static analysis, such as updating variable values, filtering out unused variables, or merging analysis results across program points.",
      "description_length": 526,
      "index": 356,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.YamlWitness.Make.FMap.Labels",
      "library": "goblint.lib",
      "description": "This module provides labeled functions for manipulating finite maps with key-based operations such as adding, replacing, modifying, and filtering entries. It supports data types involving `FMap.t` structures, enabling precise transformations and queries over key-value pairs. Concrete use cases include maintaining and transforming structured YAML witness data with labeled keys during validation or generation processes.",
      "description_length": 421,
      "index": 357,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.YamlWitness.Make.FMap.Infix",
      "library": "goblint.lib",
      "description": "This module provides infix operators `(-->)` and `(<--)` for accessing and modifying values in a functional map (`FMap.t`). The `(-->)` operator retrieves a value associated with a key, while `(<--)` updates the map with a new key-value pair. These operations are useful for concise, immutable map manipulations in witness generation or configuration handling workflows.",
      "description_length": 370,
      "index": 358,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Base.MainFunctor.VarH.Infix",
      "library": "goblint.lib",
      "description": "Implements variable access and assignment operations for variable maps. Provides the `-->` operator to retrieve values associated with a variable key and the `<--` operator to bind a value to a variable key in a mutable variable map. Useful for managing variable state in static analysis contexts where variables are mapped to analysis values.",
      "description_length": 343,
      "index": 359,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.PrecCompare.MakeDump.CompareDump.CompareD",
      "library": "goblint.lib",
      "description": "This module compares two domain instances for precision using a structured dumping mechanism. It evaluates and contrasts their internal states, producing a detailed document that highlights differences in precision. Use cases include analyzing the precision of abstract domains during static analysis or debugging domain implementations.",
      "description_length": 337,
      "index": 360,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.WitnessUtil.Locator.LocM.Exceptionless",
      "library": "goblint.lib",
      "description": "This module provides operations for safely querying and extracting values from a keyed map structure without raising exceptions. It supports functions to find a value by key, select any key-value pair, or retrieve an arbitrary binding, all returning optional results. These operations are useful when processing partial or conditional data mappings where absence of a key or value is expected and should be handled gracefully.",
      "description_length": 426,
      "index": 361,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Server.Locator.FileH.Exceptionless",
      "library": "goblint.lib",
      "description": "This module provides operations to safely locate and modify values associated with file handles in a server context. It works with file handle structures that map keys to values within a server session. Concrete use cases include updating or retrieving file-specific data during JSON-RPC interactions without raising exceptions, ensuring robust error handling.",
      "description_length": 360,
      "index": 362,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.PrecCompareUtil.Util.RH.Exceptionless",
      "library": "goblint.lib",
      "description": "This module provides safe lookup and modification operations for hash tables, returning optional values or result types instead of raising exceptions. It works with hash tables (`Hashtbl`) where keys and values can be of arbitrary types. Concrete use cases include safely retrieving values with `find` and applying in-place transformations with `modify`, handling missing keys gracefully in error-prone contexts.",
      "description_length": 412,
      "index": 363,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.BaseDomain.CPA.M.Group",
      "library": "goblint.lib",
      "description": "This module defines a data type `t` representing groups of variables in the context of base analysis. It provides a `compare` function for ordering these groups, which is essential for maintaining consistent and efficient data flow during static analysis. This structure is specifically used to manage variable groupings in constraint propagation algorithms.",
      "description_length": 358,
      "index": 364,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.CompareConstraints.CompareGlobal.Compare.CompareD",
      "library": "goblint.lib",
      "description": "This module defines a comparison function for global analysis constraints, specifically comparing two instances of `G.t` to determine their relationship (e.g., inclusion, equality, or inconsistency). It produces a comparison result paired with a structured document detailing the differences. This is used in static analysis to assess the precision and convergence of constraint states during fixed-point computations.",
      "description_length": 418,
      "index": 365,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Control.AnalyzeCFG.SpecSys.GHT",
      "library": "goblint.lib",
      "description": "This module implements imperative hash tables optimized for managing key-value pairs representing program variables and constraints, supporting efficient lookups, in-place updates, and conversions to sequences and lists. It includes operations for labeled argument handling, safe modification with optional returns, and infix syntax for heap-like state transitions, enabling precise control over temporary and persistent state changes. The labeled operations improve clarity when manipulating hash tables, while the safe lookup and modification functions prevent exceptions during constraint solving. Infix operators allow direct, path-sensitive updates to a global heap, facilitating state manipulation in static analysis workflows.",
      "description_length": 733,
      "index": 366,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.CompareConstraints.CompareGlobal.Compare.Var",
      "library": "goblint.lib",
      "description": "This module defines operations for comparing, identifying, and pretty-printing variable-like structures in a constraint system. It works with the `t` type, representing variables with associated metadata such as node location and write-only status. Concrete use cases include tracking variable identities across analyses, pretty-printing constraint traces, and generating stable string representations for serialization or debugging.",
      "description_length": 433,
      "index": 367,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MutexAnalysis.Spec.Arg.GProtected",
      "library": "goblint.lib",
      "description": "This module manages associations between mutexes and variables they protect, offering operations to create, compare, and query protection states with distinctions for read and write access. It employs a lattice structure (`t`) supporting static analysis tasks like merging and narrowing protection contexts, which is critical for tracking must-lockset and may-lockset relationships in concurrent programs. The design enables reasoning about variable access control under different locking disciplines during program analysis.",
      "description_length": 525,
      "index": 368,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.CompareConstraints.CompareGlobSys.PP.Infix",
      "library": "goblint.lib",
      "description": "This module defines infix operators for working with pretty-printing contexts, specifically `-->` for retrieving values by key and `<--` for binding values to keys within a `PP.t` context. It operates on `PP.t`, a type representing a pretty-printing environment, and uses `PP.key` as identifiers for values in that environment. These operators simplify the manipulation of contextual data during pretty-printing tasks, such as formatting complex data structures or managing indentation levels.",
      "description_length": 493,
      "index": 369,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.ThreadId.Spec.Created.Callees",
      "library": "goblint.lib",
      "description": "The module provides lattice-based operations (join, meet, widen, narrow) for analyzing hierarchical thread identifiers alongside utilities for comparison, hashing, and serialization (XML, Yojson). It operates on thread ID abstractions (`t = TD.t`) and analysis context data to model concurrency relationships and track thread state hierarchies. These capabilities support static analysis tasks like merging divergent thread contexts and determining subsumption in concurrent program analysis.",
      "description_length": 492,
      "index": 370,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MallocFresh.Spec.C",
      "library": "goblint.lib",
      "description": "This module defines lattice operations (join, meet, widen, narrow) and equality predicates for an abstract type representing unescaped heap allocations, enabling static analysis of memory properties in concurrent programs. It supports merging analysis states, determining value subsumption, and generating symbolic representations of thread-local heap locations. The type models allocation sites with domain-specific extremal elements (top/bot) to approximate memory behaviors during abstract interpretation.",
      "description_length": 508,
      "index": 371,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.WrapperFunctionAnalysis.MallocWrapper.V",
      "library": "goblint.lib",
      "description": "This module defines a data type `t` representing symbolic heap locations for dynamic memory allocations, with operations to compare, hash, display, and serialize these locations. It supports precise tracking of memory by associating each location with a unique ID and node/thread context. Concrete use cases include modeling `malloc`-allocated memory in static analysis to distinguish between different allocation sites and contexts.",
      "description_length": 433,
      "index": 372,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Constants.Spec.C",
      "library": "goblint.lib",
      "description": "This module represents constant values for local variables in an intraprocedural analysis. It supports operations for equality checking, hashing, comparison, and pretty-printing of constants, along with serialization to XML and JSON. It is used to track and manipulate definite integer constant values within a single function scope during static analysis.",
      "description_length": 356,
      "index": 373,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Constants.Spec.A",
      "library": "goblint.lib",
      "description": "This module defines a specification for analyzing definite integer constant values of local variables within a single procedure. It provides operations for equality checking, hashing, comparison, and pretty-printing of constant values, along with utilities for serialization, arbitrary value generation, and race detection. Concrete use cases include tracking local variable constants during intraprocedural analysis and identifying potential race conditions between constant values.",
      "description_length": 483,
      "index": 374,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.AccessAnalysis.Spec.V",
      "library": "goblint.lib",
      "description": "This module provides operations for representing and manipulating control flow graph (CFG) nodes as a variant type encompassing statements and functions, with support for comparison, serialization, and metadata extraction (e.g., location, identifiers). It includes functions to retrieve associated function definitions, resolve nodes by unique identifiers, and determine node-specific properties like write-only status, operating on analysis nodes and function definitions. These capabilities enable static analysis tasks such as memory access tracking, CFG visualization, and structured data serialization for analysis results.",
      "description_length": 628,
      "index": 375,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.SpecLifters.LevelSliceLifter.V",
      "library": "goblint.lib",
      "description": "This module defines operations for managing and comparing globally constrained variables, including equality, hashing, comparison, and pretty-printing. It works with a concrete type `t` representing constraint variables, each identified by a unique tag. These operations support tracking and analyzing variables in static analysis, particularly for handling slices and constraints during program analysis.",
      "description_length": 405,
      "index": 376,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.WitnessUtil.Locator.ES",
      "library": "goblint.lib",
      "description": "This module manages ordered sets of comparable elements, enabling efficient membership checks, set operations like union and intersection, and ordered traversal. It supports data types `ES.t` for sets and `ES.elt` for elements, with core operations to manipulate extremal values, convert between collections, and maintain ordering. Child modules extend functionality by providing safe element retrieval through optional values and enabling iteration, mapping, and filtering over sets. Example uses include tracking program states with ordered invariants, selecting representative elements from sets without exceptions, and filtering element subsets during witness generation.",
      "description_length": 675,
      "index": 377,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MemLeak.Spec.D",
      "library": "goblint.lib",
      "description": "This module defines a lattice-based abstract domain for analyzing memory leak states, featuring operations like `join`, `meet`, `widen`, and `narrow` to combine or compare abstract memory states, along with `top` and `is_top` to identify and verify extremal states in the lattice hierarchy. It operates on a type `t` representing abstract memory leak information, enabling tasks such as merging analysis paths, detecting unbounded memory growth, and debugging via serialization (XML/JSON), pretty-printing, and arbitrary value generation.",
      "description_length": 538,
      "index": 378,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MutexTypeAnalysis.Spec.P",
      "library": "goblint.lib",
      "description": "This module defines operations for managing and comparing path-representative constraint variables used in mutex type analysis. It provides equality checks, hashing, ordering, and string/XML/JSON representations for these variables, which are essential for tracking and resolving global constraints during analysis. The module supports concrete use cases like constraint solving, path merging, and witness generation in static analysis of concurrent programs.",
      "description_length": 459,
      "index": 379,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.StackTrace.Spec1.A",
      "library": "goblint.lib",
      "description": "This module provides operations for handling unit values with comparison, equality, and hashing functions. It includes utilities for pretty-printing, serialization to JSON, and generating arbitrary values for testing. Concrete use cases involve representing empty or singleton states in stack trace analyses where no additional data is required.",
      "description_length": 345,
      "index": 380,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.WideningTokenLifter.Lifter.D",
      "library": "goblint.lib",
      "description": "This module provides lattice operations including equality, ordering, join, meet, widening, and narrowing for an abstract domain with embedded widening tokens. It handles top value creation and checks while enabling delayed convergence in static analysis by tracking token set dynamics during iterations. The operations act on abstract elements of type `D.t`, which carry both local and global token states to control widening behavior based on token stabilization.",
      "description_length": 465,
      "index": 381,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Svcomp.StackTaskResult.Arg",
      "library": "goblint.lib",
      "description": "This module models control flow graphs for SV-COMP tasks, representing program locations as nodes and transitions as edges. It provides direct access to the main entry node and enumerates outgoing transitions, pairing edges with target nodes for path analysis and property verification. The Edge submodule enriches CFG edges with task-specific data and string formatting, while the Node submodule offers equality, comparison, and accessors for node attributes like CFG references and context identifiers. Together, they enable precise traversal, comparison, and display of control flow structures in static analysis workflows.",
      "description_length": 626,
      "index": 382,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.WitnessConstraints.PathSensitive3.D",
      "library": "goblint.lib",
      "description": "This module provides lattice operations (join, meet, widen, narrow, top, bot) and comparison utilities for an abstract domain `D.t` used in path-sensitive static analysis. It supports tasks like abstract reachability graph construction by enabling precise representation and manipulation of abstract values across different program paths, with functionality to explain differences between lattice elements during analysis refinement.",
      "description_length": 433,
      "index": 383,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ThreadFlag.Spec.C",
      "library": "goblint.lib",
      "description": "This module provides lattice operations (leq, join, meet, widen, narrow) and domain-specific primitives for modeling thread flag states in concurrent program analysis. It operates on a type `t` (aliased from `D.t`) representing abstract thread flag values, including bottom and top elements, with support for serialization (XML/JSON), comparison, and arbitrary value generation. These capabilities enable static analysis of multi-threaded programs by formalizing thread safety properties within abstract interpretation frameworks.",
      "description_length": 530,
      "index": 384,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MayLocks.Spec.C",
      "library": "goblint.lib",
      "description": "Implements lattice-based abstract domains for tracking may-lock states in concurrent program analysis, providing operations like join, meet, widen, and narrowing to model lockset approximations. The type `t` (aliased from `Goblint_lib.MayLocks.Spec.D.t`) represents abstract lock states with support for comparison, pretty-printing, and serialization to enable static analysis of double-locking and synchronization errors. Designed for use in abstract interpretation frameworks to verify thread safety and detect concurrency bugs through lattice-based approximations of lock acquisition patterns.",
      "description_length": 596,
      "index": 385,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.PthreadSignals.Spec.D",
      "library": "goblint.lib",
      "description": "This module provides lattice-theoretic operations for an abstract domain modeling signal propagation states in concurrent programs, specifically tracking possible and definite signal receptions on Pthread condition variables. It defines join/meet operations, top element checks, and difference visualization to support dataflow analysis, enabling static analysis tools to reason about signal interactions between threads. The domain's serialization and arbitrary value generation capabilities facilitate testing and integration into abstract interpretation frameworks analyzing synchronization behavior.",
      "description_length": 603,
      "index": 386,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ThreadId.Spec.C",
      "library": "goblint.lib",
      "description": "This module defines a lattice structure for thread identifiers with operations supporting abstract interpretation in concurrent program analysis. It works with an abstract type `t` representing thread IDs, enabling modeling of thread interactions and synchronization through lattice operations like join, meet, and ordering relations. The lattice's top value signifies unknown or non-deterministic thread contexts, while serialization and QCheck utilities aid in analysis debugging and testing of concurrent systems.",
      "description_length": 516,
      "index": 387,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ExtractPthread.Spec.D",
      "library": "goblint.lib",
      "description": "This module provides lattice operations (join, meet, widen, narrow) and domain-specific abstractions for static analysis of concurrent systems, focusing on abstract state representation. It works with a tagged lattice type `t` supporting equality, hashing, and serialization, along with arbitrary value generation for testing. The design enables context-sensitive analysis in frameworks requiring precise handling of abstract domains, such as thread state tracking or synchronization property inference.",
      "description_length": 503,
      "index": 388,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MayLocks.Spec.A",
      "library": "goblint.lib",
      "description": "This module defines operations for analyzing may locksets in a concurrent program, including equality, comparison, and hashing for tracking lock states. It provides functions to check potential race conditions between lock states and determine if a state should be printed. Concrete use cases include detecting double locking and analyzing possible concurrency violations in static analysis.",
      "description_length": 391,
      "index": 389,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Region.Spec.A",
      "library": "goblint.lib",
      "description": "This module defines operations for analyzing and comparing optional heap regions, including equality, comparison, and hashing functions. It supports data race detection by determining whether two regions may concurrently access shared memory. Key functions include `may_race` for race condition checks and `pretty` for readable output of region information.",
      "description_length": 357,
      "index": 390,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.CommonPriv.MutexGlobals.VGlobal",
      "library": "goblint.lib",
      "description": "This module represents global variables used in thread-modular analysis of mutex-protected data. It provides operations for equality checking, hashing, comparison, and pretty-printing of variable identifiers, along with serialization to formats like XML and JSON. It supports generating arbitrary values for testing and extracting unique identifiers for witness generation.",
      "description_length": 373,
      "index": 391,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Taint.Spec.G",
      "library": "goblint.lib",
      "description": "This module implements core lattice operations for taint analysis, including join, meet, widen, and narrowing, alongside utilities for equality checks, hashing, and serialization formats like XML/JSON. It operates on an abstract lattice type `t` designed to model taint states, enabling static analysis of data flow in programs\u2014particularly useful for security-sensitive scenarios like detecting injection vulnerabilities. The inclusion of top/bottom elements and differencing mechanisms also supports educational use in demonstrating abstract interpretation principles for static program analysis.",
      "description_length": 598,
      "index": 392,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ResultQuery.NH.Labels",
      "library": "goblint.lib",
      "description": "This module implements a hash table for storing and manipulating key-value pairs where keys are of type `Goblint_lib.ResultQuery.NH.key` and values are arbitrary. It supports operations like insertion, modification, iteration, filtering, and merging, all centered around per-key processing with direct or function-based updates. Concrete use cases include tracking analysis results per program point or variable during static analysis, efficiently updating and querying constraint solution data.",
      "description_length": 495,
      "index": 393,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ExtractPthread.Codegen.PmlResTbl",
      "library": "goblint.lib",
      "description": "This module manages mappings between resources, thread names, and unique identifiers used for edge labeling in Promela extraction. It generates deterministic string identifiers by combining resource types and thread names, supporting operations to register, retrieve, and translate keys into prefixed labels. The module includes a bidirectional table for function names and integer IDs, enabling stable numeric identification of functions during model checking. Example usage includes converting a function name to an ID for edge labels or reconstructing thread-specific resource identifiers from raw keys.",
      "description_length": 606,
      "index": 394,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Taint.Spec.A",
      "library": "goblint.lib",
      "description": "This module defines a taint analysis specification with operations for comparing, hashing, and displaying taint values. It supports concrete use cases such as tracking data flow in interprocedural analysis, identifying context-specific taints via unique tags, and generating output for race detection. The module works directly with a custom type `t` and integrates with serialization formats like XML, Pretty, and Yojson for logging and debugging.",
      "description_length": 448,
      "index": 395,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.UnassumeAnalysis.Spec.D",
      "library": "goblint.lib",
      "description": "This module provides lattice and set-theoretic operations for managing collections of CIL expressions, supporting static analysis tasks like invariant tracking and unassume event generation. It works with abstract sets of `CilType.Exp.t` values, offering operations such as union, intersection, subset checks, and lattice joins/meets to model program state transformations. Specific use cases include analyzing expression invariants from YAML witnesses and emitting unassume directives during abstract interpretation, with utilities for serialization and integration into analysis frameworks.",
      "description_length": 592,
      "index": 396,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ExtractPthread.Tbls.TblGen",
      "library": "goblint.lib",
      "description": "Implements generic hash tables with keys of type `k` and values of type `v`. Provides operations for creating, querying, and modifying tables, including `find`, `add`, and `remove`. Useful for tracking variable mappings or state during Pthread program analysis.",
      "description_length": 261,
      "index": 397,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Queries.Hashtbl.Labels",
      "library": "goblint.lib",
      "description": "This module provides operations for manipulating hash tables with labeled keys, including adding, replacing, modifying, and removing entries. It supports functions for mapping, filtering, folding, and merging hash tables based on both keys and values, with both in-place and non-destructive variants. These operations are used for efficiently managing and transforming collections of query results indexed by keys in analysis tools.",
      "description_length": 432,
      "index": 398,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.LongjmpLifter.Lifter.D",
      "library": "goblint.lib",
      "description": "This module supports lattice-theoretic operations like join, meet, widen, and narrow over an abstract domain representing program states during static analysis of longjmp/setjmp contexts. It works with abstract values of type `t` that encode possible runtime behaviors, including extremal elements like bottom and top for uninitialized or unconstrained states. These operations enable merging divergent execution paths, checking state relationships, and generating test values to validate analysis precision in scenarios involving non-local control flow.",
      "description_length": 554,
      "index": 399,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.VarEq.Spec.C",
      "library": "goblint.lib",
      "description": "This module implements lattice and type operations for symbolic expression equality analysis, working with a lattice-structured type `t` that supports comparison, hashing, and serialization. It provides core functionalities like `join`, `meet`, `widen`, and `narrow` to manipulate abstract values, alongside `top` and `is_top` for lattice extremal checks. These operations enable static analysis of variable equalities in programs through abstract interpretation, particularly for tracking symbolic relationships between expressions.",
      "description_length": 533,
      "index": 400,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.CommonPriv.PerMutexTidCommon.LLock",
      "library": "goblint.lib",
      "description": "This module defines a polymorphic sum type for representing either a must-lock analysis result or a variable identifier, with operations for comparison, hashing, pretty-printing, and serialization. It supports concrete use cases such as tracking lock states and variable references in thread-modular analysis. Functions like `mutex` and `global` allow constructing values of the type, while `relift` enables subtyping between labeled variants.",
      "description_length": 443,
      "index": 401,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.SpecLifters.HashconsLifter.V",
      "library": "goblint.lib",
      "description": "This module provides operations for managing hash-consed constraint variables with globally unique identifiers. It supports equality checks, hashing, comparison, and pretty-printing, along with serialization to XML and Yojson. Concrete use cases include tracking and identifying constraint variables in analysis contexts where uniqueness and efficient representation are critical.",
      "description_length": 380,
      "index": 402,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.LocksetAnalysis.Make.C",
      "library": "goblint.lib",
      "description": "This module supports lattice-based abstract interpretation for concurrency analysis by providing operations to manipulate lockset domains, including comparison, combination (`join`, `meet`), and approximation (`widen`, `narrow`) of lock states. It works with abstract lockset values (`C.t`) that track sets of locks held during program execution, structured as a lattice with distinguished bottom and top elements to represent extreme states. These capabilities are used to detect concurrency issues like deadlocks or race conditions by statically modeling lock acquisition and release patterns in multithreaded programs.",
      "description_length": 621,
      "index": 403,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.ThreadReturn.Spec.A",
      "library": "goblint.lib",
      "description": "This module defines operations for a thread return analysis, including equality, hashing, comparison, and serialization functions for its abstract type `t`. It supports reasoning about thread call stack states by determining whether values may race and whether they should be printed in race output. The module is used to track and compare thread return states during static analysis of concurrent programs.",
      "description_length": 407,
      "index": 404,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MayLocks.Arg.G",
      "library": "goblint.lib",
      "description": "This module provides lattice operations and utilities for analyzing may-lock states, which model sets of locks that could be concurrently held during program execution. It supports key operations like join, meet, widening, and context-sensitive lifting to track lock acquisition patterns and detect concurrency issues such as double locking. The abstract type `t` represents these lock states, enabling static analysis of multithreaded programs to reason about possible lock dependencies across different program contexts.",
      "description_length": 522,
      "index": 405,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Control.AnalyzeCFG.RT",
      "library": "goblint.lib",
      "description": "This module implements analysis of control flow graphs (CFGs) for abstract interpretation by solving constraints derived from program paths. It operates on tuples containing constraint and data specifications along with CIL function declarations, enabling precise interprocedural analysis of C programs. Key operations include comparison, hashing, pretty-printing, and XML output for analysis results, supporting concrete use cases like value analysis and pointer tracking.",
      "description_length": 473,
      "index": 406,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.YamlWitnessType.ViolationSequence.Waypoint",
      "library": "goblint.lib",
      "description": "This module defines operations for handling waypoints in a violation sequence within a YAML witness format. It supports converting waypoint data to and from YAML representations and comparing waypoint values. The module works specifically with waypoint type records that include a `waypoint_type` field of a predefined waypoint type.",
      "description_length": 333,
      "index": 407,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.CommonPriv.PerMutexTidCommon.L",
      "library": "goblint.lib",
      "description": "This module provides dictionary operations for managing key-value associations between locks and abstract values, lattice-theoretic combinators for merging and comparing these structures, and utilities for serialization, pretty-printing, and analysis-specific transformations. It operates on finite maps with lock-identified keys and parametrized value domains, supporting both container-style manipulations and domain-specific algebraic operations like widening/narrowing. The design targets thread-modular static analysis scenarios where per-lock state must be combined, filtered, or lifted through abstract domains with bottom/top elements.",
      "description_length": 643,
      "index": 408,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Base.MainFunctor.VarMap",
      "library": "goblint.lib",
      "description": "This module organizes variable maps around `CilType.Varinfo.t` keys, supporting standard and specialized operations for static analysis, including insertion, lookup, predicate-based extraction, and in-place updates. It enables transformations, filtering, and bidirectional conversion with lists, seqs, and enums, while submodules provide infix operators for concise access and modification, labeled maps for structured variable environments, and exceptionless queries for safe value retrieval. Specific uses include tracking variable states, managing per-variable metadata, and handling data-flow computations in BAP-based analyses. Together, the module and its submodules offer a cohesive toolkit for efficient, expressive manipulation of variable-keyed data in both functional and imperative styles.",
      "description_length": 801,
      "index": 409,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.ObserverAnalysis.MakeSpec.G",
      "library": "goblint.lib",
      "description": "This module provides lattice operations for comparison, display, and lattice theory (e.g., `leq`, `join`, `meet`, `widen`, `narrow`, `bot`, `top`) on the abstract domain type `G.t`. It supports dataflow analysis in abstract interpretation by enabling precise state tracking across program paths, particularly for path-sensitive analysis using extremal values like `top` and `bot` to represent lattice bounds. The type `G.t` is structured to facilitate static analysis of program properties through operations that align with theoretical lattice requirements.",
      "description_length": 558,
      "index": 410,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ExtractPthread.Codegen.Action",
      "library": "goblint.lib",
      "description": "This module defines actions representing low-level concurrency operations like thread creation, mutex manipulation, and condition variable signaling, using structured types such as `thread`, `cond_wait`, and `fun_call_id`. It includes functions to extract thread creation details and convert actions to Promela code. Concrete use cases involve translating pthread-based CIL code into Promela for model checking.",
      "description_length": 411,
      "index": 411,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ExtractPthread.Tbls.SymTblGen",
      "library": "goblint.lib",
      "description": "Generates symbol tables for Pthread analysis with operations to create and manage key-value mappings. It works with hash tables that bind keys of type `k` to values of type `v`. Used to track symbol associations during Promela extraction, such as mapping thread identifiers to their corresponding control states.",
      "description_length": 312,
      "index": 412,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.PthreadSignals.Spec.P",
      "library": "goblint.lib",
      "description": "This module defines a path-representative type `t` used to track unique identifiers for context-sensitive analysis in concurrent programs. It provides equality checks, hashing, comparison, and serialization operations for this type, enabling efficient set and map manipulations. These operations are essential for managing path-sensitive constraints during static analysis of pthread signal interactions.",
      "description_length": 404,
      "index": 413,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Control.AnalyzeCFG.Slvr",
      "library": "goblint.lib",
      "description": "This module implements a constraint solver for static analysis of C programs, combining variable and constraint manipulation with control flow graph traversal to compute fixed points for path-sensitive analyses. It defines labeled and global variables with domains and constraints, supporting operations like join, meet, widening, and narrowing over lifted lattices, along with value comparison, serialization, and pretty-printing. Child modules extend the solver with state management, imperative variable handling, solution splitting, and analysis resumption, enabling tasks such as constant propagation, reaching definitions, and merging path-sensitive states. Specific capabilities include solving interdependent constraints from CFG nodes, tracking variable equality and ordering, and extracting partitioned analysis results for efficient abstract interpretation.",
      "description_length": 868,
      "index": 414,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Queries.Hashtbl.Infix",
      "library": "goblint.lib",
      "description": "This module extends hashtables with operations to query and update bindings using the `-->` and `<--` operators. It works with hashtables where keys conform to the `Queries.Hashtbl.key` type and values can be of any type. Concrete use cases include efficiently retrieving or inserting query results in a lattice-aware context.",
      "description_length": 326,
      "index": 415,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Taint.Spec.V",
      "library": "goblint.lib",
      "description": "This module defines operations for managing and comparing globally constrained taint variables, including equality, hashing, comparison, and pretty-printing. It works with a concrete type `t` representing taint variables, each assigned a unique ID for context identification. These functions support precise tracking and differentiation of taint sources in interprocedural analysis, particularly for generating analysis witnesses.",
      "description_length": 430,
      "index": 416,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ResultQuery.Make.FileCfg",
      "library": "goblint.lib",
      "description": "This module implements queries over the control flow graph (CFG) of a single file, enabling traversal and analysis of CFG nodes and edges through operations like retrieving predecessors, successors, and path conditions. It supports precise mapping between CFG nodes and the original source code by tracking skipped statements during CFG creation, allowing retrieval of skipped AST statements between nodes. Key data types include CFG nodes and edges, with operations to analyze control flow relationships and extract source code correspondence. For example, it can identify the sequence of statements skipped between two CFG nodes or determine the path conditions leading to a specific node.",
      "description_length": 691,
      "index": 417,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.WrapperFunctionAnalysis.SpecBase.D",
      "library": "goblint.lib",
      "description": "This module combines node-based flat lattices with unique call counters to model symbolic execution states, offering lattice operations (join, meet, widen, etc.) and serialization tools for XML, JSON, and pretty-printing. It operates on tuples of `NodeFlatLattice.t` and `UniqueCallCounter.t`, supporting tasks like comparing analysis results, generating test cases, and formatting output differences in wrapper function analyses.",
      "description_length": 430,
      "index": 418,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.CommonPriv.ConfCheck.RequireMutexPathSensOneMainInit",
      "library": "goblint.lib",
      "description": "This module enforces path-sensitive mutex usage checks during initialization in a thread-modular analysis. It ensures that mutex operations follow a single main initialization path, preventing inconsistent or unsafe access patterns. It works with abstract execution paths and mutex state tracking structures to validate correct locking behavior in concurrent code.",
      "description_length": 364,
      "index": 419,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Analyses.GVarG.CSet",
      "library": "goblint.lib",
      "description": "This module provides lattice and set operations for an abstract constraint set type, enabling manipulation of variable or constraint collections in static analysis. It supports core set functionality like membership, union, intersection, and transformation with lattice-theoretic extensions such as widening/narrowing for fixed-point computation. Designed for constraint system solving in abstract interpretation, it handles tasks like variable dependency tracking and constraint propagation in program analysis.",
      "description_length": 512,
      "index": 420,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Uninit.Spec.C",
      "library": "goblint.lib",
      "description": "This module provides lattice operations (join, meet, widen, narrow) and type-class functionalities (equal, hash, show) for an abstract type `t` representing uninitialized variable states in static analysis. It includes top and bottom lattice elements to model extremal initialization states, enabling checks to determine whether variables are uninitialized or fully initialized. These operations are specifically used in Goblint's analysis of local variable initialization to track and reason about uninitialized values during program execution.",
      "description_length": 545,
      "index": 421,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ExtractPthread.Tbls.ThreadTidTbl",
      "library": "goblint.lib",
      "description": "This module provides a thread-local storage mechanism mapping thread names to thread IDs using a hash table. It supports operations to retrieve thread IDs by name, find thread names by ID, and list all thread mappings. It is used to track and identify threads during Promela extraction for Pthread programs.",
      "description_length": 307,
      "index": 422,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MemLeak.Spec.C",
      "library": "goblint.lib",
      "description": "This module defines operations for managing and comparing memory leak analysis contexts, including equality, hashing, comparison, and pretty-printing functions. It works with the abstract type `t` representing memory leak contexts, supporting serialization to JSON and XML, and generating arbitrary values for testing. Concrete use cases include tracking unique context identifiers for witness generation and enabling efficient context comparison during analysis.",
      "description_length": 463,
      "index": 423,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Constants.Spec.G",
      "library": "goblint.lib",
      "description": "This module provides lattice-based abstract domain operations for tracking constant values of local variables in static analysis. It defines a type `t` representing abstract variable states with standard lattice operations (`join`, `meet`, `widen`, `narrow`, `leq`) and structural utilities like serialization, comparison, and arbitrary value generation. It is specifically used in intraprocedural analyses to infer definite integer constants without propagating information across function boundaries.",
      "description_length": 502,
      "index": 424,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.LocksetAnalysis.MakeMay.A",
      "library": "goblint.lib",
      "description": "Implements a may-lockset analysis for concurrency-related operations, determining potential lock dependencies between units of code. It works with abstract lock identifiers and provides predicates to check for possible race conditions and printing capabilities for debugging. Useful in static analysis tools to detect concurrency issues in programs with shared memory access.",
      "description_length": 375,
      "index": 425,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.WrapperFunctionAnalysis.ThreadCreateWrapper.P",
      "library": "goblint.lib",
      "description": "This module defines a path-representative type `t` with operations for equality, hashing, comparison, and pretty-printing. It works with symbolic thread identifiers derived from analysis nodes, providing unique tags for context identification. Used to track and distinguish thread creation events in static analysis, enabling precise reasoning about thread-local state and interleavings.",
      "description_length": 387,
      "index": 426,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.YamlWitness.Make.WitnessInvariant",
      "library": "goblint.lib",
      "description": "This module tracks and identifies loop heads and invariant locations in the control flow graph for YAML witness generation. It provides functions to determine if a node is a loop head, after a lock, or part of an invariant, using node and location data. Concrete use cases include filtering nodes for witness emission and validating loop structure during analysis.",
      "description_length": 364,
      "index": 427,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.YamlWitness.Make.FMap",
      "library": "goblint.lib",
      "description": "This module manages finite maps keyed by function declarations, enabling imperative updates, safe access, and functional transformations over associated data. It supports core operations like insertion, deletion, and in-place modification, along with traversal via sequences and lists, used to process YAML witness data during verification. Submodules extend its capabilities with exception-safe access for string keys, labeled key-based manipulations, and infix syntax for functional updates, enabling precise and concise handling of structured analysis results. Examples include validating and transforming function-specific witness data using safe lookups, labeled operations, or infix syntax for immutable modifications.",
      "description_length": 724,
      "index": 428,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Server.Locator.FileH",
      "library": "goblint.lib",
      "description": "This module implements a file-aware hash table for managing polymorphic key-value associations with specialized string keys, enabling efficient insertion, lookup, deletion, and transformation through in-place and functional operations. It supports conversions to and from sequences, lists, and enumerations, while submodules provide typed access via infix operators, labeled data management for source files, and safe, non-raising operations for JSON-RPC interactions. Use it to track file metadata, annotate code with analysis results, or manage file-specific state in an interactive server. Direct APIs handle core hash table operations, while child modules specialize in file-based key access, labeled data transformations, and robust value manipulation during server sessions.",
      "description_length": 780,
      "index": 429,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Expsplit.Spec.P",
      "library": "goblint.lib",
      "description": "This module defines and manipulates path representatives for a path-sensitive analysis, uniquely identifying them with tags and providing equality, comparison, and serialization operations. It works with a concrete type `t` representing paths, derived from constraint variables and used in witness generation. Use cases include tracking distinct execution paths during static analysis and enabling precise context-sensitive reasoning over program expressions.",
      "description_length": 459,
      "index": 430,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.PrivPrecCompareUtil.Util.RH",
      "library": "goblint.lib",
      "description": "This module provides a hash table structure for key-value associations with polymorphic values, supporting imperative updates and functional transformations. It includes operations for conditional traversal, mapping, filtering, merging, in-place modifications, and conversion to sequences, along with utilities for statistics and pretty-printing. The child modules enhance this functionality: one introduces key-value interaction operators used in static analysis for managing precision settings, another extends standard hash table manipulations with imperative and higher-order functions, and the third enables safe, error-aware modifications of mapped values. Together, they allow tasks like tracking analysis state, transforming resource data, and propagating update errors without exceptions.",
      "description_length": 797,
      "index": 431,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.WrapperFunctionAnalysis.MallocWrapper.C",
      "library": "goblint.lib",
      "description": "This module implements a symbolic heap location analysis for dynamic memory allocations, generating unique identifiers based on node and thread context. It supports operations like equality checking, hashing, comparison, and pretty-printing for its symbolic heap location values. Used to track memory allocations from `malloc` and similar functions with precision across different execution contexts.",
      "description_length": 400,
      "index": 432,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.SpecLifters.PathSensitive2.D",
      "library": "goblint.lib",
      "description": "This module provides lattice operations for path-sensitive abstract interpretation, including join, meet, widen, and narrow, which manipulate values of type `D.t` combined with unique context tags to track analysis states. It supports advanced dataflow analyses by enabling precise value comparisons and transformations across different execution paths, while utilities for serialization and pretty-printing facilitate debugging and integration with analysis frameworks. The lattice semantics align with abstract interpretation principles, making it suitable for scenarios requiring context-sensitive reasoning and state merging.",
      "description_length": 629,
      "index": 433,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.WrapperFunctionAnalysis.ThreadCreateWrapper.G",
      "library": "goblint.lib",
      "description": "This analysis component implements lattice operations for symbolic thread identifiers derived from program nodes, enabling precise tracking of thread creation contexts in static analysis. It manipulates abstract values of type `t` that represent symbolic thread IDs, supporting comparisons, hashing, and lattice transformations like join and widen. These capabilities are specifically used to model thread creation events and their relationships in concurrent programs, with a dedicated top element to represent unknown or initial thread states.",
      "description_length": 545,
      "index": 434,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.CondVars.Spec.C",
      "library": "goblint.lib",
      "description": "This module type defines lattice operations (`join`, `meet`, `widen`, `narrow`, `bot`, `top`) and value manipulation utilities (`equal`, `hash`, `compare`, `show`, serialization) for an abstract type `t` representing symbolic variable equalities and logical expressions. It supports static analysis tasks by enabling precise modeling of variable relationships and constraint simplification, particularly useful for program optimization and verification scenarios where tracking equivalence classes or logical invariants is required. The inclusion of top/bottom checks and XML/JSON serialization facilitates integration with analysis frameworks and visualization tools.",
      "description_length": 668,
      "index": 435,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.RaceAnalysis.Spec.MemoSet",
      "library": "goblint.lib",
      "description": "This module provides set operations (union, intersection, membership checks) and lattice operations (join, meet, leq) for managing collections of memory location descriptors (memos) that encode access paths with roots (variables or types) and offsets. It supports data race analysis by organizing these memos in trie-based structures to efficiently handle hierarchical relationships\u2014such as prefix/suffix overlaps in struct fields or type-based accesses\u2014during postsolving. The sets track access patterns to enable precise race detection, ensuring combinations of accesses to nested or type-compatible locations are checked without redundant analysis.",
      "description_length": 651,
      "index": 436,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ObserverAnalysis.MakePathSpec.P",
      "library": "goblint.lib",
      "description": "This module defines a path-representative type `t` with operations for equality, hashing, comparison, and serialization. It works with path-sensitive analysis data, providing unique identification via `tag` and projection from analysis elements using `of_elt`. Concrete use cases include tracking execution paths in a constraint system and generating unique context identifiers for witness extraction.",
      "description_length": 401,
      "index": 437,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.YamlWitnessType.InvariantSet.Invariant",
      "library": "goblint.lib",
      "description": "This module defines and manipulates invariant records used to represent specific constraints within a YAML-based witness format. It includes functions for comparing invariants, converting them to and from YAML structures. It is used to serialize and deserialize invariant data for external analysis tools or verification processes.",
      "description_length": 331,
      "index": 438,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ThreadFlag.Spec.P",
      "library": "goblint.lib",
      "description": "This module provides lattice operations (join, meet, widen, narrow) and manipulation primitives (e.g., creating top elements, identity conversion) for a thread flag specification type. It operates on an abstract representation of thread states in concurrent programs, enabling static analysis of multi-threaded code through abstract interpretation. Key use cases include tracking synchronization points, determining possible execution paths, and analyzing state transitions in parallel contexts.",
      "description_length": 495,
      "index": 439,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.LoopfreeCallstring.Spec.P",
      "library": "goblint.lib",
      "description": "This module defines path-representative values for loop-free call strings, where each path is represented by a sequence of function calls with cycles collapsed into sets. It provides operations for equality checking, hashing, comparison, and string/XML/JSON representation of these path-representatives. Concrete use cases include tracking unique calling contexts in static analysis to reduce state explosion caused by recursive or cyclic call patterns.",
      "description_length": 453,
      "index": 440,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Expsplit.Spec.D",
      "library": "goblint.lib",
      "description": "This module provides standard lattice operations (join, meet, widen, narrow), value comparisons (equal, compare), and serialization methods (show, to_yojson) for an abstract data type 't'. It is designed for lattice-based abstract interpretation in static analysis, enabling representation of extremal states via top and bottom elements and supporting path-sensitive value tracking through precise combination and transformation of abstract values.",
      "description_length": 448,
      "index": 441,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.RaceAnalysis.Spec.V",
      "library": "goblint.lib",
      "description": "This module defines a polymorphic variant type `t` that represents either a memory root (`Left`) or a variable info (`Right`), primarily used to distinguish between different kinds of memory access origins in data race analysis. It provides comparison, hashing, pretty-printing, and serialization functions for this type, enabling efficient set operations and integration with analysis infrastructures. Concrete use cases include tracking and differentiating between global variable accesses and type-based memory locations during race analysis.",
      "description_length": 545,
      "index": 442,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Control.AnalyzeCFG.SpecSys",
      "library": "goblint.lib",
      "description": "This module manages constraint systems and state mappings for abstract interpretation, using lattice and global variables to compute fixed points through dependency resolution. It provides hash table extensions with labeled, exception-safe operations and infix syntax for efficient key-value manipulation, supporting transformations, filtering, and hierarchical state updates. You can use it to build and iterate constraint systems, merge and modify labeled state mappings, and perform path-sensitive heap updates using infix operators like `-->` and `<--`. Specific examples include resolving variable equalities during analysis, safely updating constraint environments, and managing program state transitions with labeled imperative tables.",
      "description_length": 742,
      "index": 443,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.WrapperFunctionAnalysis.MallocWrapper.A",
      "library": "goblint.lib",
      "description": "This module defines a data type `t` representing symbolic heap locations for dynamic memory allocations, with operations to compare, hash, and display these locations. It provides precision through unique identifiers tied to nodes and threads, supporting analysis of memory allocation behavior in concurrent contexts. Concrete use cases include tracking distinct heap allocations across program points and identifying potential memory races based on symbolic location comparisons.",
      "description_length": 480,
      "index": 444,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Expsplit.Spec.V",
      "library": "goblint.lib",
      "description": "This module defines and manipulates constraint variables used in path-sensitive analysis, specifically handling operations like equality checks, hashing, comparison, and pretty-printing. It works with a concrete type `t` representing constraint variables, each associated with a unique ID and name for identification and serialization. These variables are used to track and differentiate contexts in analyses that split based on expression values.",
      "description_length": 447,
      "index": 445,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.LoopTermination.Spec.A",
      "library": "goblint.lib",
      "description": "This module defines and manipulates a specific type `t` used in loop termination analysis, providing operations for equality checking, hashing, comparison, and string representation. It includes functions for pretty printing, XML serialization, and JSON conversion, along with utilities for generating arbitrary values and handling race conditions. Concrete use cases include tracking loop termination states, comparing analysis results, and generating human-readable or machine-processable outputs for diagnostics and witness generation.",
      "description_length": 538,
      "index": 446,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ObserverAnalysis.MakeSpec.A",
      "library": "goblint.lib",
      "description": "Implements analysis specifications for path-sensitive observer automata, defining operations for comparing, hashing, and visualizing states. Works with the abstract state type `t`, supporting serialization, pretty-printing, and race detection checks. Used to define analysis behavior in concurrency-related verification scenarios, such as tracking shared memory accesses and generating witness outputs.",
      "description_length": 402,
      "index": 447,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ObserverAnalysis.MakeSpec.D",
      "library": "goblint.lib",
      "description": "This module provides lattice operations (join, meet, widen, narrow) and comparison-based reasoning (equality, ordering) for abstract domain values, along with utilities for pretty-printing and serialization. It operates on an abstract type representing analysis states in a path-sensitive observer analysis, focusing on lattice semantics and extremal value handling like top element detection. These features enable precise static analysis of program state transitions and constraint propagation in abstract interpretation frameworks.",
      "description_length": 534,
      "index": 448,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Malloc_null.Spec.P",
      "library": "goblint.lib",
      "description": "This module provides lattice operations and domain-specific utilities for abstract interpretation in static analysis, focusing on path-sensitive memory allocation states. It defines a lattice structure with `join`, `meet`, `widen`, `narrow`, and distinguished `bot`/`top` elements, operating on an abstract type `t` (aliased from `D.t`) that models dynamic memory allocation outcomes, including failure states. The module supports serialization, comparison, and arbitrary value generation, enabling use in analysis frameworks that track potential null returns from memory allocation functions.",
      "description_length": 593,
      "index": 449,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.LoopfreeCallstring.Spec.D",
      "library": "goblint.lib",
      "description": "This module implements an abstract domain for loop-free callstrings optimized for static analysis, where recursive call cycles are compactly represented by grouping repeated calls into sets. It provides lattice operations (join, meet, widen, narrow), equality checks, and a top element to model the least precise callstring state, operating on an abstract type that encodes call sequences like `main, {a, b, c}` instead of repeating cycles. The domain is particularly useful for improving scalability in abstract interpretation of recursive programs by reducing path explosion while preserving relational context.",
      "description_length": 613,
      "index": 450,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.SymbLocksDomain.Symbolic.S",
      "library": "goblint.lib",
      "description": "This module supports manipulation of symbolic locksets through lattice and set operations, representing lock states as either a set of symbolic expressions (`Lifted`) or an over-approximated top element. It provides set-like functionality for symbolic expressions (`CilType.Exp.t`), including membership checks, union/intersection, and iterative transformations, while adhering to abstract domain semantics for program analysis. Designed for static analysis contexts, it enables tracking and merging of lockset states during abstract interpretation to reason about concurrent program behavior.",
      "description_length": 593,
      "index": 451,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.SpecLifters.PathSensitive2.P",
      "library": "goblint.lib",
      "description": "This module defines a type `t` representing path-sensitive global constraint variables, with operations for equality, comparison, hashing, and pretty-printing. It includes functions to convert values to JSON, generate arbitrary test values, and project from another type `D.t`. Concrete use cases include tracking unique path identifiers in static analysis and enabling context-sensitive constraint propagation.",
      "description_length": 411,
      "index": 452,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.WideningTokenLifter.Lifter.G",
      "library": "goblint.lib",
      "description": "This module implements lattice-theoretic operations such as join, meet, widen, and narrow for an abstract domain `G.t` augmented with widening tokens. These tokens track local and global state changes to dynamically delay widening until token sets stabilize, enabling precise fixpoint computations in static analysis contexts where deferred widening avoids premature convergence. The lattice structure supports top and bottom elements, with utilities for comparison, hashing, and pretty-printing differences, making it suitable for abstract interpretation frameworks requiring controlled widening behavior.",
      "description_length": 606,
      "index": 453,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.LoopfreeCallstring.Spec.C",
      "library": "goblint.lib",
      "description": "This module implements loop-free call strings by collapsing recursive cycles into sets, preserving call order while reducing redundancy. It supports equality checks, hashing, comparison, and serialization for use in abstract interpretation contexts. Concrete use cases include optimizing static analysis of recursive programs by tracking call contexts without infinite expansion.",
      "description_length": 379,
      "index": 454,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Signs.Spec.V",
      "library": "goblint.lib",
      "description": "This module represents global constraint variables used in an intraprocedural integer sign analysis. It provides operations for equality checking, hashing, comparison, and pretty-printing of constraint variables, along with utilities for serialization, arbitrary value generation, and context identification via unique tags. It is used to track and manipulate sign information for integer variables during static analysis of C code.",
      "description_length": 432,
      "index": 455,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.CommonPriv.WriteCenteredD.W",
      "library": "goblint.lib",
      "description": "This module provides dictionary operations for managing variable-to-minimal-lockset associations, supporting insertion, iteration, and functional transformations, alongside lattice operations like join and widen for static analysis. It works with abstract values encapsulating write-centered data, structured as mappings from variables to locksets, and includes utilities for comparison, serialization, and pretty-printing. Designed for thread-modular concurrency analysis, it enables tracking lockset dependencies and combining abstract states during static analysis of concurrent programs.",
      "description_length": 591,
      "index": 456,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.TmpSpecial.Spec.D",
      "library": "goblint.lib",
      "description": "This module provides associative map operations and lattice-based abstract interpretation utilities for tracking dependencies of math library function calls. It works with a map structure that associates expressions (`Mval.Exp.t`) with dependency sets (`MLDeps.t`), supporting merging, transformation, and algebraic combinators alongside meet/join operations for static analysis of program states. It is used to model how variables propagate through math function results, enabling analyses to track and merge abstract values representing potential modifications to expressions or their dependencies.",
      "description_length": 600,
      "index": 457,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.PrecCompare.MakeDump.CompareDump",
      "library": "goblint.lib",
      "description": "This module compares two abstract domains for precision by analyzing their internal states with a customizable function, generating a structured result and formatted document that highlights differences. It operates on domains encapsulated in `Util.Dom.t`, supporting verbose output and custom naming options to aid in debugging and analysis. The child module extends this by implementing a structured dumping mechanism that evaluates and contrasts domain states in detail, producing human-readable reports on precision discrepancies. Together, they enable precise, customizable comparison of abstract domains with rich output for static analysis and implementation verification.",
      "description_length": 679,
      "index": 458,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Callstring.Spec.C",
      "library": "goblint.lib",
      "description": "Implements call string specifications with operations for equality, hashing, comparison, and serialization. Works with call string elements parameterized by the `CT` module, supporting arbitrary value generation and relifting. Used to define analysis contexts with infinite or bounded call strings (e.g., k-CFA) for precise context-sensitive analysis in static program verification.",
      "description_length": 382,
      "index": 459,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Queries.Set.Exceptionless",
      "library": "goblint.lib",
      "description": "This module provides functions to query elements from a set without raising exceptions, returning `option` types instead. It supports operations like retrieving the minimum or maximum element, selecting an arbitrary element, or finding a specific element within the set. These functions are designed for safe, predictable handling of sets in contexts where absence of elements should not cause failures.",
      "description_length": 403,
      "index": 460,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.SpecLifters.DeadCodeLifter.P",
      "library": "goblint.lib",
      "description": "This module defines operations for handling path-representative values used in global constraint analysis. It provides equality, hashing, comparison, and serialization functions for its type `t`, along with a projection function from type `D.t`. These operations support tracking and distinguishing unreachable code contexts in lifted analyses.",
      "description_length": 344,
      "index": 461,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.UseAfterFree.Spec.A",
      "library": "goblint.lib",
      "description": "This module defines operations for managing and comparing abstract values representing memory states in a use-after-free analysis. It supports concrete data types like `t` with functions for equality, hashing, comparison, and pretty-printing, as well as serialization via `to_yojson` and XML. These operations are used to track and identify memory accesses post-free, enabling detection of potential vulnerabilities in analyzed programs.",
      "description_length": 437,
      "index": 462,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.LocksetAnalysis.MakeMay.D",
      "library": "goblint.lib",
      "description": "This module implements a lattice structure for abstract lockset states, providing operations like join, meet, widen, and narrow to model concurrency behaviors, along with comparison, equality checks, and serialization for analysis integration. It operates on a type `t` (aliasing `Arg.D.t`) representing abstract lockset states, featuring top and bottom elements to denote maximal and minimal analysis precision. These capabilities enable static analysis of concurrent programs to identify synchronization issues such as deadlocks and race conditions through abstract interpretation.",
      "description_length": 583,
      "index": 463,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.ThreadAnalysis.Spec.P",
      "library": "goblint.lib",
      "description": "This module provides lattice operations (join, meet, widen, narrow) and utilities for manipulating an abstract type representing thread states or program points in static analysis. It includes functions to handle extremal elements (top/bottom), compare values, and serialize results, supporting over-approximation of concurrent program behaviors. The abstractions model thread uniqueness and state transitions, enabling analyses like race condition detection or thread-local reasoning in concurrent systems.",
      "description_length": 507,
      "index": 464,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.MemOutOfBounds.Spec.C",
      "library": "goblint.lib",
      "description": "This module implements lattice operations such as join, meet, widen, and narrow alongside type utilities for a memory bounds analysis domain. It operates on an abstract type representing memory state approximations, structured to support static program verification. The lattice's top and bottom elements, along with comparison and serialization functions, enable detecting out-of-bounds memory accesses during analysis.",
      "description_length": 420,
      "index": 465,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ResultQuery.NH.Exceptionless",
      "library": "goblint.lib",
      "description": "Handles modifications and lookups in a constraint system solution without raising exceptions. Works with typed constraint system data through result-wrapped operations. Useful for safely querying and updating constraint values during analysis phases.",
      "description_length": 250,
      "index": 466,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Queries.Hashtbl.Exceptionless",
      "library": "goblint.lib",
      "description": "This module provides operations for safely querying and modifying a thread-safe, extensible hash table that maps keys to values of arbitrary type. It includes functions to retrieve values as optional results and to apply transformations to existing entries, handling potential exceptions during modification. Concrete use cases include managing shared state in concurrent analyses where key-based updates and lookups are required without raising exceptions.",
      "description_length": 457,
      "index": 467,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ThreadId.Spec.Created",
      "library": "goblint.lib",
      "description": "This module combines lattice operations for thread state analysis with serialization tools for structured data exchange. It defines core types like `t` (thread identifiers) and operations including join, meet, and widen to model thread relationships, while supporting comparisons, hashing, and formatting to XML/Yojson for diagnostics and reporting. You can merge analysis contexts, check subsumption between thread states, and generate structured outputs for static analysis of concurrent programs. Submodules refine these capabilities with specialized lattice functions and context-aware analysis tools.",
      "description_length": 605,
      "index": 468,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.SpecLifters.DeadBranchLifter.D",
      "library": "goblint.lib",
      "description": "The module provides lattice operations for an abstract domain type `D.t` used in static analysis to model dead branch information. It supports merging abstract states via join/meet, convergence control through widening/narrowing, and includes utilities for equality checks, ordering relations (`leq`, `is_bot`, `is_top`), and diagnostic output generation. This structure is specifically applied in abstract interpretation to combine or compare dead branch states during program analysis.",
      "description_length": 487,
      "index": 469,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.CompareConstraints.CompareNode.Compare",
      "library": "goblint.lib",
      "description": "This module compares constraint environments and generates structured, human-readable reports of their differences, supporting verbose output and custom naming. It defines core operations for comparing variable-like entities and constraint nodes, including equality checks, hashing, and total ordering via `compare`. The child modules handle node-specific comparisons and pretty-printing, enabling use cases like analyzing abstract states in static analysis and generating diagnostic reports. Together, they provide a comprehensive interface for comparing and serializing constraint discrepancies across analyses.",
      "description_length": 613,
      "index": 470,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.LocksetAnalysis.MakeMust.A",
      "library": "goblint.lib",
      "description": "This module implements a must-lockset analysis where all accesses must be protected by the same lock. It provides operations to check for potential race conditions between accesses and determine if an access should be printed based on locking context. The analysis works with abstract lockset values and is used in concurrency analysis to enforce strict lock-based synchronization.",
      "description_length": 381,
      "index": 471,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.WrapperFunctionAnalysis.ThreadCreateWrapper.A",
      "library": "goblint.lib",
      "description": "This module defines a data type `t` representing symbolic thread identifiers for thread creation wrapper analysis. It provides operations for equality checking, hashing, comparison, string representation, and XML/YoJSON serialization of these identifiers. The module supports tracking and comparing thread creation events with functions like `may_race` and `tag`, and controls output visibility with `should_print`.",
      "description_length": 415,
      "index": 472,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.StackDomain.Dom1.VarLat",
      "library": "goblint.lib",
      "description": "This module provides lattice operations (join, meet, widening, narrowing) and structural utilities for variable domains in call stack analysis, working with lattice elements that represent variable states. It includes functions to check bottom elements, compare lattice differences, and serialize data for testing or output formats like XML/JSON. These capabilities are particularly useful for static analysis tasks requiring precise state comparisons, debugging, and test-case generation.",
      "description_length": 489,
      "index": 473,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.RaceAnalysis.Spec.G",
      "library": "goblint.lib",
      "description": "This module provides lattice operations and trie-based hierarchical analysis for detecting data races in memory accesses. It operates on `OffsetTrie.t` structures to manage nested memory location prefixes and `MemoSet.t` sets to track type-based suffixes, enabling precise race detection between structurally related accesses. Key use cases include analyzing overlapping field accesses in structs, type-punned memory regions, and dynamically allocated memory with resolved points-to information.",
      "description_length": 495,
      "index": 474,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.YamlWitnessType.ViolationSequence.WaypointType",
      "library": "goblint.lib",
      "description": "This module defines a variant type representing different kinds of waypoints in a violation sequence, such as assumptions, targets, function entry/exit points, and branching nodes. It includes functions to compare waypoints, retrieve their type as a string, and parse them from YAML values. Concrete use cases include tracking control flow events in program analysis and serializing these events to or from YAML for witness generation.",
      "description_length": 435,
      "index": 475,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.StackTrace.Spec2.P",
      "library": "goblint.lib",
      "description": "This module provides comparison, equality, and hashing operations for a unit type used in call stack analysis. It includes functions for pretty-printing, serialization to XML and Yojson, and generating arbitrary values for testing. Concrete use cases include tracking and analyzing execution paths in program analysis tools.",
      "description_length": 324,
      "index": 476,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.ExpRelation.Spec.A",
      "library": "goblint.lib",
      "description": "This module defines a specification for comparing expressions syntactically to determine must-equality (=_{must}) in a stateless manner. It provides operations like `equal`, `compare`, `hash`, and `show` for handling expression relations, along with serialization and pretty-printing functions. It works directly with expressions represented by type `t`, supporting concrete use cases such as race detection analysis and symbolic expression comparison in static analysis workflows.",
      "description_length": 481,
      "index": 477,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Base.MainFunctor.Invariant",
      "library": "goblint.lib",
      "description": "This module implements invariant-based value refinement for static analysis. It provides functions to apply invariants during analysis, refine values based on expressions or lvalues, and handle fallback cases for unresolved expressions. These operations work on abstract values represented as `ValueDomain.Compound.t` and are used to improve precision in dataflow analysis by enforcing constraints derived from program invariants.",
      "description_length": 430,
      "index": 478,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Assert.Spec.D",
      "library": "goblint.lib",
      "description": "This lattice type supports core operations like join, meet, widen, and narrow for abstract interpretation, along with comparison, pretty-printing, and serialization capabilities. It operates on a domain type with distinguished top and bottom elements, forming a partial order structure. These features enable static analysis of program assertions by modeling value approximations and transformations in abstract domains.",
      "description_length": 420,
      "index": 479,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.TmpSpecial.Spec.Deps",
      "library": "goblint.lib",
      "description": "This module provides set-theoretic operations (union, intersection, difference) and lattice structures (join, meet, widening) for managing lifted domains of CIL expressions, where a top element represents unconstrained values. It works with sets of expressions (`CilType.Exp.t`) to track dependencies between variables and math function call arguments in static analysis. These capabilities enable precise propagation of equivalence relations and dependency tracking during abstract interpretation, particularly for identifying invalidated equivalences when expressions are modified.",
      "description_length": 583,
      "index": 480,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.IntDomainProperties.WithIkind.Ikind",
      "library": "goblint.lib",
      "description": "This module defines and provides the integer kind (`ikind`) used within the `IntDomainProperties` for specifying the bitwidth and signedness of integer values during property-based testing. It works with the `GoblintCil.Cil.ikind` type, which represents different integer types such as `IInt`, `I8`, `I16`, `I32`, and `I64`, each with signed or unsigned variants. A concrete use case is ensuring that integer domain operations behave correctly across various integer kinds during automated tests.",
      "description_length": 496,
      "index": 481,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Malloc_null.Spec.C",
      "library": "goblint.lib",
      "description": "The module implements lattice operations (join, meet, widen, narrow, bot, top) and auxiliary utilities like serialization and comparison for a static analysis domain. It operates on an abstract type modeling memory states to track null pointers and failed dynamic memory allocations. This enables path-sensitive analysis in C programs, particularly for detecting null dereferences and verifying error-handling paths during allocation failures.",
      "description_length": 443,
      "index": 482,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.WrapperFunctionAnalysis.SpecBase.UniqueCallCounter",
      "library": "goblint.lib",
      "description": "This module provides a map-based structure for tracking unique call counts per node, supporting precise symbolic heap location and thread identifier management through wrapper functions. It combines standard container operations with lattice functions (join, widen, etc.) to enable abstract interpretation in static analysis contexts. Designed for scenarios requiring distinct instance tracking\u2014such as dynamic memory allocations or thread creation\u2014it facilitates formal verification of program properties by maintaining node-specific counters with customizable combination logic.",
      "description_length": 580,
      "index": 483,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.MutexEventsAnalysis.Spec.P",
      "library": "goblint.lib",
      "description": "This module defines a path-representative type `t` used to track unique execution paths in mutex locking and unlocking analysis. It provides equality, hashing, comparison, and serialization operations for path representatives, enabling precise context identification in witness generation and constraint propagation. It works closely with mutex event data from the `Events` module and is used to lift and project path information during analysis.",
      "description_length": 446,
      "index": 484,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.LoopfreeCallstring.Spec.A",
      "library": "goblint.lib",
      "description": "This module defines a specification for loop-free call strings, which compactly represent recursive call chains by collapsing cycles into sets. It provides operations for equality checking, hashing, comparison, and pretty-printing of these call strings, along with utilities for XML and JSON serialization, arbitrary value generation, and race detection. Concrete use cases include context-sensitive static analysis where recursive calls must be summarized efficiently to avoid state explosion.",
      "description_length": 494,
      "index": 485,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Region.Spec.V",
      "library": "goblint.lib",
      "description": "This module implements operations for a unit-type specification used in region analysis, providing equality checks, comparison, hashing, and pretty-printing for abstract region values. It works with the unit type `t` to represent regions in memory analysis, specifically for tracking disjoint heap regions. Concrete use cases include comparing and identifying regions during static analysis for race detection and memory safety verification.",
      "description_length": 441,
      "index": 486,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.WrapperFunctionAnalysis.SpecBase.C",
      "library": "goblint.lib",
      "description": "This module provides lattice operations (join, meet, widen, narrow, top, bot) for an abstract domain type `C.t`, which represents program properties in static analysis. It works with lattice-structured values to enable merging and comparing abstract states, particularly in fixed-point computations for analyzing wrapper functions that model dynamic memory allocations and thread creation. The type supports determining extremal states (e.g., `top` for all possible values, `bot` for unreachable states) during abstract interpretation of library function behaviors.",
      "description_length": 565,
      "index": 487,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.WrapperFunctionAnalysis.ThreadCreateWrapper.D",
      "library": "goblint.lib",
      "description": "This module provides lattice-based abstract interpretation operations for managing symbolic thread identifiers in concurrent program analysis. It defines a structured type `t` representing abstract values, with lattice primitives like `join`, `meet`, and `widen` to track analysis precision, alongside utilities for comparison, serialization, and testing. The design supports precise thread creation analysis by associating symbolic thread IDs with program nodes and handling wrapper functions through abstract domain operations like `top` and `is_top`.",
      "description_length": 553,
      "index": 488,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.AccessAnalysis.Spec.C",
      "library": "goblint.lib",
      "description": "This module provides lattice operations for abstract interpretation in memory access analysis, including join, meet, widen, narrow, and ordering primitives, alongside top and bottom element handling. It operates on an abstract type `t` representing access analysis information, structured as a lattice for static analysis of C programs. These capabilities support use cases like tracking memory access patterns and optimizing code through abstract domain computations.",
      "description_length": 468,
      "index": 489,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MutexAnalysis.Spec.Arg",
      "library": "goblint.lib",
      "description": "This module tracks locksets using concrete address-based operations, enabling manipulation of mutex states through addition, removal, or clearing of locks at synchronization points. It works with polymorphic variants representing mutex states and pairs of must-lockset and multiplicity types to model locking behavior across function calls. Combined with submodules, it supports deadlock detection, lock order verification, and variable protection analysis by associating shared variables with required mutexes. It also handles mutex values as variables or offsets, enabling precise lockset tracking and static analysis of thread synchronization and access patterns in concurrent programs.",
      "description_length": 689,
      "index": 490,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ThreadFlag.Spec.A",
      "library": "goblint.lib",
      "description": "This module defines operations for a boolean thread flag type `t`, including equality, comparison, hashing, and pretty-printing functions. It supports analyzing multi-threaded program behavior by providing concrete operations like `may_race` to determine potential race conditions and `should_print` to control output based on flag values. The module is used in static analysis to track and compare thread-related states during program analysis.",
      "description_length": 445,
      "index": 491,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.YamlWitness.Make.LH",
      "library": "goblint.lib",
      "description": "This module provides imperative hash table-like structures keyed by `CilType.Location.t`, supporting efficient insertion, deletion, traversal, and bulk reset operations. It enables polymorphic value storage and transformation through higher-order functions for mapping, filtering, and merging, while utilities allow conversion to and from sequences and pretty-printed formats. Submodules extend this functionality with safe key-based access returning result types, hierarchical map manipulations for nested data, and infix operators for concise retrieval and update syntax. These features are used to manage and transform location-indexed metadata in YAML witness validation, configuration handling, and analysis pipelines.",
      "description_length": 723,
      "index": 492,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.LongjmpLifter.Lifter.C",
      "library": "goblint.lib",
      "description": "This module defines operations for manipulating a custom type `t` with equality, comparison, and serialization functions. It supports concrete data structures like hash tables and ordered maps by providing `equal`, `hash`, `compare`, and `show`. Use cases include tracking and comparing analysis contexts with unique identifiers and serializing them for reporting or testing.",
      "description_length": 375,
      "index": 493,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.RecursionTermLifter.Lifter.P",
      "library": "goblint.lib",
      "description": "This module defines a path-representative type `t` with operations for equality, hashing, comparison, and serialization. It works with context-sensitive analysis data, specifically lifted recursion terms, to uniquely identify and compare paths in a dynamic call graph. Concrete use cases include tracking and distinguishing recursive function call contexts during static analysis.",
      "description_length": 380,
      "index": 494,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Deadlock.Spec.Arg",
      "library": "goblint.lib",
      "description": "This module analyzes program control flow to track lock acquisition and release events, correlating them with memory accesses to detect potential deadlocks. It provides core operations like `add`, `remove`, and `part_access` to manipulate and query lock states, working primarily with `G.t` for analysis state and `ValueDomain.Addr.t` for memory addresses. The first child module enhances this with map-based tracking of may-lock event pairs, enabling path-sensitive analysis through merging, filtering, and lattice operations. The second child module supports pointer analysis using lattice-based abstract interpretation, modeling pointer values and transitions to resolve memory accesses and detect concurrency issues across abstract states.",
      "description_length": 743,
      "index": 495,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.WitnessConstraints.PathSensitive3.V",
      "library": "goblint.lib",
      "description": "This module defines and manipulates globally unique constraint variables with operations for equality, hashing, comparison, and pretty-printing. It supports path-sensitive analysis by providing unique identifiers (via `tag`) and serialization for use in witness generation. Concrete use cases include tracking variable identities across analysis contexts and ensuring correct constraint propagation in path-sensitive symbolic execution.",
      "description_length": 436,
      "index": 496,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.SpecLifters.DeadBranchLifter.V",
      "library": "goblint.lib",
      "description": "This module defines a data type `t` representing global constraint variables, primarily used for tracking and analyzing variable states in static analysis. It provides operations for equality checking, hashing, comparison, and pretty-printing, along with utilities for serialization, generating arbitrary values, and determining variable properties like write-only status. Concrete use cases include constraint solving and witness generation in program analysis.",
      "description_length": 462,
      "index": 497,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.YamlWitnessType.ViolationSequence.Assumption",
      "library": "goblint.lib",
      "description": "This module represents assumptions in a violation sequence within a YAML witness format. It includes parsing from YAML, comparison, and a fixed waypoint type identifier. It is used to capture and process assumption constraints during program analysis.",
      "description_length": 251,
      "index": 498,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.PthreadSignals.Spec.A",
      "library": "goblint.lib",
      "description": "This module defines and manipulates abstract values representing thread signals for Pthread condition variables. It supports equality checks, hashing, comparison, and pretty-printing for these values, along with operations to determine race conditions between them and whether a value should be included in race output. The module is used during static analysis to track and report potential concurrency issues involving condition variable signaling.",
      "description_length": 450,
      "index": 499,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.ObserverAnalysis.MakeSpec.V",
      "library": "goblint.lib",
      "description": "This module defines operations for managing global constraint variables in a path-sensitive analysis, including equality checks, hashing, comparison, and serialization. It works with a concrete type `t` representing constraint variables, supporting operations like generating unique IDs, pretty-printing, and conversion to JSON. It is used to track and differentiate constraint variables during analysis, enabling precise context-sensitive reasoning and witness generation.",
      "description_length": 473,
      "index": 500,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ExpRelation.Spec.D",
      "library": "goblint.lib",
      "description": "This module provides lattice operations for comparing and combining abstract values that represent syntactic relationships between expressions under a must-equality analysis. It operates on a type encoding symbolic expression relations, supporting operations like join, meet, and widening to facilitate static analysis of program expressions without state tracking. The structure is particularly useful in analysis frameworks requiring precise merging of expression equivalence information during fixed-point computations.",
      "description_length": 522,
      "index": 501,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Constants.Spec.P",
      "library": "goblint.lib",
      "description": "This module defines path-representative values for tracking global constraint variables in a constants analysis. It provides operations for equality checking, hashing, comparison, and pretty-printing these representatives, along with functions to convert them to JSON and XML formats. It is used to uniquely identify and manipulate constraint contexts within the analysis, particularly during witness generation and testing.",
      "description_length": 424,
      "index": 502,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.LoopTermination.Spec.G",
      "library": "goblint.lib",
      "description": "This module provides lattice-based abstract domain operations for analyzing loop termination properties, including join, meet, widen, and narrow for combining abstract states, along with top/bottom element checks. It works with a type representing termination specifications, structured to support abstract interpretation in static analysis. These operations enable modeling loop behaviors and convergence checks when proving termination or identifying non-terminating patterns in programs.",
      "description_length": 490,
      "index": 503,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.ExpRelation.Spec.G",
      "library": "goblint.lib",
      "description": "This module provides lattice-based operations for comparing and manipulating symbolic expression relations, focusing on syntactic equality checks. It operates on an abstract lattice type representing relationships between expressions, supporting queries like ordering and equivalence, as well as transformations such as widening and narrowing. The design enables integration into static analysis frameworks for symbolic reasoning, property-based testing, and serialization workflows in formats like XML or JSON.",
      "description_length": 511,
      "index": 504,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.MemLeak.Spec.P",
      "library": "goblint.lib",
      "description": "This module defines operations for managing path-representative values used in global constraint variables. It provides equality checks, hashing, comparison, and string/XML/JSON representations for these values, along with a function to generate arbitrary test values and a projection function from domain elements. The module supports tracking and identifying unique paths in memory leak analysis through its tagging and comparison capabilities.",
      "description_length": 446,
      "index": 505,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ExtractPthread.Tbls.FunNameToTids",
      "library": "goblint.lib",
      "description": "Maps function names to sets of thread IDs in a thread analysis context. Provides operations to add, retrieve, and extend mappings between function names and thread IDs, along with reverse lookup of function names by thread ID. Useful for tracking which threads are associated with specific functions during static analysis of concurrent programs.",
      "description_length": 346,
      "index": 506,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ThreadEscape.Spec.ThreadIdSet",
      "library": "goblint.lib",
      "description": "This module implements a set abstraction for tracking thread identifiers with support for lattice operations like join, meet, and widening, enabling precise escape analysis of thread-local variables in concurrent programs. It operates on sets of lifted thread IDs (`ThreadIdDomain.ThreadLifted.t`), where elements represent concrete threads or an abstract \"all threads\" value (`top`), and provides utilities for set algebra, iteration, and analysis-specific queries. Key use cases include determining thread escape states during static analysis, merging thread contexts via lattice operations, and testing properties with QCheck-generated arbitrary sets.",
      "description_length": 654,
      "index": 507,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.MayLocks.Arg.D",
      "library": "goblint.lib",
      "description": "The module provides lattice operations including join, meet, widen, and narrowing on an abstract domain type representing potential lock sets, enabling static analysis of concurrent programs. It works with abstract elements of type `t` that model may-lock states, supporting comparisons, top/empty checks, and pretty-printing for analysis tracking. This structure is specifically used in Goblint's static analysis to detect concurrency-related errors like double locking by approximating lock acquisition patterns.",
      "description_length": 514,
      "index": 508,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.ActiveSetjmp.Spec.C",
      "library": "goblint.lib",
      "description": "This module provides lattice operations and value manipulation functions for analyzing active setjmp buffer states in static analysis. It works with an abstract type `t` (aliased from `D.t`) representing buffer states and includes operations to check or create top states denoting the most general state. The lattice structure supports merging (join/meet) and approximation (widen/narrow) operations, with serialization capabilities for persistence or communication.",
      "description_length": 466,
      "index": 509,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ThreadAnalysis.Spec.V",
      "library": "goblint.lib",
      "description": "This module provides operations for managing thread identifiers (TIDs) in static analysis, including comparison, hashing, and tracking thread creation relationships to determine main or unique threads and model spawning behavior. It also includes a function to check if a value represents a write-only variable, aiding in thread behavior analysis. The module works with TIDs and abstract analysis values, supporting use cases like reasoning about thread uniqueness and variable access patterns in concurrent programs.",
      "description_length": 517,
      "index": 510,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ThreadId.Spec.A",
      "library": "goblint.lib",
      "description": "This module defines operations for handling optional thread identifiers, including equality checks, comparison, hashing, and pretty-printing. It works with the `ThreadLifted.t option` type to represent potentially absent thread IDs, supporting serialization to XML and JSON, and checking for race conditions between thread IDs. Concrete use cases include tracking thread identity in concurrent analysis and determining thread interference in lifted contexts.",
      "description_length": 458,
      "index": 511,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.MutexEventsAnalysis.Spec.V",
      "library": "goblint.lib",
      "description": "This module defines a data type `t` representing global constraint variables used in mutex locking and unlocking analysis. It provides operations for equality checking, hashing, comparison, string representation, and serialization to XML and YoJSON formats. These variables are used to track and identify mutex events in different analysis contexts, supporting precise constraint propagation and witness generation.",
      "description_length": 415,
      "index": 512,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.AnalysisResult.Result.Labels",
      "library": "goblint.lib",
      "description": "This module operates on hashtables with keys of type `key` and data of a generic type `'a`, using a specific hash table implementation tied to `Goblint_lib.AnalysisResult.ResultNode`. It provides fine-grained manipulation of analysis result labels through operations like adding, replacing, filtering, mapping, and merging entries based on custom logic applied to keys and values. These functions enable precise modification and traversal of analysis results, such as selectively updating or extracting data associated with specific program points or labels during static analysis.",
      "description_length": 581,
      "index": 513,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.CommonPriv.ConfCheck.RequireMutexActivatedInit",
      "library": "goblint.lib",
      "description": "This module enforces that mutexes are activated during initialization by validating configuration settings related to thread-modular analysis. It operates on internal analysis states and configuration flags to ensure proper setup before analysis begins. Use this module to catch misconfigurations that could lead to incorrect concurrency analysis in multi-threaded programs.",
      "description_length": 374,
      "index": 514,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Region.Spec.C",
      "library": "goblint.lib",
      "description": "This module provides lattice operations (join, meet, widen, narrow) and domain management (top/bot checks) for an abstract type representing heap region states. It works with lattice elements that model disjoint heap regions using abstract interpretation, supporting comparisons and serialization. These operations enable static analysis of concurrent programs to detect memory races by tracking region ownership and interference.",
      "description_length": 430,
      "index": 515,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.LoopTermination.Spec.D",
      "library": "goblint.lib",
      "description": "This domain implements lattice operations (join, meet, widen, narrow) and comparisons for a symbolic termination state type, used in abstract interpretation to analyze loop and goto termination. It supports creating top elements and checking their presence, enabling static analysis of C programs to determine termination properties through symbolic state manipulation.",
      "description_length": 369,
      "index": 516,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.CompareConstraints.CompareEqSys.Compare",
      "library": "goblint.lib",
      "description": "This module compares constraint systems represented as hash tables mapping variables to domains, producing structured results and formatted output to analyze differences. It supports customization of comparison output and labeling for clarity in debugging or verification tasks. The core functionality works with variables (`t` as `Sys.Var.t`) and domains (`Sys.Dom.t`), enabling precise equality checks, structural analysis, and human-readable traces. Operations include variable identity tracking, domain comparison, and pretty-printing, combining direct API calls and submodules for comprehensive constraint system analysis.",
      "description_length": 627,
      "index": 517,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.SpecLifters.OptEqual.P",
      "library": "goblint.lib",
      "description": "This module defines operations for managing and comparing path-representative values with globally unique identifiers. It supports equality checks, hashing, comparison, and various serialization methods, including XML and JSON. These values are used to track and identify specific analysis contexts during constraint propagation in static analysis.",
      "description_length": 348,
      "index": 518,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.CompareConstraints.CompareNode.Node",
      "library": "goblint.lib",
      "description": "The module provides comparison, identification, and conversion operations for nodes representing CIL statements and function entries, facilitating control flow graph labeling, solver tracing, and serialization. It supports analysis frameworks through utilities to manage node identities, convert identifiers to nodes, and determine properties like write-only status, with pretty-printing and serialization functions aiding debugging and data exchange (e.g., XML, Yojson).",
      "description_length": 471,
      "index": 519,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MutexEventsAnalysis.Spec.A",
      "library": "goblint.lib",
      "description": "This module defines operations for analyzing mutex events, including equality, hashing, comparison, and pretty-printing of mutex event values. It supports detecting potential race conditions between events with `may_race` and provides context identification via unique tags. Concrete use cases include tracking and comparing lock and unlock events in concurrent program analysis.",
      "description_length": 379,
      "index": 520,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.StackTrace.Spec1.C",
      "library": "goblint.lib",
      "description": "This module supports lattice operations (join, meet, widen, narrow) and structural manipulations (equality, hashing, serialization) over abstract call stack states represented by a type `t` with a distinguished singleton \"top\" element. It works with data structures modeling hierarchical stack traces in static analysis, where the top value signifies an initial or default state. These operations enable tracking and comparing call stack contexts within Goblint's abstract interpretation framework for program analysis tasks like bug detection or optimization.",
      "description_length": 560,
      "index": 521,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MayLocks.Arg.V",
      "library": "goblint.lib",
      "description": "This module defines a value type `t` with operations for equality, hashing, comparison, and pretty-printing. It supports serialization through XML and Yojson, and includes functionality for generating arbitrary values and extracting unique identifiers. It is used to represent and manipulate abstract values in may-lock analysis, particularly for tracking lock ownership and write-only status.",
      "description_length": 393,
      "index": 522,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.SymbLocks.Spec.C",
      "library": "goblint.lib",
      "description": "This module provides lattice operations for symbolic lock analysis, including retrieving the top element and checking top membership, which are essential for abstract interpretation. It works with symbolic lock states represented by the abstract type `t`, designed to model per-element locking patterns using lattice-theoretic semantics. These operations enable static race detection in concurrent systems code, particularly for verifying correct locking discipline in device drivers as described in the referenced analysis approach.",
      "description_length": 533,
      "index": 523,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MutexEventsAnalysis.Spec.C",
      "library": "goblint.lib",
      "description": "This module defines a data type `t` representing mutex lock and unlock events, along with operations to compare, hash, display, and serialize these events. It supports concrete use cases such as tracking mutex usage patterns, generating unique identifiers for event instances, and producing structured output for analysis reporting or witness generation. Functions like `equal`, `show`, and `to_yojson` enable precise event comparison and integration with external tools.",
      "description_length": 471,
      "index": 524,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.StackTrace.Spec2.C",
      "library": "goblint.lib",
      "description": "This component defines lattice operations and structural utilities for call stack analysis, supporting abstract interpretation in static analysis workflows. It works with stack trace elements to enable comparisons, serialization, and top-of-stack checks, which are critical for tracking function call hierarchies and analyzing program behavior.",
      "description_length": 344,
      "index": 525,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.LongjmpLifter.Lifter.V",
      "library": "goblint.lib",
      "description": "This module defines a data type `t` representing global constraint variables, primarily used for tracking and managing constraints during static analysis involving longjmp and setjmp. It provides operations for equality checking, hashing, comparison, and pretty-printing, as well as serialization to XML and Yojson formats. These variables are used to uniquely identify and reason about program points in the context of lifted analyses, particularly when dealing with non-local control flow.",
      "description_length": 491,
      "index": 526,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Goblint_lib.Uninit.Spec.P",
      "library": "goblint.lib",
      "description": "This module provides lattice operations (join, meet, widen, narrow) and comparison utilities for an abstract type representing uninitialized variable states, supporting abstract interpretation in static analysis. It works with a lattice-structured type that includes distinguished bottom and top elements, enabling representation of initialization domains with partial information. Specific use cases include tracking initialized local variables in program analysis and generating structured outputs like XML/JSON for state visualization.",
      "description_length": 538,
      "index": 527,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ExtractPthread.Tbls.MutexMidTbl",
      "library": "goblint.lib",
      "description": "Implements a bidirectional mapping between mutex names and unique identifiers, enabling efficient lookup and management of mutex state during Pthread program analysis. Uses a hash table to store associations and provides operations to retrieve identifiers by name, names by identifier, and enumerate all pairs. Useful for tracking mutex usage and ensuring consistent identifier assignment across analysis phases.",
      "description_length": 412,
      "index": 528,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Witness.Result.Query",
      "library": "goblint.lib",
      "description": "This module provides functions to query local and global analysis results within a constraint system, specifically using a graph structure to represent analysis contexts. It operates on data types such as constraint graphs, nodes, and analysis domains to retrieve results for specific queries. Concrete use cases include extracting variable values at specific program points or checking global invariants derived from static analysis.",
      "description_length": 434,
      "index": 529,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.SpecLifters.WidenContextLifterSide.P",
      "library": "goblint.lib",
      "description": "This module provides operations for managing and transforming context identifiers, including equality checks, hashing, comparison, and pretty-printing. It works with the abstract type `P.t`, representing contexts, and supports serialization through XML and Yojson. Concrete use cases include tracking unique context IDs during static analysis and facilitating context-sensitive dataflow analyses with lifted specifications.",
      "description_length": 423,
      "index": 530,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.AnalysisResult.Result.Exceptionless",
      "library": "goblint.lib",
      "description": "This module provides operations to safely query and update a hash table mapping analysis result nodes to values, using `find` to retrieve optional values for keys and `modify` to apply transformations returning a result indicating success or failure. It works with hash tables from the standard library, parameterized over analysis result nodes as keys and arbitrary values. Concrete use cases include managing and updating analysis results during static analysis without direct exception handling.",
      "description_length": 498,
      "index": 531,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.RecursionTermLifter.Lifter.D",
      "library": "goblint.lib",
      "description": "This module provides lattice-theoretic operations for abstract domain elements, including comparison, combination (join/meet), approximation (widen/narrow), and extremal value checks (bot/is_bot, top/is_top). It operates on values of type `D.t`, structured as a lattice with serialization and generation capabilities for analysis frameworks. These operations support static analysis tasks like cycle detection in recursive function call graphs by enabling precise abstract interpretation over dynamic contexts.",
      "description_length": 510,
      "index": 532,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Taint.Spec.C",
      "library": "goblint.lib",
      "description": "This module defines a specification for taint analysis in C programs, providing operations to compare, hash, and serialize taint values. It works with a concrete type `t` representing taint states, supporting pretty-printing, XML output, and JSON serialization via Yojson. Use cases include tracking data flow through C functions and generating analysis results for external tools or reports.",
      "description_length": 392,
      "index": 533,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.UseAfterFree.Spec.C",
      "library": "goblint.lib",
      "description": "This module defines operations for managing and comparing abstract values representing memory states in a use-after-free analysis. It supports data types with unique identifiers and hashed comparisons, enabling precise tracking and differentiation of memory contexts during static analysis. Concrete use cases include detecting invalid memory accesses after deallocation and generating witness reports for identified vulnerabilities.",
      "description_length": 433,
      "index": 534,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.RecursionTermLifter.Lifter.G",
      "library": "goblint.lib",
      "description": "This module provides lattice operations such as join, meet, widen, and narrow for a type representing context-sensitive analysis states with HConsed identifiers. These operations enable tracking recursive function calls through unique tagged values, supporting cycle detection in dynamic call graphs. It is specifically used in static analysis to ensure termination of recursive procedures by identifying repeated contexts.",
      "description_length": 423,
      "index": 535,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.RaceAnalysis.Spec.OffsetTrie",
      "library": "goblint.lib",
      "description": "This module organizes memory access analysis through a trie-based lattice that maps structured offsets to access sets, enabling precise merging of access patterns via join, meet, and widening operations. It tracks hierarchical relationships between memory locations, supporting operations for traversal, comparison, and combination of access sets across nested prefixes and type suffixes. The trie structure allows efficient race detection in concurrent C programs by analyzing overlapping memory regions from struct fields, pointer arithmetic, or type punning. Submodules implement core lattice operations and map-based trie management, facilitating abstract interpretation over complex type hierarchies and pointer indirections.",
      "description_length": 730,
      "index": 536,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Base.MainFunctor.InvariantEval",
      "library": "goblint.lib",
      "description": "This module evaluates invariants during static analysis by computing values from expressions and memory locations using a given context and store. It handles operations like evaluating unary operators, resolving variables, addresses, and offsets, and updating or refining stored values. It works with abstract domains for values (VD), addresses (AD), function descriptors (FD), and integer descriptors (ID), and is used to analyze and refine variable values during program analysis.",
      "description_length": 482,
      "index": 537,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ExpRelation.Spec.V",
      "library": "goblint.lib",
      "description": "This module defines operations for comparing, hashing, and printing constraint variables used in symbolic expression analysis. It works with the abstract type `t` representing global constraint variables, primarily for syntactic equality checks (`=_{must}`) without state. Concrete use cases include identifying constraints during expression comparison and supporting serialization for analysis reporting and testing.",
      "description_length": 417,
      "index": 538,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.RaceAnalysis.Spec.OneOffset",
      "library": "goblint.lib",
      "description": "This module represents individual offset components in memory access paths for data race analysis. It defines a type `t` that distinguishes between struct field offsets (`Field`) and array index offsets (`Index`), along with operations for comparison, hashing, and string representation. It supports precise identification of memory locations during race analysis by enabling traversal and matching of offset paths in trie structures.",
      "description_length": 434,
      "index": 539,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.WrapperFunctionAnalysis.ThreadCreateWrapper.V",
      "library": "goblint.lib",
      "description": "This module defines a data type `t` representing symbolic thread identifiers for wrapper functions, with operations for equality, hashing, comparison, and string/XML/JSON representation. It supports precise tracking of thread creation contexts by associating unique IDs with nodes in the analysis graph. Use cases include distinguishing between different thread creation sites and enabling context-sensitive analysis of concurrent programs.",
      "description_length": 440,
      "index": 540,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ExpRelation.Spec.C",
      "library": "goblint.lib",
      "description": "This module defines a concrete specification for comparing expressions syntactically with `=_{must}`. It provides operations for equality checking, hashing, comparison, and pretty-printing of expressions, along with serialization and arbitrary value generation for testing. It works directly with expression structures to support precise relation analysis in static analysis contexts.",
      "description_length": 384,
      "index": 541,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Taint.Spec.D",
      "library": "goblint.lib",
      "description": "This module provides lattice operations for managing taint information in static analysis, including equality checks, ordering relations (leq, join/meet), extremal elements (bot/top), and serialization utilities. It operates on an abstract type representing taint states, designed for interprocedural data flow tracking where top elements denote maximally permissive taint contexts and bottom elements represent empty information. The lattice structure supports analysis convergence through widening/narrowing, while pretty-printing and XML/JSON serialization aid debugging and diagnostic output in taint propagation scenarios.",
      "description_length": 627,
      "index": 542,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ResultQuery.NH.Infix",
      "library": "goblint.lib",
      "description": "This module provides infix operators for querying and updating a constraint system solution. It works with typed query handles and keys to access or modify specific values. Concrete use cases include retrieving analysis results for a given key or setting values during constraint solving.",
      "description_length": 288,
      "index": 543,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.CommonPriv.MutexGlobals.VMutexInits",
      "library": "goblint.lib",
      "description": "This module represents mutex initialization states in a thread-modular analysis, providing equality, comparison, and hashing operations for tracking mutexes across analysis domains. It supports serialization through pretty-printing, XML, and Yojson formats, along with QCheck arbitrary instance generation for testing. It is used to model and distinguish mutex initialization statuses during static analysis of concurrent programs.",
      "description_length": 431,
      "index": 544,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.UseAfterFree.Spec.V",
      "library": "goblint.lib",
      "description": "This module defines and manipulates constraint variables used in tracking use-after-free vulnerabilities. It provides operations for equality checking, hashing, comparison, and pretty-printing of these variables, along with utilities for serialization, generating arbitrary values, and extracting identifiers. These variables are used to represent abstract memory locations in the analysis of memory safety violations during static program analysis.",
      "description_length": 449,
      "index": 545,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Base.MainFunctor.V",
      "library": "goblint.lib",
      "description": "This module defines a polymorphic variant type combining values from `Priv.V.t` and `ThreadIdDomain.thread`, providing comparison, hashing, and pretty-printing operations. It includes utilities for type conversion, XML and JSON serialization, and value inspection, supporting analysis of concurrent program states. Concrete use cases involve tracking thread-specific and privilege-related values in static analysis.",
      "description_length": 415,
      "index": 546,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Deadlock.Spec.P",
      "library": "goblint.lib",
      "description": "This module defines operations for a singleton type `t` representing a unit value in deadlock analysis. It includes equality checks, comparison, and hashing functions, along with utilities for pretty-printing, serialization, and generating arbitrary values. It is used to model absence of data in a structured way across analysis components.",
      "description_length": 341,
      "index": 547,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ExtractPthread.Spec.C",
      "library": "goblint.lib",
      "description": "This module defines operations for manipulating and analyzing Pthread specification data in the context of Promela extraction. It provides equality, hashing, comparison, and serialization functions for type `t`, which represents Pthread constructs. These operations support precise context identification and comparison in analysis tasks such as witness generation and XML output formatting.",
      "description_length": 391,
      "index": 548,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.PoisonVariables.Spec.VS",
      "library": "goblint.lib",
      "description": "This module provides lattice and set-theoretic operations for tracking tainted variables in static analysis, specifically modeling sets of C variables (`CilType.Varinfo.t`) that may be invalidated by `setjmp`/`longjmp` interactions. It supports abstract interpretation through join/meet operations and precise set manipulations like union/difference, alongside serialization and comparison utilities. The design enables analyzing undefined behavior from unsequenced modifications to non-volatile variables across non-local gotos.",
      "description_length": 529,
      "index": 549,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Queries.Set.Labels",
      "library": "goblint.lib",
      "description": "This module implements standard collection operations like `iter`, `fold`, `map`, and `filter` for a set structure over elements of type `Goblint_lib.Queries.Set.elt`. It supports transformations, inspections, and subdivisions of sets based on predicate functions applied to individual elements. These operations are useful for analyzing or manipulating sets of abstract queries in static analysis contexts.",
      "description_length": 407,
      "index": 550,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.MayLocks.Spec.P",
      "library": "goblint.lib",
      "description": "This module defines a singleton type `t` with operations for comparison, hashing, and pretty-printing, primarily used to represent abstract lock states in may-lockset analysis. It includes functions for serialization, testing, and conversion, facilitating analysis of potential locking behaviors in concurrent programs. Concrete use cases include tracking lock acquisition histories and detecting double locking in static analysis.",
      "description_length": 431,
      "index": 551,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ObserverAnalysis.MakeSpec.P",
      "library": "goblint.lib",
      "description": "This module defines operations for managing path-representative values with a unique type `t`, including equality checks, hashing, comparison, and string representation. It supports data types like `D.t` through projection and provides serialization via XML and Yojson. Concrete use cases include tracking unique path identifiers in constraint-based analysis and enabling precise context-sensitive comparisons in automated verification.",
      "description_length": 436,
      "index": 552,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.CompareConstraints.CompareHashtbl.CompareD",
      "library": "goblint.lib",
      "description": "Implements a hash table for tracking and comparing constraint values during static analysis. It maps constraint identifiers to their values and supports efficient lookups, insertions, and equality checks. Used to detect redundant or conflicting constraints in program analysis.",
      "description_length": 277,
      "index": 553,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.CommonPriv.PerMutexTidCommon.GMutex",
      "library": "goblint.lib",
      "description": "This module provides associative container operations for a map from `Digest.t` keys to `LD.t` values, supporting insertion, bulk transformations, and customizable merging of key lists or maps. It includes lattice operations (join, meet, widen) and semantic-aware utilities like `leq` and `compare` for abstract interpretation in concurrent analysis. Designed for thread-modular value analysis, it enables modeling mutex states, lock dependencies, and merging analysis states with domain-specific combination logic.",
      "description_length": 515,
      "index": 554,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Control.AnalyzeCFG.CompareGlobSys",
      "library": "goblint.lib",
      "description": "This module compares analysis states across control flow graph contexts by combining global and local variable tracking with constraint solving. It provides data types like `GH.t` and `LH.t` for key-based global and node-local state management, supporting operations to merge, compare, and transform analysis results across CFG nodes. Direct APIs enable state updates, constraint evaluation, and result comparison, while submodules handle lattice operations, context merging, and variable identity tracking. Example uses include verifying abstract interpretation consistency between solver iterations and merging variable states from different control flow paths.",
      "description_length": 663,
      "index": 555,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.WitnessConstraints.PathSensitive3.C",
      "library": "goblint.lib",
      "description": "This module defines a constraint type `t` with operations for equality, hashing, comparison, and serialization, tailored for path-sensitive analysis in abstract interpretation. It supports generating unique IDs, pretty-printing, XML and JSON output, and arbitrary value generation for testing. Concrete use cases include tracking and comparing abstract states during path-sensitive static analysis and exporting analysis results for external consumption.",
      "description_length": 454,
      "index": 556,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.SpecLifters.LimitLifter.P",
      "library": "goblint.lib",
      "description": "This module defines a path-representative type `t` with operations for equality, hashing, comparison, and pretty-printing. It supports global constraint variables by providing unique tagging, serialization, and arbitrary instance generation for testing. Concrete use cases include tracking context identifiers in analysis witnesses and projecting constraint data through `of_elt`.",
      "description_length": 380,
      "index": 557,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.SpecLifters.WidenContextLifterSide.DD",
      "library": "goblint.lib",
      "description": "This module provides lattice operations (comparison, join, meet, widen, narrow) and utilities like top element checks and XML serialization for a hash-consed domain (`DD.t`) with unique context tagging. It is designed for abstract interpretation tasks requiring fixpoint stabilization and difference analysis, particularly in scenarios where structural equality and efficient state comparison are critical for static analysis workflows.",
      "description_length": 436,
      "index": 558,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.CommonPriv.PerMutexTidCommon.G",
      "library": "goblint.lib",
      "description": "This module provides lattice-based abstractions for tracking thread-modular analysis states, combining mutex and thread identifiers within a unified hierarchy. It supports operations to lift, widen, and compare tagged values representing either mutexes (`GMutex.t`) or threads (`GThread.t`), enabling precise state manipulation in static analysis contexts. The type hierarchy (`Bot`, `Top`, `Lifted1`, `Lifted2`) facilitates approximating program behavior across thread-mutex interactions, particularly useful for concurrency analysis in value-flow frameworks.",
      "description_length": 560,
      "index": 559,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.WrapperFunctionAnalysis.SpecBase.NodeFlatLattice",
      "library": "goblint.lib",
      "description": "This lattice implementation provides core operations\u2014leq, join, meet, widen, and narrow\u2014for a flat lattice structure with three states: bottom, top, and lifted node values. It operates on Node.t identifiers, organizing them into a hierarchical flat lattice to enable precise symbolic tracking of heap allocations and thread identifiers in wrapper function analyses. The design supports distinguishing symbolic states based on node context, which is critical for analyzing dynamic memory and thread creation patterns in library functions.",
      "description_length": 537,
      "index": 560,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Deadlock.Spec.LockEventPair",
      "library": "goblint.lib",
      "description": "This module represents pairs of lock events and provides operations to compare, hash, and serialize them. It works with tuples of two `LockEvent.t` values, primarily for analyzing potential deadlocks by examining ordered lock acquisitions. Concrete use cases include tracking lock sequences during static analysis and generating reports with human-readable or structured output for debugging.",
      "description_length": 392,
      "index": 561,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.ExtractPthread.Spec.P",
      "library": "goblint.lib",
      "description": "This module defines operations for managing globally constrained path-representative values in Promela extraction analysis. It provides equality checks, hashing, comparison, and serialization functions for type `t`, which represents abstract paths derived from Pthread program elements. These values are used to track and identify unique execution paths during analysis, supporting precise context-sensitive reasoning in witness generation.",
      "description_length": 440,
      "index": 562,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ExtractPthread.Spec.A",
      "library": "goblint.lib",
      "description": "This module defines operations for comparing, hashing, and displaying thread specification values, including checking potential races between thread actions and determining whether a value should be included in race output. It works with the abstract type `t` representing thread specifications, primarily used in concurrency analysis for identifying and tracking thread interactions. Concrete use cases include generating unique identifiers for thread contexts, pretty-printing for diagnostics, and supporting XML/Yojson serialization for external tools.",
      "description_length": 555,
      "index": 563,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.CommonPriv.ConfCheck.RequireThreadFlagPathSensInit",
      "library": "goblint.lib",
      "description": "This module enforces thread-flags path sensitivity during initialization by validating that required flags are set before analysis begins. It operates on thread state and flag configurations, ensuring correct setup for path-sensitive analyses. Used specifically in scenarios where thread-modular analysis depends on precise flag initialization.",
      "description_length": 344,
      "index": 564,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.SpecLifters.HashconsLifter.D",
      "library": "goblint.lib",
      "description": "This module provides lattice-theoretic operations (join, meet, widen, narrow, bot, top) and hash-consed equality management for an abstract domain, working with hash-consed values of type `D.t`. It supports static analysis tasks requiring efficient representation and comparison of abstract values, with utilities for serialization, XML output, and debugging via difference explanation. The hash-consed structure ensures canonical forms for values, optimizing memory usage and equality checks in abstract interpretation frameworks.",
      "description_length": 531,
      "index": 565,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.PrivPrecCompareUtil.Util.Dom",
      "library": "goblint.lib",
      "description": "This module implements lattice-theoretic operations and comparisons for a compound domain type, supporting abstract interpretation tasks. It works with values of type `t` (an alias for `ValueDomain.Compound.t`) to compute joins, meets, widening/narrowing sequences, and precision comparisons via `leq`, while providing standard utilities like top element checks and structured serialization. These operations enable static analysis workflows requiring precise domain value relationships and lattice manipulations.",
      "description_length": 513,
      "index": 566,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Control.AnalyzeCFG.LT",
      "library": "goblint.lib",
      "description": "This module implements lattice-theoretic operations (join, meet, widen, narrow) and set manipulations (union, intersection, membership checks) on collections of elements structured as sets. It works with data representing program states or constraints, following lattice theory principles for abstract interpretation. These capabilities are used in static analysis to compute program invariants and solve constraints over control flow paths during C program verification.",
      "description_length": 471,
      "index": 567,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MutexAnalysis.Spec.P",
      "library": "goblint.lib",
      "description": "This module provides lattice operations and utility functions for analyzing mutex-related states in static analysis. It works with a lattice type `t` built over a base domain `D.t`, representing locksets or protection states through operations like join, meet, widen, and narrowing, alongside serialization and testing tools. It is used in abstract interpretation frameworks to model and reason about possible locking behaviors in concurrent programs.",
      "description_length": 451,
      "index": 568,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.StackTrace.Spec2.A",
      "library": "goblint.lib",
      "description": "This module provides operations for handling unit values with comparison, equality, and hashing functions. It includes utilities for pretty-printing, serialization to JSON, and XML output, along with support for QCheck arbitrary value generation. Concrete use cases include representing empty or singleton states in call stack analyses and serving as a placeholder in higher-level data structures requiring a unit type.",
      "description_length": 419,
      "index": 569,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Control.AnalyzeCFG.Query",
      "library": "goblint.lib",
      "description": "This module provides functions to query local and global analysis results during control flow graph (CFG) analysis. It operates on abstract interpretation data structures including analysis states, variables, and nodes from the CFG. Concrete use cases include retrieving constraint solutions at specific program points or across the entire program during static analysis.",
      "description_length": 371,
      "index": 570,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.StackDomain.Dom1.Var",
      "library": "goblint.lib",
      "description": "This module provides lattice operations (join, meet, widen, narrow) and value manipulation (lift, relift) for abstract values in static analysis, handling combinations of bottom, top, and lifted values from an underlying variable lattice. It operates on a lattice domain constructed from a variable lattice type (`VarLat.t`), enabling precise dataflow analysis in scenarios requiring convergence through widening and narrowing, such as call stack analysis.",
      "description_length": 456,
      "index": 571,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Callstring.Spec.A",
      "library": "goblint.lib",
      "description": "This module defines operations for a call string analysis with support for infinite or bounded call strings (k-CFA), where the element type is specified by the `CT` argument. It provides equality, comparison, hashing, and serialization functions for the call string type `t`, along with utilities for race detection and pretty-printing. Concrete use cases include context-sensitive static analysis and concurrency race detection where call context must be uniquely identified and compared.",
      "description_length": 489,
      "index": 572,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Callstring.Spec.D",
      "library": "goblint.lib",
      "description": "This module provides lattice-theoretic operations for static analysis domains, including comparison, hashing, pretty-printing, and hierarchical context manipulation via join/meet/widen/narrow. It operates on abstract call string contexts (`t`) and domain elements (`D.t`) representing k-CFA analysis states with configurable call stack depth tracking. These capabilities enable context-sensitive data flow analysis, points-to analysis, and precision-controlled call graph reconstruction in program analysis workflows.",
      "description_length": 517,
      "index": 573,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.CommonPriv.PerMutexTidCommon.LMust",
      "library": "goblint.lib",
      "description": "This module supports set-theoretic operations and lattice-based analysis for tracking lock states in concurrent programs, working with a polymorphic variant type that represents either a concrete set of locks (`Lifted`) or an abstract top element. It provides standard set manipulations like union and filtering alongside lattice operations such as widening and join/meet, tailored for abstract interpretation in thread-modular static analysis. The design addresses concurrency control scenarios where lock sets must model uncertainty (via `Top`) or precise initialization states, particularly for C program analysis with Goblint's value analysis framework.",
      "description_length": 657,
      "index": 574,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ExpRelation.Spec.P",
      "library": "goblint.lib",
      "description": "This module defines path-representative values for symbolic expression comparisons, providing equality checks, hashing, and comparison operations. It works with symbolic expressions to determine syntactic equivalence relations, specifically for `=_{must}` comparisons. Used to project and compare expression relationships within global constraint analysis.",
      "description_length": 356,
      "index": 575,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Region.Spec.Lvals",
      "library": "goblint.lib",
      "description": "This module provides set-theoretic operations (union, intersection, difference) and lattice operations (join, meet, widening) over collections of memory expressions (`Mval.Exp.t`), enabling precise manipulation and comparison of abstract memory regions. It supports static analysis tasks like region-based race detection by modeling disjoint heap regions through ordered, serializable sets with traversal, transformation, and partitioning utilities. The structure is optimized for static program analysis workflows requiring efficient abstraction of dynamically allocated memory regions.",
      "description_length": 587,
      "index": 576,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.LoopTermination.Spec.P",
      "library": "goblint.lib",
      "description": "This module defines operations for handling path-representative constraint variables, including equality checks, hashing, comparison, and string representation. It works with a concrete type `t` that represents constraints in termination analysis, primarily used for tracking unique identifiers and relationships between loop paths. Functions like `tag`, `of_elt`, and `relift` support constraint manipulation and projection, enabling precise analysis of loop termination conditions in program verification.",
      "description_length": 507,
      "index": 577,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Assert.Spec.P",
      "library": "goblint.lib",
      "description": "This module defines a path-representative type `t` used for tracking unique identifiers in global constraint analysis. It provides equality checks, hashing, comparison, and serialization operations for managing path representatives in witness generation. The type supports conversion from domain elements and is used to identify contexts during constraint solving.",
      "description_length": 364,
      "index": 578,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.CompareConstraints.CompareNode.NH",
      "library": "goblint.lib",
      "description": "This module implements imperative hash tables with `Node.t` keys and polymorphic values, supporting insertion, lookup, deletion, and traversal, along with transformations like mapping, filtering, and merging. It integrates labeled node management for constraint graphs, infix operators for key-based access and updates, and safe modification operations that handle exceptions. You can track variable constraints during analysis, manage dependencies, retrieve or update values using symbolic keys, and perform robust modifications in concurrent settings. The module combines direct hash table manipulation with specialized submodules for constraint propagation, named state handling, and error-resilient updates.",
      "description_length": 711,
      "index": 579,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Base.MainFunctor.VarH",
      "library": "goblint.lib",
      "description": "This module manages variable maps with a focus on safe and efficient manipulation of variable bindings in static analysis contexts. It provides the core `VarH.t` type for variable-labeled hashtables, supporting both functional and imperative operations like `add`, `map`, `fold`, and `merge`, along with exception-safe access and modification through `-->` and `<--` operators. You can use it to track variable values across program points, filter unused variables, or merge analysis results without handling `Not_found` exceptions. The module enables concise, direct transformations of variable state during static analysis passes.",
      "description_length": 632,
      "index": 580,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MutexAnalysis.Spec.A",
      "library": "goblint.lib",
      "description": "This module provides lattice-based set operations and transformations for analyzing must-lock read/write constraints in static analysis. It works with lifted sets of `MustLockRW` elements augmented with `Top`/`Lifted` semantics, supporting operations like union, subset checks, widening/narrowing, and conversions to concrete locksets. These capabilities enable tracking and combining lock dependencies in mutex analysis, with utilities for debugging (XML/printing) and testing (arbitrary value generation).",
      "description_length": 507,
      "index": 581,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.CommonPriv.MutexGlobals.V",
      "library": "goblint.lib",
      "description": "This module defines a polymorphic variant type `t` that represents three distinct categories of values related to mutex and global variable handling in a thread-modular analysis. It provides operations for equality checking, comparison, hashing, and conversion between these categories, along with utilities for pretty-printing, serialization to XML and JSON, and generating string representations. Concrete use cases include tracking mutex states, global variable initializations, and lifting values between analysis domains during static analysis of concurrent programs.",
      "description_length": 572,
      "index": 582,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ArgTools.Make.Query",
      "library": "goblint.lib",
      "description": "This module provides functions to query local and global analysis results within a constraint system solution. It operates on data structures including constraint graphs, nodes, and analysis states, enabling precise lookups during abstract interpretation. Concrete use cases include retrieving variable values at specific program points or obtaining global invariants from fixed-point computations.",
      "description_length": 398,
      "index": 583,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Server.Locator.ES",
      "library": "goblint.lib",
      "description": "This module manages ordered collections of symbolic identifiers with set algebra operations like union, intersection, and difference, while supporting efficient membership checks and rank-based element retrieval. Its core functionality enables structured handling of server state in JSON-RPC contexts, such as tracking ordered event streams or client sessions. Submodule 1 provides safe, exception-free queries for elements like min, max, or key-based lookups returning `option` values, ideal when element presence is uncertain. Submodule 2 supports iteration, transformation, and filtering over sets, particularly useful for processing code locations or applying bulk operations across JSON-RPC server data.",
      "description_length": 708,
      "index": 584,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MutexTypeAnalysis.Spec.A",
      "library": "goblint.lib",
      "description": "This module defines operations for comparing, hashing, and displaying mutex type analysis values, including checking race conditions between types and determining output visibility. It works with the abstract type `t` representing mutex types in the analysis. Concrete use cases include identifying conflicting mutex types during concurrency analysis and formatting results for reporting.",
      "description_length": 388,
      "index": 585,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Callstring.Spec.V",
      "library": "goblint.lib",
      "description": "This module defines and manipulates globally unique constraint variables used in the analysis. It supports operations for equality checking, hashing, comparison, and pretty-printing, along with serialization to XML and Yojson formats. These variables are used to represent and track distinct analysis contexts with unique identifiers, primarily in constraint-based analyses.",
      "description_length": 374,
      "index": 586,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.SpecLifters.LimitLifter.C",
      "library": "goblint.lib",
      "description": "This module provides operations for managing and manipulating a type `t` that represents analysis contexts with limited widenings per node. It includes equality checks, hashing, comparison, string representation, XML and JSON serialization, and functions for relifting contexts. Concrete use cases include tracking and controlling analysis precision in static program analysis by limiting widenings and ensuring unique context identification.",
      "description_length": 442,
      "index": 587,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.CommonPriv.PerMutexTidCommon.W",
      "library": "goblint.lib",
      "description": "This library component offers a lattice-based abstraction for tracking may-written variables through thread-modular analysis, supporting comparison, lattice operations (join, meet, widen), and set manipulations (union, subset, cardinality checks) on a structure that combines finite sets of variables or a top element. It works with sets of variables from `Basetype.Variables.t`, enabling abstract interpretation in concurrent program analysis to model thread-local and shared variable modifications while balancing precision and scalability.",
      "description_length": 542,
      "index": 588,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.ExtractPthread.Tbls.Tbl",
      "library": "goblint.lib",
      "description": "This module provides a mutable key-value store with operations to add entries, retrieve values by key, and find keys by value. It works with key-value pairs of types determined by the parameter module `G`. Concrete use cases include tracking variable mappings during Pthread program analysis and maintaining state during Promela extraction.",
      "description_length": 340,
      "index": 589,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.YamlWitness.Make.FCMap",
      "library": "goblint.lib",
      "description": "This module combines a hybrid functional/imperative map structure with specialized operations for managing key-value pairs indexed by function declarations and specification contexts. It supports merging hierarchical specifications, filtering by code elements, and domain-specific aggregations, while enabling direct manipulation of YAML witness paths through key-indexed transformations. The structure integrates submodules for string-keyed map manipulation, safe value access with optional keys, and thread-safe operations via infix notation, allowing tasks like structured YAML updates, conditional entry modifications, and concurrent map interactions. Specific applications include validating analysis results, transforming witness data, and managing configuration maps in multi-threaded static analysis workflows.",
      "description_length": 818,
      "index": 590,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.SpecLifters.HashconsContextLifter.P",
      "library": "goblint.lib",
      "description": "This module provides operations for managing hash-consed context identifiers, including equality checks, hashing, comparison, and pretty-printing. It works with a hash-consed type `t` derived from a base type `D.t`, supporting efficient context identification via unique tags. Concrete use cases include tracking distinct analysis contexts in static analysis, where path-representative identifiers are needed for constraint solving and witness generation.",
      "description_length": 455,
      "index": 591,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.CommonPriv.PerMutexTidCommon.D",
      "library": "goblint.lib",
      "description": "This module provides lattice-based abstract interpretation operations\u2014such as join, meet, widen, and narrowing\u2014with a focus on combining and comparing a composed lattice-like domain type (`t`) built from `W.t`, `LMust.t`, and `L.t`. It supports testing and visualization through QCheck generators and lattice-aware pretty-printing of differences, targeting thread-modular analysis of concurrent programs and verification of lattice domain correctness. The operations are designed for static analysis frameworks requiring precise state merging and debugging of hierarchical data-flow properties.",
      "description_length": 594,
      "index": 592,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.CommonPriv.Locksets.MinLocksets",
      "library": "goblint.lib",
      "description": "This module provides lattice operations and set-like manipulations for minimal locksets, enabling precise thread-modular analysis of concurrent programs. It works with abstract lockset elements (`MustLockset.t`) and structures like persistent sets (`MinLocksets.t`) to track, partition, and transform lock ownership states. Key use cases include static analysis for identifying race conditions and ensuring thread-safety by modeling lock acquisition patterns in multithreaded code.",
      "description_length": 481,
      "index": 593,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Preprocessor.FpathH.Exceptionless",
      "library": "goblint.lib",
      "description": "This module provides operations for safely modifying and querying a hash table with exception handling. It works with typed hash tables and their keys, returning results as either values or exceptions. Concrete use cases include updating or retrieving values in a thread-safe hash table without direct exception propagation.",
      "description_length": 324,
      "index": 594,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MayLocks.Spec.V",
      "library": "goblint.lib",
      "description": "This module defines operations for comparing, hashing, and converting to string or XML may-lock values, which represent potential lock states in concurrency analysis. It supports concrete use cases like tracking lock acquisition and release in static analysis to detect double locking or deadlocks. Functions include equality checks, pretty-printing, JSON serialization, and generating arbitrary values for testing.",
      "description_length": 415,
      "index": 595,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Constants.Spec.V",
      "library": "goblint.lib",
      "description": "This module defines operations for managing global constraint variables used in an intraprocedural constants analysis. It supports equality checks, hashing, comparison, and string/XML/JSON representations of constraint variables, primarily working with a unique, hashed type `t`. These variables track definite local variable values within a function, enabling precise constraint propagation and analysis in a verification context.",
      "description_length": 431,
      "index": 596,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Deadlock.Spec.MayLockEventPairs",
      "library": "goblint.lib",
      "description": "This module implements a lattice structure and set algebra for analyzing potential lock event pairs in deadlock detection. It operates on sets of `LockEventPair.t` values, offering operations like union, intersection, membership checks, and lattice join/meet to model possible lock acquisition orders. These capabilities are specifically used to track and reason about concurrent lock pairs that may contribute to deadlock states in program analysis.",
      "description_length": 450,
      "index": 597,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.ThreadReturn.Spec.V",
      "library": "goblint.lib",
      "description": "This module defines a specification for global constraint variables used in thread-return analysis, where each variable represents whether a thread is at the topmost call stack frame. It provides operations for equality checking, hashing, comparison, string representation, and serialization, working with a custom abstract type `t`. These variables are used to track and constrain thread behavior in static analysis, ensuring precise identification of thread entry and exit points.",
      "description_length": 482,
      "index": 598,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Deadlock.Spec.A",
      "library": "goblint.lib",
      "description": "This module defines operations for a singleton type `t` used in deadlock analysis, including equality, comparison, and hashing functions. It provides utilities for pretty-printing, serialization to JSON, and XML output, along with functions to determine race conditions and whether a value should be printed. Concrete use cases include representing abstract deadlock states and supporting analysis reporting and testing through QCheck arbitraries.",
      "description_length": 447,
      "index": 599,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Signs.Spec.G",
      "library": "goblint.lib",
      "description": "This lattice structure provides operations for representing and manipulating integer sign states in static analysis, including join/meet for combining abstract values, widen/narrow for convergence control, and comparison/serialization utilities. It works with an abstract type `t` modeling sign information (positive, negative, zero, or unknown) and supports lattice-theoretic queries like checking top elements. The structure is used in intraprocedural sign analysis to track variable ranges, enable domain refinement through relifting, and output analysis results in formats like XML or JSON for debugging.",
      "description_length": 608,
      "index": 600,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.WitnessUtil.Locator.FileH",
      "library": "goblint.lib",
      "description": "This module implements a mutable hash table for string keys and arbitrary values, optimized for managing file handle mappings in witness generation workflows. It provides imperative operations for insertion, lookup, and in-place modification, along with advanced transformations like filtering, merging, and conversion to sequences and lists. The core functionality is extended by submodules that offer safe, exception-free access, infix operators for concise key-based updates, and labeled operations for precise manipulation of file-located data. Examples include tracking per-file metadata, merging analysis results, and enforcing invariants during structured file traversal.",
      "description_length": 678,
      "index": 601,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.CompareConstraints.CompareGlobSys.PP",
      "library": "goblint.lib",
      "description": "This module organizes a polymorphic map-like structure (`t`) with keys as `Node.t` identifiers and arbitrary values, enabling dictionary operations, functional transformations, and sequence conversions. It supports key-aware manipulations such as conditional updates, filtering, and merging, along with utilities to convert between constraint systems and enumerable key-value representations, facilitating structured analysis of node-indexed data. Submodules extend its capabilities with safe querying and updating via `result`-typed operations, parameterized map manipulations using key-based predicates, and infix operators `-->` and `<--` for concise pretty-printing context management. Examples include tracking labeled constraints during static analysis, transforming node-associated data under specific conditions, and formatting structured output with context-sensitive bindings.",
      "description_length": 886,
      "index": 602,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.SpecLifters.WidenContextLifterSide.D",
      "library": "goblint.lib",
      "description": "This module combines two abstract domains into a product lattice with structural equality, offering standard operations like widening, narrowing, and meet/join over pairs of contexts. It supports manipulation of analysis contexts as tuples (S.D.t * M.t), enabling JSON/XML serialization, difference reporting, and test value generation. These capabilities are particularly useful in static analysis for managing complex state representations and persisting analysis results in multiple formats.",
      "description_length": 494,
      "index": 603,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.SymbLocks.Spec.A",
      "library": "goblint.lib",
      "description": "This module combines lattice operations with structured set manipulations to model symbolic lock behavior for static race detection in concurrent systems. It defines a core type `t` as a polymorphic variant of either symbolic or integer locks, supporting operations such as join, meet, union, and filtering, along with serialization and comparison utilities. Submodules refine this abstraction by associating locks with memory offsets and providing arbitrary value generation for testing, enabling precise tracking of per-element locking in data structures. Example uses include analyzing locking patterns in device drivers to detect concurrency issues during static analysis.",
      "description_length": 676,
      "index": 604,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Assert.Spec.G",
      "library": "goblint.lib",
      "description": "This module provides lattice operations for an abstract type `t` representing assertion states, including join, meet, widen, and narrow for combining and approximating values, along with comparison, display, and serialization functions. It supports static analysis by modeling program invariants through a hierarchy of extremal states (top/bot) and tracking differences between lattice elements. Use cases include abstract interpretation for program verification and generating explanations for assertion mismatches.",
      "description_length": 516,
      "index": 605,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.WrapperFunctionAnalysis.MallocWrapper.G",
      "library": "goblint.lib",
      "description": "This module provides lattice operations (meet, join, top) and comparisons for an abstract domain modeling symbolic heap locations derived from program nodes and thread identifiers. It operates on a symbolic type `t` that represents dynamic memory allocations in static analysis, enabling precise tracking of heap-allocated data structures through wrapper functions. The analysis aids memory safety verification and points-to analysis in C programs by distinguishing allocations based on their contextual execution state.",
      "description_length": 520,
      "index": 606,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.YamlWitnessType.ViolationSequence.Branching",
      "library": "goblint.lib",
      "description": "This module defines operations for handling branching structures in violation sequences of a YAML witness format. It includes parsing from YAML, comparing branching instances, and specifying a waypoint type. Concrete use cases include analyzing and validating branching paths in program verification witnesses.",
      "description_length": 310,
      "index": 607,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.SpecLifters.OptEqual.V",
      "library": "goblint.lib",
      "description": "This module defines operations for managing global constraint variables, including equality checks, hashing, comparison, and string representation. It works with the abstract type `t` representing constraint variables, providing functions for pretty-printing, XML serialization, and JSON conversion. Concrete use cases include tracking and comparing constraint variables during static analysis, supporting arbitrary generation for testing, and identifying variables uniquely via tags for witness generation.",
      "description_length": 507,
      "index": 608,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MutexTypeAnalysis.Spec.G",
      "library": "goblint.lib",
      "description": "This module implements lattice operations for a static analysis domain modeling mutex type states, including join, meet, widen, and narrow functions to track possible type values. It operates on a lattice-structured abstract type representing mutex types, with support for comparison, hashing, and extremal value checks like top and bottom elements. The lattice is specifically used in concurrency analysis to model the flow-sensitive state of mutexes in programs, enabling properties like deadlock detection through abstract interpretation.",
      "description_length": 541,
      "index": 609,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Control.AnalyzeCFG.PostSolverArg",
      "library": "goblint.lib",
      "description": "Implements post-analysis operations for control flow graphs after constraint solving, handling pruning, verification, warning generation, and run persistence based on boolean flags. Works with CFG structures and analysis results from constraint solving. Used to control post-processing behavior during static analysis runs, such as deciding whether to emit warnings or save analysis state.",
      "description_length": 389,
      "index": 610,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ObserverAnalysis.MakeSpec.C",
      "library": "goblint.lib",
      "description": "This module defines a specification for a context type used in a path-sensitive analysis framework. It includes operations for equality checking, hashing, comparison, string representation, and serialization to XML and JSON formats. It is used to uniquely identify and manage analysis contexts during symbolic execution or abstract interpretation.",
      "description_length": 347,
      "index": 611,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MayLocks.Spec.D",
      "library": "goblint.lib",
      "description": "The module provides lattice operations (join, meet, widen) and type utilities (equality, hashing, serialization) for a may-lock analysis data type. It manipulates abstract locksets represented as lattice elements to model potential concurrency issues in programs. This supports static analysis tasks like detecting double locking by tracking sets of locks that may be held at runtime.",
      "description_length": 384,
      "index": 612,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Deadlock.Spec.D",
      "library": "goblint.lib",
      "description": "This module provides lattice operations for deadlock analysis, including element comparison, combination (join/meet), and extremal values (top/bottom), with support for semantic representations. It operates on lattice elements representing deadlock states, tracking lock acquisition patterns and thread interactions. These operations enable static analysis to detect potential deadlocks by modeling the flow of lock states across program paths.",
      "description_length": 444,
      "index": 613,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Witness.Result.ArgTool",
      "library": "goblint.lib",
      "description": "This module manages argument indexing and querying for analysis results in a constraint system, working with tuples of control flow nodes, constraints, and indices through a bi-directional structure. It supports direct operations like `get` for retrieving data and `ask_indices` for resolving variable indices, while its submodules enhance node-keyed storage, ARG node manipulation, and analysis result queries. It enables tasks like tracking metadata, refining analysis outcomes, and extracting variable values at program points, with support for efficient lookups, node transformations, and graph-based queries. Key data types include nodes, constraints, indices, and typed key-value maps, with operations spanning equality checks, hashing, conditional updates, and path-based analysis.",
      "description_length": 788,
      "index": 614,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ExtractPthread.Tbls.CtxTbl",
      "library": "goblint.lib",
      "description": "Maps integer keys to integer values with thread context tracking. Provides operations to retrieve values by key, safely access optional values, and list all key-value pairs. Used to manage per-thread state during Pthread program analysis.",
      "description_length": 238,
      "index": 615,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.SpecLifters.DeadBranchLifter.P",
      "library": "goblint.lib",
      "description": "This module defines operations for managing path-representative values used in constraint analysis, including equality checks, hashing, comparison, and string representation. It works with a concrete type `t` that represents paths, supporting serialization, pretty-printing, and generation of arbitrary values for testing. Concrete use cases include tracking and comparing execution paths in static analysis and generating unique identifiers for path-based constraints.",
      "description_length": 469,
      "index": 616,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ArgTools.Make.Node",
      "library": "goblint.lib",
      "description": "This module implements operations for manipulating and analyzing abstract reachability graph (ARG) nodes, including equality checks, comparisons, hashing, and string representation. It works with tuples of control flow graph nodes, specification contexts, and integers, providing functions to extract components, check liveness, and compute node transitions. Concrete use cases include constructing and traversing ARGs from constraint system solutions for program analysis tasks like invariant generation and bug detection.",
      "description_length": 523,
      "index": 617,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.RecursionTermLifter.Lifter.C",
      "library": "goblint.lib",
      "description": "Implements equality, hashing, comparison, and serialization for a context-sensitive call graph node type `t`. Provides operations for pretty-printing, XML output, JSON conversion, and generating arbitrary values for testing. Used to manage unique identification and structural equivalence of recursion terms in a dynamic analysis.",
      "description_length": 330,
      "index": 618,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.SpecLifters.OptEqual.G",
      "library": "goblint.lib",
      "description": "This component defines lattice operations (join, meet, widen, narrow), equality checks, and extremal value detection for a generic type `G.t`, which is typically used in abstract interpretation frameworks. It supports static analysis tasks by enabling comparison and combination of abstract domain values, with utilities for pretty-printing, serialization, and test generation via QCheck. The operations are particularly suited for dataflow analysis where tracking and merging program states requires precise lattice semantics and equivalence checks.",
      "description_length": 550,
      "index": 619,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.SpecLifters.HashconsLifter.P",
      "library": "goblint.lib",
      "description": "This module provides operations for managing hash-consed path representatives with unique identifiers, including equality checks, hashing, comparison, and serialization. It works with a hash-consed domain type `t` derived from a base type `D.t`. Concrete use cases include tracking unique path identifiers in static analysis and generating XML or JSON representations for debugging and witness generation.",
      "description_length": 405,
      "index": 620,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.SpecLifters.LimitLifter.G",
      "library": "goblint.lib",
      "description": "This module provides lattice operations such as join, meet, widen, and narrow for the `G.t` type, including top and bottom elements, alongside serialization and comparison utilities. It supports context-sensitive static analysis by structuring abstract domains to manage fixed-point computations with bounded widenings per node, enabling witness generation and differencing explanations for program analysis.",
      "description_length": 408,
      "index": 621,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.StackTrace.Spec1.D",
      "library": "goblint.lib",
      "description": "This module provides lattice operations (join, meet, widen, narrow) and stack manipulation primitives (push, top) for analyzing hierarchical program states. It operates on abstract values representing call stacks, where elements are structured as a lattice with bottom and top markers, and incorporates variables from a base type domain. These capabilities enable tracking and merging of dynamic call paths in static analysis scenarios, such as identifying variable flow across nested function calls or detecting recursion patterns.",
      "description_length": 532,
      "index": 622,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.BaseDomain.CPA.M0",
      "library": "goblint.lib",
      "description": "This module implements a map-based abstract domain with lattice operations for static analysis, using variables as keys and abstract values to model program states. It provides associative map functionality for key-value manipulation alongside structural comparison, merging, and fixpoint computation support through join, meet, and widen operations. Designed for control flow analysis, it enables tracking variable relationships and combining abstract states during iterative fixpoint calculations, with utilities for pretty-printing and XML/JSON serialization.",
      "description_length": 562,
      "index": 623,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.StackTrace.Spec2.D",
      "library": "goblint.lib",
      "description": "This module supports lattice operations (join, meet, widening) and stack manipulation primitives (push, top checks) for abstract interpretation of call stack states. It operates on two core types: a lattice-based domain for abstract stack values and a specialized stack trace element structure that tracks variable-specific context. These capabilities enable static analysis of program paths with precise variable flow tracking through nested function calls.",
      "description_length": 458,
      "index": 624,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ObserverAnalysis.MakePathSpec.V",
      "library": "goblint.lib",
      "description": "This module defines a data type `t` representing global constraint variables used in path-sensitive analysis. It provides operations for equality checking, hashing, comparison, string representation, and serialization to XML and Yojson formats. These variables are used to track and identify constraints across different analysis contexts, particularly in generating and handling witnesses with unique identifiers.",
      "description_length": 414,
      "index": 625,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.ThreadJoins.Spec.D",
      "library": "goblint.lib",
      "description": "This module provides lattice operations (join, meet, widen, narrow) and comparison utilities for a product domain combining thread ID tracking (`MustTIDs`) and exit state analysis (`CleanExit`), supporting abstract interpretation of concurrent programs. It enables serialization to XML/JSON, pretty-printing, and test generation for specifications in thread-joined analysis scenarios, particularly for validating inter-thread dependencies and clean termination conditions in static analyzers.",
      "description_length": 492,
      "index": 626,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Signs.Spec.C",
      "library": "goblint.lib",
      "description": "This module represents abstract values for integer signs in a static analysis, supporting operations like equality checks, comparison, and conversion to strings or JSON. It works with a custom type `t` that encodes sign information, such as positive, negative, or zero. Used to track and reason about the sign of integer variables during intraprocedural analysis of C programs.",
      "description_length": 377,
      "index": 627,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ExtractPthread.Codegen.Writer",
      "library": "goblint.lib",
      "description": "Handles Promela code generation for Pthread programs by writing output to files. Works with strings representing file paths and Promela code. Used to serialize analysis results into valid Promela models for verification tools.",
      "description_length": 226,
      "index": 628,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.MallocFresh.Spec.D",
      "library": "goblint.lib",
      "description": "This module provides standard set operations (union, subset, filter) and lattice operations (join, meet, widening) for managing sets of C variables (`CilType.Varinfo`) represented in a lifted domain that includes a top element for abstraction. It supports static analysis tasks like tracking unescaped heap allocations by enabling precise set manipulation, comparison, and approximation of variable relationships during abstract interpretation. Key use cases include merging abstract states, determining variable inclusion in thread-local allocations, and serializing analysis results for diagnostics.",
      "description_length": 601,
      "index": 629,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MutexEventsAnalysis.Spec.G",
      "library": "goblint.lib",
      "description": "This lattice structure provides operations for comparing, combining, and transforming abstract states representing mutex event sequences, including join, meet, widen, and narrow for monotonic analysis. It manipulates lattice elements that model runtime mutex locking behaviors and a distinguished top value to denote unreachable or over-approximated states. Designed for static analysis of concurrent programs, it enables tracking lock/unlock event dependencies to detect synchronization errors or validate thread safety properties.",
      "description_length": 532,
      "index": 630,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.SymbLocksDomain.ILock.Idx",
      "library": "goblint.lib",
      "description": "This module defines operations for handling index values in an index-based symbolic lock domain, including equality checks, comparison, hashing, and string representation. It works with the variant type `t` representing lock indices, which can be `Unknown`, `Star`, or concrete values derived from the index type. Concrete use cases include tracking and comparing symbolic lock indices during static analysis to manage thread synchronization and detect potential concurrency issues.",
      "description_length": 482,
      "index": 631,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.SpecLifters.HashconsContextLifter.V",
      "library": "goblint.lib",
      "description": "This module provides operations for managing hash-consed context values with globally unique identifiers, including equality checks, hashing, comparison, and pretty-printing. It works with a hash-consed type `t` that represents analysis contexts, supporting concrete use cases like tracking context identities in static analysis and generating unique tags for witness identification. Functions like `tag` and `relift` enable context manipulation and relifting, while `is_write_only` indicates context mutability properties.",
      "description_length": 523,
      "index": 632,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.WideningTokenLifter.Lifter.V",
      "library": "goblint.lib",
      "description": "This module defines global constraint variables with operations for equality checking, hashing, comparison, and pretty-printing. It supports concrete use cases like tracking unique variable identifiers in abstract domains and managing context-sensitive analysis states. The type `t` represents these variables, with functions like `tag` providing unique IDs for identification in witnesses and `relift` enabling variable state transitions during analysis.",
      "description_length": 455,
      "index": 633,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.BaseDomain.PartDeps.VarSet",
      "library": "goblint.lib",
      "description": "This module provides standard set operations (union, intersection, difference), lattice operations (join, meet, widen), and utilities for serialization and testing, all tailored for handling collections of variables. It operates on immutable sets (`VarSet.t`) containing elements of type `Basetype.Variables.t`, designed for functional manipulation. These capabilities support dataflow analysis in abstract interpretation frameworks, enabling efficient tracking and transformation of variable sets through operations like partitioning, extremum extraction, and cardinality checks.",
      "description_length": 580,
      "index": 634,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.LocksetAnalysis.MakeMay.P",
      "library": "goblint.lib",
      "description": "This module implements a may-lockset analysis where the abstract state tracks sets of locks that might be held at each program point. It operates over a unit type abstract domain, using equality, comparison, and pretty-printing functions to manage and display lockset information. It is used to infer potential lock dependencies and detect possible concurrency issues in programs.",
      "description_length": 380,
      "index": 635,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.LocksetAnalysis.MakeMust.D",
      "library": "goblint.lib",
      "description": "This lattice structure implements standard operations like join, meet, widen, and narrowing for abstract lockset states, along with utilities for equality, hashing, serialization, and testing. It manipulates values representing abstracted lockset data in static analysis, specifically for tracking synchronization primitives in concurrent programs. The design enables detecting concurrency issues like race conditions or deadlocks by modeling lock acquisition patterns during program analysis.",
      "description_length": 493,
      "index": 636,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.LoopfreeCallstring.Spec.V",
      "library": "goblint.lib",
      "description": "This module defines operations for handling loop-free call strings with cycle detection and compression. It provides equality checks, hashing, comparison, and string representations for call strings that collapse repeated call sequences into sets. These operations are used to manage and analyze recursive function calls more efficiently by reducing redundancy in call string representations.",
      "description_length": 392,
      "index": 637,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.WideningTokenLifter.Lifter.P",
      "library": "goblint.lib",
      "description": "This module defines path-representative tokens for tracking and delaying widening in abstract domains. It provides operations for creating, comparing, and serializing these tokens, along with a projection function from domain elements to tokens. Concrete use cases include managing widening delays in static analysis based on path-sensitive conditions.",
      "description_length": 352,
      "index": 638,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.LoopfreeCallstring.Spec.G",
      "library": "goblint.lib",
      "description": "This module provides lattice operations (join, meet, widen) and structural utilities (equality, hashing, ordering) for a compact callstring representation that replaces recurring cycles with sets of functions (e.g., `main, {a, b, c}`). It operates on loop-free callstrings derived from recursive program paths, where cycles are collapsed into unordered groups to reduce analysis overhead. This structure is particularly useful in static analysis for context-sensitive abstract interpretation, enabling efficient handling of recursive functions while preserving precision in cyclic call chains.",
      "description_length": 593,
      "index": 639,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MemLeak.Spec.A",
      "library": "goblint.lib",
      "description": "This module defines operations for comparing, hashing, and displaying memory leak analysis values, including functions for generating unique identifiers, pretty-printing, XML serialization, and JSON conversion. It works with the abstract type `t` representing memory leak states, supporting equality checks, ordering, and arbitrary value generation for testing. Concrete use cases include tracking and identifying memory leaks during static analysis, determining race conditions between states, and producing human-readable or structured output for debugging and reporting.",
      "description_length": 573,
      "index": 640,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ActiveSetjmp.Spec.P",
      "library": "goblint.lib",
      "description": "This module provides lattice-based operations such as join, meet, widen, and narrow, alongside comparison, ordering, and top element management for an abstract type `t`. Designed for static analysis, it models active setjmp buffer states in Goblint, enabling precise dataflow analysis by representing and manipulating abstract program domains. The type `t` serves as a foundational structure for tracking buffer lifetimes and control-flow sensitivity in C programs.",
      "description_length": 465,
      "index": 641,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.YamlWitnessType.InvariantSet.LoopInvariant",
      "library": "goblint.lib",
      "description": "This module defines and processes loop invariants in a YAML-based witness format. It supports parsing loop invariant data from YAML values, comparing invariant records, and identifying the invariant type. It works with loop invariant structures that include location, value, and format fields, and is used to validate and manipulate loop invariant information in static analysis witnesses.",
      "description_length": 389,
      "index": 642,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.CompareConstraints.CompareHashtbl.Var",
      "library": "goblint.lib",
      "description": "This module provides hash table operations for variable constraints using a custom equality and hashing function. It works with the `Var.t` type, ensuring consistent key comparison and hashing for variables in constraint systems. Concrete use cases include tracking variable identities, comparing variables for structural or address-based equality, and integrating with pretty-printing or serialization tools for analysis diagnostics.",
      "description_length": 434,
      "index": 643,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.WitnessConstraints.PathSensitive3.G",
      "library": "goblint.lib",
      "description": "This module provides lattice operations for path-sensitive static analysis, including join, meet, widen, and narrow functions to combine or compare abstract values. It operates on the abstract type `G.t`, which represents lattice elements with defined equality, ordering, and serialization capabilities. These operations are used to model program abstractions that track value constraints across different execution paths, enabling precise analysis of branching behaviors in code.",
      "description_length": 480,
      "index": 644,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.YamlWitness.Make.NH",
      "library": "goblint.lib",
      "description": "This module manages imperative hash tables mapping `Node.t` keys to arbitrary values, supporting dynamic node-value tracking with operations for insertion, lookup, in-place modification, and conversion to lists or sequences. Its nested hash table submodules enable safe hierarchical access through `find` and `modify` functions, returning `result`-typed values to handle missing keys or errors internally. Infix operators allow concise key-based access and updates in nested structures, ideal for configuration or log data with hierarchical keys. Labeled hierarchical operations further support typed key-value manipulation, enabling precise transformations and merges of structured data like YAML witnesses.",
      "description_length": 708,
      "index": 645,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MHPAnalysis.Spec.A",
      "library": "goblint.lib",
      "description": "This module implements may-happen-in-parallel (MHP) analysis for concurrent programs, determining whether two program points may execute in parallel based on thread creation, joining, and execution state. It operates on thread identifiers and sets, tracking which threads may be running or must have completed at a given point. Concrete use cases include detecting potential race conditions between memory accesses and optimizing synchronization operations in static analysis of multithreaded code.",
      "description_length": 498,
      "index": 646,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ExtractPthread.Tbls.CondVarIdTbl",
      "library": "goblint.lib",
      "description": "This module implements a bidirectional mapping between condition variable names and unique identifiers for Pthread-based Promela extraction. It provides operations to retrieve identifiers by name, names by identifier, and to list all name-identifier pairs. It is used to track condition variables during the translation of Pthread programs into Promela for model checking.",
      "description_length": 372,
      "index": 647,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ExtractPthread.Spec.G",
      "library": "goblint.lib",
      "description": "This module provides lattice-theoretic operations (join, meet, widen, narrow, top, bot) and serialization capabilities (XML, JSON, pretty-printing) for an abstract type modeling concurrency access states. It operates on a lattice structure representing possible runtime states of Pthread programs during Promela extraction analysis, enabling abstract interpretation of thread interactions and synchronization. The lattice operations facilitate static analysis by tracking hierarchical relationships between concurrency states, while serialization supports debugging and verification workflows in program analysis pipelines.",
      "description_length": 623,
      "index": 648,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.ObserverAnalysis.MakePathSpec.G",
      "library": "goblint.lib",
      "description": "This module supports path-sensitive analysis by defining a lattice structure over abstract paths in a control-flow graph, with operations like `join`, `meet`, `widen`, and `narrow` to merge and approximate path states. It works with values of type `G.t` representing abstract paths, providing comparison, display, and lattice-specific functionality for static analysis domains. These tools enable use cases such as tracking context-sensitive program state transitions and merging divergent path information at control-flow join points.",
      "description_length": 535,
      "index": 649,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.LongjmpLifter.Lifter.P",
      "library": "goblint.lib",
      "description": "This module defines a path-representative type `t` with operations for equality, hashing, comparison, and serialization. It works with global constraint variables and supports lifting and projection to and from another type `D.t`. Concrete use cases include tracking unique identifiers for context-sensitive analysis and enabling witness-based reasoning in constraint systems.",
      "description_length": 376,
      "index": 650,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.PthreadSignals.Spec.G",
      "library": "goblint.lib",
      "description": "This module provides lattice operations and utilities for abstract analysis states tracking Pthread condition variable signals. It works with lattice elements of type `t` that model concurrency-related signal propagation in static analysis. These structures are used to implement must-received signal analysis for verifying thread synchronization correctness in concurrent programs.",
      "description_length": 382,
      "index": 651,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Taint.Spec.P",
      "library": "goblint.lib",
      "description": "This module defines a path-representative type `t` used to track unique identifiers for taint analysis contexts. It provides equality, hashing, comparison, and pretty-printing operations, along with serialization to XML and Yojson formats. The type is used in witness generation and constraint solving to represent distinct taint paths during analysis.",
      "description_length": 352,
      "index": 652,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Base.MainFunctor.G",
      "library": "goblint.lib",
      "description": "This module combines a lattice structure with a sum type to model abstract domains for static analysis, supporting operations like join, meet, and widening on pairs of values tagged as private or thread-local. It works with polymorphic variants (`Lifted1`, `Lifted2`) and abstract domains (`Priv.G.t`, `VD.t`) to enable precise tracking of value dependencies in concurrent programs. Key use cases include merging analysis states during fixpoint computation and distinguishing thread-local versus global data in base analysis passes.",
      "description_length": 532,
      "index": 653,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.YamlWitness.Validator.WitnessInvariant",
      "library": "goblint.lib",
      "description": "Validates invariants at specific control flow points by checking node properties against syntactic and semantic conditions. It operates on `Node.t` and `GoblintCil.location` types, determining loop heads, lock states, and invariant validity. Used to ensure correctness of generated YAML witnesses by confirming that invariants are placed only at valid program locations.",
      "description_length": 370,
      "index": 654,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.YamlWitnessType.InvariantSet.LocationInvariant",
      "library": "goblint.lib",
      "description": "This module defines and manipulates location-based invariants in a YAML witness format, specifically associating string values and formats with code locations. It provides functions to construct invariants from YAML data, compare them, and identify their type. Concrete use cases include parsing and validating YAML-encoded invariants for static analysis tools.",
      "description_length": 361,
      "index": 655,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ThreadReturn.Spec.P",
      "library": "goblint.lib",
      "description": "This module defines a path-representative type `t` used to track unique identifiers for context-sensitive analysis in thread-return scenarios. It provides equality checks, hashing, comparison, and serialization operations for this type, enabling efficient representation and comparison of abstract thread states. Concrete use cases include managing context identifiers during static analysis to distinguish between different call paths leading to the same function.",
      "description_length": 465,
      "index": 656,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.SpecLifters.DeadBranchLifter.G",
      "library": "goblint.lib",
      "description": "This module implements lattice operations for an abstract domain type `G.t`, including standard meet/join semantics and extremal element handling (top/bot). It supports static analysis workflows by modeling dead branch states through structured domain elements with comparison, serialization, and arbitrary value generation capabilities. The lattice structure is specifically applied to track unreachable code paths in program analysis.",
      "description_length": 436,
      "index": 657,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Signs.Spec.D",
      "library": "goblint.lib",
      "description": "The module implements a lattice-based abstract domain for integer sign analysis, providing operations to combine (join/meet), compare (leq/equal), and refine (widen/narrow) abstract values representing integer signs. It defines an abstract type `t` to model sign information, along with utilities to determine extremal values (bot/top), compute differences (pretty_diff), and serialize results. This structure supports intraprocedural static analysis for reasoning about integer sign properties in programs, such as identifying non-negative variables or potential overflow conditions.",
      "description_length": 584,
      "index": 658,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.YamlWitnessType.ViolationSequence.Segment",
      "library": "goblint.lib",
      "description": "This module represents a segment of a violation sequence in a YAML witness format, specifically handling a list of waypoints. It provides functions to convert segments to and from YAML representation and compare segments based on their structure. It is used to model and manipulate violation paths in static analysis results.",
      "description_length": 325,
      "index": 659,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.WrapperFunctionAnalysis.ThreadCreateWrapper.C",
      "library": "goblint.lib",
      "description": "This module defines a concrete type `t` representing symbolic thread identifiers for wrapper function analysis. It provides operations for equality checking, hashing, comparison, string representation, and serialization to XML and JSON formats. These identifiers are used to track thread creation contexts based on node IDs, enabling precise analysis of concurrent programs.",
      "description_length": 374,
      "index": 660,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.UnassumeAnalysis.Spec.Locator",
      "library": "goblint.lib",
      "description": "This module coordinates source code locations with analysis events, supporting insertion, lookup, and transformation of events tied to specific program positions using CIL locations, analysis nodes, and event sets. It integrates ordered maps for location-keyed data, node sets for structured collections, and string-keyed tables for flexible storage, enabling operations like merging YAML invariants, selecting minimal nodes, and bidirectional mapping of unassume events. Functionality spans ordered traversal with `fold` and `min_binding`, set operations like union and filtering, and imperative hash table manipulations with structured keys. Specific use cases include emitting unassume events from witness invariants, transforming labeled event streams, and maintaining file-specific analysis data for verification workflows.",
      "description_length": 828,
      "index": 661,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ThreadReturn.Spec.G",
      "library": "goblint.lib",
      "description": "This module provides lattice operations (`join`, `meet`, `widen`, `narrow`, and `leq`) to compare and combine abstract thread return values, which represent the state of a thread's call stack. The lattice structure includes a top element denoting the most abstract (least precise) state, enabling hierarchical reasoning about thread behavior. It is used in static analysis of concurrent programs to model and merge possible thread return paths, particularly when tracking whether a thread is at the topmost call stack frame or not.",
      "description_length": 531,
      "index": 662,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Expsplit.Spec.A",
      "library": "goblint.lib",
      "description": "This module defines and manipulates abstract values for path-sensitive analysis based on arbitrary expressions. It supports operations for equality checking, hashing, comparison, and pretty-printing of these values, along with generating unique IDs and JSON representations. It is used to track and analyze expression values during static analysis, particularly in detecting and reporting potential race conditions.",
      "description_length": 415,
      "index": 663,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.SpecLifters.OptEqual.D",
      "library": "goblint.lib",
      "description": "This module provides lattice operations for ordering (leq), combination (join, meet), approximation (widen",
      "description_length": 106,
      "index": 664,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ExtractPthread.Tbls.NodeTbl",
      "library": "goblint.lib",
      "description": "Maps integer keys to control flow graph nodes and provides direct lookups. Supports retrieval of nodes by key, keys by node, and conversion to a list of key-node pairs. Useful for tracking and accessing CFG nodes during Pthread program analysis.",
      "description_length": 245,
      "index": 665,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.SpecLifters.LimitLifter.V",
      "library": "goblint.lib",
      "description": "This module defines operations for managing global constraint variables, including equality checks, hashing, comparison, and string representation. It works with a concrete type `t` representing constraint variables, each assigned a unique ID for context identification. These variables are used to track and limit widenings per node in static analysis, supporting precise witness generation and constraint propagation.",
      "description_length": 419,
      "index": 666,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ObserverAnalysis.MakePathSpec.A",
      "library": "goblint.lib",
      "description": "This module defines a data type `t` representing abstract execution paths in a path-sensitive analysis. It provides operations for comparing, hashing, and displaying path identifiers, along with serialization to XML and JSON, and support for generating arbitrary values for testing. The module is used to track and distinguish execution contexts in a concurrent analysis, particularly for identifying and reporting potential race conditions.",
      "description_length": 441,
      "index": 667,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.StackTrace.SpecLoc.C",
      "library": "goblint.lib",
      "description": "This module provides lattice operations (join, meet, widen, narrow) and comparison utilities for an abstract type representing specification locations in static analysis, including distinguished top and bottom values to model symbolic states or sentinel placeholders. It works with call stack tracking data structures to enable path-sensitive analysis and symbolic state representation in program analysis frameworks.",
      "description_length": 417,
      "index": 668,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.PrecCompareUtil.Util.RH",
      "library": "goblint.lib",
      "description": "This module manages key-value mappings with imperative and functional hash table operations, supporting insertion, deletion, filtering, in-place updates, and merging. It provides direct access to bindings through infix operators, labeled argument functions for clarity, and safe operations that return optional or result types, working seamlessly with `Hashtbl` and `BatHashtbl` structures. You can use it to track variable bindings during analysis, merge maps with custom key-aware logic, or safely modify values without raising exceptions. Conversions to sequences, lists, and enumerations enable efficient data transformations in precision-sensitive workflows.",
      "description_length": 663,
      "index": 669,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.MutexTypeAnalysis.Spec.V",
      "library": "goblint.lib",
      "description": "This module defines operations for handling globally unique constraint variables used in a mutex type analysis. It provides equality checks, hashing, comparison, and serialization functions for the type `t`, which represents constraint variables with unique identifiers. These operations support precise tracking and differentiation of mutex types during static analysis.",
      "description_length": 371,
      "index": 670,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.PthreadSignals.Spec.C",
      "library": "goblint.lib",
      "description": "This module defines and manipulates a data type `t` representing specifications for Pthread condition variable signals. It provides operations for equality checking, hashing, comparison, string representation, and serialization to XML and Yojson formats. It is used to track and identify signal events in static analysis of concurrent programs using condition variables.",
      "description_length": 370,
      "index": 671,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.LocksetAnalysis.MakeMust.C",
      "library": "goblint.lib",
      "description": "This module provides lattice operations like join, meet, widen, and narrow, along with utilities for serialization, comparison, and arbitrary value generation, tailored for abstract domains modeling locksets. It operates on a lattice-based abstract type representing lock acquisition states, enabling static analysis of concurrent programs to infer and verify synchronization behavior. Specific use cases include tracking lock usage patterns across threads and ensuring correct mutual exclusion in multi-threaded systems.",
      "description_length": 521,
      "index": 672,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.WrapperFunctionAnalysis.MallocWrapper.D",
      "library": "goblint.lib",
      "description": "This module provides lattice operations (join, meet, widen, narrow) and identity management (equality, hashing) for symbolic heap locations derived from node and thread identifiers. It operates on an abstract domain type representing dynamic memory allocations, enabling static analysis of program behavior involving concurrent memory operations. The domain supports tracking allocation sites and their relationships across execution paths, particularly useful for analyzing programs with thread-specific allocation patterns and node-based context sensitivity.",
      "description_length": 560,
      "index": 673,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ExtractPthread.Tbls.SymTbl",
      "library": "goblint.lib",
      "description": "Maintains a bidirectional mapping between keys and values using a hash table, allowing efficient lookups in both directions. It supports operations to retrieve values by key, find keys by value, and convert the table to a list of key-value pairs. This structure is used to track symbol mappings during Pthread program analysis, where keys and values represent program symbols and their associated data.",
      "description_length": 402,
      "index": 674,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.RecursionTermLifter.Lifter.V",
      "library": "goblint.lib",
      "description": "This module defines operations for managing global constraint variables, including equality checks, hashing, comparison, and serialization. It works with a concrete type `t` representing variables in a constraint system, supporting operations like pretty-printing, XML output, and JSON conversion. These variables are used to track and identify contexts in a context-sensitive analysis, particularly for cycle detection in dynamic function call graphs.",
      "description_length": 452,
      "index": 675,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.LocksetAnalysis.MakeMay.C",
      "library": "goblint.lib",
      "description": "This module provides lattice operations and top element manipulation for abstract lockset states represented by the `C.t` type, which models possible lock ownership scenarios in static analysis. It supports operations like join, meet, widening, and narrowing to combine or compare lockset states, alongside utilities for comparison, serialization, and testing. These capabilities are specifically used in may-lockset analysis to track potential lock acquisitions in concurrent programs, aiding thread safety verification and deadlock detection.",
      "description_length": 544,
      "index": 676,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ExtractPthread.Codegen.AdjacencyMatrix",
      "library": "goblint.lib",
      "description": "This module represents a directed control flow graph using a hash table-based adjacency matrix, enabling efficient edge population and traversal for analyzing thread transitions and dependencies. It provides core operations to add and query edges, retrieve nodes, and extract incoming or outgoing edges, while its nested module enhances safety and expressiveness with optional values, labeled matrices, and infix operators like `-->` and `<--`. Together, they support precise modeling of control flow and state transitions in Pthread and Promela programs, facilitating tasks such as dependency tracking and path analysis.",
      "description_length": 621,
      "index": 677,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.BaseDomain.CPA.M",
      "library": "goblint.lib",
      "description": "This module manages variable-value mappings with support for standard dictionary operations like insertion, lookup, and iteration, along with higher-order transformations such as filtering and folding. It extends these mappings with lattice operations\u2014join, meet, and widening\u2014enabling precise abstract interpretation tasks like value propagation and constraint solving. A key data type represents variable groups with a comparison function, facilitating structured data flow in constraint propagation algorithms. Together, these capabilities allow combining and analyzing abstract states under customizable merging strategies.",
      "description_length": 627,
      "index": 678,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.WitnessConstraints.PathSensitive3.P",
      "library": "goblint.lib",
      "description": "This module defines a path-representative type `t` with equality, hashing, comparison, and serialization operations. It supports projection from analysis domain elements and provides unique tagging for witness generation in path-sensitive analysis. Used to track and distinguish execution paths in constraint-based analysis transformations.",
      "description_length": 340,
      "index": 679,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Constants.Spec.D",
      "library": "goblint.lib",
      "description": "This module provides lattice operations (join, widen, narrow) and utility functions (equality, ordering, pretty-printing) for an abstract domain representing definite integer constants of local variables. It operates on a single-variable abstract value type `t` that models possible constant values through lattice theory, with `top` representing unconstrained values. The domain supports intraprocedural static analysis for tracking variable constants in program analysis, specifically designed for educational demonstrations of abstract interpretation principles without interprocedural state propagation.",
      "description_length": 607,
      "index": 680,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ThreadId.Spec.D",
      "library": "goblint.lib",
      "description": "This module provides lattice operations (join, meet, widen, narrow, leq) and domain-specific utilities for a tuple-based thread ID analysis structure that combines thread counters, thread-lifted data, and thread creation sets. It supports comparison, serialization, and structured difference reporting between thread identity values, specifically designed for analyzing concurrency in programs where tracking thread creation hierarchies and lifted data relationships is critical. The arbitrary value generation and pretty-printing functions enable robust testing and debugging of thread state transitions in concurrent systems.",
      "description_length": 627,
      "index": 681,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.SpecLifters.LevelSliceLifter.P",
      "library": "goblint.lib",
      "description": "This module defines operations for managing and comparing path-representative values used in global constraint tracking. It works with a type `t` that represents abstract paths, supporting equality checks, hashing, comparison, and conversion to string or XML formats. Concrete use cases include identifying and serializing unique path contexts during static analysis, particularly for constraint propagation and witness generation.",
      "description_length": 431,
      "index": 682,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.PthreadSignals.Spec.V",
      "library": "goblint.lib",
      "description": "This module defines a data type `t` representing global constraint variables used in the analysis of Pthread condition variables. It provides operations for equality checking, hashing, comparison, string representation, and serialization to XML and Yojson formats. These variables are used to track and reason about signal reception constraints in concurrent programs.",
      "description_length": 368,
      "index": 683,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.WitnessUtil.Locator.LocM",
      "library": "goblint.lib",
      "description": "This module manages data indexed by source code locations using ordered maps, enabling location-aware transformations, aggregations, and queries over values of arbitrary types. It supports operations like `add_to_list`, `update_stdlib`, and `find_first`, while its submodules provide labeled data traversal, monadic manipulation with infix operators, and safe, exception-free lookups returning optional values. Use it to track invariants, associate metadata with code positions, or thread location context through computations with controlled error handling. Examples include collecting and filtering location-annotated values, transforming standard library elements, and querying maps for optional bindings.",
      "description_length": 708,
      "index": 684,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MutexAnalysis.Spec.GM",
      "library": "goblint.lib",
      "description": "This module manages a thread-unsafe mutable map for lock-related key-value pairs, supporting insertion, lookup, deletion, and higher-order transformations. It includes bidirectional mappings for associating and retrieving values with keys, a labeled map for atomic updates and analysis of mutex states, and exception-safe operations for querying and modifying locksets. You can use it to track lock dependencies, ownership, and synchronization points in static analysis, with customizable serialization and bulk processing via map and fold operations.",
      "description_length": 551,
      "index": 685,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MemLeak.Spec.V",
      "library": "goblint.lib",
      "description": "This module defines operations for managing globally constrained variables in a memory leak analysis. It provides equality, hashing, comparison, and serialization functions for a type `t` representing constraint variables, along with utilities to generate arbitrary values and extract unique identifiers. These operations support tracking and comparing constraint variables during analysis to detect memory leaks in programs.",
      "description_length": 425,
      "index": 686,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.PrivPrecCompareUtil.Util.Key",
      "library": "goblint.lib",
      "description": "This module provides operations for comparing, hashing, and converting a specific type `t` into various representations like strings, XML, and JSON. It supports working with values of type `t` that are keys in maps or sets, enabling serialization, pretty-printing, and generation of arbitrary values for testing. Concrete use cases include key-based data structure manipulation, logging, and integration with analysis frameworks requiring structured output formats.",
      "description_length": 465,
      "index": 687,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.AnalysisResult.Result.Infix",
      "library": "goblint.lib",
      "description": "This module provides infix operators for interacting with a hash table that maps keys to analysis result values. The `-->` operator retrieves a value for a given key, while `<--` associates a key-value pair. These operations are used to efficiently store and access analysis results during static program analysis.",
      "description_length": 314,
      "index": 688,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Witness.Result.BiArgInvariant-Node",
      "library": "goblint.lib",
      "description": "Implements equality, hashing, and comparison for nodes in an abstract reachability graph (ARG), ensuring consistent identification of nodes based on their control-flow graph node, context ID, and path ID. Provides operations to convert nodes to string representations, retrieve structural components like CFG nodes, and check equality scoped to context. Useful for tracking and comparing program states during static analysis where context-sensitive path distinctions are critical.",
      "description_length": 481,
      "index": 689,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.SpecLifters.LimitLifter.D",
      "library": "goblint.lib",
      "description": "This domain type provides lattice operations and widening control for abstract interpretation, working with abstract analysis values to enforce per-node widening limits. It supports equality checks, comparison, hashing, and standard lattice manipulations on analysis domains, specifically targeting scenarios where convergence in static analysis must be guaranteed through bounded widening steps. The type is designed for static analysis lifters that require precise control over abstraction refinement during fixpoint computations.",
      "description_length": 532,
      "index": 690,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.StackTrace.Spec.C",
      "library": "goblint.lib",
      "description": "This library component defines lattice operations (join, meet, widen, narrow) with bottom element handling, alongside equality, comparison, and serialization for call contexts represented by `C.t` (an alias for `D.t`). It also includes utilities to identify and verify top contexts, enabling static analysis tasks like merging hierarchical contexts, tracking call stack positions, and abstract interpretation with lattice-based domains.",
      "description_length": 436,
      "index": 691,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ThreadReturn.Spec.D",
      "library": "goblint.lib",
      "description": "This module provides a lattice-based abstract domain for modeling thread call stack states using boolean-like values, supporting operations like join, meet, widen, and narrowing to analyze thread return behavior. It works with an abstract type `t` representing threadreturn states, including distinguished top and bottom elements to denote over-approximated or uninitialized contexts. The domain is particularly useful in static analysis of concurrent programs to track whether a thread's execution has propagated return values across call stack boundaries, enabling analyses like thread termination detection or return flow aggregation.",
      "description_length": 637,
      "index": 692,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Assert.Spec.C",
      "library": "goblint.lib",
      "description": "This module defines operations for comparing, hashing, and serializing assertion specification values, including equality checks, string and XML representations, and JSON conversion. It works with the abstract type `t` representing assertion specifications, supporting pretty-printing, arbitrary value generation for testing, and unique tagging. Concrete use cases include analyzing and persisting assertion results in various formats, enabling structured comparisons and serialization for external tools or logging.",
      "description_length": 516,
      "index": 693,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.ThreadAnalysis.Spec.C",
      "library": "goblint.lib",
      "description": "This module provides lattice operations (join, meet, widen, narrow, leq, bot, top, is_bot, is_top), equality checks, comparison, hashing, and serialization utilities for an abstract type representing thread analysis states. The type `t` models abstract thread states in static analysis contexts. These functions are used in static analysis tools to infer properties of concurrent programs",
      "description_length": 388,
      "index": 694,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Assert.Spec.A",
      "library": "goblint.lib",
      "description": "This module defines operations for comparing, hashing, and serializing assertion specification instances, including equality checks, pretty-printing, XML and JSON conversion, and arbitrary value generation for testing. It works with the abstract type `t` representing assertion specifications, supporting operations like checking potential race conditions between specifications and determining if a value should be printed in race output. Concrete use cases include analyzing concurrent program assertions, generating test cases for specifications, and producing structured output for debugging or external tools.",
      "description_length": 614,
      "index": 695,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.CommonPriv.MutexGlobals.VMutex",
      "library": "goblint.lib",
      "description": "This module provides operations for managing mutex variables with offset tracking, including comparisons, domain conversions, and analysis integration. It works with mutex value types (`t`) and general value domains (`Mval.t`), enabling precise handling of mutex states in thread-modular static analysis. Key use cases include concurrency analysis and verification of lock-based synchronization in programs.",
      "description_length": 407,
      "index": 696,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.ThreadId.Spec.N",
      "library": "goblint.lib",
      "description": "This module provides lattice operations (join, meet, widen, narrow) and value manipulation functions (lift, relift, bot, top) for analyzing thread identifiers in a three-tiered domain: bottom (Bot), concrete version-numbered IDs (Lifted), and top (Top). It supports static analysis of concurrent programs by enabling precise merging and comparison of thread states during abstract interpretation. Use cases include dataflow analysis and fixpoint computations where thread identity tracking across control-flow paths requires lattice-based abstraction.",
      "description_length": 551,
      "index": 697,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Expsplit.Spec.G",
      "library": "goblint.lib",
      "description": "This module provides lattice operations for abstract contexts in path-sensitive analysis, including comparisons, joins/meets, and widening/narrowing with bottom value handling. It works with abstract contexts represented as type `t`, structured to support constraint solving and witness generation in value-dependent expression analysis. These operations enable merging analysis states, checking subsumption, and iteratively refining abstract interpretations during program analysis.",
      "description_length": 483,
      "index": 698,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Deadlock.Spec.C",
      "library": "goblint.lib",
      "description": "This module provides lattice-theoretic operations such as join, meet, widen, and narrowing, alongside comparison, serialization, and pretty-printing utilities. It operates on an abstract type representing deadlock analysis states, structured as a lattice with distinguished top elements to model analysis precision. These capabilities support static analysis for detecting or reasoning about deadlock scenarios in concurrent programs through abstract interpretation.",
      "description_length": 466,
      "index": 699,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Signs.Spec.P",
      "library": "goblint.lib",
      "description": "This module represents path-representative constraint variables for tracking unique contexts in a static analysis. It provides operations for equality checking, hashing, comparison, and pretty-printing of path identifiers, along with serialization to XML and Yojson. It is used to distinguish different control-flow paths during analysis, enabling precise context-sensitive reasoning.",
      "description_length": 384,
      "index": 700,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Witness.Result.BiArgInvariant",
      "library": "goblint.lib",
      "description": "Implements operations to analyze and traverse a graph structure where each node maintains incoming and outgoing edges. Provides functions to retrieve the main entry node, find predecessors and successors of nodes, iterate over all nodes, and query specific properties or invariants associated with nodes. Useful for static analysis tasks that require examining program control flow or data dependencies through a graph-based intermediate representation.",
      "description_length": 453,
      "index": 701,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "Goblint_lib.LockDomain.MustMultiplicity.Count",
      "library": "goblint.lib",
      "description": "This module provides lattice operations (join, meet, widen, narrow, leq) over integer values to model lock multiplicity counts in concurrency analysis. It works with integer-based data structures augmented with comparison, hashing, and serialization capabilities for JSON/XML formats, alongside test utilities for generating arbitrary integers. The design supports static analysis of concurrent programs where precise tracking of lock acquisition counts and their abstract representations are critical for soundness.",
      "description_length": 516,
      "index": 702,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.CommonPriv.PerMutexTidCommon.V",
      "library": "goblint.lib",
      "description": "This module defines operations for handling a sum type that represents either a mutex global variable or a thread identifier. It includes functions for equality checking, comparison, hashing, pretty-printing, and serialization to JSON and XML formats. Concrete use cases include tracking ownership of mutexes and distinguishing between thread-specific and global state in thread-modular analysis.",
      "description_length": 396,
      "index": 703,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.SpecLifters.DeadCodeLifter.V",
      "library": "goblint.lib",
      "description": "This module defines operations for managing a special bottom element representing unreachable code in a lifted analysis. It provides equality checks, hashing, comparison, and pretty-printing for this element, along with utilities to generate arbitrary values and extract unique identifiers. Concrete use cases include tracking dead code during static analysis and lifting abstract values while preserving unreachable state information.",
      "description_length": 435,
      "index": 704,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Server.Locator.LocM",
      "library": "goblint.lib",
      "description": "This module implements a persistent, location-indexed map for managing polymorphic data with support for both functional transformations and monadic state updates. It provides ordered traversal, filtering, merging, and aggregation operations, along with safe inspection functions like `choose_opt` and `min_binding`, enabling precise manipulation of location-annotated values in interactive analysis contexts. Submodules extend its core functionality with labeled mappings for structured server data, exception-safe querying mechanisms, and infix operators for concise monadic access and updates. Example uses include tracking source code locations during analysis, aggregating contextual data in Goblint's server, and managing error positions in JSON-RPC responses.",
      "description_length": 766,
      "index": 705,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.YamlWitnessType.InvariantSet.InvariantType",
      "library": "goblint.lib",
      "description": "This module defines and manipulates invariant types in a YAML-based witness format, specifically distinguishing between location and loop invariants. It provides operations to compare invariant types, retrieve their string representation, and parse them from YAML values. Concrete use cases include validating program analysis results and serializing/deserializing invariant data for external tools.",
      "description_length": 399,
      "index": 706,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.CompareConstraints.CompareGlobal.Compare",
      "library": "goblint.lib",
      "description": "This module orchestrates comparison logic for constraint systems, enabling analysis of global constraint states through customizable comparison functions. It operates on structures like `G.t GH.t`, yielding comparison results alongside formatted documentation to highlight differences in constraint environments, such as pre- and post-state discrepancies in verification tasks. Submodule 1 specializes in comparing `G.t` instances to determine inclusion or divergence, while Submodule 2 handles variable-like structures, supporting identity tracking, pretty-printing, and stable serialization across analyses. Together, they enable precise constraint state analysis and readable difference reporting in static analysis workflows.",
      "description_length": 729,
      "index": 707,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.UseAfterFree.Spec.P",
      "library": "goblint.lib",
      "description": "This module defines and manipulates path-representative values used to track and identify unique execution paths in use-after-free analysis. It supports operations for equality checking, hashing, comparison, and pretty-printing, along with serialization and generation of arbitrary instances for testing. These values are used to associate constraints with specific paths and provide unique identifiers for witness generation and context-sensitive analysis.",
      "description_length": 457,
      "index": 708,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ExtractPthread.Tbls.FunCallTbl",
      "library": "goblint.lib",
      "description": "This module provides a hash table for mapping function names and string identifiers to integer values. It supports operations to insert, retrieve, and convert the table to a list of key-value pairs. Useful for tracking function call counts or identifiers during Pthread program analysis.",
      "description_length": 287,
      "index": 709,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.YamlWitnessType.ViolationSequence.FunctionEnter",
      "library": "goblint.lib",
      "description": "Handles parsing and comparison of function entry violation data in YAML witness files. Works with YAML values and structured violation records containing location and action fields. Used to process and validate function entry waypoints during static analysis result checking.",
      "description_length": 275,
      "index": 710,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.StackTrace.Spec1.P",
      "library": "goblint.lib",
      "description": "This module provides operations for handling unit-type values in the context of call stack analysis, including equality checks, comparison, hashing, and pretty-printing. It supports data types related to abstract analysis elements like `stack_trace`, `stack_trace_set`, and `stack_loc`. Concrete use cases include normalizing and comparing stack trace representations during static analysis of program call stacks.",
      "description_length": 414,
      "index": 711,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.StackTrace.Spec2.V",
      "library": "goblint.lib",
      "description": "This module implements a singleton-type specification for call stack analysis, providing identity operations, comparisons, and serialization for a unit-like type representing empty stack traces. It supports concrete use cases such as tracking and distinguishing empty stack states in static analysis, and generating unique identifiers and XML/YoJSON representations for witness generation or logging. Functions like `tag`, `printXml`, and `to_yojson` enable integration with external analysis tools and persistent storage formats.",
      "description_length": 530,
      "index": 712,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.YamlWitness.Validator.Locator",
      "library": "goblint.lib",
      "description": "This module tracks source code locations and maps them to specification variables using a hierarchical structure, enabling validation of YAML witnesses by correlating program positions with expected specification elements. It supports creating and querying location mappings, adding or resolving associations, and clearing stored data, often in combination with submodules that handle sets, ordered maps, and file-based structures. The first submodule manipulates collections of variables with set operations and ordered traversal, supporting transformations and queries on structured data like YAML. The second manages location-keyed maps for precise association and safe traversal, enabling error reporting and configuration parsing with positional context, while the third organizes file-based data with structured maps, supporting merging, filtering, and in-place updates for static analysis and witness validation workflows.",
      "description_length": 929,
      "index": 713,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.YamlWitnessType.ViolationSequence.FunctionReturn",
      "library": "goblint.lib",
      "description": "Handles parsing and comparison of function return violation sequences in YAML witness files. Works with YAML values and converts them into structured violation data including location, action, and constraints. Used to validate function return assumptions during static analysis.",
      "description_length": 278,
      "index": 714,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.ThreadReturn.Spec.C",
      "library": "goblint.lib",
      "description": "This module implements a specification for a thread return analysis by managing abstract representations of thread call stacks using a boolean-like structure. It provides operations for equality checking, hashing, comparison, and string/XML/JSON serialization, along with generating unique identifiers and arbitrary values for testing. It is used to track whether a thread is at the topmost call frame during static analysis, aiding in context-sensitive dataflow analysis and witness generation.",
      "description_length": 495,
      "index": 715,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "Goblint_lib.ThreadEscape.Spec.C",
      "library": "goblint.lib",
      "description": "This module provides lattice-based abstract domain operations for thread escape analysis, working with an abstract type `t` (alias for `D.t`) to model variable escape states. It includes comparison, display, and lattice utilities like `join`, `meet`, `top`, and `is_top`, enabling static analysis to determine whether variables escape thread-local contexts. These operations support abstract interpretation by representing hierarchical escape properties in a lattice structure.",
      "description_length": 477,
      "index": 716,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.YamlWitnessType.ViolationSequence.Constraint",
      "library": "goblint.lib",
      "description": "This module represents structured constraints with values and optional format strings, enabling comparison, validation, and YAML serialization. Its core type works with custom value types like the polymorphic `t` from the child module, which supports string and integer constraint values in violation sequences. Operations include parsing from YAML, converting to YAML, and comparing values, all used to handle constraint data in program analysis witness files. For example, it can validate whether a constraint value matches a specified format, serialize constraints for storage, or parse them during analysis.",
      "description_length": 611,
      "index": 717,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.TmpSpecial.Spec.MLDeps",
      "library": "goblint.lib",
      "description": "This module combines tracked math library call results (`ML.t`) with dependency tracking (`Deps.t`) to manage equivalences between variables and their computed expressions. It provides lattice operations for abstract interpretation, along with serialization and testing utilities, enabling precise analysis of variable dependencies in programs. It is particularly useful for scenarios where changes to variables or expressions require invalidating or updating tracked equivalences during static analysis.",
      "description_length": 504,
      "index": 718,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ArgTools.Make.NHT",
      "library": "goblint.lib",
      "description": "This module manages key-value associations with `Node.t` keys, enabling creation, traversal, and transformation of hash tables through mapping, filtering, and merging operations. It supports conversion to sequences and formatted outputs, facilitating dynamic data handling in constraint system analysis, such as tracking node relationships or aggregating results during graph construction. The first child module introduces infix operators `-->` and `<--` for concise access and updates to nested values, simplifying manipulation of deep structures in abstract reachability graphs. The second child module adds safe, exception-free access and modification of nested entries using result types, ensuring robust updates in hierarchical key-value stores derived from constraint solutions.",
      "description_length": 785,
      "index": 719,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Callstring.Spec.P",
      "library": "goblint.lib",
      "description": "This module defines path-representative values with operations for equality, hashing, comparison, and serialization. It works with a type `t` that represents abstract paths, supporting concrete use cases like tracking unique execution contexts in static analysis and enabling context-sensitive dataflow analysis with k-CFA. Functions include generating arbitrary instances for testing, converting from analysis elements, and producing stable identifiers for context-sensitive reasoning.",
      "description_length": 486,
      "index": 720,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.CommonPriv.PerMutexTidCommon.GThread",
      "library": "goblint.lib",
      "description": "This module provides a thread-modular abstract domain combining must- and may-approximation values, supporting lattice operations like widening, narrowing, and joins alongside structural manipulation and comparison utilities. It operates on paired abstract representations (`LMust.t` and `L.t`) to model concurrent program states, with specialized support for XML/JSON serialization and differential pretty-printing. Designed for thread-modular static analysis, it enables precise concurrency reasoning in value analysis and facilitates data exchange or testing through arbitrary value generation and structured output formatting.",
      "description_length": 630,
      "index": 721,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.CommonPriv.WriteCenteredD.P",
      "library": "goblint.lib",
      "description": "This module provides a polymorphic map-like structure for managing variable-to-minimal-lockset associations, supporting standard associative operations like insertion, removal, and transformation, alongside lattice operations such as join, meet, and widening. It operates on parametrized key-value types built over lifted-bottom maps, where keys represent variables and values encode locksets, enabling efficient state combination and comparison. These capabilities are tailored for thread-modular static analysis, particularly in tracking concurrency-related dependencies and performing abstract interpretation over program states.",
      "description_length": 632,
      "index": 722,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MayLocks.Spec.G",
      "library": "goblint.lib",
      "description": "This module implements lattice operations and utility functions for analyzing may-locksets in concurrent program analysis. It works with a type representing abstract locksets, supporting operations like join, meet, widening, and narrowing to track potential lock interactions. These capabilities are used for static analysis of concurrency scenarios, such as detecting double locking or inconsistent lock acquisition patterns.",
      "description_length": 426,
      "index": 723,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MutexEventsAnalysis.Spec.D",
      "library": "goblint.lib",
      "description": "The domain provides lattice operations like `join`, `meet`, `widen`, and `narrow` to model and analyze mutex states in concurrent programs. It manipulates abstract values representing lock and unlock events, which are used to track potential synchronization errors. This enables static analysis for correctness checks such as deadlock detection and proper lock usage in multi-threaded code.",
      "description_length": 390,
      "index": 724,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.PrecCompare.MakeHashtbl.CompareD",
      "library": "goblint.lib",
      "description": "This module implements a hash table for comparing precision between two data structures using the `compare` function from the `PrecCompare` module. It works with data types that conform to the `D.t` signature, tracking and comparing their precision levels. Concrete use cases include analyzing abstract domains in static analysis to determine which domain provides more precise results.",
      "description_length": 386,
      "index": 725,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.UseAfterFree.Spec.G",
      "library": "goblint.lib",
      "description": "This module defines lattice operations (join, meet, widen, narrow) and serialization utilities for an abstract domain representing memory states in pointer analysis. It operates on a type capturing abstract program states, enabling dataflow analysis to detect use-after-free vulnerabilities in C programs through static analysis techniques like abstract interpretation. The lattice structure supports tracking pointer validity and memory lifetimes across program paths.",
      "description_length": 469,
      "index": 726,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Base.MainFunctor.C",
      "library": "goblint.lib",
      "description": "This module provides lattice-theoretic operations such as `join`, `meet`, `widen`, and `narrow`, alongside comparison, display, and serialization functions for an abstract value type `C.t`. It operates on non-relational analysis data structures used in static analysis, enabling tasks like merging abstract states, determining value ranges, and enforcing safety properties through fixpoint computations. Key constants like `bot`, `top`, and their checks (`is_bot`, `is_top`) support lattice-based reasoning in abstract interpretation frameworks.",
      "description_length": 545,
      "index": 727,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MutexAnalysis.Spec.C",
      "library": "goblint.lib",
      "description": "Implements lattice operations (join, meet, widen, narrow, top/bottom elements), equality checks, and domain-specific serialization/pretty-printing for an abstract domain modeling mutex states. It operates on lockset and protecting lockset data structures encapsulated in a type aliased from Arg.D.t, enabling static analysis of concurrency safety in programs through abstract interpretation. This supports verifying correct mutex usage patterns, such as ensuring locks are properly acquired/released and identifying race conditions.",
      "description_length": 532,
      "index": 728,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ObserverAnalysis.MakePathSpec.D",
      "library": "goblint.lib",
      "description": "This domain provides lattice operations for abstract interpretation, including join, meet, widening, and narrowing, along with extremal value checks (`top`, `is_top`) and structural utilities like hashing and serialization. It operates on abstract domain values (`D.t`) representing program states in a path-sensitive context. These capabilities enable precise static analysis of program paths by merging state approximations and handling unknown or impossible conditions.",
      "description_length": 472,
      "index": 729,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Deadlock.Spec.V",
      "library": "goblint.lib",
      "description": "This module defines operations for comparing, hashing, and serializing deadlock specification values, including equality checks, string representation, XML and JSON output, and integration with testing frameworks. It works with the abstract type `t` representing deadlock analysis specifications. Concrete use cases include persisting deadlock states, generating test cases, and producing human-readable or machine-readable output for analysis results.",
      "description_length": 452,
      "index": 730,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.WrapperFunctionAnalysis.MallocWrapper.P",
      "library": "goblint.lib",
      "description": "This module defines a path-representative type used to track symbolic heap locations for dynamic memory allocations. It provides equality, comparison, and hashing operations, along with serialization and pretty-printing functions for analysis output. It works with constraint variables and symbolic identifiers, primarily used in tracking heap allocations across different program paths.",
      "description_length": 387,
      "index": 731,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Assert.Spec.V",
      "library": "goblint.lib",
      "description": "This module defines and manipulates globally unique constraint variables used in assert analysis. It supports equality checks, hashing, ordering, string representation, and serialization to XML and JSON, with operations for generating arbitrary values and checking write-only status. These variables are used to track and identify constraints in program analysis, particularly in witness generation and verification contexts.",
      "description_length": 425,
      "index": 732,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.LoopTermination.Spec.V",
      "library": "goblint.lib",
      "description": "This module defines and manipulates global constraint variables used in termination analysis for loops and gotos. It provides operations for equality checking, hashing, comparison, and pretty printing of these variables, along with utilities for serialization, generating arbitrary instances, and checking write-only status. These variables are used to track and reason about loop termination conditions and context-sensitive constraints in program analysis.",
      "description_length": 458,
      "index": 733,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Base.MainFunctor.Dom",
      "library": "goblint.lib",
      "description": "This module supports abstract interpretation by defining lattice operations for domain elements, including join, meet, widen, and narrowing, which are essential for static analysis convergence. It works with abstract values represented as `Dom.t` and `RVEval.t`, focusing on non-relational value approximations. These operations enable dataflow analysis in program verification, particularly for ensuring termination of fixed-point computations through widening and narrowing strategies.",
      "description_length": 487,
      "index": 734,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Control.AnalyzeCFG.Result",
      "library": "goblint.lib",
      "description": "This module manages hashtables mapping control flow graph nodes to arbitrary values, enabling imperative and functional transformations such as merging, filtering, and in-place updates. It supports safe access and modification through result-wrapped values, direct node-based lookups (`-->`, `<--`), and aggregation operations over node-value pairs. Main data types include `Result.key` for indexing and generic `'a` values stored in the table, with operations for converting to sequences or lists. Examples include merging abstract interpretation results, generating analysis reports in structured formats, and tracking per-node state during static analysis passes.",
      "description_length": 666,
      "index": 735,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.WideningTokenLifter.Lifter.C",
      "library": "goblint.lib",
      "description": "This module provides operations for managing and manipulating abstract elements enhanced with widening tokens, including equality checks, hashing, comparison, and serialization. It works with abstract data types that carry token sets to control widening behavior during analysis. Concrete use cases include delaying widening in static analysis to improve precision by tracking token changes across iterations.",
      "description_length": 409,
      "index": 736,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ExtractPthread.Spec.V",
      "library": "goblint.lib",
      "description": "This module defines operations for managing and comparing globally constrained variables in the context of Pthread program analysis. It provides equality, hashing, comparison, and serialization functions for the type `t`, which represents constraint variables with unique identifiers. These operations support precise tracking and differentiation of variables during analysis, particularly in scenarios involving concurrent execution paths and witness generation.",
      "description_length": 463,
      "index": 737,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Expsplit.Spec.C",
      "library": "goblint.lib",
      "description": "This module represents contexts for path-sensitive analysis based on arbitrary expressions. It provides operations for comparing, hashing, and serializing contexts, along with generating arbitrary instances for testing. It is used to track and distinguish different analysis paths through unique identifiers and structural equality.",
      "description_length": 332,
      "index": 738,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.StackTrace.Spec1.V",
      "library": "goblint.lib",
      "description": "This module implements a singleton-type stack trace analysis for tracking call contexts with unique identifiers. It provides operations for equality checking, hashing, comparison, and pretty-printing of empty stack trace values, along with serialization to XML and Yojson formats. It is used to uniquely tag and identify analysis contexts during abstract interpretation in witness generation.",
      "description_length": 392,
      "index": 739,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ObserverAnalysis.MakePathSpec.C",
      "library": "goblint.lib",
      "description": "This module defines a context type `t` with operations for equality, hashing, comparison, and serialization. It supports path-sensitive analysis by providing unique identification via `tag` and structured output through `show`, `pretty`, and `printXml`. Concrete use cases include tracking analysis contexts during symbolic execution and generating XML or JSON representations for external tools like witnesses.",
      "description_length": 411,
      "index": 740,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.WitnessUtil.InvariantExp.ES",
      "library": "goblint.lib",
      "description": "This module provides set-theoretic and lattice operations on collections of CIL expressions (`CilType.Exp.t`), including union, intersection, difference, subset checks, and lattice-specific functions like join, meet, widen, and narrow. It works with an abstract type representing expression sets, supporting transformations, membership queries, and conversions to formats like XML and Yojson. It is specifically used to model and manipulate expression-based invariants during witness generation for static analysis, enabling tasks like invariant comparison, combination, and serialization for verification workflows.",
      "description_length": 616,
      "index": 741,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.YamlWitnessType.ViolationSequence.Target",
      "library": "goblint.lib",
      "description": "This module defines a target within a violation sequence in a YAML witness, containing a location and an action string. It provides operations to parse a YAML value into a target, compare two targets, and identify the target's type as a waypoint. It is used to represent and process specific violation points in static analysis reports.",
      "description_length": 336,
      "index": 742,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ThreadId.Spec.P",
      "library": "goblint.lib",
      "description": "This module provides lattice-based operations for thread ID analysis, including partial order comparisons (leq), joins/meets, and widening/narrowing, alongside serialization and structural equality checks. It operates on abstract thread ID values represented by the type `t`, which incorporates a distinguished \"top\" element to model hierarchical or concurrent execution states. These capabilities are particularly useful in static program analysis for tracking thread interactions and merging control flow paths in concurrent systems.",
      "description_length": 535,
      "index": 743,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Signs.Spec.A",
      "library": "goblint.lib",
      "description": "This module defines operations for handling abstract integer sign values in a static analysis context, including equality checks, comparison, hashing, and pretty-printing. It works with a concrete abstract type `t` representing sign information, supporting serialization, arbitrary value generation for testing, and race condition checks. Concrete use cases include tracking variable sign states during program analysis to detect potential issues like negative indices or invalid arithmetic behavior.",
      "description_length": 500,
      "index": 744,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.LongjmpLifter.Lifter.G",
      "library": "goblint.lib",
      "description": "This module implements lattice operations for abstract interpretation in static analysis, focusing on handling non-local control flow from setjmp/longjmp in C. It defines a lattice structure over type `G.t` with comparison, join/meet operations, and top element checks, enabling precise state merging during analysis. The lattice supports tracking possible jump targets and associated program states across function boundaries.",
      "description_length": 427,
      "index": 745,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MallocFresh.Spec.A",
      "library": "goblint.lib",
      "description": "This module represents analysis results for unescaped heap locations, where values are boolean tags indicating whether a memory allocation is fresh (i.e., not reachable from any thread other than the allocating one). It supports comparison, hashing, pretty-printing, and XML/Yojson serialization, primarily used in static analysis to track thread-local allocations and detect potential race conditions. The boolean values are used directly in analysis decisions, such as whether to report a race or optimize memory behavior.",
      "description_length": 524,
      "index": 746,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.SpecLifters.DeadBranchLifter.C",
      "library": "goblint.lib",
      "description": "This module defines operations for lifting and comparing abstract contexts with support for serialization, pretty-printing, and generating arbitrary test values. It works with a concrete abstract type `t` that represents analysis contexts, each associated with a unique ID. Concrete use cases include tracking and comparing analysis states during static program analysis, enabling context-sensitive dataflow analyses with lifted specifications.",
      "description_length": 444,
      "index": 747,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.VarEq.Spec.D",
      "library": "goblint.lib",
      "description": "This module provides set-like operations and lattice combinators on a polymorphic set abstraction that can represent either a concrete set of elements (`B.t`) or a top element denoting an over-approximated value. It supports static analysis tasks by enabling equivalence class manipulation (e.g., union, intersection, subset checks) and lattice-theoretic computations (join, meet, widening) over symbolic expressions, particularly for tracking variable equalities and invariants in program analysis. The structure is tailored for scenarios requiring precise set operations alongside lattice-based abstraction refinement, such as equivalence relation maintenance in abstract interpretation.",
      "description_length": 689,
      "index": 748,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.IntDomainProperties.IntegerSet.Base",
      "library": "goblint.lib",
      "description": "This integer set abstract domain supports lattice operations (join, meet, widen, narrow), arithmetic/bitwise manipulations, and comparisons over abstract integer values. It operates on integer sets represented via `Base.t`, congruence relations, and CIL type-aware integer kinds, with utilities for overflow handling, invariant generation from expressions, and test-case synthesis. Designed for numerical static analysis, it enables precise value analysis and extremal value checking in abstract interpretation workflows.",
      "description_length": 521,
      "index": 749,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.SpecLifters.WidenContextLifterSide.M",
      "library": "goblint.lib",
      "description": "This module provides map-based abstractions for static analysis, supporting operations like merging, widening, and narrowing of abstract states represented as variable-to-`DD.t` mappings. It combines standard associative map manipulations (insertion, iteration, filtering) with lattice-theoretic operations (join, meet, leq) tailored for abstract interpretation, enabling efficient analysis of program variables' value ranges. Use cases include tracking variable bindings during dataflow analysis, visualizing state differences via `pretty_diff`, and bulk-updating abstract domains with customizable combination logic.",
      "description_length": 618,
      "index": 750,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Preprocessor.FpathH.Labels",
      "library": "goblint.lib",
      "description": "This module provides hash table operations for managing key-value pairs where keys are file paths. It supports standard imperative operations like adding, modifying, and filtering entries, as well as higher-order functions for mapping, folding, and merging. Concrete use cases include tracking preprocessor definitions per file, transforming or filtering file-specific data during C analysis, and merging file path-based mappings from multiple sources.",
      "description_length": 452,
      "index": 751,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.YamlWitness.ValidationResult.ChainParams",
      "library": "goblint.lib",
      "description": "Handles validation of chain parameters in YAML witness files, ensuring correct structure and values. Works with integers and strings, primarily using the `n` and `names` functions to validate and retrieve parameter counts and identifiers. Used during YAML witness validation to check chain-specific parameters against expected values.",
      "description_length": 334,
      "index": 752,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Preprocessor.FpathH.Infix",
      "library": "goblint.lib",
      "description": "This module defines infix operators for accessing and modifying values associated with keys in a file path-based data structure. It provides `-->` for retrieving values by key and `<--` for updating the structure with a key-value pair. These operations are used to manage preprocessor configuration settings tied to specific file paths during C preprocessor detection.",
      "description_length": 368,
      "index": 753,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.SpecLifters.OptEqual.C",
      "library": "goblint.lib",
      "description": "This module implements equality-based lifting operations for context values, providing `equal`, `hash`, and `compare` functions for structural comparison and caching. It operates on the type `C.t`, which represents abstract contexts in static analysis. Concrete use cases include deduplicating analysis contexts and enabling efficient lookups in fixed-point computations.",
      "description_length": 371,
      "index": 754,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.UseAfterFree.Spec.D",
      "library": "goblint.lib",
      "description": "This module implements a lattice structure for abstract analysis states, featuring join, meet, widen, and narrow operations to model memory safety properties. It operates on an abstract type representing program states, with support for equality checks, ordering relations, and utilities like pretty-printing and serialization. These capabilities enable static analysis frameworks to detect use-after-free vulnerabilities by tracking dynamically allocated memory lifetimes and invalid accesses.",
      "description_length": 494,
      "index": 755,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.LoopTermination.Spec.C",
      "library": "goblint.lib",
      "description": "This module defines and manipulates a specific data type `t` representing loop termination specifications in C code analysis. It provides operations for equality checking, hashing, comparison, and string/XML/JSON representation, enabling precise identification and serialization of loop contexts. Concrete use cases include tracking and comparing loop termination states during static analysis and generating unique identifiers for witness generation in verification tasks.",
      "description_length": 473,
      "index": 756,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.LocksetAnalysis.MakeMust.P",
      "library": "goblint.lib",
      "description": "Implements a must-alias analysis for locksets using a singleton domain where all values are considered equivalent. It provides comparison, hashing, and pretty-printing operations, ensuring consistency in tracking and merging lock states. This module is used to determine if locks must be held at specific program points, improving precision in concurrency analysis.",
      "description_length": 365,
      "index": 757,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.UseAfterFree.HeapVars",
      "library": "goblint.lib",
      "description": "This module provides lattice and set-theoretic operations to track heap-allocated variables during static analysis of use-after-free vulnerabilities. It works with sets of `CilType.Varinfo` elements, representing dynamically allocated variables, and supports operations like union, intersection, and partitioning alongside lattice-specific utilities for merging and comparing variable states. These capabilities enable precise modeling of heap variable lifetimes to detect invalid memory accesses when variables are used after being freed.",
      "description_length": 539,
      "index": 758,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Control.AnalyzeCFG",
      "library": "goblint.lib",
      "description": "This module performs abstract interpretation over control flow graphs by solving monotone framework constraints to compute program-wide dataflow solutions. It combines a constraint solver, state management, and lattice operations to determine reachable states, detect dead code, and produce analysis results from path-sensitive constraint systems. Key data types include labeled variables, constraint systems, and state mappings with operations for merging, comparison, and imperative updates. You can use it to perform interprocedural analysis, track variables across CFG nodes, extract partitioned results, and manage fixed-point computations with support for widening, narrowing, and resumption.",
      "description_length": 698,
      "index": 759,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.ExpressionEvaluation.ExpEval",
      "library": "goblint.lib",
      "description": "Performs expression evaluation during static analysis by transforming CIL files based on given queries. Works with CIL AST structures and analysis results to compute values of expressions at specific program points. Used to extract concrete values from analyzed code for visualization or further processing in tools like Gobview.",
      "description_length": 329,
      "index": 760,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ResultQuery.Query",
      "library": "goblint.lib",
      "description": "This module provides functions to query local and global analysis results within a constraint system solution. It operates on data types including constraint graphs, analysis states, and query types from the `Goblint_lib.Queries` module. Concrete use cases include retrieving variable values at specific nodes or obtaining system-wide analysis outcomes.",
      "description_length": 353,
      "index": 761,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.SpecLifters.PathSensitive2",
      "library": "goblint.lib",
      "description": "This module enhances static analysis with path-sensitive transfer functions that model program behavior across multiple execution paths using abstract states (`D.t`), control points (`C.t`), and hierarchical contexts (`G.t`, `V.t`). Its core functionality includes path discrimination for concurrent thread tracking, function call specialization, and event-driven state propagation, while child modules provide lattice operations for merging and transforming abstract values and constraint variables for tracking path-specific conditions. The lattice module supports join, meet, widen, and narrow operations on `D.t` values tagged with unique contexts, enabling precise dataflow analysis and debugging through serialization and pretty-printing. The constraint variable module allows identity tracking, context-sensitive propagation, and conversion to JSON, supporting analyses that require unique path identification and constraint projection from abstract states.",
      "description_length": 964,
      "index": 762,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.YamlWitnessType.Invariant",
      "library": "goblint.lib",
      "description": "This module defines and manipulates invariant data structures used to represent YAML witness format types. It provides functions to convert invariants to and from YAML format and compare them, working directly with the `t` record type containing string, type, and format fields. It is used to serialize and deserialize invariant data for analysis or configuration purposes.",
      "description_length": 373,
      "index": 763,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.CommonPriv.NoAtomic",
      "library": "goblint.lib",
      "description": "This module controls handling of atomic blocks in SV-COMP benchmarks during value analysis. It provides a mutable flag `handle_atomic` that determines whether atomic sections are processed or skipped. Useful when analyzing concurrent programs where atomicity guarantees affect precision and performance.",
      "description_length": 303,
      "index": 764,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.PrecCompare.Make",
      "library": "goblint.lib",
      "description": "Implements precision comparison operations for data values of type `D.t`, producing comparison results paired with formatted documentation. Compares two values with optional verbosity and custom naming, returning structured precision insights. Useful for analyzing precision differences in abstract domains during static analysis.",
      "description_length": 330,
      "index": 765,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Analyses.EmptyV",
      "library": "goblint.lib",
      "description": "This module implements an analysis value type based on an empty structure, providing equality checks, hashing, string representation, and serialization. It supports use cases where a placeholder or null analysis value is needed, such as representing absence of data or initializing analysis states. The module includes functions for comparison, pretty printing, XML and JSON output, and generating arbitrary test values.",
      "description_length": 420,
      "index": 766,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.LoopTermination.Spec",
      "library": "goblint.lib",
      "description": "This module analyzes termination properties of loops and control flow in C programs by modeling variable transitions, function calls, and branching using abstract domains and CIL data types. It defines core types like `t` for representing loop states, constraint variables for tracking path conditions, and lattice operations for abstract interpretation, supporting operations such as join, widen, and serialization for analysis and diagnostics. Submodules handle domain-specific manipulations, constraint tracking, and specification serialization, enabling tasks like proving loop termination, generating verification witnesses, and analyzing goto targets. Examples include modeling loop bounds with symbolic states, comparing termination contexts, and serializing analysis results for external tools.",
      "description_length": 802,
      "index": 767,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Queries.Protection",
      "library": "goblint.lib",
      "description": "This module defines two protection levels, Strong and Weak, to determine whether a mutex protects a global variable in a concurrent program. It provides comparison and hashing operations for these protection levels. Use cases include analyzing thread safety and ensuring proper synchronization of global variables in multi-threaded programs.",
      "description_length": 341,
      "index": 768,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Svcomp.TaskResult-Arg-Node",
      "library": "goblint.lib",
      "description": "This module defines operations for comparing, hashing, and converting task result nodes, which represent program points in SV-COMP analysis. It provides functions to extract associated control flow graph nodes, context IDs, and path IDs, along with a move operation that optionally updates the node's CFG location. Concrete use cases include tracking and differentiating analysis results at specific program points during static analysis.",
      "description_length": 438,
      "index": 769,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.VectorMatrix.ArrayVector",
      "library": "goblint.lib",
      "description": "This module provides array-based vector operations for creation, element-wise transformations, in-place modifications, and comparisons. It works with generic vectors of elements `A.t`, supporting indexed access, functional updates, and direct array conversions. Suitable for performance-critical applications requiring efficient array-backed vector manipulations or interoperability with list/array-based data structures.",
      "description_length": 421,
      "index": 770,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.PthreadSignals.Spec",
      "library": "goblint.lib",
      "description": "This module models state transitions and context management in concurrent C programs, focusing on synchronization events like thread creation, signal handling, and function calls. It manipulates abstract domains representing dataflow states (`D.t`), global states (`G.t`), control states (`C.t`), and variable/path abstractions (`V`, `P`) to analyze interactions involving Pthread condition variables, enabling tasks like tracking signal propagation, resolving synchronization dependencies, and maintaining analysis precision during context switches. Child modules enhance this capability by providing lattice operations for signal propagation states, path-representative types for context-sensitive analysis, and abstract values for tracking thread signals and race conditions. Together, they support static analysis tools in verifying correctness of concurrent synchronization behaviors and reporting potential concurrency issues.",
      "description_length": 932,
      "index": 771,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.PrecCompareUtil.S-RH-Infix",
      "library": "goblint.lib",
      "description": "This module defines infix operators for interacting with a BatHashtbl structure, providing direct access and modification of key-value bindings. The `-->` operator retrieves the current value associated with a key, while `<--` adds a new binding that hides previous ones until removed. These operations are useful for managing scoped or layered state where temporary overrides are needed, such as in symbolic execution or constraint solving.",
      "description_length": 441,
      "index": 772,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.VectorMatrix.AbstractMatrix",
      "library": "goblint.lib",
      "description": "This module provides operations for constructing, transforming, and analyzing matrices through in-place modifications and functional transformations. It works with matrices containing elements of type `A.t`, represented internally using vectors from the associated `V` module, and supports operations like row/column manipulation, element-wise mapping, normalization, and structural checks. It is suitable for numerical algorithms, data processing pipelines, or symbolic computation tasks requiring efficient matrix manipulations with optional side effects.",
      "description_length": 557,
      "index": 773,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "Goblint_lib.PoisonVariables.Spec",
      "library": "goblint.lib",
      "description": "This module performs taint tracking for variables affected by non-local control flow jumps (`setjmp`/`longjmp`), using a set-based representation (`VS.t`) to model poisoned states. It provides operations to update, query, and sanitize tainted variable sets during static analysis, integrating with analysis contexts (`ctx`) and abstract domains (`D.t`) to handle CIL expressions, assignments, and function scopes. The child module enhances this by defining lattice and set-theoretic operations over tainted variable sets, supporting join/meet, union/difference, and comparison, enabling precise tracking of invalidated `CilType.Varinfo.t` variables across non-local gotos. Together, they ensure detection of unsafe accesses to indeterminate values in C programs using exception-like control flows.",
      "description_length": 797,
      "index": 774,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Analyses.SpecSysSol-SpecSys-EQSys",
      "library": "goblint.lib",
      "description": "This module defines a system of equations over local and global variables, supporting iterative solving with change tracking. It provides operations to construct and manipulate constraint systems involving variable assignments and dependencies, using variable queries to select subsets of variables. Concrete use cases include solving dataflow equations for static analysis, where variable states propagate through program points until fixpoint.",
      "description_length": 445,
      "index": 775,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.MutexTypeAnalysis.Spec",
      "library": "goblint.lib",
      "description": "This module coordinates static analysis of mutex types through abstract states, global environments, and control contexts, enabling detection of type mismatches in concurrent programs. It integrates constraint variable management, type comparison, and lattice operations to model mutex behavior across threads and function calls. Concrete operations include tracking path-dependent constraints, resolving global type conflicts, and merging abstract states through lattice joins and meets. Specific use cases include detecting inconsistent locking, solving type constraints, and generating analysis witnesses during concurrency checks.",
      "description_length": 634,
      "index": 776,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.SpecLifters.DeadBranchLifter",
      "library": "goblint.lib",
      "description": "This module analyzes unreachable code paths by modeling state transitions during static analysis of control flow, conditionals, and interprocedural behavior, using abstract domains for program states (`D`), global variables (`G`), constraints (`C`), and value analyses (`V`). It includes submodules that define lattice operations for abstract domains `D.t` and `G.t`, enabling join/meet, widening/narrowing, and ordering checks; data types and operations for global constraint variables (`C.t`) and path-representative values (`P.t`) for tracking and comparing execution paths; and context management for lifted analyses with unique identifiers. Direct APIs handle function boundaries, variable assignments, and concurrency primitives, supporting dead code elimination and safety checks in concurrent programs through precise abstract interpretation. Example uses include constraint solving, witness generation, and path-based analysis with context-sensitive dataflow tracking.",
      "description_length": 977,
      "index": 777,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.RegionDomain.RS",
      "library": "goblint.lib",
      "description": "This module implements a region set domain for static analysis, featuring set operations (union, intersection, difference, subset checks) and lattice operations (bot, top, narrow) to manage abstract memory regions. It operates on sets of variable fragments (VF.t) and VFB elements, enabling transformations like adding/removing bullets or replacing variables to model heap memory and analyze disjoint region boundaries. The functionality supports abstract interpretation tasks such as tracking dynamic memory allocations and variable associations in low-level code.",
      "description_length": 565,
      "index": 778,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.IntDomainProperties.WithIkind",
      "library": "goblint.lib",
      "description": "This module combines lattice, arithmetic, bitwise, and comparison operations on an abstract integer domain with support for typed integer kinds, enabling precise static analysis of integer behaviors in programs. It provides the core type `t` representing abstract integers with bottom and top values, and integrates `ikind` for specifying bitwidth and signedness, ensuring operations respect type constraints during analysis. You can perform join and meet to combine value ranges, apply arithmetic and bitwise transformations, and use property-based testing to validate domain correctness across different integer types. Submodule `ikind` works with `GoblintCil.Cil.ikind` to enforce correct handling of signed and unsigned integers like `I8`, `I32`, or `I64` in abstract operations.",
      "description_length": 783,
      "index": 779,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MHPAnalysis.Spec",
      "library": "goblint.lib",
      "description": "This module orchestrates concurrency analysis by transforming abstract states to model thread interactions, memory access patterns, and control flow around function calls and synchronization events. It defines core operations over analysis states (`D.t`), CIL constructs (`lval`, `exp`, `fundec`), and context objects, enabling precise tracking of parallel execution paths. Its child module specializes in may-happen-in-parallel (MHP) analysis, determining whether two program points may execute concurrently by tracking active thread sets and their execution constraints. Together, they support concrete tasks like race condition detection and synchronization optimization by combining high-level state transitions with fine-grained thread-aware analysis.",
      "description_length": 756,
      "index": 780,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Server.ArgWrapper-Arg",
      "library": "goblint.lib",
      "description": "This module wraps command-line argument parsing and handling functionality, specifically for configuring and launching the interactive server mode. It operates on argument nodes and edges, managing transitions between parsing states. Concrete use cases include defining command-line options, processing user input, and initializing server configurations based on parsed arguments.",
      "description_length": 380,
      "index": 781,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Analyses.IdentitySpec",
      "library": "goblint.lib",
      "description": "This module facilitates identity analysis for program constructs like assignments, function calls, and branches, propagating abstract states through control-flow transitions. It operates on abstract representations of program elements (e.g., variables, expressions, function definitions) and includes concurrency modeling via thread creation and synchronization mechanisms. It is particularly useful for static analysis tasks requiring precise tracking of variable identities across complex program paths and parallel execution contexts.",
      "description_length": 537,
      "index": 782,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.YamlWitnessType.LocationInvariant",
      "library": "goblint.lib",
      "description": "This module defines and manipulates location-invariant records in the YAML witness format, specifically handling their comparison and parsing from YAML values. It operates on the `t` type, which pairs a location with an invariant, and provides `compare` for ordering and `of_yaml` for deserialization. It is used to process and validate YAML-encoded location-invariant data during witness parsing.",
      "description_length": 397,
      "index": 783,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.DomainProperties.Connect",
      "library": "goblint.lib",
      "description": "Implements QCheck property tests for lattice structures, specifically verifying connectivity properties such as least upper bounds and greatest lower bounds. Works directly with lattice data types through the provided `D` module. Useful for testing correctness of lattice implementations in static analysis domains.",
      "description_length": 315,
      "index": 784,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Constraints.Increment",
      "library": "goblint.lib",
      "description": "Implements incremental constraint solving for analysis specifications by tracking and updating constraint data as the program state evolves. It operates on constraint systems and analysis data structures, specifically handling additions or modifications to constraints without full recomputation. This supports efficient re-analysis in scenarios like iterative program changes or dynamic analysis updates.",
      "description_length": 405,
      "index": 785,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Base.MainSpec-A",
      "library": "goblint.lib",
      "description": "This module defines operations for a base analysis type, including equality, hashing, comparison, and pretty-printing functions. It works with a concrete type `t` representing abstract values in a non-relational analysis. Use cases include managing abstract values with unique identifiers, checking potential race conditions between values, and generating structured output for analysis results.",
      "description_length": 395,
      "index": 786,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.CommonPriv.PerMutexTidCommon",
      "library": "goblint.lib",
      "description": "This module tracks thread-modular value analysis for mutex-protected data, modeling interactions between threads and mutexes using abstract domains like `LD` and `W`. It coordinates with submodules to represent lock states, variable references, and thread identifiers as sum types, manage per-lock state with finite maps and lattice combinators, and merge analysis states using domain-specific operations like widening and join. Specific capabilities include determining possible values written under a mutex, analyzing lock dependencies, and lifting abstract states across thread-mutex interactions. The design integrates polymorphic variants, dictionaries, and lattice hierarchies to support precise, scalable concurrency analysis.",
      "description_length": 733,
      "index": 787,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.PrecCompareUtil.S-RH-Labels",
      "library": "goblint.lib",
      "description": "This module provides labeled argument versions of standard Hashtbl operations, enhancing readability and argument order flexibility. It works with hashtables where keys are of type `RH.key` and data can be any type `'a`. Concrete use cases include adding or replacing entries with explicitly labeled keys and data, iterating and folding over tables with key-value pairs, and performing conditional modifications or merges based on keys.",
      "description_length": 436,
      "index": 788,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.YamlWitnessType.FlowInsensitiveInvariant",
      "library": "goblint.lib",
      "description": "This module defines a YAML witness type for flow-insensitive invariants, including parsing from YAML and comparison operations. It works with the `t` record type containing an `Invariant.t` value. It is used to represent and validate static analysis witnesses in a flow-insensitive context, such as checking invariants across program points without tracking control flow.",
      "description_length": 371,
      "index": 789,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Analyses.Spec2Spec-G",
      "library": "goblint.lib",
      "description": "This module provides lattice-theoretic operations including join, meet, widen, and narrow, alongside top element manipulation via `top` and `is_top`. It operates on an abstract domain type `G.t` designed for static analysis, incorporating equality checks, comparison, and pretty-printing capabilities. The structure supports practical use cases in abstract interpretation, such as constraint system resolution and analysis state serialization, with auxiliary tools for testing and XML-based output.",
      "description_length": 498,
      "index": 790,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.ExtractPthread.Resource",
      "library": "goblint.lib",
      "description": "This module defines and manipulates resource identifiers for Pthread-related entities such as threads and functions. It provides constructors and accessors for pairing resource types with names, along with string formatting and display functions. It is used to represent and serialize Pthread program elements during Promela extraction.",
      "description_length": 336,
      "index": 791,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Graphml.ArgNodeGraphMlWriter",
      "library": "goblint.lib",
      "description": "This module writes GraphML files by streaming data to an output channel. It supports defining graph elements such as nodes and edges, attaching metadata, and specifying keys for attributes. It is used to serialize structured graphs with labeled nodes and edges, suitable for visualization or analysis tools that consume GraphML.",
      "description_length": 328,
      "index": 792,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.IntDomainProperties.OldSWithIkind-Ikind",
      "library": "goblint.lib",
      "description": "This module defines integer kind values for use in abstract domains, specifically providing the `ikind` function to generate signed and unsigned integer types of varying bit widths. It works with the `ikind` type from GoblintCil to specify the size and signedness of integers in domain operations. It is used to configure abstract domains for precise integer value analysis in static program analysis.",
      "description_length": 401,
      "index": 793,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.LocksetAnalysis.MayArg-V",
      "library": "goblint.lib",
      "description": "This module defines a value type `t` with operations for equality, comparison, hashing, and pretty-printing, along with serialization to XML and Yojson. It supports generating arbitrary values for testing, relifting values, and checking if a value is write-only. Concrete use cases include representing abstract lockset elements in concurrency analysis and enabling efficient, precise comparison and serialization within static analysis frameworks.",
      "description_length": 448,
      "index": 794,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Base.MainSpec-P",
      "library": "goblint.lib",
      "description": "This module defines operations for managing global constraint variables used in path-sensitive analysis. It provides equality checks, hashing, comparison, and string representation for these variables, along with serialization to XML and JSON formats. The module supports lifting elements from another domain and generating arbitrary values for testing, using a unique tag for context identification.",
      "description_length": 400,
      "index": 795,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Timeout.Js",
      "library": "goblint.lib",
      "description": "Implements timeout handling for function calls in JavaScript environments. Provides a `timeout` function that wraps a function call, enforcing a time limit on its execution. Useful for preventing infinite loops or long-running computations in browser-based OCaml applications.",
      "description_length": 276,
      "index": 796,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Analyses.UnitV",
      "library": "goblint.lib",
      "description": "This module defines a unit value analysis with operations for equality, comparison, and hashing. It provides functions for pretty-printing, serialization to XML and Yojson, and QCheck arbitrary value generation. Concrete use cases include stub analysis implementations and testing of analysis framework components.",
      "description_length": 314,
      "index": 797,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.YamlWitnessType.Task",
      "library": "goblint.lib",
      "description": "This module defines a record type for representing task information in a YAML witness format, including input files, their hashes, data model, language, and optional specification. It provides functions to convert this task type to and from YAML values for serialization and parsing. This supports concrete use cases like storing and retrieving structured task metadata in YAML-based witness files.",
      "description_length": 398,
      "index": 798,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Server.ArgWrapper",
      "library": "goblint.lib",
      "description": "This module wraps JSON-RPC request arguments for interactive server operations, converting string identifiers into structured node references. It processes request parameters to locate and return corresponding AST or CFG nodes using the Locator module. Directly used during JSON-RPC method execution to map string-based input to internal node representations.",
      "description_length": 359,
      "index": 799,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.WitnessUtil.NH",
      "library": "goblint.lib",
      "description": "This module offers efficient mutable mappings between node keys (`Node.t`) and arbitrary values, supporting standard operations like insertion, deletion, lookup, and bulk initialization from sequences of key-value pairs. It centers on the `NH.t` hash table type, enabling iteration, folding, and conversion to lazy sequences for incremental processing. Designed for scenarios requiring dynamic node-centric data tracking\u2014such as witness generation or invariant computation\u2014it facilitates bulk updates and efficient lookups, ideal for managing relationships between nodes in program analysis or graph-based workflows.",
      "description_length": 616,
      "index": 800,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.LongjmpLifter.Lifter",
      "library": "goblint.lib",
      "description": "This module performs abstract interpretation for programs with non-local control flow, using structured analysis contexts and abstract domains to track state across setjmp/longjmp and thread-aware execution paths. It defines core types like `D.t` for abstract values, `G.t` for global state, and `C.t` for contexts, with operations to merge, compare, and serialize them, enabling precise interprocedural analysis. Submodules provide lattice operations, equality and ordering functions, constraint variable handling, and path-representative types that lift and project values to model control flow transitions. Example uses include merging divergent states after longjmp, tracking jump targets across functions, and serializing analysis results for reporting or testing.",
      "description_length": 769,
      "index": 801,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Analyses.Dom",
      "library": "goblint.lib",
      "description": "This module provides lattice-based abstract interpretation operations for analyzing potentially invalid or dead states in static analysis. It defines a lifted domain structure that extends an underlying domain `LD.t` with `Bot` (dead code) and `Top` (overapproximated) values, supporting join/meet operations, widening/narrowing for fixpoint computation, and state comparison/serialization. It is specifically used to model scenarios where program states may become invalid or unreachable, enabling precise dead-code detection and propagation in constraint systems.",
      "description_length": 565,
      "index": 802,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.UnassumeAnalysis.FH",
      "library": "goblint.lib",
      "description": "This module provides imperative hash table operations for mapping function definitions (`CilType.Fundec.t`) to arbitrary values, supporting efficient lookups, in-place modifications, and bulk transformations from sequential data. It is designed to track function-specific unassume events derived from YAML witness invariants during static analysis of C code, enabling dynamic invariant enforcement by associating runtime assumptions with their corresponding function contexts. The structure facilitates traversal, filtering, and statistical analysis of these mappings, optimizing scenarios where function-level state must be dynamically adjusted based on external configuration.",
      "description_length": 678,
      "index": 803,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MemLeak.Spec",
      "library": "goblint.lib",
      "description": "This module orchestrates memory leak tracking in C programs by managing analysis states through initialization and finalization routines, handling variable declarations, assignments, control flow, function calls, and concurrency. It defines core operations over abstract program states, global variables, and execution contexts, enabling interprocedural leak detection across complex scenarios like function returns and inline assembly. The module\u2019s submodules refine this functionality with specialized data types: lattice operations merge and compare memory states, context management tracks and differentiates analysis paths, constraint variables model global conditions, and path representations identify unique execution traces. Together, these components support concrete tasks like race condition detection, witness generation, and structured output for debugging or reporting.",
      "description_length": 884,
      "index": 804,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Server.ArgWrapper-Locator-ES-Labels",
      "library": "goblint.lib",
      "description": "This module provides operations for iterating over, transforming, and querying collections of elements from a specific data structure, supporting actions like mapping functions, filtering based on conditions, and checking logical predicates across elements. It works directly with `Locator.ES.t`, an abstract collection type representing a set or sequence of `Locator.ES.elt` elements. Concrete use cases include processing and analyzing structured data elements in bulk, such as filtering relevant entries or applying side effects to each element during server-side JSON-RPC operations.",
      "description_length": 587,
      "index": 805,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ExtractPthread.Variable",
      "library": "goblint.lib",
      "description": "This module provides functions to analyze and construct variable information from lvalues and lhosts, specifically handling `varinfo` types from `GoblintCil.Cil`. It includes predicates to check variable properties such as being integral, global, or memory-related, and utilities to convert and display variable data. Concrete use cases include extracting variable details during Promela translation and filtering variables based on their role in pthread programs.",
      "description_length": 464,
      "index": 806,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.CompareConstraints.CompareGlobSys",
      "library": "goblint.lib",
      "description": "This module compares global and local constraint systems between analyses, identifying discrepancies in constraint values associated with variables represented as hash tables. It provides operations to detect differences in constraints and contexts, using a custom pretty-printing module to format and track changes during comparison. The core structure organizes constraint data using a polymorphic map with `Node.t` keys, supporting transformations, conditional updates, and sequence conversions. Submodules enhance this with safe querying, predicate-based manipulations, and infix operators for context-aware formatting, enabling tasks like tracking labeled constraints, transforming node-associated data, and producing structured analysis output.",
      "description_length": 750,
      "index": 807,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.AutoTune.FunctionCallMap",
      "library": "goblint.lib",
      "description": "This module supports operations for managing mappings of CIL function identifiers to polymorphic values, enabling autotuning of analysis configurations through syntactic heuristics. It provides standard map manipulations like insertion, filtering, and traversal, along with ordered sequence conversions for structured processing of function call data. Designed for static analysis of C code, it facilitates tracking and optimizing function call behavior in program contexts where variable identifiers dictate tuning decisions.",
      "description_length": 526,
      "index": 808,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.PrecCompareUtil.S-RH",
      "library": "goblint.lib",
      "description": "This module provides imperative hash table operations for managing key-value pairs with `Key.t` keys and polymorphic values, supporting creation, modification, iteration, and querying. It includes utilities for mapping, filtering, merging, and converting between hash maps and sequences/lists, enabling efficient data transformation. The module is suited for handling structured data where precision-sensitive comparisons and flexible manipulation of key-value associations are required.",
      "description_length": 487,
      "index": 809,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.AbstractionDomainProperties.AbstractTest",
      "library": "goblint.lib",
      "description": "This module defines equality checks between abstract domain values and provides functions to create QCheck tests for abstract operations. It works with concrete data types `CD.t` and abstract domain types `AD.t`, using QCheck's arbitrary generators and test frameworks. Concrete use cases include testing correctness of abstract interpretations by comparing abstract values and generating test cases for domain-specific properties.",
      "description_length": 431,
      "index": 810,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Analyses.IdentityUnitContextsSpec",
      "library": "goblint.lib",
      "description": "This module provides operations for context-sensitive analysis of program elements like variable declarations, control flow branches, and function calls, alongside concurrency handling via thread creation and context switching. It operates on abstract analysis states and CIL syntax representations (e.g., `lval`, `exp`, `fundec`), enabling use cases such as tracking variable liveness across control flow paths and modeling thread interactions in concurrent programs.",
      "description_length": 468,
      "index": 811,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.AutoTune.VariableMap",
      "library": "goblint.lib",
      "description": "This module implements a map specialized for CIL variable keys with polymorphic values, supporting associative operations like insertion, lookup, and updating, as well as merging, filtering, and conversions to/from lazy sequences. It enables autotuning workflows by analyzing variable usage patterns and managing variable-specific data in static analysis through structural manipulations (e.g., partitioning, key-based traversal) and semantic inspections.",
      "description_length": 455,
      "index": 812,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.IntDomainProperties.OldS",
      "library": "goblint.lib",
      "description": "This module supports lattice operations (join, meet, widening), arithmetic manipulations (addition, division, remainders), and bitwise transformations (AND, OR, shifts) over an abstract integer domain type `t`. It models integer value abstractions for static analysis tasks like program verification, enabling reasoning about properties such as ranges, overflows, and bit-level behaviors. The type `t` encapsulates domain-specific approximations of integer states, with utilities for comparison, serialization, and logical conversions to booleans or exclusion lists.",
      "description_length": 566,
      "index": 813,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Analyses.Var",
      "library": "goblint.lib",
      "description": "This module represents and manipulates variables within an analysis framework, providing operations for equality checks, comparison, hashing, and identifier extraction. It works with the `Node.t` type, which represents variables in the analysis context. Concrete use cases include tracking variable identities during constraint solving and enabling efficient variable-based dataflow computations.",
      "description_length": 396,
      "index": 814,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.PrecCompare.Comparison",
      "library": "goblint.lib",
      "description": "This module represents and manipulates precision comparison results between two analyses. It provides operations to aggregate comparison outcomes, convert them to human-readable strings, and calculate total counts. Use cases include summarizing and comparing the precision of different static analysis configurations in terms of equality, dominance, and incomparability.",
      "description_length": 370,
      "index": 815,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Callstring.Callsite",
      "library": "goblint.lib",
      "description": "This module represents call sites in call string analysis, providing operations to create, compare, and serialize call site instances. It works with function definitions and analysis contexts to track invocation points uniquely, including generating XML and JSON representations for external tools. Concrete use cases include identifying and distinguishing call sites during static analysis to support context-sensitive data flow tracking.",
      "description_length": 439,
      "index": 816,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Analyses.Spec",
      "library": "goblint.lib",
      "description": "This analysis specification defines abstract interpretation components like domain operations and transfer functions for program statements and control flow. It operates on abstract states, contexts, and function declarations to enable context-sensitive analysis, handling of function calls, threads, and control flow events. Key use cases include static analysis tasks requiring precise state propagation and context-aware processing of program elements.",
      "description_length": 455,
      "index": 817,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.BaseInvariant.Eval-V",
      "library": "goblint.lib",
      "description": "This module defines operations for evaluating and comparing abstract values in a dataflow analysis, including equality, hashing, comparison, and pretty-printing. It works with abstract value types that represent program invariants, such as constants, intervals, or symbolic expressions. Concrete use cases include tracking variable bounds, refining branch conditions, and generating human-readable or machine-readable representations of analysis results for debugging or external tools.",
      "description_length": 486,
      "index": 818,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Violation.PathArg",
      "library": "goblint.lib",
      "description": "Handles path-based violation analysis in an abstract reachability graph (ARG). It tracks and analyzes paths through the graph to identify potential violations, working with nodes and edges defined by the `Node` and `Edge` modules. Useful for detecting issues like unreachable code or invalid state transitions during static analysis.",
      "description_length": 333,
      "index": 819,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Svcomp.Task-Cfg",
      "library": "goblint.lib",
      "description": "This module provides operations to analyze and manipulate control flow graphs (CFGs) for SV-COMP tasks, specifically tracking previous and next CFG states and identifying skipped AST statements during CFG creation. It works with CFG structures (`MyCFG.cfg`) and nodes (`MyCFG.node`) to extract edges and statement lists. Concrete use cases include determining unreachable code paths and reconstructing the original AST context from CFG transitions.",
      "description_length": 448,
      "index": 820,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.MCPRegistry.GlobalDomainListSpec",
      "library": "goblint.lib",
      "description": "Implements a list-based specification for managing a collection of lattice domains indexed by integers. Provides operations to retrieve a domain by index and list all registered domains with their indices. Used to define and access a fixed set of global analysis domains in a dynamic analysis product configuration.",
      "description_length": 315,
      "index": 821,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Queries.SD",
      "library": "goblint.lib",
      "description": "This module provides lattice operations for a security domain used in static analysis to model information flow between distinct security levels. It works with an abstract type representing three states: a bottom element (lowest security), a lifted string value (specific security label), and a top element (highest security). These operations enable tracking and enforcing security policies during abstract interpretation by comparing and combining security levels of program variables.",
      "description_length": 487,
      "index": 822,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.LockDomain.MustLocksetRW",
      "library": "goblint.lib",
      "description": "This module provides set operations (union, subset, filtering) and lattice manipulations (join, meet, widening) over lifted sets of read-write locks, represented as either a concrete collection of `MustLockRW` elements or an abstract `Top` value. It supports static analysis tasks like tracking must-locked dependencies in concurrent programs, enabling fixpoint computations and conversions to other lockset domains, with utilities for comparison, pretty-printing, and XML serialization. The design facilitates abstract interpretation by modeling lock acquisition requirements for read/write operations on shared resources.",
      "description_length": 623,
      "index": 823,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.YamlWitnessType.Metadata",
      "library": "goblint.lib",
      "description": "This module defines metadata for YAML witness files, including format version, UUID, creation time, producer, and optional task. It provides serialization to and from YAML format for structured metadata representation. Used to store and parse metadata in YAML witness files conforming to the witness format specification.",
      "description_length": 321,
      "index": 824,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.WitnessUtil.InvariantExp",
      "library": "goblint.lib",
      "description": "This module processes CIL expressions to extract and manipulate logical conjuncts for invariant generation in static analysis. It breaks down expressions into simplified forms and identifies common logical components, supporting tasks like invariant comparison, combination, and serialization. The core operations work on an abstract type representing sets of CIL expressions, offering set-theoretic functions like union and intersection, lattice operations such as join and meet, and transformations to XML or Yojson. These capabilities enable precise modeling of program invariants during verification workflows.",
      "description_length": 614,
      "index": 825,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.BaseInvariant.Eval",
      "library": "goblint.lib",
      "description": "This module evaluates expressions and lvalues in the context of a dataflow analysis, performing operations like unop application, variable and memory access, and value refinement. It works with data types such as `D.t`, `VD.t`, `AD.t`, `ID.t`, and `FD.t`, alongside CIL types like `exp`, `lval`, and `typ`. Concrete use cases include evaluating right-hand side expressions, refining variable values during analysis, and handling memory writes with offset conversion and type information.",
      "description_length": 487,
      "index": 826,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Analyses.SpecSys-GHT",
      "library": "goblint.lib",
      "description": "This module provides imperative hash table management with functional transformation capabilities for key-value stores where keys are analysis-specific variables (`EQSys.GVar.t`). It supports efficient operations like conditional updates, key-aware filtering, and merging, alongside conversions to sequences, lists, and formatted outputs. These tools are suited for analysis frameworks requiring structured data manipulation, such as tracking variable constraints or aggregating intermediate results in static analysis pipelines.",
      "description_length": 529,
      "index": 827,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.BaseInvariant.Eval-G",
      "library": "goblint.lib",
      "description": "This module implements lattice operations for abstract interpretation, including comparison, extremal value checks, and structural manipulation of lattice elements. It operates on a parametric type `G.t` representing abstract values, supporting static analysis tasks like program invariant tracking through join/meet operations and top/bottom element detection. The functionality enables reasoning about program states in a generalized lattice framework, particularly for branch refinement in base analysis.",
      "description_length": 507,
      "index": 828,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Access.A",
      "library": "goblint.lib",
      "description": "This module represents and manipulates memory access information, including configuration, access kind, associated node, expression, and nested access data. It provides operations for equality checks, comparison, hashing, pretty printing, serialization to XML and Yojson, and string representation. Concrete use cases include tracking and analyzing memory accesses during static analysis of C code, particularly for handling expressions and access paths in a type-safe manner.",
      "description_length": 476,
      "index": 829,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.SymbLocksDomain.Symbolic",
      "library": "goblint.lib",
      "description": "This module defines lattice and set operations for symbolic locksets, enabling analysis of concurrent programs through abstract domains. It supports key operations like join, meet, widen, and leq on symbolic locksets represented as `S.t`, alongside utilities for manipulation and comparison. The Lifted submodule provides concrete set-like operations over symbolic expressions (`CilType.Exp.t`), including membership, union, and intersection, while handling over-approximation with a top element. Together, they allow tracking and merging of lock states during static analysis to reason about potential concurrency errors.",
      "description_length": 622,
      "index": 830,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.PrecCompareUtil.R-RH-Exceptionless",
      "library": "goblint.lib",
      "description": "This module provides safe lookup and modification operations for hash tables, returning optional values or result types instead of raising exceptions. It works with hash tables (`Hashtbl`) where keys and values can be of arbitrary types. Concrete use cases include safely retrieving values without handling exceptions and applying in-place transformations to entries while handling potential errors explicitly.",
      "description_length": 410,
      "index": 831,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.UnitAnalysis.Spec",
      "library": "goblint.lib",
      "description": "This module implements abstract interpretation callbacks for a unit domain analysis, focusing on operations that manipulate abstract states (`D.t`) during program analysis. It processes assignments, control flow constructs, function calls, and thread lifecycle events using CIL expressions (`GoblintCil.exp`), statements (`GoblintCil.lval`), and function definitions (`GoblintCil.fundec`), while managing context transitions for interprocedural and concurrent code analysis. The specification supports static analysis of program behavior by combining domain-specific effects with syntactic program elements.",
      "description_length": 607,
      "index": 832,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.ThreadFlagDomain.S",
      "library": "goblint.lib",
      "description": "This module provides lattice operations for analyzing thread-related states in concurrent programs, including join/meet combinators and comparison utilities. It works with a type `t` representing hierarchical thread contexts like single-threaded, multi-threaded, and main-thread flags, alongside bottom elements for uninitialized states. The functionality supports static analysis of multi-threaded code, enabling precise tracking of thread interactions and debugging of abstract domain transitions.",
      "description_length": 499,
      "index": 833,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.BaseDomain.CPA",
      "library": "goblint.lib",
      "description": "This module implements a lattice-based abstract domain for control point analysis, combining map-like structures with constraint propagation. It supports key-value pairs where keys are hashed and cached, and values form an abstract domain with operations like join, meet, and widening. The module enables tracking and merging abstract states across program control points, facilitating static analysis tasks such as value propagation and fixed-point computation. Submodules extend this with variable-based mappings, structural comparison, and serialization, enhancing analysis precision through customizable merging strategies and higher-order transformations.",
      "description_length": 660,
      "index": 834,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.LocksetAnalysis.MakeMay",
      "library": "goblint.lib",
      "description": "This module coordinates static analysis of concurrent programs by tracking potential lock acquisitions and releases across execution paths, integrating thread spawning and synchronization handling with abstract states (`D.t`), environments, and contexts. Its child modules define lattice structures and abstract domains for representing locksets, supporting operations like join, meet, widen, and narrow to model lock dependencies and detect race conditions or deadlocks. The analysis tracks sets of locks that might be held at each program point, using abstract states to infer potential synchronization issues and provide debugging output. Together, these components enable precise may-lockset analysis for verifying thread safety and identifying concurrency errors in programs with shared memory access.",
      "description_length": 806,
      "index": 835,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.RaceAnalysis.Spec",
      "library": "goblint.lib",
      "description": "This module performs data race analysis by tracking memory accesses through hierarchical trie structures that capture relationships between memory locations based on roots, offsets, and types. It uses `OffsetTrie` to manage nested prefixes like struct fields or array indices and `MemoSet` to represent sets of access paths, enabling efficient set and lattice operations that detect overlapping accesses across threads. The analysis distinguishes access origins using a polymorphic variant type that identifies variables or type-based roots, supporting precise race reporting at the most specific access path during postsolving. Key operations include traversal, union, intersection, and lattice joins over trie-organized access sets, with concrete use cases in analyzing struct field overlaps, type coercion, and pointer arithmetic in concurrent C programs.",
      "description_length": 858,
      "index": 836,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.PrecCompareUtil.S",
      "library": "goblint.lib",
      "description": "This module supports precision comparison by providing functions to initialize comparison contexts, unmarshal results, and handle marshaled data structures. It operates on types like `Dom.t RH.t` for result hashmaps and `marshal` for serialized representations. Concrete use cases include loading and comparing analysis results across different runs or configurations.",
      "description_length": 368,
      "index": 837,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.DomainProperties.Widen",
      "library": "goblint.lib",
      "description": "Implements widening operator properties for lattice domains using QCheck tests. Works with lattice structures defined by the D module parameter. Used to verify correctness of widening operations in abstract domains for static analysis.",
      "description_length": 235,
      "index": 838,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.MyARG.StackNode",
      "library": "goblint.lib",
      "description": "This module represents a stack of nodes in an abstract reachability graph, where each stack node contains a path and context identifier. It provides operations to compare, hash, and move through the graph, returning string representations of paths and checking equality based on node and context. Concrete use cases include tracking execution paths in static analysis and managing node transitions in graph-based analysis algorithms.",
      "description_length": 433,
      "index": 839,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Queries.Set",
      "library": "goblint.lib",
      "description": "This module manages sets with a focus on safe querying and collection manipulation. It provides core operations for retrieving elements like minimum, maximum, or arbitrary values using non-exceptional `option` returns, while supporting transformations and inspections through `iter`, `fold`, `map`, and `filter` over sets of abstract query elements. Users can safely access elements, apply predicates to filter subsets, or aggregate values within static analysis workflows. Specific use cases include querying for specific elements without raising errors and applying analysis passes over sets of abstract values.",
      "description_length": 613,
      "index": 840,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.DeadCode.RemoveDeadCode",
      "library": "goblint.lib",
      "description": "Performs dead code elimination on CIL files by removing unused functions, variables, and code paths. It operates on the CIL intermediate representation, analyzing reachability and side effects to determine which code elements are unreachable. This module is used during static analysis to simplify programs and improve performance of subsequent analyses.",
      "description_length": 354,
      "index": 841,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.LocksetAnalysis.MustArg-V",
      "library": "goblint.lib",
      "description": "This module represents values used in lockset analysis, providing operations for equality, hashing, comparison, and string representation. It works with abstract lockset values to track synchronization primitives in concurrent programs. Concrete use cases include analyzing must-alias information for locks and reasoning about thread synchronization at specific program points.",
      "description_length": 377,
      "index": 842,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.StackTrace.Spec1",
      "library": "goblint.lib",
      "description": "This module coordinates static analysis contexts by tracking call stacks and managing control flow, function calls, and thread spawns over abstract domains and CIL elements. It supports interprocedural and concurrent analysis through lattice operations, stack manipulation primitives, and context-sensitive state transitions. Child modules refine this behavior with unit values, singleton traces, and lattice-structured call stacks, enabling precise modeling of program flow across function boundaries and recursive structures. Specific capabilities include merging stack states during analysis, tagging contexts with unique identifiers, and normalizing stack traces for comparison or serialization in formats like JSON and XML.",
      "description_length": 728,
      "index": 843,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Analyses.SpecSysSol-SpecSys-Spec-P",
      "library": "goblint.lib",
      "description": "This module defines operations for managing global constraint variables, including equality checks, hashing, comparison, and string representation. It works with the abstract type `t` representing path-representative constraint variables. Concrete use cases include tracking unique constraint identifiers via `tag`, projecting constraint variables from domain elements with `of_elt`, and supporting serialization through `show`, `printXml`, and `to_yojson`.",
      "description_length": 457,
      "index": 844,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.LocksetAnalysis.MayArg-G",
      "library": "goblint.lib",
      "description": "This module provides lattice operations (join, meet, widen, narrow, bot, top), comparison operators (equal, compare, leq), and utilities for printing (show, pretty, printXml), identity tracking (tag, name), and debugging (pretty_diff, relift) for the `G.t` type. It operates on abstract values representing lockset or aliasing states in a static analysis lattice, enabling precise modeling of may-alias or may-lock dependencies. These capabilities are critical for static analysis frameworks analyzing concurrency-related properties or pointer aliasing in programs.",
      "description_length": 565,
      "index": 845,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Violation.UnknownFeasibility",
      "library": "goblint.lib",
      "description": "This module checks the feasibility of a path in an abstract reachability graph (ARG) represented as a list of node-edge-node triples. It returns whether the path is feasible, infeasible (with a counterexample trace), or unknown. Concrete use cases include verifying if a reported violation path in static analysis can be realized by actual program execution.",
      "description_length": 358,
      "index": 846,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Witness.WitnessTaskResult",
      "library": "goblint.lib",
      "description": "Handles the result of a verification task by providing access to the verification result, invariants, and node properties of an abstract reachability graph. It works with abstract syntax trees and invariants associated with nodes in the graph. Used to query whether a node represents a violation or a sink, and to retrieve the invariant at a given node.",
      "description_length": 353,
      "index": 847,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Witness.WitnessTaskResult-Arg",
      "library": "goblint.lib",
      "description": "Handles task results for Witness output by defining nodes and edges in an abstract reachability graph. It provides functions to access the main entry node and retrieve outgoing edges and successor nodes. This module is used to construct and traverse GraphML representations of program analysis results, specifically for visualizing reachability paths.",
      "description_length": 351,
      "index": 848,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.EvalAssert.EvalAssert",
      "library": "goblint.lib",
      "description": "This module transforms a program by inserting assertions at specific points to validate computed invariants. It works with CIL files and variable information, targeting top-level local variables at join points or after assignments, depending on configuration. Concrete use cases include verifying value ranges or state consistency during program execution by injecting assert statements directly into the code structure.",
      "description_length": 420,
      "index": 849,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.CommonPriv.ConfCheck",
      "library": "goblint.lib",
      "description": "This module evaluates configuration conditions for thread-modular analysis, determining whether branched thread creation must be handled through synchronization functions like `syncJoin` or `syncJoinCall`. It operates on boolean domains, CIL function declarations, and analysis queries to enforce context-sensitive thread behavior, such as deciding synchronization strategies based on call-site context and analysis settings. The first child module ensures correct mutex usage by validating that initialization follows a single execution path, preventing inconsistent locking behavior during analysis. The second enforces proper mutex activation by checking configuration flags, while the third validates thread flags to ensure correct path-sensitive analysis setup.",
      "description_length": 766,
      "index": 850,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.SarifType.ReportingDescriptor",
      "library": "goblint.lib",
      "description": "This module defines a data structure for representing SARIF reporting descriptors, including fields like rule ID, name, descriptions, and help links. It provides functions to convert these descriptors to Yojson format for serialization. Used to generate structured static analysis result reports in SARIF-compatible tools.",
      "description_length": 322,
      "index": 851,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Analyses.MCPSpec-A",
      "library": "goblint.lib",
      "description": "This module defines operations for managing and comparing analysis-specific values with support for hashing, equality checks, and pretty-printing. It works with a polymorphic type `A.t` representing abstract analysis elements, enabling unique identification via `tag`, comparison with `compare`, and structured output through `pretty` and `printXml`. Concrete use cases include tracking and analyzing concurrency-related values in a constraint system, such as detecting race conditions using `may_race`, and generating human-readable or machine-parseable representations for debugging and reporting.",
      "description_length": 599,
      "index": 852,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Base.MainSpec-V",
      "library": "goblint.lib",
      "description": "This module defines operations for managing global constraint variables, including equality checks, hashing, comparison, and string representation. It works with the abstract type `t` representing constraint variables, supporting serialization, pretty-printing, and generation of arbitrary values for testing. Concrete use cases include tracking and comparing constraint variables during analysis, enabling unique identification for witness generation, and facilitating debugging through XML and JSON output.",
      "description_length": 508,
      "index": 853,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Signs.SL",
      "library": "goblint.lib",
      "description": "This module provides lattice operations for sign abstraction analysis, handling three-state representations of integer signs (`bottom`, lifted values, and `top`). It works with abstract sign values to support static analysis tasks like range reasoning and comparison constraints, enabling optimizations and correctness checks in program analysis. Key operations include widening/narrowing for convergence, joins/meets for combination, and lifting for value abstraction, tailored to intraprocedural sign tracking.",
      "description_length": 512,
      "index": 854,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.AbstractionDomainProperties.AbstractFunction",
      "library": "goblint.lib",
      "description": "Implements abstract function properties for checking approximation and ordering between concrete and abstract values. Works with pairs of concrete (`c`) and abstract (`a`) types, using `abstract` to map and `check_leq` to verify that a concrete value approximates an abstract one. Useful for testing correctness of abstraction relations in static analysis domains.",
      "description_length": 364,
      "index": 855,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ResultQuery.SpecSysSol2-SpecSys-LHT-Infix",
      "library": "goblint.lib",
      "description": "This module defines infix operators for interacting with a BatHashtbl-based constraint system solution. It provides `-->` to retrieve the current binding of a key or raise `Not_found`, and `<--` to add a new binding that hides previous ones. These operations support incremental updates and backtracking over a constraint system's solution state.",
      "description_length": 346,
      "index": 856,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.AbstractionDomainProperties.ValidTest",
      "library": "goblint.lib",
      "description": "This module defines QCheck test cases to validate abstract domain operations. It works with concrete domains (`CD.t`), abstract domains (`AD.t`), and abstractions (`AF.t`). It supports testing equivalence between abstract values, generating arbitrary inputs, and validating unary and binary operations under specified conditions.",
      "description_length": 329,
      "index": 857,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.PrecCompareUtil.Util",
      "library": "goblint.lib",
      "description": "This module unmarshals and compares precision results across analysis runs using hash-based representations of key-to-domain mappings. It directly supports loading and comparing analysis data between configurations or versions, while its child module offers imperative and functional hash table operations for tracking, merging, and transforming key-value pairs with optional and result-typed safety. You can merge maps with custom logic, safely update bindings, and convert mappings to sequences or lists for further processing, all while maintaining precision consistency across runs. Infix operators and labeled functions simplify working with hashtables, making variable binding and result comparison straightforward in analysis workflows.",
      "description_length": 743,
      "index": 858,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Base.MainSpec-C",
      "library": "goblint.lib",
      "description": "Implements specifications for base analysis operations on type `t`, including equality, hashing, comparison, and serialization functions. Provides concrete functionality for handling values with unique identification via `tag` and supports pretty-printing, XML output, and JSON conversion. Designed for use in static analysis contexts requiring precise value tracking and context-sensitive comparisons.",
      "description_length": 402,
      "index": 859,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.SarifType.ArtifactLocation",
      "library": "goblint.lib",
      "description": "This module defines a SARIF artifact location with a `uri` field representing a file path or resource identifier. It includes functions to serialize to YoJSON and compare instances for equality. Used to specify source file locations in SARIF output for static analysis results.",
      "description_length": 277,
      "index": 860,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.ExtractPthread.Action",
      "library": "goblint.lib",
      "description": "This module defines actions representing low-level concurrency operations in Pthread programs, such as thread creation, mutex locking, and condition variable waits. It works with structured types like `thread`, `cond_wait`, and `mutex_id` to model program behavior during Promela extraction. Concrete use cases include modeling function calls, synchronization primitives, and control flow decisions during the analysis of concurrent C programs.",
      "description_length": 444,
      "index": 861,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Svcomp.Result",
      "library": "goblint.lib",
      "description": "This module represents and converts SV-COMP verification results to string format. It defines a sum type `t` with variants `True`, `False` (optionally carrying a specification), and `Unknown`, and provides the `to_string` function to convert these result values into human-readable strings. It is used to report and log verification outcomes in SV-COMP-compatible formats.",
      "description_length": 372,
      "index": 862,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.IntDomainProperties.All",
      "library": "goblint.lib",
      "description": "Implements QCheck property tests for integer domains, ensuring correctness of operations like addition, subtraction, and comparison. Works with abstract integer domain implementations provided by the `D` module parameter. Validates domain behavior against expected mathematical properties and edge cases.",
      "description_length": 304,
      "index": 863,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.LocksetAnalysis.MayArg",
      "library": "goblint.lib",
      "description": "This module tracks lock acquisition and release operations using abstract domains for locksets. It provides functions to add or remove locks from a lockset based on memory access addresses during analysis. Use it to model thread synchronization behavior in concurrent programs where precise lockset tracking affects analysis precision.",
      "description_length": 335,
      "index": 864,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Server.ArgWrapper-Locator-LocM-Labels",
      "library": "goblint.lib",
      "description": "This module provides operations for manipulating key-value maps with location-based keys, including adding, filtering, mapping, and folding over entries. It works with `Locator.LocM.t` structures, which associate data with location keys from the `Locator` module. Concrete use cases include tracking and transforming source code annotations or analysis results tied to specific program locations during static analysis.",
      "description_length": 419,
      "index": 865,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Server.Request",
      "library": "goblint.lib",
      "description": "Handles JSON-RPC request processing with strict parameter and response serialization. Defines operations for parsing JSON input into structured parameters, executing server logic, and converting results back to JSON. Used to implement specific JSON-RPC methods within an interactive server, such as handling client queries or state updates.",
      "description_length": 340,
      "index": 866,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.DomainProperties.DomainTest",
      "library": "goblint.lib",
      "description": "This module defines QCheck tests for lattice domain properties using arbitrary values of type `D.t`. It provides a custom equality operator `(@=)` for comparing domain elements and generates tests with configurable parameters like failure thresholds and retry counts. Concrete use cases include validating correctness of lattice operations such as `join`, `meet`, and `leq` implementations for a specific domain.",
      "description_length": 412,
      "index": 867,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Analyses.GVarG",
      "library": "goblint.lib",
      "description": "This module combines abstract values and constraint contexts into a unified lattice structure, enabling analysis of program properties through joined specifications and context sets. It supports operations to combine, compare, and refine these composite values, including join, meet, widening, and narrowing, to drive fixpoint computations in static analysis. The child module extends this by managing constraint sets as lattice elements, offering set operations enriched with fixpoint capabilities for tracking variables and propagating constraints. Together, they enable precise analysis of program behavior by merging specification logic with constraint system solving.",
      "description_length": 672,
      "index": 868,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.ExtractPthread.Env",
      "library": "goblint.lib",
      "description": "This module manages environment data for Pthread analysis, providing access to analysis context components such as domain data, tasks, and resource tracking. It operates on environment values of type `t`, which encapsulate analysis state and configuration during Promela extraction. Concrete use cases include retrieving domain-specific data, tracking control flow nodes, and managing resource usage during Pthread-to-Promela translation.",
      "description_length": 438,
      "index": 869,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Transform.PartialEval",
      "library": "goblint.lib",
      "description": "Performs partial evaluation of CIL expressions during transformation, reducing constant expressions and simplifying control flow based on known values. It operates directly on CIL AST structures, including expressions, statements, and function bodies, to optimize code before analysis. This module is used to precompute values and eliminate dead code branches in static analysis pipelines.",
      "description_length": 389,
      "index": 870,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Analyses.Spec2Spec-C",
      "library": "goblint.lib",
      "description": "This module provides operations for lifting and comparing abstract contexts, including equality, hashing, and pretty-printing. It works with the abstract type `C.t`, which represents analysis contexts. Concrete use cases include managing context identities in constraint solving and generating human-readable or machine-serializable representations of contexts for debugging and output.",
      "description_length": 386,
      "index": 871,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.StackDomain.Dom3",
      "library": "goblint.lib",
      "description": "The module provides lattice operations (join, meet, widen, narrow), comparison functions, and domain-specific checks (top/bottom) alongside a `push` operation to add values at CIL locations. It works with a lattice-structured type aliasing `Loc.t`, which represents stack domains tied to CIL locations, and includes utilities for pretty-printing and state difference analysis. This supports static analysis tools in tracking stack-based value flows and function call contexts during program analysis.",
      "description_length": 500,
      "index": 872,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ObserverAnalysis.MakePathSpec",
      "library": "goblint.lib",
      "description": "This module enables path-sensitive static analysis of C programs by managing analysis contexts and handling control flow and concurrency operations across abstract domains. It provides core data types such as path identifiers, constraint variables, and analysis contexts, each supporting equality, hashing, and serialization for tracking and distinguishing execution paths and states. Operations include lattice manipulations for merging and approximating path states, alongside utilities for generating unique identifiers and structured output for witness extraction. These features support use cases such as tracking context-sensitive data flow, identifying race conditions, and generating XML or JSON reports for external analysis tools.",
      "description_length": 740,
      "index": 873,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.DeadlockDomain.MayLockEvents",
      "library": "goblint.lib",
      "description": "This module provides a lattice-based set abstraction for tracking potential lock events in concurrent program analysis, supporting operations like union, intersection, subset checks, and lattice-theoretic joins/meets to model abstract states. It works with a set-like type `t` containing `LockEvent.t` elements or a top element representing all possible events, enabling static analysis to approximate lock acquisition patterns. The structure is used in deadlock detection to merge or compare may-lock event sets across execution paths, facilitating fixed-point computations through widening and narrowing operators.",
      "description_length": 616,
      "index": 874,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MCPRegistry.PrintableOfRepresentativeSpec",
      "library": "goblint.lib",
      "description": "This module maps analysis domains to printable representations using a registry system. It provides `assoc_dom` to retrieve a printable module by integer key and `domain_list` to list all registered domains. It works with analysis domains represented as modules conforming to `Printable.S`. Use cases include dynamically selecting and listing analysis outputs in Goblint's configurable analysis framework.",
      "description_length": 405,
      "index": 875,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MCPRegistry.DomVariantPrintable",
      "library": "goblint.lib",
      "description": "This module implements equality, hashing, comparison, and serialization for a tuple type consisting of an integer and a polymorphic object. It provides operations to convert values to strings, XML, and JSON, along with utilities for pretty printing and generating arbitrary test values. It is used to represent and manipulate context-identified tagged values in analysis specifications.",
      "description_length": 386,
      "index": 876,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.ObserverAnalysis.MakeSpec",
      "library": "goblint.lib",
      "description": "This module enables path-sensitive analysis by tracking state transitions and handling control flow constructs across abstract domains for data, global state, contexts, and variables. It supports concurrency analysis, inter-procedural effects, and complex control flow with features like marshaled state initialization and context synchronization. Child modules refine this framework by defining lattice operations for global states and analysis states, implementing observer automata for race detection, managing constraint variables and path identifiers, and specifying serializable context types. These components collectively enable precise static analysis tasks such as constraint propagation, witness generation, and context-sensitive comparisons in verification workflows.",
      "description_length": 779,
      "index": 877,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Transform.S",
      "library": "goblint.lib",
      "description": "Implements transformations applied during analysis, handling queries and file modifications. Works with CIL files and analysis queries to perform structured code transformations. Used to implement analysis-driven refactorings or instrumentation directly in the AST.",
      "description_length": 265,
      "index": 878,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Base.MainSpec",
      "library": "goblint.lib",
      "description": "This module provides transfer functions for static analysis of CIL-based programs, handling assignments, control flow, function calls, and concurrency primitives like thread spawning. It operates on abstract domains (`D`, `G`, `C`, `V`, `P`, `A`) representing program states and values, along with CIL expressions and function definitions. Key use cases include analyzing imperative control flow, interprocedural behavior, and low-level features like inline assembly or event-driven execution paths.",
      "description_length": 499,
      "index": 879,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ActiveLongjmp.Spec",
      "library": "goblint.lib",
      "description": "This module defines operations for analyzing control flow and state manipulation in CIL constructs, focusing on setjmp/longjmp handling, inter-procedural context management, and abstract domain transitions. It operates on abstract domains and analysis contexts to track non-local jump targets and propagate state across function calls, threads, and exits. Specific use cases include static analysis of C programs with complex control flow and modular abstract interpretation frameworks requiring precise handling of asynchronous state changes.",
      "description_length": 543,
      "index": 880,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "Goblint_lib.MyARG.S",
      "library": "goblint.lib",
      "description": "Implements an abstract reachability graph with nodes and edges, supporting traversal from a main entry point. Provides operations to retrieve successor nodes via outgoing edges and list all reachable node-edge pairs. Useful for static analysis tasks like control flow graph exploration or dependency tracking in program analysis.",
      "description_length": 329,
      "index": 881,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.StackDomain.S",
      "library": "goblint.lib",
      "description": "This module provides lattice operations for approximating and comparing abstract values in a call stack domain, supporting static analysis tasks like tracking function call hierarchies. It manages stack-like structures parameterized over base variables, enabling push operations to extend contexts and top-element inspection for current scope analysis. The combination of lattice joins, meets, and stack manipulation facilitates precise yet efficient abstract interpretation of recursive or nested program behaviors.",
      "description_length": 516,
      "index": 882,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Violation.ViolationArg-Node",
      "library": "goblint.lib",
      "description": "This module defines operations for comparing, hashing, and converting node values within an abstract reachability graph (ARG). It provides functions to access associated control flow graph nodes, context IDs, path IDs, and string representations of nodes, along with a move operation that optionally returns a new node based on a given CFG node. It works directly with `Node.t` values, which represent nodes in the ARG, and supports precise node comparison and manipulation in static analysis contexts.",
      "description_length": 502,
      "index": 883,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.RegionDomain.RegMap",
      "library": "goblint.lib",
      "description": "This module implements a map-based abstract domain that associates value flow variables with region sets, enabling standard map operations and domain-specific combination functions like `map2` and `merge`. It supports lattice operations (join, meet, widen, narrow) parametrized by customizable merging and comparison logic, tailored for heap region analysis in static analysis tasks. The structure facilitates tracking and combining region-value associations with domain-specific semantics, such as merging overlapping heap regions or resolving value flow constraints.",
      "description_length": 568,
      "index": 884,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.AccessDomain.EventSet",
      "library": "goblint.lib",
      "description": "This domain provides a lattice-structured set type for managing memory access events, supporting operations like union, intersection, difference, and extremal element selection alongside lattice-specific combinators such as widen and narrow. It works with sets of memory access events (`Event.t`) to model and analyze dynamic memory behaviors, enabling use cases like merging access paths, querying presence of specific accesses, or computing fixed points in static analysis. The domain also includes utilities for structured logging, comparison, and XML/JSON serialization to aid in debugging and result inspection.",
      "description_length": 616,
      "index": 885,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.DomainProperties.AllNonAssoc",
      "library": "goblint.lib",
      "description": "Implements QCheck property tests for lattice operations of a domain `D`, ensuring correctness of meet and join operations without associativity constraints. Works directly with lattice elements and their partial order relations. Useful for verifying lattice property compliance in abstract domains used in static analysis.",
      "description_length": 322,
      "index": 886,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.VectorMatrix.Vector",
      "library": "goblint.lib",
      "description": "This module provides operations for creating, modifying, and querying vectors of numeric elements, supporting element-wise transformations (`map`, `map2`), indexed access (`nth`, `set_val`), and in-place mutations (`set_val_with`, `reverse_in_place`). It emphasizes vector-to-vector computations, conversions to/from lists/arrays, and length-aware comparisons, catering to mathematical modeling, numerical analysis, and algorithms requiring efficient indexed data manipulation.",
      "description_length": 477,
      "index": 887,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.CompareConstraints.CompareHashtbl",
      "library": "goblint.lib",
      "description": "This module implements hash tables for comparing constraint domains, mapping `Var.t` keys to `Dom.t` values and providing structural equivalence checks via a `compare` function that yields both a result and a human-readable difference summary. It supports efficient insertion, lookup, and equality testing, with child modules offering specialized operations for variable-based constraints and custom hashing. Examples include tracking variable identities, detecting redundant constraints, and enabling fixpoint detection in static analysis by comparing constraint states across iterations.",
      "description_length": 589,
      "index": 888,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Timeout.Unix",
      "library": "goblint.lib",
      "description": "Implements time-limited function execution with signal-based interruption. Uses `alarm` and `setitimer` to enforce timeouts on computations, handling edge cases like partial application and signal masking. Useful for bounding analysis phases like constraint solving or interprocedural fixed-point iteration.",
      "description_length": 307,
      "index": 889,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.CommonPriv.MayVars",
      "library": "goblint.lib",
      "description": "This module provides lattice-based set operations for tracking may-variables in thread-modular static analysis, supporting union, intersection, difference, and ordered element manipulation alongside lattice operations like widening and narrowing. It works with sets of `Basetype.Variables.t` elements, offering utilities for membership checks, iteration, and state queries (e.g., `is_top`, `disjoint`) while maintaining ordered element representations. Designed for static analysis of concurrent programs, it enables tracking lifted variable sets to approximate thread interactions and shared-state modifications under approximation-aware semantics.",
      "description_length": 649,
      "index": 890,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Analyses.SpecSysSol-SpecSys-Spec-C",
      "library": "goblint.lib",
      "description": "This module defines operations for managing and manipulating analysis contexts, including equality checks, hashing, comparison, and string representations. It works with the abstract type `t` representing analysis contexts, incorporating HConsed identifiers for uniqueness. Concrete use cases include tracking distinct analysis states in constraint systems and enabling precise context-sensitive analysis through unique identification and serialization.",
      "description_length": 453,
      "index": 891,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.PrecCompareUtil.S-Key",
      "library": "goblint.lib",
      "description": "This module defines operations for comparing, hashing, and converting key values to strings or XML, specifically working with a type `t` that represents keys. It includes functions for equality checks, ordering, pretty-printing, and serialization to formats like XML and Yojson, along with utilities for generating arbitrary keys and extracting location information. Concrete use cases include managing and comparing keys in data structures like maps and sets, and supporting serialization for logging or external representation.",
      "description_length": 529,
      "index": 892,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.RegionDomain.B",
      "library": "goblint.lib",
      "description": "This module represents a singleton domain for heap regions with only a unit value, used to model absence of region distinctions. It provides comparison, hashing, and serialization operations for this unit type, ensuring compatibility with domain interfaces. Concrete use cases include serving as a placeholder region domain when region distinctions are irrelevant or unused.",
      "description_length": 374,
      "index": 893,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.BaseDomain.BaseComponents",
      "library": "goblint.lib",
      "description": "This module provides lattice operations (join, meet, widen, narrow) and utilities (equality, serialization) for abstract interpretation of program states, centered on a domain type `t` built from `PrivD.t`. It supports combining binary operations across components like CPA, PartDeps, and WeakUpdates, enabling context-sensitive static analysis where H-consed tags identify distinct program contexts. Use cases include modeling program state abstractions with customizable merging and comparison logic for static analyzers like Goblint.",
      "description_length": 536,
      "index": 894,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Vla.Spec",
      "library": "goblint.lib",
      "description": "This interface provides operations for analyzing variable-length arrays (VLAs) in C code, covering initialization, control-flow analysis, memory access tracking, function return handling, thread spawning, and scope management. It works with abstract analysis contexts, CIL expressions, lvalues, variable declarations, and VLA-specific state, following a context-passing style. The interface supports static analysis frameworks needing precise memory modeling, interprocedural dataflow analysis, and thread-aware context transitions for programs with dynamic array allocations.",
      "description_length": 576,
      "index": 895,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.DomainProperties.Leq",
      "library": "goblint.lib",
      "description": "Implements QCheck property tests for lattice operations, specifically verifying the `leq` (less than or equal) relation and its interactions with `join` and `meet`. Works with lattice elements from the provided module `D`. Useful for testing correctness of lattice implementations in abstract interpretation domains.",
      "description_length": 316,
      "index": 896,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Queries.ThreadNodeLattice",
      "library": "goblint.lib",
      "description": "This module provides lattice-theoretic operations for combining and comparing thread-node analysis states, paired with utilities for serializing results to XML/JSON, generating test values, and visualizing differences. It operates on structured pairs of `NFL.t` (node flow lattices) and `TC.t` (thread context lattices) to model concurrent program states during static analysis. Its design supports use cases like abstract interpretation of multi-threaded code, regression testing of analysis engines, and diagnostic output generation for divergent execution paths.",
      "description_length": 565,
      "index": 897,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MyARG.S-Edge",
      "library": "goblint.lib",
      "description": "This module represents edges in an abstract reachability graph, providing operations to embed control flow graph edges into this structure and convert them to string representations. It works with abstract edge types that model transitions in program analysis. Concrete use cases include tracking control flow transitions during static analysis and generating human-readable edge identifiers for debugging or reporting.",
      "description_length": 419,
      "index": 898,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Assert.Spec",
      "library": "goblint.lib",
      "description": "This module analyzes CIL code assertions and control flow effects using abstract domains and CIL constructs, managing variable handling, branching, and concurrency semantics. It leverages submodules to define lattice structures for abstract interpretation, track path representatives for constraint solving, model assertion states with extremal values, compare and serialize specifications, detect race conditions in concurrent contexts, and manipulate unique constraint variables for verification. Operations include join, meet, widen, narrow, equality checks, pretty-printing, and structured serialization across domains like `D`, `G`, `C`, and `V`. Examples include verifying program invariants, analyzing skipped statements, generating witnesses for assertion mismatches, and tracking constraints in inline assembly or multi-threaded code.",
      "description_length": 843,
      "index": 899,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Server.Function",
      "library": "goblint.lib",
      "description": "This module defines operations for handling function identifiers in the interactive server, including equality checks, comparison, hashing, and JSON serialization. It works with a record type representing functions, containing their names and source locations. It supports filtering and listing functions from CIL globals, used to manage function data during server interactions.",
      "description_length": 379,
      "index": 900,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.WideningToken.Index",
      "library": "goblint.lib",
      "description": "This module represents optional integer indices used in widening operations, providing equality checks, ordering, hashing, and serialization. It works with lifted integer domains to track or compare index values during abstract interpretation. Concrete use cases include managing iteration counts and controlling widening in static analysis contexts.",
      "description_length": 350,
      "index": 901,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Analyses.SpecSysSol-SpecSys",
      "library": "goblint.lib",
      "description": "This module combines analysis specifications with constraint system solving capabilities, handling operations like variable resolution and constraint propagation. It works with abstract domains, variable bindings, and constraint equations. Used for implementing dataflow analyses where interprocedural constraints must be resolved efficiently.",
      "description_length": 343,
      "index": 902,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Analyses.DefaultSpec",
      "library": "goblint.lib",
      "description": "This module provides default implementations for analysis specification functions, handling context initialization, finalization, and basic control flow operations like skipping and querying. It works with abstract analysis contexts and state manipulation, enabling straightforward analysis setup without custom logic. Concrete use cases include initializing analysis states, defining default responses for assembly and variable declaration handling, and managing synchronization points during static analysis.",
      "description_length": 510,
      "index": 903,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Analyses.SpecSysSol-SpecSys-LHT-Exceptionless",
      "library": "goblint.lib",
      "description": "This module provides safe lookup and modification operations for hash tables, returning optional values or result types instead of raising exceptions. It works with hash tables (`Hashtbl`) where keys and values have specific types. Use it to handle missing keys gracefully or perform in-place updates with error handling.",
      "description_length": 321,
      "index": 904,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Analyses.StdV",
      "library": "goblint.lib",
      "description": "Implements standard value analyses for static program analysis, focusing on tracking variable values and their possible states. Works with abstract values, variables, and constraint systems to determine properties like constants, intervals, or possible nullness. Used in analyses that require value propagation, such as constant folding, null dereference detection, and range analysis.",
      "description_length": 385,
      "index": 905,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.LockDomain.AddrRW",
      "library": "goblint.lib",
      "description": "This module represents a domain for tracking addresses and their associated read/write permissions. It provides operations for comparing, hashing, and pretty-printing address-permission pairs, as well as serialization to XML and Yojson formats. It is used to model and manipulate lockset information in static analysis, particularly for reasoning about memory accesses in concurrent programs.",
      "description_length": 392,
      "index": 906,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Analyses.SpecSysSol",
      "library": "goblint.lib",
      "description": "Implements analysis specifications for constraint systems with global and local state handling. Provides operations to manipulate and solve equation systems using domain-specific solvers. Useful for static analysis tasks like dataflow analysis and abstract interpretation.",
      "description_length": 272,
      "index": 907,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.DomainProperties.All",
      "library": "goblint.lib",
      "description": "Implements QCheck property tests for lattice structures defined by module D. Works directly with lattice operations like meet, join, and comparison. Useful for verifying correctness of lattice instances in abstract interpretation domains.",
      "description_length": 238,
      "index": 908,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.YamlWitnessType.Entry",
      "library": "goblint.lib",
      "description": "This module defines operations for converting entry values to and from a structured YAML format. It works with the `t` type, which combines entry type and metadata, and processes nested lists and key-value pairs in YAML. It is used to serialize and deserialize witness entries for analysis results in a specific format.",
      "description_length": 319,
      "index": 909,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Callstring.CallstringType",
      "library": "goblint.lib",
      "description": "This module defines a polymorphic type `t` representing call strings in static analysis, with operations to create, compare, hash, and serialize them. It supports integration with analysis contexts by generating new call string elements based on function definitions and analysis state. Concrete use cases include tracking call paths in context-sensitive dataflow analysis and generating unique identifiers for call sites in witness generation.",
      "description_length": 444,
      "index": 910,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.SarifType.Tool",
      "library": "goblint.lib",
      "description": "This module defines a tool record with a driver component and provides serialization to Yojson. It works with the `t` type, which includes a `driver` field of type `Goblint_lib.SarifType.ToolComponent.t`. It is used to represent and convert SARIF tool data to JSON format for output or transmission.",
      "description_length": 299,
      "index": 911,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Analyses.UnitA",
      "library": "goblint.lib",
      "description": "This module defines a unit analysis with trivial equality, comparison, and hashing operations. It provides functions for pretty-printing, serialization to XML and Yojson, and includes support for QCheck arbitrary values. It is used in contexts requiring a placeholder analysis with minimal behavior, such as testing or stubbing.",
      "description_length": 328,
      "index": 912,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.WideningTokenLifter.Dom",
      "library": "goblint.lib",
      "description": "This module extends an abstract domain by pairing values with widening token sets in a product type, enabling delayed widening operations. It inherits standard domain operations like join and meet while controlling widening based on token set stability, where widening only occurs if tokens do not increase. This mechanism is particularly useful in static analysis to refine precision by deferring convergence until token states stabilize.",
      "description_length": 439,
      "index": 913,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.SpecLifters.HashconsLifter",
      "library": "goblint.lib",
      "description": "This module lifts abstract interpretation transfer functions to operate over hash-consed domain values, enabling efficient interprocedural and concurrent static analysis with context-sensitive state transitions. It provides core operations for variable assignment, control flow branching, and function call handling, using hash-consed data types for optimized equality checks and memory usage. The child modules extend this functionality with support for constraint variables, lattice operations, and path representatives, each leveraging unique identifiers and canonical forms for analysis scalability. Use cases include tracking variable states across function calls, computing abstract value joins during dataflow analysis, and generating unique path identifiers for debugging or witness generation.",
      "description_length": 802,
      "index": 914,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.YamlWitnessType.EntryType",
      "library": "goblint.lib",
      "description": "This module defines a polymorphic variant type `t` representing different kinds of verification witness entries in YAML format, such as location invariants, loop invariants, and violation sequences. It provides functions to compare entries, retrieve their type as strings, and parse them from YAML values. It is used to distinguish and process specific witness types during static analysis result validation.",
      "description_length": 408,
      "index": 915,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.CommonPriv.WriteCenteredD",
      "library": "goblint.lib",
      "description": "This module manages variable-to-lockset mappings with support for dictionary-style operations, lattice computations, and abstract interpretation for concurrency analysis. It provides data types for variables mapped to minimal locksets, with operations for insertion, transformation, join, meet, and widen, all working over lifted-bottom map structures. Functional utilities allow iteration, comparison, serialization, and pretty-printing, facilitating analysis of thread-modular programs. Example uses include combining abstract states during static analysis and tracking lockset dependencies across concurrent code sections.",
      "description_length": 625,
      "index": 916,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Analyses.IdentityP",
      "library": "goblint.lib",
      "description": "This module implements lattice operations for combining and comparing abstract values, including join, meet, widening, and narrowing, alongside bounded elements like top and bottom. It works with a type `t` representing abstract analysis elements, typically used to track identity or context information in static analysis. These structures are particularly useful in constraint-solving scenarios where precise merging of abstract states or iterative fixpoint computations are required.",
      "description_length": 486,
      "index": 917,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ExtractPthread.Spec",
      "library": "goblint.lib",
      "description": "This module enables static analysis of concurrent C programs by managing abstract domains for state representation and providing core operations for context manipulation, control flow handling, and interprocedural analysis coordination. It supports analysis of threads, mutexes, and events using abstract types like `t` across its submodules, which define lattice operations, path tracking, thread specifications, and variable constraints, all with equality, hashing, and serialization support. Specific functionalities include tracking execution paths for witness generation, comparing thread contexts for race detection, and marshaling analysis states between phases. The module integrates with CIL constructs to enable precise, context-sensitive analysis across function calls and concurrency boundaries.",
      "description_length": 807,
      "index": 918,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.MCPRegistry.VarListSpec",
      "library": "goblint.lib",
      "description": "Implements variable list specifications for analysis domains in a dynamic product setting. Associates integer keys with analysis modules and provides operations to register and retrieve domain-specific variable specifications. Used to manage and query analysis configurations in systems requiring dynamic domain composition.",
      "description_length": 324,
      "index": 919,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MyARG.InlineEdge",
      "library": "goblint.lib",
      "description": "This module represents edges in an abstract reachability graph specialized for inline function calls. It provides operations to embed control flow graph edges into this specialized structure and convert them to string representations. It is used to model and manipulate call relationships between functions during static analysis.",
      "description_length": 330,
      "index": 920,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.WitnessUtil.YamlInvariant",
      "library": "goblint.lib",
      "description": "This module controls the emission of invariants in YAML witness files by determining which nodes qualify for inclusion, such as loop heads or nodes after locks. It works with control flow nodes (`MyCFG.node`) and locations (`GoblintCil.location`) to identify syntactic loop heads, stub nodes, and invariant-relevant positions in the code. Concrete use cases include filtering nodes for invariant generation and mapping control flow nodes to source code locations during witness construction.",
      "description_length": 491,
      "index": 921,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MemOutOfBounds.Spec",
      "library": "goblint.lib",
      "description": "This module initializes analysis contexts for static verification of C programs, tracking memory accesses and evaluating pointer arithmetic over CIL expressions and Goblint's abstract states. It validates dereferences and detects out-of-bounds violations in array indexing and pointer operations through state transitions and memory constraints. The integrated lattice module supports domain operations like join, widen, and meet on abstract memory states, enabling precise static inference of memory bounds. Example uses include verifying function return pointers, checking array bounds during loops, and ensuring valid pointer arithmetic in conditional branches.",
      "description_length": 664,
      "index": 922,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.ArgTools.NodeStyles",
      "library": "goblint.lib",
      "description": "Implements functions to determine additional styles for nodes in an abstract reachability graph based on their properties. Works with the `node` type to produce string lists representing visualization styles. Used to customize node appearance in graph outputs according to analysis results.",
      "description_length": 290,
      "index": 923,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.LocksetAnalysis.MustArg-G",
      "library": "goblint.lib",
      "description": "This module provides lattice-based static analysis operations for tracking must-argument lock dependencies in concurrent programs. It operates on a lattice-structured abstract domain (`G.t`) that models possible lock states, supporting comparisons, joins/meets, and precision adjustments via widening/narrowing to infer necessary lock holdings. The analysis is used in static concurrency checking to determine locks that must be held at specific program points, aiding in race condition detection and synchronization correctness.",
      "description_length": 529,
      "index": 924,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.DomainProperties.Bot",
      "library": "goblint.lib",
      "description": "Implements QCheck property tests for bottom elements in lattice structures. Works with any lattice module D that includes a bottom value. Ensures D.bottom behaves correctly under operations like D.leq and D.eq.",
      "description_length": 210,
      "index": 925,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.BaseDomain.DomFunctor",
      "library": "goblint.lib",
      "description": "This module supports abstract interpretation by enabling lattice operations like `meet`, `join`, `widen`, and `narrow` on domain values combining PrivD and BaseDomain components. It works with abstract domain types that include equality, ordering, and serialization capabilities, alongside functors for parameterizing combination strategies across interdependent domains. Typical use cases include merging analysis results, testing with arbitrary domain values, and defining adaptive domain interactions through customizable operation schemes.",
      "description_length": 543,
      "index": 926,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ExtractPthread.Edges",
      "library": "goblint.lib",
      "description": "Tracks and manipulates control-flow edges between resources in Pthread programs during Promela extraction. It stores edges in a hash table mapping resources to sets of edges, supports adding edges with optional destination nodes and data, and provides functions to retrieve or filter edges based on actions. This module is used to build the control-flow graph for thread synchronization and resource access in Pthread-to-Promela translation.",
      "description_length": 441,
      "index": 927,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Base.MainFunctor",
      "library": "goblint.lib",
      "description": "This module orchestrates abstract interpretation by manipulating analysis contexts, transforming states, and managing memory with support for control flow, variable access, and concurrency. It operates on abstract domains like intervals and pointers, refining values through invariants, evaluating expressions, and handling thread states, with core data types including variable maps, polymorphic variants for values and threads, and lattice-based domains for static analysis. You can evaluate CIL expressions, invalidate memory states, merge analysis contexts using lattice operations, and track variable values across program points using safe, efficient map structures. Submodules enhance this functionality with refinement rules, invariant evaluation, serialization, and structured variable environments for precise, context-sensitive dataflow analysis.",
      "description_length": 857,
      "index": 928,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.WideningTokenLifter.TS",
      "library": "goblint.lib",
      "description": "This module provides lattice and set operations for managing widening token sets, which control delayed widening in abstract interpretation. It works with a token set type (`t`) that stores `Token.t` elements and includes a top element to represent an unbounded state, supporting operations like union, intersection, and subset checks. It is specifically used in static analysis to regulate widening behavior by tracking token additions, ensuring convergence while preserving precision in iterative fixpoint computations.",
      "description_length": 521,
      "index": 929,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Graphml.DeDupGraphMlWriter",
      "library": "goblint.lib",
      "description": "This module writes deduplicated GraphML files by managing node and edge attributes with unique keys. It streams output to a channel, supporting incremental construction of graphs with metadata and custom node/edge attributes. Use it to generate compact visualizations of large program analysis results or dependency graphs where attribute reuse is common.",
      "description_length": 355,
      "index": 930,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Analyses.GVarFC",
      "library": "goblint.lib",
      "description": "This module defines a polymorphic sum type `t` that represents either a value of type `V.t` or a function call context paired with a `CilType.Fundec` and `C.t`. It provides operations to compare, hash, and pretty-print these values, along with utilities to extract identifiers, determine write-only status, and serialize to formats like XML or Yojson. Concrete use cases include tracking variable and function call contexts in static analysis, particularly for constraint-based analyses involving control flow and data dependencies.",
      "description_length": 532,
      "index": 931,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MutexAnalysis.Spec",
      "library": "goblint.lib",
      "description": "This module analyzes mutex usage in concurrent C programs by modeling lock states, lockset manipulations, and thread interactions through control-flow contexts. It operates on key data types including locksets (`D.t`), protected variables (`GProtected.t`), and protecting locks (`GProtecting.t`), enabling detection of race conditions and deadlocks by tracking lock acquisition patterns and variable protection. Submodules provide concrete lockset tracking, lattice-based analysis of mutex states, must-lock constraints, mutable lock maps, and domain-specific lattice operations, supporting tasks like deadlock detection, lock order verification, and synchronization correctness. Example uses include analyzing thread safety by combining lock dependencies, verifying correct lock acquisition across function calls, and modeling possible locking behaviors using abstract interpretation.",
      "description_length": 885,
      "index": 932,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.ThreadEscape.Spec",
      "library": "goblint.lib",
      "description": "This module manages thread escape analysis by integrating context initialization, state transformations, and control flow handling across function calls and concurrency primitives. It operates on thread IDs, CIL expressions, and abstract domains (`D.t`, `G.t`, `ThreadLifted.t`) to track variable reachability and escape events, enabling precise analysis of thread-local variables across inter-procedural and concurrent contexts. The thread set submodule provides lattice operations over thread ID sets, including join, meet, and widening, to merge and compare thread contexts during analysis. The domain submodule defines the abstract lattice type `t` with comparison, display, and hierarchical operations that model variable escape states, supporting static determination of whether values escape thread-local scopes.",
      "description_length": 819,
      "index": 933,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.CommonPriv.MustVars",
      "library": "goblint.lib",
      "description": "This module offers operations for managing variable sets in static analysis, focusing on set-theoretic manipulations (union, intersection, difference), lattice semantics (bot, top, widen, join), and conversions between `MayVars` and `MustVars` representations. It works with `MayVars.t` and `MustVars.t` types\u2014sets tracking variables under thread-modular analysis\u2014to support abstract domain operations like extremal element selection, equality checks, and domain-specific serialization. These capabilities are particularly useful in concurrent program analysis for modeling variable dependencies and lattice-based data flow propagation.",
      "description_length": 636,
      "index": 934,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.MCPRegistry.DomainListMCPASpec",
      "library": "goblint.lib",
      "description": "This module defines a list of domains for the dynamic product analysis, mapping integer keys to analysis modules. It provides functions to retrieve a specific domain by index and to list all domains. It is used to configure and manage multiple analysis components in a dynamic analysis product.",
      "description_length": 294,
      "index": 935,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Analyses.SpecSysSol-SpecSys-Spec-D",
      "library": "goblint.lib",
      "description": "This module implements standard lattice operations and auxiliary utilities for abstract domain elements in static analysis. It operates on values of type `SpecSys.Spec.D.t`, encompassing equality checks, comparison, hashing, serialization, and lattice-theoretic manipulations like `join`, `meet`, `widen`, and `narrow`, alongside top/bottom element detection. These capabilities are critical for building dataflow analyses and abstract interpretation frameworks requiring precise domain modeling and efficient value transformations.",
      "description_length": 532,
      "index": 936,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Analyses.SpecSysVar",
      "library": "goblint.lib",
      "description": "This module defines operations for managing and comparing abstract analysis variables, including equality, hashing, ordering, and pretty-printing. It works with a concrete abstract type `t` representing analysis variables, supporting serialization, arbitrary generation for testing, and context identification via unique tags. It is used to specify and manipulate variables within constraint systems during static analysis.",
      "description_length": 423,
      "index": 937,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Analyses.SpecSys-Spec-P",
      "library": "goblint.lib",
      "description": "This module defines operations for managing global constraint variables, including equality checks, hashing, comparison, and string representation. It works with the abstract type `t` representing path-representative identifiers, supporting serialization through XML and JSON, and integration with QCheck for arbitrary value generation. Concrete use cases include tracking unique identifiers for analysis contexts and enabling precise context-sensitive dataflow analysis in constraint systems.",
      "description_length": 493,
      "index": 938,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.CommonPriv.AtomicParam",
      "library": "goblint.lib",
      "description": "Implements parameter handling for atomic block analysis in thread-modular value analysis. Provides functions to track and manage atomic regions using boolean flags, specifically supporting SV-COMP atomic block semantics. Used in static analysis to control atomicity during constraint solving in BasePriv and RelationPriv modules.",
      "description_length": 329,
      "index": 939,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Analyses.Spec-V",
      "library": "goblint.lib",
      "description": "This module defines operations for managing global constraint variables, including equality, hashing, comparison, and serialization. It works with a concrete type `t` representing constraint variables, supporting pretty-printing, XML and JSON output, and generating arbitrary values for testing. It is used for uniquely identifying and comparing constraint variables in analysis contexts.",
      "description_length": 388,
      "index": 940,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.ThreadReturn.Spec",
      "library": "goblint.lib",
      "description": "This module orchestrates thread return analysis in concurrent programs by managing abstract states and transitions through function calls and returns. It defines core data types like `t` for thread return states, path representatives for context-sensitive tracking, and global constraint variables to model stack frame positions, all equipped with comparison, serialization, and lattice operations for analysis precision. Operations include initializing thread states, propagating dataflow through statements, and merging abstract states using join and widen functions. It enables tracking whether threads are at topmost call frames, detecting return value dependencies, and generating witnesses for race conditions across different call paths.",
      "description_length": 744,
      "index": 941,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Violation.PathArg-Node",
      "library": "goblint.lib",
      "description": "This module defines operations for comparing, hashing, and converting path argument nodes in an abstract reachability graph (ARG). It works with a concrete node type that includes control flow graph node references, context identifiers, and path identifiers. These functions enable precise node equality checks, efficient hash-based data structure integration, and string representation for debugging or logging specific path nodes in the analysis.",
      "description_length": 448,
      "index": 942,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.AutoTune.VariableSet",
      "library": "goblint.lib",
      "description": "This module provides functions for creating and manipulating sets of program variables (`CilType.Varinfo.t`) with standard operations like union, intersection, filtering, and membership checks, along with conversions to and from lists and sequences for flexible traversal. It supports autotuning workflows by managing variable sets to identify optimization candidates, analyze dependencies, or filter variables based on analysis results during configuration adjustments.",
      "description_length": 470,
      "index": 943,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MCPRegistry.DomainListSysVarSpec",
      "library": "goblint.lib",
      "description": "This module manages a registry of analysis domains indexed by integers, allowing domains to be associated with identifiers and retrieved as a list. It provides operations to associate a domain with an integer key and to list all registered domains with their keys. This supports dynamic activation of analyses by enabling lookups based on integer identifiers.",
      "description_length": 359,
      "index": 944,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Server.ArgWrapper-Locator-FileH",
      "library": "goblint.lib",
      "description": "This module provides imperative hash table operations for key-value storage with support for multiple values per key, including insertion, lookup, iteration, and in-place transformations. It works with maps where keys are string-like identifiers and values are polymorphic, offering bulk conversion to and from sequences, lists, and enumerated types. Typical use cases involve managing dynamic collections of keyed data that require efficient aggregation, filtering, or structured serialization, such as configuration management or intermediate data processing pipelines.",
      "description_length": 571,
      "index": 945,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.StackDomain.Dom2",
      "library": "goblint.lib",
      "description": "This module provides a lattice-structured domain for representing sets of variables with stack-like manipulation capabilities, combining standard set operations (union, intersection, membership checks) with abstract interpretation primitives (widen/narrow, partitioning, extremal element retrieval). It operates on variable sets (`Var.t`) stored in a specialized `Dom2.t` structure, supporting both analysis (via iteration and predicate checks) and transformation (through mapping, filtering, and stack-style element insertion). Designed for static analysis scenarios, it enables tracking variable states in call stack domains by maintaining hierarchical relationships and cardinality constraints during abstract interpretation.",
      "description_length": 728,
      "index": 946,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.LockDomain.MustLockRW",
      "library": "goblint.lib",
      "description": "This module represents a lock domain where each lock is paired with a read-write (RW) state, tracking must-lock requirements. It provides operations for comparing, hashing, and pretty-printing these paired values, along with arbitrary value generation for testing. Concrete use cases include static analysis of concurrent programs to enforce correct lock usage with read/write semantics.",
      "description_length": 387,
      "index": 947,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.UnassumeAnalysis.Spec",
      "library": "goblint.lib",
      "description": "This module orchestrates static analysis specifications for tracking and emitting unassumed conditions, combining abstract domain operations with structured event management. It leverages `D.t` for symbolic state tracking, `Locator.t` for precise invariant positioning, and integrates with CIL expressions and contexts to model control flow and synchronization. The first child module manipulates sets of CIL expressions with lattice operations, enabling invariant analysis and unassume event generation from YAML witnesses. The second child module maps analysis events to source locations using ordered maps and sets, supporting event transformation, minimal node selection, and file-specific data maintenance for verification.",
      "description_length": 728,
      "index": 948,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.ResultQuery.SpecSysSol2-SpecSys-LHT-Exceptionless",
      "library": "goblint.lib",
      "description": "This module provides safe lookup and in-place modification operations for hash tables, returning optional values or result types to handle absence or failure explicitly. It works with typed hash tables and their keys, ensuring exception-free access and updates. Concrete use cases include safely querying and updating constraint system solutions without risking unhandled exceptions during analysis.",
      "description_length": 399,
      "index": 949,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.AnalysisResult.ResultType2",
      "library": "goblint.lib",
      "description": "This module represents analysis results combining context, data, and function definitions. It supports equality checks, comparison, hashing, and serialization to JSON, with functions for pretty-printing, XML output, and generating arbitrary test values. It is used to uniquely identify and compare analysis results per function in CIL-based static analysis.",
      "description_length": 357,
      "index": 950,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Preprocessor.FpathH",
      "library": "goblint.lib",
      "description": "This module manages hash tables keyed by file paths, offering standard and advanced operations for insertion, lookup, iteration, transformation, and merging. It supports imperative updates and functional manipulations through typed hash tables, with infix operators for concise key-value access and modification. Concrete uses include tracking file-specific configurations, aggregating analysis results, and merging mappings across multiple sources. Submodules enhance safety with exception-aware operations, extend functionality for path-based keys, and provide intuitive operators for key-value interactions.",
      "description_length": 610,
      "index": 951,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Svcomp.TaskResult-Arg-Edge",
      "library": "goblint.lib",
      "description": "This module handles the conversion and representation of control flow graph edges within SV-COMP task results. It defines the type `t` and provides functions to embed edges into a specific argument type and convert them to string representations. It is used to map and display CFG edges in the context of static analysis result reporting.",
      "description_length": 338,
      "index": 952,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.AccessDomain.Event",
      "library": "goblint.lib",
      "description": "This module represents events related to memory accesses, capturing variable information, offsets, and access kinds. It provides operations for comparing, hashing, and pretty-printing access events, along with serialization to XML and Yojson formats. Concrete use cases include tracking memory access patterns during static analysis and generating human-readable or machine-processable representations of access events for logging or external tools.",
      "description_length": 449,
      "index": 953,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.AbortUnless.Spec",
      "library": "goblint.lib",
      "description": "The module provides control-flow analysis and state transformation operations for handling functions that conditionally abort execution, such as `abortUnless`. It works with abstract analysis contexts (`ctx`), C expressions (`exp`), function definitions (`fundec`), and lvalues (`lval`), while modeling program behavior through abstract states (`D.t`). This enables static analysis of safety-critical C code to determine conditions under which such functions return or terminate, aiding verification of program properties in tools like Goblint.",
      "description_length": 544,
      "index": 954,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.UseAfterFree.Spec",
      "library": "goblint.lib",
      "description": "This module orchestrates the tracking of memory state transformations across program execution points, integrating variable declarations, assignments, control flow, and concurrency handling to detect use-after-free vulnerabilities. It leverages abstract domains (like D.t, G.t) and CIL elements to model interprocedural and thread-aware behaviors, enabling precise static analysis. Child modules refine this capability by defining abstract values, constraint variables, and path-representative identifiers that capture and differentiate memory contexts, supporting operations like equality checks, hashing, and serialization. These components collectively enable tasks such as identifying invalid memory accesses, generating vulnerability witnesses, and performing lattice-based dataflow analysis to track pointer validity and memory lifetimes.",
      "description_length": 844,
      "index": 955,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.SymbLocksDomain.LockingPattern",
      "library": "goblint.lib",
      "description": "This module represents locking patterns using symbolic expressions, tracking lock acquisition and release sequences. It provides operations to compare, serialize, and manipulate these patterns, supporting analysis of concurrency-related behavior. Concrete use cases include detecting deadlocks and ensuring correct lock usage in multithreaded programs.",
      "description_length": 352,
      "index": 956,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MyARG.InterestingArg",
      "library": "goblint.lib",
      "description": "Traverses an abstract reachability graph to identify and process nodes connected via edges, determining which nodes are interesting based on a provided predicate. It uses the `Arg` module for node and edge representations and the `IsInteresting` module to filter nodes during traversal. This supports analysis tasks like detecting relevant program points in static analysis.",
      "description_length": 374,
      "index": 957,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.PrecCompareUtil.S-RH-Exceptionless",
      "library": "goblint.lib",
      "description": "This module provides safe lookup and in-place modification operations for hash tables, returning optional values and result types instead of raising exceptions. It works with hash tables (`Hashtbl`) where keys and values have defined equality and hashing. Concrete use cases include safely retrieving values by key and updating existing entries in a hash table without risking unhandled exceptions.",
      "description_length": 398,
      "index": 958,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Svcomp.TaskResult",
      "library": "goblint.lib",
      "description": "Handles SV-COMP task results, providing access to the final result, invariants, and violation/sink checks for nodes. Works with task arguments, nodes, and invariants. Used to analyze verification outcomes and extract proof artifacts from specific program points.",
      "description_length": 262,
      "index": 959,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Svcomp.StackTaskResult",
      "library": "goblint.lib",
      "description": "This module processes task results for SV-COMP benchmarks by analyzing execution paths and extracting verification outcomes, working with control flow graphs that model program locations as nodes and transitions as edges. It provides operations to retrieve the overall result, check for violations or sink nodes, and compute invariants from node sequences, while supporting traversal, comparison, and display of CFG structures through its submodules. You can use it to analyze program paths, verify properties, and format task-specific control flow data for reporting or further processing. The Edge and Node submodules enhance CFG edges with metadata and offer attribute access, comparison, and string formatting for precise static analysis workflows.",
      "description_length": 752,
      "index": 960,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.RecursionTermLifter.Lifter",
      "library": "goblint.lib",
      "description": "This module coordinates context-sensitive recursion analysis through abstract domains, control flow graphs, and dynamic call graph structures, enabling cycle detection and termination analysis for recursive and concurrent code. It defines core types like `D.t` for abstract values, `G.t`, `C.t`, and `V.t` for context and state tracking, with operations such as `combine_assign` and `threadenter` for state transitions and interprocedural synchronization. Submodules refine these capabilities with path identification, lattice operations for domain elements, and structured representations for call graph nodes and constraint variables, supporting precise tracking and comparison of recursive contexts. Example uses include detecting infinite recursion cycles and ensuring termination by identifying repeated context patterns across dynamic call paths.",
      "description_length": 852,
      "index": 961,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.PrecCompareUtil.S-Dom",
      "library": "goblint.lib",
      "description": "This module provides lattice operations (join, meet, widen, narrow, extremum checks) and serialization utilities for abstract domain elements structured as a lattice. It works with abstract domain types (`Dom.t`) that model data flow analysis properties, enabling precision comparisons and extremal value handling. Use cases include static analysis tasks requiring hierarchical element ordering, such as comparing abstract values during fixpoint computations or verifying domain-specific invariants.",
      "description_length": 499,
      "index": 962,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MCPRegistry.DomListRepresentative",
      "library": "goblint.lib",
      "description": "This module represents a list of domain elements with associated identifiers, providing operations for equality, hashing, comparison, and serialization. It works with lists of tuples containing integers and OCaml objects, supporting concrete use cases like tracking and comparing analysis contexts in dynamic product configurations. Key functions include converting from element lists, generating unique tags, and producing XML or JSON representations of the data.",
      "description_length": 464,
      "index": 963,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.CompareConstraints.CompareGlobal",
      "library": "goblint.lib",
      "description": "This module implements comparison logic for global constraint states using variable mappings, enabling detection of inconsistencies in constraint propagation during analysis. It provides a `compare` function that takes variable names and constraint maps to check and report differences in associated constraints, working with structures like `G.t GH.t` to analyze pre- and post-state discrepancies. Submodule 1 compares `G.t` instances for inclusion or divergence, while Submodule 2 handles variable-like structures with support for identity tracking, pretty-printing, and serialization. Together, they enable precise constraint analysis and readable difference reporting in static analysis workflows.",
      "description_length": 701,
      "index": 964,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Svcomp.TaskResult-Arg",
      "library": "goblint.lib",
      "description": "This module defines the structure and operations for handling task results in SV-COMP benchmarks, specifically working with node and edge data types to represent program control flow. It provides functions to retrieve the main entry point and traverse possible execution paths via nodes and edges. Concrete use cases include analyzing program paths for verification tasks and tracking control flow transitions during static analysis.",
      "description_length": 433,
      "index": 965,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MayLocks.Spec",
      "library": "goblint.lib",
      "description": "This module performs abstract interpretation-based analysis of lock dependencies and concurrency behaviors in C programs, using abstract states to model locksets and thread interactions. It leverages child modules that define lattice structures, equality, comparison, and serialization for may-lock states, enabling detection of double locking, race conditions, and synchronization errors. Operations include join, meet, widen, and pretty-printing, with concrete uses in tracking lock acquisition histories and analyzing thread spawning events. The combined functionality supports static analysis of potential concurrency violations through precise, context-sensitive modeling of lock usage patterns.",
      "description_length": 700,
      "index": 966,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Server.ArgWrapper-Locator-ES-Exceptionless",
      "library": "goblint.lib",
      "description": "This module provides functions to query and retrieve elements from an `Locator.ES.t` set, including finding minimum, maximum, arbitrary, and specific elements. It operates directly on `Locator.ES.t` sets and their elements (`Locator.ES.elt`). Use cases include inspecting or manipulating sets of symbolic execution states during analysis in a server context.",
      "description_length": 358,
      "index": 967,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Taint.VarinfoSet",
      "library": "goblint.lib",
      "description": "This module provides set operations and lattice manipulations for tracking collections of CIL variable information (`CilType.Varinfo.t`), supporting tasks like membership testing, union/intersection, and fixed-point computations in static analysis. It is designed for interprocedural taint analysis, where sets of variables are used to model tainted data flow across program boundaries. Key use cases include tracking potential sources of insecure inputs and propagating taint states through control-flow and data dependencies.",
      "description_length": 527,
      "index": 968,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.StackDomain.Loc",
      "library": "goblint.lib",
      "description": "This module implements stack-based operations for tracking source code locations during static analysis. It provides functions to compare, hash, and serialize location stacks, as well as compute common prefixes and suffixes between them. These operations support precise call stack tracking and are used in analyzing control flow and function inlining in CIL-based programs.",
      "description_length": 374,
      "index": 969,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Server.ArgWrapper-Locator-FileH-Infix",
      "library": "goblint.lib",
      "description": "This module provides functions for mapping and retrieving values associated with file paths using a key-value store interface. It supports operations to bind file paths to keys and associate values with those keys, enabling efficient lookups and updates. Concrete use cases include tracking file-specific metadata or analysis results in a server environment where file paths are frequently accessed and modified.",
      "description_length": 412,
      "index": 970,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.BaseDomain.DomWithTrivialExpEval",
      "library": "goblint.lib",
      "description": "This module provides lattice operations (join, meet, widen, narrow) and structural utilities (comparison, serialization, pretty-printing) for abstract domain elements representing analysis states. It operates on a lattice-structured type that supports merging and comparing values through customizable combination strategies applied to domain components like control flow or dependency tracking. The functionality is used in static analysis frameworks to manage abstract state transitions and evaluate program properties through compositional operations.",
      "description_length": 554,
      "index": 971,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Queries.Any",
      "library": "goblint.lib",
      "description": "This module defines operations for comparing, ordering, and hashing abstract queries, along with pretty-printing functionality. It works directly with the `any_query` type, which represents a polymorphic query in Goblint's analysis framework. Concrete use cases include managing query identities in caches, enforcing query precedence during analysis, and generating readable representations of queries for debugging or output.",
      "description_length": 426,
      "index": 972,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MCPRegistry.ContextListSpec",
      "library": "goblint.lib",
      "description": "Implements a list-based context management system for dynamically activatable analyses. Associates integer keys with printable domain modules and provides operations to register, retrieve, and iterate over these domain associations. Used to maintain and query a collection of analysis domains indexed by integer identifiers during static analysis.",
      "description_length": 347,
      "index": 973,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Analyses.SpecSys-Spec-V",
      "library": "goblint.lib",
      "description": "This module defines operations for managing global constraint variables, including equality checks, hashing, comparison, and string representation. It works with the abstract type `t` representing constraint variables, supporting serialization, pretty-printing, and generation of arbitrary values for testing. Concrete use cases include tracking and comparing constraint variables in analysis phases, emitting XML or JSON representations for external tools, and ensuring unique identification via tags for witness generation.",
      "description_length": 525,
      "index": 974,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ArgTools.BiArg-Node",
      "library": "goblint.lib",
      "description": "Implements equality, hashing, and comparison operations for a node type that combines CFG nodes with context and path identifiers. It supports efficient key-based comparisons and string representation for use in maps and sets. Useful for tracking unique nodes in abstract interpretation contexts with multiple execution paths.",
      "description_length": 326,
      "index": 975,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Deadlock.Spec",
      "library": "goblint.lib",
      "description": "This module analyzes concurrency in C programs by modeling thread states and lock dependencies using abstract domains and analysis contexts. It tracks lock events, memory accesses, and control flow to detect deadlocks through operations like `add`, `remove`, and `part_access`, working with types such as `G.t` and `ValueDomain.Addr.t`. Submodules handle lock event pairs, lattice-based set operations, and singleton types to represent and manipulate deadlock states. These components enable path-sensitive analysis, structured reporting, and abstract interpretation of lock acquisition patterns across concurrent execution paths.",
      "description_length": 630,
      "index": 976,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Analyses.SpecSys-GHT-Labels",
      "library": "goblint.lib",
      "description": "This module provides labeled argument versions of standard Hashtbl operations, enhancing readability and safety when working with hash tables. It supports common operations like adding, replacing, iterating, mapping, filtering, and folding over key-value pairs, with functions that accept labeled arguments for improved clarity. Concrete use cases include managing mappings between keys and arbitrary data values where argument labels help prevent mistakes and allow flexible argument ordering.",
      "description_length": 494,
      "index": 977,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.WrapperFunctionAnalysis.SpecBase",
      "library": "goblint.lib",
      "description": "This module enables interprocedural static analysis by modeling symbolic heap locations and thread identifiers through lattice-based structures, supporting precise tracking across function calls and dynamic memory or thread creation events. It combines direct operations on abstract analysis contexts with submodules that provide `NodeFlatLattice` for hierarchical state representation, `UniqueCallCounter` for instance tracking, and combined lattice operations for merging, comparing, and serializing analysis states. The core domain type `C.t` supports fixed-point computations over wrapper functions like `mallocWrapper` and `threadCreateWrapper`, while map-based counter structures enable node-specific state management with customizable combination logic. Together, these components facilitate context-sensitive analysis and formal verification of program properties in scenarios involving dynamic allocation and concurrency.",
      "description_length": 930,
      "index": 978,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.WitnessUtil.Invariant",
      "library": "goblint.lib",
      "description": "This module manages the detection and emission of invariant nodes in a control flow graph, specifically identifying loop heads, nodes after lock operations, and other relevant control points. It works with control flow graph nodes and locations to track and verify invariants at specific syntactic points in the code. Concrete use cases include determining whether a node is part of a loop, follows a lock operation, or qualifies as an invariant node during witness generation.",
      "description_length": 477,
      "index": 979,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MCPRegistry.LocalDomainListSpec",
      "library": "goblint.lib",
      "description": "Implements a list-based specification for managing multiple abstract domains in a dynamic product analysis. Associates domain identifiers with lattice modules and provides access to the full list of registered domains. Used to define and retrieve domain configurations for compositional analysis passes.",
      "description_length": 303,
      "index": 980,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Analyses.Spec2Spec-V",
      "library": "goblint.lib",
      "description": "This module defines operations for managing global constraint variables, including equality checks, hashing, comparison, and string representation. It works with the abstract type `t` representing constraint variables, providing functions for pretty-printing, XML serialization, and JSON conversion. Concrete use cases include tracking and comparing constraint variables during analysis, supporting witness generation through unique tagging, and enabling arbitrary value generation for testing.",
      "description_length": 494,
      "index": 981,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.BaseInvariant.Eval-D",
      "library": "goblint.lib",
      "description": "This module provides lattice operations for comparing, combining, and transforming abstract values of type `D.t`, including join, meet, widen, narrow, and extremal value checks. It works with abstract domains structured as lattices, where values represent over-approximated program states or properties. These operations enable static analysis tasks like fixpoint stabilization, difference tracking, and convergence control in abstract interpretation frameworks.",
      "description_length": 462,
      "index": 982,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Analyses.SpecSysSol-SpecSys-LHT-Infix",
      "library": "goblint.lib",
      "description": "This module extends a hash table with infix operators for key-value lookups and additions. It provides `-->` to retrieve the current value of a key or raise `Not_found`, and `<--` to bind a key to a value, preserving previous bindings until explicitly removed. These operations are used to manage temporary or layered state in analysis contexts, such as tracking variable bindings during abstract interpretation.",
      "description_length": 412,
      "index": 983,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.SarifType.Run",
      "library": "goblint.lib",
      "description": "This module defines the structure and serialization for a SARIF run object, including tool metadata, source language, invocations, artifacts, and analysis results. It provides functions to convert the run data to JSON format using Yojson. Use this module to generate SARIF-compliant output for static analysis tools.",
      "description_length": 316,
      "index": 984,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.DomainProperties.S",
      "library": "goblint.lib",
      "description": "Implements QCheck property tests for lattice structures, ensuring correctness of operations like `leq`, `join`, and `meet`. Works with abstract lattice types defined in the library, validating their adherence to lattice laws. Useful for testing custom lattice implementations used in static analysis domains.",
      "description_length": 308,
      "index": 985,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.SymbLocksDomain.Exp",
      "library": "goblint.lib",
      "description": "This module provides utilities for structural analysis, simplification, and serialization of symbolic expressions, focusing on operations like equality checks, variable containment, offset folding, and rewriting. It works directly with CIL expressions (`GoblintCil.exp`) and offsets to model array accesses and symbolic lockset constraints. Specific applications include symbolic lockset tracking in static analysis and determining constant vs. dynamic indices in array expressions for program verification.",
      "description_length": 507,
      "index": 986,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.SarifType.Message",
      "library": "goblint.lib",
      "description": "Handles message representation in SARIF format with conversion to Yojson. Works with strings and SARIF message records. Used for serializing analysis messages into JSON for output.",
      "description_length": 180,
      "index": 987,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ResultQuery.SpecSysSol2-SpecSys-LHT-Labels",
      "library": "goblint.lib",
      "description": "This module provides labeled versions of standard hash table operations, enhancing readability and argument order flexibility. It works with labeled hash tables (`SpecSys.LHT.t`) and keys (`SpecSys.LHT.key`), supporting actions like adding, modifying, filtering, and merging entries using key-aware functions. Concrete use cases include safely updating values associated with specific keys, filtering entries based on key-value pairs, and merging two hash tables with custom conflict resolution logic.",
      "description_length": 501,
      "index": 988,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MyARG.SIntra",
      "library": "goblint.lib",
      "description": "Implements intra-procedural abstract reachability graph construction and traversal. It provides operations to compute successor edges and nodes in a control flow graph, working with nodes and edges defined in `MyCFG`. Used for static analysis tasks like identifying reachable program points within a function.",
      "description_length": 309,
      "index": 989,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Analyses.Spec2Spec-P",
      "library": "goblint.lib",
      "description": "This module defines operations for managing global constraint variables, including equality checks, hashing, comparison, and string representation. It works with the abstract type `t` and supports serialization via XML and Yojson, along with generating arbitrary values for testing. Concrete use cases include tracking and identifying constraint variables uniquely within analysis contexts and facilitating their comparison and persistence.",
      "description_length": 440,
      "index": 990,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.YamlWitnessType.PreconditionLoopInvariantCertificate",
      "library": "goblint.lib",
      "description": "This module defines and processes certificate data for loop invariants combined with preconditions in the YAML witness format. It supports parsing from YAML values, comparing certificates, and identifying the entry type. It is used to validate and handle verification conditions for loop invariants that depend on preconditions in static analysis workflows.",
      "description_length": 357,
      "index": 991,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.MusteqDomain.VF",
      "library": "goblint.lib",
      "description": "This module provides operations for managing symbolic lvalue identifiers with offset tracking, enabling precise manipulation of field and index tags in value-flow analysis. It works with tuples combining values and flow-sensitive information, alongside CIL expressions and lvalues, to support structural checks like collapsibility or definiteness. Key use cases include analyzing memory accesses in data structures, optimizing variable substitutions, and propagating equality constraints across program points with field- or index-specific precision.",
      "description_length": 550,
      "index": 992,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ResultQuery.SpecSysSol2-FileCfg",
      "library": "goblint.lib",
      "description": "Implements operations to query and analyze constraint system solutions over CIL files using a control flow graph (CFG). It provides functions to traverse and extract solution data specific to file-level CFG structures, such as retrieving constraints at specific program points or analyzing dataflow across CFG edges. Useful for performing precise interprocedural analysis and extracting verification results tied to the program's control flow structure.",
      "description_length": 453,
      "index": 993,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MCPRegistry.DomListPrintable",
      "library": "goblint.lib",
      "description": "This module implements operations for a list of tagged abstract values, providing equality, hashing, comparison, and serialization to string, XML, and JSON. It supports pretty-printing for structured output and includes a unique identifier for context tracking in analysis. Used to represent and manipulate dynamic analysis contexts with concrete tags and values.",
      "description_length": 363,
      "index": 994,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Queries.Result",
      "library": "goblint.lib",
      "description": "This module handles query results within a lattice structure, providing operations to retrieve bottom and top elements for a given query type. It works with generic query result types `'a` constrained by lattice semantics. Concrete use cases include initializing or comparing results in static analysis where extremal values are required.",
      "description_length": 338,
      "index": 995,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Analyses.SpecSys-Spec-D",
      "library": "goblint.lib",
      "description": "This module provides lattice-theoretic operations for an abstract domain type, including equality checks, comparison, join/meet operations, widening/narrowing, and top/bottom element handling. It supports static analysis frameworks by modeling program states or properties within a dataflow lattice, enabling tasks like abstract interpretation and dataflow analysis. The domain's serialization, pretty-printing, and arbitrary value generation also aid in testing and debugging analysis implementations.",
      "description_length": 502,
      "index": 996,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.UseAfterFree.ThreadIdToJoinedThreadsMap",
      "library": "goblint.lib",
      "description": "This module provides a map structure that associates thread identifiers with sets of threads requiring synchronization, supporting operations like union, intersection, and lattice-based combination (meet/join) for dataflow analysis. It works with specialized thread ID and thread set types from the analysis framework, enabling precise tracking of join dependencies between threads. These capabilities are critical for modeling thread interactions in use-after-free vulnerability detection, where ensuring proper synchronization is necessary to validate memory safety.",
      "description_length": 568,
      "index": 997,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.CommonPriv.Digest",
      "library": "goblint.lib",
      "description": "Implements hash-consed context identifiers with unique tags for thread-modular analysis. Provides equality, comparison, and serialization to XML and Yojson for context-sensitive dataflow analysis. Used to track and compare analysis contexts during witness generation and relational reasoning.",
      "description_length": 292,
      "index": 998,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MCPRegistry.DomainListRepresentativeSpec",
      "library": "goblint.lib",
      "description": "Implements operations to register and retrieve disjoint domains by integer keys. Provides `assoc_dom` to associate a domain with an integer and `domain_list` to list all registered domains. Useful for managing multiple abstract domains in static analysis where each domain is identified by a unique integer key.",
      "description_length": 311,
      "index": 999,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.RegionDomain.Reg",
      "library": "goblint.lib",
      "description": "This module supports lattice operations, variable transformations, and identification of global variables related to memory regions through its core abstractions. It operates on region data structures paired with `RegPart` and `RegMap` types, alongside evaluation contexts that track heap relationships and escaping variables. These capabilities enable static analysis of heap memory usage, such as determining which global variables alias specific regions or tracking ownership in region-based memory models.",
      "description_length": 509,
      "index": 1000,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Server.ArgWrapper-Locator-ES",
      "library": "goblint.lib",
      "description": "This module provides set-theoretic and ordered collection operations for managing `Arg.Node.t` elements, primarily through the `Locator.ES.t` ordered set structure. It supports standard set manipulations (union, intersection, difference), order-based queries (min/max extraction, range filtering), and sequence conversions, enabling efficient analysis of argument dependencies in interactive server contexts. These capabilities are particularly useful for tracking and resolving argument relationships during static analysis or handling dynamic client requests requiring structured data transformations.",
      "description_length": 603,
      "index": 1001,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Region.Spec",
      "library": "goblint.lib",
      "description": "This module performs region-based static analysis of heap-allocated memory, tracking disjoint regions and value flows through control-flow constructs, variable declarations, and concurrency primitives. It manipulates abstract domains like `RegMap.t` and `MapDomain.MapBot` to model memory regions and analysis contexts, enabling race detection and must-equality analysis across CIL code. Submodules handle optional regions, unit-type specifications, lattice operations, and set-theoretic manipulations of memory expressions, supporting operations like `may_race`, `pretty`, and lattice joins to compare, serialize, and transform abstract memory states. Specific uses include synchronizing region states across function calls, enforcing region-sensitive constraints, and detecting data races in concurrent programs.",
      "description_length": 814,
      "index": 1002,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ResultQuery.SpecSysSol2-SpecSys-Spec",
      "library": "goblint.lib",
      "description": "This module provides transfer functions and context manipulation routines for static analysis, handling variable declarations, assignments, branching, function entry semantics, and thread operations. It operates on abstract domains (D, G, C, V) and analysis contexts (ctx) to model program behavior, specifically targeting CIL expressions, function calls, and concurrency primitives like thread spawning. Its design enables tracking program state through control-flow and data-flow analyses, particularly for interprocedural and concurrent code in C-like languages.",
      "description_length": 565,
      "index": 1003,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Svcomp.Task",
      "library": "goblint.lib",
      "description": "Processes SV-COMP task files, parsing specifications and constructing control flow graphs for analysis. Works with CIL files and structured specifications to extract verification targets and properties. Used to load and prepare task data for static analysis tools within the Goblint framework.",
      "description_length": 293,
      "index": 1004,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.SarifType.Invocation",
      "library": "goblint.lib",
      "description": "Handles serialization of SARIF invocation data to JSON format. Works with the `t` record type containing `commandLine` and `executionSuccessful` fields. Used to convert tool execution results into SARIF-compatible JSON output for analysis reporting.",
      "description_length": 249,
      "index": 1005,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.LoopfreeCallstring.Spec",
      "library": "goblint.lib",
      "description": "This module performs loop-free call string analysis by collapsing cycles into sets, optimizing recursive context representation for scalable abstract interpretation of C programs. It manipulates abstract domains derived from CIL constructs through transfer functions for control-flow events like function calls and returns, while preserving call order and eliminating redundancy. The child modules define compact call string representations, providing lattice operations, equality checks, hashing, and serialization to support context-sensitive analysis without infinite expansion. Examples include tracking unique calling contexts, summarizing recursive call chains, and enabling efficient static analysis of programs with repetitive or cyclic call patterns.",
      "description_length": 759,
      "index": 1006,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.BaseInvariant.Make",
      "library": "goblint.lib",
      "description": "This module implements refinement and invariant application logic for value domains in static analysis. It provides operations to refine values based on expressions or lvalues, apply invariants, and handle fallback cases during analysis. It works with value domains (VD.t), evaluation domains (Eval.D.t), and CIL expressions and lvalues, targeting use cases such as narrowing variable ranges or enforcing value constraints during abstract interpretation.",
      "description_length": 454,
      "index": 1007,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ResultQuery.SpecSysSol2-SpecSys-Spec-V",
      "library": "goblint.lib",
      "description": "This module defines operations for handling globally unique constraint variables, including equality checks, hashing, comparison, and string representation. It works with the abstract type `t` representing constraint variables, leveraging HConsed identifiers for uniqueness and context tracking. Concrete use cases include managing variable identities in constraint systems, supporting pretty-printing for diagnostics, and enabling efficient comparisons in solver implementations.",
      "description_length": 480,
      "index": 1008,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Server.ArgWrapper-Locator-FileH-Labels",
      "library": "goblint.lib",
      "description": "This module provides operations for manipulating file-based data structures with key-value associations, including adding, replacing, filtering, mapping, and folding over entries. It supports in-place modifications and conditional transformations, enabling precise updates and queries on file-backed data. Concrete use cases include managing per-file state in an interactive server, synchronizing file metadata, and processing file-specific analysis results.",
      "description_length": 458,
      "index": 1009,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Analyses.SpecSysSol-SpecSys-GHT-Infix",
      "library": "goblint.lib",
      "description": "This module defines infix operators for interacting with a BatHashtbl-based global heap table (GHT). It provides `-->` for safely retrieving values by key and `<--` for adding or updating bindings while preserving previous values. These operations are used to manage temporary state changes in analysis contexts where shadowing and restoring bindings is required.",
      "description_length": 363,
      "index": 1010,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MCPRegistry.PrintableOfLatticeSpec",
      "library": "goblint.lib",
      "description": "Implements analysis domain associations for lattice specifications using a printable interface. Maps integer keys to modules implementing the `Printable.S` interface and provides lookup operations. Useful for dynamically retrieving and listing analysis domains in a product configuration.",
      "description_length": 288,
      "index": 1011,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ResultQuery.SpecSysSol2-SpecSys-Spec-C",
      "library": "goblint.lib",
      "description": "This module defines operations for comparing, hashing, and serializing context identifiers from the constraint system solution. It works with the `SpecSys.Spec.C.t` type, which represents abstract contexts in the analysis. Concrete use cases include identifying unique contexts during witness generation, pretty-printing contexts for debugging, and converting contexts to JSON for external tools.",
      "description_length": 396,
      "index": 1012,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Graphml.GraphMlWriter",
      "library": "goblint.lib",
      "description": "Handles streaming GraphML output with operations to define graph structure and metadata. Works with nodes and edges, attaching key-value properties to elements. Used to serialize control flow or data flow graphs with attributes like labels or types to GraphML files.",
      "description_length": 266,
      "index": 1013,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Analyses.MCPSpec-V",
      "library": "goblint.lib",
      "description": "This module defines operations for managing global constraint variables, including equality checks, hashing, comparison, and string representation. It works with a concrete type `t` representing constraint variables, primarily used for tracking and identifying variables in constraint systems. Key use cases include variable comparison and serialization for analysis contexts, such as generating unique IDs for witness generation or XML/YoJSON output.",
      "description_length": 451,
      "index": 1014,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.IntDomainProperties.IntegerSet",
      "library": "goblint.lib",
      "description": "This module implements a numerical abstract domain for integer sets with lattice operations like join, meet, widen, and narrow, alongside arithmetic and bitwise manipulations. It supports abstract values represented via `Base.t`, congruence relations, and CIL type-aware integers, with utilities for overflow handling, invariant generation, and test-case synthesis. Functional transformations and element-wise arithmetic enable precise value analysis and extremal value checking in static analysis workflows. Specific operations include union, intersection, difference, membership checks, bitwise AND/OR, shifts, and value serialization.",
      "description_length": 637,
      "index": 1015,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Access.MemoRoot",
      "library": "goblint.lib",
      "description": "This module represents memory access roots with two possible tags: variables or type signatures. It provides comparison, hashing, and pretty-printing operations for these roots. Concrete use cases include tracking memory locations in static analysis and generating human-readable or machine-processable representations of access paths.",
      "description_length": 335,
      "index": 1016,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.VectorMatrix.RatOps",
      "library": "goblint.lib",
      "description": "This module defines arithmetic operations and comparisons for rational numbers, including addition, subtraction, multiplication, division, and absolute value. It works with the abstract type `t` representing rationals, along with conversions to and from integers and strings. Concrete use cases include precise rational number computations in numerical analysis and symbolic manipulation where exact fractions are required.",
      "description_length": 423,
      "index": 1017,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.YamlWitnessType.LoopInvariantCertificate",
      "library": "goblint.lib",
      "description": "This module defines and manipulates loop invariant certificates in the YAML witness format. It provides functions to parse certificates from YAML values and compare them, working with structured data that includes a target and certification component. It is used to represent and validate loop invariants in static analysis results.",
      "description_length": 332,
      "index": 1018,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Analyses.SpecSys-Spec-C",
      "library": "goblint.lib",
      "description": "This module defines operations for managing and manipulating analysis contexts, including equality checks, hashing, comparison, and serialization. It works with the abstract type `Spec.C.t`, which represents analysis contexts, and provides functions for pretty-printing, XML output, JSON conversion, and generating arbitrary values for testing. It is used to handle context identification, comparison, and data exchange in static analysis workflows.",
      "description_length": 449,
      "index": 1019,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.UnassumeAnalysis.EH",
      "library": "goblint.lib",
      "description": "This module provides imperative hash table operations for mapping Cil expressions to arbitrary values, supporting in-place updates, iteration, and transformation, alongside sequence-based bulk initialization and modification of key-value pairs where keys conform to `Goblint_lib.UnassumeAnalysis.EH.key`. It facilitates dynamic tracking and manipulation of analysis-specific data during unassume event processing, particularly for handling transient invariants or constraints derived from YAML witness files in static analysis workflows.",
      "description_length": 537,
      "index": 1020,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Analyses.SpecSysSol-SpecSys-Spec-G",
      "library": "goblint.lib",
      "description": "This module supports lattice-theoretic operations for abstract interpretation, including equality checks, partial order comparisons, and fixpoint approximation via widening/narrowing. It works with the `SpecSys.Spec.G.t` type, which models abstract states or constraints in a solver system as elements of a lattice. These operations are specifically designed for static analysis tasks requiring hierarchical state merging and convergence detection in program verification.",
      "description_length": 472,
      "index": 1021,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.PthreadDomain.Pred",
      "library": "goblint.lib",
      "description": "This module provides a lattice-structured domain for managing sets of predecessor nodes in control flow graphs, supporting standard set operations (union, intersection, insertion), lattice combinators (join, meet, widen), and element-level queries (min, max, partitioning). It operates on immutable collections of node identifiers, enabling efficient representation of predecessor relationships during dataflow analysis. These abstractions are used to model control flow dependencies in concurrent programs, such as merging analysis states from multiple predecessors or tracking reachable nodes across Pthread synchronization points.",
      "description_length": 633,
      "index": 1022,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.SpecLifters.LimitLifter",
      "library": "goblint.lib",
      "description": "This module coordinates static analysis frameworks by restricting widening iterations at individual program nodes, combining abstract domains, environment tracking, and convergence control to ensure termination and precision. It defines core types like path representatives, constraint variables, and context-aware lattices, with operations for transfer functions across assignments, branches, and function calls, while managing fixed-point computations through bounded widenings. Concrete capabilities include tracking analysis state convergence, generating analysis witnesses, and serializing constraint data for debugging or testing, all while enforcing unique context identification and controlled abstraction refinement. Submodules extend this by providing structured lattice manipulations, context relifting, and constraint propagation mechanisms tailored for context-sensitive static analysis.",
      "description_length": 900,
      "index": 1023,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.AnalysisResult.ResultConf",
      "library": "goblint.lib",
      "description": "This module defines configurations for analysis result outputs, including settings that control formatting and serialization. It works with analysis results structured as nested maps and lists, enabling customization of output fields and structure. Concrete use cases include configuring JSON or text-based reporting formats for specific analysis needs.",
      "description_length": 353,
      "index": 1024,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.DeadlockDomain.LockEvent",
      "library": "goblint.lib",
      "description": "This module represents events related to lock operations in a deadlock analysis, combining locks, control flow nodes, and memory access information. It provides comparison, hashing, and serialization functions for these events, enabling their use in sets, maps, and persistent data structures. Concrete use cases include tracking lock acquisition and release points during static analysis to detect potential deadlocks.",
      "description_length": 419,
      "index": 1025,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.CondVars.Domain",
      "library": "goblint.lib",
      "description": "This module implements a map-based abstraction for associating symbolic expressions with domain-specific values, supporting operations like addition, filtering, and lattice-based combination (meet, join) of mappings. It works with ordered symbolic expressions (`Mval.Exp.t`) as keys and abstract values (`V.t`) to model conditional variable relationships and taint information. The structure is used in static analysis to track variable equalities, propagate constraints, and filter variables based on program expressions or global state.",
      "description_length": 538,
      "index": 1026,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ThreadId.VNI",
      "library": "goblint.lib",
      "description": "This module implements operations for comparing, hashing, and displaying thread identifiers that combine variable information, control flow nodes, and optional thread creation counts. It supports concrete use cases such as tracking unique thread instances during static analysis and distinguishing between thread creation sites. Functions include equality checks, string conversion, pretty printing, and serialization for analysis and debugging purposes.",
      "description_length": 454,
      "index": 1027,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Signs.Spec",
      "library": "goblint.lib",
      "description": "This module orchestrates intraprocedural integer sign analysis by integrating constraint variables and lattice-based abstract domains. It defines core data types such as constraint variables for tracking contexts and an abstract type `t` for representing sign states (positive, negative, zero, unknown), with operations including join/meet for value combination, widen/narrow for convergence, and serialization for output. The module enables precise analysis of integer behavior in C code, supporting tasks like detecting invalid arithmetic, refining domains through relifting, and distinguishing control-flow paths via unique tags. Specific utilities include pretty-printing, comparison, and JSON/XML export for debugging and integration with analysis frameworks.",
      "description_length": 764,
      "index": 1028,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.MCPRegistry.DomVariantLattice0",
      "library": "goblint.lib",
      "description": "This module supports lattice operations such as comparison, combination, and approximation of tagged abstract domain values, where each value pairs a unique integer tag with an object to track identity during analysis. It works with a tuple-based type representing lattice elements, enabling dynamic analysis configurations through operations like `join`, `widen`, and `narrow`, alongside serialization and property-based testing capabilities. Typical use cases include managing abstract interpretation states in configurable static analyses and generating test cases for lattice behaviors.",
      "description_length": 590,
      "index": 1029,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.DomainProperties.Join",
      "library": "goblint.lib",
      "description": "This module defines QCheck tests for join operations on a lattice domain, ensuring properties like associativity, commutativity, idempotence, and absorption. It works with elements of type D.t, where D represents a lattice structure, and includes custom test generation and comparison functions. Concrete use cases include verifying correctness of join implementations in abstract domains used for static analysis.",
      "description_length": 414,
      "index": 1030,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ArgTools.Dot",
      "library": "goblint.lib",
      "description": "This module generates DOT representations of argument graphs using custom node and edge formatting. It provides functions to print individual nodes, edges, and complete graphs in DOT syntax, leveraging the `Arg` module for graph structure and `NodeStyles` for visual styling. Concrete use cases include visualizing abstract reachability graphs (ARGs) with customized node labels and edge styles for debugging or analysis tools.",
      "description_length": 427,
      "index": 1031,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.MCPRegistry.AccListSpec",
      "library": "goblint.lib",
      "description": "Implements a list-based accumulator for analysis domains in a product configuration. Associates integer keys with analysis modules and provides ordered retrieval of these associations. Useful for managing and iterating over dynamically activated analysis components in a specific sequence.",
      "description_length": 289,
      "index": 1032,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.SpecLifters.WidenContextLifterSide",
      "library": "goblint.lib",
      "description": "This module orchestrates context-sensitive static analysis by transforming and synchronizing abstract states across control-flow paths, pairing domains with auxiliary data to track value assignments, side effects, and function call boundaries. It leverages context identifiers with structural equality for precise state comparison, combines domains into product lattices for complex state modeling, and uses map-based abstractions to analyze variable bindings and value ranges. Operations include widening, narrowing, join/meet for fixpoint stabilization, along with XML/Yojson serialization for analysis persistence and difference reporting. Examples include tracking variable states through conditionals, merging environments at loop exits, and lifting function entry/return contexts with precise side-effect handling.",
      "description_length": 820,
      "index": 1033,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.DomainProperties.Equal",
      "library": "goblint.lib",
      "description": "Implements QCheck property tests for equality in lattice structures. Works with any module D that defines a lattice domain. Ensures D's equality operations adhere to lattice property requirements through concrete test cases.",
      "description_length": 224,
      "index": 1034,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.PrecCompareUtil.R-RH",
      "library": "goblint.lib",
      "description": "The module type provides imperative and functional operations for managing a hash map structure with typed keys and polymorphic values, supporting modifications like insertion, deletion, and merging, as well as transformations through mapping and filtering. It facilitates conversions between hash maps and sequences, lists, or enumerations, alongside exception-safe variants and infix operators for streamlined composition. This is useful in scenarios requiring precise key-value tracking, such as static analysis precision comparisons, data aggregation pipelines, or state management with dynamic value types.",
      "description_length": 611,
      "index": 1035,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MCPRegistry.DomainListPrintableSpec",
      "library": "goblint.lib",
      "description": "This module specifies analysis domains for the dynamic product registry, providing functions to retrieve a domain by index and list all registered domains with their indices. It works with integers as domain identifiers and modules implementing the `Printable.S` signature. Concrete use cases include dynamically selecting and printing analysis domains during program analysis configuration.",
      "description_length": 391,
      "index": 1036,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Violation.Feasibility",
      "library": "goblint.lib",
      "description": "This module determines the feasibility of paths in an abstract reachability graph (ARG) by analyzing sequences of nodes and edges. It works with node and edge structures defined in the `Node` submodule and the `MyARG` module. A concrete use case is verifying whether a specific path through program analysis states is actually possible, returning whether it's feasible, infeasible with a counterexample, or unknown.",
      "description_length": 415,
      "index": 1037,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.YamlWitnessType.Target",
      "library": "goblint.lib",
      "description": "This module defines operations for comparing, serializing, and deserializing target metadata in a YAML-based witness format. It works with a record type containing UUID, type identifier, and file hash fields. It is used to uniquely identify and validate analysis targets in witness documents.",
      "description_length": 292,
      "index": 1038,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Server.Locator",
      "library": "goblint.lib",
      "description": "This module coordinates source code location tracking and analysis node association through file contexts and environment state, enabling precise lookups during interactive analysis. It leverages a file-specialized hash table for metadata storage, an ordered identifier set for managing symbolic references with set operations, and a persistent location map for functional and monadic manipulation of location-annotated data. You can register source locations to nodes, query environment state by position, transform file-specific data with typed accessors, or aggregate analysis results across multiple locations. The combination supports structured server state handling, error tracking, and interactive code analysis with robust, non-raising operations over JSON-RPC.",
      "description_length": 770,
      "index": 1039,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.PrecCompareUtil.R-Dom",
      "library": "goblint.lib",
      "description": "This module provides lattice operations and precision comparison utilities for abstract domain elements, including equality checks, extremum detection (top/bot), and structural comparison. It works with `Dom.t` values representing abstract elements in a static analysis lattice, supporting functions like `join`, `meet`, `widen`, and `narrow` for domain-specific precision tuning. Typical use cases involve analyzing program abstractions, such as comparing abstract values during fixpoint computations or generating human-readable diffs for lattice elements in static analysis frameworks.",
      "description_length": 588,
      "index": 1040,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Access.TSH",
      "library": "goblint.lib",
      "description": "This module provides thread-safe imperative hash table operations for storing and manipulating key-value pairs where keys are CilType.Typsig.t. It supports concurrent access through atomic bulk modifications via sequences, enabling safe batch updates, and offers traversal capabilities through iteration, folding, and sequence conversion. The structure is optimized for scenarios requiring coordinated shared-state management across multiple threads, such as parallel analysis tasks handling type-signature-based mappings.",
      "description_length": 522,
      "index": 1041,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.VarEq.Spec",
      "library": "goblint.lib",
      "description": "This module analyzes symbolic expressions through variable equality checks, context propagation, and state transformations using abstract domains like `D.t` and `ES.t`. It supports static analysis tasks such as points-to analysis by tracking symbolic relationships across program paths, handling control flow effects, and preserving variable equalities during state transitions. The first child module defines lattice operations over a structured type `t`, offering `join`, `meet`, `widen`, and `narrow` to manipulate abstract values and perform extremal checks with `top` and `is_top`. The second child module extends this with polymorphic set abstractions that support union, intersection, subset checks, and lattice combinators for refining equivalence relations during abstract interpretation.",
      "description_length": 797,
      "index": 1042,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.MCPRegistry.DomListLattice",
      "library": "goblint.lib",
      "description": "This module supports lattice operations (join, meet, widen, narrow) and extremum checks (is_bot, is_top) for a data structure combining integer-tagged abstract domain elements in a list. It enables context-sensitive abstract interpretation by managing complex value comparisons, with utilities for serialization, difference tracking, and structured output formats like XML/Yojson. The design accommodates dynamic analysis workflows where hierarchical domain combinations require precise lattice-theoretic manipulation.",
      "description_length": 518,
      "index": 1043,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "Goblint_lib.VectorMatrix.ArrayMatrix",
      "library": "goblint.lib",
      "description": "This module implements array-based matrix operations including row/column manipulation, normalization into reduced row echelon form (RREF), and structural transformations like appending or mapping with index awareness. It operates on matrices composed of elements from a base module A and row vectors from a vector module V, leveraging RREF structure to optimize operations such as column reduction and zero-row elimination. The functionality is particularly suited for applications requiring efficient row reduction, such as solving linear systems or analyzing matrix properties under RREF constraints.",
      "description_length": 603,
      "index": 1044,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.ModifiedSinceSetjmp.Spec",
      "library": "goblint.lib",
      "description": "This module provides operations for tracking variables modified since setjmp in C programs, focusing on control-flow-sensitive analysis through context management, branching, and thread state manipulation. It operates on CIL structures like expressions and function definitions, alongside abstract domains (`D.t`) for state representation, enabling precise handling of function calls, returns, and inter-thread data flow. Specific use cases include static analysis of C code with non-local jumps (via `setjmp`/`longjmp`), where accurate tracking of variable modifications across divergent execution paths and concurrent contexts is critical for correctness.",
      "description_length": 657,
      "index": 1045,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.BaseDomain.WeakUpdates",
      "library": "goblint.lib",
      "description": "This module offers lattice-based set operations for tracking variables requiring weak updates, combining standard domain operations like join, meet, and widening with functional set manipulations (union, subset, filter) over `Basetype.Variables.t`. It supports analysis scenarios where variables have multiple reachable copies by enabling precise propagation of weak update effects through static analysis frameworks, with utilities for serialization and integration with analysis tools. Key use cases include managing variable sets during abstract interpretation to handle cases where assignments must invalidate related copies rather than overwriting directly.",
      "description_length": 662,
      "index": 1046,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Analyses.VarinfoV",
      "library": "goblint.lib",
      "description": "This module implements equality, hashing, comparison, and serialization operations for the `GoblintCil.varinfo` type, which represents variable information in CIL (C Intermediate Language). It enables efficient set and map operations over variables, supporting analyses that require tracking variable identities, such as dataflow analysis or points-to analysis. Specific use cases include comparing variables for equality, generating unique string representations, and serializing variable data for external output or storage.",
      "description_length": 526,
      "index": 1047,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Analyses.MCPSpec-G",
      "library": "goblint.lib",
      "description": "This module defines lattice operations for manipulating abstract values represented by the type `G.t`, including comparison, ordering, combination (join/meet/widen/narrow), and pretty-printing. It supports lattice-theoretic computations in static analysis frameworks, particularly for monotone analyses that require tracking abstract program states (e.g., top element checks and extremal value propagation). The operations are tailored for abstract interpretation and constraint system solving, where precise representation of dataflow information is critical.",
      "description_length": 560,
      "index": 1048,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.IntDomainProperties.OldSWithIkind",
      "library": "goblint.lib",
      "description": "This module provides lattice operations (join, meet, widen, narrow), arithmetic and bitwise manipulations (addition, division, shifts), and logical operations (negation, AND/OR) on abstract integer domain values represented as type `t`. It works with integer domains structured in a lattice hierarchy, supporting interval or symbolic representations, bounded/exact values, and exclusion lists. The operations enable abstract interpretation for static analysis, such as verifying program integer arithmetic, handling value constraints, and modeling undefined behaviors in low-level code.",
      "description_length": 586,
      "index": 1049,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.LockDomain.MustLock",
      "library": "goblint.lib",
      "description": "This module provides operations for managing lock variables with offset information, enabling conversions between lock domain values and both CIL representations and Mval.t abstractions. It works with structured data combining variable metadata (`varinfo`) and offset indices, facilitating lockset domain mappings in static analysis. These operations are essential for tracking lock dependencies and concurrency constraints when analyzing threaded programs.",
      "description_length": 457,
      "index": 1050,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.PthreadDomain.D",
      "library": "goblint.lib",
      "description": "This module provides lattice operations (join, meet, widen, narrow) and comparison utilities (equal, compare) for abstract thread states, represented as the type `t`. It supports serialization to JSON and pretty-printing for debugging, alongside constants like top/bottom elements for lattice initialization. These features enable precise static analysis of Pthread concurrency by modeling thread state transitions and integrating with analysis frameworks requiring structured data exchange.",
      "description_length": 491,
      "index": 1051,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.CommonPriv.ThreadNotStartedDigest",
      "library": "goblint.lib",
      "description": "This module tracks whether specific threads have been started during analysis, using a digest structure to represent the state. It provides operations to compare, hash, and display these states, along with utilities to check if one state accounts for another. It is used to refine analysis precision by capturing thread initialization context in value and relation analyses.",
      "description_length": 374,
      "index": 1052,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.LocksetAnalysis.MayArg-D",
      "library": "goblint.lib",
      "description": "This module provides lattice operations (join, meet, widen, narrow) and utilities for comparison and representation, working with an abstract domain D.t that models may-locksets in concurrent programs. It supports static analysis tasks such as tracking potential lock acquisitions and ensuring thread safety by defining top and bottom elements to represent extremal states in lockset analysis.",
      "description_length": 393,
      "index": 1053,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Witness.WitnessTaskResult-Arg-Node",
      "library": "goblint.lib",
      "description": "This module implements a hash and equality-based comparison for ARG nodes, enabling efficient key-based operations like set and map manipulations. It works with `Arg.Node.t` values, extracting structural and contextual information such as CFG nodes, context IDs, and path IDs. It supports precise node comparison and transformation in analysis results, particularly during witness generation or graph traversal tasks.",
      "description_length": 417,
      "index": 1054,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Analyses.SpecSysSol-SpecSys-GHT-Exceptionless",
      "library": "goblint.lib",
      "description": "This module provides safe lookup and in-place modification operations for hash tables, returning optional values or result types to handle absence or failure explicitly. It works with hash tables parameterized over keys and values, using standard key-value pair types. Concrete use cases include managing analysis state in constraint systems where key presence is uncertain or modifications may fail, such as tracking variable bindings or analysis results during static analysis.",
      "description_length": 479,
      "index": 1055,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.SarifType.Result",
      "library": "goblint.lib",
      "description": "This module defines the structure and serialization for SARIF analysis results. It includes operations to convert result data, such as rule ID, severity level, message, and locations, into SARIF-compliant JSON format. It is used to report static analysis findings with precise source code positioning and related context.",
      "description_length": 321,
      "index": 1056,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.YamlWitnessType.Producer",
      "library": "goblint.lib",
      "description": "This module provides functions to convert a producer record to and from YAML format. It works with the `t` type, which includes fields like name, version, and optional command line. Use this module when serializing or deserializing producer information in YAML for witness files.",
      "description_length": 279,
      "index": 1057,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.DomainProperties.Top",
      "library": "goblint.lib",
      "description": "Implements QCheck property tests for top element behavior in lattice structures. Works with any lattice module D that includes a top value and comparison operations. Useful for verifying correctness of lattice implementations in abstract interpretation contexts.",
      "description_length": 262,
      "index": 1058,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.YamlWitness.Validator",
      "library": "goblint.lib",
      "description": "This module validates YAML witness files against logical and structural rules, ensuring correctness during static analysis by enforcing invariants at specific program points. It operates on YAML data and uses node-level checks to confirm valid placement of invariants based on control flow, lock states, and syntactic conditions. The module tracks source locations and maps them to specification variables using hierarchical structures, supporting precise validation through set operations, ordered maps, and file-based data manipulation. Examples include verifying that invariants are placed at loop heads, resolving variable associations at specific code locations, and merging or filtering YAML-based witness files with positional context.",
      "description_length": 742,
      "index": 1059,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.TerminationPreprocessing.VarToStmt",
      "library": "goblint.lib",
      "description": "This module specializes in mapping C variables (`CilType.Varinfo.t`) to generic values, offering ordered map operations like insertion, lookup, and traversal, along with bulk conversions to sequences and lists. It supports termination analysis by maintaining associations between variables and their corresponding statements, enabling ordered processing and efficient querying of variable-related data. Key use cases include tracking variable dependencies and facilitating structured analysis of termination conditions in C code.",
      "description_length": 529,
      "index": 1060,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Analyses.VarF",
      "library": "goblint.lib",
      "description": "This module pairs analysis data with control-flow graph nodes, enabling precise tracking of variable states across program points. It supports operations like equality checks, hashing, and location extraction for analysis diagnostics, and is used in constraint-based analyses to associate variable facts with CFG nodes. Concrete use cases include tracking variable liveness, value ranges, or pointer aliases at specific program locations during static analysis.",
      "description_length": 461,
      "index": 1061,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.LoopTermination.Statements",
      "library": "goblint.lib",
      "description": "This module provides lattice operations (join, meet, widen, narrow) and comparison utilities for a type representing termination states of loops, which can be either bottom (unreachable), top (unknown), or lifted Cil statements tracking specific control flow points. It supports abstract interpretation by enabling merging and comparison of termination analysis states, particularly for handling loops and goto statements in program analysis. The lattice structure facilitates precise tracking of termination behavior across iterative control flow constructs during static analysis.",
      "description_length": 582,
      "index": 1062,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.YamlWitnessType.PreconditionLoopInvariant",
      "library": "goblint.lib",
      "description": "This module defines and manipulates a data structure that combines a location with a loop invariant and a precondition. It provides functions to compare instances, parse them from YAML, and access the entry type string. It is used to represent and validate preconditions and loop invariants in a YAML-based witness format for program analysis.",
      "description_length": 343,
      "index": 1063,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.LocksetAnalysis.MakeMust",
      "library": "goblint.lib",
      "description": "This module performs abstract interpretation for tracking locksets in concurrent programs, managing initialization, context switching, and program constructs such as assignments, branches, and function calls, while analyzing thread spawning and synchronization events using CIL-based elements and abstract domains for per-thread and combined states. It includes submodules that implement must-lockset analysis for race detection, lattice operations for abstract lockset states, and a singleton domain for must-alias analysis, all supporting precise concurrency analysis through operations like join, meet, widen, and narrowing. The module enables tracking lock acquisition patterns, enforcing lock usage discipline, and verifying thread safety across multi-threaded C programs. Specific capabilities include determining required locks at program points, merging lock states across threads, and detecting race conditions and deadlock scenarios through static analysis.",
      "description_length": 967,
      "index": 1064,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.BasePriv.S-D",
      "library": "goblint.lib",
      "description": "This module provides lattice operations (join, meet, widen, narrow) and structural manipulations (equality, hashing, XML/JSON serialization) for abstract domains used in thread-modular static analysis. It operates on a lattice type `D.t` representing abstract values in non-relational analyses, with dedicated support for top element detection and lattice extremum handling. These capabilities enable efficient abstract interpretation of concurrent programs by tracking value properties across thread interactions.",
      "description_length": 514,
      "index": 1065,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.AbstractionDomainProperties.Monotone",
      "library": "goblint.lib",
      "description": "Implements QCheck property tests for monotonicity of abstract domain operations. Verifies that increasing the input to abstract functions does not decrease the output. Works with concrete domains, abstract domains, and abstractions connecting them. Useful for validating correctness of abstract interpreters.",
      "description_length": 308,
      "index": 1066,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.WrapperFunctionAnalysis.WrapperArgs",
      "library": "goblint.lib",
      "description": "This module defines the interface for wrapper function analyses that generate symbolic heap locations and thread identifiers based on node and thread IDs. It includes operations to check if a function is wrapped and to retrieve the list of wrapper function names. Used to track dynamic memory allocations and thread creation in analyses like `mallocWrapper` and `threadCreateWrapper`.",
      "description_length": 384,
      "index": 1067,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Analyses.SpecSysSol-SpecSys-LHT",
      "library": "goblint.lib",
      "description": "This module provides imperative hash table operations for managing key-value mappings with `EQSys.LVar.t` keys and arbitrary values, supporting multiple values per key through functions like `add`, `find`, bulk updates, and traversal. It includes utilities for in-place modifications, functional transformations (e.g., filtering, merging), and conversions to sequences or lists, alongside formatted output capabilities. These features are tailored for static analysis workflows requiring efficient constraint manipulation, dynamic data aggregation, and structured representation of variable-associated state.",
      "description_length": 608,
      "index": 1068,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.YamlWitnessType.ViolationSequence",
      "library": "goblint.lib",
      "description": "This module processes sequences of violation segments in YAML witness files, representing structured paths of constraints, assumptions, targets, and control flow elements like function calls and branches. It parses and compares segments, waypoints, and constraints, supporting operations like serialization to YAML, structural comparison, and type-specific handling of waypoints such as function entry/exit and branching nodes. Concrete use cases include validating function return assumptions, tracking control flow events, and modeling violation paths with structured constraints on locations and actions. Key types include waypoints with typed records, branching structures, and constraint values with format specifiers, all organized into segments that model complete violation sequences.",
      "description_length": 792,
      "index": 1069,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Access.Memo",
      "library": "goblint.lib",
      "description": "This module represents memory locations for accesses, combining a root identifier with an offset. It provides operations to create, compare, hash, and manipulate these locations, including adding offsets and converting to other representations like strings or XML. Use cases include tracking memory references in analysis, such as identifying specific variables or types along with their offsets during static analysis.",
      "description_length": 419,
      "index": 1070,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Malloc_null.Spec",
      "library": "goblint.lib",
      "description": "This module performs path-sensitive static analysis to detect null dereferences and unreachable code paths caused by failed memory allocations in C programs. It operates on abstract memory states (`D.t`), analysis contexts (`ctx`), and CIL structures like expressions and function definitions, using lattice operations from its submodules to model allocation outcomes and track null pointers across control flow paths. The child modules define the lattice structure and utilities for abstract interpretation, supporting operations like `join`, `meet`, `widen`, and `narrow` to refine memory state approximations during analysis. Example uses include verifying that error-handling paths are taken after failed allocations and ensuring pointers are non-null before dereference.",
      "description_length": 775,
      "index": 1071,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ObserverAutomaton.S",
      "library": "goblint.lib",
      "description": "Implements a finite automaton that processes sequences of abstract reachability graph (ARG) nodes to detect infeasible paths. It transitions between states using an initial state, a next-state function, and an acceptance condition. Useful for static analysis tools that need to track path feasibility during abstract interpretation.",
      "description_length": 332,
      "index": 1072,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Analyses.SpecSys-LHT-Labels",
      "library": "goblint.lib",
      "description": "This module provides labeled argument versions of standard Hashtbl operations, enhancing readability and argument order flexibility while maintaining identical behavior. It works with labeled hashtables (`LHT.t`) and supports key-value manipulations such as adding, replacing, filtering, mapping, folding, and merging with functions that take labeled keys and data. Concrete use cases include safer and more expressive hash table transformations in analysis code, such as tracking variable bindings or aggregating analysis results per key.",
      "description_length": 539,
      "index": 1073,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.ExtractPthread.Tbls",
      "library": "goblint.lib",
      "description": "This module organizes thread-local storage and mapping infrastructure for Pthread program analysis, combining hash table-based tracking of symbolic identifiers with context-specific data. It supports bidirectional mappings, integer-to-node lookups, and thread-specific state management, enabling precise tracking of threads, mutexes, condition variables, and function calls. Operations include adding and retrieving thread IDs by name, mapping function names to thread sets, and maintaining synchronized associations between identifiers and program symbols. Specific uses include Promela extraction tasks like control state tracking, mutex and condition variable management, and per-thread function call analysis.",
      "description_length": 713,
      "index": 1074,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.YamlWitness.Entry",
      "library": "goblint.lib",
      "description": "This module constructs individual entries for YAML witnesses, representing verification results such as invariants and certificates. It supports data types like `Entry.t`, `Task.t`, `Location.t`, `Invariant.t`, `Target.t`, and `Certification.t`, primarily used to describe program analysis outcomes. Concrete use cases include creating location-specific invariants, loop invariants, flow-insensitive invariants, and certification entries tied to specific code targets.",
      "description_length": 468,
      "index": 1075,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.BaseDomain.ExpEvaluator",
      "library": "goblint.lib",
      "description": "Implements expression evaluation for integer constants in the base analysis domain. Works with the abstract state type `t` and CIL expressions, producing optional integer results. Evaluates arithmetic and logical expressions during static analysis to refine value approximations.",
      "description_length": 279,
      "index": 1076,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.RegionDomain.RegPart",
      "library": "goblint.lib",
      "description": "This module manages disjoint heap regions using set-based and lattice operations over region identifiers, supporting analysis of memory relationships through partition structures. It provides core data types `RS.t` for region sets and `RegPart.t` for partitions, with operations like union, intersection, closure, and lattice joins to determine equivalence classes and track memory regions. Functional transformations and serialization functions such as `pretty` and `to_yojson` enable abstract interpretation and data exchange. Submodules extend these capabilities with specialized operations for region analysis and partition manipulation.",
      "description_length": 641,
      "index": 1077,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Taint.Spec",
      "library": "goblint.lib",
      "description": "This module orchestrates data flow tracking through control flow constructs and interprocedural analysis, modeling taint states with abstract domains, global environments, and value abstractions. It defines core operations for manipulating taint information using lattice structures, equality checks, and serialization, while child modules refine these abstractions into concrete types for tracking taint variables, managing path representatives, and generating analysis output. You can use it to detect security vulnerabilities like injection flaws by tracing tainted data across function calls, or generate witnesses for race conditions using uniquely tagged taint contexts. Specific capabilities include comparing taint states, serializing analysis results to JSON/XML, and managing thread-aware taint propagation through CIL-based programs.",
      "description_length": 844,
      "index": 1078,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Analyses.MCPA",
      "library": "goblint.lib",
      "description": "Implements a context representation for static analysis with support for comparison, hashing, and serialization. Works with context identifiers that track analysis states in constraint systems. Used to identify and compare analysis contexts during fixed-point computations and race detection.",
      "description_length": 292,
      "index": 1079,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.WrapperFunctionAnalysis.MallocWrapper",
      "library": "goblint.lib",
      "description": "This module tracks symbolic heap locations for dynamic memory allocations in C programs, using node and thread identifiers to distinguish allocation sites across execution contexts. It defines a core type `t` representing these locations, equipped with comparison, hashing, and serialization operations, and integrates lattice operations to model program state changes during static analysis. The module enables precise tracking of `malloc`-style allocations through wrapper functions, supporting analysis of concurrent memory access and heap-structure relationships. Submodules refine this behavior with path-sensitive tracking, constraint integration, and domain-specific precision for static analyses like points-to and memory safety verification.",
      "description_length": 750,
      "index": 1080,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Analyses.MCPSpec-P",
      "library": "goblint.lib",
      "description": "This module defines operations for managing global constraint variables, including equality checks, hashing, comparison, and string representation. It works with a concrete type `t` and provides functions to project values of another type `D.t` into `t`, retrieve unique identifiers, and support arbitrary value generation for testing. It is used to represent and manipulate path representatives in constraint systems with unique tags for context identification.",
      "description_length": 462,
      "index": 1081,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.CommonPriv.MutexGlobals",
      "library": "goblint.lib",
      "description": "This module coordinates global variable management in thread-modular analysis for mutex-protected state, offering iteration and transformation over shared values. It works with submodules that model variable identifiers, mutex initialization statuses, polymorphic value categories, and offset-tracked mutex variables, all supporting equality, hashing, serialization, and test generation. Operations enable tracking shared state, distinguishing mutex statuses, lifting values between domains, and analyzing lock synchronization. Examples include extracting variable identifiers, updating mutex states, and verifying concurrent program correctness through structured value transformations.",
      "description_length": 687,
      "index": 1082,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.LockDomain.MakeRW",
      "library": "goblint.lib",
      "description": "This module combines a lockset domain with read/write permissions, supporting operations like equality checks, comparison, and pretty-printing of lock and permission pairs. It works with tuples of type `P.t * RW.t`, where `P` represents a lockset domain and `RW.t` represents read/write permission states. Concrete use cases include tracking and comparing synchronized access permissions in concurrent program analysis.",
      "description_length": 419,
      "index": 1083,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.CommonPriv.Protection",
      "library": "goblint.lib",
      "description": "This module determines variable protection status in concurrent analysis. It checks whether variables are unprotected, protected by specific locks, or unprotected except under certain conditions, using thread-modular analysis. Functions evaluate lock requirements and variable access safety in the context of must-lock domains and query-based protection policies.",
      "description_length": 363,
      "index": 1084,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.PrecCompareUtil.R-RH-Labels",
      "library": "goblint.lib",
      "description": "This module provides labeled argument versions of standard Hashtbl operations, enhancing readability and argument order flexibility. It works with Hashtbl instances where keys are of type `RH.key` and data can be any type `'a`. Concrete use cases include safely modifying or filtering hash table entries using labeled functions like `modify`, `filteri`, or `merge`, ensuring clarity in function calls with multiple arguments.",
      "description_length": 425,
      "index": 1085,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Expsplit.Spec",
      "library": "goblint.lib",
      "description": "This interface enables path-sensitive static analysis by tracking expression values across program paths using abstract domains and context-sensitive operations. It processes CIL constructs to manage state transitions, function calls, and concurrency, with core types including paths, constraint variables, abstract values, and analysis contexts. Operations support lattice manipulations (join, meet, widen), path differentiation via unique identifiers, and precise value tracking through domain-specific merging and transfer functions. Example uses include detecting race conditions, analyzing recursive functions, and generating witnesses for branching paths with value-dependent constraints.",
      "description_length": 694,
      "index": 1086,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.PrivPrecCompareUtil.LV",
      "library": "goblint.lib",
      "description": "This module defines operations for comparing, hashing, and displaying location-variable pairs, specifically tuples of `CilType.Location.t` and `Basetype.Variables.t`. It includes functions for equality checks, ordering, string representation, XML and JSON serialization, and generating arbitrary values for testing. These utilities support precise analysis of variable locations in CIL-based static analysis, particularly in tracking and comparing base type variables within Goblint's analysis framework.",
      "description_length": 504,
      "index": 1087,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ObserverAutomaton.KMP",
      "library": "goblint.lib",
      "description": "Implements a finite automaton for detecting infeasible abstract reachability graph paths using a KMP-like algorithm. Works with integer states and transition values provided by the KMPArg module. Used to efficiently match patterns in program analysis paths, specifically identifying when a path becomes infeasible during static analysis.",
      "description_length": 337,
      "index": 1088,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.ResultQuery.NH",
      "library": "goblint.lib",
      "description": "This module implements a mutable hash table optimized for constraint system analysis, using `Node.t` identifiers as keys and supporting generic value types with imperative operations for insertion, lookup, filtering, mapping, and merging. It enables efficient data manipulation and structural conversions to lists or sequences, facilitating performance-critical analysis passes. Submodules extend functionality with exception-safe value handling, typed constraint system operations, and infix syntax for concise key-based queries and updates. Example uses include tracking and refining analysis results per program point or variable, and restructuring solver output during static analysis.",
      "description_length": 689,
      "index": 1089,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.LockDomain.MustMultiplicity",
      "library": "goblint.lib",
      "description": "This module combines map-like structures with lattice operations to track must-locked locks using keys of type `MustLock.t` and values representing multiplicity counts. It supports algebraic combinations of lock states, incrementing and decrementing counts, and analyzing upper and lower bounds through operations like join, meet, widen, and narrow. The module enables precise modeling of lock dependencies and multiplicity constraints, useful for verifying correct lock usage in concurrent programs. It also includes utilities for comparison, hashing, JSON/XML serialization, and testing with arbitrary integers.",
      "description_length": 613,
      "index": 1090,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.AccessAnalysis.Spec",
      "library": "goblint.lib",
      "description": "This module implements transfer operations for abstract interpretation-based access analysis, modeling memory access and state changes in concurrent programs using abstract domains (`D.t`, `G.t`), CIL expressions, and control flow elements. It includes submodules for CFG node manipulation and lattice operations, enabling analysis of memory effects, access patterns, and domain computations. The CFG submodule represents and processes control flow nodes with metadata, supporting analysis tasks like visualization and serialization, while the lattice submodule provides join, meet, and widening operations over abstract access information. Together, they allow tracking memory accesses across threads, resolving node properties, and performing dataflow-driven optimizations.",
      "description_length": 775,
      "index": 1091,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.MallocFresh.Spec",
      "library": "goblint.lib",
      "description": "This module analyzes unescaped heap allocations in C programs through abstract interpretation, tracking allocation freshness across function calls, branches, and threads. It combines variable sets with CIL AST elements to model heap state, using abstract domains for merging, approximating, and querying memory properties during analysis. Child modules define lattice structures for allocation states, set operations for variable tracking, and boolean tags for freshness results, enabling precise modeling of thread-local allocations. Examples include determining if an allocation site is thread-local, merging abstract states at join points, and serializing analysis results for diagnostics or further processing.",
      "description_length": 714,
      "index": 1092,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.LocksetAnalysis.MustArg-D",
      "library": "goblint.lib",
      "description": "This module provides lattice operations for an abstract domain representing lockset information, including join/meet for combining concurrent states and widen/narrow for iterative analysis convergence. It manipulates values of type `D.t` structured as a lattice with distinguished top (unconstrained) and bottom (unreachable) elements, specifically designed for tracking must-hold locks in concurrent program analysis. The operations enable static analysis of synchronization correctness by maintaining precise lock acquisition contexts across program paths.",
      "description_length": 558,
      "index": 1093,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.MyARG.UnCilLogicIntra",
      "library": "goblint.lib",
      "description": "Implements intra-procedural abstract reachability graph traversal operations. Provides `next` and `next_opt` functions to compute reachable nodes and edges from a given control flow graph node, working directly with `MyCFG.node` and `MyCFG.edge` types. Used for analyzing function-local control flow paths in program analysis tasks.",
      "description_length": 332,
      "index": 1094,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.WideningTokenLifter.Lifter",
      "library": "goblint.lib",
      "description": "This module enhances abstract domains with widening tokens to control convergence during static analysis, combining local and global state tracking to delay widening until token sets stabilize. It provides transfer functions over abstract values (`D.t`), global state (`G.t`), function contexts (`C.t`), and value operations (`V.t`), enabling precise fixpoint computations in interprocedural and concurrent analyses. Submodules define lattice operations, constraint variables, and token management, supporting concrete tasks like path-sensitive widening delays, context-sensitive state transitions, and unique variable tracking. Key operations include join, meet, widen, and narrowing with token-aware comparisons, along with utilities for tagging, serialization, and token projection.",
      "description_length": 785,
      "index": 1095,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MCPRegistry.DomVariantSysVar",
      "library": "goblint.lib",
      "description": "This module represents system variables in a dynamic analysis context, where each variable is uniquely identified by a combination of an integer tag and an object value. It provides operations for equality checking, hashing, comparison, and various forms of serialization (e.g., to strings, XML, and Yojson). These variables are used to track and distinguish different analysis contexts during witness generation and constraint solving in a product-based analysis framework.",
      "description_length": 474,
      "index": 1096,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Server.ArgWrapper-Locator-LocM-Exceptionless",
      "library": "goblint.lib",
      "description": "This module provides functions to query and retrieve values from a location map without raising exceptions. It supports operations like `find`, which looks up a value by key, `choose`, which selects a key-value pair, and `any`, which returns any key-value pair. These functions are used to safely inspect or select entries in a `Locator.LocM.t` structure, typically representing mappings from source code locations to analysis results. Concrete use cases include retrieving analysis data for specific program points or selecting representative values during abstract interpretation.",
      "description_length": 582,
      "index": 1097,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Analyses.Spec-G",
      "library": "goblint.lib",
      "description": "This module supports lattice operations including join, meet, widen, and narrow, along with equality checks, ordering comparisons, and extremal value handling (top, bot) for an abstract lattice type `G.t`. It provides utilities for serialization, pretty-printing, and property testing, enabling use in static analysis frameworks where abstract interpretation or dataflow analysis requires fixed-point computations and result inspection.",
      "description_length": 436,
      "index": 1098,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.SarifType.SarifLog",
      "library": "goblint.lib",
      "description": "Handles SARIF log serialization to Yojson format. Works with SARIF log data structures, including version, schema, and run records. Used to convert SARIF logs into JSON representations for output or further processing.",
      "description_length": 218,
      "index": 1099,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Base.MainSpec-D",
      "library": "goblint.lib",
      "description": "This module provides lattice operations for an abstract domain, including comparison (`leq`, `compare`), combination (`join`, `meet`, `widen`, `narrow`), and extremum handling (`bot`, `top`, `is_bot`, `is_top`), all operating on elements of type `D.t`. It supports static analysis via abstract interpretation, enabling domain-specific approximations and non-relational value tracking. Key use cases include dataflow analysis and program safety verification, where precise yet efficient modeling of value ranges or properties is required.",
      "description_length": 537,
      "index": 1100,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.RegionDomain.VFB",
      "library": "goblint.lib",
      "description": "This module provides operations for managing must-equality constraints and region domain values through a variant type, supporting abstract interpretation tasks like inclusion checks (`leq`), joins, and variable elimination. It works with polymorphic values, region-tagged data, and symbolic expressions involving variables and offsets, enabling precise tracking of heap region relationships. Key use cases include static analysis of memory operations, where region constraints and variable substitutions must be dynamically resolved or collapsed during program analysis.",
      "description_length": 571,
      "index": 1101,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.MCPRegistry.DomainListLatticeSpec",
      "library": "goblint.lib",
      "description": "Implements a lattice specification for a list of domains indexed by integers, where each domain adheres to the Lattice.S signature. Provides operations to retrieve individual domains by index and list all registered domains with their indices. Used to manage and access multiple abstract domains in a dynamic product analysis context.",
      "description_length": 334,
      "index": 1102,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Analyses.SpecSysSol-SpecSys-GHT",
      "library": "goblint.lib",
      "description": "This module supports efficient manipulation of hash tables with key-value pairs, offering operations for insertion, lookup, and deletion with support for handling duplicates and optional values. It provides functions to transform, filter, and merge hash tables, along with conversions to and from sequences like lists and enumerations. These capabilities are useful in scenarios requiring structured data management, such as static analysis of program constraints or configuration handling.",
      "description_length": 490,
      "index": 1103,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.YamlWitnessType.Certification",
      "library": "goblint.lib",
      "description": "Handles parsing and serializing certification data in YAML format, specifically for witness files. It provides functions to convert between a structured type with `string`, `type_`, and `format` fields and YAML representation. Used to validate and manipulate certification sections in YAML-based witness documents.",
      "description_length": 314,
      "index": 1104,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.LocksetAnalysis.MustArg",
      "library": "goblint.lib",
      "description": "This module implements must-argument lockset analysis operations, tracking locks that must be held when accessing shared resources. It provides functions to add or remove locks based on memory addresses accessed, using abstract domains for data (D), global state (G), and values (V). Use this to enforce mandatory locking discipline in concurrent programs by analyzing which locks must be acquired before accessing specific memory locations.",
      "description_length": 441,
      "index": 1105,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.MyARG.Stack",
      "library": "goblint.lib",
      "description": "Implements a stack-based traversal mechanism over nodes and edges of an abstract reachability graph. Provides operations to retrieve the main entry point (`main_entry`) and to compute the next reachable nodes along with their connecting edges (`next`). Useful for analyzing control flow or dependencies in program structures represented as graphs.",
      "description_length": 347,
      "index": 1106,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Server.ParamParser",
      "library": "goblint.lib",
      "description": "Parses JSON-RPC structured input into a typed parameter configuration for server requests. It processes optional JSON-RPC payloads, converting them into validated parameter values or error messages. This supports handling client requests with structured data in an interactive server context.",
      "description_length": 292,
      "index": 1107,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Analyses.SpecSys-LHT",
      "library": "goblint.lib",
      "description": "This module implements imperative hash table operations for managing key-value pairs where keys are logical variables (`EQSys.LVar.t`) and values are abstracted. It supports in-place modifications, higher-order transformations (e.g., filtering, merging), and conversions to sequences, enabling efficient state manipulation during static analysis. Typical use cases include tracking variable bindings, aggregating analysis results, and handling exception-safe table updates in constraint systems.",
      "description_length": 495,
      "index": 1108,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.StackTrace.Spec",
      "library": "goblint.lib",
      "description": "This module provides analysis operations for modeling program behavior through control flow, state transitions, and concurrency, operating on abstract contexts, CIL expressions, and function and variable metadata. It includes a child module that defines lattice operations\u2014join, meet, widen, narrow\u2014on call contexts with support for comparison, serialization, and identifying top and bottom elements. Together, they enable precise call stack reconstruction, merging hierarchical contexts, and abstract interpretation with lattice-based domains. Specific uses include tracking concurrent execution paths, resolving interprocedural state changes, and analyzing function calls under varying environments.",
      "description_length": 701,
      "index": 1109,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Analyses.MCPSpec-C",
      "library": "goblint.lib",
      "description": "This module defines operations for managing and manipulating analysis contexts with support for equality, hashing, comparison, and serialization. It works with the abstract type `C.t` representing analysis contexts, providing functions for generating unique identifiers, pretty-printing, XML and JSON serialization, and QCheck arbitraries. Concrete use cases include context handling in static analysis, such as tracking and comparing analysis states, generating unique context tags for witness identification, and supporting serialization for analysis result output.",
      "description_length": 567,
      "index": 1110,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Base.MainSpec-G",
      "library": "goblint.lib",
      "description": "This module provides lattice operations and abstract domain manipulations for static analysis, including equality checks, comparison, and domain-specific functions like widening and narrowing. It works with abstract values of type `G.t`, which represent non-relational data-flow information in a structured lattice hierarchy. These capabilities are used to implement value analysis in static program analysis, enabling precise yet efficient reasoning about program properties through domain-theoretic operations.",
      "description_length": 512,
      "index": 1111,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Analyses.MCPSpec-D",
      "library": "goblint.lib",
      "description": "This module provides lattice-theoretic operations for abstract interpretation, including join, meet, widening, narrowing, and extremal value checks (top, bot), operating on an abstract domain type `D.t`. It supports static analysis tasks like merging program states, comparing abstractions, and tracking approximations in dataflow analysis. The operations facilitate reasoning about program properties through algebraic structures that model hierarchical or constrained value spaces.",
      "description_length": 483,
      "index": 1112,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.IntDomainProperties.Valid",
      "library": "goblint.lib",
      "description": "Implements QCheck test cases to validate properties of integer domains, ensuring correctness of operations like addition, subtraction, and comparison. Works with concrete and abstract integer domains (CD, AD) and abstract flags (AF) to check domain-specific behaviors. Useful for testing soundness and precision of abstract interpretations in static analysis.",
      "description_length": 359,
      "index": 1113,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MyARG.CfgIntra",
      "library": "goblint.lib",
      "description": "Implements intra-procedural abstract reachability graph traversal operations. Provides functions to retrieve outgoing edges and successor nodes from a given node in the control flow graph. Useful for analyzing function-level control flow and data dependencies during static analysis.",
      "description_length": 283,
      "index": 1114,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ThreadFlagDomain.Simple",
      "library": "goblint.lib",
      "description": "This module implements lattice operations and utilities for managing thread flags that identify the main thread, including state creation, comparison, and serialization. It works with an algebraic type `t` representing thread states like top, single, multi, and main, enabling precise tracking of thread identity. These capabilities support static analysis tools in distinguishing main thread interactions and concurrency patterns in multi-threaded programs.",
      "description_length": 458,
      "index": 1115,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Graphml.XmlGraphMlWriter",
      "library": "goblint.lib",
      "description": "This module writes GraphML files in XML format to an output channel. It supports defining graph keys, metadata, nodes, and edges with attributes, operating on string-based node identifiers. It is used to serialize directed graphs with labeled nodes and edges into a structured XML format suitable for visualization or analysis tools.",
      "description_length": 333,
      "index": 1116,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.WrapperFunctionAnalysis.ThreadCreateWrapper",
      "library": "goblint.lib",
      "description": "This module analyzes thread creation in C programs by assigning symbolic thread identifiers derived from control flow nodes, enabling precise tracking of thread spawning and entry points across interprocedural and concurrent contexts. It operates on abstract domains for state (D), global data (G), contexts (C), and variables (V), and includes data types for symbolic thread IDs with operations for comparison, hashing, serialization, and lattice manipulations such as join and widen. Submodules provide path-representative types, lattice-based abstract interpretation, and context-sensitive tracking mechanisms, supporting operations like `may_race`, `tag`, and `should_print` to manage and distinguish thread creation events. These components work together to model thread-local state, control flow constructs, and wrapper functions in static analysis, enabling precise reasoning about concurrency and interleavings.",
      "description_length": 919,
      "index": 1117,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Analyses.Spec2Spec",
      "library": "goblint.lib",
      "description": "This module provides operations for initializing and finalizing analysis states with marshaled data, handling control flow transitions, and defining transfer functions for assignments, branches, function calls, and thread operations. It works with abstract domains `D`, `G`, `C`, and `V` to model program states, contexts, and global information, alongside CIL variables and functions for precise interprocedural tracking. These capabilities enable context-sensitive interprocedural analysis, concurrency handling, and synchronization point management in modular static analysis frameworks.",
      "description_length": 590,
      "index": 1118,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.PrecCompareUtil.R-Key",
      "library": "goblint.lib",
      "description": "This module defines operations for comparing, hashing, and converting key values to strings or XML, specifically working with the abstract type `t`. It supports use cases like tracking unique identifiers for contexts in witness generation and comparing keys for precision analysis. Functions include `compare`, `hash`, `show`, and `tag`, which are essential for managing key-based data structures and diagnostics.",
      "description_length": 413,
      "index": 1119,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.LockDomain.MayLocksetNoRW",
      "library": "goblint.lib",
      "description": "This module provides a lattice-based set domain for tracking potential lock acquisitions in concurrent programs, operating on sets of memory addresses (`Addr.t`) as lock identifiers. It supports precise set operations like union, intersection, and difference alongside lattice join/meet, enabling analysis of lock state transitions and safety properties. Typical use cases include static analysis of thread synchronization to detect race conditions or deadlocks by modeling possible lock ownership scenarios.",
      "description_length": 508,
      "index": 1120,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.WideningToken.Uuid",
      "library": "goblint.lib",
      "description": "This module implements UUID-based widening tokens used to track and manage context-specific state during abstract interpretation. It provides operations for equality checking, hashing, comparison, and serialization to formats like XML and JSON, along with generating arbitrary values for testing. These tokens are used to uniquely identify and lift contexts in witness generation and analysis precision control.",
      "description_length": 411,
      "index": 1121,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ExtractPthread.Tasks",
      "library": "goblint.lib",
      "description": "This module provides lattice-based set operations for analyzing concurrent programs, focusing on tasks represented as combinations of memory addresses and thread states. It works with a specialized set type built from a product lattice of addresses and pthread domain values, supporting operations like union, filtering, and extremal element extraction. These capabilities are used for abstract interpretation of thread interactions, static analysis of shared-memory concurrency, and tracking thread state transitions in Pthread programs.",
      "description_length": 538,
      "index": 1122,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.MusteqDomain.P",
      "library": "goblint.lib",
      "description": "This module represents pairs of symbolic lvalues and provides operations for equality checking, comparison, hashing, and pretty-printing. It supports data types involving pairs of `V.t` values, where `V` is a module defining symbolic values. Concrete use cases include tracking and comparing equalities between memory locations in static analysis, serializing pairs for output, and generating arbitrary test instances for verification.",
      "description_length": 435,
      "index": 1123,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.UseAfterFree.AllocaVars",
      "library": "goblint.lib",
      "description": "This module implements lattice and set-based operations for tracking stack-allocated variables during memory safety analysis, focusing on detecting use-after-free vulnerabilities. It works with a lattice domain representing either a set of variable identifiers or a top element, alongside a specialized set-like structure for efficient manipulation of CIL variable descriptors through standard operations like union, intersection, and element removal. These tools enable precise modeling of variable lifetimes in static analysis to identify invalid memory accesses after deallocation.",
      "description_length": 584,
      "index": 1124,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Violation.Feasibility-Node",
      "library": "goblint.lib",
      "description": "This module represents nodes in an abstract reachability graph (ARG) for tracking violation feasibility. It provides operations to compare, hash, and serialize nodes, as well as extract control flow and contextual information. Use cases include identifying unique nodes during violation analysis and tracking path and context identifiers for debugging and refinement.",
      "description_length": 367,
      "index": 1125,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Analyses.SpecSys-LHT-Infix",
      "library": "goblint.lib",
      "description": "This module defines infix operators for interacting with a BatHashtbl-based table, providing `-->` to retrieve the current binding of a key and `<--` to add a new binding that hides previous entries for the same key. It works directly with `LHT.t`, a hash table type from the `LHT` module, using standard key-value pairs. These operators simplify common hash table lookups and updates while preserving historical bindings until explicitly removed.",
      "description_length": 447,
      "index": 1126,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Access.WarnAccs",
      "library": "goblint.lib",
      "description": "This module tracks sets of memory accesses categorized by their context, such as current node, prefix, and type suffix accesses, to support race detection and warning generation. It provides operations to compute differences between access sets, unify all accesses, check emptiness, and pretty-print access information. Concrete use cases include analyzing concurrent memory accesses during static analysis to identify potential data races.",
      "description_length": 440,
      "index": 1127,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.VectorMatrix.ConvenienceOps",
      "library": "goblint.lib",
      "description": "This module defines infix operators for arithmetic and comparison operations on values of type `A.t`, including addition, subtraction, multiplication, division, and equality checks. It also provides a conversion function from integers to `A.t`. These operations are intended for use with rational number types that support the operations in `RatOps`.",
      "description_length": 350,
      "index": 1128,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.YamlWitnessType.Location",
      "library": "goblint.lib",
      "description": "This module defines operations for handling source code location information in YAML format. It provides functions to convert location data to and from YAML, supporting structured representation of file names, line and column numbers, file hashes, and function names. Concrete use cases include serializing and deserializing location metadata for analysis reports or witness files.",
      "description_length": 381,
      "index": 1129,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Analyses.SpecSys-EQSys",
      "library": "goblint.lib",
      "description": "Implements constraint system specifications for analysis, defining how to compute and update variable values within a lattice structure. It operates on local and global variables (`LVar.t`, `GVar.t`) with associated domain types (`D.t`, `G.t`), supporting operations to evaluate constraints, iterate over variables, and track changes in the system state. Used to model and solve dataflow equations during static analysis of programs.",
      "description_length": 433,
      "index": 1130,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.StackTrace.Spec2",
      "library": "goblint.lib",
      "description": "This module coordinates control flow tracking, variable assignment management, and interprocedural analysis across sequential and concurrent programs using CIL constructs. It integrates call stack analysis through lattice operations, stack manipulation, and unit-type representations that enable precise modeling of function call hierarchies and thread-local state. Concrete capabilities include path-sensitive bug detection, variable flow tracking through nested calls, and serialization of analysis states for logging or external tool integration. Submodules provide specialized support for stack trace comparison, abstract interpretation, and handling unit values in analysis workflows.",
      "description_length": 689,
      "index": 1131,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Analyses.SpecSys",
      "library": "goblint.lib",
      "description": "This module combines analysis specifications with constraint system interfaces, enabling the definition and solving of analysis constraints over abstract domains. It operates on abstract syntax trees and constraint systems, supporting tasks like dataflow analysis and points-to analysis in static program analysis. Use cases include implementing custom analyses for C programs in Goblint, such as tracking memory safety or concurrency properties.",
      "description_length": 446,
      "index": 1132,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.StackTrace.SpecLoc",
      "library": "goblint.lib",
      "description": "This module analyzes CIL control flow constructs and manages abstract interpretation contexts for static analysis, working with CIL expressions and abstract states to track execution paths, handle function calls and returns, and model thread interactions. It includes lattice operations and comparison utilities for specification locations, supporting path-sensitive analysis with symbolic states and call stack tracking structures. You can perform interprocedural dataflow analysis, represent symbolic program states, and model concurrency in C verification frameworks. The module enables operations like join and widen on abstract states while providing context management for function entry and exit points.",
      "description_length": 710,
      "index": 1133,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.WitnessUtil.InvariantParser",
      "library": "goblint.lib",
      "description": "This module provides functions to parse expressions in CABS and CIL formats for invariant generation, working with environments and variable lists from CIL files. It supports parsing expressions with contextual checks against function definitions and locations. Concrete use cases include extracting and validating invariants from witness annotations during static analysis.",
      "description_length": 374,
      "index": 1134,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ResultQuery.SpecSysSol2-SpecSys-LHT",
      "library": "goblint.lib",
      "description": "This module provides imperative hash table operations for key-value pairs with `EQSys.LVar.t` keys and polymorphic values, supporting efficient lookups, bulk modifications, and in-place transformations like filtering, merging, and key-value mapping. It facilitates conversions between hash tables and sequences/lists/enumerators, along with utilities for structured traversal, aggregation, and formatted output. Use cases include managing constraint system solutions where dynamic key-value associations require iterative refinement, merging analysis results from different scopes, or transforming intermediate data into consumable formats for downstream processing.",
      "description_length": 666,
      "index": 1135,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ResultQuery.SpecSysSol2-SpecSys",
      "library": "goblint.lib",
      "description": "Implements operations for querying and transforming constraint system solutions using specification-driven logic. It provides functions to extract and manipulate solution components such as variables, constraints, and domains. This module is used to analyze and interpret the results of constraint solving in static analysis workflows.",
      "description_length": 335,
      "index": 1136,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.BaseDomain.PartDeps",
      "library": "goblint.lib",
      "description": "This module manages hierarchical variable dependencies using a specialized abstract domain, supporting algebraic combinations and bulk transformations of variable-to-variable-set mappings. It provides lattice operations like join, meet, and widening over dependency partitions, enabling precise modeling of dataflow interactions in static analysis tasks such as taint tracking and constant propagation. The module includes submodules for standard set operations, serialization, and testing, all working on immutable variable sets to support functional manipulation, partitioning, and cardinality checks. Example uses include merging partitioned dependencies during fixpoint computations and customizing domain-specific merging logic for abstract interpretation.",
      "description_length": 761,
      "index": 1137,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Graphml.StringGraphMlWriter",
      "library": "goblint.lib",
      "description": "This module writes GraphML files with string-labeled nodes and edges. It provides functions to start and end a graph, write keys, metadata, nodes, and edges with attributes. Concrete use cases include exporting control flow graphs or dependency graphs to GraphML for visualization or analysis.",
      "description_length": 293,
      "index": 1138,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Queries.VS",
      "library": "goblint.lib",
      "description": "This module provides lattice-based operations and standard set manipulations for handling variable sets, with support for abstract interpretation tasks like merging analysis states and querying variable properties. It works with sets of `CilType.Varinfo.t` elements, offering transformations, partitioning, and extremal element retrieval to model program variable relationships during static analysis. Use cases include tracking variable presence, dependencies, or constraints across program paths in a lattice structure that accommodates top values for imprecise information.",
      "description_length": 576,
      "index": 1139,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.SarifType.Artifact",
      "library": "goblint.lib",
      "description": "This module defines a SARIF artifact with a location field and provides functions to convert artifact instances to Yojson format. It works with the `ArtifactLocation.t` type to represent file or resource locations in SARIF output. Concrete use cases include serializing analysis results to SARIF for external tooling integration.",
      "description_length": 329,
      "index": 1140,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Server.ArgWrapper-Locator-LocM-Infix",
      "library": "goblint.lib",
      "description": "This module defines bidirectional operations for manipulating location-based monadic values using `-->` to retrieve values by key and `<--` to update or insert key-value pairs in a monadic context. It works with `Locator.LocM.t` structures, which represent computations in a monad parameterized by a key type. Concrete use cases include managing and transforming contextual data in interactive server sessions, such as tracking source code positions or handling scoped variables during analysis.",
      "description_length": 495,
      "index": 1141,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.YamlWitness.Make",
      "library": "goblint.lib",
      "description": "This module generates and validates YAML witnesses by integrating node and loop tracking, function-specific data management, and location-based metadata handling. It processes abstract syntax tree nodes, analysis contexts, and invariants to export structured verification results, using imperative maps and hash tables for efficient key-based access and transformation. Operations include loop detection, safe value manipulation with string and labeled keys, and hierarchical merges for structured YAML updates. Examples include validating analysis outcomes, exporting witnesses for external tools, and managing nested configuration data with infix syntax and result-safe lookups.",
      "description_length": 680,
      "index": 1142,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Server.Registry",
      "library": "goblint.lib",
      "description": "This module manages a registry of JSON-RPC request handlers, mapping string identifiers to modules implementing the `Goblint_lib.Server.Request` signature. It provides operations to create a new empty registry and register individual request handlers. Concrete use cases include setting up an interactive server with named RPC endpoints for handling client requests in a structured and extensible manner.",
      "description_length": 404,
      "index": 1143,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MusteqDomain.Equ",
      "library": "goblint.lib",
      "description": "This domain provides map-like operations for managing key-value associations, lattice operations (join, meet, widen) to combine equality constraints, and utilities for evaluating expressions within symbolic equality analysis. It operates on sets of must-equality relations between variables and values, represented as key-value pairs in a structured lattice. The domain is used in static analysis to track equalities that must hold at runtime and analyze program constraints through symbolic manipulation of variable-value relationships.",
      "description_length": 537,
      "index": 1144,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.ResultQuery.SpecSysSol2-SpecSys-GHT-Labels",
      "library": "goblint.lib",
      "description": "This module provides labeled argument versions of standard Hashtbl operations, enhancing readability and safety when working with tables of type `'a SpecSys.GHT.t`. It supports key-value operations such as adding, replacing, modifying, and querying entries, along with transformations, filters, and folds over the table elements. Concrete use cases include managing and transforming constraint system solutions with improved argument clarity and order flexibility.",
      "description_length": 464,
      "index": 1145,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.TaintPartialContexts.VS",
      "library": "goblint.lib",
      "description": "This module provides a lattice-based taint analysis domain for tracking sets of tainted variables, supporting operations like union, intersection, and difference alongside lattice-specific functions such as join and widen. It works with a set-like abstract type for variables (`Basetype.Variables.t`), offering constructors, queries, and transformations for precise static analysis of taint propagation. The structure is optimized for use cases like context-sensitive taint tracking in static analysis tools, enabling efficient enumeration, partitioning, and size-based constraints on variable sets.",
      "description_length": 599,
      "index": 1146,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.MutexAnalysis.VarSet",
      "library": "goblint.lib",
      "description": "This module provides standard set operations and lattice operations for analyzing sets of program variables represented as `Basetype.Variables.t`. It supports dataflow analysis tasks through functions like union, intersection, partitioning, and lattice-specific operations such as join and widen. These capabilities are applied in static analysis to track concurrency-related properties, including must-lock and protecting lockset information in multi-threaded programs.",
      "description_length": 470,
      "index": 1147,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.LocksetAnalysis.Make",
      "library": "goblint.lib",
      "description": "This module performs lockset analysis for concurrent programs, managing thread states and inter-procedural contexts to model synchronization behavior across CIL AST elements. It defines abstract domains (`D.t`) and contexts (`C`) for representing lock states as lattices, supporting operations like `join`, `meet`, `widen`, and `narrow` to analyze and combine locksets during abstract interpretation. The analysis tracks thread-local locks, synchronization primitives, and assignment effects in control flow to detect concurrency issues such as deadlocks and race conditions. Submodules provide lattice-specific manipulations, enabling precise static modeling of lock acquisition and release patterns in multithreaded code.",
      "description_length": 723,
      "index": 1148,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MCPAccess.A",
      "library": "goblint.lib",
      "description": "This module defines operations for comparing, hashing, and serializing memory access metadata represented as lists of integer-object pairs. It includes functions for checking potential race conditions between access sets, folding over access elements, and converting data to XML or JSON formats. Use cases include analyzing concurrent memory accesses in static analysis and managing metadata during abstract interpretation.",
      "description_length": 423,
      "index": 1149,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Goblint_lib.ResultQuery.SpecSysSol2-SpecSys-GHT-Infix",
      "library": "goblint.lib",
      "description": "This module defines infix operators for interacting with a BatHashtbl-based constraint system solution. It provides `-->` to retrieve the current binding of a key or raise `Not_found`, and `<--` to add a new binding that hides previous ones without removing them. These operations support incremental updates and backtracking in constraint solving scenarios.",
      "description_length": 358,
      "index": 1150,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MyARG.CFGEdge",
      "library": "goblint.lib",
      "description": "This module represents edges in an abstract reachability graph derived from a control flow graph. It provides operations to embed raw CFG edges into the abstract representation and convert them to string form. It is used to analyze program paths in static analysis by tracking transitions between nodes in the abstract graph.",
      "description_length": 325,
      "index": 1151,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Queries.Hashtbl",
      "library": "goblint.lib",
      "description": "This module manages hash tables with polymorphic values indexed by `Goblint_lib.Queries.Any.t` keys, supporting multiple values per key and offering imperative and functional operations for conditional updates, mapping, filtering, and merging. Submodules extend this functionality with labeled key manipulations, operator-based access using `-->` and `<--`, and thread-safe operations for concurrent environments. It enables key-based data aggregation, iterative transformations, and structured output generation, with concrete uses in analysis tools for lattice-aware query result handling and shared state management. Direct APIs include conversion to sequences and lists, while submodules provide specialized transformations and safe retrieval mechanisms.",
      "description_length": 758,
      "index": 1152,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Queries.TS",
      "library": "goblint.lib",
      "description": "This module provides a lattice structure over sets of CIL types, supporting set operations like union, intersection, and membership checks alongside lattice-specific operations such as widening and narrowing. It works with polymorphic sets (`t`) of `CilType.Typ.t` elements, offering utilities for partitioning, size analysis, and conversions between sets and lists. Designed for abstract interpretation, it enables tracking and combining type information across program states, such as analyzing possible type assignments or refining type constraints during static analysis.",
      "description_length": 575,
      "index": 1153,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.BasePriv.S-V",
      "library": "goblint.lib",
      "description": "This module defines operations for a value analysis type `t`, including equality, hashing, comparison, and string representation. It supports concrete use cases like tracking unique identifiers for values using `tag` and enabling context-sensitive analysis through `relift`. The module works with values of type `V.t`, which represents abstract values in a thread-modular analysis framework.",
      "description_length": 391,
      "index": 1154,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MyARG.S-Node",
      "library": "goblint.lib",
      "description": "This module defines operations for comparing, hashing, and ordering abstract reachability graph nodes. It provides functions to access components like CFG nodes, context IDs, and path IDs, as well as converting nodes to strings. It supports moving a node to a new CFG node when possible and checks equality based on node context.",
      "description_length": 329,
      "index": 1155,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.SarifType.Region",
      "library": "goblint.lib",
      "description": "This module defines a data structure for representing source code region information with start and end line and column numbers. It includes functions for converting region data to JSON format and comparing regions for equality. This is used to encode positional information in SARIF output for static analysis tools.",
      "description_length": 317,
      "index": 1156,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Analyses.MCPSpec",
      "library": "goblint.lib",
      "description": "This module type provides operations for initializing and finalizing analyses with marshaling support, managing abstract data states (`D`), global",
      "description_length": 146,
      "index": 1157,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.MyARG.Node",
      "library": "goblint.lib",
      "description": "This module defines operations for working with abstract reachability graph nodes, providing equality, hashing, and comparison functions based on both node structure and context. It supports concrete operations like extracting CFG nodes, context IDs, and path IDs from a node, as well as generating string representations and creating modified node instances via `move_opt`. These functions are used to manipulate and distinguish nodes within the abstract reachability graph during analysis.",
      "description_length": 491,
      "index": 1158,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.YamlWitnessType.InvariantSet",
      "library": "goblint.lib",
      "description": "This module manages collections of verification invariants in YAML format, supporting parsing from and conversion to YAML values, along with comparison operations. It handles structured invariant records, including loop and location invariants, each associated with specific attributes such as location, value, and format. The module enables operations like deserializing invariant data for analysis, comparing invariant sets for equivalence, and validating static analysis results. Submodules provide fine-grained handling of invariant types, loop-specific structures, and location-based associations, supporting full round-trip processing between in-memory representations and YAML-encoded data.",
      "description_length": 697,
      "index": 1159,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MyARG.IsInteresting",
      "library": "goblint.lib",
      "description": "Determines whether a path in the abstract reachability graph should be explored further based on node and edge properties. It evaluates the interestingness of transitions between nodes via edges to guide analysis precision and performance. Used during analysis to filter out irrelevant paths and prioritize important ones.",
      "description_length": 322,
      "index": 1160,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ThreadId.Spec",
      "library": "goblint.lib",
      "description": "This module analyzes thread identities in concurrent programs through lattice-based abstract interpretation, modeling thread creation, synchronization, and state transitions across control flow paths. It defines core data types such as `t` for abstract thread IDs and `ThreadLifted.t option` for handling optional or lifted thread contexts, with operations including join, meet, widen, and leq to merge and compare thread states. You can track thread interference in variable assignments, resolve thread identity in function calls, and serialize analysis results to XML or Yojson for diagnostics. Submodules refine this foundation with tuple-based analysis, lifted domains, and optional thread handling to support precise static analysis of multithreaded CIL code.",
      "description_length": 764,
      "index": 1161,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ObserverAnalysis.PathArg",
      "library": "goblint.lib",
      "description": "Tracks path-sensitive analysis states through control flow edges using an observer automaton. It represents paths as lists of node pairs from a control flow graph (CFG), enabling analysis of execution paths and their transitions. This supports precise dataflow analysis by associating values with specific paths through the CFG.",
      "description_length": 328,
      "index": 1162,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MCPRegistry.PathListSpec",
      "library": "goblint.lib",
      "description": "Implements path-sensitive analysis specifications using disjoint domains. Provides operations to associate domain identifiers with representative modules and retrieve ordered domain lists for analysis composition. Supports dynamic activation of analyses based on path conditions in static analysis workflows.",
      "description_length": 308,
      "index": 1163,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.CompareConstraints.CompareNode",
      "library": "goblint.lib",
      "description": "This module coordinates constraint comparison and state management across analysis nodes, combining operations for merging and analyzing hierarchical constraint data (`D.t`, `LH.t`, `NH.t`) with utilities for node identification, pretty-printing, and structured reporting. It enables concrete tasks such as merging abstract environments during fixpoint iteration, detecting convergence by comparing constraint states, and generating human-readable diffs of analysis discrepancies. Submodules handle node-specific comparisons, control-flow-aware identification, and imperative hash tables keyed on analysis nodes, supporting efficient constraint tracking, serialization, and diagnostic output. Together, these components facilitate robust constraint analysis, debugging, and integration with solver and reporting infrastructure.",
      "description_length": 827,
      "index": 1164,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.CommonPriv.ThreadDigest",
      "library": "goblint.lib",
      "description": "This module implements a digest type for tracking thread-local contributions in abstract interpretations, specifically for identifying and comparing local analysis states across threads. It provides operations for equality checking, hashing, comparison, and pretty-printing, along with utilities for serialization and generating arbitrary values for testing. It is used to determine whether one thread's local state has accounted for another's in a thread-modular analysis, supporting precise join operations and witness generation.",
      "description_length": 532,
      "index": 1165,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.ResultQuery.SpecSysSol2-SpecSys-Spec-G",
      "library": "goblint.lib",
      "description": "This module implements lattice-theoretic operations for combining and comparing abstract values represented by the `SpecSys.Spec.G.t` type, which models elements in a static analysis constraint system. It provides core functionality like `join`, `meet`, `widen`, and `narrow` for merging and refining program analysis states, alongside predicates `is_bot` and `is_top` to detect extremal values. These operations are essential for analyzing program properties through abstract interpretation, such as determining value ranges or tracking data flow dependencies.",
      "description_length": 561,
      "index": 1166,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.ThreadJoins.Spec",
      "library": "goblint.lib",
      "description": "This module models thread-join analysis for concurrent programs, combining thread state domains, CIL expressions, and analysis contexts to track synchronization, initialization, and return values across dynamically created threads. It defines operations for clustered relational thread-modular abstract interpretation, enabling static analysis of inter-thread dependencies and synchronization behavior. The child modules enhance this by providing lattice operations and comparisons over a product domain that combines thread ID tracking with exit state analysis, supporting serialization, pretty-printing, and test generation. Together, they allow precise modeling of thread interactions and clean termination conditions, such as ensuring all spawned threads complete successfully before program exit.",
      "description_length": 801,
      "index": 1167,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.SpecLifters.DeadCodeLifter",
      "library": "goblint.lib",
      "description": "This module enhances static analysis by introducing a lifted bottom element to model unreachable code paths, manipulating a domain `D.t` to track reachability states across control flow, concurrency, and variable assignment operations. It integrates path-representative values for distinguishing unreachable contexts and provides utilities to lift abstract values while preserving dead code information. Specific capabilities include detecting dead code, analyzing concurrency, and optimizing transformations through unreachable code elimination. The module works with global environments to resolve interprocedural dependencies and supports serialization, comparison, and pretty-printing for analysis artifacts.",
      "description_length": 712,
      "index": 1168,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.UseAfterFree.StackAndHeapVars",
      "library": "goblint.lib",
      "description": "This module combines an abstract domain for lattice-based analysis of stack and heap variables using `AllocaVars` and `HeapVars` types, enabling operations like join, meet, and widening to model memory state transitions. It supports serialization to XML/JSON, generates test values, and compares variable states to identify discrepancies in memory usage patterns. These capabilities are specifically applied to detect use-after-free vulnerabilities by tracking allocation lifetimes and validating safe memory access in program analyses.",
      "description_length": 536,
      "index": 1169,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.RegionDomain.RegionDom",
      "library": "goblint.lib",
      "description": "This module provides lattice operations such as join, meet, widen, and narrow for abstractly representing and manipulating disjoint heap regions in static analysis. It operates on a variant domain type combining bottom/top elements with lifted region maps (`RegMap.t`), which model abstract memory regions. The functionality supports tracking and reasoning about heap memory partitions in analyses like concurrency verification or memory safety checks, leveraging serialization and property-based testing for robustness.",
      "description_length": 520,
      "index": 1170,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.EscapeDomain.EscapedVars",
      "library": "goblint.lib",
      "description": "This module provides a lattice-based domain for tracking thread-local variables that have escaped their original scope during program analysis, using a sum type that either represents a concrete set of variables or a top element denoting all variables. It operates on sets of `Basetype.Variables.t` values with standard set operations like union, intersection, and filtering, while supporting functional transformations such as mapping and folding. The domain is particularly useful in static analysis scenarios to reason about concurrency-related escapes, such as identifying variables shared between threads or escaping to global state.",
      "description_length": 638,
      "index": 1171,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.TmpSpecial.Spec",
      "library": "goblint.lib",
      "description": "This module coordinates variable equivalences and math library function results within an abstract interpretation framework, managing dataflow states, expressions, and function declarations. It tracks how variables relate to computed values through dependency maps and sets, supporting operations like merging, transformation, and lattice combinators to handle control-flow and invalidation on modification. For example, it enables tracking how a variable's value propagates through a math function call, or determining when an equivalence must be dropped due to assignment. Submodules refine this with dependency maps, expression sets with lattice structures, and combined equivalence tracking, each enhancing precision in static analysis scenarios involving math function results and variable dependencies.",
      "description_length": 808,
      "index": 1172,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.PrivPrecCompareUtil.Util",
      "library": "goblint.lib",
      "description": "This module orchestrates precision comparisons and domain value manipulations in static analysis, centered around `unmarshal` for initializing domain values and working with types like `Dom.t`, `RH.t`, and `marshal`. It integrates a polymorphic hash table for managing analysis state with imperative and functional transformations, enabling tasks like resource tracking and error propagation through key-value operators and safe value modifications. Lattice operations for compound domains support joins, meets, and precision checks, facilitating abstract interpretation workflows that rely on structured value relationships. Additional utilities for hashing, conversion, and serialization allow for pretty-printing, structured output, and generation of arbitrary values for testing, covering key-based data manipulation and analysis integration.",
      "description_length": 846,
      "index": 1173,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Witness.Result",
      "library": "goblint.lib",
      "description": "This module orchestrates result determination and output generation for verification tasks by analyzing node-spec pairs and producing structured GraphML-based witness files. It integrates result types, control flow graphs, and SV-COMP task definitions to map verification outcomes to specific program points, supporting operations such as result querying, metadata tracking, and path-based analysis. Key data types include nodes, constraints, indices, and key-value maps, with functionality for equality checks, hashing, graph traversal, and context-sensitive comparisons. Submodules enable constraint graph queries, bidirectional index resolution, structural node identification, and graph navigation, facilitating tasks like variable value extraction, invariant checking, and witness generation across context-sensitive paths.",
      "description_length": 828,
      "index": 1174,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.SarifType.ToolComponent",
      "library": "goblint.lib",
      "description": "This module defines a tool component structure used to describe analysis tools within the SARIF format, including metadata like name, version, and organization. It includes functions to convert the structure to JSON using Yojson for serialization. The component is used to bundle tool-specific rules and reporting descriptors for static analysis results.",
      "description_length": 354,
      "index": 1175,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Uninit.Spec",
      "library": "goblint.lib",
      "description": "This module tracks uninitialized variables during static analysis by propagating initialization states through control flow and function calls, using abstract domains and CIL AST elements to model liveness and memory access. It includes submodules that define lattice operations and type-class functionalities for abstract states, supporting operations like join, meet, and widen to handle partial information and extremal states. These components enable detection of uninitialized variable usage in C programs, with utilities for comparison, visualization, and structured output generation. Example uses include analyzing local variable initialization across branches and assignments, and visualizing state transitions in XML or JSON formats.",
      "description_length": 743,
      "index": 1176,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.DomainProperties.Meet",
      "library": "goblint.lib",
      "description": "Implements QCheck property tests for meet operations in lattice structures. Works with any lattice domain module D that includes meet semantics. Ensures correctness of meet against lattice laws like idempotence, commutativity, and absorption through concrete test cases.",
      "description_length": 270,
      "index": 1177,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Analyses.SpecSysSol-SpecSys-LHT-Labels",
      "library": "goblint.lib",
      "description": "This module provides labeled argument versions of standard Hashtbl operations, enhancing readability and safety by requiring explicit parameter names. It works with labeled hashtables (`SpecSys.LHT.t`) where keys and data values are manipulated using functions that enforce labeled argument order. Concrete use cases include adding, replacing, filtering, mapping, and merging entries in a type-safe manner, particularly useful when dealing with complex or ambiguous function signatures where argument order might otherwise lead to errors.",
      "description_length": 538,
      "index": 1178,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.ResultQuery.SpecSysSol2-SpecSys-Spec-P",
      "library": "goblint.lib",
      "description": "This module defines operations for handling globally unique constraint variables, including equality checks, hashing, comparison, and string representation. It works with the abstract type `t` representing path-representative constraint variables. Used to project constraint system elements into unique identifiers and support witness generation with unique tags.",
      "description_length": 363,
      "index": 1179,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Analyses.Spec2Spec-D",
      "library": "goblint.lib",
      "description": "This module provides lattice-theoretic operations essential for abstract interpretation, including join, meet, widening, narrowing, and difference comparison, all acting on an abstract domain type. It supports static analysis tasks like fixpoint computation and value comparison by defining extremal elements (e.g., top) and predicates to reason about domain-specific program abstractions. These operations enable precise and efficient analysis of data structures representing program states or properties.",
      "description_length": 506,
      "index": 1180,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Server.ArgWrapper-Locator",
      "library": "goblint.lib",
      "description": "This module manages mappings from source code locations to argument nodes in an interactive server context. It provides operations to create, add, query, and clear these mappings, specifically working with file handles, location monads, and environment substitutions. It is used to track and retrieve argument information during analysis in Goblint's server mode.",
      "description_length": 363,
      "index": 1181,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.CompareConstraints.CompareEqSys",
      "library": "goblint.lib",
      "description": "This module compares constraint systems by checking equality of values within a domain across two variable mappings, using a `compare` function that takes string keys and mappings to assert equivalence. It works with variables (`Sys.Var.t`) and domains (`Sys.Dom.t`), enabling precise equality checks and structural analysis. The module produces structured comparison results and formatted output, supporting customization for clarity in debugging or verification. It integrates direct operations like variable identity tracking and domain comparison with submodules for comprehensive constraint system analysis.",
      "description_length": 612,
      "index": 1182,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.CondVars.Spec",
      "library": "goblint.lib",
      "description": "This module manages symbolic variables and logical equality analysis for concurrent pointer programs, combining abstract domain state manipulation with CIL expression tracking to model thread interactions. It provides core operations like context-sensitive branching, thread spawning, and pointer target queries, while its child module defines lattice operations and utilities for an abstract type modeling variable relationships and logical invariants. The API supports tasks such as resolving indirect pointer targets, verifying shared variable dependencies, and integrating with analysis tools via XML/JSON serialization. Together, they enable precise static analysis of concurrent C code by tracking equivalence classes and simplifying constraints across dynamic execution paths.",
      "description_length": 783,
      "index": 1183,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.SpecLifters.LevelSliceLifter",
      "library": "goblint.lib",
      "description": "This module implements context-sensitive analysis transfer functions to track and limit function call depth during static analysis, managing abstract states (`D.t`, `G.t`, `C.t`, `V.t`) and handling control and dataflow transitions for function calls, threads, and synchronization. Its child modules provide support for globally constrained variable management and path-representative value handling, enabling precise constraint tracking and path-sensitive analysis. Operations include equality, comparison, hashing, and pretty-printing for constraint variables and abstract paths, with concrete use cases in slice management, constraint propagation, and witness generation. It allows limiting analysis depth dynamically, improving precision and performance in interprocedural analysis by restricting exploration beyond configured thresholds.",
      "description_length": 842,
      "index": 1184,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.YamlWitnessType.LoopInvariant",
      "library": "goblint.lib",
      "description": "This module defines and compares loop invariant data structures used in YAML witness files. It parses YAML values into loop invariant records containing location and invariant information. It supports validation and manipulation of loop invariants during static analysis workflows.",
      "description_length": 281,
      "index": 1185,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Analyses.SpecSys-GHT-Exceptionless",
      "library": "goblint.lib",
      "description": "This module provides safe lookup and modification operations for hash tables, returning optional values or result types instead of raising exceptions. It works with hash tables (`GHT.t`) and their keys, allowing non-failing access and in-place updates. Concrete use cases include handling potentially missing keys during analysis state updates and safely querying analysis data without exception handling overhead.",
      "description_length": 414,
      "index": 1186,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.DomainProperties.Narrow",
      "library": "goblint.lib",
      "description": "Implements narrowing operations for lattice domains, generating QCheck tests to verify correctness. Works with lattice structures defined by the D module, ensuring they satisfy narrowing properties. Useful for testing abstract interpretation domains in static analysis.",
      "description_length": 269,
      "index": 1187,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MemLeak.ToppedVarInfoSet",
      "library": "goblint.lib",
      "description": "This module provides lattice operations (leq, join, meet, widen, narrow, bot, is_bot) and set abstractions (union, intersection, difference, membership) for managing variable information (`Varinfo`) with a universal \"top\" element representing all possible variables. It operates on sets of CIL variable descriptors (`CilType.Varinfo.t`), supporting functional manipulation through iteration, mapping, folding, filtering, and extremal element retrieval, while enabling abstract interpretation via hashing, serialization, and convergence checks. These capabilities are specifically applied in memory leak analysis to track and compare sets of variables involved in dynamic memory allocations, using set operations to model ownership transfers and lattice operations to ensure fixpoint stability during static analysis.",
      "description_length": 816,
      "index": 1188,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.YamlWitness.ValidationResult",
      "library": "goblint.lib",
      "description": "This module combines lattice-based validation state manipulation with structured validation of chain parameters to support static analysis workflows. It defines a four-state `result` type and an integer-based `t` type, supporting operations like `join`, `meet`, comparison, and serialization to XML/JSON. The core lattice operations enable merging and ordering of validation outcomes, while the child module validates YAML witness chain parameters using `n` and `names` to check counts and identifiers. Together, they model hierarchical validation results and enforce correctness in structured witness data.",
      "description_length": 607,
      "index": 1189,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.AnalysisResult.ResultNode",
      "library": "goblint.lib",
      "description": "This module represents nodes in a control flow graph (CFG) for analysis results, providing operations to compare, hash, and serialize nodes. It supports concrete data types like `MyCFG.node` and includes functions for pretty-printing, XML output, and JSON conversion. Use cases include tracking unique node identifiers for witness generation and comparing CFG nodes during static analysis.",
      "description_length": 389,
      "index": 1190,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Signs.Signs",
      "library": "goblint.lib",
      "description": "This module represents integer signs with three possible values: negative, zero, or positive. It provides operations to compare, hash, and convert sign values to and from strings or JSON, as well as to derive signs from integers. It is used to track the sign of integer expressions during intraprocedural static analysis.",
      "description_length": 321,
      "index": 1191,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ObserverAutomaton.KMPArg",
      "library": "goblint.lib",
      "description": "Implements a finite automaton for detecting infeasible abstract reachability graph paths using a predefined pattern of states. It operates on arrays of state values and supports equality checks between states. This module is used to identify invalid execution paths in static analysis by matching sequences against a known infeasible pattern.",
      "description_length": 342,
      "index": 1192,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Queries.ES",
      "library": "goblint.lib",
      "description": "This module provides a lattice-based abstraction for managing sets of CIL expressions (`CilType.Exp.t`) with support for standard set operations (union, intersection, membership checks), cardinality tracking, and lattice semantics via a top element (`Top`). It combines set manipulation (e.g., filtering, mapping, element selection) with analysis-specific utilities like widening/narrowing for fixed-point computations, equality checks, and pretty-printing. Designed for static analysis tasks such as tracking possible expressions in dataflow domains, handling symbolic values, or representing unbounded sets in abstract interpretation scenarios.",
      "description_length": 646,
      "index": 1193,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Constraints.FromSpec",
      "library": "goblint.lib",
      "description": "This module generates a constraint system from a specification and control flow graphs, providing functions to construct and manipulate constraint variables. It operates on logical and global variables with associated data and global domains. Concrete use cases include building and modifying constraint systems for static analysis based on given specifications and CFGs.",
      "description_length": 371,
      "index": 1194,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.IntDomainProperties.AllNonAssoc",
      "library": "goblint.lib",
      "description": "This module defines QCheck property tests for an integer domain implementation. It works with integer domains that support standard arithmetic and comparison operations. Concrete use cases include verifying correctness of interval arithmetic, bitwise operations, and domain-specific properties like overflow handling.",
      "description_length": 317,
      "index": 1195,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.SpecLifters.OptEqual",
      "library": "goblint.lib",
      "description": "This module implements abstract interpretation semantics for static analysis, defining transfer functions that manipulate control flow, interprocedural state transitions, and context-sensitive operations. It operates on abstract domains representing program values, global state, contexts, and variables, with specialized handling for function calls, threading, and event-driven execution. The module enables precise data flow tracking, interprocedural state merging, and context-sensitive handling of branching or concurrent execution paths. Child modules enhance this by providing equality and lattice operations for values, contexts, and constraint variables, supporting tasks like deduplication, caching, constraint comparison, and witness generation through hashing, serialization, and QCheck-based testing.",
      "description_length": 812,
      "index": 1196,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Analyses.Spec-P",
      "library": "goblint.lib",
      "description": "This module defines operations for managing global constraint variables, including equality checks, hashing, comparison, and string representation. It works with a concrete type `t` representing path-representative variables and supports serialization through XML and JSON formats. It is used to identify and compare constraint variables uniquely within an analysis, particularly during witness generation and context-sensitive constraint solving.",
      "description_length": 447,
      "index": 1197,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Analyses.UnitP",
      "library": "goblint.lib",
      "description": "This module defines a unit analysis with operations for equality, comparison, and hashing of unit values, along with pretty-printing, serialization, and arbitrary value generation. It works primarily with the unit type, providing concrete functionality for analysis components that require canonical representations of unit values. Use cases include constraint system definitions and analysis domains where unit values serve as placeholders or terminal states.",
      "description_length": 460,
      "index": 1198,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.SarifType.PhysicalLocation",
      "library": "goblint.lib",
      "description": "Handles physical location data in SARIF format with serialization to JSON and equality checks. Works with artifact locations and regions to specify file positions. Used for representing and comparing source code locations in static analysis reports.",
      "description_length": 249,
      "index": 1199,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MyARG.InlineEdgePrintable",
      "library": "goblint.lib",
      "description": "This module defines operations for comparing, hashing, and converting inline edges in an abstract reachability graph to strings or JSON. It supports data types like `inline_edge` by providing equality checks, pretty printing, XML serialization, and unique ID tagging. Concrete use cases include generating human-readable representations of inline edges and serializing them for external analysis or storage.",
      "description_length": 407,
      "index": 1200,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Server.ArgWrapper-Locator-FileH-Exceptionless",
      "library": "goblint.lib",
      "description": "This module provides operations to locate and modify values in a file handle structure using a key-based lookup. It supports finding an optional value by key and modifying a value at a key with a function, returning a result with unit or exception. Concrete use cases include managing file-specific data in a JSON-RPC server, such as tracking open files or caching analysis results per file.",
      "description_length": 391,
      "index": 1201,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.VectorMatrix.Matrix",
      "library": "goblint.lib",
      "description": "This module provides operations for creating, modifying, and analyzing matrices and vectors, including row/column manipulation, structural transformations like normalization and row-reduced echelon form computation, and element-wise comparisons. It works with matrices, vectors, and numeric types, supporting applications in linear algebra, data processing, and algorithm implementation where matrix manipulations are essential.",
      "description_length": 428,
      "index": 1202,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Analyses.Spec-C",
      "library": "goblint.lib",
      "description": "This module defines operations for handling abstract contexts in static analysis, including equality checks, hashing, comparison, and string representation. It works with the abstract type `C.t` representing analysis contexts, supporting serialization, pretty-printing, and generation of arbitrary values for testing. Concrete use cases include context manipulation in constraint-based analyses and integration with witness formats for verification tasks.",
      "description_length": 455,
      "index": 1203,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ExtractPthread.Codegen",
      "library": "goblint.lib",
      "description": "This module generates Promela code from Pthread-based CIL models by translating control flow, escaping variables, and structuring output, operating on strings, locations, and analysis data to emit model definitions and transitions. It coordinates with mappings that assign stable identifiers to functions and threads, concurrency actions that model thread creation and synchronization, and a control flow graph that tracks transitions for precise analysis. The graph module supports efficient edge queries and path analysis using labeled, optional values and infix operators, while the output module writes finalized Promela models to disk. Examples include converting function calls into Promela `run` statements, mapping thread operations to labeled transitions, and serializing analysis results for model checking.",
      "description_length": 817,
      "index": 1204,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ResultQuery.SpecSysSol2-SpecSys-GHT",
      "library": "goblint.lib",
      "description": "This module provides operations for managing and transforming hash table-like structures with keys of type `EQSys.GVar.t`, supporting insertion, lookup, iteration, and in-place or functional updates of key-value pairs. It works with map-like data structures (`SpecSys.GHT.t`) and facilitates conversions to sequences, lists, and enumerations, alongside customizable printing of contents. Specific use cases include constraint system analysis workflows requiring efficient key-value manipulation, merging of analysis results, and structured data transformation tasks with flexible traversal patterns.",
      "description_length": 599,
      "index": 1205,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Queries.VI",
      "library": "goblint.lib",
      "description": "This module supports lattice operations like widening, meet, and narrowing for abstract domain elements represented as a polymorphic variant with bottom, top, and lifted variables from a base variable type. It provides utilities for comparison, conversion, and arbitrary value generation, enabling efficient abstract interpretation in static analysis frameworks. These operations are particularly useful for dataflow analysis and program verification tasks requiring precise yet scalable domain abstractions.",
      "description_length": 508,
      "index": 1206,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.SarifType.Location",
      "library": "goblint.lib",
      "description": "This module defines a SARIF location record that includes a physical location component. It provides functions to serialize the location to JSON (`to_yojson`) and compare two locations for equality (`equal`). This is used to represent and manipulate file or code locations within SARIF output, such as mapping analysis results to specific source code positions.",
      "description_length": 361,
      "index": 1207,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ResultQuery.SpecSysSol2-SpecSys-Spec-D",
      "library": "goblint.lib",
      "description": "This module provides lattice operations (join, meet, widen, narrow, top, bot) and utility functions (equality, comparison, serialization) for manipulating abstract domain elements. It operates on the `SpecSys.Spec.D.t` type, representing dataflow facts in static analysis, enabling querying and transformation of program analysis results. These capabilities are specifically used in constraint solvers to reason about program behavior through abstract interpretation.",
      "description_length": 467,
      "index": 1208,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.MayLocks.Arg",
      "library": "goblint.lib",
      "description": "This module analyzes may-lock states in concurrent programs by tracking sets of locks that could be held simultaneously, using domain operations to detect issues like double locking. It provides core functionality to add or remove locks from a lockset domain (`D.t`) using context-aware interactions with global and variable state (`G.t`, `V.t`). The child modules extend this by defining lattice operations such as join, meet, and widening, enabling context-sensitive analysis of lock acquisition patterns across program execution paths. Additionally, they include utilities for representing and manipulating abstract lock values with support for comparison, serialization, and identifier extraction, facilitating precise static analysis of multithreaded code.",
      "description_length": 761,
      "index": 1209,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.BasePriv.S",
      "library": "goblint.lib",
      "description": "This module implements thread-modular abstract interpretation operations for tracking value domains in concurrent programs. It provides functions to handle thread creation, synchronization, global variable access, and lock operations, working with abstract values, global and local variable states, and thread identifiers. Concrete use cases include analyzing thread-local storage, enforcing memory safety during concurrent execution, and computing invariants for shared variables.",
      "description_length": 481,
      "index": 1210,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Callstring.Callstring",
      "library": "goblint.lib",
      "description": "This module implements call string analysis using a customizable call string length limit. It provides operations to create, compare, hash, and display call strings, along with support for serialization, pretty printing, and generating arbitrary values for testing. It works with function definitions and analysis contexts to track calling sequences during static analysis.",
      "description_length": 373,
      "index": 1211,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Constants.Spec",
      "library": "goblint.lib",
      "description": "This module performs intraprocedural analysis of definite integer constant values in local variables, using abstract domains and lattice operations to model variable states across control flow and concurrency constructs. It includes submodules for representing constants, managing constraint variables, defining lattice semantics, and handling path-sensitive contexts, all supporting precise tracking and propagation of constant values within single functions. Operations include assignment transfer, flow-sensitive analysis, race detection, and constraint manipulation, with utilities for comparison, serialization, and pretty-printing. Example uses include constant propagation optimizations and educational demonstrations of abstract interpretation on concurrent code regions.",
      "description_length": 779,
      "index": 1212,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ResultQuery.SpecSysSol2-SpecSys-GHT-Exceptionless",
      "library": "goblint.lib",
      "description": "This module provides safe lookup and in-place modification operations for hash tables, returning optional values or result types to handle absence or failure explicitly. It works with hash tables (`Hashtbl`) where keys and values have specific types determined by the `SpecSys.GHT` module. Use this when you need to query or update hash table entries without raising exceptions, such as in analysis passes over constraint systems where missing entries are expected and must be handled gracefully.",
      "description_length": 496,
      "index": 1213,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.SymbLocks.Spec",
      "library": "goblint.lib",
      "description": "This module performs symbolic lockset analysis for detecting data races in concurrent systems code, particularly in device drivers requiring fine-grained locking. It models per-element locking patterns using abstract analysis states and symbolic effect tracking across assignments and library calls, with core operations on symbolic lock sets represented by the type `t`, including join, meet, union, and filtering. Submodules provide lattice semantics and structured set manipulations, supporting context-aware analysis and precise tracking of locks at memory offsets. Example uses include verifying correct locking discipline during static analysis and identifying race conditions in low-level concurrent programs.",
      "description_length": 716,
      "index": 1214,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.PrecCompare.MakeDump",
      "library": "goblint.lib",
      "description": "This module loads and processes analysis results from files, comparing pairs to quantify precision differences and count analyzed locations across multiple runs. It leverages `Util.Dom.t` domains to evaluate and contrast abstract states using customizable comparison functions, generating structured metrics and formatted reports that highlight discrepancies. The child module enhances this by implementing detailed, customizable dumping mechanisms that produce human-readable summaries of domain precision and coverage. Use cases include evaluating analysis configurations on the same program and generating detailed reports on domain behavior and location-based coverage.",
      "description_length": 673,
      "index": 1215,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ArgTools.Make",
      "library": "goblint.lib",
      "description": "This module builds bi-directional argument graphs from constraint solutions, organizing control flow nodes into a structured graph representation with support for node identity management and data retrieval. It works with constraint graphs, analysis states, and hash tables to enable operations like resolving variable indices, querying analysis results, and traversing program dependencies. Child modules enhance this functionality by adding infix operators for concise nested value manipulation, result-type-based safe updates, and utilities for constructing and analyzing abstract reachability graphs. Together, they support tasks like invariant generation, bug detection, and path analysis through structured graph transformations and dynamic key-value mappings.",
      "description_length": 766,
      "index": 1216,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Analyses.SpecSysSol-SpecSys-GHT-Labels",
      "library": "goblint.lib",
      "description": "This module provides labeled argument versions of standard Hashtbl operations, enhancing readability and argument order flexibility. It works with labeled hashtables (`SpecSys.GHT.t`) and keys (`SpecSys.GHT.key`), supporting operations like insertion, iteration, mapping, filtering, and merging. Concrete use cases include managing analysis state in constraint systems where labeled arguments clarify function intent and usage.",
      "description_length": 427,
      "index": 1217,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.WitnessConstraints.PathSensitive3",
      "library": "goblint.lib",
      "description": "This module enables path-sensitive static analysis by defining transfer functions for control flow decisions, function calls, and variable state transitions across abstract domains. It provides core data types such as constraint variables, path representatives, and lattice elements, with operations for joining, widening, and comparing abstract values, along with unique tagging and serialization for witness generation and constraint tracking. Submodules refine analysis precision through lattice operations on abstract domains and support path distinction via unique identifiers, enabling tasks like abstract reachability graph construction and constraint-based analysis of branching and concurrent behaviors. Example uses include tracking variable identities across paths, exporting abstract states in XML or JSON, and modeling program semantics under different execution paths for verification and bug detection.",
      "description_length": 917,
      "index": 1218,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Server.ArgWrapper-Locator-LocM",
      "library": "goblint.lib",
      "description": "This module provides ordered, persistent map operations for location-annotated data, supporting key-based manipulation of `CilType.Location.t`-indexed values with functions like `add`, `find`, `modify`, and predicate-driven searches. It handles structured transformations of location-keyed maps (`Locator.LocM.t`) and annotated lists (`'a list Locator.LocM.t`), enabling use cases such as static analysis metadata tracking, source code position management, and bidirectional traversal of ordered key-value collections. Additional utilities include custom-formatted output generation for annotated structures and list appending within a monadic context.",
      "description_length": 652,
      "index": 1219,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ObserverAnalysis.StepObserverAutomaton",
      "library": "goblint.lib",
      "description": "Implements a state machine for tracking analysis steps over control flow graphs. It defines transitions between states based on edges between CFG nodes, starting from an initial state and determining acceptance based on analysis results. Used to model and verify properties of program paths during static analysis.",
      "description_length": 314,
      "index": 1220,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Queries.FlatYojson",
      "library": "goblint.lib",
      "description": "This module provides lattice operations (join, meet, widen, narrow) and serialization utilities for a three-state flat lattice structure containing bottom, top, or wrapped Yojson values. It supports abstract interpretation tasks in static analysis by enabling convergence control through widening/narrowing while preserving precision for Yojson data. The design facilitates diffing, comparison, and pretty-printing of lattice elements during analysis state transitions.",
      "description_length": 469,
      "index": 1221,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Graphml.EnumerateNodeGraphMlWriter",
      "library": "goblint.lib",
      "description": "This module writes GraphML files by enumerating nodes and edges with customizable attributes. It streams output to a channel, supporting incremental construction of large graphs without loading the entire structure in memory. Use it to generate visualizations of program analysis results, such as control flow or data flow graphs, where nodes and edges carry semantic information.",
      "description_length": 380,
      "index": 1222,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.AnalysisResult.Result",
      "library": "goblint.lib",
      "description": "This module manages analysis results stored in hash tables keyed by `ResultNode` identifiers, offering both functional and imperative operations to transform, query, and merge data. It supports core operations like map, filter, fold, and merge, enabling precise updates and traversals based on keys and values, such as refining ranges at specific program points or extracting subsets of results. Infix operators provide concise access and modification, while safe retrieval and modification functions handle potential absence or failure. Use cases include serializing results to XML or JSON, refining static analysis data, and generating structured outputs for visualization or further processing.",
      "description_length": 697,
      "index": 1223,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.LockDomain.MustLockset",
      "library": "goblint.lib",
      "description": "This module provides standard set operations (union, subset, element manipulation) and lattice operations (join, meet, widening) for analyzing sets of must-locks. It operates on data structures representing locksets as lifted sets of `MustLock` values with explicit top and bottom elements, supporting precise static analysis of concurrency constraints. The domain is particularly useful for tracking locks that must be acquired in specific program contexts to ensure thread safety.",
      "description_length": 482,
      "index": 1224,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Violation.ViolationArg",
      "library": "goblint.lib",
      "description": "This module handles violation propagation and checking within an abstract reachability graph (ARG). It provides functions to track and report violations by analyzing paths through the graph, specifically working with nodes and edges defined in the `Node` submodule. Concrete use cases include identifying unreachable code and detecting assertion failures during static analysis.",
      "description_length": 378,
      "index": 1225,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Access.AS",
      "library": "goblint.lib",
      "description": "This module provides set operations and lattice-based analysis functions for managing collections of memory access elements. It works with sets of values of type `Goblint_lib.Access.A.t`, supporting creation, modification, iteration, and comparison operations alongside domain-specific analysis utilities like widening/narrowing for abstract interpretation. Key use cases include tracking memory access patterns in static analysis, combining access sets through union/intersection, and leveraging lattice properties for approximating program behavior during dataflow analysis.",
      "description_length": 576,
      "index": 1226,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Analyses.SpecSys-GHT-Infix",
      "library": "goblint.lib",
      "description": "This module defines infix operators for interacting with a BatHashtbl, providing `-->` to retrieve the current binding of a key and `<--` to add a new binding for a key. It works directly with BatHashtbl.t and its key type. These operators simplify hash table manipulation in analysis code, particularly when managing scoped or layered environments where bindings can be temporarily overridden and later restored.",
      "description_length": 413,
      "index": 1227,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.SymbLocksDomain.ILock",
      "library": "goblint.lib",
      "description": "This module implements an index-based symbolic lock domain for static analysis, combining symbolic pointer abstraction with index tracking to model lock states and memory offsets. It provides core operations like equality checks, offset manipulation, and type conversions, while its child module handles index-specific logic such as comparisons and string representations for values like `Unknown`, `Star`, or concrete indices. Together, they enable precise tracking of symbolic locksets during concurrency analysis, supporting tasks like detecting race conditions or verifying thread synchronization. Example use cases include comparing lock indices to resolve contention and converting symbolic expressions into lock states for analysis.",
      "description_length": 739,
      "index": 1228,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Analyses.SpecSys-Spec-G",
      "library": "goblint.lib",
      "description": "This module provides lattice-theoretic operations\u2014join, meet, widen, narrow, and ordering checks\u2014for combining and comparing abstract analysis states of type `Spec.G.t`, which models contextual approximations in static analysis. It supports abstract interpretation frameworks by enabling domain-specific reasoning about program properties through hierarchical state approximations. Serialization, hashing, and equality utilities complement these operations, facilitating integration into analysis workflows like control flow analysis or interprocedural dataflow tracking.",
      "description_length": 571,
      "index": 1229,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.LocksetAnalysis.DS",
      "library": "goblint.lib",
      "description": "This module provides lattice operations like join, meet, widen, and narrowing to manipulate abstract lockset values, which model possible concurrency control states. It works with an abstract type `t` that supports order-theoretic reasoning, serialization, and comparison, designed for static analysis of lock-based synchronization. These operations enable efficient fixpoint computations in dataflow analyses tracking lock acquisition patterns.",
      "description_length": 445,
      "index": 1230,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.IntDomainProperties.S",
      "library": "goblint.lib",
      "description": "This module provides lattice operations, arithmetic and bitwise manipulations, and domain refinement capabilities for abstract integer values. It operates on an abstract domain type `t` combined with CIL integer kinds (`ikind`) to handle type-specific behaviors in static analysis. Key use cases include abstract interpretation for program analysis, constraint refinement with intervals/congruences, and precision-preserving value projections for integer properties.",
      "description_length": 466,
      "index": 1231,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Analyses.ValueContexts",
      "library": "goblint.lib",
      "description": "Manages value contexts for analysis by initializing and providing access to a default context value of type `D.t`. Uses the submodule `D` to define the structure and operations of the context data. Enables tracking and propagation of analysis states through functions like `startcontext`, which sets up the initial state for dataflow analysis.",
      "description_length": 343,
      "index": 1232,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.ArgTools.BiArg",
      "library": "goblint.lib",
      "description": "Implements bidirectional traversal over a graph structure using nodes and edges, enabling efficient navigation from any node to its predecessors and successors. Works with `Node.t` and `Edge.t` types to represent graph elements, supporting operations like retrieving adjacent nodes and edges. Useful for analyzing program control flow or data dependencies where reverse and forward traversal is required.",
      "description_length": 404,
      "index": 1233,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.AutoTune.FunctionSet",
      "library": "goblint.lib",
      "description": "This module supports manipulation of sets of C variables (`CilType.Varinfo.t`) through operations like union, intersection, difference, and membership checks, along with transformations (map, filter) and conversions to/from lists and sequences. It enables autotuning workflows that analyze variable usage patterns in C code, such as optimizing configuration settings based on syntactic heuristics derived from variable interactions. The integration with `Stdlib.Seq` facilitates efficient iteration and bulk updates for large-scale variable set analysis.",
      "description_length": 554,
      "index": 1234,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.SymbLocks.PS",
      "library": "goblint.lib",
      "description": "This module provides lattice operations (join, meet, widen, narrow) and set-theoretic manipulations (union, intersection, membership checks, element removal) over symbolic locksets, which represent sets of lock patterns or a top element. It operates on structured symbolic locks tracked in a parametric set type (`PS.t`), enabling precise analysis of concurrent data accesses in scenarios like device driver verification. The operations support static race detection by modeling per-element locking disciplines through abstract interpretation.",
      "description_length": 543,
      "index": 1235,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Goblint_lib.Analyses.SpecSysSol-SpecSys-Spec-V",
      "library": "goblint.lib",
      "description": "This module defines operations for managing globally unique constraint variables, including equality checks, hashing, comparison, and string representation. It works with the abstract type `t` representing constraint variables, which are used to identify and track analysis contexts during constraint solving. Concrete use cases include ensuring variable uniqueness across analyses, enabling context-sensitive dataflow analysis, and supporting witness generation through stable identifiers.",
      "description_length": 490,
      "index": 1236,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MutexEventsAnalysis.Spec",
      "library": "goblint.lib",
      "description": "This module analyzes mutex events in concurrent C programs by modeling lock and unlock actions through static analysis of function calls, thread operations, and variable assignments. It defines core data types like path representatives, constraint variables, and mutex events, with operations for comparison, serialization, and context tracking, enabling precise analysis of synchronization behavior. Submodules provide structured representations of mutex events, constraint variables, and path information, supporting operations like race detection, witness generation, and constraint propagation. The lattice and domain modules enable abstract interpretation of mutex states, allowing join, meet, widen, and narrow operations to detect synchronization errors such as deadlocks and improper lock usage.",
      "description_length": 803,
      "index": 1237,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.StackDomain.Dom1",
      "library": "goblint.lib",
      "description": "This module organizes variable lists into a lattice structure, enabling analysis of stack states through operations like join, meet, widening, and narrowing. It directly supports list-level manipulations, structural equality, and serialization, while its submodules refine lattice behavior for variable domains and abstract value handling. You can compare stack prefixes, approximate sequences during fixed-point iteration, or serialize analysis results for debugging. Combining its direct utilities with its child modules, it enables precise static analysis of dynamic scoping and variable lifecycles in call stacks.",
      "description_length": 617,
      "index": 1238,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MyARG.SIntraOpt",
      "library": "goblint.lib",
      "description": "Implements intra-procedural analysis optimizations for abstract reachability graphs. It provides functions to compute and cache optimized successor nodes and edges for a given control flow graph node, improving analysis efficiency. This module works directly with `MyCFG.node` and `MyCFG.edge` types, specifically handling optional successor lists to model control flow transitions. Use cases include optimizing reachability queries and reducing redundant edge traversals during static analysis.",
      "description_length": 495,
      "index": 1239,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Server.ArgWrapper-Arg-Node",
      "library": "goblint.lib",
      "description": "This module defines operations for comparing, hashing, and converting `Arg.Node.t` values, which represent analysis nodes in a control flow graph. It provides structural comparison via `compare`, equality check with `equal`, and conversion to string with `to_string`, alongside accessors like `cfgnode`, `context_id`, and `path_id` for extracting node components. These functions support precise node identification and manipulation in dataflow analysis and program slicing tasks.",
      "description_length": 480,
      "index": 1240,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.PtranalAnalysis.Spec",
      "library": "goblint.lib",
      "description": "This module provides operations for pointer analysis on CIL constructs, handling control flow, memory effects, and function calls, with a focus on interprocedural evaluation of function pointers. It operates on CIL expressions, lvalues, function definitions, and analysis contexts, while also managing abstract state transitions and thread interactions through generic state manipulation. Use cases include sound function pointer analysis, synchronization of analysis states across function boundaries, and modeling multi-threaded program behavior via stateful thread spawning and parameter handling.",
      "description_length": 600,
      "index": 1241,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ExpRelation.Spec",
      "library": "goblint.lib",
      "description": "This module performs syntactic relational analysis using structural equality (`=_{must}`) across expressions, integrating abstract domains and control-flow points to resolve equivalences during program analysis. It supports operations like `equal`, `compare`, `hash`, and `show` on expression types, enabling use cases such as race detection, symbolic comparison, and constraint resolution. Submodules define lattice structures for merging and querying expression relations, handling constraint variables, and generating path-representative values, all while maintaining stateless, syntactic equality checks. These components collectively enable precise static analysis, property-based testing, and serialization workflows in analysis tools.",
      "description_length": 741,
      "index": 1242,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.WitnessUtil.Locator",
      "library": "goblint.lib",
      "description": "This module organizes witness data using a hierarchical hash table structure keyed by file and location, enabling efficient storage and retrieval of `E.t` elements tied to program points in CIL analyses. It integrates ordered set operations through a child module for managing extremal values and filtered subsets, a mutable string-keyed hash table for file-level data mapping, and location-indexed maps supporting transformations like `add_to_list` and `find_first`. You can track per-file metadata with imperative updates, collect location-annotated invariants, and safely query structured data using optional returns and infix operators for concise, safe traversals.",
      "description_length": 669,
      "index": 1243,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ThreadAnalysis.Spec",
      "library": "goblint.lib",
      "description": "This module orchestrates thread state management and control flow handling in an abstract interpretation framework, coordinating operations across initialization, interprocedural state transitions, and inter-thread data flow analysis. It defines core data types such as thread identifiers (TIDs), abstract domains (`D.t`), and CIL-based program constructs, with primary operations for branching, calling, assigning, and tracking thread lifecycles in concurrent programs. Submodules refine these capabilities by implementing lattice structures for abstract state manipulation, utilities for TID analysis including thread creation tracking and write-only variable detection, and domain-specific comparison and serialization functions. Together, they enable precise static analysis of multi-threaded programs, supporting tasks like race condition detection, thread-local reasoning, and modeling of concurrent execution semantics.",
      "description_length": 926,
      "index": 1244,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.LockDomain.MvalRW",
      "library": "goblint.lib",
      "description": "This module represents a domain for tracking lock values combined with read/write permissions. It provides operations for equality, comparison, hashing, and pretty-printing of lock-value pairs, along with arbitrary value generation for testing. It is used to model and analyze concurrency-related properties in static analysis, specifically handling lock acquisition and release scenarios with directional access tracking.",
      "description_length": 422,
      "index": 1245,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MCPRegistry.PrintableOfMCPASpec",
      "library": "goblint.lib",
      "description": "This module maps analysis domains to printable representations using an integer key. It provides operations to associate a domain with a printable module and retrieve a list of these associations. It is used to dynamically select and display analysis results based on their domain identifiers.",
      "description_length": 293,
      "index": 1246,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ActiveSetjmp.Spec",
      "library": "goblint.lib",
      "description": "This module enables context-sensitive static analysis of C programs with setjmp/longjmp by tracking non-local control transfers through abstract analysis states and CIL constructs. It supports function call handling, concurrency modeling, and control-flow divergence using lattice operations from its submodules, which define the abstract type `t` for buffer states and provide join, meet, widen, and meet operations to merge and approximate analysis states. The module allows querying analysis results to detect potential undefined behavior or imprecise buffer captures in asynchronous error handling and coroutine-like structures. Examples include determining whether a setjmp buffer is active at a given program point or analyzing the control-flow impact of longjmp calls across function boundaries.",
      "description_length": 802,
      "index": 1247,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MyARG.Edge",
      "library": "goblint.lib",
      "description": "This module represents edges in an abstract reachability graph, providing operations to embed control flow graph edges into this abstraction and convert them to string representations. It works with abstract edge types derived from a control flow graph. Concrete use cases include tracking transitions between program points during static analysis and visualizing abstract paths through code.",
      "description_length": 392,
      "index": 1248,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.ResultQuery.SpecSysSol2",
      "library": "goblint.lib",
      "description": "Implements querying of constraint system solutions for analysis results, specifically handling local and global variable evaluations within a system of equations. Operates on data types like `SpecSys.EQSys.LVar.t` for local variables, `Node.t` for control flow nodes, and uses `SpecSys.Spec.D.t` for domain-specific data during queries. Enables concrete tasks such as retrieving computed values at specific program points or under particular local environments.",
      "description_length": 461,
      "index": 1249,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MyARG.Intra",
      "library": "goblint.lib",
      "description": "Implements abstract reachability graph traversal within a single analysis context. Provides entry points and transition logic for navigating control flow graphs using nodes and edges specific to intra-procedural analysis. Enables precise path exploration in static analysis tools by modeling program states and their relationships.",
      "description_length": 331,
      "index": 1250,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.ResultQuery.SpecSysSol2-SpecSys-EQSys",
      "library": "goblint.lib",
      "description": "This module implements functions to query and manipulate constraint system solutions, focusing on variable iteration and system change tracking. It operates on constraint systems involving local and global variables (`LVar.t`, `GVar.t`) with associated domains (`D.t`, `G.t`). Concrete use cases include analyzing program analysis results by iterating over variable solutions and detecting changes in constraint system state during incremental analysis.",
      "description_length": 453,
      "index": 1251,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.SpecLifters.HashconsContextLifter",
      "library": "goblint.lib",
      "description": "This module enables efficient context management in static analysis by hash-consing context identifiers and values, ensuring fast equality checks and unique identification across program elements like functions and threads. It operates on abstract domains `D.t`, `G.t`, `C.t`, and `V.t`, providing core operations for context transformation, relifting, and mutability tracking, such as `relift` and `is_write_only`. The child modules enhance this by offering fine-grained control over hash-consed context identifiers and globally unique tags, supporting use cases like constraint solving and witness generation. Together, they streamline context handling in complex analyses requiring precise state propagation and identity tracking.",
      "description_length": 733,
      "index": 1252,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.CommonPriv.Locksets",
      "library": "goblint.lib",
      "description": "This module tracks and manipulates sets of locks held during thread-modular analysis, computing minimal locksets and checking consistency of lock acquisitions to enforce correct lock usage in concurrent programs. It provides data types like `MustLockset.t` and `MinLocksets.t`, supporting lattice operations, set manipulations, and transformations on lock ownership states. The module enables static analysis for race conditions and thread-safety by modeling lock acquisition patterns, including operations to partition, merge, and compare locksets across program points. These capabilities are used directly through functions on locksets and extended via submodules that refine analysis precision and adapt to specific concurrency models.",
      "description_length": 739,
      "index": 1253,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MCPRegistry.PrintableOfSysVarSpec",
      "library": "goblint.lib",
      "description": "Implements analysis domains for system variables in dynamic product configurations. Uses an integer key to associate with specific domains and provides a list of all registered domain-specifications. Enables runtime selection and application of different analysis domains for system variables.",
      "description_length": 293,
      "index": 1254,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ResultQuery.SpecSysSol2-FileCfg-Cfg",
      "library": "goblint.lib",
      "description": "This module performs precise queries on the constraint system solution for a control flow graph (CFG), enabling analysis of program paths and skipped statements. It operates on CFG structures defined in `MyCFG`, including nodes, edges, and statements, with specific functions to track skipped statements between nodes. Concrete use cases include analyzing gaps in control flow during static analysis, such as identifying AST statements bypassed during CFG construction.",
      "description_length": 469,
      "index": 1255,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ThreadFlagDomain.Trivial",
      "library": "goblint.lib",
      "description": "This module provides lattice operations (join, meet, widen, narrow) and state manipulation functions for a thread flag type `t` representing abstract thread states such as uninitialized (top), single-threaded, multi-threaded, and main thread contexts. It supports abstract interpretation in concurrent program analysis by enabling precise tracking of thread interactions and state transitions through equality checks, ordering relations, and serialization capabilities. The operations are designed for static analysis tools to model thread behavior and enforce concurrency constraints during program verification.",
      "description_length": 613,
      "index": 1256,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Callstring.Spec",
      "library": "goblint.lib",
      "description": "This module implements call string analysis for static program verification, combining infinite and bounded k-CFA approaches to track function call contexts with configurable precision. It defines core data types for abstract domains (`D`, `G`, `C`, `V`) and call string elements (`CT`), supporting operations like context-sensitive interprocedural analysis, race detection, and constraint variable tracking. Submodules provide utilities for path representation, lattice operations, serialization, and unique identifier generation, enabling scalable data flow analysis, points-to analysis, and precise call graph reconstruction. Example use cases include concurrency analysis with bounded call strings and precision-controlled static verification using k-CFA with custom call stack element types.",
      "description_length": 796,
      "index": 1257,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Analyses.SpecSys-LHT-Exceptionless",
      "library": "goblint.lib",
      "description": "This module provides safe lookup and modification operations for hash tables, returning optional values or result types instead of raising exceptions. It works with hash tables (`LHT.t`) and their keys, allowing non-failing access and in-place updates. Concrete use cases include handling potentially missing keys during analysis state updates and safely retrieving values in constraint-solving phases without exception overhead.",
      "description_length": 429,
      "index": 1258,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.ExtractPthread.Variables",
      "library": "goblint.lib",
      "description": "This module tracks variable states in Pthread programs during Promela extraction, distinguishing between top-level and thread-local variables. It provides operations to add variables to thread-specific sets, check variable validity, and retrieve global or local variable lists. Concrete use cases include managing variable visibility across threads and ensuring correct variable handling during program analysis.",
      "description_length": 412,
      "index": 1259,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Analyses.SpecSys-Spec",
      "library": "goblint.lib",
      "description": "This module specifies analysis behaviors for static program analysis, encompassing operations to manage control flow, variable declarations, function calls, and concurrency primitives through abstract interpretation. It manipulates analysis domains (`D`, `G`, `C`, `V`, `P`) and interfaces with CIL constructs to model program semantics, enabling use cases like interprocedural dataflow analysis, thread-aware state tracking, and context-sensitive value propagation.",
      "description_length": 466,
      "index": 1260,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.PrecCompareUtil.R",
      "library": "goblint.lib",
      "description": "This module provides functions to unmarshal and compare precision results between different analysis runs using a hashmap structure. It works with marshaled precision data, domain values, and result types to enable direct comparisons of analysis outcomes. Concrete use cases include evaluating the precision of abstract domains across different program points or configurations.",
      "description_length": 378,
      "index": 1261,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ThreadFlag.Spec",
      "library": "goblint.lib",
      "description": "This module analyzes concurrent programs by managing thread states and synchronization primitives, working with CIL expressions, analysis contexts, and thread identifiers to enable context-sensitive and path-sensitive reasoning. It defines abstract thread flag types and boolean thread flags, supporting operations like thread creation, termination, state transitions, and race condition detection through static analysis. Submodules provide lattice operations, domain-specific primitives, and concrete operations like `may_race` and `should_print`, enabling formalization of thread safety properties and tracking of synchronization points and execution paths. Examples include detecting data races, analyzing state transitions, and controlling output based on thread flag values during multi-threaded program analysis.",
      "description_length": 819,
      "index": 1262,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.WitnessUtil.YamlInvariantValidate",
      "library": "goblint.lib",
      "description": "This module validates invariants in YAML witness files by identifying loop heads, lock-adjacent nodes, and syntactic loop locations in control flow graphs. It provides boolean flags to control emission of specific node types and checks whether nodes meet criteria for invariants, such as being loop heads or following lock operations. Concrete use cases include filtering and verifying witness correctness during static analysis of C programs using Goblint.",
      "description_length": 457,
      "index": 1263,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Analyses.Spec-D",
      "library": "goblint.lib",
      "description": "This module provides lattice primitives and utility functions for abstract domain manipulation, including join, meet, widen, narrow, and extremal value checks (top/is_top), alongside equality, comparison, and JSON serialization. It operates on abstract domain values (type `D.t`) to support semantic reasoning through operations like `leq` and `pretty_diff`, which explains non-comparable states. These capabilities are applied in static analysis to approximate program semantics and solve dataflow constraints via abstract interpretation.",
      "description_length": 539,
      "index": 1264,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ResultQuery.Make",
      "library": "goblint.lib",
      "description": "This module evaluates constraint systems to compute variable values and analysis results at specific program points, supporting queries on both global and local variables. It integrates with the CFG module to enable control flow-aware analysis, allowing retrieval of path conditions, skipped statements, and source code mappings during traversal of CFG nodes and edges. Key data types include variables, constraint solutions, CFG nodes, and edges, with operations to query values, trace control flow, and reconstruct skipped AST statements. For example, it can determine the computed value of a variable at a given node or identify the sequence of skipped statements between two control flow points.",
      "description_length": 699,
      "index": 1265,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.MyARG.UnCilTernaryIntra",
      "library": "goblint.lib",
      "description": "Performs ternary analysis on control flow graphs to determine reachable nodes and edges. It provides `next` and `next_opt` functions that take a CFG node and return possible successor edges and nodes, handling intra-procedural control flow. This module is used for static analysis tasks such as path-sensitive data flow analysis and reachability tracking.",
      "description_length": 355,
      "index": 1266,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.PrecCompare.MakeHashtbl",
      "library": "goblint.lib",
      "description": "This module implements precision-aware comparison operations for hashtables with keys of type `K.t`, data of type `D.t`, and hash functions from `KH`. It provides a `compare` function that takes two hashtables and returns a precision comparison result along with a formatted explanation, enabling analysis of variable bindings in abstract interpretation. The child module extends this functionality by using `PrecCompare.compare` to track and compare precision levels of data conforming to `D.t`, particularly in static analysis domains. Together, they support precise comparison of analysis results, such as determining which abstract domain yields more accurate outcomes.",
      "description_length": 673,
      "index": 1267,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.WitnessUtil.NS",
      "library": "goblint.lib",
      "description": "This module provides set-like operations for managing collections of `Node.t` elements, supporting standard set operations (union, intersection, difference), transformations (`map`, `filter`), and membership queries (`mem`, `find`). It uses a custom `NS.t` data structure integrated with OCaml sequences for efficient traversal and conversion, suitable for scenarios like witness generation where precise set manipulations and safe element access (via `_opt` variants) are required. The structure also enables ordered iteration, subset checks, and sequence-based construction, making it ideal for tracking node relationships in program analysis tasks.",
      "description_length": 651,
      "index": 1268,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MCPRegistry.DomVariantLattice",
      "library": "goblint.lib",
      "description": "This module provides a variant-based lattice structure that supports standard operations like join, meet, widen, and narrow over values lifted from an underlying lattice (`DLSpec`), augmented with explicit `Bot` and `Top` elements. It includes utilities for comparison, serialization, and property-based testing, enabling dynamic combination of abstract domains in product analyses. The design facilitates abstract interpretation tasks where multiple analysis domains need to be composed or compared at runtime, such as in configurable static analysis frameworks.",
      "description_length": 563,
      "index": 1269,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.PrecCompareUtil.R-RH-Infix",
      "library": "goblint.lib",
      "description": "This module defines infix operators for interacting with a BatHashtbl, providing direct access to and modification of key-value bindings. It supports operations to retrieve a value by key (`-->`) and to add or update a binding (`<--`), working with any BatHashtbl instance. These operators simplify common hashtable manipulations such as lookups and inserts in a concise, readable syntax.",
      "description_length": 388,
      "index": 1270,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Analyses.GVarF",
      "library": "goblint.lib",
      "description": "This module defines a polymorphic sum type for representing either a value of type `V.t` or a CIL function declaration. It includes standard operations for equality, comparison, hashing, and pretty-printing, along with utilities to extract identifiers, check write-only status, and convert values to JSON or XML. It is used to model analysis contexts where variables and functions are treated uniformly, such as in dataflow analysis or constraint systems.",
      "description_length": 455,
      "index": 1271,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.PrecCompareUtil.LocalizedPrintable",
      "library": "goblint.lib",
      "description": "This module defines a printable data type where each value is associated with a specific code location. It provides operations for equality checking, hashing, comparison, string representation, and XML/YoJSON serialization, along with utilities for generating arbitrary values and extracting the related source location. It is used to track and compare precision information tied to program locations during static analysis.",
      "description_length": 424,
      "index": 1272,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.EscapeDomain",
      "library": "goblint.lib",
      "description": "This module defines a lattice structure for tracking thread-local variables that have escaped their original scope, using a sum type that represents either a concrete set of variables or a top element for all variables. It supports standard set operations like union, intersection, and filtering, along with functional transformations such as map and fold over sets of `Basetype.Variables.t`. This enables precise static analysis of concurrency-related escapes, such as detecting variables shared between threads or escaping to global state. For example, it can track which thread-local variables are accessed by multiple threads or modify analysis results to exclude escaped variables.",
      "description_length": 686,
      "index": 1273,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.SpecLifters",
      "library": "goblint.lib",
      "description": "This collection of modules provides path-sensitive static analysis capabilities by lifting abstract interpretation transfer functions over structured control flow, concurrency, and interprocedural behavior. Core data types include abstract domains (`D.t`), global state (`G.t`), constraints (`C.t`), and value analyses (`V.t`), with operations for join, meet, widen, narrow, and path-sensitive state propagation. The modules support tracking unreachable code, function call depth limits, hash-consed context management, and constraint variable handling, enabling precise analysis of variable assignments, concurrency, and function boundaries. Example uses include dead code elimination, witness generation, constraint solving, and context-sensitive dataflow tracking across loops, conditionals, and thread interactions.",
      "description_length": 819,
      "index": 1274,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ObserverAutomaton",
      "library": "goblint.lib",
      "description": "This module implements a finite automaton that processes sequences of program states or transitions to detect infeasible paths in abstract reachability graphs (ARGs), using both general state-based pattern matching and a specialized KMP-like algorithm. It supports operations such as transitioning between states based on input sequences, checking path feasibility via acceptance conditions, and matching paths against predefined infeasible patterns using equality checks on state arrays. Specific use cases include pruning invalid execution paths during static analysis by identifying when a path matches a known infeasible state sequence or exhibits a pattern detected by the KMP-based matcher. The module provides both a generic automaton interface and specialized variants for different pattern-matching strategies, enabling flexible integration into abstract interpretation frameworks.",
      "description_length": 890,
      "index": 1275,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Vla",
      "library": "goblint.lib",
      "description": "This module analyzes variable-length arrays in C code, tracking their initialization, memory usage, and scope across control flow and function calls. It operates on CIL expressions, lvalues, and variable declarations, maintaining VLA state within abstract analysis contexts. The interface supports interprocedural dataflow analysis, thread-aware context transitions, and precise memory modeling for dynamic array allocations. Example uses include detecting out-of-bounds accesses, ensuring proper initialization before use, and tracking array lifetimes across function boundaries.",
      "description_length": 580,
      "index": 1276,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.IntDomainProperties",
      "library": "goblint.lib",
      "description": "This module verifies correctness of integer domain implementations using QCheck properties, ensuring operations adhere to algebraic laws through property-based testing. It defines core abstractions like the abstract integer type `t` with bottom and top values, combined with `ikind` for typed integer kinds (e.g., `I32`, `I64`), supporting lattice operations (join, meet), arithmetic (addition, division), and bitwise manipulations (AND, shifts). Submodules enable precise static analysis via integer sets with union, intersection, and membership checks, and test suites that validate domain behavior across edge cases and abstract interpretations. Examples include verifying interval arithmetic, overflow handling, and soundness of abstract domains in program verification workflows.",
      "description_length": 784,
      "index": 1277,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ThreadEscape",
      "library": "goblint.lib",
      "description": "This module performs escape analysis for thread-local variables by tracking their reachability and escape events across function calls and concurrency primitives, using abstract domains and thread ID sets to model variable lifetimes. It integrates context initialization and state transformations to determine whether variables escape their scope, leveraging lattice operations for merging thread contexts and hierarchical analysis. The thread set submodule supports join, meet, and widening operations on thread ID sets, while the domain submodule defines the escape state lattice for static analysis. Examples include analyzing variable capture in closures, detecting escaping thread-local storage across threads, and optimizing memory usage by proving variables do not outlive their scope.",
      "description_length": 792,
      "index": 1278,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Callstring",
      "library": "goblint.lib",
      "description": "This module manages call string and call site analysis with customizable length limits, enabling context-sensitive static analysis through extensible call string types. It provides core data structures like `t` for call strings and associated operations for creation, comparison, serialization, and integration with analysis contexts. Submodules handle call site tracking, polymorphic call string manipulation, bounded k-CFA analysis, and abstract domain definitions, supporting tasks like data flow tracking, race detection, and call graph reconstruction. Example uses include generating unique identifiers for call sites, performing context-sensitive interprocedural analysis, and configuring precision in static verification tasks.",
      "description_length": 734,
      "index": 1279,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.ObserverAnalysis",
      "library": "goblint.lib",
      "description": "This module performs path-sensitive static analysis using observer automata to track program states through control flow graphs. It provides core data types such as path identifiers, constraint variables, and analysis contexts, along with operations for lattice manipulations, state transitions, and unique identifier generation. These mechanisms support precise data flow tracking, race condition detection, and witness generation across modular functors that tailor analysis to specific path contexts. Submodules refine this framework with automaton-based state tracking, inter-procedural effect handling, and structured output for verification workflows.",
      "description_length": 657,
      "index": 1280,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.VarEq",
      "library": "goblint.lib",
      "description": "This module analyzes symbolic expressions by tracking variable equalities and propagating contexts through abstract domains like `D.t` and `ES.t`, supporting static analysis tasks such as points-to analysis across control flow paths. It defines lattice operations (`join`, `meet`, `widen`, `narrow`) over structured types to manipulate abstract values and includes polymorphic set abstractions for refining equivalence relations via union, intersection, and subset checks. Users can model symbolic relationships, perform extremal value checks with `top` and `is_top`, and preserve variable equalities during state transitions. Example uses include tracking pointer equivalences in memory analysis and refining symbolic constraints during abstract interpretation.",
      "description_length": 762,
      "index": 1281,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MCPRegistry",
      "library": "goblint.lib",
      "description": "This module manages a dynamic registry of analysis components, enabling runtime configuration of abstract domains, lattices, and variable/path-sensitive features through integer-keyed lookups and list-based compositions. It supports operations for domain registration, retrieval, and serialization, along with lattice manipulations such as join, widen, and comparison, often pairing integer tags with polymorphic values or modules implementing signatures like `Printable.S` and `Lattice.S`. Submodules specialize in context tracking, domain association, and structured output, enabling use cases like configurable static analysis, witness generation, and dynamic domain composition with context- or path-sensitive semantics. Examples include retrieving a lattice by index, associating domains with printable modules, and serializing tagged abstract values for analysis debugging or result reporting.",
      "description_length": 899,
      "index": 1282,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ThreadJoins",
      "library": "goblint.lib",
      "description": "This module analyzes thread-joining behavior in concurrent programs by combining thread state domains with CIL expressions and analysis contexts to track synchronization, initialization, and return values across dynamically created threads. It provides lattice operations and comparisons over a product domain that pairs thread ID tracking with exit state analysis, supporting serialization, pretty-printing, and test generation. Specific capabilities include modeling inter-thread dependencies, verifying clean thread termination, and ensuring all spawned threads complete successfully before program exit.",
      "description_length": 607,
      "index": 1283,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.SymbLocks",
      "library": "goblint.lib",
      "description": "This module performs symbolic lockset analysis to detect data races in concurrent systems code, particularly for device drivers requiring fine-grained locking. It models per-element locking patterns using symbolic lock sets represented by type `t` and structured sets of locks (`PS.t`), supporting operations such as join, meet, union, and filtering to track lock acquisition and release across memory offsets. Lattice semantics and set-theoretic manipulations enable precise, context-aware static analysis for verifying correct locking discipline and identifying race conditions. Example uses include analyzing concurrent device driver code to ensure proper synchronization at the field or index level.",
      "description_length": 703,
      "index": 1284,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MemLeak",
      "library": "goblint.lib",
      "description": "This module enables memory leak detection in C programs by analyzing variable usage and memory states through abstract interpretation. It provides core data types for representing program variables (`Varinfo`) and lattice structures to model memory states across different execution paths. Operations include set manipulations (union, intersection, membership) and lattice functions (join, meet, widen) to track dynamic memory allocations and detect leaks. Examples include identifying unreleased memory blocks after function returns or tracking variable ownership changes across control flow branches.",
      "description_length": 602,
      "index": 1285,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.PoisonVariables",
      "library": "goblint.lib",
      "description": "This module tracks variables that become tainted due to modifications between `setjmp` and `longjmp` calls, using a set-based representation (`VS.t`) to capture poisoned states. It provides operations to update, query, and sanitize tainted variables, integrating with analysis contexts and abstract domains to handle CIL expressions, assignments, and function scopes. The child module adds lattice and set-theoretic operations\u2014such as join, meet, union, and difference\u2014enabling precise propagation of tainted variable sets across non-local control flow. This supports detection of unsafe accesses to indeterminate values in C programs using `longjmp`.",
      "description_length": 651,
      "index": 1286,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MHP",
      "library": "goblint.lib",
      "description": "This module defines a may-happen-in-parallel (MHP) analysis domain for concurrency analysis. It tracks thread identifiers, created threads, and threads that must have been joined, enabling precise reasoning about parallel execution. Key operations include checking if two program points may execute in parallel, determining if a thread is guaranteed to have completed, and comparing or hashing MHP states for analysis purposes.",
      "description_length": 427,
      "index": 1287,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Constraints",
      "library": "goblint.lib",
      "description": "This module builds and transforms constraint systems from analysis specifications and control flow graphs, supporting operations on abstract syntax trees, constraint variables, and solver-ready representations. It enables the instantiation of constraint systems for specific static analyses and applies functors to modify analysis behavior during construction. The first child module supports incremental constraint solving by efficiently updating constraint data in response to program changes, while the second constructs constraint systems from specifications and CFGs, manipulating logical variables and domains. Examples include generating solver-ready constraints from CFGs and incrementally updating analysis results after code modifications.",
      "description_length": 749,
      "index": 1288,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.PrivPrecCompareUtil",
      "library": "goblint.lib",
      "description": "This module implements precision comparison operations for abstract domains, handling marshaling and unmarshaling of domain states using types like `marshal`, `dump`, and `result`. It supports analysis and comparison of abstract interpretation precision during static analysis, with utilities for comparing, hashing, and displaying location-variable pairs via submodules. The child modules enable structured value relationships through lattice operations, serialization, and arbitrary value generation, facilitating tasks like resource tracking, error propagation, and CIL-based variable analysis. Specific use cases include comparing base type variables in Goblint's analysis framework and managing domain precision with imperative and functional transformations.",
      "description_length": 764,
      "index": 1289,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.UnassumeAnalysis",
      "library": "goblint.lib",
      "description": "This module tracks and processes unassume events derived from YAML witness invariants during static analysis of C code, associating runtime assumptions with function contexts and CIL expressions. It provides imperative hash tables mapping function definitions and expressions to arbitrary values, supporting efficient lookups, in-place modifications, and bulk transformations. Operations include symbolic state tracking with `D.t`, invariant positioning with `Locator.t`, and structured event management using ordered maps and sets. You can use it to dynamically enforce function-specific invariants, generate unassume events from YAML witnesses, or map analysis events to source locations for verification.",
      "description_length": 707,
      "index": 1290,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.AbortUnless",
      "library": "goblint.lib",
      "description": "This module analyzes functions that conditionally abort execution, like `abortUnless`, by modeling control flow and state transformations. It operates on abstract analysis contexts, C expressions, function definitions, and lvalues, tracking program behavior through abstract states. This enables static analysis of safety-critical C code to verify conditions under which functions return or terminate. For example, it can determine if a function continues execution only when a specific non-zero value is passed, aiding in program verification.",
      "description_length": 544,
      "index": 1291,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ResultQuery",
      "library": "goblint.lib",
      "description": "This module enables querying and transforming constraint system solutions using combinators, handlers, and hash table operations over abstract analysis states. It supports data types like constraint graphs, analysis domains (`D`, `G`, `C`, `V`), hash tables (`GHT`, `LHT`, `BatHashtbl`), and control flow structures (`Node`, `MyCFG`), with operations including joins, meets, variable lookups, constraint checks, and path-aware queries. You can extract variable values at specific program points, analyze global and local solution states, perform interprocedural analysis over CFGs, and manipulate constraint systems with typed, exception-safe hash table updates. Submodules enhance this functionality with infix syntax, labeled operations, and lattice-theoretic combinators for merging and refining analysis results.",
      "description_length": 816,
      "index": 1292,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Violation",
      "library": "goblint.lib",
      "description": "This module checks violations in an abstract reachability graph (ARG) by identifying sink nodes and finding paths to them, using node and edge definitions from the `Node` and `Edge` modules. It determines path feasibility through integration with the `Feasibility` module, returning whether a path is feasible, infeasible with a counterexample, or unknown. Main data types include `Node.t` for representing nodes with control flow, context, and path identifiers, and path-based structures for tracking sequences of nodes and edges. Specific operations include comparing and hashing nodes, extracting control flow information, checking path feasibility, and propagating violations through the graph to detect unreachable code or invalid state transitions.",
      "description_length": 754,
      "index": 1293,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MutexEventsAnalysis",
      "library": "goblint.lib",
      "description": "This module analyzes mutex events in concurrent C programs by modeling lock and unlock actions through static analysis of function calls, thread operations, and variable assignments. It defines core data types such as mutex events, constraint variables, and path representatives, supporting operations like race detection, witness generation, and constraint propagation. Abstract interpretation of mutex states is enabled through lattice and domain modules, allowing join, meet, widen, and narrow operations to detect synchronization errors. Examples include tracking lock acquisition order, identifying deadlocks, and verifying proper mutex usage across threads.",
      "description_length": 663,
      "index": 1294,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.SymbLocksDomain",
      "library": "goblint.lib",
      "description": "This module analyzes concurrent programs by tracking symbolic locksets through abstract domains, using data types like `S.t` and `CilType.Exp.t` to represent and manipulate symbolic expressions for locks. It supports operations such as join, meet, widen, and leq for merging and comparing lock states, along with utilities for serialization, simplification, and index-based tracking. The domain enables precise reasoning about concurrency issues like deadlocks and race conditions, with applications in static analysis for verifying thread synchronization and lock usage patterns. Example tasks include comparing lock indices to resolve contention and converting symbolic expressions into lock states for analysis.",
      "description_length": 714,
      "index": 1295,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.LockDomain",
      "library": "goblint.lib",
      "description": "This module family models lockset domains for static analysis of concurrent programs, focusing on tracking must-locked dependencies with read/write permissions. Core data types include lifted sets of lock identifiers (`MustLock`, `MustLockRW`), address-permission pairs, and lattice-based structures supporting operations like join, meet, widening, and set manipulations. These modules enable precise analysis of synchronization constraints, such as tracking required lock acquisitions, modeling access permissions on shared memory, and verifying correct lock usage across threads. Examples include detecting race conditions via lockset comparisons, enforcing must-lock requirements for memory accesses, and analyzing lock dependencies with multiplicity tracking.",
      "description_length": 763,
      "index": 1296,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.EvalAssert",
      "library": "goblint.lib",
      "description": "This module instruments programs by inserting assert statements to validate computed invariants at critical control flow points. It targets top-level local variables, inserting assertions either after assignments or at join points, with optional focus on regions protected by mutex locks. The transformation operates on CIL representations, enabling checks on variable ranges or state consistency during execution. For example, it can assert that a variable remains within a valid range after an assignment or that shared state remains consistent across thread synchronization points.",
      "description_length": 584,
      "index": 1297,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Malloc_null",
      "library": "goblint.lib",
      "description": "This module analyzes C programs to detect null dereferences and unreachable code paths resulting from failed memory allocations, using path-sensitive static analysis. It models memory states with abstract domains (`D.t`) and tracks null pointers across control flow using lattice operations like `join`, `widen`, and `narrow`. The analysis operates on CIL expressions and function definitions within an analysis context (`ctx`), enabling verification of error handling after allocation failures and ensuring pointers are valid before dereference. For example, it can confirm that a function properly checks a returned pointer from `malloc` before use or identifies code that becomes unreachable due to null pointer constraints.",
      "description_length": 727,
      "index": 1298,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.CilCfg",
      "library": "goblint.lib",
      "description": "This module constructs and analyzes control flow graphs (CFGs) for CIL-processed programs. It provides functions to create CFGs, identify end basic blocks, and count loops within the CFG. Concrete use cases include analyzing program structure for static analysis tools and optimizing code transformations based on CFG properties.",
      "description_length": 329,
      "index": 1299,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Timeout",
      "library": "goblint.lib",
      "description": "This module enables time-constrained execution of functions through its `wrap` function, which takes a callable, an input, and a timeout duration, and triggers a callback if the operation exceeds the specified time. It supports use cases such as limiting file parsing or network request durations, and integrates signal-based interruption via submodules to handle long-running computations in system-level contexts. A second child module adapts this behavior for JavaScript environments, enforcing timeouts on function calls to prevent blocking in browser-based applications. Together, these components provide a robust interface for managing execution time across diverse runtime environments.",
      "description_length": 694,
      "index": 1300,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.YamlWitnessType",
      "library": "goblint.lib",
      "description": "This module family represents and processes YAML-encoded witness data for static analysis, supporting structured serialization and validation of invariants, locations, tasks, and metadata. Key data types include records for invariants, location-invariant pairs, loop certificates, violation sequences, and metadata such as task info, producer details, and source locations. Operations span YAML conversion, comparison, and type-specific parsing, enabling use cases like validating analysis results, tracking control flow violations, and storing structured witness files. Examples include deserializing loop invariants with preconditions, comparing location-bound invariants, and modeling violation paths with structured waypoints and constraints.",
      "description_length": 746,
      "index": 1301,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.BasePriv",
      "library": "goblint.lib",
      "description": "This module implements non-relational thread-modular value analyses for tracking base values with thread-local private state, enabling abstract interpretation of concurrent programs through operations to get, set, and merge thread-specific state. It defines core data types such as abstract values `V.t`, analysis state type `t`, and lattice type `D.t`, supporting operations like `tag`, `relift`, and lattice join/meet for tracking invariants and detecting data races. Submodules provide structural manipulations and lattice operations for abstract domains, thread-modular interpretation primitives for concurrency, and utilities for value analysis with context sensitivity. Example uses include computing thread-local invariants, analyzing shared variable access, and enforcing memory safety through abstract state merging.",
      "description_length": 825,
      "index": 1302,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.RecursionTermLifter",
      "library": "goblint.lib",
      "description": "This module enables context-sensitive recursion analysis by integrating abstract domains, control flow graphs, and dynamic call graphs to detect cycles and analyze termination in recursive and concurrent code. It provides key data types such as `D.t` for abstract values, `G.t`, `C.t`, and `V.t` for tracking context and state, along with operations like `combine_assign` and `threadenter` to manage state transitions and synchronization. It supports precise analysis through submodules that handle path identification, lattice operations, and structured representations of call graph nodes. Example applications include detecting infinite recursion and proving termination by analyzing repeated context patterns across dynamic call paths.",
      "description_length": 739,
      "index": 1303,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ThreadId",
      "library": "goblint.lib",
      "description": "This module tracks and retrieves the current thread ID during analysis using `get_current` and `get_current_unlift`, which return lifted and unlifted thread identifiers from the `ThreadLifted` and `Thread` modules. It supports distinguishing between threads in concurrent programs and tracking thread-specific state through abstract interpretation, using data types like `t` and `ThreadLifted.t option` with operations such as join, meet, and leq. Submodules handle comparison, hashing, and display of thread IDs, enabling tracking of unique thread instances and creation sites, while lattice-based analysis models thread creation, synchronization, and state transitions across control flow. Examples include resolving thread identity in function calls, tracking interference in variable assignments, and serializing results to XML or Yojson for diagnostics.",
      "description_length": 858,
      "index": 1304,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.BaseUtil",
      "library": "goblint.lib",
      "description": "This module provides functions to check variable properties in CIL code during analysis, such as whether a variable is global, static, volatile, or excluded from specific analysis steps. It operates on `GoblintCil.varinfo` structures and uses analysis context from `Goblint_lib.Queries.ask`. These checks are used to guide analysis decisions, such as tracking or invalidation, based on variable attributes.",
      "description_length": 406,
      "index": 1305,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.AutoTune",
      "library": "goblint.lib",
      "description": "This module analyzes CIL code to dynamically adjust analysis configurations by examining function call graphs and syntactic patterns, using sets and maps to track relationships between functions, variables, and expressions. It enables autotuning through complexity estimation, score-driven configuration selection, and lazy state management, supporting optimizations like termination checking and domain selection. Submodules provide function and variable maps for associative data management, and variable sets for dependency analysis and filtering, all integrating with sequences for scalable processing. Examples include tuning analysis precision based on function call frequency or adjusting concurrency safety checks according to variable usage patterns.",
      "description_length": 759,
      "index": 1306,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.ExpressionEvaluation",
      "library": "goblint.lib",
      "description": "This module evaluates expressions on analysis results using CIL-based code structures and JSON-encoded queries, enabling the extraction of concrete values at specific program points. It supports querying with syntactic code patterns and integrates with static analysis transformations to generate evaluation results for visualization tools like Gobview. The core functionality operates on CIL ASTs and analysis data, while the child module specializes in transforming CIL files based on expression queries during analysis. Examples include extracting variable values, control flow properties, or custom code features for visualization or further processing.",
      "description_length": 657,
      "index": 1307,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MutexTypeAnalysis",
      "library": "goblint.lib",
      "description": "This module analyzes mutex types during static analysis, determining whether a mutex must be recursive by tracking constraints across threads and function calls. It models mutex behavior using abstract states, global environments, and control contexts, incorporating lattice operations for merging state information. The analysis detects type mismatches, resolves global type conflicts, and generates witnesses for concurrency violations. Specific capabilities include enforcing correct lock acquisition patterns and solving path-dependent type constraints for mutex variables.",
      "description_length": 577,
      "index": 1308,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "Goblint_lib.BaseInvariant",
      "library": "goblint.lib",
      "description": "This module orchestrates branch refinement in Base analysis by evaluating and strengthening invariants through abstract value manipulation and condition analysis. It integrates expression evaluation, lattice operations, and value refinement to improve control-flow precision, supporting tasks like variable range narrowing and path feasibility checks. Key data types include abstract values (`D.t`, `VD.t`, `G.t`) and CIL constructs, with operations for comparison, join/meet, expression evaluation, and invariant application. Specific capabilities include refining boolean conditions in `if` statements, tracking variable bounds, and stabilizing fixpoints using widening and narrowing during abstract interpretation.",
      "description_length": 717,
      "index": 1309,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Svcomp",
      "library": "goblint.lib",
      "description": "This module orchestrates SV-COMP task handling by integrating task configuration, control flow analysis, and result reporting. It classifies functions, checks error conditions, and manages task-specific outcomes with context-aware error raising. Key data types include task results, CFG nodes and edges, and verification outcomes, manipulated through operations for traversal, conversion, and analysis. You can load and parse SV-COMP benchmarks, track program points and their transitions, extract invariants and violations, and format results for reporting or further processing.",
      "description_length": 580,
      "index": 1310,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ArgTools",
      "library": "goblint.lib",
      "description": "This module constructs and manipulates abstract reachability graphs (ARGs) from constraint system solutions, defining bidirectional argument structures and node styles to represent program states and transitions. It supports operations such as building symbolic execution trees, encoding analysis results into structured graphs, and customizing node appearance based on properties using string lists for visualization. The module handles node identity with efficient equality, hashing, and comparison operations, enabling tracking of unique nodes across multiple execution paths in abstract interpretation contexts. It also generates DOT representations for visual debugging, enables bidirectional graph traversal for control flow and data dependency analysis, and integrates with submodules to support tasks like invariant generation, bug detection, and path analysis through structured graph transformations.",
      "description_length": 910,
      "index": 1311,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.MyARG",
      "library": "goblint.lib",
      "description": "This module manages abstract reachability graphs for static analysis, combining graph traversal, node and edge manipulation, and path exploration. It defines core data types such as nodes with context and path identifiers, and edges derived from control flow transitions, supporting operations like successor retrieval, path filtering, and string representation. Submodules handle specialized tasks including intra-procedural traversal, inline call modeling, stack-based navigation, and edge embedding from CFG structures. Examples include tracking execution paths through function calls, filtering relevant nodes during traversal, and optimizing reachability queries using cached transitions.",
      "description_length": 693,
      "index": 1312,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Graphml",
      "library": "goblint.lib",
      "description": "This module streams GraphML output incrementally, serializing nodes and edges into XML elements during traversal. It supports writing graphs with labeled nodes and edges, attaching metadata, and defining keys for attributes, enabling efficient generation of large GraphML files for visualization or analysis. Submodules handle deduplication of attributes, structured graph construction, and customizable node/edge enumeration, allowing use cases like exporting control flow graphs or dependency graphs with semantic attributes. It operates on string-based identifiers and streams output directly to a channel, avoiding the need to load the full graph in memory.",
      "description_length": 661,
      "index": 1313,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ApronDomain",
      "library": "goblint.lib",
      "description": "This module implements abstract domains for numerical analysis using the Apron library, providing operations for creating, combining, and querying abstract values such as intervals, octagons, and polyhedra. It works with data structures representing numerical constraints over program variables, supporting operations like meet, join, widening, and assignment. Concrete use cases include tracking variable ranges and relationships in static analysis to prove safety properties or detect overflows.",
      "description_length": 497,
      "index": 1314,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ContextGasLifter",
      "library": "goblint.lib",
      "description": "This module provides a function `get_gas_lifter` that returns a spec transformer controlling context-sensitive analysis depth via a gas counter. It operates on analysis specifications, reducing the gas value at each function call and switching to context-insensitive analysis when gas is exhausted. It is used to limit the precision of context-sensitive analyses to manage performance and scalability in static analysis.",
      "description_length": 420,
      "index": 1315,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.TmpSpecial",
      "library": "goblint.lib",
      "description": "This module analyzes variable relationships with math library function results, tracking equivalences through abstract interpretation. It manages dataflow states and dependencies, allowing precise propagation and invalidation of variable-value associations when expressions change. Key operations include merging states, transforming values across control-flow, and maintaining equivalence sets with lattice structures. For example, it can track how a variable's value relates to a math function's argument or determine when an assignment breaks an equivalence.",
      "description_length": 561,
      "index": 1316,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Control",
      "library": "goblint.lib",
      "description": "This module implements the core analysis loop for abstract interpretation-based program analysis, handling constraint solving and state management across control flow graphs. It provides data types like labeled variables, constraint systems, and state mappings, with operations for merging, comparison, and imperative updates to support fixed-point computations using widening and narrowing. You can perform interprocedural dataflow analysis, detect dead code, track variables across CFG nodes, and extract JSON representations of analysis states for debugging. The module integrates with constraint solvers and state management components to enable both forward and backward analyses over program-wide control flow.",
      "description_length": 716,
      "index": 1317,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.MallocFresh",
      "library": "goblint.lib",
      "description": "This module analyzes unescaped, thread-local heap allocations in C programs through abstract interpretation, tracking allocation freshness across control flow and function boundaries. It uses lattice structures to represent allocation states, set operations to track variables, and boolean tags to capture freshness properties, enabling precise modeling of heap behavior. The analysis merges abstract states at control-flow joins and identifies thread-local allocations by their syntactic and semantic context. Example uses include determining if a malloc site remains thread-local through all paths, merging heap states after conditionals, and extracting diagnostic information about allocation lifetimes.",
      "description_length": 706,
      "index": 1318,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ActiveLongjmp",
      "library": "goblint.lib",
      "description": "This module analyzes control flow and state transitions in CIL code, particularly around non-local jumps like setjmp and longjmp. It provides data types for abstract domains, analysis contexts, and inter-procedural state tracking, enabling precise propagation of control and data flow across function calls and threads. Operations include identifying active longjmp targets, managing context-sensitive state, and handling domain transitions during analysis. Example uses include static analysis of error handling in C programs and improving precision in abstract interpretation frameworks dealing with asynchronous control flow.",
      "description_length": 628,
      "index": 1319,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.AbstractionDomainProperties",
      "library": "goblint.lib",
      "description": "This module defines QCheck properties to verify correctness of abstract operations in static analysis, ensuring soundness and precision across lattice and transfer functions. It supports testing equality, approximation, and ordering between concrete and abstract values, using arbitrary generators to validate domain operations under various conditions. Main data types include concrete and abstract domain values with functions like `check_leq` and `abstract`, enabling tests for equivalence, monotonicity, and correctness of transformations. Examples include generating test cases for abstract interpretation soundness and validating that abstract functions preserve ordering.",
      "description_length": 678,
      "index": 1320,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.CondVars",
      "library": "goblint.lib",
      "description": "This module analyzes logical equalities between symbolic variables and expressions in concurrent programs, using maps to associate symbolic keys with abstract values that represent taint and constraint relationships. It supports operations such as meet and join over lattices, filtering by expressions, and tracking variable equivalences across threads and control paths. You can use it to resolve indirect pointer targets, verify shared variable dependencies, or simplify logical invariants during static analysis of concurrent C code. Specific examples include propagating constraints through control flow branches and merging variable states across thread interactions.",
      "description_length": 672,
      "index": 1321,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Maingoblint",
      "library": "goblint.lib",
      "description": "This module orchestrates static analysis workflows by parsing command-line arguments, preprocessing source files with GCC, and managing CIL AST transformations through merging and incremental updates. It handles core data structures like CIL ASTs, analysis results, and incremental state files to support tasks such as differential analysis between code versions or generating HTML visualization reports. Key use cases include end-to-end analysis execution, preprocessing pipeline coordination, and post-processing tasks like result diffing or Gobview visualization.",
      "description_length": 566,
      "index": 1322,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.BaseDomain",
      "library": "goblint.lib",
      "description": "This module provides a lattice-based abstract domain for static analysis, supporting core operations like join, meet, widen, and narrow over composite values, with polymorphic data structures enabling comparison, hashing, and detection of top/bottom elements. It combines with child modules to model program states through control point analysis, variable mappings, dependency tracking, and weak update handling, enabling context-sensitive analysis and precise propagation of variable values and constraints. Functionality includes evaluating integer expressions, managing hierarchical variable dependencies, and performing set-based operations for tracking variables requiring weak updates. Examples include constant propagation, interval analysis, taint tracking, and merging abstract states across control points using customizable strategies.",
      "description_length": 846,
      "index": 1323,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.AffineEqualityDomain",
      "library": "goblint.lib",
      "description": "Implements abstract domain operations for tracking affine equalities among variables, such as `x = y + c`. Works with variable identifiers and integer constants to represent and manipulate equivalence classes under affine transformations. Useful for optimizing compiler analyses that require precise reasoning about linear relationships between variables.",
      "description_length": 355,
      "index": 1324,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.SarifRules",
      "library": "goblint.lib",
      "description": "This module defines and provides access to SARIF rule metadata used for static analysis reporting in Goblint. It includes structured data such as rule IDs, descriptions, and documentation URIs. The primary operations retrieve specific rule details by ID or list all available rules, supporting precise error categorization and reporting.",
      "description_length": 337,
      "index": 1325,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.DomainProperties",
      "library": "goblint.lib",
      "description": "This module provides QCheck-based property testing for lattice structures, ensuring correctness of core operations such as `join`, `meet`, `leq`, `bot`, `top`, `widen`, and `narrow`. It includes utilities for defining and validating lattice laws using arbitrary domain elements, with support for custom equality checks and configurable test parameters. Submodules focus on specific lattice properties, including connectivity, associativity, commutativity, idempotence, and behavior of extremal elements, enabling comprehensive testing of domain implementations used in static analysis. Examples include verifying that `join` satisfies absorption with `meet`, ensuring `widen` progresses correctly toward a fixed point, and confirming that `bottom` is the least element under `leq`.",
      "description_length": 781,
      "index": 1326,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.PthreadSignals",
      "library": "goblint.lib",
      "description": "This module analyzes signal propagation and synchronization behavior in concurrent C programs using abstract domains for dataflow, global, and control states. It tracks interactions involving Pthread condition variables through lattice operations, context-sensitive path representations, and abstract values for thread signals. The analysis resolves synchronization dependencies, maintains precision during context switches, and detects race conditions. Example uses include verifying correct signal handling in thread pools and identifying missed wakeups or spurious wakeups in condition variable usage.",
      "description_length": 604,
      "index": 1327,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.MusteqDomain",
      "library": "goblint.lib",
      "description": "This module implements a symbolic analysis domain for tracking must-equality constraints between memory locations and values, using precise offset-aware lvalue identifiers. It supports key operations such as equality checking, lattice combination of constraint sets, and expression evaluation over symbolic values, structured as pairs and maps. Concrete uses include verifying memory access consistency, propagating equalities across control-flow points, and optimizing variable substitutions in data structure analysis. Examples include checking collapsibility of nested field accesses, comparing symbolic memory locations for equality, and joining constraint sets to infer shared equalities across branches.",
      "description_length": 709,
      "index": 1328,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.AnalysisResult",
      "library": "goblint.lib",
      "description": "This module organizes analysis results with structured data types and transformations, enabling creation, manipulation, and serialization of result nodes, configurations, and control flow graph elements. It supports key operations like comparison, hashing, pretty-printing, and JSON conversion, with data structures such as result nodes, nested maps, and hash tables for efficient querying and merging. Examples include generating JSON reports with custom formatting, tracking CFG nodes for witness generation, and refining analysis data at specific program points using hash table operations. Submodules extend functionality for output configuration, result identity, node representation, and table-based storage with functional and imperative interfaces.",
      "description_length": 756,
      "index": 1329,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.UnitAnalysis",
      "library": "goblint.lib",
      "description": "This module performs static analysis using a unit domain, tracking abstract states through program execution to analyze control flow, function calls, and concurrency. It defines operations on abstract values of type `D.t` and manipulates them in response to assignments, conditionals, loops, and thread events using CIL constructs like expressions, lvalues, and function definitions. Context-sensitive analysis is supported via transitions that capture calling contexts and synchronization points. For example, it can determine reachability of program points or detect potential concurrency issues by propagating unit domain effects across function and thread boundaries.",
      "description_length": 671,
      "index": 1330,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Base",
      "library": "goblint.lib",
      "description": "This module implements non-relational value analysis for tracking scalar values and properties across program points, using abstract interpretation with transfer functions and lattice operations. It defines core data types like abstract values (`t`), constraint variables, and domains (`D`, `G`, `C`, `V`, `P`, `A`) for static analysis, supporting operations such as join, meet, widen, and transfer functions for assignments, control flow, and concurrency. You can perform constant propagation, sign analysis, interval tracking, and path-sensitive constraint management, with support for pretty-printing, serialization, and arbitrary value generation for testing. Submodules refine analysis precision through lattice hierarchies, context-sensitive comparisons, and memory state transformations, enabling structured output and efficient value tracking across imperative and concurrent code.",
      "description_length": 889,
      "index": 1331,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.CommonPriv",
      "library": "goblint.lib",
      "description": "This module coordinates thread-modular value analysis through abstract domains for locks, variables, and thread states, enabling precise tracking of concurrency-related data flows and synchronization constraints. It supports operations like lockset computation, must/may variable analysis, and atomic block handling, with core data types including locksets, variable sets, and digest-based state identifiers. Child modules refine this foundation with domain-specific capabilities: tracking mutex-protected variables, enforcing atomicity, managing thread-local states, and modeling lock dependencies. Examples include determining which variables are protected by a given lock, merging thread states during analysis joins, and controlling atomic section processing in SV-COMP benchmarks.",
      "description_length": 785,
      "index": 1332,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.LoopUnrolling",
      "library": "goblint.lib",
      "description": "This module provides syntactic loop unrolling for CIL functions, allowing loops to be expanded a specified number of times. It operates on CIL function definitions and statements, transforming their structure directly. Use cases include optimizing performance-critical code sections or enabling further analysis by reducing loop complexity.",
      "description_length": 340,
      "index": 1333,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.ThreadAnalysis",
      "library": "goblint.lib",
      "description": "This module analyzes thread creation and uniqueness properties in concurrent programs through abstract interpretation. It centers on thread identifiers (TIDs), abstract domains (`D.t`), and CIL-based program constructs, offering operations for branching, calling, assignment, and thread lifecycle tracking. It supports precise reasoning about race conditions, thread-local state, and inter-thread data flow by combining lattice structures, TID analysis, and domain-specific comparisons. Example uses include detecting write-only variables across threads and modeling concurrent execution paths during static analysis.",
      "description_length": 617,
      "index": 1334,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.TerminationPreprocessing",
      "library": "goblint.lib",
      "description": "This module transforms control-flow structures in C programs to enable termination analysis by rewriting loops and conditionals with counters and state variables, ensuring proper unwinding through modified function returns. It works with a submodule that maps C variables to generic values, supporting ordered operations like insertion, lookup, and traversal to track variable dependencies and their associated statements. Together, they enable structured analysis of termination conditions by maintaining state and facilitating efficient querying of variable-related data. Example use cases include tracking iteration bounds, transforming recursive calls into bounded loops, and analyzing conditional exits in transformed control graphs.",
      "description_length": 738,
      "index": 1335,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ReturnUtil",
      "library": "goblint.lib",
      "description": "This module manages special variables representing function return values and longjmp returns in the analysis. It provides access to the return variable's varinfo, AD.t, and lval representations, which are used to track and manipulate return values during static analysis. Concrete use cases include handling function exits, modeling return value propagation, and supporting analyses that depend on return state tracking.",
      "description_length": 421,
      "index": 1336,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.PtranalAnalysis",
      "library": "goblint.lib",
      "description": "This module performs pointer analysis on CIL constructs, focusing on interprocedural evaluation of function pointers and handling control flow, memory effects, and function calls. It operates on expressions, lvalues, function definitions, and analysis contexts, while managing abstract state transitions and thread interactions. Key data types include analysis states and contexts, with operations for state manipulation, function pointer resolution, and synchronization across function boundaries. Example uses include tracking function pointer assignments, analyzing call sites with indirect calls, and modeling thread creation with state propagation.",
      "description_length": 653,
      "index": 1337,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.SarifType",
      "library": "goblint.lib",
      "description": "This module provides a comprehensive set of data structures and serialization functions for working with the SARIF format, enabling the representation and conversion of static analysis results into structured JSON output. Key data types include reporting descriptors, artifact locations, tool components, run metadata, analysis results, and source code regions, all of which can be serialized to JSON using Yojson. Operations allow for constructing and manipulating SARIF objects such as tool runs with associated source files, analysis messages, and precise code locations. For example, it supports generating a SARIF-compliant report with tool metadata, source file references, and analysis findings mapped to specific code regions.",
      "description_length": 734,
      "index": 1338,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Signs",
      "library": "goblint.lib",
      "description": "This module performs intraprocedural integer sign analysis using a three-state abstraction (negative, zero, positive) to track and reason about the possible signs of integer expressions. It provides lattice operations such as join, meet, widen, and narrow to combine and refine sign states, along with constraint variables for context-sensitive analysis and domain relifting. The analysis supports detecting invalid arithmetic, refining control-flow paths, and exporting results in formats like JSON or XML. Examples include determining that a variable is always non-negative in a loop or identifying potential overflow from mixed-sign arithmetic.",
      "description_length": 647,
      "index": 1339,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.WitnessConstraints",
      "library": "goblint.lib",
      "description": "This module enables path-sensitive static analysis by defining transfer functions for control flow and variable state transitions across abstract domains. It introduces core data types such as constraint variables, path representatives, and lattice elements, supporting operations like join, widen, and comparison for abstract value manipulation. Unique tagging and serialization facilitate witness generation and constraint tracking across paths. Example uses include modeling program semantics under varying execution paths, constructing abstract reachability graphs, and exporting abstract states in XML or JSON for verification and bug detection.",
      "description_length": 650,
      "index": 1340,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.LinearTwoVarEqualityDomain",
      "library": "goblint.lib",
      "description": "Implements a domain for tracking equalities between pairs of variables in a linear form. Supports operations to add, query, and simplify constraints involving two variables. Useful for static analysis passes that require precise handling of linear relationships between program variables.",
      "description_length": 288,
      "index": 1341,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.GoblintDir",
      "library": "goblint.lib",
      "description": "Provides functions to manage an intermediate data directory structure. It initializes and finalizes the directory setup, and gives access to root and preprocessed data paths. Useful for organizing temporary or processed data during analysis workflows.",
      "description_length": 251,
      "index": 1342,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.SvcompSpec",
      "library": "goblint.lib",
      "description": "This module parses and represents SV-COMP specification strings and files into structured types, supporting direct conversion between string formats and typed values. It handles individual specifications like `UnreachCall`, `NoDataRace`, and `Termination`, as well as multi-specification lists. Use it to load and process SV-COMP properties from files or command-line options, or to generate string representations of checked properties for output.",
      "description_length": 448,
      "index": 1343,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.DeadlockDomain",
      "library": "goblint.lib",
      "description": "This module analyzes deadlock potential in concurrent programs by abstracting lock events as a lattice-based set structure, enabling operations like union, intersection, and comparison to model and merge abstract program states. It centers on two core types: a set-like structure for tracking possible lock events and a detailed event type capturing lock actions, control flow positions, and memory access data. Users can perform static analysis to detect deadlocks by approximating lock acquisition patterns across execution paths, using fixed-point computations with widening and narrowing. Example usage includes merging sets of lock events from different code branches to determine potential deadlock scenarios or comparing event sets to identify conflicting lock orders.",
      "description_length": 775,
      "index": 1344,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Witness",
      "library": "goblint.lib",
      "description": "This module generates GraphML output for verification tasks by processing abstract reachability graphs and structured result types. It defines nodes and edges based on control flow and analysis data, supports node comparison through hashing and structural inspection, and assembles witness files with metadata, constraints, and path information. Operations include retrieving invariants, querying node properties, traversing graph paths, and mapping analysis outcomes to program points. Use cases include exporting verification results for external validation, visualizing reachability paths, and formatting output for competition submissions.",
      "description_length": 643,
      "index": 1345,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.AccessDomain",
      "library": "goblint.lib",
      "description": "This domain models memory access events using a lattice-structured set type over `Event.t`, enabling analysis through union, intersection, difference, and lattice operations like widen and narrow. The event type captures variable, offset, and access kind details, supporting comparison, hashing, and structured serialization. It facilitates tracking and merging access patterns, querying specific accesses, and computing fixed points in static analysis. Example uses include logging access traces, analyzing memory behavior across paths, and integrating with external tools via JSON/Yojson output.",
      "description_length": 597,
      "index": 1346,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.WideningTokenLifter",
      "library": "goblint.lib",
      "description": "This module coordinates widening tokens to control convergence in abstract interpretation by associating them with abstract elements and deferring widening until token sets stabilize. It supports operations to add tokens to local or global states and execute functions with token-aware side effects, enabling precise fixpoint computations in static analysis. The core widening token set type provides lattice and set operations like union, intersection, and subset checks, with a top element for unbounded states, ensuring controlled convergence while preserving precision. Submodules extend abstract domains with token-aware product structures, interprocedural tracking, and constraint handling, supporting tasks like path-sensitive analysis and context-sensitive widening delays through operations on tagged values, projections, and serializable token states.",
      "description_length": 861,
      "index": 1347,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ThreadFlagDomain",
      "library": "goblint.lib",
      "description": "This module implements abstract domains for tracking thread-related flags in concurrent programs, combining lattice operations with thread state management to analyze multi-threaded behavior. It provides data types like `t` to represent hierarchical thread contexts\u2014single-threaded, multi-threaded, main-thread\u2014and supports operations such as join, meet, and comparison for state manipulation and query. Submodules extend this with specialized functionality for main thread identification, state serialization, and precise thread interaction tracking during static analysis. Examples include detecting race conditions, verifying synchronization, and modeling thread transitions in C program analysis.",
      "description_length": 700,
      "index": 1348,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.AccessAnalysis",
      "library": "goblint.lib",
      "description": "This module analyzes memory accesses in concurrent programs by modeling state changes through abstract interpretation. It uses data types like `D.t` and `G.t` to represent abstract domains and global states, supporting operations such as join, meet, and widening for dataflow analysis. The CFG submodule processes control flow nodes with metadata, enabling tracking of memory effects across threads and visualization of analysis results. Example uses include resolving memory access conflicts, optimizing dataflow-driven computations, and serializing analysis states for debugging.",
      "description_length": 581,
      "index": 1349,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.LocksetAnalysis",
      "library": "goblint.lib",
      "description": "This module performs precise lockset analysis for concurrency verification, tracking sets of locks held at each program point using abstract domains to enable static analysis of thread safety and synchronization errors. It provides core operations for computing may and must locksets, integrating thread spawning and synchronization handling across execution paths, and supports lattice-based abstract interpretation with join, meet, widen, and narrow operations to model lock dependencies. Concrete data types include abstract lockset values (`D.t`, `G.t`, `V.t`) with equality, comparison, and serialization capabilities, enabling efficient analysis of lock acquisition and release patterns. It allows users to detect race conditions and deadlocks by analyzing lock usage discipline, merging lock states across threads, and enforcing synchronization constraints at specific program points.",
      "description_length": 891,
      "index": 1350,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.RegionDomain",
      "library": "goblint.lib",
      "description": "This module family provides abstract domains for analyzing disjoint heap regions using set and map structures combined with lattice operations. Core data types include region sets (RS.t), region maps (RegMap.t), and partition structures (RegPart.t), supporting operations like union, intersection, join, and widen to model memory relationships and constraints. Functional transformations enable tracking variable associations, resolving region equalities, and managing heap partitions with support for serialization and analysis integration. Examples include analyzing dynamic memory allocations, determining global variable aliases, and verifying memory safety through abstract interpretation of low-level code.",
      "description_length": 712,
      "index": 1351,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Analyses",
      "library": "goblint.lib",
      "description": "This module enables the construction and manipulation of analysis specifications and constraint systems through a suite of modular components that operate on abstract domains, program variables, and analysis contexts. It supports the definition of lattice structures with operations like join, meet, widen, and narrow, and includes constraint system solvers that model dataflow equations over local and global variables, enabling iterative fixpoint computation. Child modules provide concrete analysis values, identity tracking, context-sensitive analysis, and imperative hash table utilities, facilitating tasks such as static dataflow analysis, abstract interpretation, and concurrency modeling. Specific capabilities include variable and function context tracking, constraint propagation, dead code detection, and serialization of analysis states for debugging or output.",
      "description_length": 874,
      "index": 1352,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.CompilationDatabase",
      "library": "goblint.lib",
      "description": "This module processes compilation databases to extract and manipulate compile commands for C files. It parses JSON files into command objects, splits commands based on regex patterns, and preprocesses them for analysis. Concrete use cases include loading and filtering compiler invocations for static analysis tools.",
      "description_length": 316,
      "index": 1353,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ModifiedSinceSetjmp",
      "library": "goblint.lib",
      "description": "This module tracks variables modified since `setjmp` in C programs using control-flow-sensitive analysis, managing context splits, branches, and thread states. It operates on CIL expressions and function definitions, using abstract domains (`D.t`) to model state changes across function calls, returns, and inter-thread flows. It enables precise static analysis of non-local jumps, handling divergent execution paths and concurrent modifications to ensure correctness. Example use cases include detecting unsafe variable access after `longjmp` and verifying state consistency across jump targets.",
      "description_length": 596,
      "index": 1354,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Region",
      "library": "goblint.lib",
      "description": "This module analyzes disjoint heap regions in dynamically allocated memory, using abstract domains like `RegMap.t` and `MapDomain.MapBot` to model memory states and track value flows across control-flow and concurrency constructs. It supports operations such as `may_race`, lattice joins, and `pretty` to detect data races, enforce region constraints, and visualize memory states. It enables synchronization of region analyses across function calls and handles optional regions, unit-type specs, and set-theoretic manipulations of memory expressions. Example uses include race detection in concurrent programs and region-sensitive static analysis of CIL code.",
      "description_length": 659,
      "index": 1355,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Queries",
      "library": "goblint.lib",
      "description": "This module orchestrates a suite of lattice-based abstractions and query mechanisms essential for static analysis, combining core operations with specialized submodules to model security levels, thread states, variable sets, and abstract expressions. It centers around the `any_query` type and lattice semantics for managing extremal values, comparisons, and transformations, enabling precise dataflow analysis, synchronization modeling, and information flow tracking. Submodules handle structured sets of CIL types, hash tables with polymorphic keys, and security lattices with bottom/top elements, supporting operations like widening, meet, and join alongside safe querying, serialization, and pretty-printing. Concrete tasks include analyzing thread safety with mutex protection levels, enforcing security policies via lattice comparisons, and tracking variable dependencies with set-based abstractions.",
      "description_length": 906,
      "index": 1356,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Assert",
      "library": "goblint.lib",
      "description": "This module analyzes CIL code assertions and control flow effects using abstract domains and CIL constructs, managing variable handling, branching, and concurrency semantics. It defines lattice structures for abstract interpretation, tracks path representatives for constraint solving, models assertion states with extremal values, and detects race conditions in concurrent code. Operations include join, meet, widen, narrow, equality checks, pretty-printing, and serialization across domains like `D`, `G`, `C`, and `V`. Examples include verifying program invariants, analyzing skipped statements, generating witnesses for assertion mismatches, and tracking constraints in inline assembly or multi-threaded code.",
      "description_length": 713,
      "index": 1357,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Refinement",
      "library": "goblint.lib",
      "description": "Implements refinement operations for analysis results, enabling incremental improvements to value abstractions. Works with abstract domains and refinement policies to adjust precision during static analysis. Useful for optimizing analysis accuracy in iterative program verification tasks.",
      "description_length": 288,
      "index": 1358,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.WrapperFunctionAnalysis",
      "library": "goblint.lib",
      "description": "This module analyzes wrapper functions to generate symbolic heap locations and thread identifiers based on node and thread IDs, enabling precise tracking of dynamic memory allocations and thread creation across function calls. It defines core types like `C.t` for symbolic locations and thread IDs, along with lattice-based structures for state manipulation, and supports operations such as `mallocWrapper` and `threadCreateWrapper` for context-sensitive modeling. Submodules refine this behavior with path-sensitive tracking, constraint integration, and domain-specific precision, enabling analyses like points-to, memory safety, and concurrency verification. Specific uses include modeling `malloc` allocations and `pthread_create` calls with symbolic identifiers that distinguish allocation and thread spawning sites across execution contexts.",
      "description_length": 846,
      "index": 1359,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Events",
      "library": "goblint.lib",
      "description": "This module defines event types for tracking concurrency-related actions like locking, unlocking, thread spawning, and memory accesses, along with expression evaluations and assertions. It works with abstract domains for addresses, threads, and escape information to model program behavior during analysis. Concrete use cases include modeling lock acquisition order, tracking escaped variables, and simulating branch splits for path-sensitive analysis.",
      "description_length": 452,
      "index": 1360,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Server",
      "library": "goblint.lib",
      "description": "The module enables interactive JSON-RPC server functionality for analysis tasks, managing CIL files and dynamic analysis states with operations for request handling, node location, and state resets. It directly supports structured input/output management and integrates with submodules for command-line parsing, JSON-RPC argument conversion, and node-based data manipulation. Submodules provide concrete tools for working with node sets (`Locator.ES.t`), location-keyed maps (`Locator.LocM.t`), function identifiers, and imperative hash tables, enabling bulk transformations, set operations, and keyed data aggregation. Specific capabilities include parsing client requests into structured parameters, locating AST/CFG nodes from string identifiers, tracking source code annotations, and managing per-file analysis state with efficient lookups and updates.",
      "description_length": 856,
      "index": 1361,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.LoopfreeCallstring",
      "library": "goblint.lib",
      "description": "This module optimizes call string analysis by collapsing recursive cycles into set-based representations, reducing context length while preserving call order for scalable static analysis. It defines compact call strings with lattice operations, equality, and serialization, enabling efficient handling of repetitive or cyclic call patterns in C programs. Users can track unique calling contexts, summarize recursive chains, and perform context-sensitive analysis without infinite expansion. Example transformations include collapsing `main, a, b, c, a` into `main, {a, b, c}` and `main, a, a, b, b, b` into `main, {a}, {b}`.",
      "description_length": 624,
      "index": 1362,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.WideningToken",
      "library": "goblint.lib",
      "description": "This module combines UUID and index-based tokens to uniquely identify and manage widening steps in abstract interpretation. It supports comparison, hashing, serialization, and context-sensitive tracking through submodules that handle optional indices and UUID generation. The index submodule manages iteration counts and comparison logic for lifted domains, while the UUID submodule enables unique token identification across analysis states. Together, they facilitate precise control over widening transitions and witness generation in static analysis workflows.",
      "description_length": 563,
      "index": 1363,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Expsplit",
      "library": "goblint.lib",
      "description": "This module enables path-sensitive static analysis by tracking expression values across program paths using abstract domains and context-sensitive operations. It provides core types such as paths, constraint variables, abstract values, and analysis contexts, with operations for lattice manipulations, path differentiation, and domain-specific merging and transfer functions. It processes CIL constructs to manage state transitions, function calls, and concurrency, supporting tasks like race condition detection, recursive function analysis, and witness generation for value-dependent branches. Example uses include analyzing branching paths with precise value tracking and generating constraints for path-sensitive verification.",
      "description_length": 730,
      "index": 1364,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.ExtractPthread",
      "library": "goblint.lib",
      "description": "This module models concurrency primitives and control flow for Pthread programs, translating them into Promela for verification. It defines structured representations of threads, mutexes, condition variables, and program actions, using typed data like `promela_src`, environment mappings, and control-flow edges to capture program behavior. Operations include variable tracking, thread-local storage, lattice-based set manipulation, and Promela code generation, with submodules handling resource identifiers, variable analysis, concurrency actions, and control graph construction. Examples include translating function calls into Promela `run` statements, modeling synchronization primitives, and tracking thread state transitions for static analysis.",
      "description_length": 751,
      "index": 1365,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ThreadReturn",
      "library": "goblint.lib",
      "description": "This module analyzes thread return behavior in concurrent programs by abstracting call stack depth with a boolean, indicating whether a thread is at the topmost frame. It defines the core type `t` to represent thread return states and provides operations like `is_current` to check topmost status, along with initialization, dataflow propagation, and state merging via join and widen. The analysis tracks return dependencies, detects context-sensitive return points, and generates witnesses for race conditions by modeling stack transitions across function calls and returns. It integrates path representatives and constraint variables for precise, scalable context-sensitive reasoning.",
      "description_length": 686,
      "index": 1366,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Access",
      "library": "goblint.lib",
      "description": "This module analyzes memory accesses in CIL-based representations by identifying ignorable elements and detecting race conditions through access pattern summarization. It operates on CIL types, variables, expressions, and offsets, using type signatures and structured data to refine access precision and support concurrency analysis. Main data types include memory access roots (variables or type signatures), memory locations (root with offset), and access sets categorized by context. Operations enable tracking, comparing, and manipulating accesses, with support for race detection, pretty printing, serialization, and thread-safe shared-state management across parallel analysis tasks.",
      "description_length": 689,
      "index": 1367,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.ProcessPool",
      "library": "goblint.lib",
      "description": "Runs a list of tasks in parallel, up to a specified number of concurrent jobs. Each task consists of a shell command and an optional working directory. Useful for executing multiple external processes, such as running analysis tools or scripts, while limiting resource usage.",
      "description_length": 275,
      "index": 1368,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ExpRelation",
      "library": "goblint.lib",
      "description": "This module performs stateless syntactic analysis of expression relationships using structural equality (`=_{must}`), integrating abstract domains and control-flow information to determine equivalences. It provides core operations like `equal`, `compare`, `hash`, and `show` on expressions, enabling use cases such as race detection, symbolic comparison, and constraint resolution. Submodules define lattice structures for merging and querying expression relations, handling constraint variables, and generating path-representative values. These capabilities support precise static analysis, property-based testing, and serialization workflows.",
      "description_length": 644,
      "index": 1369,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.CompareConstraints",
      "library": "goblint.lib",
      "description": "This module compares constraint systems across analysis states by examining variable mappings, constraint domains, and structural equivalence, identifying discrepancies in constraint propagation and value assignments. It provides hash tables and polymorphic maps keyed on variables and analysis nodes, supporting operations like `compare`, equality checks, transformations, and structured diff reporting. Submodules enable context-aware comparisons, conditional updates, fixpoint detection, and serialization, with examples including tracking variable identities, detecting redundant constraints, and generating human-readable analysis diffs.",
      "description_length": 642,
      "index": 1370,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Transform",
      "library": "goblint.lib",
      "description": "This module coordinates transformations during static analysis, combining direct manipulation of CIL ASTs and control flow with analysis-driven modifications. It supports partial evaluation of expressions, control flow simplification, and dead code pruning, operating on data types like CIL expressions, statements, and control flow graphs. Submodules handle static optimization passes and structured code transformations based on analysis queries. Example uses include precomputing constant expressions, removing unreachable code paths, and instrumenting functions during analysis.",
      "description_length": 582,
      "index": 1371,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.GobExn",
      "library": "goblint.lib",
      "description": "Handles exception filtering and safe exception swallowing. Works with OCaml's built-in exception type. Useful for implementing robust error handling in analysis components where certain exceptions need to be ignored without affecting critical failures.",
      "description_length": 252,
      "index": 1372,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Uninit",
      "library": "goblint.lib",
      "description": "This module tracks uninitialized variables during static analysis by propagating initialization states through control flow and function calls, using abstract domains and CIL AST elements to model liveness and memory access. It defines lattice operations and type-class functionalities for abstract states, supporting join, meet, and widen operations to handle partial information and extremal states. The module enables detection of uninitialized variable usage in C programs, with utilities for comparison, visualization, and structured output generation. Example uses include analyzing local variable initialization across branches and assignments, and visualizing state transitions in XML or JSON formats.",
      "description_length": 709,
      "index": 1373,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.PrecCompare",
      "library": "goblint.lib",
      "description": "This module enables precision comparison across abstract analysis domains by quantifying differences in data values, structured results, and domain coverage. It defines core operations for comparing values of type `D.t` and hashtables mapping `K.t` to `D.t`, producing structured insights into equality, dominance, and incomparability. The module supports loading and aggregating analysis results, generating formatted reports that highlight precision discrepancies and location-based coverage. Example uses include comparing static analysis configurations on the same program and evaluating which domain yields more accurate variable bindings.",
      "description_length": 644,
      "index": 1374,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MCPAccess",
      "library": "goblint.lib",
      "description": "This module provides tools to analyze and manipulate memory access metadata through comparison, hashing, and serialization operations. It supports race condition detection between access sets, traversal of access elements, and conversion to XML or JSON formats. Key data types include lists of integer-object pairs representing memory accesses, with operations to check conflicts and aggregate access information. Example uses include static analysis of concurrent memory accesses and tracking memory usage during abstract interpretation.",
      "description_length": 538,
      "index": 1375,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.DeadCode",
      "library": "goblint.lib",
      "description": "This module optimizes CIL code by removing unreachable statements, functions, and variables through control flow analysis. It provides data types for representing code reachability and operations that traverse CFGs to identify and eliminate dead code. You can use it to prune redundant assignments, eliminate unused functions, and simplify control flow structures. The module works at both the statement level and across entire CIL files to improve analysis efficiency.",
      "description_length": 469,
      "index": 1376,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.VectorMatrix",
      "library": "goblint.lib",
      "description": "This module provides array-based numerical structures for vectors and matrices, enabling efficient dense computations with support for in-place mutations and functional transformations. It includes core operations for vector creation, element-wise mapping, indexed access, and arithmetic, alongside matrix manipulation through row/column updates, normalization, and structural analysis such as RREF computation. Child modules extend functionality to rational number arithmetic, infix operators for generic numeric types, and advanced matrix algorithms suitable for solving linear systems or symbolic computations. Examples include transforming vectors with `map2`, normalizing matrices, performing row reduction, and conducting precise rational arithmetic for exact fractional calculations.",
      "description_length": 790,
      "index": 1377,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MutexAnalysis",
      "library": "goblint.lib",
      "description": "This module analyzes mutex usage in concurrent programs by modeling lock states, tracking locksets, and enforcing synchronization constraints across threads. It operates on key data types including locksets (`D.t`), protected variables (`GProtected.t`), and protecting locks (`GProtecting.t`), supporting operations like lock acquisition tracking, must-lock constraint propagation, and deadlock detection. It enables tasks such as verifying correct lock usage across function calls, analyzing thread safety through abstract interpretation, and ensuring consistent lock ordering using domain-specific lattice operations. Example uses include detecting race conditions by analyzing lock dependencies and modeling possible locking behaviors in multi-threaded C programs.",
      "description_length": 767,
      "index": 1378,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.StackDomain",
      "library": "goblint.lib",
      "description": "This module implements call stack domains for static analysis, combining lattice operations with stack-based context tracking to model function calls and stack-allocated variables. It provides data types for abstract values tied to CIL locations (`Loc.t`, `Var.t`, `Dom2.t`) and supports operations like `push`, join, meet, widen, and narrow to manipulate and compare stack states. With submodules handling location tracking, variable set manipulation, and list-based stack structures, it enables precise analysis of recursive functions, dynamic scoping, and function call hierarchies. Examples include tracking variable lifetimes, approximating call contexts during fixed-point iteration, and comparing stack prefixes to detect control flow relationships.",
      "description_length": 756,
      "index": 1379,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.TimeUtil",
      "library": "goblint.lib",
      "description": "Converts Unix time structures to ISO 8601 strings, retrieves current time in ISO 8601 format, and parses duration strings into seconds. Operates on Unix.tm records and string representations of time. Useful for logging, benchmarking, and time-based data serialization.",
      "description_length": 268,
      "index": 1380,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Preprocessor",
      "library": "goblint.lib",
      "description": "This module detects and manages C preprocessors by locating suitable executables, filtering by version, and generating compilation commands, while handling dependencies and serializing them to JSON for build tools. It works with file paths using the `Fpath` type and includes a sub-module for path-keyed hash tables that support efficient insertion, lookup, and transformation of file-specific data. You can use it to find a working `cpp` binary, track configuration settings per file, and merge analysis results across multiple source files. The module combines direct operations for preprocessor detection with rich data management through its path-aware hash table infrastructure.",
      "description_length": 683,
      "index": 1381,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.PrecCompareUtil",
      "library": "goblint.lib",
      "description": "This module implements precision comparison logic for abstract domains, enabling analysis of static properties through functions that measure and compare domain element precision. It supports abstract types with localized printing and refinement, offering operations to determine precision dominance and quantify differences between analysis results. Child modules enhance these capabilities with hash table utilities for managing key-value state, labeled and infix operations for clarity, lattice functions for domain manipulation, and serialization tools for tracking precision across runs. Examples include comparing abstract values during fixpoint computations, merging scoped bindings with custom logic, and converting structured data to sequences for further processing.",
      "description_length": 776,
      "index": 1382,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.LoopTermination",
      "library": "goblint.lib",
      "description": "This module performs termination analysis for loops and goto statements by modeling variable transitions, control flow, and function calls using abstract domains and CIL data types. It defines core types like `t` to represent loop states and constraint variables for path conditions, with operations including join, widen, and serialization for abstract interpretation and diagnostics. Submodules provide lattice operations and comparison utilities to merge and analyze termination states across control flow points, supporting tasks like proving loop bounds, generating verification witnesses, and analyzing goto targets. Example uses include modeling loop iterations with symbolic states, comparing termination contexts for precision, and serializing analysis results for external tools.",
      "description_length": 789,
      "index": 1383,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.TaintPartialContexts",
      "library": "goblint.lib",
      "description": "This module performs taint analysis by tracking variables modified within functions using a specialized variable set structure, converting analysis data into an efficient set representation for querying and manipulation. It includes a lattice-based domain for taint tracking with operations like union, intersection, and difference, alongside lattice functions such as join and widen, working with `Basetype.Variables.t` for set-like variable handling. It enables precise static analysis of taint propagation, supporting context-sensitive tracking through efficient enumeration, partitioning, and size constraints. Examples include identifying data flow from untrusted inputs to sensitive operations by analyzing tainted variable sets across function boundaries.",
      "description_length": 762,
      "index": 1384,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ActiveSetjmp",
      "library": "goblint.lib",
      "description": "This module performs context-sensitive static analysis of C programs using setjmp/longjmp by modeling non-local control transfers through abstract analysis states. It defines the abstract type `t` to represent buffer states and supports lattice operations\u2014join, meet, widen, and narrow\u2014to merge and approximate states across control-flow paths, including function calls and concurrency. It enables queries to detect undefined behavior, such as inactive buffer captures, and analyzes control-flow divergence caused by longjmp across function boundaries. Example uses include verifying setjmp buffer liveness at specific program points and tracking the effects of longjmp in coroutine-like or error-handling code.",
      "description_length": 711,
      "index": 1385,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.LongjmpLifter",
      "library": "goblint.lib",
      "description": "This module enables abstract interpretation of programs with non-local control flow by tracking state across setjmp/longjmp and thread-aware paths using structured analysis contexts. It provides core data types `D.t` for abstract values, `G.t` for global state, and `C.t` for contexts, along with operations to merge, compare, and serialize these states, supporting precise interprocedural analysis. Submodules handle lattice operations, constraint variables, and path-representative types that model control flow transitions. Example uses include merging states after longjmp, tracking cross-function jump targets, and serializing analysis results for reporting.",
      "description_length": 663,
      "index": 1386,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.YamlWitness",
      "library": "goblint.lib",
      "description": "This module generates and validates YAML witnesses for static analysis by computing file hashes, serializing entries, and tracking validation outcomes with counters. It works with YAML values, file paths, and location data to store and verify analysis invariants in CI workflows. The validation submodule enforces logical and structural rules on YAML data, using node-level checks to confirm invariant placement based on control flow and lock states, while mapping source locations to specification variables through ordered maps and set operations. The entry submodule defines core data types like `Entry.t`, `Invariant.t`, and `Certification.t` to represent verification results, supporting location-specific invariants, loop invariants, and certification entries tied to code targets. A generation submodule integrates node and loop tracking with function-specific data to export structured YAML results, using imperative maps and hierarchical merges for efficient updates, while a lattice submodule provides four-state result modeling and chain parameter validation with integer-based counters and name checks.",
      "description_length": 1114,
      "index": 1387,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Goblint_lib.Deadlock",
      "library": "goblint.lib",
      "description": "This module analyzes concurrency in C programs by modeling thread states and lock dependencies to detect deadlocks. It uses abstract domains and analysis contexts to track lock events, memory accesses, and control flow, with key operations like `add`, `remove`, and `part_access` working on types such as `G.t` and `ValueDomain.Addr.t`. Submodules manage lock event pairs, lattice-based sets, and singleton types to enable path-sensitive deadlock detection and abstract interpretation across execution paths. For example, it can identify when two threads hold conflicting locks or report missing unlock operations along specific control paths.",
      "description_length": 643,
      "index": 1388,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Taint",
      "library": "goblint.lib",
      "description": "This module performs interprocedural taint analysis by tracking tainted variables through function calls using `VarinfoSet` to represent variable sets and determine taint propagation via `is_sink`, `is_source`, and `return_varinfo`. The `VarinfoSet` submodule provides set operations and lattice manipulations for tracking CIL variable information, enabling membership testing, union/intersection, and fixed-point computations essential for modeling tainted data flow across program boundaries. The analysis core uses abstract domains and global environments to manage taint states, supporting operations like equality checks, serialization to JSON/XML, and thread-aware propagation through control-flow constructs. You can use this module to detect injection vulnerabilities by tracing tainted inputs across function boundaries or generate witnesses for race conditions using tagged taint contexts.",
      "description_length": 899,
      "index": 1389,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.StackTrace",
      "library": "goblint.lib",
      "description": "This module enables static analysis of program control flow and interprocedural behavior by modeling call stacks and abstract contexts through lattice operations and stack manipulation primitives. It provides data types for call contexts, stack traces, and abstract states, supporting operations such as join, meet, widen, and narrow to merge and compare analysis states across function calls and threads. You can track execution paths, resolve context-sensitive function calls, and serialize analysis results for logging or external tools. Specific uses include path-sensitive bug detection, concurrent execution modeling, and interprocedural dataflow analysis in C verification frameworks.",
      "description_length": 691,
      "index": 1390,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.MHPAnalysis",
      "library": "goblint.lib",
      "description": "This module performs may-happen-in-parallel analysis to determine concurrent execution paths in multithreaded programs. It models thread interactions and memory accesses using abstract states (`D.t`), CIL expressions (`exp`), and function definitions (`fundec`), tracking active threads and synchronization constraints. It enables race detection and synchronization optimization by analyzing control flow and memory access patterns. For example, it can determine whether two memory accesses may execute in parallel or identify conflicting operations across threads.",
      "description_length": 565,
      "index": 1391,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MCP",
      "library": "goblint.lib",
      "description": "This module coordinates context-sensitive and path-sensitive static analyses within a modular abstract interpretation framework, managing dependencies between lattices, system variables, and accumulators. It enables registration and activation of analysis combinations with varying sensitivity levels, supporting precise program verification tasks such as value analysis, pointer tracking, and dataflow optimization. Submodules handle specific analysis configurations, including sensitivity selection and inter-analysis communication. For example, users can define an analysis stack that combines path-sensitive value tracking with context-sensitive alias resolution to improve precision in detecting runtime errors.",
      "description_length": 716,
      "index": 1392,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.MemOutOfBounds",
      "library": "goblint.lib",
      "description": "This module analyzes C programs to detect out-of-bounds memory accesses by tracking pointer arithmetic and array indexing within abstract memory states. It provides data types for representing memory constraints and operations for state transitions, domain joins, and bounds validation. Key functionality includes verifying pointer dereferences, checking array bounds in loops, and ensuring correctness of pointer arithmetic in conditionals. Example uses involve validating function return pointers and detecting out-of-bounds accesses in iterative or conditional code structures.",
      "description_length": 580,
      "index": 1393,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Constants",
      "library": "goblint.lib",
      "description": "This module analyzes definite integer constant values in local variables within a single function, using abstract domains and lattice operations to track and propagate constants across control flow and concurrency constructs. It provides data types for representing constants, constraint variables, and lattice states, along with operations for assignment transfer, flow-sensitive analysis, race detection, and constraint manipulation. Users can perform constant propagation optimizations or demonstrate abstract interpretation techniques on concurrent code. Example uses include simplifying expressions by replacing variables with known constants and detecting inconsistent variable states in parallel execution paths.",
      "description_length": 719,
      "index": 1394,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ThreadFlag",
      "library": "goblint.lib",
      "description": "This module tracks multi-threaded execution states during static analysis, using flags to determine if a function is currently or has ever been multi-threaded. It enables context-sensitive concurrency checks by integrating with analysis contexts, thread identifiers, and CIL expressions, supporting operations such as thread creation, state transitions, and race detection. Submodules formalize thread safety properties, provide lattice and domain-specific operations, and implement concrete checks like `may_race` and `should_print`. Example uses include detecting data races, analyzing synchronization points, and controlling analysis output based on thread state.",
      "description_length": 666,
      "index": 1395,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.WitnessUtil",
      "library": "goblint.lib",
      "description": "This module facilitates witness generation and invariant handling during static analysis by integrating control flow graph operations with structured data management. It identifies key program points like loop heads and lock-adjacent nodes, extracts and manipulates logical conjuncts from CIL expressions, and manages invariants in formats such as YAML and XML. The module supports efficient node-centric data tracking through mutable hash tables, set-like node collections, and hierarchical storage of invariants by file and location. You can use it to parse and validate invariants, emit witness data based on syntactic criteria, or perform set-theoretic operations on node sets during analysis.",
      "description_length": 697,
      "index": 1396,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Sarif",
      "library": "goblint.lib",
      "description": "This module converts analysis messages into SARIF (Static Analysis Results Interchange Format) structures. It provides functions to transform message data into SARIF results, artifacts, and locations, supporting integration with tools that consume SARIF output. It works with message types from the `Messages` module and constructs SARIF-specific data structures like `Result.t`, `Artifact.t`, and `Location.t`.",
      "description_length": 411,
      "index": 1397,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ViolationZ3",
      "library": "goblint.lib",
      "description": "This module implements path feasibility checking for abstract reachability graphs using weakest precondition calculations with the Z3 theorem prover. It operates on control flow paths and symbolic program states, determining whether a given path is feasible under the program's semantics. Concrete use cases include verifying whether a specific error path can be triggered in static analysis or pruning infeasible paths during symbolic execution.",
      "description_length": 446,
      "index": 1398,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MayLocks",
      "library": "goblint.lib",
      "description": "This module performs static analysis of concurrency behaviors in C programs by modeling may-lock states and detecting synchronization errors such as double locking and race conditions. It uses abstract interpretation with lattice operations\u2014join, meet, widen\u2014to track lock acquisition histories and analyze thread interactions across execution paths. Core data types include locksets (`D.t`) and global/variable state (`G.t`, `V.t`), supporting operations to add or remove locks and reason about potential concurrency violations. Example uses include analyzing thread spawning events and tracking lock dependencies to ensure correct synchronization.",
      "description_length": 649,
      "index": 1399,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.UseAfterFree",
      "library": "goblint.lib",
      "description": "This analysis tracks memory state transformations across program execution to detect use-after-free vulnerabilities by modeling heap and stack-allocated variables using lattice-based domains. It provides core data types including sets of variable identifiers (`CilType.Varinfo`), thread maps, and abstract domains for memory contexts, supporting operations like union, intersection, meet/join, and widening to model variable lifetimes and synchronization dependencies. Specific capabilities include identifying invalid memory accesses, generating vulnerability witnesses, and performing interprocedural and thread-aware dataflow analysis. Examples include tracking when a pointer is dereferenced after being freed or determining unsynchronized access to heap variables across threads.",
      "description_length": 784,
      "index": 1400,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.AutoSoundConfig",
      "library": "goblint.lib",
      "description": "This module automatically enables analyses required for soundness based on specifications like SV-COMP or programming constructs such as `longjmp`. It operates on configuration options and analysis settings, using predefined mappings to determine necessary analysis combinations. Concrete use cases include enabling memory safety, termination, and general specification-based analyses, as well as activating `longjmp`-specific analyses when required.",
      "description_length": 450,
      "index": 1401,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.PthreadDomain",
      "library": "goblint.lib",
      "description": "This module provides abstractions for analyzing Pthread programs by combining control flow and thread state information. It uses lattice-structured domains to manage predecessor node sets and abstract thread states, supporting operations like join, meet, widen, and comparison. These data types enable modeling control dependencies and thread interactions at synchronization points. For example, it can merge analysis states from multiple control flow paths or track reachable nodes across thread joins and locks.",
      "description_length": 513,
      "index": 1402,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.RaceAnalysis",
      "library": "goblint.lib",
      "description": "The module analyzes data races in concurrent programs by organizing memory accesses into hierarchical tries that model relationships between struct fields, array indices, and type-based memory locations. It uses `OffsetTrie` to track nested field accesses and `MemoSet` to manage sets of concurrent accesses, supporting operations like union, intersection, and lattice joins to detect overlapping reads and writes. This enables precise race detection across complex access patterns such as struct field overlaps, type coercions, and pointer arithmetic. For example, it can identify a race between writing to `s.f` and reading from the entire struct `s`, or between accesses to `((struct S *)p)->f` and `((int *)p)[0]` through type suffix analysis.",
      "description_length": 747,
      "index": 1403,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib",
      "library": "goblint.lib",
      "description": "This library provides a comprehensive framework for static analysis of C programs with a focus on concurrency, numerical properties, and memory safety. It offers a variety of abstract domains, lattice structures, and analysis techniques such as path-sensitive and context-sensitive interpretation, constraint solving, and witness generation. Core data types include abstract values (`D.t`), global and local state (`G.t`, `L.t`), constraint variables (`C.t`), and value analyses (`V.t`), with operations like join, meet, widen, and narrow for domain manipulation. Users can perform tasks such as detecting data races, verifying termination, tracking tainted variables, analyzing lock usage, and generating SARIF-compliant reports, enabling precise and scalable verification of complex program behaviors.",
      "description_length": 803,
      "index": 1404,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MessageCategory.Behavior.Undefined.ArrayOutOfBounds",
      "library": "goblint.common",
      "description": "This module defines operations for handling array out-of-bounds message categories. It provides functions to create and classify out-of-bounds access events, including cases for past the end, before the start, and unknown bounds. The module works with string lists to represent paths and constructs message categories from them.",
      "description_length": 328,
      "index": 1405,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MessageCategory.Behavior.Undefined",
      "library": "goblint.common",
      "description": "This module classifies undefined behavior in program analysis, such as array out-of-bounds access, null pointer dereference, and memory leaks, providing constructors for error categories and utilities to convert paths into string representations. Its main data types include error categories and string lists representing paths, with operations to create, classify, and convert these structures. The child module extends this by handling array-specific out-of-bounds cases, offering functions to generate message categories for accesses past the end, before the start, or with unknown bounds. Together, they enable precise reporting of runtime errors in static analysis tools using structured path data.",
      "description_length": 703,
      "index": 1406,
      "embedding_norm": 1.0
    },
    {
      "module_path": "RichVarinfo.BiVarinfoMap.S",
      "library": "goblint.common",
      "description": "This module implements a bi-directional map between custom variable identifiers and `GoblintCil.varinfo` values. It supports lookup by either key type, binding enumeration, and serialization through `marshal` and `unmarshal` operations. Use it to maintain synchronized associations between extended variable metadata and CIL variable descriptors during analysis phases.",
      "description_length": 369,
      "index": 1407,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Printable.HashCached.LazyHash",
      "library": "goblint.common",
      "description": "This module implements lazy hashing for printable elements, deferring hash computation until needed. It works with any type that conforms to the `Printable` signature, storing values alongside their delayed hash results. Useful when dealing with large or infrequently used data where immediate hash computation would be inefficient, such as in memoization or on-demand data serialization.",
      "description_length": 388,
      "index": 1408,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MyCFG.NodeH.Exceptionless",
      "library": "goblint.common",
      "description": "This module provides operations to safely access and modify a hash table keyed by control-flow graph nodes, without raising exceptions. It supports lookup with `find` and in-place updates with `modify`, returning optional values and result types to handle absence and errors explicitly. Use it when manipulating node-associated data in a CFG, such as tracking analysis results or transformation metadata during static analysis passes.",
      "description_length": 434,
      "index": 1409,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "MyCFG.NodeH.Infix",
      "library": "goblint.common",
      "description": "This module provides direct access to node values in a control-flow graph using key-based lookups and updates. It supports reading and writing node data through the `(-->)` and `(<--)` operators, which interact with a node handle (`MyCFG.NodeH.t`) and a key type specific to the graph structure. Concrete use cases include tracking variable states at specific control-flow nodes or modifying node annotations during analysis passes.",
      "description_length": 432,
      "index": 1410,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MyCFG.CfgEdgeH.Labels",
      "library": "goblint.common",
      "description": "This module manipulates labels on edges of a control-flow graph, allowing precise modification, filtering, and transformation of edge-associated data. It operates on a hash table structure where keys are edge identifiers and values are label data. Use it to track or transform edge properties such as branch conditions or execution frequencies during analysis or optimization passes.",
      "description_length": 383,
      "index": 1411,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MyCFG.CfgEdgeH.Infix",
      "library": "goblint.common",
      "description": "This module provides infix operators for manipulating control-flow graph edges. It supports adding edges with the `(-->)` operator and updating edges with the `(<--)` operator, working directly with graph edge types and keys. Concrete use cases include constructing and modifying control-flow graphs during static analysis or code transformation tasks.",
      "description_length": 352,
      "index": 1412,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MyCFG.NodeH.Labels",
      "library": "goblint.common",
      "description": "This module manages labeled data associated with nodes in a control-flow graph, providing operations to add, replace, filter, and transform node labels based on their keys and data. It supports hash tables indexed by `MyCFG.NodeH.key` with values of arbitrary type `'a`, enabling precise manipulation of node metadata during analysis or transformation passes. Concrete use cases include tracking variable assignments, annotating nodes with analysis results, and modifying control-flow based on label values.",
      "description_length": 507,
      "index": 1413,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "RichVarinfo.BiVarinfoMap.Collection",
      "library": "goblint.common",
      "description": "Implements operations for managing collections of bi-directional variable mappings using a list of modules that conform to the BiVarinfoMap.S signature. Provides functions to add, remove, and query variable mappings while ensuring consistency across both directions of the mapping. Useful for tracking relationships between pairs of variables in program analysis, such as aliasing or equivalence.",
      "description_length": 396,
      "index": 1414,
      "embedding_norm": 1.0
    },
    {
      "module_path": "RichVarinfo.BiVarinfoMap.Make",
      "library": "goblint.common",
      "description": "This module implements a bidirectional mapping between a custom type `t` (derived from module `X`) and `GoblintCil.varinfo`, enabling conversion between them and checking existence. It supports operations to bind, lookup, and describe variable information with concrete associations between custom data and CIL variables. Use cases include tracking additional metadata for CIL variables during analysis and ensuring consistent, reversible mappings for efficient querying and retrieval.",
      "description_length": 485,
      "index": 1415,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Messages.Table.MH",
      "library": "goblint.common",
      "description": "This module provides imperative hash table operations for managing key-value pairs where keys are messages (e.g., analysis warnings) and values are arbitrary. It supports bulk sequence-based manipulation, enabling efficient population or updates from `Stdlib.Seq.t` sources, such as aggregating diagnostic data or transforming message-bound metadata in batch. Use cases include tracking message-specific statistics, filtering diagnostic streams, or merging analysis results from multiple sources.",
      "description_length": 496,
      "index": 1416,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Printable.HConsed.HC",
      "library": "goblint.common",
      "description": "This module implements hash-consing for efficient memory usage and equality checks on structured data. It provides operations to create and manage hash-consed tables, ensuring unique representation of equivalent values. Use it to optimize performance when working with large numbers of structurally identical elements, such as abstract syntax trees or symbolic expressions.",
      "description_length": 373,
      "index": 1417,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MyCFG.CfgEdgeH.Exceptionless",
      "library": "goblint.common",
      "description": "This module provides operations to safely query and modify a hash table mapping control-flow graph edges to values, where keys are edges in a custom CFG representation. It includes functions to look up edge-associated data and apply transformations to existing entries, returning results that indicate success or failure without raising exceptions. Concrete use cases include tracking and updating edge-specific metadata during static analysis passes, such as annotating edges with analysis results or modifying edge weights based on traversal logic.",
      "description_length": 550,
      "index": 1418,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CilType.Attributes",
      "library": "goblint.common",
      "description": "This module provides operations for comparing, hashing, and serializing CIL attributes, including functions for pretty-printing, XML output, and JSON conversion. It works with the `attributes` type, which represents structured metadata in CIL. Concrete use cases include attribute manipulation during analysis, serialization for storage or communication, and generating human-readable or machine-readable representations of attributes.",
      "description_length": 435,
      "index": 1419,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Printable.Showable",
      "library": "goblint.common",
      "description": "This module defines a signature for types that can be converted to human-readable string representations. It requires the implementation of a `show` function that maps values of type `t` to strings. Useful for debugging and logging structured data like trees, records, or custom algebraic types.",
      "description_length": 295,
      "index": 1420,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Printable.DefaultConf",
      "library": "goblint.common",
      "description": "Defines default configuration values for printing, including names for bottom and top elements and boolean flags controlling expansion levels. Works with boolean and string types to customize output behavior. Used to set standard display options in printing routines without requiring manual configuration.",
      "description_length": 306,
      "index": 1421,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Printable.UnitConf",
      "library": "goblint.common",
      "description": "This module defines operations for handling unit values with comparison, hashing, and pretty-printing. It includes functions for equality checking, ordering, generating string representations, and producing XML and Yojson outputs. Use it when working with unit-typed values in contexts requiring serialization, comparison, or structured output formatting.",
      "description_length": 355,
      "index": 1422,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MyCFG.NodeH",
      "library": "goblint.common",
      "description": "This module offers imperative hash table operations for mapping control-flow graph nodes to arbitrary values, enabling creation, insertion, lookup, deletion, iteration, and folding. It supports higher-order transformations such as mapping, filtering, and merging, along with in-place modifications and conversions to and from lists and sequences. The module's core API handles key-value associations through standard operations, while its submodules extend functionality with safe, non-raising access patterns, direct node-value lookups using infix operators, and label-based metadata management. Use it to track analysis results, annotate nodes with variable states, or manipulate node metadata during optimization passes.",
      "description_length": 723,
      "index": 1423,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CilType.Fieldinfo",
      "library": "goblint.common",
      "description": "This module provides operations for comparing, hashing, and serializing field information in CIL types, including equality checks, string conversion, and JSON/Yojson encoding. It works with the `fieldinfo` type, representing structural fields in CIL. Concrete use cases include tracking field identities in analysis, serializing field data for logging, and enabling precise comparisons in constraint solving.",
      "description_length": 408,
      "index": 1424,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Printable.Chain",
      "library": "goblint.common",
      "description": "This module defines operations for working with integers as printable, comparable, and serializable values. It includes functions for equality checking, hashing, comparison, string conversion, pretty printing, XML output, and Yojson serialization. Concrete use cases include representing tagged identifiers in a context-sensitive system and enabling structured output for testing or logging.",
      "description_length": 391,
      "index": 1425,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cilfacade.StmtH",
      "library": "goblint.common",
      "description": "This module implements a hash table for mapping CIL statements to arbitrary values, supporting imperative operations like insertion, replacement, and lookup, as well as bulk updates from sequences of key-value pairs. It facilitates efficient association of per-statement metadata or intermediate analysis results, with utilities for iterating, filtering, and folding over statement-keyed entries. The design enables seamless integration with sequence-based data flows, such as processing collections of statements during control flow analysis or transformation passes.",
      "description_length": 568,
      "index": 1426,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Basetype.CilStmt",
      "library": "goblint.common",
      "description": "Handles statement-level operations and transformations on CIL (C Intermediate Language) representations of code. It provides equality checks, hashing, comparison, and serialization functions for `GoblintCil.stmt` values, supporting precise manipulation and analysis of individual statements. Useful for static analysis tools that require tracking or comparing code statements during program traversal or optimization.",
      "description_length": 417,
      "index": 1427,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Printable.Z",
      "library": "goblint.common",
      "description": "This module implements equality, comparison, and serialization operations for arbitrary-precision integers using the Z.t type. It provides functions for pretty-printing, XML output, JSON conversion, and generating arbitrary values for testing. Concrete use cases include handling large integers in formal verification, symbolic computation, and data serialization workflows.",
      "description_length": 374,
      "index": 1428,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "CilType.Typsig",
      "library": "goblint.common",
      "description": "This module provides operations for comparing, hashing, and serializing CIL type signatures. It supports concrete data types like `GoblintCil.typsig` with functionality for generating unique IDs, pretty-printing, XML output, and JSON conversion. Use cases include type signature normalization, equality checks, and integration with analysis tools requiring structured type representations.",
      "description_length": 389,
      "index": 1429,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CilType.Typ",
      "library": "goblint.common",
      "description": "This module provides operations for comparing, hashing, and converting CIL type representations to strings or JSON. It works with the `GoblintCil.typ` type, enabling serialization, pretty-printing, and generation of arbitrary values for testing. Concrete use cases include type equality checks, generating unique identifiers for types, and producing human-readable or machine-readable output for analysis or debugging.",
      "description_length": 418,
      "index": 1430,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Printable.Prod3",
      "library": "goblint.common",
      "description": "This module implements comparison, hashing, and serialization for triplets of values from three base modules. It supports structured output via string representations, XML printing, and JSON conversion, along with generating arbitrary values for testing. Use it when working with composite data made of three distinct typed components that need to be compared, printed, or persisted.",
      "description_length": 383,
      "index": 1431,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "MyCFG.CfgEdge",
      "library": "goblint.common",
      "description": "Represents control-flow graph edges as tuples of source node, edge type, and target node. Provides equality and hashing operations for edge values. Useful for analyzing program flow by uniquely identifying transitions between nodes in a CFG.",
      "description_length": 241,
      "index": 1432,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Cilfacade.StringH",
      "library": "goblint.common",
      "description": "This module implements a string-keyed hash table with imperative operations for element manipulation, bulk updates from sequences, and transformations. It supports efficient lookups, in-place filtering, folding over key-value pairs, and metadata tracking, while enabling conversions to and from sequence representations. Typical applications include managing string-indexed data collections where bulk modifications, iterative processing, or statistical analysis are required.",
      "description_length": 476,
      "index": 1433,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "MyCFG.FileCfg-Cfg",
      "library": "goblint.common",
      "description": "This module provides operations to traverse and analyze control-flow graphs, specifically handling edges and nodes. It works with CFG structures including nodes, edges, and AST statements, enabling precise tracking of skipped statements during CFG construction. Concrete use cases include identifying the real statement associated with a CFG node and analyzing control flow in the presence of complex AST constructs.",
      "description_length": 416,
      "index": 1434,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "MyCFG.CfgBidir",
      "library": "goblint.common",
      "description": "Implements bidirectional traversal of control-flow graphs using predecessor and successor edges. Operates on `MyCFG.cfg` nodes, enabling reverse and forward navigation through `prev` and `next` references. Useful for analyses requiring path-sensitive reasoning, such as dataflow analysis or code optimization passes that need to track both incoming and outgoing control dependencies.",
      "description_length": 383,
      "index": 1435,
      "embedding_norm": 1.0
    },
    {
      "module_path": "RichVarinfo.Make",
      "library": "goblint.common",
      "description": "This module creates a customizable interface for managing `GoblintCil.varinfo` entries using a parameterized type `t`. It supports marshaling and unmarshaling of variable information, enabling persistence across analyses, and provides access to all bound variable associations. Concrete use cases include tracking variable metadata during static analysis and restoring analysis state from serialized data.",
      "description_length": 405,
      "index": 1436,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CilType.Varinfo",
      "library": "goblint.common",
      "description": "This module provides operations for comparing, hashing, and pretty-printing CIL variable information, including unique identification via tags and serialization to JSON. It works with `GoblintCil.varinfo` values, which represent variables in CIL intermediate language. Concrete use cases include tracking variable identities during analysis, generating human-readable output, and persisting variable data in structured formats.",
      "description_length": 427,
      "index": 1437,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Printable.ChainParams",
      "library": "goblint.common",
      "description": "This module defines chain parameters for printable elements, providing `n` to retrieve a count and `names` to map indices to string identifiers. It works with integer indices and string-based naming schemes. Useful for generating named representations in serialization or configuration contexts.",
      "description_length": 295,
      "index": 1438,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CilType.Fkind",
      "library": "goblint.common",
      "description": "This module provides operations for comparing, hashing, and serializing function kinds from the CIL library. It supports concrete data types like `GoblintCil.fkind` and includes functions for pretty-printing, XML output, and generating arbitrary values for testing. Use cases include analyzing or transforming C functions during static analysis in tools like Goblint.",
      "description_length": 367,
      "index": 1439,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Basetype.CilExp",
      "library": "goblint.common",
      "description": "This module provides operations for manipulating and analyzing CIL expressions, including equality checks, hashing, comparison, and pretty-printing. It supports concrete tasks like variable occurrence detection, expression replacement, and extraction of variables from expressions. Use cases include symbolic evaluation, expression normalization, and analysis of CIL code during static analysis.",
      "description_length": 395,
      "index": 1440,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "CilType.Offset",
      "library": "goblint.common",
      "description": "This module provides operations for comparing, hashing, and serializing CIL type offsets, including functions for pretty-printing, XML output, and JSON conversion. It works directly with `GoblintCil.offset` values, which represent field offsets in CIL types. Concrete use cases include tracking struct field positions during analysis and enabling precise type comparisons in constraint solving.",
      "description_length": 394,
      "index": 1441,
      "embedding_norm": 1.0
    },
    {
      "module_path": "UpdateCil0.NodeMap",
      "library": "goblint.common",
      "description": "This module implements a hash table for mapping `Node0.t` keys to arbitrary values, supporting imperative operations like insertion, deletion, and iteration, along with advanced in-place transformations such as filtering and folding. It provides bulk update capabilities via functions that integrate key-value sequences (`add_seq`, `replace_seq`, `of_seq`), enabling efficient initialization and modification of maps from sequential data. Designed for scenarios requiring dynamic node-centric data management\u2014such as resolving dependency cycles in `UpdateCil0`\u2014it facilitates efficient, structured manipulation of associations between nodes and contextual metadata.",
      "description_length": 665,
      "index": 1442,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Printable.EitherConf",
      "library": "goblint.common",
      "description": "This module defines a sum type with `Left` and `Right` constructors wrapping values of two distinct types. It provides comparison, hashing, and conversion to string or XML for this union type, along with pretty-printing and Yojson serialization. It is used when handling values that may be one of two distinct types, such as configuration variants or dual-format data.",
      "description_length": 368,
      "index": 1443,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CilType.Fundec",
      "library": "goblint.common",
      "description": "This module provides operations for comparing, hashing, and serializing function definitions, specifically working with `GoblintCil.fundec` values. It supports concrete use cases such as tracking function identity via unique tags, pretty-printing for debugging, and generating JSON representations for external consumption. Functions like `equal`, `compare`, and `arbitrary` enable use in sets, maps, and property-based testing.",
      "description_length": 428,
      "index": 1444,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Printable.ProdConf",
      "library": "goblint.common",
      "description": "This module implements comparison, hashing, and serialization for pairs of values from two base modules. It supports structured output via pretty-printing, XML, and JSON formats, with customizable expansion flags for each component. Typical use cases include representing and serializing compound configurations or product types with associated comparison logic.",
      "description_length": 362,
      "index": 1445,
      "embedding_norm": 1.0
    },
    {
      "module_path": "IntOps.BigIntOpsBase",
      "library": "goblint.common",
      "description": "This module supports arithmetic and bitwise operations on arbitrary-precision integers represented by the `Z.t` type alias, enabling precise calculations beyond machine-word limits. It bridges OCaml's primitive integers with big integers through bidirectional conversions, comparison operators, and utilities like hashing or range checks. Typical applications include cryptographic algorithms, financial computations requiring exact precision, and testing scenarios needing arbitrary value generation or string-based integer representations.",
      "description_length": 541,
      "index": 1446,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Printable.S",
      "library": "goblint.common",
      "description": "This module defines operations for types that support comparison, hashing, and structured output. It includes functions to check equality, generate string representations, produce XML and JSON serializations, and create pretty-printed documents. It is used for types that need to be displayed, compared, or persisted in formats like XML or JSON, such as AST nodes or configuration values.",
      "description_length": 388,
      "index": 1447,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Printable.Prettyable",
      "library": "goblint.common",
      "description": "This module defines a type `t` and a function `pretty` that converts values of `t` into structured documents for pretty-printing. It works with the `Pretty.doc` type to enable customizable, layout-aware output formatting. Use this module to generate human-readable representations of structured data, such as ASTs or configuration values, with control over spacing and line breaks.",
      "description_length": 381,
      "index": 1448,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Printable.SimpleShow",
      "library": "goblint.common",
      "description": "This module provides functions to format, print, and serialize values of type `P.t`. It supports pretty-printing with `pretty`, XML output with `printXml`, and conversion to Yojson with `to_yojson`. Concrete use cases include generating human-readable output for debugging, exporting data in XML format, and serializing values to JSON for inter-process communication.",
      "description_length": 367,
      "index": 1449,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CilType.Lval",
      "library": "goblint.common",
      "description": "This module provides operations for comparing, hashing, and converting CIL lvalue representations to strings or JSON. It supports data types used in CIL's abstract syntax tree for program analysis, particularly for tracking memory locations and variables. Concrete use cases include equality checks between lvalues, generating string representations for debugging, and serializing lvalues for external output or analysis reporting.",
      "description_length": 431,
      "index": 1450,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Printable.StdLeaf",
      "library": "goblint.common",
      "description": "Implements default tag, arbitrary, and relift operations for leaf types like primitives and CIL types. These functions support handling values that do not contain nested types requiring relifting. Useful when working with simple data structures in contexts needing comparison or output, such as printing or serialization.",
      "description_length": 321,
      "index": 1451,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cilfacade.LocSet",
      "library": "goblint.common",
      "description": "This module implements a hash table for mapping source code locations to arbitrary values, supporting insertion, deletion, lookup, and in-place transformations of entries. It operates on polymorphic value types and integrates sequence-based bulk operations for efficient updates, leveraging `CilType.Location.t` as keys. Designed for static analysis tasks, it facilitates tracking location-associated data like annotations, intermediate results, or transformation metadata in CIL-based tools.",
      "description_length": 492,
      "index": 1452,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "MessageCategory.Integer",
      "library": "goblint.common",
      "description": "This module defines operations for handling integer-related message categories. It provides functions to create categories from integer values, handle overflow and division-by-zero errors, convert string lists to categories, and generate string paths from integer categories. The module works directly with `MessageCategory.Integer.t` and `MessageCategory.category` types, enabling precise categorization of integer-based messages in error reporting and logging systems.",
      "description_length": 470,
      "index": 1453,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Timing.Default",
      "library": "goblint.common",
      "description": "Implements hierarchical timing measurements with start, stop, reset, enter, exit, and wrap operations for tracking nested timed sections. Uses timing trees to represent the hierarchy and supports pretty-printing the results. Useful for profiling structured computations and generating detailed timing reports.",
      "description_length": 309,
      "index": 1454,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CilType.Constant",
      "library": "goblint.common",
      "description": "This module defines operations for comparing, printing, and serializing CIL constants, including equality checks, hashing, string representation, and XML and JSON output. It works directly with the `GoblintCil.constant` type, providing functionality for inspection, transformation, and persistence. Concrete use cases include constant comparison during analysis, pretty-printing for debugging, and generating machine-readable output for external tools.",
      "description_length": 452,
      "index": 1455,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Printable.FailwithMessage",
      "library": "goblint.common",
      "description": "This module defines a value `message` of type `string` that represents a failure message. It is used to provide a textual description when an operation fails unexpectedly. The module is typically employed in error handling scenarios where a descriptive string is needed to indicate failure conditions.",
      "description_length": 301,
      "index": 1456,
      "embedding_norm": 1.0
    },
    {
      "module_path": "IntOps.IntOpsBase",
      "library": "goblint.common",
      "description": "This module type provides arithmetic operations (addition, multiplication, division), bitwise manipulations, and comparisons for an abstract integer type, along with conversions to and from common representations like `int`, `int64`, `Z.t`, and strings. It supports use cases such as implementing custom integer types with integrated testing via `QCheck.arbitrary` and ensuring interoperability with OCaml's numeric ecosystem through precise range checks and bidirectional conversions.",
      "description_length": 485,
      "index": 1457,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CilType.Exp",
      "library": "goblint.common",
      "description": "This module provides operations for comparing, hashing, and serializing CIL expressions, including equality checks, string conversion, and JSON/Yojson output. It works directly with `GoblintCil.exp` values, offering utilities for pretty printing, XML serialization, and generating arbitrary test values. Concrete use cases include expression normalization, witness generation for analysis, and integration with external tools via JSON or XML formats.",
      "description_length": 450,
      "index": 1458,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "CfgTools.NodeStyles",
      "library": "goblint.common",
      "description": "Handles node style attributes for CFG visualization. Provides default styles for nodes and computes additional styles based on node properties. Works with CFG nodes and string lists to customize graph rendering. Useful for generating visually distinct nodes in graph outputs.",
      "description_length": 275,
      "index": 1459,
      "embedding_norm": 1.0
    },
    {
      "module_path": "RichVarinfo.BiVarinfoMap",
      "library": "goblint.common",
      "description": "This module manages associations between pairs of `GoblintCil.varinfo` values, supporting insertion, lookup, and iteration over variable relationships. It enables tracking interactions such as aliasing or data flow between two variables, with direct operations and structured extensions via submodules. The first submodule synchronizes custom identifiers with CIL variables, allowing bidirectional lookups and marshaling. The second manages collections of consistent bidirectional mappings, while the third provides conversions between a custom type and `GoblintCil.varinfo`, supporting metadata tracking and reversible associations.",
      "description_length": 633,
      "index": 1460,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CilType.Ikind",
      "library": "goblint.common",
      "description": "This module provides operations for comparing, hashing, and converting CIL integer kind types to strings or JSON. It supports data types representing different integer kinds, such as signed and unsigned integers of various sizes. Concrete use cases include normalizing and serializing integer type information for analysis or output in a consistent format.",
      "description_length": 356,
      "index": 1461,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CilType.Location",
      "library": "goblint.common",
      "description": "This module provides operations for comparing, hashing, and serializing location values, including equality checks, string conversion, JSON encoding/decoding, and pretty printing. It works with the `GoblintCil.location` type, which represents source code locations in CIL. Concrete use cases include tracking and identifying code positions during analysis, enabling structured output for debugging, and supporting serialization for storage or communication.",
      "description_length": 457,
      "index": 1462,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Printable.Std",
      "library": "goblint.common",
      "description": "This module provides placeholder implementations for tagging values and generating arbitrary values. It works with any type, producing a tag function that maps values to a unit-like result and an arbitrary function that constructs a value from nothing. Useful for stubbing or testing contexts where real implementations are not yet needed.",
      "description_length": 339,
      "index": 1463,
      "embedding_norm": 1.0
    },
    {
      "module_path": "IntOps.Int32OpsBase",
      "library": "goblint.common",
      "description": "This module implements arithmetic, bitwise, and comparison operations for 32-bit signed integers, including addition, multiplication, bitwise shifts, and logical operations. It provides utilities for type conversion (e.g., to/from strings, 64-bit integers, and arbitrary-precision integers), value comparison, and range validation. These capabilities are particularly useful in systems programming, data serialization, and testing scenarios requiring precise 32-bit integer behavior or cross-type interoperability.",
      "description_length": 514,
      "index": 1464,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "RichVarinfo.VarinfoMap",
      "library": "goblint.common",
      "description": "This module implements a map for managing `GoblintCil.varinfo` entries with custom key types, supporting operations to bind, retrieve, and marshal variable information. It works directly with `GoblintCil.varinfo` and a marshaled representation for persistence. Concrete use cases include tracking variable metadata across analysis phases and serializing variable state for checkpointing.",
      "description_length": 387,
      "index": 1465,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Printable.Unit",
      "library": "goblint.common",
      "description": "This module implements equality, comparison, and pretty-printing operations for the unit type, enabling consistent serialization and structural analysis. It provides concrete functions to convert unit values to strings, XML, and Yojson representations, along with utilities for pretty-printing and generating arbitrary values for testing. Use cases include simplifying unit value handling in tests, logging, and data serialization workflows.",
      "description_length": 441,
      "index": 1466,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "CilType.Typeinfo",
      "library": "goblint.common",
      "description": "This module provides operations for comparing, hashing, and serializing CIL type information, including functions for generating unique IDs, pretty-printing, and converting to JSON. It works directly with `GoblintCil.typeinfo` values, enabling efficient equality checks, ordering, and string representations. Concrete use cases include type comparison during analysis, generating stable identifiers for type-based tracking, and exporting type data for external consumption or debugging.",
      "description_length": 486,
      "index": 1467,
      "embedding_norm": 1.0
    },
    {
      "module_path": "IntOps.NIntOps",
      "library": "goblint.common",
      "description": "This module supports arithmetic operations including GCD computation, bitwise manipulations like shifts and logical AND/OR, and comparisons (min/max) on an abstract integer type `t` with optional bounds. It provides conversions between integers, strings, and arbitrary-precision representations, along with boolean logic operations that treat integers as bit-level truth values. These capabilities are particularly useful for low-level system programming, cryptographic algorithms requiring precise bit manipulation, or handling integer data across varying precision domains.",
      "description_length": 575,
      "index": 1468,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Printable.Either",
      "library": "goblint.common",
      "description": "This module implements a sum type with two tagged variants, supporting equality checks, ordering, and string/XML/JSON serialization. It operates on arbitrary types through its two base type parameters, enabling tagged union values to be compared, hashed, and pretty-printed. Concrete use cases include representing dual-result computations, such as parsing successes or failures with distinct value types.",
      "description_length": 405,
      "index": 1469,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "CilType.Attrparam",
      "library": "goblint.common",
      "description": "This module provides operations for comparing, hashing, and serializing attribute parameters, specifically working with the `GoblintCil.attrparam` type. It includes functions for generating string representations, pretty printing, XML output, and JSON conversion, along with utilities for arbitrary value generation and identity preservation. Concrete use cases include attribute handling in CIL-based analyses and data persistence in various formats.",
      "description_length": 451,
      "index": 1470,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Printable.ProdSimple",
      "library": "goblint.common",
      "description": "Handles printing and comparison of simple product types composed of two elements. Works with pairs of values from the Base1 and Base2 modules, supporting operations like string conversion, XML printing, and JSON serialization. Useful for structured data output where both components have predefined printable representations.",
      "description_length": 325,
      "index": 1471,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Printable.Liszt",
      "library": "goblint.common",
      "description": "This module implements operations for working with lists of comparable and outputtable elements, providing equality checks, comparison, JSON serialization, and string formatting. It supports concrete use cases like pretty-printing lists, computing common prefixes or suffixes between lists, and serializing list data to XML or JSON formats. The module also includes utilities for generating arbitrary list values and comparing or hashing list structures.",
      "description_length": 454,
      "index": 1472,
      "embedding_norm": 1.0
    },
    {
      "module_path": "IntOps.Int64Ops",
      "library": "goblint.common",
      "description": "This module offers arithmetic operations (addition, multiplication, GCD), bitwise manipulations (shifts, logical AND/OR/XOR), and comparisons (equality, ordering) for 64-bit integers. It supports conversions to and from integers, strings, and big integers, enabling use cases like cryptographic algorithms, low-level system programming, and data serialization. Utilities include handling integer bounds, boolean conversions, XML formatting, and arbitrary data generation for testing or simulation.",
      "description_length": 497,
      "index": 1473,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MyCFG.CfgForward",
      "library": "goblint.common",
      "description": "Implements forward traversal of a control-flow graph, processing nodes in execution order. Provides functions to iterate over statements and edges while maintaining state across paths. Useful for analyzing variable definitions, tracking data flow, or propagating constraints through reachable blocks.",
      "description_length": 300,
      "index": 1474,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CilType.Binop",
      "library": "goblint.common",
      "description": "This module provides operations for comparing, hashing, and converting binary operator values to strings or JSON. It works with the `GoblintCil.binop` type, representing CIL binary operators. Use cases include serialization for analysis results, equality checks in constraint solving, and pretty-printing operator values during debugging or logging.",
      "description_length": 349,
      "index": 1475,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Messages.Tag",
      "library": "goblint.common",
      "description": "This module defines operations for handling tags associated with analysis messages, such as categorizing warnings or identifying issues by CWE number. It supports equality checks, comparison, hashing, pretty-printing, and JSON serialization/deserialization for the tag type. These functions are used to manage and persist message metadata, enabling filtering and reporting based on tags during static analysis.",
      "description_length": 410,
      "index": 1476,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Printable.LiftTop",
      "library": "goblint.common",
      "description": "This module defines a type `t` that represents either a lifted value of type `Base.t` or a distinguished `Top` element. It provides operations for comparison, hashing, string representation, and serialization to XML and Yojson, all handling both `Top` and lifted values. It is used to model hierarchical or lattice-like structures where a special top element sits above regular values.",
      "description_length": 385,
      "index": 1477,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cilfacade.FunLocH",
      "library": "goblint.common",
      "description": "This module implements a hash table for associating function declarations (`CilType.Fundec.t`) with arbitrary data, supporting imperative operations like insertion, lookup, iteration, and folding, along with bulk transformations from and to key-value sequences. It enables efficient per-function metadata management, such as tracking analysis results or annotations during static analysis, and facilitates transformations that require aggregating or querying function-specific data in GoblintCil-based tools.",
      "description_length": 508,
      "index": 1478,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Messages.Severity",
      "library": "goblint.common",
      "description": "This module defines a set of severity levels for messages, including operations to compare, serialize, and convert between string and integer representations. It supports filtering messages based on severity with `should_warn` and provides structured output via `pp` and JSON serialization functions. Use cases include logging, user-facing diagnostics, and configuring analysis tools to handle warnings and errors programmatically.",
      "description_length": 431,
      "index": 1479,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "LoopUnrolling0.CopyOfHashTable",
      "library": "goblint.common",
      "description": "This module provides imperative hash table operations for keys of type `GoblintCil.stmt`, supporting additions, removals, and in-place transformations via traversal, filtering, and folding mechanisms. It facilitates hash table construction and modification from sequences of key-value pairs, enabling bulk updates or initial population from iterable data sources. Such functionality is particularly suited for program analysis tasks requiring efficient mapping and mutation of statement-bound data.",
      "description_length": 498,
      "index": 1480,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Cilfacade.IntH",
      "library": "goblint.common",
      "description": "This module implements integer-keyed hash tables with efficient operations for insertion, lookup, modification, and bulk transformation using sequences. It supports key-value pairs where keys are integers and values can be arbitrary types, enabling optimized storage and retrieval in scenarios requiring high-performance integer indexing. Typical applications include managing sparse integer mappings, aggregating data with integer identifiers, or processing large datasets through sequence-based bulk operations.",
      "description_length": 513,
      "index": 1481,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MessageCategory.Behavior",
      "library": "goblint.common",
      "description": "This module organizes message categories around program behaviors, including undefined behavior, implementation details, and machine-specific events, using `MessageCategory.Behavior.t` and `MessageCategory.category`. It supports constructing and converting categories from string lists and path-based representations, enabling structured classification of diagnostics such as runtime errors. Submodules refine this with specific undefined behavior classifications, including array bounds violations and null pointer dereferences, offering constructors for precise error categorization. Combined, they allow static analysis tools to generate detailed diagnostic paths and message hierarchies based on behavioral context.",
      "description_length": 719,
      "index": 1482,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MessageCategory.Cast",
      "library": "goblint.common",
      "description": "This module handles conversions between string-based identifiers and typed categories, primarily used for validating and transforming message paths. It provides functions to create typed categories from string lists, handle type mismatches, and serialize category paths back to strings. Concrete use cases include parsing message routes and ensuring correct category typing in a messaging system.",
      "description_length": 396,
      "index": 1483,
      "embedding_norm": 1.0
    },
    {
      "module_path": "RichVarinfo.H",
      "library": "goblint.common",
      "description": "This module defines a key type `t` for managing `GoblintCil.varinfo` with equality and hashing operations. It provides `equal` and `hash` functions to support use in hash tables or sets, ensuring consistent behavior for key comparison. It also includes functions to retrieve the name and description of a variable info entry.",
      "description_length": 325,
      "index": 1484,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Printable.PrefixName",
      "library": "goblint.common",
      "description": "This module implements comparison, hashing, and serialization operations for a type `t` derived from `Base.t`, supporting pretty-printing, XML output, and QCheck arbitraries. It works with types that have a name and a unique tag, enabling use in contexts requiring structural equality, logging, or property-based testing. Concrete use cases include generating human-readable representations of values, comparing and hashing complex data structures, and creating serializable, witnessable types for formal verification.",
      "description_length": 518,
      "index": 1485,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Printable.Either3Conf",
      "library": "goblint.common",
      "description": "Handles printing and comparison of ternary sum types with configurable expansion flags for each variant. Works with three distinct type parameters, each representing a possible value state. Useful for rendering or comparing disjoint result types where each variant requires separate formatting logic.",
      "description_length": 300,
      "index": 1486,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Printable.Yojson",
      "library": "goblint.common",
      "description": "This module implements equality checks, pretty-printing, and JSON serialization for values of type `Yojson.Safe.t`. It provides concrete operations like `equal`, `show`, `pretty`, and `to_yojson` to compare, display, and convert JSON values. Use this module when working with JSON data structures that need to be printed, compared, or integrated into XML output.",
      "description_length": 362,
      "index": 1487,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Printable.HConsed",
      "library": "goblint.common",
      "description": "This module provides hash-consed values with built-in comparison and printing, using `BatHashcons` to ensure canonical representations. It includes operations like `lift`, `unlift`, and `relift` to manipulate hash-consed values, and supports output through `show`, `pretty`, and `to_yojson`. Child modules handle the underlying hash-consing mechanics, enabling efficient storage and structural equality checks on data like ASTs or symbolic expressions. Together, they allow creating, transforming, and inspecting canonical values with guaranteed physical equality and optimized memory use.",
      "description_length": 589,
      "index": 1488,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Timing.Program",
      "library": "goblint.common",
      "description": "Tracks nested timed sections with start/stop/reset lifecycle controls, using string-labeled phases and optional tracing arguments. It manages a hierarchical timing tree structure with enter/exit/wrap functions for scoped measurements. Used to profile structured computations like program analysis passes, where phases nest and timing data must be aggregated hierarchically.",
      "description_length": 373,
      "index": 1489,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CilType.Unop",
      "library": "goblint.common",
      "description": "This module provides operations for working with unary operators in CIL types, including equality checks, hashing, comparison, and string representation. It supports data types like `GoblintCil.unop` with functions for pretty printing, XML serialization, and JSON conversion. Concrete use cases include analyzing or transforming CIL-based intermediate representations in program analysis tools.",
      "description_length": 394,
      "index": 1490,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Printable.Option",
      "library": "goblint.common",
      "description": "This module implements equality, comparison, hashing, and pretty-printing for optional values, using the provided `Base` module for underlying operations. It supports concrete use cases like comparing and displaying optional configuration values or parsing results. The `show` function converts an option directly to a string, while `printXml` and `to_yojson` enable XML and JSON serialization of optional values.",
      "description_length": 413,
      "index": 1491,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "CfgTools.CfgPrinters",
      "library": "goblint.common",
      "description": "Implements formatting and visualization routines for control flow graphs. Defines styles for node and edge rendering and provides functions to print nodes and edges with associated attributes using a formatter. Useful for generating graphical representations of CFGs in tools like Dot or other visualization frameworks.",
      "description_length": 319,
      "index": 1492,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Messages.Location",
      "library": "goblint.common",
      "description": "This module represents and manipulates source code locations for user messages, supporting two forms: node-based and CIL-based locations. It provides equality, comparison, and hashing operations, along with conversions to and from CIL locations and JSON representations. It is used to accurately associate analysis warnings with specific points in the source code while supporting incremental updates through node-based references.",
      "description_length": 431,
      "index": 1493,
      "embedding_norm": 1.0
    },
    {
      "module_path": "IntOps.IntOps",
      "library": "goblint.common",
      "description": "This interface provides arithmetic operations (addition, multiplication, division with remainder), bitwise logic (AND, OR, XOR, negation), and shift functions for an abstract integer type that supports arbitrary-precision values through `Z.t`. It includes comparisons, numeric conversions (e.g., string and integer representations), min/max utilities, and boolean-to-integer coercion, enabling use in cryptographic computations, bit-level system modeling, and property-based testing with randomized integer generation.",
      "description_length": 518,
      "index": 1494,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Printable.Formatable",
      "library": "goblint.common",
      "description": "This module defines a signature for types that can be formatted and printed using the standard format module. It requires a type `t` and a function `pp` that specifies how to format values of that type. This is used to enable structured output in logging, debugging, and pretty-printing scenarios.",
      "description_length": 297,
      "index": 1495,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Printable.Failwith",
      "library": "goblint.common",
      "description": "This module defines a type `t` that represents values which can be compared, hashed, and converted to human-readable or machine-readable formats like strings, XML, and Yojson. It includes operations for equality checking, ordering, pretty-printing, and generating arbitrary values for testing. Concrete use cases include representing and serializing structured error messages or identifiers with rich contextual information.",
      "description_length": 424,
      "index": 1496,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Printable.Name",
      "library": "goblint.common",
      "description": "This module defines a named element with a string identifier. It provides direct access to the name value for labeling or identification purposes. Useful for scenarios requiring symbolic references or human-readable tags in data structures.",
      "description_length": 240,
      "index": 1497,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "CfgTools.SCC",
      "library": "goblint.common",
      "description": "This module represents strongly connected components (SCCs) in a control flow graph (CFG). It tracks nodes within each SCC and maintains successor and predecessor edges to model relationships between SCCs. It supports operations to compute and analyze SCCs during CFG processing, such as identifying loops and hierarchical structure.",
      "description_length": 333,
      "index": 1498,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LazyEval.Make",
      "library": "goblint.common",
      "description": "Implements lazy evaluation for a given module's values, computing results only when forced. Works with any data type through the parameter module's `t` and `result` types. Useful for deferring expensive computations until necessary, such as loading large data structures on demand.",
      "description_length": 281,
      "index": 1499,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Printable.SimplePretty",
      "library": "goblint.common",
      "description": "This module implements string conversion, XML printing, and Yojson serialization for a given type `P.t`. It provides `show` for human-readable strings, `printXml` for structured XML output, and `to_yojson` for JSON-compatible representations. Useful for logging, serialization, and structured data interchange.",
      "description_length": 310,
      "index": 1500,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Basetype.RawStrings",
      "library": "goblint.common",
      "description": "This module implements operations for handling raw string values with support for equality checks, hashing, comparison, and serialization. It works directly with the `string` type, providing functions for pretty-printing, XML output, JSON conversion, and generating arbitrary values for testing. Concrete use cases include managing string identifiers, serializing string data to various formats, and supporting context-aware comparisons with unique tagging.",
      "description_length": 457,
      "index": 1501,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Printable.SimpleFormat",
      "library": "goblint.common",
      "description": "This module implements string conversion, pretty-printing, XML serialization, and Yojson encoding for a given type `P.t`. It provides `show` for human-readable strings, `pretty` for structured document formatting, `printXml` for XML output, and `to_yojson` for JSON serialization. Useful for generating readable output or serializing data structures in various formats.",
      "description_length": 369,
      "index": 1502,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Printable.Strings",
      "library": "goblint.common",
      "description": "This module implements comparison, hashing, and serialization for strings, enabling structured output to JSON and Pretty-printed formats. It supports operations like equality checks, ordering, and XML printing, making it suitable for applications requiring consistent string representation across different output channels. Concrete use cases include logging systems, configuration serializers, and structured data exporters.",
      "description_length": 425,
      "index": 1503,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MyCFG.CfgEdgeH",
      "library": "goblint.common",
      "description": "This module provides a hash table structure for associating arbitrary data with control-flow graph edges, enabling efficient insertion, lookup, filtering, and merging of edge-linked values. It supports bulk transformations and predicate-based traversal, making it suitable for dataflow analysis or optimization passes that track metadata on CFG edges. The module includes submodules for label manipulation, infix operators for edge construction and update, and safe query and modification operations with explicit error handling. Together, these features allow tasks such as annotating edges with branch conditions, modifying control-flow graphs during analysis, and tracking execution frequencies with precise transformations.",
      "description_length": 727,
      "index": 1504,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Messages.Message",
      "library": "goblint.common",
      "description": "This module defines a structured representation of user-facing messages, including their tags, severity levels, and multipiece status. It provides operations for equality checking, comparison, hashing, and JSON serialization/deserialization. Concrete use cases include logging analysis results, filtering messages by severity, and transmitting message data between system components via JSON.",
      "description_length": 392,
      "index": 1505,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CilType.Compinfo",
      "library": "goblint.common",
      "description": "This module provides operations for comparing, hashing, and converting CIL composite type information to strings or JSON. It works with the `compinfo` type, representing structured C data types. Concrete use cases include identifying type definitions in CIL-based analyses and serializing type metadata for logging or inter-process communication.",
      "description_length": 346,
      "index": 1506,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Printable.ProdConfiguration",
      "library": "goblint.common",
      "description": "Handles printing of product configurations with customizable expansion of first and second components. Works with pairs of configurations where each element is a printable structure. Useful for displaying nested configuration data with control over verbosity.",
      "description_length": 259,
      "index": 1507,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Printable.LiftConf",
      "library": "goblint.common",
      "description": "Implements configuration settings for lifting operations, including names for bottom and top elements and a flag for expansion behavior. Works with strings and boolean values to customize printing and transformation processes. Used to configure pretty-printing and code generation in formal verification tasks.",
      "description_length": 310,
      "index": 1508,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MyCFG.CfgBackward",
      "library": "goblint.common",
      "description": "Implements backward traversal and analysis of control-flow graphs, starting from a given node. Operates on `MyCFG.cfg` structures, providing functions to collect predecessors, reverse paths, and compute dataflow information in reverse execution order. Useful for analyses like backward slicing or liveness where propagation follows control flow in reverse.",
      "description_length": 356,
      "index": 1509,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Printable.HashCached",
      "library": "goblint.common",
      "description": "This module wraps values with cached lazy hash values, enabling efficient equality checks and hashing by deferring computation until needed. It supports lifting and unlifting values, comparing and hashing them, and generating string or structured representations for debugging and serialization. The child module extends this functionality to printable types, allowing on-demand hash computation for large or infrequently accessed data such as memoized results or serialized structures. Together, they optimize performance in hash-based collections and simplify equality checks for complex, lazily-evaluated data.",
      "description_length": 613,
      "index": 1510,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CilType.Enuminfo",
      "library": "goblint.common",
      "description": "Handles enumeration information with operations for equality, hashing, comparison, and serialization. Works with `GoblintCil.enuminfo` values representing CIL enumeration definitions. Used to manage and query enum metadata, such as names and unique identifiers, in static analysis contexts.",
      "description_length": 290,
      "index": 1511,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Printable.Empty",
      "library": "goblint.common",
      "description": "This module represents an empty type with no values, used to indicate unrepresentable or impossible cases. It provides comparison, hashing, and conversion functions like `equal`, `hash`, `show`, and `to_yojson`, all of which handle the absence of actual values. Concrete use cases include serving as a placeholder in algebraic data types where a variant has no associated data or signaling errors in contexts that require a return value.",
      "description_length": 437,
      "index": 1512,
      "embedding_norm": 1.0
    },
    {
      "module_path": "IntOps.Int32Ops",
      "library": "goblint.common",
      "description": "This module provides arithmetic, bitwise, and comparison operations for 32-bit integers, including overflow-safe conversions to and from types like `int`, `int64`, `Z.t`, and `string`. It supports use cases requiring precise numeric manipulation, such as low-level systems programming, data serialization to JSON/XML, and property-based testing via QCheck arbitraries. Key operations include logical negation, shifts, min/max, hashing, and bidirectional boolean conversions, all optimized for 32-bit signed integer values.",
      "description_length": 522,
      "index": 1513,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CilType.Stmt",
      "library": "goblint.common",
      "description": "This module provides operations for comparing, hashing, and serializing CIL statements, including equality checks, string representations, and XML/YOJSON output. It works directly with `GoblintCil.stmt` values, leveraging HConsed identifiers for unique tagging and efficient comparison. Concrete use cases include statement normalization in analysis passes, generating human-readable or machine-parseable output for debugging, and supporting witness generation through arbitrary instance creation.",
      "description_length": 497,
      "index": 1514,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Messages.MultiPiece",
      "library": "goblint.common",
      "description": "Handles structured messages composed of single pieces or groups with associated text, location, and multiple message pieces. It supports serialization to and from JSON, equality checks, comparison, and hashing for message groups and individual message pieces. Useful for organizing and persisting analysis warnings with contextual grouping and precise location information.",
      "description_length": 373,
      "index": 1515,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Basetype.Variables",
      "library": "goblint.common",
      "description": "This module provides operations for comparing, hashing, and pretty-printing variables, along with converting them to JSON and XML. It works directly with `GoblintCil.varinfo` and a custom `group` type that categorizes variables into Global, Local, Parameter, or Temp. Concrete use cases include tracking variable identity in analysis contexts, grouping variables by scope, and generating readable or structured output for debugging and reporting.",
      "description_length": 446,
      "index": 1516,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CilType.Attribute",
      "library": "goblint.common",
      "description": "This module provides operations for comparing, hashing, and serializing CIL attributes, including functions for generating unique identifiers, pretty-printing, and converting to JSON. It works directly with the `attribute` type from CIL, supporting both structural equality and ordered comparisons. Concrete use cases include attribute normalization, persistent storage of attribute states, and integration with analysis tools requiring structured attribute representations.",
      "description_length": 474,
      "index": 1517,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Printable.Lift2Conf",
      "library": "goblint.common",
      "description": "This module defines a sum type combining values from two base modules with special markers for bottom and top elements. It provides comparison, hashing, and pretty-printing operations for this type, enabling structured output and equality checks. It is used to model layered configurations or combined states from two distinct domains, such as abstract interpretations or multi-level settings.",
      "description_length": 393,
      "index": 1518,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CilType.Std",
      "library": "goblint.common",
      "description": "This module provides operations for manipulating and inspecting CIL types, including lifting, tagging, and generating arbitrary values. It works directly with CIL type representations, enabling precise type transformations and analysis. Use cases include type normalization, type-based code generation, and static analysis passes requiring detailed type information.",
      "description_length": 366,
      "index": 1519,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Messages.Table",
      "library": "goblint.common",
      "description": "This module manages a collection of unique messages using a hash table, supporting operations to add, check existence, and retrieve messages, along with conversion to JSON for serialization. It works with message keys and pairs them with arbitrary values, enabling storage and manipulation of message-bound metadata. The module includes imperative hash table operations for key-value management and supports bulk sequence-based manipulation for efficient population or updates from `Stdlib.Seq.t` sources. Use cases include aggregating diagnostic data, tracking message-specific statistics, filtering warning streams, and merging analysis results from multiple sources.",
      "description_length": 669,
      "index": 1520,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MyCFG.CfgBidirSkip",
      "library": "goblint.common",
      "description": "This module provides operations to navigate control-flow graphs bidirectionally, allowing traversal via `prev` and `next` to move backward and forward through CFG nodes. It handles skipping over intermediate statements using `skippedByEdge`, which returns the list of AST statements bypassed when moving between nodes. This is used to accurately model control flow that skips over certain code constructs, such as inlined function calls or macro expansions.",
      "description_length": 457,
      "index": 1521,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "CilType.Wstring_type",
      "library": "goblint.common",
      "description": "This module supports operations for handling wide string types in CIL, including equality checks, hashing, comparison, and string conversion. It works with the `wstring_type` type, which represents wide string constructs in CIL. Concrete use cases include analyzing or transforming C code that involves wide strings, such as handling `wchar_t` arrays in CIL-based static analysis tools.",
      "description_length": 386,
      "index": 1522,
      "embedding_norm": 1.0
    },
    {
      "module_path": "RichVarinfo.G",
      "library": "goblint.common",
      "description": "Implements a hash-consed set of variable information entries with efficient equality and lookup. It uses a custom hash function and equality predicate to manage unique identifiers for variables in a C-like abstract syntax tree. This is useful for tracking variable declarations and references across program analyses where consistent identity is critical.",
      "description_length": 355,
      "index": 1523,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CilType.S",
      "library": "goblint.common",
      "description": "This module defines operations for working with CIL types, including equality checking, hashing, comparison, string representation, and XML and JSON serialization. It supports data types used in CIL (C Intermediate Language) analysis, such as types and expressions, and is used in program analysis tasks like type checking, transformation, and code generation. Concrete use cases include comparing type structures during analysis, generating human-readable type representations, and serializing types for storage or communication.",
      "description_length": 530,
      "index": 1524,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cilfacade.VarinfoH",
      "library": "goblint.common",
      "description": "This module offers specialized hash table operations for efficient storage and retrieval of variable information identifiers (`CilType.Varinfo.t`) paired with arbitrary values, supporting bulk updates, iterative processing, and sequence-based initialization. It works with hash tables structured as `VarinfoH.t`, optimized for handling variable metadata in static analysis contexts. Common applications include tracking variable properties, analysis results, or intermediate computations during code analysis workflows.",
      "description_length": 519,
      "index": 1525,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "FloatOps.CDouble",
      "library": "goblint.common",
      "description": "This module provides arithmetic operations (addition, multiplication, trigonometric functions, square roots), comparison predicates, and conversions between `CDouble.t` and numeric types like float or big_int, alongside constants such as pi and zero. Supporting configurable rounding modes and utilities for hashing or string serialization, it enables precise numerical simulations, financial calculations, and other applications requiring deterministic control over floating-point behavior.",
      "description_length": 491,
      "index": 1526,
      "embedding_norm": 1.0
    },
    {
      "module_path": "FloatOps.CFloatType",
      "library": "goblint.common",
      "description": "This module provides precise floating-point arithmetic, transcendental functions (sqrt, trigonometric), and comparison operations with explicit rounding mode control, alongside conversions between a custom arbitrary-precision float type `t` and native floats, integers (`Z.t`), and JSON. The abstract type `t` supports numerical computations requiring fine-grained rounding guarantees, such as interval arithmetic or financial calculations where error bounds must be rigorously tracked.",
      "description_length": 486,
      "index": 1527,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Printable.Either3",
      "library": "goblint.common",
      "description": "This module defines a sum type with three possible values, each wrapping a distinct type, and provides operations for comparison, hashing, pretty-printing, XML serialization, and JSON conversion. It supports concrete data types through its three base modules, enabling discrimination between three distinct value categories. Typical use cases include representing ternary outcomes, tagged unions of different data forms, or structured error types with distinct failure causes.",
      "description_length": 476,
      "index": 1528,
      "embedding_norm": 1.0
    },
    {
      "module_path": "IntOps.IntOpsDecorator",
      "library": "goblint.common",
      "description": "This module provides arithmetic operations (addition, multiplication, GCD), bitwise logic (AND, OR, shifting), and comparison operators on a wrapped integer type that may enforce bounds. It supports conversions between various integer representations (int, int64, Z.t) and includes serialization to XML and Yojson, making it suitable for cryptographic algorithms requiring bitwise manipulations, numerical abstractions with constrained precision, and systems needing structured data interchange of integer values.",
      "description_length": 513,
      "index": 1529,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Printable.PQueue",
      "library": "goblint.common",
      "description": "Implements a priority queue with elements ordered by a base type's comparison function, using a deque for internal storage. Supports operations like insertion, extraction of the minimum element, and conversion to strings or JSON for debugging and serialization. Useful for scheduling tasks with priorities or managing ordered event queues.",
      "description_length": 339,
      "index": 1530,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Printable.PrefixNameConf",
      "library": "goblint.common",
      "description": "This module defines operations for handling prefix names in contexts where name collisions may occur during expansion. It provides functions to generate, compare, and manipulate prefixed identifiers, ensuring unique naming when `expand` is enabled. Use cases include managing variable names in code generation or symbolic manipulation where name capture must be avoided.",
      "description_length": 370,
      "index": 1531,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CilType.Encoding",
      "library": "goblint.common",
      "description": "This module defines operations for comparing, hashing, and serializing CIL type encodings. It supports concrete tasks like generating unique identifiers for types, converting them to JSON for external representation, and ensuring structural equality checks. Use cases include type analysis in program verification and tracking type identities across different contexts.",
      "description_length": 369,
      "index": 1532,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "MyCFG.FileCfg",
      "library": "goblint.common",
      "description": "Represents control-flow graphs for entire source files. Provides functions to build and manipulate CFGs from CIL file structures, including node and edge creation, traversal, and function-specific CFG extraction. Used to analyze program flow within a single compilation unit for static analysis tasks like reachability or dependency tracking.",
      "description_length": 342,
      "index": 1533,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Printable.Prod",
      "library": "goblint.common",
      "description": "Handles comparison, hashing, and string-based representation of pairs combining two distinct types. Provides structured output in formats like XML, Yojson, and Pretty documents. Useful for composite data types requiring serialization or human-readable debugging.",
      "description_length": 262,
      "index": 1534,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Printable.LiftBot",
      "library": "goblint.common",
      "description": "This module defines a type `t` that represents either a bottom value (`Bot`) or a wrapped value of type `Base.t`. It provides operations to compare, hash, and convert these values, along with functions to lift values into the type, format them as strings, and serialize them to XML or Yojson. Use cases include handling optional or extended values in a structured way, such as modeling computations that may fail or return enriched results.",
      "description_length": 440,
      "index": 1535,
      "embedding_norm": 1.0
    },
    {
      "module_path": "IntOps.BigIntOps",
      "library": "goblint.common",
      "description": "This module supports arithmetic operations (addition, multiplication, GCD), bitwise manipulations (shifts, logical operators), and comparisons (equality, ordering) on arbitrary-precision integers represented by a dedicated type. It facilitates conversions between integer formats, string representations, and JSON/XML serialization, with utilities for testing and custom logic. Applications include cryptographic algorithms requiring large integers, precise numerical computations, and low-level bit-level data processing.",
      "description_length": 522,
      "index": 1536,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Messages.Tags",
      "library": "goblint.common",
      "description": "Handles operations for comparing, serializing, and formatting lists of message tags. Works with `Messages.Tag.t` lists, providing equality checks, JSON conversion, and pretty-printing. Used to manage tags for warnings, including determining if a warning should be raised based on its tags.",
      "description_length": 289,
      "index": 1537,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Messages.Piece",
      "library": "goblint.common",
      "description": "This module defines a data structure for representing individual messages, such as warnings, with optional location information, text content, and contextual data. It includes functions for converting messages to and from JSON, comparing and hashing message instances, and extracting message text with context. Concrete use cases include serializing analysis results for external consumption and uniquely identifying and comparing messages during program analysis.",
      "description_length": 464,
      "index": 1538,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CfgTools",
      "library": "goblint.common",
      "description": "This module builds and analyzes control flow graphs using custom node and edge structures, enabling operations like SCC computation, CFG minimization, and reachability analysis. It supports concrete tasks such as detecting dead code in CIL-converted functions, tracking global initialization, and visualizing control flow for debugging. Submodules handle node styling, define formatting for graph output, and model SCCs with inter-component edges. Together, they enable detailed CFG manipulation, analysis, and customizable graphical representation.",
      "description_length": 549,
      "index": 1539,
      "embedding_norm": 1.0
    },
    {
      "module_path": "AnalysisState",
      "library": "goblint.common",
      "description": "This module manages global state flags used during program analysis to track conditions like warnings, memory safety violations, and termination status. It provides mutable references for boolean and optional boolean values that are updated in response to specific analysis events. These flags are used to control analysis behavior and report results, such as detecting potential overflows, invalid memory operations, or non-termination.",
      "description_length": 437,
      "index": 1540,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Node",
      "library": "goblint.common",
      "description": "This module enables comparison, serialization, and pretty-printing of control-flow graph (CFG) nodes, while exposing functionality to resolve enclosing",
      "description_length": 151,
      "index": 1541,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CilCfg0",
      "library": "goblint.common",
      "description": "Handles control flow graph (CFG) operations for CIL (C Intermediate Language) files. Provides the `end_basic_blocks` function to finalize basic blocks in the CFG, ensuring proper structure for analysis. Works directly with CIL's file and control flow data types, used during CFG construction to resolve dependencies.",
      "description_length": 316,
      "index": 1542,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "IntOps",
      "library": "goblint.common",
      "description": "This module unifies arithmetic, bitwise, and comparison operations across multiple integer representations, including native, 32-bit, 64-bit, and arbitrary-precision integers. It defines core data types like `int`, `int32`, `int64`, and `Z.t`, along with operations for conversion, hashing, comparison, and bitwise manipulation. Submodules extend these capabilities to specialized domains such as cryptographic algorithms, systems programming, and property-based testing, supporting tasks like overflow-safe conversions, GCD computation, and XML/Yojson serialization. Examples include performing precise financial calculations with big integers, implementing bit-level logic for 32-bit integers, and generating arbitrary integer values for testing cryptographic protocols.",
      "description_length": 772,
      "index": 1543,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "ResettableLazy",
      "library": "goblint.common",
      "description": "This module implements a lazy value that can be re-evaluated by resetting it to its original closure. It supports creating a lazy value from a function, forcing evaluation, and resetting the value to recompute on next access. Useful for caching results that need to be recomputed from the same source closure, such as reloading configuration or regenerating test data.",
      "description_length": 368,
      "index": 1544,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MessageUtil",
      "library": "goblint.common",
      "description": "This module controls terminal color output based on file descriptor properties. It detects if colors are supported on a given file descriptor and applies color codes to strings if supported. Useful for CLI tools that conditionally format output for terminals versus logs or pipes.",
      "description_length": 280,
      "index": 1545,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "CilLocation",
      "library": "goblint.common",
      "description": "This module provides functions to retrieve source code location information for CIL labels, instructions, and statements. It works with CIL's label, instr, and stmt data types, extracting their associated location details. Concrete use cases include tracking the origin of specific code elements during analysis or transformation tasks.",
      "description_length": 336,
      "index": 1546,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "UpdateCil0",
      "library": "goblint.common",
      "description": "This module coordinates node-to-location mappings to resolve dependency cycles during program analysis, combining imperative hash table operations with bulk update capabilities. It supports key operations like insertion, deletion, iteration, and sequence-based initialization, enabling efficient management of associations between nodes and metadata. Use it to dynamically track and modify source code locations for nodes, or apply transformations like filtering and folding to refine mappings in-place. The integrated hash table handles both individual and batch updates, making it suitable for analysis tasks that require precise node-centric data tracking.",
      "description_length": 659,
      "index": 1547,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "MyCFG",
      "library": "goblint.common",
      "description": "This module represents control-flow graphs with nodes for statements and functions, and edges for program transitions such as assignments, function calls, and tests. It provides core operations to build, compare, and hash edges, along with interfaces for forward, backward, and bidirectional graph traversal, enabling precise analysis of program flow and data dependencies. Child modules extend this foundation with hash tables for annotating nodes and edges with arbitrary data, tracking skipped statements, and performing path-sensitive analyses such as liveness and slicing. Together, these components support tasks like tracking variable states, annotating edges with branch conditions, and analyzing control flow in the presence of complex AST constructs.",
      "description_length": 760,
      "index": 1548,
      "embedding_norm": 1.0
    },
    {
      "module_path": "RichVarinfo",
      "library": "goblint.common",
      "description": "This module extends GoblintCil.varinfo handling with customizable data structures for mapping, marshaling, and comparing variable information. It introduces a parameterized type `t` that supports bidirectional associations, persistent storage via marshaling, and efficient key-based lookups using custom equality and hashing. With this module, you can track variable metadata across analysis phases, serialize variable state for checkpointing, and manage relationships such as aliasing or data flow between variables. Submodules provide hash-consed sets, bidirectional maps, and structured conversions between custom types and CIL variables, enabling precise and scalable static analysis workflows.",
      "description_length": 698,
      "index": 1549,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LazyEval",
      "library": "goblint.common",
      "description": "This module enables lazy evaluation of values from a parameter module, deferring computation until explicitly forced. It supports any data type through the parameter module's `t` and `result` types, allowing on-demand loading of expensive structures like large datasets. Operations include creating lazy values, forcing evaluation, and marshaling results. For example, it can delay reading a file's contents until accessed or cache the result of a costly calculation.",
      "description_length": 467,
      "index": 1550,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Edge",
      "library": "goblint.common",
      "description": "This module defines a CFG edge type representing program statements between control flow nodes, including assignments, function calls, conditionals, inline assembly, and variable declarations. It provides comparison, equality, hashing, and JSON serialization functions for these edge types. Concrete use cases include modeling control flow transitions in static analysis and serializing CFG edges for external tools or logging.",
      "description_length": 427,
      "index": 1551,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "ContextUtil",
      "library": "goblint.common",
      "description": "This module handles Goblint-specific C attributes and options for controlling analysis behavior. It provides functions to check for the presence of attributes and options in function declarations, and to determine whether certain attributes should be kept based on analysis settings. These operations are used to customize static analysis precision and context sensitivity in C code.",
      "description_length": 383,
      "index": 1552,
      "embedding_norm": 1.0
    },
    {
      "module_path": "FloatOps",
      "library": "goblint.common",
      "description": "This module offers a unified interface for working with 32-bit and 64-bit floating-point numbers, enabling precise control over rounding modes during arithmetic operations, comparisons, and conversions. It includes core functions for addition, multiplication, trigonometry, and square roots, along with support for converting between floating-point types and numeric representations such as integers and JSON. Child modules extend this functionality with specialized operations on abstract float types, enabling rigorous error tracking in interval arithmetic or financial computations. Examples include simulating scientific models with controlled rounding, serializing floats deterministically, and converting between arbitrary-precision and native floating-point values.",
      "description_length": 772,
      "index": 1553,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "XmlUtil",
      "library": "goblint.common",
      "description": "Converts special characters in a string to their corresponding XML entities. Works with raw string data to ensure valid XML output. Useful for generating XML content from user-provided or dynamic input strings.",
      "description_length": 210,
      "index": 1554,
      "embedding_norm": 1.0
    },
    {
      "module_path": "AnalysisStateUtil",
      "library": "goblint.common",
      "description": "This module defines a variant type for memory safety violations and provides a function to set a flag indicating a specific violation. It works with the analysis state to track issues like invalid memory operations during program execution. Use this module to report and handle memory safety errors such as invalid dereferences or improper memory cleanup in static analysis tools.",
      "description_length": 380,
      "index": 1555,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Printable",
      "library": "goblint.common",
      "description": "This module enables structured output, comparison, and serialization for a wide range of data types, from primitives to complex composites, by combining direct operations and submodules. It centers on a core type `t` that supports equality, ordering, and human-readable formatting via functions like `show`, `pretty`, `printXml`, and `to_yojson`, often parameterized through functors over base modules. Submodules handle unit values, integers, pairs, sums, lists, and tagged unions, each providing consistent comparison, hashing, and serialization to formats like XML and Yojson, while others support advanced use cases like hash-consing, priority queues, and name prefixing. Examples include pretty-printing a list of integers, serializing a sum type to JSON, or comparing hash-consed AST nodes with guaranteed physical equality.",
      "description_length": 830,
      "index": 1556,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Basetype",
      "library": "goblint.common",
      "description": "This module provides utilities for comparing, serializing, and transforming fundamental CIL constructs such as statements, expressions, variables, and strings. It supports precise equality, hashing, and pretty-printing operations tailored to each type, enabling tasks like static analysis, symbolic evaluation, and structured output generation. Key data types include `GoblintCil.stmt`, `GoblintCil.exp`, `GoblintCil.varinfo`, and `string`, each with dedicated manipulation and analysis functions. Examples include detecting variable occurrences in expressions, normalizing CIL code, serializing data to JSON or XML, and tracking variable scope and identity during analysis.",
      "description_length": 674,
      "index": 1557,
      "embedding_norm": 1.0
    },
    {
      "module_path": "GobFormat",
      "library": "goblint.common",
      "description": "This module provides functions for formatting and printing values with control over output geometry and ANSI color tags. It works with format strings and formatters to produce strings or output directly. Concrete use cases include generating colored terminal output and handling infinite-width formatting for pretty-printing data structures.",
      "description_length": 341,
      "index": 1558,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "ControlSpecC",
      "library": "goblint.common",
      "description": "This module provides operations for managing and comparing abstract context values used in dynamic analysis composition. It supports data types including a unique identifier-tagged context type, with functions for equality checks, hashing, string and XML representation, and QCheck arbitraries for testing. Concrete use cases include tracking analysis contexts during program verification and enabling context-aware decision-making in modular static analyses.",
      "description_length": 459,
      "index": 1559,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cilfacade0",
      "library": "goblint.common",
      "description": "This module provides functions to extract expression-level source code locations from CIL (C Intermediate Language) constructs such as labels, instructions, and statements. It includes utilities to retrieve precise location information, favoring expression locations over broader statement-level ones when available. Concrete use cases include improving precision in static analysis tools by tracking exact expression positions in the source code.",
      "description_length": 447,
      "index": 1560,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Timing",
      "library": "goblint.common",
      "description": "This module measures execution time of functions and programs, offering a `wrap` function to time computations with optional tracing. It supports hierarchical timing through submodules that track nested sections with start, stop, reset, enter, exit, and wrap operations, organizing data in timing trees. These trees can be pretty-printed for detailed performance reports, particularly useful in structured computations like program analysis passes. Example uses include profiling function performance and tracing execution duration across nested program phases.",
      "description_length": 561,
      "index": 1561,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Messages",
      "library": "goblint.common",
      "description": "This module generates and manages structured diagnostic messages with severity levels, locations, tags, and categories, using formatted documentation and location metadata. It supports conditional tracing, message grouping, indentation control, and deferred finalization through a message table, catering to static analysis tools requiring precise error reporting and categorized output. Main data types include messages with associated tags, severity levels, and source code locations, along with message groups and tables for bulk handling. Examples include filtering messages by severity, contextualizing errors with source locations, organizing trace messages by subsystem tags, and aggregating diagnostic data with message tables.",
      "description_length": 735,
      "index": 1562,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Node0",
      "library": "goblint.common",
      "description": "This module defines a polymorphic type `t` representing nodes in a control flow graph, specifically statements and functions from CIL. It provides operations for equality checking, comparison, hashing, and JSON serialization, along with extracting source code locations from nodes. It is used to manage node identities and relationships in analyses that require precise tracking of code elements without introducing dependency cycles.",
      "description_length": 434,
      "index": 1563,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CilType",
      "library": "goblint.common",
      "description": "This module provides utilities to serialize and compare CIL data structures into readable formats, supporting analysis and debugging through structured outputs. It handles core CIL types like variables, expressions, types, and attributes, offering operations for equality, hashing, pretty-printing, and conversion to JSON or XML. Submodules manage low-level constructs such as integer kinds and operators, alongside higher-level entities like functions, enums, and statements. Examples include normalizing type signatures, generating unique identifiers for variables, serializing attributes for storage, and converting expressions to JSON for external analysis tools.",
      "description_length": 667,
      "index": 1564,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Cilfacade",
      "library": "goblint.common",
      "description": "This module provides hash table utilities for mapping CIL statements, strings, source code locations, function declarations, integers, and variable information identifiers to arbitrary values, supporting imperative operations like insertion, lookup, and in-place modification, along with bulk updates from and to sequences. It enables efficient metadata tracking, analysis result aggregation, and transformation workflows across different key types, with specialized modules for statement-keyed tables, string-indexed collections, location-based annotations, function-specific data, integer-identified entries, and variable metadata. Examples include associating analysis results with CIL statements, tracking variable properties across functions, aggregating per-function metadata, or managing sparse integer mappings with custom data. Each submodule integrates sequence-based processing for scalable transformations and iterative analysis in static analysis tools.",
      "description_length": 966,
      "index": 1565,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MessageCategory",
      "library": "goblint.common",
      "description": "This module organizes program analysis messages using a polymorphic `category` type, with variants like `array_oob` and `cast` for classifying errors such as out-of-bounds array access and type conversion issues. It provides core operations to compare, hash, serialize to JSON, and convert between string paths and categories, enabling static analysis tools to classify and report diagnostics like undefined behavior, type mismatches, and runtime errors. The Integer submodule specializes in categorizing integer-related issues such as overflow and division-by-zero, supporting conversion from string lists and generation of precise diagnostic paths. The Behavior and Path submodules further structure categories around program behavior and string-based routing, allowing validation, transformation, and hierarchical classification of message routes in error reporting and analysis systems.",
      "description_length": 890,
      "index": 1566,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LoopUnrolling0",
      "library": "goblint.common",
      "description": "This module manages a hash table that maps keys to their copies, enabling efficient lookups of copies with `find_copyof` and reverse lookups of original keys with `find_original`. It supports imperative operations for statement keys, allowing in-place modifications through traversal, filtering, and folding, as well as bulk updates from sequences of key-value pairs. The module is designed for program analysis tasks, particularly for tracking variable copies during loop unrolling transformations. For example, it can map original statements to their unrolled copies or maintain multiple versions of variables during iterative analysis.",
      "description_length": 638,
      "index": 1567,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "GobConfig.Validator",
      "library": "goblint.config",
      "description": "Validates JSON configuration values against a schema encoding. Works with JSON schema representations and untyped configuration data. Used to enforce correct configuration structure during initialization or updates.",
      "description_length": 215,
      "index": 1568,
      "embedding_norm": 1.0
    },
    {
      "module_path": "JsonSchema.Schema",
      "library": "goblint.config",
      "description": "Handles schema definition and validation for JSON structures, providing functions to construct, validate, and manipulate JSON schemas. Works directly with JSON values and schema definitions, supporting operations like type checking, field validation, and schema composition. Useful for ensuring data conforms to expected formats during API input validation or configuration parsing.",
      "description_length": 382,
      "index": 1569,
      "embedding_norm": 1.0
    },
    {
      "module_path": "GobConfig.ValidatorRequireAll",
      "library": "goblint.config",
      "description": "Validates that all fields in a JSON schema are present in a given configuration. Works with JSON schema representations and configuration values. Used to enforce completeness of configuration data against a defined schema.",
      "description_length": 222,
      "index": 1570,
      "embedding_norm": 1.0
    },
    {
      "module_path": "JsonSchema.Validator",
      "library": "goblint.config",
      "description": "Validates JSON values against a schema representation, ensuring structural correctness. It provides `validate_exn`, which checks a JSON value and raises an exception if it does not conform to the schema. This module is used to enforce schema constraints during runtime, such as validating API inputs or configuration files.",
      "description_length": 323,
      "index": 1571,
      "embedding_norm": 1.0
    },
    {
      "module_path": "JsonSchema.JE",
      "library": "goblint.config",
      "description": "This module provides functions to convert values to and from JSON representations using encodings, specifically handling schema validation. It works with `Json_repr.Yojson.value` and generic types through `Json_encoding.encoding`. Concrete use cases include serializing and deserializing structured data according to a JSON schema, with support for custom encodings and schema-driven validation.",
      "description_length": 395,
      "index": 1572,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "GobConfig.S",
      "library": "goblint.config",
      "description": "This module provides direct access to a hierarchical, path-based configuration system using JSON values, with typed operations for integers, booleans, strings, and lists. It supports reading and writing the full configuration to files, merging configurations from files or JSON objects, and enforcing immutability during specific computations. Concrete use cases include loading and modifying analysis settings for a static analysis tool, dynamically adjusting parameters during execution, and persisting configuration changes to disk.",
      "description_length": 535,
      "index": 1573,
      "embedding_norm": 1.0
    },
    {
      "module_path": "JsonSchema.JS",
      "library": "goblint.config",
      "description": "Converts JSON schemas to and from Yojson values. Handles schema serialization and deserialization using a specific JSON representation. Useful for loading validation rules from JSON files or exporting schemas for external tools.",
      "description_length": 228,
      "index": 1574,
      "embedding_norm": 1.0
    },
    {
      "module_path": "GobConfig.Impl",
      "library": "goblint.config",
      "description": "This module provides direct access to a hierarchical, path-based configuration system using JSON values, with typed operations for retrieving and setting integers, booleans, strings, and lists. It supports loading and merging configurations from files or JSON objects, writing the current configuration to disk, and enforcing read-only access during specific computations. Concrete use cases include initializing application settings from a config file, dynamically modifying configuration values during runtime, and ensuring configuration integrity during critical operations.",
      "description_length": 577,
      "index": 1575,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "JsonSchema.JQ",
      "library": "goblint.config",
      "description": "This module provides functions to query, insert, replace, and merge JSON values using JSON Query paths. It operates directly on `Json_repr.Yojson.value` structures, enabling precise manipulation of JSON data trees. Use cases include extracting specific fields from JSON documents, updating nested values, and combining JSON objects recursively.",
      "description_length": 344,
      "index": 1576,
      "embedding_norm": 1.0
    },
    {
      "module_path": "GobConfig",
      "library": "goblint.config",
      "description": "This module enables path-based querying and modification of JSON-backed configurations with typed value access for integers, booleans, strings, and lists. It supports bulk operations like merging hierarchical configurations from files or objects, enforces immutability constraints, and manages global runtime parameters such as concurrency limits and initialization flags. Submodules provide schema validation, completeness checks, and direct access to hierarchical configuration data, enabling tasks like dynamic reloading, cross-module consistency validation, and controlled global state updates. Specific use cases include initializing application settings, modifying analysis parameters at runtime, and persisting configuration changes to disk while ensuring structural correctness and completeness.",
      "description_length": 803,
      "index": 1577,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Options",
      "library": "goblint.config",
      "description": "This module provides operations for inspecting, validating, and printing configuration options based on a JSON schema. It works with JSON schemas, Yojson values, and string lists to support concrete use cases like generating configuration completions, extracting field paths, and printing structured documentation. Functions enable direct access to default values, required fields, and nested schema elements for precise configuration handling.",
      "description_length": 444,
      "index": 1578,
      "embedding_norm": 1.0
    },
    {
      "module_path": "JsonSchema",
      "library": "goblint.config",
      "description": "This module enables working with JSON schemas and Yojson values for validation, conversion, and manipulation. It supports validating JSON data against schemas, generating defaults, and serializing or deserializing structured data with schema-driven constraints. Operations include schema-to-Yojson conversion, runtime validation with exception handling, and precise JSON tree manipulation using query paths. Example uses include validating API inputs, generating sample JSON from schemas, and dynamically modifying or extracting nested JSON values.",
      "description_length": 548,
      "index": 1579,
      "embedding_norm": 1.0
    },
    {
      "module_path": "AfterConfig",
      "library": "goblint.config",
      "description": "Registers and executes callback functions that run after runtime configuration is fully loaded. It maintains a list of unit functions, allowing modules to register setup or initialization logic that depends on fully loaded configuration data. This is used to trigger post-configuration steps such as initializing services or applying runtime settings.",
      "description_length": 351,
      "index": 1580,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.TwoPhased.W.XY.HPM.Labels",
      "library": "goblint.solver",
      "description": "This module implements a labeled map structure for handling key-value pairs with thread-local and global contributions in constraint-solving contexts. It provides operations for adding, modifying, filtering, and transforming entries based on keys and values, supporting both in-place and functional-style updates. Concrete use cases include tracking and merging analysis results across program points in static analysis of multi-threaded C programs.",
      "description_length": 449,
      "index": 1581,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.TwoPhased.N.XY.HPM.Infix",
      "library": "goblint.solver",
      "description": "This module provides direct access and modification operations for keyed values within a multi-threaded constraint system. It works with a map-like structure parameterized by a key type and a value type, supporting get and set operations via the `-->` and `<--` operators. Concrete use cases include tracking and updating thread-specific contributions to shared global variables during static analysis.",
      "description_length": 402,
      "index": 1582,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.TwoPhased.W.XY.HPM.Exceptionless",
      "library": "goblint.solver",
      "description": "This module provides `find` and `modify` operations for safely accessing and updating values associated with keys in a structured map. It works with typed maps (`'a W.XY.HPM.t`) and key-based data representations. Concrete use cases include tracking and adjusting per-key state in constraint-solving processes without handling exceptions explicitly.",
      "description_length": 349,
      "index": 1583,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.TwoPhased.W.XY.HPM.Infix",
      "library": "goblint.solver",
      "description": "This module defines bidirectional operations between a polymorphic value and a key-based structure, enabling direct value-key mapping and retrieval. It works with a polymorphic type `'a t` and a key type `W.XY.HPM.key`, supporting get and set operations via `(-->)` and `(<--)`. Concrete use cases include managing per-key state in constraint solvers, such as tracking thread-local contributions in multi-threaded program analysis.",
      "description_length": 431,
      "index": 1584,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.TwoPhased.N.XY.HPM.Labels",
      "library": "goblint.solver",
      "description": "This module implements a labeled map structure for managing thread-local and global contributions in constraint systems, with support for key-based insertion, modification, and traversal operations. It provides functions for mapping, filtering, folding, and merging data associated with keys of type `N.XY.HPM.key`, enabling precise handling of per-label state in multi-threaded analysis. Use cases include tracking memory locations, variable assignments, or synchronization states across different phases of a solver.",
      "description_length": 518,
      "index": 1585,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.TwoPhased.N.XY.HPM.Exceptionless",
      "library": "goblint.solver",
      "description": "Implements operations to safely query and update values associated with global contributions in a constraint system. Works with key-value structures where keys identify contributions and values represent their states. Used when analyzing multi-threaded C programs to track and refine global variable modifications across threads without exception handling.",
      "description_length": 356,
      "index": 1586,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.Make0.XY.HPM.Exceptionless",
      "library": "goblint.solver",
      "description": "This module provides operations for safely querying and modifying a map-like structure that tracks global contributions in a constraint-solving context. It works with polymorphic map (`'a t`) and key types, handling modifications with fallible updates that return a result type. Concrete use cases include managing per-key state during static analysis of multi-threaded C programs, where updates may fail due to side effects or inconsistencies.",
      "description_length": 444,
      "index": 1587,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.TwoPhased.N.H.HeapCompare",
      "library": "goblint.solver",
      "description": "Implements a heap comparison mechanism for variable keys in a priority queue, using a custom ordering function. It operates on types defined by `S.Var.t` and `HM.key`, which represent variables and heap map keys, respectively. This module is used to prioritize variables during constraint solving in multi-threaded analysis, where heap-allocated variables require specialized ordering.",
      "description_length": 385,
      "index": 1588,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.Make0.XY.HPM.Labels",
      "library": "goblint.solver",
      "description": "This module provides operations for manipulating key-value maps with efficient in-place updates, filtering, and transformation functions. It works with typed maps parameterized over their data and key types, supporting conditional modification and merging of entries. Concrete use cases include tracking and updating per-key state during constraint solving, such as propagating and refining global variable contributions in a multi-threaded analysis.",
      "description_length": 450,
      "index": 1589,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_solver.SLR.TwoPhased.W.XY.HPM",
      "library": "goblint.solver",
      "description": "This module manages polymorphic key-value mappings with imperative hash table operations and functional transformations, optimized for tracking intermediate state in multi-threaded constraint solvers. It provides a hash map type (`W.XY.HPM.t`) supporting efficient mutation, filtering, merging, and conversion to sequences or lists, along with customizable formatting for debugging. Submodules extend this with labeled maps for thread-local and global contributions, safe key-based access and modification without exceptions, and direct bidirectional mappings between values and keys using infix operators. Example uses include merging analysis results from concurrent threads, iterating over program points, and maintaining per-key solver state in static analysis of C programs.",
      "description_length": 779,
      "index": 1590,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.TwoPhased.N.XY.HPM",
      "library": "goblint.solver",
      "description": "This module provides a hash-based map structure for efficient storage and manipulation of key-value pairs with keys of type `N.XY.P.t`, supporting operations like `add`, `find`, `remove`, `mem`, and `fold`. It enables advanced transformations such as filtering, merging, and conversion to sequences or lists, along with I/O handling for formatted output, making it suitable for tracking global contributions in multi-threaded C analysis workflows. Submodules extend this functionality by offering direct access via `-->` and `<--` operators, labeled map management for thread-local and global state, and safe querying mechanisms for constraint system solving. Together, they facilitate precise handling of memory locations, variable assignments, and synchronization states across threads during static analysis.",
      "description_length": 811,
      "index": 1591,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.TwoPhased.W.XY.P",
      "library": "goblint.solver",
      "description": "This module defines a data type representing pairs of variables used to track global contributions in multi-threaded analysis. It provides equality and hashing operations for these pairs, enabling their use in sets and maps. These operations support precise tracking of variable interactions in constraint systems for thread analysis.",
      "description_length": 334,
      "index": 1592,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.Make0.XY.HPM.Infix",
      "library": "goblint.solver",
      "description": "This module provides direct access and mutation operations for key-value pairs within a solver-specific data structure, using the `-->` and `<--` operators. It works with the `XY.HPM.t` type, which represents a map from keys to values in the context of constraint solving. Concrete use cases include querying and updating solver state during analysis of multi-threaded programs, particularly for tracking global variable contributions.",
      "description_length": 435,
      "index": 1593,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_solver.SLR.Make.XY.HPM.Labels",
      "library": "goblint.solver",
      "description": "This module provides operations for manipulating key-value maps with efficient in-place updates, filtering, and transformation functions. It supports data types with keys of type `XY.HPM.key` and values of arbitrary type `'a`, enabling precise tracking and modification of per-key state in constraint-solving contexts. Concrete use cases include managing thread-local contributions in static analysis of multi-threaded C programs, where keys represent program points or variables and values encode abstract memory states or constraints.",
      "description_length": 536,
      "index": 1594,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.TwoPhased.N.XY.P",
      "library": "goblint.solver",
      "description": "This module defines a type `t` as a pair of variables and provides equality and hashing operations for these pairs. It is used to represent and compare value contributions in constraint systems involving two variables. These operations support efficient analysis of multi-threaded programs by enabling precise tracking of variable interactions.",
      "description_length": 344,
      "index": 1595,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.JustWiden.XY.HPM.Infix",
      "library": "goblint.solver",
      "description": "This module defines two operations: `(-->)` for retrieving values associated with a key in a global contributions map, and `(<--)` for updating a key with a new value. It works with maps (`XY.HPM.t`) that store values indexed by keys (`XY.HPM.key`). These operations are used to manipulate per-variable state in constraint solvers, particularly during fixed-point computations in static analysis of multi-threaded C programs.",
      "description_length": 425,
      "index": 1596,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.Td3.Base.CurrentVarS.S.Var",
      "library": "goblint.solver",
      "description": "This module represents variables in a constraint system, providing operations for equality checks, hashing, comparison, and identification. It works with variable types tied to control-flow nodes and supports pretty-printing and XML serialization. Concrete use cases include tracking variable states during constraint solving and managing variable identities in a CFG-based analysis.",
      "description_length": 383,
      "index": 1597,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.Td3.Base.CurrentVarS.S.Dom",
      "library": "goblint.solver",
      "description": "The module provides lattice operations (join, meet, widen, narrow) and utilities for comparing, serializing, and transforming abstract domain elements, which are essential for static program analysis. It operates on an abstract domain type `t` representing lattice elements in a constraint system, supporting operations like `leq`, `top`, and `is_top` to model hierarchical relationships. These capabilities enable efficient incremental analysis and interactive re-evaluation of programs by managing abstract values during fixed-point computations.",
      "description_length": 548,
      "index": 1598,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_solver.SLR.Make.XY.HPM.Exceptionless",
      "library": "goblint.solver",
      "description": "This module provides operations to safely query and update a map-like structure where values are associated with keys. It supports retrieving values by key and modifying them in place, handling potential exceptions during modification. It is useful for managing per-key state in constraint-solving contexts where errors must be explicitly handled.",
      "description_length": 347,
      "index": 1599,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.Make.XY.HPM.Infix",
      "library": "goblint.solver",
      "description": "This module provides direct get and set operations for value mappings in a constraint system, using the `-->` and `<--` operators. It works with key-value pairs where keys are of type `XY.HPM.key` and values are polymorphic. It is used to manipulate per-key contributions in a solver context, such as tracking thread-local state or shared memory effects in static analysis.",
      "description_length": 373,
      "index": 1600,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_solver.SLR.JustWiden.XY.HPM.Exceptionless",
      "library": "goblint.solver",
      "description": "This module provides operations for safely querying and modifying values associated with keys in a map structure, specifically designed for handling global contributions in constraint systems. It works with map-like structures where keys are of a specific type and values are of a generic type `'a`. Concrete use cases include tracking and updating global state information during static analysis of multi-threaded programs, particularly in scenarios requiring precise handling of widening operations without exceptions.",
      "description_length": 520,
      "index": 1601,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_solver.SLR.JustWiden.XY.HPM.Labels",
      "library": "goblint.solver",
      "description": "This module provides operations for manipulating key-value maps with labeled keys, including adding, replacing, filtering, mapping, and merging entries. It supports data types like `'a XY.HPM.t` which represent polymorphic maps indexed by `XY.HPM.key`. These functions are used to manage and transform global contribution values during constraint system solving in static analysis of multi-threaded C programs.",
      "description_length": 410,
      "index": 1602,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.TwoPhased.W.H.HeapCompare",
      "library": "goblint.solver",
      "description": "Implements a heap comparison mechanism for priority queues using variable keys. It provides a `compare` function that orders heap keys based on variable identifiers. This supports efficient scheduling and processing of constraints in multi-threaded analysis scenarios.",
      "description_length": 268,
      "index": 1603,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.TwoPhased.W.P",
      "library": "goblint.solver",
      "description": "This module provides operations for managing a set of keys within a constraint system, specifically supporting insertion, removal, membership checks, and conversion to a list of keys. It works with a hidden map (HM) data structure, where keys represent variables or constraints in the analysis of multi-threaded C programs. Concrete use cases include tracking dependencies of global variables and maintaining stable sets during fixed-point computations in static analysis.",
      "description_length": 472,
      "index": 1604,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.PrintInfluence.S1.X",
      "library": "goblint.solver",
      "description": "Implements influence analysis for constraint systems using a first-order SLR solver. It tracks variable dependencies through hash maps (`HM.t`) and provides functions to print influence graphs based on constraint keys. Useful for analyzing how changes in variables propagate through multi-threaded C program constraints.",
      "description_length": 320,
      "index": 1605,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.TopDown_deprecated.TD3.HPM.Labels",
      "library": "goblint.solver",
      "description": "This module provides hash table operations for managing key-value pairs where keys are of type `HPM.key` and values are polymorphic. It supports standard imperative operations like `add`, `replace`, `modify`, and in-place transformations with functions that operate on both keys and values. Concrete use cases include efficiently maintaining and transforming constraint system labels during analysis in a deprecated top-down solver implementation.",
      "description_length": 447,
      "index": 1606,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLRphased.Make.HPM.Exceptionless",
      "library": "goblint.solver",
      "description": "This module provides a two-phased SLR3 solver for constraint systems using a box abstraction with a hash-based map (HPM), handling modifications and lookups in a stateful manner. It supports operations like `find` for retrieving values by key and `modify` for updating values, both working directly with HPM.t maps and keys. It is used in static analysis to solve dataflow equations with precise, efficient propagation of constraints.",
      "description_length": 434,
      "index": 1607,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.TopDown_deprecated.TD3.VS.Exceptionless",
      "library": "goblint.solver",
      "description": "This module provides operations for querying and selecting elements from a set structure `VS.t`, including retrieving minimum, maximum, and arbitrary elements. It supports concrete use cases like iterating through elements in a specific order or extracting representative values from a constraint solution set. Functions like `find` enable direct lookups, while `choose` and `any` support non-deterministic selection strategies in analysis workflows.",
      "description_length": 450,
      "index": 1608,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLRterm.SLR3term.VS.Exceptionless",
      "library": "goblint.solver",
      "description": "This module provides operations for querying and selecting elements from a set structure, including retrieving the minimum, maximum, or arbitrary elements. It works with sets (`VS.t`) containing elements of type `VS.elt`, supporting lookup and selection without raising exceptions. Concrete use cases include safely extracting representative values from constraint solution sets during analysis phases in a static analyzer.",
      "description_length": 423,
      "index": 1609,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_solver.SLR.TwoPhased.N.XY",
      "library": "goblint.solver",
      "description": "This module manages global contribution values using a map structure, providing direct access via keys with `get_value` and `set_value`, and falling back with `hpm_find_default`. It pairs keys from `N.XY.HPM.key` with values from `S.Dom.t`, enabling precise global state tracking in constraint solving. The child module offers a hash-based map for key-value pairs of `N.XY.P.t`, supporting operations like `add`, `find`, and `fold`, along with advanced transformations and I/O handling. A secondary submodule defines a pair type for representing two-variable contributions, with equality and hashing to track variable interactions in multi-threaded analysis.",
      "description_length": 658,
      "index": 1610,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.TwoPhased.N.D",
      "library": "goblint.solver",
      "description": "This module implements lattice operations and domain-specific utilities for analyzing abstract values in static program analysis. It operates on the domain type `N.D.t`, providing core functionalities like join/meet operations, widening/narrowing for convergence, and top/bottom element checks, alongside support for equality comparison, serialization, and XML printing. These capabilities enable its use in constraint system solvers for verifying multi-threaded C programs, particularly in contexts requiring precise abstract domain manipulations.",
      "description_length": 548,
      "index": 1611,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_solver.SLR.TwoPhased.N.P",
      "library": "goblint.solver",
      "description": "This module provides operations for managing a set of keys within a constraint system, specifically supporting insertion, removal, membership checks, and conversion to a list of keys. It works with a key type and a map type (`HM.t`) that associates keys with unit values. It is used for tracking dependencies related to global variables and stable sets during analysis of multi-threaded C programs.",
      "description_length": 398,
      "index": 1612,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.TopDown_space_cache_term.WP.VS.Labels",
      "library": "goblint.solver",
      "description": "This module operates on sets of labels, providing iteration, folding, filtering, and mapping functions tailored for label set manipulation. It supports operations like checking properties across all elements, transforming elements, and partitioning sets based on predicates. These functions are used to analyze and manipulate label-based constraints in a top-down solver context.",
      "description_length": 379,
      "index": 1613,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_solver.SLR.TwoPhased.W.X",
      "library": "goblint.solver",
      "description": "This module manages value and priority associations for constraint solving, using hash maps to store domain-specific values and keys. It provides direct access and mutation operations for keyed values, along with key generation and indexing functionality. Concrete use cases include tracking and retrieving constraint variable values during solver iterations.",
      "description_length": 359,
      "index": 1614,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.SLR3.VS.Labels",
      "library": "goblint.solver",
      "description": "This module provides operations for manipulating sets of labels, including iteration, folding, filtering, mapping, and partitioning. It works with the `VS.t` type representing sets of label elements. Concrete use cases include tracking and transforming sets of program labels during constraint system solving in static analysis of multi-threaded C programs.",
      "description_length": 357,
      "index": 1615,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.PostSolver.MakeList.S.Var",
      "library": "goblint.solver",
      "description": "This module provides operations for comparing, hashing, and inspecting variable identifiers, including checks for write-only status and XML printing. It works with the abstract variable type `S.Var.t`, which represents variables in the constraint system. Concrete use cases include tracking variable identities across constraint evaluations, generating readable traces, and supporting node-specific analysis in static code checking.",
      "description_length": 432,
      "index": 1616,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLRphased.Make.VS.Exceptionless",
      "library": "goblint.solver",
      "description": "This module provides operations for querying and selecting elements from a set structure, including retrieving minimum, maximum, arbitrary, and specific elements. It works with set types defined by the `VS` module, which represent collections of elements. Concrete use cases include extracting representative values during constraint solving or analyzing possible outcomes in static analysis phases.",
      "description_length": 399,
      "index": 1617,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.Make0.H.HeapCompare",
      "library": "goblint.solver",
      "description": "This module defines a comparison function for variables used as keys in a priority queue, specifically ordering `S.Var.t` values to enable efficient prioritization during constraint solving. It is used to determine the processing order of variables in the solver's worklist algorithm. The comparison supports concrete use cases like prioritizing variables based on their dependencies or impact to optimize convergence in multi-threaded analysis.",
      "description_length": 445,
      "index": 1618,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_solver.SLR.TwoPhased.W.T",
      "library": "goblint.solver",
      "description": "This module tracks variable dependencies and settings for constraint system solving. It uses hash maps (`HM.t`) to store and update variable values, supporting operations to retrieve (`sub`), modify (`update`), and manage dependencies (`set`). Concrete use cases include managing variable assignments during static analysis of multi-threaded C programs.",
      "description_length": 353,
      "index": 1619,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLRphased.Make.HPM.Infix",
      "library": "goblint.solver",
      "description": "This module provides imperative get and set operations for a constraint solver's phase management using the `HPM` (Hierarchical Phase Map) structure. It allows associating values with keys in a mutable table, where `-->` retrieves a value for a given key and `<--` updates a key-value pair in place. This is used to track and update intermediate constraint states during the two-phased solving process.",
      "description_length": 402,
      "index": 1620,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.TopDown_deprecated.TD3.HPM.Exceptionless",
      "library": "goblint.solver",
      "description": "This module implements a top-down constraint-solving strategy based on a modified SLR3 algorithm, operating on constraint systems represented in HPM structures. It provides operations to find and modify constraint values by key, returning results in a wrapped type that handles potential errors. Use cases include analyzing program properties where constraints are resolved in a top-down manner without exception handling overhead.",
      "description_length": 431,
      "index": 1621,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_solver.Td3.Base.VS.Exceptionless",
      "library": "goblint.solver",
      "description": "Implements set operations for a constraint-solving context where elements are optionally retrieved without exceptions. Works with sets of type `VS.t` and elements of type `VS.elt`, typically representing abstract values in a lattice. Useful for querying minimal, maximal, or arbitrary elements during fixed-point computations where missing elements indicate empty sets.",
      "description_length": 369,
      "index": 1622,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_solver.PostSolver.MakeList.VH.Labels",
      "library": "goblint.solver",
      "description": "This module provides operations for manipulating hash tables with keys of type `VH.key` and values of a fixed type, including insertion, modification, filtering, and traversal functions. It supports concrete tasks like updating constraint labels in place, filtering labels based on analysis results, and merging constraint data from multiple sources. Use cases include refining analysis results, pruning irrelevant constraints, and generating targeted warnings based on label-specific conditions.",
      "description_length": 496,
      "index": 1623,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.SLR3.HPM.Exceptionless",
      "library": "goblint.solver",
      "description": "Implements a constraint-solving box for handling multi-threaded C analysis without exceptions. It provides `find` to retrieve values from a constraint map and `modify` to update them, returning a result type to handle failures explicitly. Designed for use in static analysis tools where safe, explicit error handling is critical.",
      "description_length": 329,
      "index": 1624,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.TopDown.WP.VS.Labels",
      "library": "goblint.solver",
      "description": "This module implements label management for a top-down solver, handling sets of labels with operations like iteration, folding, filtering, and partitioning. It works with a set type `VS.t` representing label collections, supporting transformations and predicate-based selection. Concrete use cases include tracking analysis states, managing constraint dependencies, and selectively processing labels during solver execution.",
      "description_length": 424,
      "index": 1625,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_solver.SLRphased.Make.HPM.Labels",
      "library": "goblint.solver",
      "description": "This module provides hash-preserving map operations for constraint system solving, including key-based addition, modification, filtering, and merging with custom functions. It works with HPM (Hash-Preserving Map) data structures, where each entry is associated with a key and a value. These operations are used to manipulate constraint sets during the two-phased SLR3 solving process, enabling precise and efficient analysis of program properties.",
      "description_length": 447,
      "index": 1626,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_solver.SLR.TwoPhased.N.L",
      "library": "goblint.solver",
      "description": "This module implements operations for maintaining and querying influence lists, which track dependencies between variables in constraint systems. It provides functions to add an element to a variable's influence list, retrieve and remove all elements for a variable, and remove a specific element from a variable's list. These operations are used during fixed-point computations to efficiently manage variable dependencies and propagate changes.",
      "description_length": 445,
      "index": 1627,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.TopDown_deprecated.TD3.VS.Labels",
      "library": "goblint.solver",
      "description": "This module provides standard set operations such as iteration, folding, filtering, and mapping over a set of labels. It works with the `VS.t` type, representing a set of label elements, and supports predicate-based transformations and queries. Concrete use cases include analyzing and manipulating sets of program labels during constraint solving in static analysis.",
      "description_length": 367,
      "index": 1628,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.Make.XY.HPM",
      "library": "goblint.solver",
      "description": "This module manages mutable key-value mappings with imperative hash table operations, supporting insertion, deletion, iteration, and transformations over polymorphic hash maps (`'a t`). It enables efficient in-place modifications, merging, and filtering of data indexed by keys of type `XY.P.t`, with direct access via operators like `-->` and `<--` for setting and retrieving values. Submodules enhance this functionality with safe querying, error handling during updates, and specialized operations for tracking per-key state in constraint systems, such as analyzing thread-local or shared memory effects in multi-threaded programs.",
      "description_length": 634,
      "index": 1629,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.TopDown_term.WP.VS.Exceptionless",
      "library": "goblint.solver",
      "description": "This module provides operations for querying and selecting elements from a set-like structure `VS.t`, including retrieving minimum, maximum, arbitrary, or specific elements. It supports concrete use cases such as extracting representative values during constraint solving or analyzing elements in a domain without exceptions. The functions operate directly on `VS.t` and return optional elements, enabling safe and controlled traversal or inspection of value sets.",
      "description_length": 464,
      "index": 1630,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.PostSolver.MakeList.S.Dom",
      "library": "goblint.solver",
      "description": "This module provides lattice operations (join, meet, widen, narrow) and utilities for comparison, printing, and arbitrary value generation on abstract domain elements (`S.Dom.t`) representing program states. These operations enable constraint solving and post-solving tasks like pruning, verification, and warning generation by manipulating abstract states during static analysis. The domain elements model program state abstractions, supporting analysis through standard lattice transformations and comparisons.",
      "description_length": 512,
      "index": 1631,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.Make0.XY.P",
      "library": "goblint.solver",
      "description": "This module defines a data type `t` as a pair of variables and provides operations for equality checking and hashing. It supports efficient comparison and hashing of variable pairs, which is essential for tracking global contributions in constraint systems. Concrete use cases include managing and analyzing relationships between variables in multi-threaded C programs during static analysis.",
      "description_length": 392,
      "index": 1632,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_solver.SLR.JustWiden.XY.HPM",
      "library": "goblint.solver",
      "description": "This module implements imperative hash table operations and dictionary-style manipulations for polymorphic maps with keys of type `XY.HPM.key`, supporting efficient addition, lookup, bulk modification, merging, and key-value transformations. It includes submodules that define infix operators for value retrieval and update, safe querying and modification under constraint systems, and labeled key manipulations for filtering and mapping. The API enables handling global contributions in static analysis of multi-threaded C programs, particularly during fixed-point computations and widening operations. Examples include using `-->` to fetch variable states, `<--` to update them, and higher-order functions to transform or merge map entries.",
      "description_length": 742,
      "index": 1633,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_solver.Worklist.Make.VS.Exceptionless",
      "library": "goblint.solver",
      "description": "This module implements a worklist solver for constraint systems using a set-like structure, supporting operations to select elements based on minimum, maximum, or arbitrary criteria. It operates on data structures from the `VS` (Variable Set) module, which represent collections of elements without exceptions during traversal. Concrete use cases include solving dataflow analysis constraints in program analysis, where elements are processed iteratively until a fixed point is reached.",
      "description_length": 486,
      "index": 1634,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.SLR3.HPM.Labels",
      "library": "goblint.solver",
      "description": "This module provides operations for manipulating hash-based polymorphic maps with labeled keys, including adding, replacing, filtering, mapping, and merging entries. It supports in-place modifications and conditional transformations, enabling precise control over key-value associations. These operations are used for managing abstract analysis labels in constraint-solving contexts, such as tracking thread-local state or variable bindings during static analysis of concurrent programs.",
      "description_length": 487,
      "index": 1635,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_solver.Worklist.Make.VS.Labels",
      "library": "goblint.solver",
      "description": "Implements a worklist solver for constraint systems using a set of labels, where each label represents a node or variable in the analysis. It provides operations to iterate, fold, filter, and map over the labels, enabling precise control over the propagation of constraints during fixed-point computation. This module is used to manage the order and conditions under which constraints are processed, improving solver efficiency and precision in static analysis tasks.",
      "description_length": 467,
      "index": 1636,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_solver.TopDown.WP.VS.Exceptionless",
      "library": "goblint.solver",
      "description": "This module provides operations for querying and selecting elements from a set-like structure `VS.t`, including retrieving minimum, maximum, and arbitrary elements. It supports concrete use cases such as extracting representative values or bounds from abstract domains during constraint solving. Functions like `find` enable direct lookup, while `choose` and `any` assist in non-deterministic selection for analysis steps.",
      "description_length": 422,
      "index": 1637,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_solver.TopDown_term.WP.VS.Labels",
      "library": "goblint.solver",
      "description": "This module implements label management for weakest precondition calculations in a constraint solver, handling sets of variables with operations like mapping, filtering, and partitioning. It works with variable sets (`VS.t`) and their elements (`VS.elt`), supporting transformations and inspections over these sets. Concrete use cases include tracking variable dependencies and side effects during constraint resolution.",
      "description_length": 420,
      "index": 1638,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_solver.SLR.TwoPhased.W.L",
      "library": "goblint.solver",
      "description": "This module implements operations for maintaining and querying influence lists, which track dependencies between variables in constraint systems. It provides functions to add an element to a variable's influence list, retrieve and remove a variable's entire influence list, and remove a specific item from a variable's list. These operations are used during fixed-point computations to efficiently manage dependencies and re-evaluate affected variables when changes occur.",
      "description_length": 472,
      "index": 1639,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.TopDown_deprecated.TD3.HPM.Infix",
      "library": "goblint.solver",
      "description": "This module provides two primary operations: `(-->)` for retrieving values associated with a key from a hash-based priority map, and `(<--)` for inserting or updating a key-value pair in the map. It works with hash-based priority maps (`HPM.t`) that associate keys of type `HPM.key` with arbitrary values. These operations are used to manage and query constraint-solving state in a top-down analysis, where keys represent program points or variables and values represent associated abstract states or constraints.",
      "description_length": 513,
      "index": 1640,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.PostSolver.MakeList.VH.Infix",
      "library": "goblint.solver",
      "description": "This module provides infix operators `(-->)` and `(<--)` for accessing and modifying values in a hash table-like structure `VH.t`. It works directly with `VH.t`, a hash table implementation keyed by `VH.key`, allowing for concise get and set operations. Concrete use cases include efficiently querying and updating constraint solution values during post-processing passes in a constraint solver.",
      "description_length": 395,
      "index": 1641,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLRterm.SLR3term.HPM.Exceptionless",
      "library": "goblint.solver",
      "description": "This module provides `find` and `modify` operations for handling a map structure where keys are of type `HPM.key` and values are of a polymorphic type `'a`. It supports safe lookup and in-place modification of map entries, returning results in a `BatPervasives.result` type to handle potential errors without exceptions. Concrete use cases include managing stateful configurations or constraint system variables where modifications must be applied atomically and lookups need to handle absence explicitly.",
      "description_length": 505,
      "index": 1642,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLRterm.SLR3term.VS.Labels",
      "library": "goblint.solver",
      "description": "This module provides operations for manipulating sets of labels, including iteration, folding, filtering, and partitioning. It works with the `VS.t` type representing sets of label elements. Concrete use cases include tracking and transforming sets of variables or constraints during the solving process in a constraint system.",
      "description_length": 327,
      "index": 1643,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_solver.TopDown.WP.HPM.Exceptionless",
      "library": "goblint.solver",
      "description": "This module provides operations for querying and updating a constraint system using a top-down approach without handling exceptions. It works with constraint stores represented as HPM.t maps, where keys identify constraints and values represent their associated data. Concrete use cases include solving constraint systems in static analysis by propagating constraints from a root node downward, modifying constraint values based on existing state, and retrieving resolved constraint values efficiently.",
      "description_length": 502,
      "index": 1644,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.TwoPhased.N.X",
      "library": "goblint.solver",
      "description": "This module manages value and priority associations for constraint solving, using a hash table (`HM.t`) to store domain-specific values (`S.Dom.t`) and integer keys. It provides direct access and mutation operations for values and keys, supporting dynamic indexing with `get_index` and snapshotting via `to_list`. Concrete use cases include tracking and updating variable priorities during solver iterations in multi-threaded analysis.",
      "description_length": 435,
      "index": 1645,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.TwoPhased.N.T",
      "library": "goblint.solver",
      "description": "This module tracks variable dependencies and settings for constraint solving. It uses hash maps (`HM.t`) to store and update variable values, supporting operations to retrieve (`sub`), modify (`update`), and set dependencies (`set`). It is used during analysis of multi-threaded C programs to manage variable states across threads.",
      "description_length": 331,
      "index": 1646,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.TopDown_space_cache_term.WP.VS.Exceptionless",
      "library": "goblint.solver",
      "description": "This module provides operations for querying and selecting elements from a set structure, including retrieving minimum, maximum, arbitrary, and specific elements. It works with sets represented by the `VS.t` type and individual elements of type `VS.elt`. Concrete use cases include efficiently extracting representative values during constraint solving or analysis without side effects.",
      "description_length": 386,
      "index": 1647,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.TwoPhased.W.XY",
      "library": "goblint.solver",
      "description": "This module manages global value contributions using a hash-based map structure, supporting key-value lookups with defaults, direct get/set operations, and efficient mutation on a shared map. It handles domain-specific values during constraint solving in multi-threaded analysis, with data types like hash maps (`W.XY.HPM.t`) and variable pairs for tracking interactions. Operations include merging, filtering, and converting to sequences, with submodules extending functionality for thread-local and global contributions, safe key access, and bidirectional mappings. Example uses include combining analysis results from concurrent threads and maintaining per-key solver state in static analysis of C programs.",
      "description_length": 710,
      "index": 1648,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_solver.SLR.TwoPhased.W.D",
      "library": "goblint.solver",
      "description": "This module implements lattice operations and domain manipulations for abstract interpretation-based analysis of multi-threaded C programs, including join/meet for value approximation, widening/narrowing for convergence control, and equality checks. It operates on abstract domain elements of type `W.D.t` that model program states in a solver framework designed for concurrent systems. These operations enable static analysis of thread interactions and shared memory accesses while ensuring computational tractability through lattice semantics.",
      "description_length": 545,
      "index": 1649,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_solver.TopDown.WP.HPM.Labels",
      "library": "goblint.solver",
      "description": "This module provides operations for manipulating hash-based polymorphic maps (HPM) with key-value pairs, supporting transformations, filtering, and in-place modifications. It works directly with HPM.t collections, using HPM.key for indexing and arbitrary data types for values. Concrete use cases include tracking and updating constraint system states during top-down solving, such as propagating and refining variable bindings or managing per-key computation results.",
      "description_length": 468,
      "index": 1650,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLRterm.SLR3term.HPM.Labels",
      "library": "goblint.solver",
      "description": "This module provides operations for manipulating hash-based polymorphic maps (HPM) with typed keys, supporting imperative updates and functional transformations. It includes functions for adding, replacing, modifying, and filtering key-value pairs, as well as merging maps and folding over their contents. Concrete use cases include tracking and transforming constraint system labels during analysis in a solver, such as updating variable bindings or filtering out obsolete constraints.",
      "description_length": 486,
      "index": 1651,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.EffectWConEq.Make.VS.Labels",
      "library": "goblint.solver",
      "description": "This module provides operations for transforming and querying sets of labels, including mapping, filtering, and partitioning. It works with sets of elements of type `VS.elt`, supporting iteration, folding, and boolean checks over these sets. Concrete use cases include processing sets of variables or expressions in static analysis, where labels represent program elements subject to constraints.",
      "description_length": 396,
      "index": 1652,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_solver.Td3.Base.CurrentVarS.S",
      "library": "goblint.solver",
      "description": "This module manages variables and abstract domain values in a constraint system, enabling efficient incremental solving and caching through operations that track and restore states at widening points during analysis. It provides core types for variables, identified by control-flow nodes, and abstract domain elements with lattice operations like join, meet, widen, and comparison utilities. You can use it to perform fixed-point computations, compare abstract values, and serialize variable and domain states for analysis in CFG-based programs. Submodules handle variable identity and lattice manipulations, supporting concrete tasks like tracking variable states and managing hierarchical relationships during constraint solving.",
      "description_length": 731,
      "index": 1653,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.TwoPhased.W.H",
      "library": "goblint.solver",
      "description": "This module implements a priority queue for managing ordered collections of constraints in solver algorithms, supporting operations to add elements, merge queues, extract the minimum element, and convert between lists and queues. The ordering of elements, which are of type `elem`, is determined by the `compare` function from the `HeapCompare` submodule, which uses variable identifiers to prioritize keys. With this structure, you can efficiently schedule and process constraints in multi-threaded analysis by maintaining a dynamically ordered queue. For example, you can insert a new constraint with a specific variable key, merge two queues to combine their elements, or extract the next minimum-priority constraint for processing.",
      "description_length": 735,
      "index": 1654,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.Td3.Base.VS.Labels",
      "library": "goblint.solver",
      "description": "This module provides operations for iterating over, transforming, and querying a set-like structure of elements, supporting common set manipulations such as filtering, mapping, and partitioning. It works directly with values of type `VS.t`, representing a collection of elements of type `VS.elt`, and assumes `VS` is a module providing set operations. Concrete use cases include processing constraint solution labels, selectively modifying or extracting elements during analysis, and partitioning sets of values based on predicates for further processing in constraint solving.",
      "description_length": 577,
      "index": 1655,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_solver.SLR.Make0.XY.HPM",
      "library": "goblint.solver",
      "description": "This module manages a map-like structure for tracking and modifying global contributions in a constraint-solving context, supporting polymorphic keys and values with fallible updates. It provides direct operations for safe querying, in-place updates, filtering, and transformation of key-value pairs, using both standard functions and custom operators like `-->` and `<--`. Submodules enable typed map manipulation, conditional modifications, and solver-specific state updates, all optimized for efficiency in multi-threaded static analysis. Examples include propagating global variable constraints, refining per-key state during analysis, and handling inconsistencies due to side effects.",
      "description_length": 689,
      "index": 1656,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_solver.SLR.Make.XY.P",
      "library": "goblint.solver",
      "description": "This module defines a data structure representing pairs of variables and provides equality and hashing operations for them. It works with tuples of type `S.Var.t`, where `S.Var` represents variables in a constraint system. These operations enable using variable pairs as keys in hash tables or as elements in sets, particularly for tracking relationships or dependencies between variables in constraint solving.",
      "description_length": 411,
      "index": 1657,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.Make.H.HeapCompare",
      "library": "goblint.solver",
      "description": "Implements a comparison function for heap keys based on variable ordering. Works with `S.Var.t` values as keys in a heap structure. Used to prioritize variables during constraint solving in multi-threaded analysis.",
      "description_length": 214,
      "index": 1658,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.JustWiden.H.HeapCompare",
      "library": "goblint.solver",
      "description": "This module defines a comparison function for keys used in a priority queue, specifically tailored for constraint system solving in multi-threaded C analysis. It operates on `HM.key` types, which correspond to variables in the constraint system. The comparison drives prioritization in the solver's worklist algorithm, influencing convergence and precision during fixed-point computation.",
      "description_length": 388,
      "index": 1659,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_solver.SLR.JustWiden.XY.P",
      "library": "goblint.solver",
      "description": "This module defines a type `t` as a pair of variables and provides equality and hashing operations for these pairs. It is used to represent and manipulate global contribution values in constraint systems. These operations support efficient comparison and storage of variable pairs during solver execution.",
      "description_length": 305,
      "index": 1660,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.TwoPhased.N.H",
      "library": "goblint.solver",
      "description": "This module provides a priority queue implementation backed by a heap structure, supporting standard operations like insertion, extraction of the minimum element, merging queues, and conversion to and from lists and enumerations. It works with elements of type `N.H.elem` and is designed for use cases such as scheduling in multi-threaded analysis and managing dynamic ordered data in constraint solving. The child module enhances the queue by defining a custom comparison mechanism for variable keys of type `S.Var.t` and `HM.key`, enabling specialized prioritization of heap-allocated variables during analysis. Together, the module and its child support efficient, context-aware handling of ordered variable data.",
      "description_length": 716,
      "index": 1661,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.EffectWConEq.Make.VS.Exceptionless",
      "library": "goblint.solver",
      "description": "This module provides operations for querying and selecting elements from a set structure, including finding minimum, maximum, arbitrary, and specific elements. It works with sets (`VS.t`) and their elements (`VS.elt`), supporting concrete use cases like extracting representative values or checking membership with retrieval. Functions such as `min_elt`, `find`, and `any` enable direct inspection and manipulation of set contents in constraint-solving contexts.",
      "description_length": 462,
      "index": 1662,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.PostSolver.MakeList.VH.Exceptionless",
      "library": "goblint.solver",
      "description": "This module provides `find` and `modify` operations for safely accessing and updating values in a `VH.t` map without raising exceptions. It works with polymorphic maps (`'a VH.t`) and key-based lookups (`VH.key`). Use this when handling constraint system data where missing keys or invalid modifications should return results explicitly instead of failing abruptly, such as during warning generation or verification passes.",
      "description_length": 423,
      "index": 1663,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLRterm.SLR3term.HPM.Infix",
      "library": "goblint.solver",
      "description": "This module defines two primary operations: `(-->)` for retrieving values associated with a key from a map-like structure, and `(<--)` for inserting or updating a key-value pair in place. It works with `'a HPM.t`, a hash-based map structure, and `HPM.key`, which represents the key type. These operators are used to manipulate constraint variables and their assignments during the solving process in a constraint system.",
      "description_length": 420,
      "index": 1664,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.SLR3.VS.Exceptionless",
      "library": "goblint.solver",
      "description": "This module provides operations for querying and selecting elements from a set-like structure `VS.t`, including retrieving minimum and maximum elements, choosing an arbitrary element, and finding a specific element. It supports concrete data types like sets of integers or other comparable values, typically used in constraint solving contexts. These functions are used during analysis of multi-threaded C programs to manage and resolve value constraints without exceptions.",
      "description_length": 474,
      "index": 1665,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.TopDown.WP.HPM.Infix",
      "library": "goblint.solver",
      "description": "This module provides imperative get and set operations for a map-like structure backed by HPM, using infix operators. It works with HPM.t, a map type indexed by HPM.key, allowing values of arbitrary type to be stored and retrieved. Concrete use cases include efficiently managing per-key state in constraint-solving algorithms, such as tracking variable assignments or constraint dependencies during analysis.",
      "description_length": 409,
      "index": 1666,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_solver.SLRphased.Make.VS.Labels",
      "library": "goblint.solver",
      "description": "This module provides operations for transforming and querying sets of labels, including iteration, folding, filtering, and partitioning. It works with sets of elements of type `VS.elt`, supporting concrete operations like applying a function to each element, selecting elements based on predicates, and splitting sets based on conditions. Use cases include analyzing and manipulating label sets during constraint solving phases in static analysis.",
      "description_length": 447,
      "index": 1667,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.SLR3.HPM.Infix",
      "library": "goblint.solver",
      "description": "This module provides two primary operations: `(-->)` for retrieving values associated with a key from a hash pointer map (HPM), and `(<--)` for binding a key-value pair in the map. It works with hash pointer maps (`HPM.t`) and their keys (`HPM.key`) to manage state in constraint solving. These operations are used to manipulate mappings during the analysis of multi-threaded C programs, specifically within the SLR3 solver framework.",
      "description_length": 434,
      "index": 1668,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.TwoPhased.N",
      "library": "goblint.solver",
      "description": "This module implements a two-phased constraint solver that coordinates variable domains, dependencies, and worklist management to solve dataflow equations in static analysis. It integrates global state tracking through hash maps that associate keys with values, priorities, influence lists, and variable sets, enabling precise handling of multi-threaded program analysis. Core operations include solving constraint systems with restarts, managing variable interactions via dependency tracking, and applying lattice operations for domain convergence. Specific capabilities include scheduling variables via priority queues, propagating changes through influence lists, and maintaining global contributions with hash-based maps.",
      "description_length": 725,
      "index": 1669,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.PostSolver.MakeList.S",
      "library": "goblint.solver",
      "description": "This module coordinates a sequence of postsolvers that refine or analyze constraint systems using variables and domains from its submodules. It applies each postsolver to a fixed point solution, enabling tasks like invariant verification and warning generation through operations on variables and abstract states. The `Var` submodule handles variable identity, comparison, and tracing, while `Dom` provides lattice operations to manipulate and analyze program state abstractions. Examples include tracking variable usage across constraints, pruning unreachable states, and generating diagnostics based on abstract interpretations.",
      "description_length": 630,
      "index": 1670,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.Make.X",
      "library": "goblint.solver",
      "description": "This module manages a mapping between integer keys and domain values, supporting dynamic value updates and key indexing. It provides direct access to keys, values, and default values through hash maps and mutable references. Used for efficiently tracking and updating constraint solution states during analysis of multi-threaded programs.",
      "description_length": 338,
      "index": 1671,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_solver.TopDown_deprecated.TD3.VS",
      "library": "goblint.solver",
      "description": "This module manages immutable collections of variables with set semantics, supporting ordered operations like union, intersection, and difference, along with functional transformations such as map, filter, and partition. It provides structured traversal, extremal value retrieval (min, max), and conversions to common data structures, enabling precise variable set manipulation in constraint systems. Submodules extend its capabilities with element selection strategies and label-based set operations, allowing tasks like querying representative values or transforming sets through predicates. Example uses include static analysis passes tracking variable dependencies and debugging tools formatting solution sets.",
      "description_length": 714,
      "index": 1672,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.PostSolver.ListArgFromStdArg.M",
      "library": "goblint.solver",
      "description": "Implements postsolver actions for constraint system analysis, handling variable constraints and value propagation. Operates on constraint variables (`S.v`), domains (`S.Dom.t`), and variable heaps (`VH.t`). Used to enforce constraints during analysis finalization, such as verifying variable bounds or triggering warnings based on derived values.",
      "description_length": 346,
      "index": 1673,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_solver.SLR.Make.XY",
      "library": "goblint.solver",
      "description": "This module manages global contribution values using a hash-based map structure, enabling efficient querying with defaults, setting values for keys within domains, and thread-safe state tracking in constraint solving. It supports core operations like `-->` and `<--` for key-value manipulation, with data indexed by keys of type `XY.P.t`, and provides imperative hash table functionality for polymorphic maps (`'a t`) with transformations, merging, and filtering. Child modules extend this with safe querying and error handling for updates, while also defining hashable variable pairs for tracking dependencies between variables in constraint systems. Example uses include managing thread-local state during analysis and representing variable relationships in constraint solving.",
      "description_length": 779,
      "index": 1674,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.Make.D",
      "library": "goblint.solver",
      "description": "This module implements lattice-based operations for comparing and combining abstract domain elements, including equality checks, partial order relations, and join/meet computations. It works with values of type `D.t` structured as a lattice to approximate program states in static analysis. These utilities are used in constraint solvers for analyzing multi-threaded C programs, particularly for handling side-effecting operations and data flow analysis.",
      "description_length": 454,
      "index": 1675,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLRterm.SLR3term.HPM",
      "library": "goblint.solver",
      "description": "This module implements imperative hash maps with polymorphic values, enabling efficient key-based storage, in-place mutation, and bulk transformations. It provides core operations such as `find`, `modify`, `-->>`, and `<--` for safe lookup, conditional updates, and atomic modifications, working with key type `HPM.key` and map type `'a HPM.t`. Submodules extend these capabilities with functions for merging, filtering, and folding over maps, supporting use cases like managing dynamic constraints, updating variable bindings, and traversing labeled solver data. Together, they enable structured, efficient manipulation of stateful configurations and constraint systems through a mix of imperative and functional operations.",
      "description_length": 725,
      "index": 1676,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.Make0.L",
      "library": "goblint.solver",
      "description": "This module provides operations to manage influence lists in a constraint system, specifically adding elements to lists, subtracting elements from lists, and removing list items entirely. It works with hash tables (`HM.t`) mapping keys to lists or individual values. Concrete use cases include tracking and updating dependencies or influences between constraints during solver iterations.",
      "description_length": 388,
      "index": 1677,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.TopDown.WP.HPM",
      "library": "goblint.solver",
      "description": "This module manages polymorphic hash tables with keys of type `P.t`, enabling in-place updates, transformations, and conditional operations on `HPM.t` structures. It supports merging, filtering, and mapping key-value pairs, along with conversions to lists, sequences, and string representations, making it suitable for constraint solving and iterative refinement of key-associated data. Submodules extend its use to top-down constraint propagation, imperative key-based state tracking, and infix-driven value manipulation, with concrete applications in static analysis and debugging. Operations like bulk transformation, key-based retrieval, and formatted serialization allow tasks such as constraint resolution, variable binding refinement, and runtime inspection of map contents.",
      "description_length": 781,
      "index": 1678,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.SLR3.HPM",
      "library": "goblint.solver",
      "description": "This module provides imperative hash table operations and polymorphic map manipulations for key-value stores with keys of type `P.t` and arbitrary values, supporting bulk transformations, in-place mutations, and merging of hash-based maps. It enables operations such as adding, replacing, filtering, and mapping entries, along with conversions to and from sequences like lists and enumerators, making it suitable for managing dynamic constraint states in multi-threaded program verification. The module's core functionality is extended by submodules that introduce constraint-solving capabilities, labeled key manipulations, and infix operators `(-->)` and `(<--)` for stateful map interactions, all used in static analysis tools for handling thread-local state and variable bindings. Specific use cases include retrieving and modifying constraint maps during C program analysis and performing conditional transformations on labeled keys within the SLR3 solver framework.",
      "description_length": 971,
      "index": 1679,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.Make.H",
      "library": "goblint.solver",
      "description": "This module provides a priority queue implementation using a heap ordered by variable-based keys from `S.Var.t`, enabling efficient management of dynamic data with priorities. It supports core operations like inserting elements, merging queues, extracting the minimum, and converting between lists and queues, all working with values of type `t` and elements of type `elem`. The child module defines the variable-based ordering used to structure the heap, making it suitable for applications like scheduling tasks or managing event queues in multi-threaded constraint solving. Specific use cases include prioritizing variables during analysis and handling weighted data streams with changing priorities.",
      "description_length": 703,
      "index": 1680,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.SLR3.VS",
      "library": "goblint.solver",
      "description": "This module implements ordered set operations for variable collections with support for set algebra, ordered element access, and sequence-based transformations. It centers around the `VS.t` type, enabling union, intersection, extremal element retrieval, and conversions to lists, arrays, and sequences. Submodules extend it with label-specific transformations and constraint-solving operations, such as mapping over labels and selecting elements based on ordering or predicates. Examples include tracking program labels during constraint resolution and managing integer sets for static analysis of concurrent programs.",
      "description_length": 618,
      "index": 1681,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLRphased.Make.HPM",
      "library": "goblint.solver",
      "description": "This module enables imperative manipulation of thread-local polymorphic hash maps with key-based constraint aggregation, supporting operations like merging, filtering, and bidirectional transformations with sequences. It centers around the `HPM.t` data type, parameterized over keys (`P.t`) and arbitrary values, allowing both single and multi-value associations, and provides core operations such as `find`, `modify`, `-->`, and `<--` for efficient state updates and lookups. Child modules integrate a two-phased SLR3 solver, phase management, and hash-preserving map utilities to support constraint system solving, where constraint states are tracked, merged, and transformed across analysis phases. Examples include retrieving and updating constraint values during dataflow analysis, managing intermediate solver states, and applying custom functions to filter or merge constraint sets.",
      "description_length": 889,
      "index": 1682,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.JustWiden.X",
      "library": "goblint.solver",
      "description": "This module manages value and priority associations for constraint solving, using hash maps to store domain-specific values and keys. It provides direct access and mutation operations for keyed values, supporting efficient lookups and updates. Concrete use cases include tracking and retrieving analysis results during iterative solver execution.",
      "description_length": 346,
      "index": 1683,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.Make0.XY",
      "library": "goblint.solver",
      "description": "This module organizes global contributions as a hash-based map, enabling key-value lookups with defaults, direct assignment, and efficient querying, all critical for tracking domain-specific state in constraint-solving. It pairs with a child module defining variable pairs as keys, supporting equality and hashing for precise variable relationship tracking in multi-threaded contexts. Another child module extends this with polymorphic map operations, including safe updates, filtering, and custom operators like `-->`, enabling propagation of global constraints and refinement of analysis state. Together, they support tasks like static analysis of C programs by maintaining and updating global variable constraints and handling side effects across threads.",
      "description_length": 758,
      "index": 1684,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.Make.T",
      "library": "goblint.solver",
      "description": "Implements variable dependency tracking and update propagation for constraint systems. Operates on hash maps (`HM.t`) with polymorphic values and keys. Used to manage and update interdependent variables during constraint solving in static analysis.",
      "description_length": 248,
      "index": 1685,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.TopDown.WP.P",
      "library": "goblint.solver",
      "description": "Implements equality and hashing operations for constraint system variables used in top-down solving. Works with pairs of variables from the constraint system. Enables efficient comparison and storage of variable pairs during constraint resolution.",
      "description_length": 247,
      "index": 1686,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.Td3.Base.CurrentVarS",
      "library": "goblint.solver",
      "description": "This module manages variable tracking and state during constraint solving, handling the current variable context with operations to set, retrieve, and reset variables while maintaining transient state for efficient reanalysis. It works with solver states and variable options, supporting incremental analysis where temporary modifications can be made and later rolled back without full recomputation. The core data types include variables identified by control-flow nodes and abstract domain elements with lattice operations such as join, meet, and widen. You can use it to perform fixed-point computations, compare abstract values, and serialize variable and domain states, with submodules supporting variable identity, lattice manipulations, and hierarchical relationships in CFG-based programs.",
      "description_length": 797,
      "index": 1687,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.PostSolver.MakeList.VH",
      "library": "goblint.solver",
      "description": "This module manages key-value mappings with imperative hash table operations, supporting insertion, lookup, iteration, and advanced transformations like filtering and merging. It provides direct access to dictionary-style manipulations over solver variables, enabling tasks such as constraint pruning, verification, and structured data extraction during post-processing. Submodules extend its functionality with specialized operations for in-place updates, infix syntax for get/set, and safe value modification without exceptions. Examples include refining constraint labels, querying solution values during solver passes, and handling missing keys gracefully in verification workflows.",
      "description_length": 686,
      "index": 1688,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.TopDown_deprecated.TD3.P",
      "library": "goblint.solver",
      "description": "This module defines a type `t` as a pair of variables and provides equality and hashing operations for it. It is used in the context of constraint solving to represent and compare variable pairs efficiently. Concrete use cases include tracking relationships between variables during the solving process.",
      "description_length": 303,
      "index": 1689,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.EffectWConEq.Make.VS",
      "library": "goblint.solver",
      "description": "This module combines variable set manipulation with ordered set functionality to support constraint solving and domain analysis. It provides ordered collections (`VS.t`) of program variables (`S.Var.t`) with standard set operations, rank-based access, ordered iteration, and efficient membership checks, along with conversions to lists, arrays, and sequences. The module enables extremal element retrieval (min/max) and custom formatting, while its submodules support label set transformations, filtering, and element selection, allowing tasks like mapping over variable sets, extracting representatives, or checking membership with retrieval. Specific uses include static analysis passes that require ordered processing of variable domains or integration with constraint systems needing precise set-theoretic decomposition.",
      "description_length": 824,
      "index": 1690,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLRphased.Make.P",
      "library": "goblint.solver",
      "description": "Implements equality and hash operations for constraint variable pairs used in the two-phased SLR3 solver. Works directly with tuples of constraint variables (`S.Var.t * S.Var.t`). Enables efficient comparison and hashing of constraint pairs during fixed-point computation phases.",
      "description_length": 279,
      "index": 1691,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_solver.SLR.JustWiden.XY",
      "library": "goblint.solver",
      "description": "This module manages global contribution values through a map structure, offering direct access via keys with `get_value` and `set_value`, and safe lookups using `hpm_find_default`. Its child modules extend this functionality with imperative hash table operations and dictionary-style manipulations for polymorphic maps, supporting efficient addition, lookup, merging, and transformation of key-value pairs under constraint systems. A secondary submodule introduces a pair type for variables, enabling equality checks and hashing needed for constraint solving. Examples include using infix operators like `-->` to retrieve variable states and `<--` to update them during fixed-point computations in static analysis.",
      "description_length": 714,
      "index": 1692,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.TopDown_space_cache_term.WP.VS",
      "library": "goblint.solver",
      "description": "This module manages immutable ordered sets of variables with efficient set-theoretic operations, ordered element access, and transformations via mapping and folding. It supports direct manipulation of `VS.t` sets through union, difference, subset checks, and rank-based selection, while its submodules enable label set analysis and element querying. Specific operations include extracting min/max elements, transforming sets based on constraints, and partitioning based on predicates, all used in dependency tracking and constraint solving. The module integrates with sequences and arrays, enabling efficient traversal and cached intermediate result handling.",
      "description_length": 659,
      "index": 1693,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.Make0.T",
      "library": "goblint.solver",
      "description": "This module tracks variable dependencies and manages their relationships using a nested hash map structure. It provides operations to retrieve, update, and set dependencies between variables in a constraint system. Used during analysis of multi-threaded C programs to track how variable values propagate and influence each other.",
      "description_length": 329,
      "index": 1694,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.Worklist.Make.VS",
      "library": "goblint.solver",
      "description": "This module provides immutable sets of variables with standard set operations, functional transformations, and ordered traversal, enabling precise manipulation of variable collections through union, intersection, difference, and element-wise filtering. It supports conversion to and from sequences, lists, and arrays, and includes utilities for extracting or removing specific elements such as min or max. The worklist solvers in its submodules leverage these sets to perform iterative constraint solving and dataflow analysis, processing elements based on selection criteria until fixed points are reached. These capabilities facilitate structured enumeration and dependency management in static analysis tasks involving variables or labeled nodes.",
      "description_length": 749,
      "index": 1695,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.Make0.H",
      "library": "goblint.solver",
      "description": "This module implements a priority queue for managing dynamic collections of elements ordered by priority, using a comparison function from a `HeapCompare` module to determine element ordering. It provides core operations like inserting elements, merging queues, extracting the minimum element, and converting between queues and lists or enumerations. The queue can prioritize elements such as tasks or variables, enabling efficient retrieval and processing\u2014such as in constraint solving where variables are prioritized based on dependencies or impact. A child module defines a comparison function for `S.Var.t`, enabling use of variables as keys in the queue and supporting optimized variable processing in multi-threaded analysis.",
      "description_length": 731,
      "index": 1696,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.Make0.X",
      "library": "goblint.solver",
      "description": "This module manages value and priority associations for constraint solving, using hash maps to store domain-specific values and keys. It provides direct access and mutation operations for solver states, including key generation, value retrieval, and index resolution with boolean flags. It is used during the solving process to track and update constraint variables and their associated data.",
      "description_length": 392,
      "index": 1697,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.Make0.D",
      "library": "goblint.solver",
      "description": "This module implements lattice-theoretic operations for abstract domain values of type `D.t`, including join, meet, widening, narrowing, and equality checks, alongside structural comparison and pretty-printing capabilities. It operates on abstract interpretation domains used in static analysis to model program states, particularly for fixed-point computations in constraint systems. These operations enable dataflow analysis and verification of multi-threaded programs by supporting precise domain transformations and solver interactions required for scalable static analysis frameworks.",
      "description_length": 589,
      "index": 1698,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.TwoPhased.W",
      "library": "goblint.solver",
      "description": "This module implements a two-phased worklist solver for constraint systems, coordinating with submodules to manage keys, values, dependencies, and priority queues for efficient interprocedural analysis of multi-threaded C programs. It operates on hash maps mapping keys to variables, domains, and worklist elements, supporting dependency tracking, restarts, and fixed-point computations. Main data types include keys, domain values, influence lists, and priority queues, with operations for insertion, update, retrieval, priority-based scheduling, and lattice manipulation. You can track variable dependencies, prioritize constraint solving with ordered queues, merge thread-local analysis results, and manage solver state changes with influence lists and domain updates.",
      "description_length": 771,
      "index": 1699,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.JustWiden.P",
      "library": "goblint.solver",
      "description": "This module provides operations for managing a set of keys within a constraint system, including inserting, removing, and checking membership of keys. It works with a hidden map (HM) structure where keys are associated with unit values, effectively representing a set. Concrete use cases include tracking dependencies for global variables and maintaining stable sets during solver iterations.",
      "description_length": 392,
      "index": 1700,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.TopDown.WP.VS",
      "library": "goblint.solver",
      "description": "This module manages structured sets of variables with efficient membership testing, union, intersection, and difference operations, along with ordered element extraction via min, max, and arbitrary selection. It supports conversions to and from lists, arrays, and sequences, enabling ordered traversal and transformation, and is used in static analysis for tracking variable states and solving constraint systems. The label management submodule extends it with iteration, filtering, and partitioning over sets of labels, while the query submodule adds element selection functions like `find`, `choose`, and `any` for retrieving specific or representative values during analysis. Together, these capabilities allow precise manipulation and querying of variable sets in symbolic reasoning tasks.",
      "description_length": 793,
      "index": 1701,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_solver.SLRphased.Make.VS",
      "library": "goblint.solver",
      "description": "This module manages ordered collections of variables with efficient set operations, supporting union, intersection, difference, and ordered traversal. It includes submodules for element selection\u2014such as min, max, and arbitrary extraction\u2014and for label set transformation through mapping, filtering, and partitioning. Direct operations allow conversion to and from lists, arrays, and sequences, while the child modules enable precise control over element access and set manipulation. Example uses include tracking variable dependencies in symbolic computation and refining label sets during static analysis.",
      "description_length": 607,
      "index": 1702,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_solver.SLR.JustWiden.T",
      "library": "goblint.solver",
      "description": "This module tracks variable dependencies and manages their relationships during constraint solving. It provides operations to set, update, and query variable mappings using a nested hash table structure. Concrete use cases include managing dependency chains and tracking variable substitutions in multi-threaded static analysis.",
      "description_length": 328,
      "index": 1703,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.JustWiden.D",
      "library": "goblint.solver",
      "description": "This module implements lattice operations for abstract domains, including join, meet, widen, and narrow, which are essential for abstract interpretation. It operates on values of type `D.t`, providing structural support for fixpoint computation and equality checks in static analysis workflows. These capabilities are specifically applied to analyzing multi-threaded C programs using constraint-based solvers, as described in Apinis' work on scalable thread-modular analysis.",
      "description_length": 475,
      "index": 1704,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_solver.TopDown_deprecated.TD3.HPM",
      "library": "goblint.solver",
      "description": "This module combines imperative hash table operations with higher-order transformations to manage polymorphic key-value maps where keys derive from `P.t`. It supports bulk modifications, conditional filtering, merging, and conversions to sequences, lists, and formatted strings, enabling efficient mutable state tracking and structured data interchange. Submodules extend this functionality with specialized constraint-solving strategies, including a modified SLR3-based top-down solver and priority-based key-value access, used for analyzing program properties and managing dynamic constraint states. Specific operations include adding and modifying key-value pairs, solving constraints without exceptions, and using `(-->)` and `(<--)` for priority-based map queries and updates.",
      "description_length": 781,
      "index": 1705,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.Make.P",
      "library": "goblint.solver",
      "description": "This module provides operations for managing a set of keys within a constraint system, including inserting, removing, and checking membership of keys. It works with a key type and a map type that associates keys with unit values. Concrete use cases include tracking dependencies for global variables and maintaining stable sets during constraint solving.",
      "description_length": 354,
      "index": 1706,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_solver.SLR.Make0.P",
      "library": "goblint.solver",
      "description": "This module provides operations for managing a set of keys within a constraint system, including insertion, removal, and membership checks. It works with a key type and a map type that associates keys with unit values. Concrete use cases include tracking dependencies for global variables and maintaining stable sets during constraint solving.",
      "description_length": 343,
      "index": 1707,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.TopDown_space_cache_term.WP.P",
      "library": "goblint.solver",
      "description": "This module defines a data structure for representing pairs of variables and provides operations for equality checking and hashing. It works with tuples of type `S.Var.t` to support key-based comparisons and efficient lookups. Concrete use cases include managing variable pairs in constraint systems where unique identification and fast equality checks are required.",
      "description_length": 366,
      "index": 1708,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLRterm.SLR3term.P",
      "library": "goblint.solver",
      "description": "This module defines a data type `t` as a pair of variables and provides operations for equality checking and hashing. It works with constraint systems involving variable pairs, enabling efficient comparison and use in hash-based data structures. Concrete use cases include tracking relationships between variables during constraint solving in static analysis.",
      "description_length": 359,
      "index": 1709,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.SLR3.P",
      "library": "goblint.solver",
      "description": "This module defines a data structure for representing pairs of variables and provides equality and hashing operations for them. It works with tuples of type `S.Var.t`, where `S.Var` represents variables in a constraint system. These operations are used to manage and compare variable pairs within the SLR3 solver's analysis of multi-threaded programs.",
      "description_length": 351,
      "index": 1710,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_solver.Td3.Base.VS",
      "library": "goblint.solver",
      "description": "This module offers a comprehensive toolkit for ordered set manipulation, centered around the `VS.t` structure, which supports efficient set-theoretic operations, order-based transformations, and precise element access. It enables tasks such as union, intersection, filtering, and rank-based retrieval (e.g., `at_rank_exn`), while also allowing conversion to and from lists, arrays, and sequences. The first child module extends this functionality to constraint solving by enabling safe, exception-free element access, supporting queries for minimal, maximal, or arbitrary elements during fixed-point computations. The second child module enhances iteration, transformation, and querying capabilities, facilitating operations like predicate-based partitioning and selective element modification on `VS.t` sets, particularly useful in abstract interpretation and constraint analysis workflows.",
      "description_length": 891,
      "index": 1711,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.JustWiden.L",
      "library": "goblint.solver",
      "description": "This module provides operations to manipulate influence lists stored in a hash map, where each key maps to a list of values. It supports adding a value to a key's list, replacing a key's list with a new one, and removing a key-value pair from the map. These operations are used to track and update dependencies or influences between variables during constraint solving in a multi-threaded analysis.",
      "description_length": 398,
      "index": 1712,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_solver.PostSolver.MakeList.IncrArg",
      "library": "goblint.solver",
      "description": "Implements incremental argument handling for postsolvers in a constraint system evaluation pass. Works with lists of postsolver modules and variable heaps, initializing reachable variables and applying postsolvers in sequence. Used to refine analysis results by propagating constraints incrementally over reachable program variables.",
      "description_length": 333,
      "index": 1713,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.TopDown_term.WP.VS",
      "library": "goblint.solver",
      "description": "This module provides set-theoretic and functional operations over variable sets (`VS.t`), enabling union, intersection, mapping, and folding, along with conversions to and from sequences, lists, and arrays. It supports element selection through min, max, and arbitrary value extraction, facilitating analysis and traversal without exceptions. The module integrates label management for constraint solving tasks like weakest precondition calculation, allowing transformations and inspections over variable sets and their dependencies. Use cases include dependency resolution, term elimination, and tracking side effects during top-down constraint system analysis.",
      "description_length": 662,
      "index": 1714,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_solver.SLRterm.SLR3term.VS",
      "library": "goblint.solver",
      "description": "This module implements a variable set structure with efficient membership checks and ordered element access, supporting core set operations like union, intersection, and difference. It includes modules for safe element selection\u2014retrieving min, max, or arbitrary elements without exceptions\u2014and for label set manipulation via iteration, filtering, and partitioning. The API enables conversion between sets and sequences, arrays, or lists, while facilitating formatted output and exception-safe extraction. Example uses include tracking variables in static analysis and resolving constraint systems with ordered collections.",
      "description_length": 623,
      "index": 1715,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.TopDown_term.WP.P",
      "library": "goblint.solver",
      "description": "Implements equality and hashing for constraint system variables used in top-down solving. Works with tuples of two `S.Var.t` values, enabling efficient comparison and storage in hash tables. Useful for tracking variable pairs during constraint resolution in the top-down solver.",
      "description_length": 278,
      "index": 1716,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_solver.SLR.PrintInfluence.S1",
      "library": "goblint.solver",
      "description": "This module implements a solver for influence analysis in constraint systems, computing dependencies between variables and their values by tracking influence through hash maps. It provides the `solve` function to process variable-value pairs and determine reachable variables, while its child module extends this with a first-order SLR solver that maps variable dependencies and prints influence graphs based on constraint keys. Together, they enable analysis of how variable changes propagate in multi-threaded C programs, identifying synchronization effects and dependency chains. For example, given a constraint system modeling thread interactions, the solver can trace how modifying one variable affects others across threads.",
      "description_length": 730,
      "index": 1717,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.Make.L",
      "library": "goblint.solver",
      "description": "This module provides operations to manipulate influence lists stored in a hash map, where each key maps to a list of values. It supports adding a value to a key's list, subtracting (removing) a value from a key's list, and removing a key's entire entry. These operations are useful for tracking and updating dependencies or influences between variables in constraint systems, particularly in the context of static analysis of multi-threaded programs.",
      "description_length": 450,
      "index": 1718,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.JustWiden.H",
      "library": "goblint.solver",
      "description": "This module implements a priority queue for managing elements with dynamic priorities, using a heap structure based on a custom comparison function. It supports key operations such as inserting elements, merging queues, extracting the minimum, and converting between lists and queues, all centered around the `t` and `elem` types. The included comparison module specializes the queue for constraint system solving by defining an ordering on `HM.key` types, which represent variables in a multi-threaded analysis context. This enables efficient worklist management where priority affects fixed-point convergence and solution precision during constraint resolution.",
      "description_length": 663,
      "index": 1719,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_solver.PostSolver.MakeStdArg",
      "library": "goblint.solver",
      "description": "This module defines standard configuration options for controlling post-processing behavior after constraint system solving. It provides boolean values to enable or disable pruning, verification, warning generation, and saving the solver run. These options are used to customize the evaluation phase for tasks like analysis refinement or result validation.",
      "description_length": 356,
      "index": 1720,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.PostSolver.IncrS-VH-Exceptionless",
      "library": "goblint.solver",
      "description": "This module provides safe lookup and in-place modification operations for hash tables, returning optional values or result types instead of raising exceptions. It works with hash tables (`VH.t`) and their keys and values. Use it to handle missing keys gracefully or apply transformations to stored values without exception handling overhead.",
      "description_length": 341,
      "index": 1721,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.PostSolver.MakeIncr",
      "library": "goblint.solver",
      "description": "This module creates an incremental postsolving function from a given incremental postsolver module `PS`. It operates on constraint systems with variables of type `PS.S.v`, domains of type `PS.S.Dom.t`, and variable-data pairs `(PS.S.v * PS.S.d)`. It is used to perform post-processing tasks such as warning generation, verification, and pruning after constraint solving.",
      "description_length": 370,
      "index": 1722,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_solver.Td3.Hooks-HM-Exceptionless",
      "library": "goblint.solver",
      "description": "This module provides safe, exception-free operations for manipulating hash tables, including `find` for retrieving values as optional results and `modify` for updating values with a function. It works directly with hash tables (`HM.t`) and key-value pairs, ensuring robust error handling by returning result types instead of raising exceptions. Concrete use cases include safely querying and updating constraint solver state during incremental analysis without interrupting execution due to missing keys.",
      "description_length": 504,
      "index": 1723,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.PostSolver.S-S-Dom",
      "library": "goblint.solver",
      "description": "This module provides lattice operations and domain-specific analysis tools for constraint system elements, including structural comparison, semantic evaluation, and extremal value checks. It works with lattice domain values of type `S.Dom.t`, supporting operations like `join`, `meet`, `widen`, and `narrow` alongside top/bottom value detection. These capabilities enable verification tasks, static analysis pruning, and warning generation in constraint system solving workflows.",
      "description_length": 479,
      "index": 1724,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.PostSolver.MakeListArg-VH-Infix",
      "library": "goblint.solver",
      "description": "This module provides infix operators for interacting with a BatHashtbl, enabling direct value retrieval and scoped binding updates. It works with BatHashtbl tables that map keys to values, supporting operations like finding a key's current value or adding a new binding that can be reverted. Concrete use cases include managing temporary state changes during constraint system evaluation, such as tracking variable assignments and restoring prior values after backtracking.",
      "description_length": 473,
      "index": 1725,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.PostSolver.S-S",
      "library": "goblint.solver",
      "description": "Implements post-processing operations on constraint systems, including warning generation and solution verification. Works with variables and domains defined by the `Var` and `Dom` submodules, processing constraint system changes based on an existing solution. Used to refine or analyze results after initial constraint solving.",
      "description_length": 328,
      "index": 1726,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_solver.SLRterm.SLR3term",
      "library": "goblint.solver",
      "description": "This module solves constraint systems with guaranteed termination, using hashmap-based structures to track variables and abstract values while supporting profiling through event counters and histograms. It combines domain narrowing operations with efficient state manipulation via imperative hash maps and variable sets, enabling precise fixed-point computation over side-effecting constraints. The API allows for safe key-based updates, atomic modifications, and set operations on variable pairs and labeled data, with concrete applications in points-to analysis and interval tracking. Submodules enhance these capabilities with ordered set traversal, safe element selection, and hash-consed variable pairing for efficient comparison and storage.",
      "description_length": 747,
      "index": 1727,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.TopDown_term.WP",
      "library": "goblint.solver",
      "description": "This module orchestrates performance profiling and worklist-based solving for abstract interpretation tasks, centered around solver variables, domains, and mutable state tracking. It manages variable evaluation phases, computes fixpoints, and outputs results and statistics, including variable updates and evaluation counts, with CSV export for analysis. Submodule 1 extends its capabilities with set-theoretic operations over variable sets, supporting transformations, dependency tracking, and traversal utilities. Submodule 2 provides equality and hashing for variable pairs, enabling efficient constraint resolution in top-down solving workflows.",
      "description_length": 649,
      "index": 1728,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.TopDown_space_cache_term.WP",
      "library": "goblint.solver",
      "description": "This module combines fixed-point solving with profiling capabilities for abstract interpretation, using solver variables, abstract domains, and constraint systems, while leveraging hashmaps for statistical tracking and space-efficient resolution. It supports iterative solving with widening and narrowing phases, detailed runtime diagnostics via CSV logging, and direct manipulation of variables and constraints. The first child module provides ordered sets for efficient variable set operations, enabling dependency tracking through union, difference, and ordered traversal, while the second handles variable pairs with equality and hashing support for use in constraint system keys. Together, they enable complex static analysis tasks like dataflow optimization and program invariant detection with precise control over memory and termination.",
      "description_length": 845,
      "index": 1729,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_solver.PostSolver.StartEqConstrSys-Var",
      "library": "goblint.solver",
      "description": "This module defines operations for managing and comparing variables within a constraint system, including equality checks, hashing, and comparison functions. It works with variables that must be hashable and comparable, supporting use cases like tracking variable identities, generating pretty-printed output, and handling node associations in a control flow graph. Specific functions enable variable comparison, XML serialization, and relifting for use in analysis passes like warning generation or constraint pruning.",
      "description_length": 519,
      "index": 1730,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.PostSolver.S-VH-Labels",
      "library": "goblint.solver",
      "description": "This module provides labeled versions of standard hash table operations, enhancing readability and safety by requiring explicit argument labels. It works with hash tables (`VH.t`) that map keys (`VH.key`) to arbitrary data. Concrete use cases include adding, replacing, filtering, and transforming entries based on keys and values, with support for in-place modifications, merging tables, and conditional updates using labels to clarify function arguments.",
      "description_length": 456,
      "index": 1731,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.MyGenericEqSolver-X",
      "library": "goblint.solver",
      "description": "This module implements a generic equality solver for constraint systems with side effects, operating over integer-indexed variables stored in a hash table. It provides operations to add constraints, propagate equalities, and resolve variable equivalences during analysis. Concrete use cases include tracking value equivalences in static analysis of multi-threaded C programs, particularly for optimizing and verifying concurrent code.",
      "description_length": 434,
      "index": 1732,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_solver.PostSolver.StartEqConstrSys",
      "library": "goblint.solver",
      "description": "Handles constraint system evaluation with initial values for solving and incremental updates. Works with variables and domains defined in associated modules, using a functional form system and change tracking. Used to initialize and refine constraint solutions during analysis passes.",
      "description_length": 284,
      "index": 1733,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_solver.Generic.SolverStats",
      "library": "goblint.solver",
      "description": "This module provides functionality to track and analyze solver performance through counters and event hooks that monitor variable operations, domain evaluations, and updates. It works with solver variables, abstract domains, and histogram maps to collect metrics, supporting diagnostic workflows like performance analysis and convergence debugging. A utility function enables printing or exporting these statistics in human-readable or CSV formats for further inspection.",
      "description_length": 471,
      "index": 1734,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.Td3.Base",
      "library": "goblint.solver",
      "description": "This module orchestrates constraint solving with variable tracking, state management, and ordered set manipulation, enabling efficient incremental analysis and reanalysis. It centers on solver variables tied to control-flow nodes, abstract domain elements with lattice operations, and ordered sets (`VS.t`) for precise element access and transformation. You can perform fixed-point computations, query minimal or maximal elements, and apply predicate-based partitioning on sets, all while leveraging caching and selective state restoration for performance. Submodules refine variable identity, lattice behavior, and set operations, integrating tightly with workflows in abstract interpretation and interactive program analysis.",
      "description_length": 727,
      "index": 1735,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.PostSolver.IncrS-S-Var",
      "library": "goblint.solver",
      "description": "This module defines operations for working with hashable and comparable constraint variables, including equality checks, hashing, and comparison. It provides utilities to inspect variable properties, such as whether a variable is write-only, and to generate variable identifiers or retrieve associated control flow nodes. These functions support constraint system evaluation, warning generation, and variable tracking during static analysis.",
      "description_length": 441,
      "index": 1736,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.PostSolver.S-VH-Exceptionless",
      "library": "goblint.solver",
      "description": "This module provides safe lookup and modification operations for hash tables, returning options and result types instead of raising exceptions. It works with hash tables (`Hashtbl`) and their keys and values. Concrete use cases include safely retrieving values by key and applying in-place transformations to entries, handling potential errors without exceptions.",
      "description_length": 363,
      "index": 1737,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.TwoPhased",
      "library": "goblint.solver",
      "description": "This module implements a two-phased constraint solver that coordinates variable domains, dependencies, and priority-based scheduling to solve dataflow equations in static analysis of multi-threaded C programs. It uses hash maps to track assignments and influence lists to propagate changes, integrating with submodules for domain operations, worklist management, and dependency tracking. Core operations include solving with restarts, prioritizing variables via queues, and merging thread-local results using lattice-based convergence. You can analyze weak memory models by tracking variable interactions, scheduling constraints by priority, and maintaining global solver state through hash-based maps and influence propagation.",
      "description_length": 728,
      "index": 1738,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.Td3.Basic",
      "library": "goblint.solver",
      "description": "Implements an incremental, terminating top-down solver that caches intermediate results and supports space-efficient reanalysis by restoring values only at widening points. Works with constraint systems represented as variable-domain pairs, using a hash table to track solutions for specific variables. Useful for abstract interpretation tasks where program analyses need to be reevaluated efficiently after small changes, such as in interactive or iterative static analysis tools.",
      "description_length": 481,
      "index": 1739,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.PrintInfluence",
      "library": "goblint.solver",
      "description": "This module performs influence analysis on constraint systems using SLR solving strategies, mapping how variables influence each other during solving to determine dependencies and computed values. It centers on hash maps to track variable-value relationships and provides the `solve` function to compute reachable variables, with a child module extending this with a first-order SLR solver that generates influence graphs based on constraint keys. These tools enable tracing how changes propagate through variables in multi-threaded C programs, revealing synchronization effects and dependency chains. For example, given a system modeling thread interactions, the solver can analyze how modifying one variable affects others across threads.",
      "description_length": 740,
      "index": 1740,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.Selector.Make",
      "library": "goblint.solver",
      "description": "Implements a solver that selects and delegates to a runtime-configured constraint-solving strategy based on string settings from `GobConfig`. It operates on constraint systems involving variables (`S.v`), domains (`S.d`), and value hierarchies (`VH`), supporting marshaling and copying of solver state. Useful for dynamically switching between different constraint-solving algorithms without recompilation.",
      "description_length": 406,
      "index": 1741,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.PostSolver.Unit",
      "library": "goblint.solver",
      "description": "Implements a postsolver for constraint systems that processes individual constraints and variables to generate warnings or prune values. It operates on variable handlers and constraint systems defined by the `S` and `VH` modules, tracking reachability and refining results after initial solving. Used to enforce verification conditions and filter out unreachable or invalid states based on solved constraints.",
      "description_length": 409,
      "index": 1742,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_solver.PostSolver.MakeListArg-module-type-M",
      "library": "goblint.solver",
      "description": "Implements post-processing logic for constraint systems using variable heaps (`VH.t`) and domain values (`Dom.t`). It tracks variable relationships and constraints during analysis, enabling checks like reachability and value propagation. Used to refine analysis results by applying constraints after initial solving, such as pruning unreachable paths or validating data flows.",
      "description_length": 376,
      "index": 1743,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_solver.SLR.Make",
      "library": "goblint.solver",
      "description": "This module orchestrates a constraint solver for multi-threaded C program analysis using a side-effecting least fixpoint approach, integrating variable querying, worklist management, and restart controls. It centers on constraint variables (V), domains (S), and hash maps (HM), with core operations for state updates, dependency tracking, and lattice-based combination of abstract values. Submodules enhance this by managing dynamic key-value mappings, thread-safe global contributions, priority queues for variable scheduling, and influence lists for dependency propagation. Example tasks include tracking thread-local state changes, prioritizing constraint variables during solving, and maintaining stable sets of global dependencies.",
      "description_length": 736,
      "index": 1744,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.PostSolver.MakeIncrListArg-S",
      "library": "goblint.solver",
      "description": "Implements incremental list-based constraint system solving with support for variable and domain operations. Works with variables (`v`) and domain values (`d`), tracking changes to efficiently update solutions. Used for incremental analysis in static program verification, such as refining dataflow results or propagating changes in pointer analysis.",
      "description_length": 350,
      "index": 1745,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.TopDown.WP",
      "library": "goblint.solver",
      "description": "This module combines profiling and constraint-solving capabilities with its submodules to enable efficient static analysis through abstract interpretation. It tracks variable operations and memory usage while computing solutions over domains and partitioned states, using variable sets, predicate maps, and variable pairs to manage and resolve constraints. The module supports concrete tasks like program verification through operations on structured sets, polymorphic hash tables, and equality comparisons, allowing bulk transformations, key-based state tracking, and precise membership queries. Together, these components enable iterative constraint refinement, symbolic reasoning, and runtime inspection of analysis results.",
      "description_length": 727,
      "index": 1746,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.Generic.SoundBoxSolver",
      "library": "goblint.solver",
      "description": "Solves constraint systems by computing a hash-map of variable-domain associations from initial values and target variables. Uses modules S for variable and domain definitions and H for hash-map operations. Useful for static analysis tasks like dataflow analysis where constraints are resolved iteratively.",
      "description_length": 305,
      "index": 1747,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.Worklist.Make",
      "library": "goblint.solver",
      "description": "This module implements a worklist-based solver for constraint systems using abstract domains, enabling efficient propagation and context-sensitive analysis through operations like `solve` and `eq`. It manages variables (`S.Var.t`), domain values (`S.Dom.t`), hash maps (`HM.t`), and variable sets (`VS.t`), with optional CSV logging for debugging. The solver supports abstract interpretation workflows and performance-critical constraint resolution, while its child module provides functional variable set operations\u2014union, intersection, difference, and ordered traversal\u2014for precise manipulation and iterative solving. These capabilities allow tasks like dataflow analysis and dependency management, where sets track variable states and guide fixed-point computations.",
      "description_length": 769,
      "index": 1748,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.PostSolver.MakeIncrListArg",
      "library": "goblint.solver",
      "description": "Works with constraint systems and variable hierarchies to manage incremental postsolving. Provides a list of postsolvers and initializes reachable states using variable hierarchies. Used to evaluate and refine constraint systems incrementally during analysis.",
      "description_length": 259,
      "index": 1749,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.PostSolver.IncrS-VH-Infix",
      "library": "goblint.solver",
      "description": "This module provides infix operators for interacting with a BatHashtbl, enabling direct value retrieval and key-value insertion. It supports operations to find a key's current binding (`-->`) and to add or update a key's value while preserving previous bindings (`<--`). These operators simplify hash table manipulation in constraint system evaluations, particularly for tracking and restoring variable bindings during analysis passes.",
      "description_length": 435,
      "index": 1750,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.PostSolver.MakeListArg",
      "library": "goblint.solver",
      "description": "Implements a list-based collection of postsolver modules that process constraint systems after the main solving phase. It works with constraint system data structures and solver results to perform tasks like warning generation, verification checks, and result pruning. Each entry in the list represents a distinct analysis or check applied to the solved constraints.",
      "description_length": 366,
      "index": 1751,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.Generic.PreciseSideEffectBoxSolver",
      "library": "goblint.solver",
      "description": "Solves constraint systems with side effects by computing a hash-map of variable-value mappings. It takes initial variable-value pairs and target variables, returning a solution for those targets. Useful for static analysis tasks like points-to analysis or taint tracking where precise variable dependencies are critical.",
      "description_length": 320,
      "index": 1752,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.PostSolver.MakeIncrListArg-VH-Infix",
      "library": "goblint.solver",
      "description": "This module provides infix operators for interacting with a BatHashtbl, supporting key-value lookups and additions with hidden prior bindings. It works directly with BatHashtbl instances and their keys and values. Concrete use cases include managing scoped or layered bindings where previous values must be temporarily overridden and later restored.",
      "description_length": 349,
      "index": 1753,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.PostSolver.S-VH-Infix",
      "library": "goblint.solver",
      "description": "This module defines infix operators for interacting with a BatHashtbl, providing direct access and scoped updates. The `-->` operator retrieves the current value associated with a key, while `<--` adds a new binding that can be undone by removing the key. These operations support incremental modifications and lookups in constraint system evaluations, such as tracking variable assignments during analysis passes.",
      "description_length": 414,
      "index": 1754,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.PostSolver.IncrS-VH-Labels",
      "library": "goblint.solver",
      "description": "This module provides labeled argument versions of standard Hashtbl operations, improving readability and argument order flexibility. It works with hashtables (VH.t) where keys are of type VH.key and values are polymorphic. Concrete use cases include adding, replacing, iterating, filtering, mapping, and merging entries in hashtables with explicit key-value handling, such as tracking variable-value mappings in static analysis or managing labeled configuration settings.",
      "description_length": 471,
      "index": 1755,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_solver.PostSolver.MakeListArg-S-Var",
      "library": "goblint.solver",
      "description": "This module defines operations for handling variables in a constraint system, including equality, hashing, comparison, and pretty-printing. It works with variables of type `S.Var.t`, which must support hashable and comparable operations. Concrete use cases include tracking variable identities, comparing and hashing variables during constraint solving, and generating readable output for debugging or reporting purposes.",
      "description_length": 421,
      "index": 1756,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_solver.PostSolver.MakeIncrListArg-S-Dom",
      "library": "goblint.solver",
      "description": "This module provides lattice-theoretic operations including join, meet, widen, and narrow, alongside utilities like hashing, pretty-printing, and serialization for elements of a lattice domain (S.Dom.t). These functions support static analysis tasks such as constraint system solving, warning generation through difference diagnostics, and verification workflows that rely on lattice properties like top element detection.",
      "description_length": 422,
      "index": 1757,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_solver.PostSolver.MakeListArg-S",
      "library": "goblint.solver",
      "description": "Implements a post-processing pass over constraint systems using a list-based argument structure. It evaluates constraints incrementally, tracking changes to variables and domains to refine solutions or generate warnings. Useful for verifying or pruning constraint systems after initial solving, based on a list of variable-domain pairs.",
      "description_length": 336,
      "index": 1758,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.Version",
      "library": "goblint.solver",
      "description": "Implements version tracking and comparison operations for constraint system solvers. Provides an integer-based identifier to distinguish solver iterations or configurations. Useful for managing incremental updates and ensuring consistency across multi-threaded analysis phases.",
      "description_length": 277,
      "index": 1759,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.Generic.SoundBoxSolverImpl",
      "library": "goblint.solver",
      "description": "The module provides operations for solving constraint systems using a sound box solver and instruments the solving process to track statistics such as variable events (creation, updates) and performance metrics (histograms, CSV logging). It operates on hash tables mapping keys to domain elements (`S.Dom.t H.t`), alongside counters and histograms for metric collection, with a focus on dataflow analysis workflows. This enables precise constraint resolution and performance debugging in scenarios requiring detailed profiling of solver behavior.",
      "description_length": 546,
      "index": 1760,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.Td3.Hooks-HM-Infix",
      "library": "goblint.solver",
      "description": "This module provides infix operators for interacting with hash tables, supporting efficient lookups and scoped updates. It works with BatHashtbl.t values, using `-->` to retrieve bindings and `<--` to add new bindings that can be reverted. Concrete use cases include managing temporary state changes during constraint solving or analysis passes where previous values must be restored after a scope ends.",
      "description_length": 403,
      "index": 1761,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_solver.PostSolver.IncrS",
      "library": "goblint.solver",
      "description": "This module evaluates constraint systems incrementally to generate warnings and verify results after solving. It tracks variable relationships using domains from `S` and variable heaps from `VH`, applying updates to individual constraints and propagating effects through `one_side` and `one_constraint`. Concrete use cases include post-analysis verification of dataflow properties and pruning unreachable code paths based on computed fixpoints.",
      "description_length": 444,
      "index": 1762,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_solver.Td3.Hooks-S-Var",
      "library": "goblint.solver",
      "description": "This module defines operations for managing and comparing variable identifiers within a constraint-solving context. It provides functions for equality checks, hashing, comparison, and pretty-printing of variables, along with utilities to retrieve variable metadata such as their associated CFG node and string identifier. It is used to support caching, lookup, and tracing of variables during incremental constraint solving.",
      "description_length": 424,
      "index": 1763,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.Td3.Hooks-S-Dom",
      "library": "goblint.solver",
      "description": "This module provides lattice-specific operations such as equality, comparison, widening/narrowing, and extremal value checks (e.g., top/bottom) for elements of `S.Dom.t` domains. These functions are critical for static analysis tasks requiring efficient merging and comparison of abstract program states, particularly in incremental or space-constrained scenarios like reanalyzing modified code or tracking lattice-based invariants. Serialization utilities further enable persistence or communication of lattice values during analysis workflows.",
      "description_length": 545,
      "index": 1764,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.PostSolver.IncrS-VH",
      "library": "goblint.solver",
      "description": "This module provides imperative and functional operations for manipulating polymorphic hash tables with keys of type `S.v`, supporting insertion, lookup, in-place updates, and transformations like filtering, merging, and key-value mapping. It includes utilities for converting hash tables to sequences, lists, or enumerations, as well as iterating over or printing key-value pairs. These operations are useful for managing dynamic mappings during post-analysis phases, such as aggregating analysis results, pruning redundant entries, or preparing data for verification tasks.",
      "description_length": 575,
      "index": 1765,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_solver.SLR.MyGenericEqSolver",
      "library": "goblint.solver",
      "description": "Solves constraint systems with equality-based propagation using a generic variable and domain representation. It performs fixed-point computation over variable domains, tracking dependencies and influence sets to efficiently update affected variables during solving. This module is used for static analysis tasks like points-to analysis or dataflow optimization where equality constraints model program behavior.",
      "description_length": 412,
      "index": 1766,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.PostSolver.Prune",
      "library": "goblint.solver",
      "description": "This module prunes constraint system solutions based on reachability analysis by tracking variable relationships and eliminating unreachable values. It operates on constraint systems represented with variables (`S.v`) and domains (`S.Dom.t`), using value heaps (`VH`) to manage intermediate states. Concrete use cases include optimizing symbolic execution results by removing dead paths and refining analysis precision after initial solving.",
      "description_length": 441,
      "index": 1767,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_solver.PostSolver.Warn",
      "library": "goblint.solver",
      "description": "This module emits warnings during a post-processing pass over a solved constraint system. It works with variables and domains from the constraint system, tracking potential issues like unreachable code or inconsistent values. Concrete use cases include reporting unused variables, unreachable control-flow nodes, and constraint violations after solving.",
      "description_length": 353,
      "index": 1768,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_solver.SolverBox.S",
      "library": "goblint.solver",
      "description": "Implements a box operator that combines two values of type `D.t` into a single value of the same type, typically used to merge results from parallel or alternative constraint-solving paths. The function is designed to work with lattice-like data structures where merging must preserve certain semantic properties. This operation is essential for narrowing or restricting the solution space in constraint solvers that handle side effects.",
      "description_length": 437,
      "index": 1769,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_solver.PostSolver.StartEqConstrSys-Dom",
      "library": "goblint.solver",
      "description": "The module provides lattice operations including join, meet, widen, and narrow for elements of type `Dom.t`, which forms a bounded lattice with top and bottom values. These operations support constraint system analysis, enabling tasks like warning generation, verification, and state pruning in static analysis workflows. Functions for comparing, serializing, and checking extremal lattice elements facilitate efficient manipulation of abstract values during solver post-processing steps.",
      "description_length": 488,
      "index": 1770,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.PostSolver.MakeListArg-VH-Labels",
      "library": "goblint.solver",
      "description": "This module provides labeled versions of standard hash table operations, enhancing readability and safety by requiring explicit argument labels. It works with hash tables (`VH.t`) where keys and values have specific types (`VH.key` and `'a`). Concrete use cases include adding, replacing, filtering, and transforming entries in a hash table, with support for in-place modifications, merging tables, and conditional updates using functions that operate on keys and values directly.",
      "description_length": 480,
      "index": 1771,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.Generic.LoadRunIncrSolver",
      "library": "goblint.solver",
      "description": "This module implements an incremental solver for constraint systems with support for serialization and reuse of intermediate states. It operates on variables and domains defined by the `S` module, using a hash table structure from `H` to store solution mappings. The solver allows loading a previous state, running incremental computations, and serializing the result for later continuation.",
      "description_length": 391,
      "index": 1772,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.PostSolver.IncrS-S-Dom",
      "library": "goblint.solver",
      "description": "This module provides lattice-theoretic operations for a domain `S.Dom.t`, including comparisons (`leq`, `join`, `meet`), extremal elements (`bot`, `top`), and approximation operators (`widen`, `narrow`). It supports static analysis domains by enabling precise value comparisons, checking for maximal or minimal constraints (`is_top`), and facilitating iterative fixpoint computations over program abstractions. The operations are essential for implementing abstract interpretation and constraint system solving in program verification.",
      "description_length": 535,
      "index": 1773,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.PostSolver.MakeListArg-VH",
      "library": "goblint.solver",
      "description": "This module provides a mutable hash table implementation with rich operations for key-value management, transformation, and sequence interconversion. It works with key-value pairs where keys are of type `S.v`, supporting existence checks, indexed filtering, in-place updates, and merging, alongside conversions to/from lists, sequences, and enumerators. It is particularly useful for scenarios requiring efficient variable tracking, constraint pruning, or structured data analysis in post-solver verification workflows.",
      "description_length": 519,
      "index": 1774,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.PostSolver.IncrS-S",
      "library": "goblint.solver",
      "description": "Performs incremental re-evaluation of constraint systems after initial solving, computing changes in variable domains based on an existing solution. Works with variables and domain values through the `Var` and `Dom` submodules, tracking differences in constraints to update results efficiently. Useful for refining analysis results when constraints evolve slightly, such as after code modifications or in iterative verification workflows.",
      "description_length": 438,
      "index": 1775,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.PostSolver.MakeIncrListArg-VH",
      "library": "goblint.solver",
      "description": "This module provides a hash table implementation for managing key-value mappings with keys of type `S.v` and polymorphic values, supporting imperative updates (insertion, deletion, in-place modifications) and functional queries (lookup, iteration, folding, filtering). It enables incremental manipulation of constraint system variables through operations like merging, transforming, and converting hash tables to sequences or lists, while also offering utilities for printing and error-handled traversals. These capabilities are particularly useful in post-processing phases for constraint-based analysis, such as refining results, generating warnings, or pruning redundant data.",
      "description_length": 679,
      "index": 1776,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.PostSolver.MakeIncrListArg-S-Var",
      "library": "goblint.solver",
      "description": "This module defines operations for managing a variable type `t` derived from a solver's variable structure, supporting equality checks, hashing, and comparison. It provides utilities to inspect variable properties, such as whether a variable is write-only, and to generate identifiers or retrieve associated control-flow nodes. These functions are used during post-processing analysis phases for tasks like trace printing, XML output, and variable relifting in constraint system evaluation.",
      "description_length": 490,
      "index": 1777,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.PostSolver.MakeListArg-VH-Exceptionless",
      "library": "goblint.solver",
      "description": "This module provides safe lookup and in-place modification operations for hash tables, returning optional values or result types instead of raising exceptions. It works with hash tables (`VH.t`) and their keys and values. Concrete use cases include safely retrieving values without handling exceptions and applying transformation functions to existing keys' values in a hash table.",
      "description_length": 381,
      "index": 1778,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_solver.Generic.LoadRunSolver",
      "library": "goblint.solver",
      "description": "Solves constraint systems by computing a hash-map of variable-value pairs from initial values and target variables. Uses data types from modules S (for variables and values) and H (for hash-maps). Useful for static analysis tasks like points-to analysis or constant propagation where constraints are iteratively resolved.",
      "description_length": 321,
      "index": 1779,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.PostSolver.EqIncrSolverFromEqSolver",
      "library": "goblint.solver",
      "description": "This module converts a non-incremental solver into one that simulates incremental behavior by solving from scratch each time. It works with constraint systems represented as variable-data pairs, producing local solutions and serialization data. It is useful when incremental solving is required but full state persistence is unnecessary, such as in analysis passes that need fresh solutions with each run while still supporting postsolving tasks like warning generation or result serialization.",
      "description_length": 494,
      "index": 1780,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_solver.PostSolver.MakeIncrListArg-VH-Exceptionless",
      "library": "goblint.solver",
      "description": "This module provides safe lookup and modification operations for imperative hashtables, returning options and result types to handle absence and errors without exceptions. It works with `VH.t`, a hashtable type, and uses `VH.key` for key types. Concrete use cases include safely retrieving values with `find` and applying in-place transformations with `modify`, which returns an error result if the key is not found.",
      "description_length": 416,
      "index": 1781,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.PostSolver.MakeIncrListArg-module-type-M",
      "library": "goblint.solver",
      "description": "Implements incremental list-based constraint propagation with variable heaps. Processes constraints by refining variable domains through side-effecting updates to heap-allocated variables. Used for post-solution analysis phases like warning generation and constraint pruning in static analysis workflows.",
      "description_length": 304,
      "index": 1782,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_solver.Td3.Hooks-HM-Labels",
      "library": "goblint.solver",
      "description": "This module provides labeled argument variants of standard hash table operations, enhancing readability and safety when working with key-value pairs. It supports common manipulations such as adding, replacing, filtering, mapping, and folding over hash tables, with functions that accept labeled keys and data. Use cases include managing dynamic mappings where argument clarity and order flexibility are important, such as tracking variable bindings, caching intermediate analysis results, or handling configuration settings.",
      "description_length": 524,
      "index": 1783,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.EffectWConEq.Make",
      "library": "goblint.solver",
      "description": "This module orchestrates constraint solving by integrating runtime analysis tracking with variable and domain management, using histogram maps to quantify events like variable creation and evaluation. It processes key-domain pairs to compute solutions while maintaining state through variable sets, supporting tasks like performance profiling and constraint system analysis. The child module enhances this by providing ordered variable sets (`VS.t`) with efficient set operations, rank-based access, and ordered iteration, enabling precise manipulation of variable collections for static analysis passes. Together, they allow operations like mapping over variable sets, extracting extremal elements, and tracking domain changes during constraint resolution.",
      "description_length": 757,
      "index": 1784,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.PostSolver.Verify",
      "library": "goblint.solver",
      "description": "This module performs a post-solution verification pass over constraint systems by evaluating individual constraints and variable relationships. It works with variable handlers (VH) and domain values (S.Dom.t) to verify consistency between computed solutions and original constraints. Concrete use cases include checking correctness of demand-driven analyses, validating variable equalities, and ensuring constraint satisfaction after solving.",
      "description_length": 442,
      "index": 1785,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_solver.PostSolver.ListArgFromStdArg",
      "library": "goblint.solver",
      "description": "This module implements postsolvers for static analysis that generate warnings or prune results based on standard argument evaluation. It operates on constraint systems using variable hierarchies and analysis states, with core data types including constraint variables (`S.v`), domains (`S.Dom.t`), and variable heaps (`VH.t`). The postsolvers enforce constraints during analysis finalization, such as checking variable bounds or raising warnings from derived values. It supports list-based result extraction from standard argument analysis, enabling precise post-processing in static analysis passes.",
      "description_length": 600,
      "index": 1786,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_solver.TopDown_deprecated.TD3",
      "library": "goblint.solver",
      "description": "This module implements a top-down constraint solving strategy for dataflow analysis, combining variable set manipulation, domain-specific solving, and partitioned map operations to process constraints hierarchically. It centers around variables, abstract domains, and structured contexts, using histograms and counters to track interactions and context reuse, with support for profiling through CSV logging. The core functionality is extended by modules that manage variable sets with ordered and functional operations, represent variable pairs for efficient comparison, and handle polymorphic key-value maps with imperative and higher-order transformations. Examples include static analysis passes tracking dependencies, constraint solving with priority-based map updates, and performance evaluation of solving strategies through logged metrics.",
      "description_length": 846,
      "index": 1787,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_solver.Td3.Hooks-HM",
      "library": "goblint.solver",
      "description": "This module provides imperative and functional operations for managing polymorphic key-value stores where keys are program variables (`S.v`), supporting efficient insertion, modification, and querying alongside bulk transformations like merging, filtering, and conversion to sequences. It enables space-efficient incremental analysis by allowing in-place mutations and selective state restoration, particularly for caching intermediate results at widening points during constraint solving. Use cases include tracking variable bindings during iterative analysis, merging abstract values from different program paths, and compactly representing solver state for interactive reanalysis.",
      "description_length": 683,
      "index": 1788,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.PostSolver.MakeIncrList",
      "library": "goblint.solver",
      "description": "This module constructs an incremental postsolving function from a list of postsolvers, executing them in sequence if the list is non-empty. It operates on constraint systems with variable and domain types defined by the `Arg` module, specifically processing lists of variable-domain pairs and mappings from variables to domains. It is used to apply post-processing steps like warning generation or result pruning after constraint solving.",
      "description_length": 438,
      "index": 1789,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SolverBox.Widen",
      "library": "goblint.solver",
      "description": "Implements a widening operator that combines two values of type `D.t` to approximate their upper bound, typically used to accelerate fixpoint convergence in abstract interpretation. Works with lattice-like data structures where `D.t` represents abstract domain elements. Useful in static analysis for efficiently computing over-approximations of program behaviors.",
      "description_length": 364,
      "index": 1790,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.JustWiden",
      "library": "goblint.solver",
      "description": "This module implements a constraint solver with customizable widening and restart strategies, using hash maps to track inflation points, widening points, and restart modes. It supports variables mapped to domain elements through constraint propagation, with utilities to find and retrieve values using default handling. The solver accelerates convergence via heuristics and is used in static analysis of multi-threaded programs. Submodules manage value associations, global contributions, key sets, variable dependencies, lattice operations, influence lists, and priority queues. They provide concrete operations such as infix operators for variable state retrieval and update, dependency tracking, and worklist management with dynamic priorities. These components support iterative fixed-point computations, constraint solving, and scalable thread-modular analysis through imperative hash tables, polymorphic maps, and custom comparison logic. Key data types include hash maps, sets, lattice elements, and priority queues, with operations tailored to abstract interpretation and constraint-based solving.",
      "description_length": 1105,
      "index": 1791,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SolverBox.NarrowOption",
      "library": "goblint.solver",
      "description": "Implements a narrowing operator that combines two values of type `D.t` to produce a more precise value of the same type. Works specifically with constraint domains that support precision refinement through narrowing. Useful in abstract interpretation for iteratively improving fixpoint approximations in constraint solving.",
      "description_length": 323,
      "index": 1792,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_solver.PostSolver.EqConstrSysFromStartEqConstrSys",
      "library": "goblint.solver",
      "description": "This module modifies constraint systems by joining start values into right-hand sides, simplifying start value handling during constraint solving. It operates on constraint systems where variables (`v`) and data (`d`) are defined by the parameter module `S`, and it provides a functional representation of the system along with incremental change computation. It is used to improve constraint system initialization and evaluation in solver implementations.",
      "description_length": 456,
      "index": 1793,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.Td3.DepVals",
      "library": "goblint.solver",
      "description": "Stores and manages variable-value dependencies during constraint solving, specifically tracking which values depend on which variables. It supports operations like copying and relifting marshaled solver states, and solving constraints incrementally while selectively retaining values at widening points. This module is used when reanalyzing program abstractions incrementally, such as after code changes, to avoid full recomputation.",
      "description_length": 433,
      "index": 1794,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.PostSolver.MakeIncrListArg-VH-Labels",
      "library": "goblint.solver",
      "description": "This module provides labeled argument versions of standard Hashtbl operations, improving readability and safety by requiring explicit labeling of arguments like `key` and `data`. It works with hashtables (`VH.t`) where keys are of type `VH.key` and values are polymorphic. Concrete use cases include adding, replacing, filtering, and transforming entries in a type-safe manner, such as using `modify` to update values at specific keys or `filteri` to selectively retain entries based on both key and data.",
      "description_length": 505,
      "index": 1795,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.PostSolver.S-VH",
      "library": "goblint.solver",
      "description": "This module provides imperative hash table operations for managing key-value associations with keys of type `S.v`, supporting creation, mutation, traversal, and transformation of hash table entries. It works primarily with `VH.t` data structures, enabling dictionary-like manipulations such as conditional updates, bulk filtering, and merging with custom logic. These capabilities are particularly useful for post-processing constraint system results, such as pruning invalid states, aggregating verification outcomes, or generating structured diagnostic outputs through sequence conversions and formatting utilities.",
      "description_length": 617,
      "index": 1796,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_solver.Generic.DirtyBoxSolver",
      "library": "goblint.solver",
      "description": "Solves constraint systems using a simple iterative algorithm, computing a local solution for specified variables from initial values. Operates on variables and domains defined by the `S` module, with results stored in a hash-map from `H`. Useful for analyses where constraints are expressed as variable dependencies and solved via fixed-point iteration.",
      "description_length": 353,
      "index": 1797,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.PostSolver.F",
      "library": "goblint.solver",
      "description": "Implements a post-processing pass over constraint systems to refine results and generate warnings or verifications. It operates on variables and domains from the constraint system, using value abstractions and variable mappings. This module is used to analyze and prune unreachable or inconsistent states after initial constraint solving.",
      "description_length": 338,
      "index": 1798,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.SLR3",
      "library": "goblint.solver",
      "description": "This module performs constraint solving and domain analysis for multi-threaded C programs, tracking variable creation, evaluation, and updates while computing variable-domain bindings and performance metrics. It operates on variables (`S.Var.t`), domains (`S.Dom.t`), variable sets (`VS`), partitions (`P`), and hash-based maps (`HPM`), supporting operations like union, mapping, and stateful transformations using infix operators `(-->)` and `(<--)`. Child modules enhance these capabilities with imperative hash tables for dynamic constraint state, ordered sets for label tracking and selection, and pair operations for comparing variable tuples. Example uses include modifying constraint maps during analysis, filtering variable sets based on predicates, and managing thread-local variable bindings with labeled key transformations.",
      "description_length": 835,
      "index": 1799,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_solver.PostSolver.SaveRun",
      "library": "goblint.solver",
      "description": "This module performs a postsolve analysis pass to track and store constraint system results for the `save_run` option. It records variable assignments, constraints, and reachability information during solver execution. Use cases include capturing solver state for debugging, analysis verification, and pruning unreachable paths post-execution.",
      "description_length": 343,
      "index": 1800,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.LocalFixpoint.Make",
      "library": "goblint.solver",
      "description": "Implements fixpoint iteration for a single transfer function using a given domain. It provides the `lfp` function to compute the least fixpoint with an optional initial value. Useful for dataflow analysis where a function's effect is iteratively applied until stabilization within a domain.",
      "description_length": 290,
      "index": 1801,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.PostSolver.Compose",
      "library": "goblint.solver",
      "description": "This module implements sequential composition of two postsolvers, applying one after the other. It processes constraint systems by propagating values through variables and refining results during initialization, constraint evaluation, and finalization stages. It is used to chain postsolver logic, such as warning generation followed by verification or pruning.",
      "description_length": 361,
      "index": 1802,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.Td3.Hooks",
      "library": "goblint.solver",
      "description": "Implements hooks for managing solver data during incremental constraint solving, including deletion, pruning, and value restoration. Operates on constraint variables (`S.v`) and maps (`HM.t`) to track and manipulate solver state. Used to optimize space by caching values at widening points and restoring them during reanalysis.",
      "description_length": 327,
      "index": 1803,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.PostSolver.S-S-Var",
      "library": "goblint.solver",
      "description": "This module defines operations for handling variables in a constraint system, including equality checks, hashing, comparison, and identification. It works with variable types that must be hashable and comparable, supporting use cases like tracking variable identities, generating pretty-printed output, and extracting associated control flow nodes. Specific functions enable efficient variable comparison, XML serialization, and variable relifting for analysis refinement.",
      "description_length": 472,
      "index": 1804,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.Td3.Hooks-S",
      "library": "goblint.solver",
      "description": "Implements hooks for managing incremental updates and caching in a top-down abstract interpretation solver. It works with variables (`v`) and abstract values (`d`), using constraint systems derived from variable and domain modules. Enables efficient reanalysis of program constraints by tracking changes and restoring previous states at widening points.",
      "description_length": 353,
      "index": 1805,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.PostSolver.S",
      "library": "goblint.solver",
      "description": "Implements a post-processing pass for constraint systems with hooks to track and analyze variable relationships. Operates on constraint variables and domains, enabling actions like warning generation or pruning based on variable assignments. Used to enforce verification conditions or emit diagnostics after solving completes.",
      "description_length": 326,
      "index": 1806,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLRphased.Make",
      "library": "goblint.solver",
      "description": "This module implements a two-phased SLR3 solver for constraint system analysis, integrating counters, histograms, and CSV logging to monitor solver behavior during fixed-point computation. It operates on variable sets and abstract domains, using efficient helper structures like polymorphic hash maps (`HPM.t`) for imperative constraint aggregation, transformation, and state management across solver phases. Core operations support merging, filtering, and bidirectional constraint updates, while submodules handle variable ordering, set manipulation, and hashing of constraint pairs for efficient comparison. Example uses include refining variable mappings during static analysis, tracking dependencies in dataflow analysis, and optimizing termination-sensitive fixed-point computations with detailed performance instrumentation.",
      "description_length": 830,
      "index": 1807,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.PostSolver.MakeListArg-S-Dom",
      "library": "goblint.solver",
      "description": "This module provides lattice operations and utility functions for a domain type `S.Dom.t`, including equality checks, comparison, hashing, and serialization, alongside core lattice primitives like `join`, `meet`, `widen`, `narrow`, and extremal element detection (`bot`, `top`, `is_bot`, `is_top`). It works with lattice-structured values of type `S.Dom.t`, enforcing lattice semantics to enable precise constraint system analysis. These operations are critical for post-solver tasks like verification, pruning, and warning generation in static analysis workflows.",
      "description_length": 564,
      "index": 1808,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SolverBox.Warrow",
      "library": "goblint.solver",
      "description": "Implements a box operator for warrowing solvers that combines two values of type `D.t` into a single value of the same type. The operation is used to merge intermediate results during constraint system solving. This supports combining dataflow information from different program points in static analysis.",
      "description_length": 305,
      "index": 1809,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.PostSolver.MakeList",
      "library": "goblint.solver",
      "description": "This module assembles a complete postsolving function from a list of individual postsolvers, enabling coordinated post-processing of constraint system results using variables and domains. It combines imperative hash table operations for key-value manipulation with incremental argument handling to refine analysis results, supporting tasks like invariant verification, constraint pruning, and diagnostic generation. Main data types include lists of variable-value pairs, domains with lattice operations, and hash tables for efficient lookups and transformations. Examples include aggregating multiple analysis checks, tracking variable usage, and safely modifying constraint labels during solver passes.",
      "description_length": 703,
      "index": 1810,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.Make0",
      "library": "goblint.solver",
      "description": "This module implements a constraint solver for static analysis of multi-threaded C programs, combining domain tracking, dependency management, and state propagation. It uses hash maps, worklists, and priority queues to manage variable relationships, influence lists, and global contributions, supporting operations like constraint solving, dependency tracking, and fixed-point computation. Key data types include variable pairs, domain values, and priority-ordered elements, with operations for safe updates, influence manipulation, and lattice transformations. Examples include tracking synchronization effects through dependency maps, prioritizing variable processing with custom comparison functions, and refining analysis states via propagation of global constraints.",
      "description_length": 771,
      "index": 1811,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SolverStats",
      "library": "goblint.solver",
      "description": "Tracks and reports statistics for constraint system solvers, including variable counts, evaluation counts, and reuse during narrowing. Uses mutable integer references to accumulate metrics and provides functions to print or reset the collected data. Useful for analyzing solver performance in specific solving tasks.",
      "description_length": 316,
      "index": 1812,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_solver.LocalFixpoint",
      "library": "goblint.solver",
      "description": "This module computes least fixpoints for iterative dataflow analysis using a single transfer function and a specified domain. It centers on the `lfp` function, which applies the transfer function repeatedly until stabilization, optionally starting from a provided initial value. The core data types include the domain elements and the transfer function itself, both abstracted to support various analysis contexts. For example, it can analyze program properties like constant propagation or liveness by iterating a transfer function over a control-flow graph until the state stabilizes.",
      "description_length": 586,
      "index": 1813,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.TopDown_deprecated",
      "library": "goblint.solver",
      "description": "This module provides a top-down constraint solving framework for dataflow analysis, organizing variables, abstract domains, and contexts into a structured hierarchy. It supports operations like variable set manipulation, map partitioning, and domain-specific solving, with profiling through CSV logging and performance tracking via histograms and counters. You can use it to implement static analysis passes that track dependencies, solve constraints with priority-based updates, or evaluate solving strategies using logged metrics. Key data types include variable sets, variable pairs, and polymorphic key-value maps with imperative and functional transformations.",
      "description_length": 665,
      "index": 1814,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLRphased",
      "library": "goblint.solver",
      "description": "This module implements a two-phased SLR3 solver for constraint system analysis with built-in instrumentation for monitoring and logging. It operates on variable sets and abstract domains, using polymorphic hash maps for efficient constraint aggregation, transformation, and state management across phases. Key operations include merging, filtering, and bidirectional constraint updates, with support for variable ordering, set manipulation, and hashing of constraint pairs. It can refine variable mappings in static analysis, track dependencies in dataflow analysis, and optimize termination-sensitive fixed-point computations with detailed performance metrics via CSV logging.",
      "description_length": 677,
      "index": 1815,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.TopDown",
      "library": "goblint.solver",
      "description": "This module integrates profiling and constraint-solving to enable static analysis via abstract interpretation, tracking variables and memory across domains and partitioned states. It provides data types like variable sets, predicate maps, and polymorphic hash tables, supporting operations for state transformation, constraint resolution, and membership queries. You can use it to perform program verification, analyze memory usage, and refine constraints iteratively. For example, it enables symbolic reasoning over variable relationships and bulk updates to analysis states during program inspection.",
      "description_length": 602,
      "index": 1816,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLRterm",
      "library": "goblint.solver",
      "description": "This module implements a terminating SLR3 solver using hashmap-based structures to track variables and abstract values, ensuring guaranteed termination during fixed-point computation. It supports imperative state manipulation through hash maps and variable sets, with operations for domain narrowing, atomic updates, and labeled set transformations, particularly useful for points-to analysis and interval tracking. The API enables precise constraint solving via key-based modifications and includes utilities for ordered traversal, element selection, and efficient variable pairing. Example uses include analyzing program variables for possible memory targets or numeric ranges under side-effecting constraints.",
      "description_length": 712,
      "index": 1817,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.Selector",
      "library": "goblint.solver",
      "description": "This module dynamically selects and delegates constraint-solving tasks to a runtime-configured solver, enabling flexible strategy switching based on string identifiers or configuration settings. It maintains a registry of solvers implementing the `ConstrSys.GenericEqIncrSolver` interface, supporting operations on variables (`S.v`), domains (`S.d`), and value hierarchies (`VH`), including state marshaling and copying. You can use it to switch between a fixed-point solver, custom algorithms, or analysis-driven strategies without recompilation. The child module integrates with `GobConfig` to automatically select solvers based on string settings, enabling seamless runtime configuration of constraint-solving behavior.",
      "description_length": 722,
      "index": 1818,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "Goblint_solver.SLR",
      "library": "goblint.solver",
      "description": "This module implements SLR solvers for constraint systems arising in the static analysis of multi-threaded C programs, combining narrowing operations with state transformers to refine program states iteratively. It supports generic constraint solving through hash maps, priority queues, and lattice-based operations, enabling fixed-point computation, dependency tracking, and influence analysis across threads. Child modules provide concrete solvers for equality propagation, version tracking, and priority-driven solving, along with utilities for worklist management, domain analysis, and influence graph construction. Example tasks include analyzing synchronization effects, computing variable equivalences, and prioritizing constraint resolution to optimize convergence in thread-modular analysis.",
      "description_length": 800,
      "index": 1819,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.TopDown_term",
      "library": "goblint.solver",
      "description": "This module implements a top-down abstract interpretation solver focused on termination analysis through worklist-based fixpoint computation. It centers on solver variables and domains, managing mutable state, evaluation phases, and constraint resolution while tracking statistics like update counts and dependencies. Set-theoretic operations and variable pair equality support dependency tracking and traversal optimizations. Example use cases include analyzing program properties through abstract domains, resolving constraints via hashing, and exporting evaluation metrics to CSV for performance analysis.",
      "description_length": 608,
      "index": 1820,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.EffectWConEq",
      "library": "goblint.solver",
      "description": "This module coordinates constraint solving by combining runtime analysis with variable and domain management, using histogram maps to track events such as variable creation and evaluation. It processes key-domain pairs to compute solutions while maintaining state through ordered variable sets (`VS.t`), which support efficient set operations, rank-based access, and ordered iteration. These structures enable precise manipulation of variable collections for static analysis, including mapping over sets, extracting minimum or maximum elements, and monitoring domain changes during resolution. Example uses include profiling constraint system performance and iteratively refining variable domains based on computed constraints.",
      "description_length": 727,
      "index": 1821,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.Generic",
      "library": "goblint.solver",
      "description": "This module suite provides solvers and utilities for constraint system resolution, focusing on static analysis tasks like dataflow analysis, points-to analysis, and taint tracking. It centers around hash-map-based solutions mapping variables to domain values, supporting iterative, incremental, and instrumented solving with performance tracking via counters, histograms, and CSV logging. Operations include solving from initial values, monitoring variable events, serializing states, and exporting metrics. Examples include computing fixed points for variable dependencies, analyzing solver performance, and resuming incremental analysis from saved states.",
      "description_length": 657,
      "index": 1822,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SolverBox",
      "library": "goblint.solver",
      "description": "This module provides operators for merging and refining constraint-solving results within lattice-like data structures. It includes a box operator for combining values to narrow solution spaces, a widening operator for accelerating fixpoint convergence, and a narrowing operator for refining approximations iteratively. These operations support static analysis tasks such as merging dataflow information from different program points or improving the precision of abstract interpretations. For example, box can merge parallel solver results, widening can approximate upper bounds efficiently, and narrowing can refine over-approximated constraints stepwise.",
      "description_length": 657,
      "index": 1823,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_solver.PostSolver",
      "library": "goblint.solver",
      "description": "This module performs post-processing on constraint systems to refine solutions, generate warnings, and verify results after initial solving. It operates on constraint variables and domains, supporting lattice operations like `join`, `meet`, `widen`, and `narrow`, and uses hash tables for efficient variable-value mapping and in-place updates. Submodules handle configuration, incremental processing, variable comparison, and lattice semantics, enabling tasks like pruning unreachable paths, checking solution consistency, and emitting diagnostics based on solved constraints. Examples include verifying dataflow properties, refining symbolic execution results, and managing scoped variable bindings during analysis passes.",
      "description_length": 723,
      "index": 1824,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_solver.Td3",
      "library": "goblint.solver",
      "description": "The module orchestrates incremental constraint solving over abstract domains, using a top-down, space-efficient strategy that caches intermediate results and restores values selectively at widening points. It manages constraint graphs with variables tied to control-flow nodes, leveraging hash tables (`HM.t`) and ordered sets (`VS.t`) for efficient state updates, lookups, and dependency tracking. Operations include fixed-point computation, lattice-based merging and comparison, and scoped state manipulation via infix operators for temporary bindings. Submodules refine variable identity, domain behavior, and table operations, enabling precise, interactive reanalysis of program abstractions after small changes without full recomputation.",
      "description_length": 743,
      "index": 1825,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.TopDown_space_cache_term",
      "library": "goblint.solver",
      "description": "This module implements a terminating top-down solver for abstract interpretation, combining fixed-point computation with space-efficient caching and profiling. It provides data types for solver variables, variable pairs, and constraint systems, supporting operations like widening, narrowing, and dependency tracking through ordered sets and hash-based keys. Users can perform iterative analysis with runtime diagnostics, manipulate variables and constraints directly, and apply the solver to tasks like dataflow optimization and invariant detection. Example use cases include tracking variable dependencies in a program or computing memory-efficient abstract states with controlled termination.",
      "description_length": 695,
      "index": 1826,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_solver.Worklist",
      "library": "goblint.solver",
      "description": "This module implements a worklist-based solver for constraint systems using abstract domains, enabling efficient propagation and context-sensitive analysis through operations like `solve` and `eq`. It manages variables (`S.Var.t`), domain values (`S.Dom.t`), hash maps (`HM.t`), and variable sets (`VS.t`), with optional CSV logging for debugging. Child modules provide functional variable set operations\u2014union, intersection, difference, and ordered traversal\u2014for precise manipulation and iterative solving. These capabilities support tasks like dataflow analysis and dependency management, where sets track variable states and guide fixed-point computations.",
      "description_length": 659,
      "index": 1827,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver",
      "library": "goblint.solver",
      "description": "This module suite provides a comprehensive framework for constraint system solving and abstract interpretation, centered on iterative fixed-point computation, domain manipulation, and dependency tracking. Key data types include variables, domains, variable sets, hash maps, and constraint systems, with operations for widening, narrowing, merging, and solving under various analysis strategies. It enables tasks like dataflow analysis, points-to analysis, and program verification through configurable solvers that support profiling, incremental updates, and runtime strategy selection. Example applications include refining variable ranges, tracking memory targets, and analyzing multi-threaded program behavior using priority-driven or worklist-based constraint resolution.",
      "description_length": 775,
      "index": 1828,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ConstrSys.GlobSolverFromEqSolver.EqSys.Var",
      "library": "goblint.constraint",
      "description": "This module defines operations for handling variables in a constraint system, supporting equality checks, hashing, comparison, and pretty-printing. It works with a variant type representing global and local variables, each tied to specific solver contexts. Concrete use cases include tracking variable identities, comparing variables during constraint resolution, and generating human-readable output for debugging constraint systems.",
      "description_length": 434,
      "index": 1829,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ConstrSys.GlobSolverFromEqSolver.VH.Exceptionless",
      "library": "goblint.constraint",
      "description": "This module provides safe lookup and modification operations for hash tables, returning optional values or result types instead of raising exceptions. It works with hash tables (`Hashtbl`) where keys and values have specific types. Use cases include safely retrieving values without checking existence first and updating entries in a transactional manner, handling errors explicitly.",
      "description_length": 383,
      "index": 1830,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ConstrSys.GlobSolverFromEqSolver.VH.Infix",
      "library": "goblint.constraint",
      "description": "This module provides infix operators for interacting with a BatHashtbl. It supports two operations: `(-->)` to retrieve the current binding of a key, and `(<--)` to add a new binding that hides previous ones. These operators simplify hash table manipulation in constraint system solving workflows, particularly when managing temporary variable assignments.",
      "description_length": 356,
      "index": 1831,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ConstrSys.GlobConstrSolFromEqConstrSol.VH.Exceptionless",
      "library": "goblint.constraint",
      "description": "Implements safe lookup and modification operations for variable mappings in constraint systems. Works with `'a VH.t` hashtables keyed by `VH.key`, handling errors without exceptions via `result` returns. Used to access and update variable bindings during constraint solving when converting equality constraints to global constraints.",
      "description_length": 333,
      "index": 1832,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ConstrSys.GlobConstrSolFromEqConstrSol.VH.Infix",
      "library": "goblint.constraint",
      "description": "This module provides functions to convert solutions from an equality constraint system to a global constraint system by splitting and mapping solution values. It operates on constraint system solutions represented in a hash table-like structure (`VH.t`) with keys of type `VH.key`. Concrete use cases include transforming solved variable assignments from a unified system into separate, structured solutions for distinct constraint domains.",
      "description_length": 440,
      "index": 1833,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ConstrSys.GlobConstrSolFromEqConstrSol.S2.Var",
      "library": "goblint.constraint",
      "description": "This module defines operations for handling variables in a constraint system solution, specifically supporting equality checks, hashing, comparison, and pretty-printing. It works with a variant type `t` that represents either global or local variables from an underlying system. Concrete use cases include tracking variable identities, comparing and hashing variables during solution processing, and generating human-readable output for debugging or trace logging.",
      "description_length": 464,
      "index": 1834,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ConstrSys.GlobConstrSolFromEqConstrSol.VH.Labels",
      "library": "goblint.constraint",
      "description": "This module provides operations for manipulating hash tables with keys of type `VH.key` and arbitrary data values. It supports adding, replacing, modifying, and filtering key-value pairs, along with higher-order functions for mapping, folding, and merging. These operations are used to construct and transform constraint solutions by processing key-value mappings derived from equation constraint systems.",
      "description_length": 405,
      "index": 1835,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ConstrSys.GlobSolverFromEqSolver.EqSys.Dom",
      "library": "goblint.constraint",
      "description": "This module implements lattice operations and utilities for a sum type `t` that combines two underlying domains (`S.G.t` and `S.D.t`) with extremal elements (`Bot`, `Top`), enabling lifted computations over composite abstract values. It provides widening and narrowing operators to approximate fixpoints in static analysis, where `widen` expands value approximations and `narrow` refines them during iterative program analysis. The domain supports scenarios requiring precise yet efficient reasoning about constraints that mix distinct data properties, such as equality and global state tracking.",
      "description_length": 596,
      "index": 1836,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ConstrSys.GlobSolverFromEqSolver.VH.Labels",
      "library": "goblint.constraint",
      "description": "This module provides labeled versions of standard hash table operations, enhancing readability and argument order flexibility. It works with hash tables (`VH.t`) where keys are of type `VH.key`. Concrete use cases include safely adding, replacing, iterating over, filtering, and merging key-value pairs in hash tables using labeled functions.",
      "description_length": 342,
      "index": 1837,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ConstrSys.GlobConstrSolFromEqConstrSol.S2.Dom",
      "library": "goblint.constraint",
      "description": "This module provides lattice operations (join, meet, widening, narrowing) for a hierarchical domain combining two abstract domains (`S.G.t` and `S.D.t`) via a sum type with explicit bottom (`Bot`), top (`Top`), and lifted value constructors. It supports abstract interpretation workflows by managing polymorphic variant-based value lifting and fixpoint acceleration in constraint system transformations, particularly for splitting solutions across hierarchical domains. The operations enable precise yet efficient analysis of program properties through structured combination of base domains with customizable merging logic.",
      "description_length": 624,
      "index": 1838,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ConstrSys.GlobSolverFromEqSolver.VH",
      "library": "goblint.constraint",
      "description": "This module manages key-value associations with imperative and functional hash table operations, supporting insertion, lookup, filtering, merging, and in-place modification using keys of type `EqSys.v`. It integrates safe lookup and modification via optional and result types, infix operators for key binding and retrieval, and labeled functions for clarity and argument flexibility. Operations target `VH.t` hash tables, lists, enums, and sequences, enabling efficient traversal and transformation in symbolic variable tracking and dynamic binding scenarios. Examples include transactional updates with explicit error handling, temporary variable assignment with operator-based syntax, and structured key-value manipulation using labeled functions.",
      "description_length": 749,
      "index": 1839,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ConstrSys.GlobConstrSolFromEqConstrSol.VH",
      "library": "goblint.constraint",
      "description": "This module manages polymorphic key-value mappings keyed by variable identifiers, supporting creation, insertion, lookup, and in-place modification using hash tables. It enables conversions between hash tables and sequence-based structures, facilitating the splitting and transformation of constraint solutions across different systems during resolution tasks. The module provides safe access and modification via result-typed operations, higher-order functions for mapping and folding, and utilities to convert and split constraint solutions into structured domain-specific outputs. For example, it can transform a unified variable assignment into separate constraint system solutions or iteratively process key-value pairs derived from equation systems.",
      "description_length": 755,
      "index": 1840,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ConstrSys.CurrentVarEqConstrSys.S",
      "library": "goblint.constraint",
      "description": "Implements constraint system operations for tracking and updating variable dependencies during evaluation. It provides `sys_change` to compute incremental updates based on a variable's current solution and `system` to retrieve the constraint function for a variable. Works with variable (`v`) and data (`d`) types to manage dynamic constraint propagation in iterative solving processes.",
      "description_length": 386,
      "index": 1841,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ConstrSys.GlobConstrSolFromEqConstrSol.S2",
      "library": "goblint.constraint",
      "description": "This module coordinates variable and domain operations to split and refine constraint system solutions, supporting incremental updates to variable bindings and domain values during global analysis. It combines variable management\u2014such as equality, comparison, and pretty-printing\u2014with hierarchical domain transformations including join, meet, and widening over combined abstract domains. You can use it to evolve a solution by modifying individual variables or lifting domain values across analysis phases, enabling efficient and precise constraint resolution in dynamic analysis scenarios. The integration of variable identity tracking and domain lattice operations facilitates complex constraint manipulations while maintaining solution consistency across evolving states.",
      "description_length": 774,
      "index": 1842,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ConstrSys.GlobSolverFromEqSolver.Splitter",
      "library": "goblint.constraint",
      "description": "Splits a combined solution into its domain and variable parts using pattern matching on the solution structure. Works with tagged tuples of variable mappings and domain data. Used to separate constraint solutions into variable assignments and domain constraints for further processing.",
      "description_length": 285,
      "index": 1843,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ConstrSys.GlobSolverFromEqSolver.Sol'",
      "library": "goblint.constraint",
      "description": "This module provides operations for copying and transforming marshaled solver states, along with a function to compute local solutions for a set of variables given initial values. It works with marshaled solver data structures and variable-value pairs, producing a hash-map of solutions and updated solver state. Concrete use cases include incremental constraint solving and serialization of solver progress during iterative computations.",
      "description_length": 438,
      "index": 1844,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ConstrSys.GlobSolverFromEqSolver.EqSys",
      "library": "goblint.constraint",
      "description": "This module solves constraint systems by integrating incremental updates into a unified solver, managing variables and domains through structured types like `Var2` and `Lift2`. It enables operations such as equality checks, comparison, and pretty-printing on variables, while supporting lifted lattice computations over composite domains with widening and narrowing for efficient fixpoint approximation. You can track variable identities during constraint resolution, generate readable debug output, and perform precise static analysis on evolving constraint sets. The combination of variable management and lifted domain operations makes it suitable for applications like symbolic execution and program analysis where constraints and abstract values evolve iteratively.",
      "description_length": 770,
      "index": 1845,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "ConstrSys.GlobConstrSys-D",
      "library": "goblint.constraint",
      "description": "This module provides lattice-based operations for a domain structure `D.t`, including join, meet, ordering (`leq`), extremal value management (`top`, `is_top`), and convergence-driven widening/narrowing. It offers utilities for serialization, comparison, and debugging, targeting abstract interpretation and constraint solving scenarios requiring domain analysis and iterative convergence.",
      "description_length": 389,
      "index": 1846,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "ConstrSys.GenericEqSolver",
      "library": "goblint.constraint",
      "description": "Translates a constraint system into a solution hash-table by solving for specified variables given initial values. Uses modules S for system representation and H for hash-table operations. Solves practical problems like evaluating dependencies in build systems or resolving variable assignments in configuration management.",
      "description_length": 323,
      "index": 1847,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ConstrSys.GlobConstrSys-G",
      "library": "goblint.constraint",
      "description": "This module provides lattice operations (join, meet, widen, narrow) and global state interrogation capabilities for constraint systems. It works with constraint types that form a lattice structure, supporting comparisons, ordering checks, and stateful queries about top elements. The design enables use cases like static program analysis where constraints must be combined, approximated, and validated against global system invariants.",
      "description_length": 435,
      "index": 1848,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ConstrSys.MonSystem-Var",
      "library": "goblint.constraint",
      "description": "This module defines operations for managing variables within a constraint system, including equality checks, hashing, comparison, and identification. It works with variables that must support hashing, comparison, and pretty-printing, often tied to program analysis nodes. Concrete use cases include tracking variable identities during dataflow analysis, comparing and hashing variables for constraint solving, and generating XML or textual representations for debugging or output.",
      "description_length": 480,
      "index": 1849,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "ConstrSys.GlobConstrSys",
      "library": "goblint.constraint",
      "description": "Maintains a mutable constraint system with global and local variables. It supports evaluating constraints using variable readers and writers, and tracking changes to variables. Useful for incremental computation where local and global state must be updated and queried efficiently.",
      "description_length": 281,
      "index": 1850,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ConstrSys.GenericEqIncrSolverBase",
      "library": "goblint.constraint",
      "description": "This module defines an incremental solver for constraint systems, producing solutions as hash tables and supporting marshaling of internal state. It operates on variable and domain types provided by the `S` module, with hash table functionality from `H`. Use cases include solving constraint systems while maintaining serializable state for incremental updates.",
      "description_length": 361,
      "index": 1851,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ConstrSys.EqConstrSysFromGlobConstrSys",
      "library": "goblint.constraint",
      "description": "Translates a global constraint system into an equivalent equality-based constraint system. It operates on variable and domain types derived from the parameter module `S`, supporting incremental updates based on existing solutions. This module is used to adapt constraint systems for solvers that require equality constraints, enabling precise analysis of program properties like data flow and type inference.",
      "description_length": 408,
      "index": 1852,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ConstrSys.EqConstrSys",
      "library": "goblint.constraint",
      "description": "Maintains a system of equations over lattice domains, where variables (`v`) are associated with values (`d`) through constraint propagation. It supports incremental updates based on an existing solution, allowing efficient recomputation of changed constraints. Useful for static analysis tasks like dataflow analysis, where variable domains evolve through iterative solving of interdependent constraints.",
      "description_length": 404,
      "index": 1853,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ConstrSys.GenericEqIncrSolver",
      "library": "goblint.constraint",
      "description": "Implements an incremental constraint-solving algorithm that tracks changes to variable domains and supports postsolving adjustments. Operates on variable-value pairs and hash-maps to manage solution states efficiently. Useful for dynamic constraint systems where variables or constraints are updated iteratively, such as in configuration or planning tools.",
      "description_length": 356,
      "index": 1854,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "ConstrSys.EqConstrSys-Var",
      "library": "goblint.constraint",
      "description": "This module defines operations for managing variables within a constraint system, including equality checks, hashing, comparison, and identification. It works with variables that must support hashing, comparison, and pretty-printing, often tied to program analysis entities like CFG nodes. Concrete use cases include tracking variable identities during dataflow analysis, comparing and hashing variables for constraint solving, and generating XML or textual representations for debugging and trace output.",
      "description_length": 505,
      "index": 1855,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "ConstrSys.IncrSolverArg",
      "library": "goblint.constraint",
      "description": "This module defines a set of boolean flags that control the behavior of an incremental constraint solver. It specifies whether the solver should perform pruning, verification, warning generation, or saving of the current run. These flags are used to configure the solver's execution context, directly influencing its decision-making and diagnostic output during constraint resolution.",
      "description_length": 384,
      "index": 1856,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ConstrSys.GlobSolverFromEqSolver",
      "library": "goblint.constraint",
      "description": "This module integrates local and global constraint solving by transforming incremental equation solvers into global constraint solvers, operating on variable types from `S` and using marshaled state to manage transitions. It provides key data structures like `VH.t` hash tables for variable tracking, tagged tuples for solution decomposition, and marshaled solver states for incremental updates. You can perform operations such as transactional hash table updates, splitting constraint solutions into variable and domain components, and computing local solutions from initial variable values. The module supports advanced use cases like iterative constraint resolution with structured types, lifted lattice operations, and precise static analysis through variable identity tracking and domain transformations.",
      "description_length": 809,
      "index": 1857,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ConstrSys.SysVar",
      "library": "goblint.constraint",
      "description": "Handles variable state transitions and constraint propagation in a logic solver. Operates on variables with read/write status, tracking dependencies and enforcing consistency during assignments. Used to implement backtracking algorithms with constraint checking for logic puzzles or type inference systems.",
      "description_length": 306,
      "index": 1858,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "ConstrSys.EqConstrSys-Dom",
      "library": "goblint.constraint",
      "description": "This module provides lattice-based operations for abstract domains, including comparison (`leq`, `compare`), combination (`join`, `meet`), approximation (`widen`, `narrow`), and extremal element detection (`is_bot`, `is_top`). It operates on values of type `Dom.t`, which represent elements within a lattice structure designed for abstract interpretation tasks. These capabilities enable static analysis of program properties by modeling possible program states and solving constraints through lattice-theoretic semantics.",
      "description_length": 522,
      "index": 1859,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ConstrSys.Var2",
      "library": "goblint.constraint",
      "description": "This module combines two variable types, `LV` and `GV`, into a single type `t` to support mixed-variable constraint systems. It provides equality, hashing, comparison, and pretty-printing operations, along with utilities to extract variable identifiers, associated CFG nodes, and XML serialization. It is used in constraint systems that require handling both local and global variables, such as dataflow analysis engines that track variable relationships across function boundaries.",
      "description_length": 482,
      "index": 1860,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ConstrSys.VarType",
      "library": "goblint.constraint",
      "description": "This module defines operations for managing and comparing variable types within a constraint system, including equality, hashing, and comparison functions. It works with a concrete type `t` representing variables, supporting operations like checking if a variable is write-only, generating XML output, and producing human-readable traces. Use cases include tracking variable identities and properties during static analysis, particularly in contexts like dataflow analysis or constraint solving where variable relationships must be precisely captured.",
      "description_length": 551,
      "index": 1861,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ConstrSys.CurrentVarEqConstrSys",
      "library": "goblint.constraint",
      "description": "This module extends a constraint system with tracking of the variable currently being evaluated, using a mutable reference to store the active variable context. It provides direct access to the `current_var` reference while integrating constraint operations that manage variable dependencies and incremental updates during solving. The `sys_change` function computes adjustments based on a variable's current solution, and `system` retrieves the constraint function for a given variable. Example usage includes propagating changes through variable dependencies when solving iterative constraint systems.",
      "description_length": 603,
      "index": 1862,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "ConstrSys.MonSystem-Dom",
      "library": "goblint.constraint",
      "description": "This module supports lattice operations including equality checks, ordering, join/meet/widen/narrow for element combination, and top element manipulation, alongside conversions to string/XML/JSON formats. It operates on elements of type `Dom.t` structured as a lattice, enabling precise approximation and transformation of values. These capabilities are particularly useful in static analysis frameworks for abstract interpretation, where lattice-based reasoning is critical for solving constraint systems or modeling program behavior.",
      "description_length": 535,
      "index": 1863,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "ConstrSys.GlobConstrSys-GVar",
      "library": "goblint.constraint",
      "description": "This module represents a constraint system for global variables, providing operations to compare, hash, and identify variables based on their structure or address. It supports tracking variable properties such as whether a variable is write-only and allows pretty-printing and XML serialization of variable information. It is used in static analysis to manage and reason about global variables across different program points.",
      "description_length": 426,
      "index": 1864,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ConstrSys.GlobConstrSolFromEqConstrSol",
      "library": "goblint.constraint",
      "description": "This module transforms solutions from an equality constraint system into structured local and global constraint solutions, using tagged values to separate and refine variable bindings and domain values. It provides the `split_solution` function that produces a pair of solutions handled by its submodules, which manage hash table-based key-value mappings and coordinate variable-domain transformations. The first submodule enables safe, result-typed manipulation of variable-to-solution mappings, supporting conversions and iterative processing of constraint components, while the second handles domain lattice operations and variable identity tracking for incremental solution updates. Example usage includes splitting unified variable assignments into distinct local and global parts, refining domains through join and meet operations, and evolving constraint solutions during dynamic analysis phases.",
      "description_length": 903,
      "index": 1865,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ConstrSys.MonSystem",
      "library": "goblint.constraint",
      "description": "Implements a mutable constraint system with variables and domains. Provides functions to define and update constraints based on variable assignments. Useful for solving constraint satisfaction problems where variables have interdependent relationships and require incremental updates.",
      "description_length": 284,
      "index": 1866,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ConstrSys.GlobConstrSolFromEqConstrSolBase",
      "library": "goblint.constraint",
      "description": "Implements a solution-splitting operation that transforms a combined constraint solution map into separate local and global constraint maps. It processes a hashtbl-based solution structure with tagged values, producing distinct tables for local constraints and global constraints. This is used when decomposing solutions to equation systems into their globally and locally constrained components.",
      "description_length": 396,
      "index": 1867,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ConstrSys.GlobConstrSys-LVar",
      "library": "goblint.constraint",
      "description": "This module manages a system of logical variables (LVar) within a constraint system, providing operations for equality checking, hashing, comparison, and pretty-printing. It supports data structures involving LVar keys, ensuring consistent hashing and comparison behavior for use in maps and sets. Concrete use cases include tracking variable identities, comparing constraint variables during solving, and generating XML representations for debugging or serialization.",
      "description_length": 468,
      "index": 1868,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ConstrSys.GenericGlobSolver",
      "library": "goblint.constraint",
      "description": "Translates constraint systems into solutions using hash-tables, returning both variable assignments and incremental serialization data. Operates on local and global variables with associated domains and constraints. Solves constraint problems by processing initial variable-value pairs and tracked variables, producing resolved states and marshaling structures for persistence.",
      "description_length": 377,
      "index": 1869,
      "embedding_norm": 1.0
    },
    {
      "module_path": "VarQuery",
      "library": "goblint.constraint",
      "description": "This module represents constraint variables related to global variables or nodes in a CIL file. It provides a way to construct and compare these variables, as well as resolve them from global names in a CIL file. It is used to track and query semantic elements like global variables and function nodes during analysis.",
      "description_length": 318,
      "index": 1870,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ConstrSys",
      "library": "goblint.constraint",
      "description": "This module implements a constraint system with support for equality constraints, variable management, and incremental solving. It defines core operations for creating, modifying, and solving constraint systems, with data types representing variables, domains, and constraint equations. Variables support hashing, comparison, and pretty-printing, while domains provide lattice operations such as join, meet, widen, and narrow for abstract interpretation. The system enables tracking of local and global variables, supports mutable updates, and integrates solver flags to control behavior during constraint resolution. Submodules handle lattice semantics, variable identity, solution splitting, and incremental updates, enabling tasks like static analysis, type inference, and configuration resolution. Specific capabilities include translating constraint systems into hash-table solutions, merging local and global constraints, and serializing solver state for persistence. Example workflows involve solving dataflow equations, refining variable domains through constraint propagation, and managing dependencies in build systems or logic solvers.",
      "description_length": 1146,
      "index": 1871,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_logs.Logs.MakeKind",
      "library": "goblint.logs",
      "description": "This module provides logging functions at different severity levels (debug, info, warn, error) that accept formatted messages using the `Stdlib.format4` type. It works with the `Level.t` type to control log output and supports formatted string logging with type-safe placeholders. A concrete use case is selectively logging events during static analysis to track internal state changes or emit warnings without affecting result presentation.",
      "description_length": 441,
      "index": 1872,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Goblint_logs.Logs.Result",
      "library": "goblint.logs",
      "description": "Handles logging operations with support for result types, enabling error tracking and message accumulation. Works with `result` values and logging channels to capture success or failure states during analysis phases. Useful for reporting intermediate computation outcomes and diagnostic information without relying on standard output.",
      "description_length": 334,
      "index": 1873,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_logs.Logs.Level",
      "library": "goblint.logs",
      "description": "This module defines a set of severity levels for logging\u2014Debug, Info, Warning, Error, and Result\u2014and provides operations to compare, convert, and manipulate these levels. It includes functions to hash, print, and serialize levels, as well as utilities to check if a level should be logged based on the current setting. Use cases include filtering log output and representing log message importance in analysis tools.",
      "description_length": 416,
      "index": 1874,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_logs.Logs.Pretty",
      "library": "goblint.logs",
      "description": "This module provides functions for formatted logging and output generation, supporting different log levels such as debug, info, warn, error, and result. It works with formatting strings and produces output using data types like `unit`, `string`, and `Pretty.doc` for structured document rendering. Concrete use cases include emitting structured log messages during static analysis and generating human-readable output for analysis results.",
      "description_length": 440,
      "index": 1875,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_logs.Logs.Format",
      "library": "goblint.logs",
      "description": "This module handles formatted logging output with support for different log levels like debug, info, warn, and error. It works with format strings and values of arbitrary types, enabling structured message construction. Concrete use cases include emitting contextual log messages during static analysis and formatting diagnostic output with precise control over message structure and severity.",
      "description_length": 393,
      "index": 1876,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_logs.Logs.PrettyKind",
      "library": "goblint.logs",
      "description": "Handles pretty-printing of log messages using a document-based formatting system. Works with logging levels and format strings to produce structured, human-readable output. Useful for generating indented or aligned log content in a type-safe way.",
      "description_length": 246,
      "index": 1877,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_logs.Logs.Kind",
      "library": "goblint.logs",
      "description": "This module defines log message kinds with severity levels and formatting capabilities. It operates on log levels and formatted message strings, supporting conditional logging based on verbosity settings. Concrete use cases include emitting debug information and analysis progress during static analysis runs.",
      "description_length": 309,
      "index": 1878,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_logs.Logs.BatteriesKind",
      "library": "goblint.logs",
      "description": "This module implements logging operations for the `BatIO.output` type, supporting formatted output with a `log` function that writes messages at specified severity levels. It works with standard format strings and output streams, enabling structured logging to files or other output destinations. Concrete use cases include writing diagnostic messages during static analysis execution to an output stream.",
      "description_length": 405,
      "index": 1879,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_logs.Logs.Batteries",
      "library": "goblint.logs",
      "description": "This module provides logging functions at various severity levels\u2014debug, info, warn, error\u2014along with a newline utility and result formatting. It works with format strings and unit values, supporting structured logging output. Concrete use cases include emitting diagnostic messages during static analysis and formatting final results for clarity.",
      "description_length": 347,
      "index": 1880,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_logs.Logs.FormatKind",
      "library": "goblint.logs",
      "description": "Handles logging with formatted output using OCaml's `Format.formatter`. Provides a `log` function that takes a log level and a format string, enabling type-safe formatted logging messages. Useful for emitting structured log entries during static analysis runs, such as debug traces or status updates.",
      "description_length": 300,
      "index": 1881,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_logs.AnsiColors",
      "library": "goblint.logs",
      "description": "This module defines a list of ANSI escape sequences for terminal colors and a reference flag to control whether colored output is enabled. It works with strings and boolean references to manage color codes and output configuration. Use this module to add colored logging to terminal messages or to toggle color support based on environment settings.",
      "description_length": 349,
      "index": 1882,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_logs.Logs",
      "library": "goblint.logs",
      "description": "This module enables logging of messages at different severity levels\u2014debug, info, warn, error, and result\u2014using format strings and type-safe placeholders to construct structured output. It supports output customization through pretty-printing, formatter integration, and configurable logging levels, allowing selective tracing of analysis steps and emission of diagnostic or result messages. Submodules extend this functionality by handling result-based logging, pretty-printed document formatting, and output to streams or custom destinations, enabling use cases such as accumulating error diagnostics, generating indented log output, and writing structured analysis results to files. Key data types include `Level.t` for severity control, `Format.formatter` for output rendering, and `Pretty.doc` for structured document generation.",
      "description_length": 834,
      "index": 1883,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_logs",
      "library": "goblint.logs",
      "description": "This module provides colored terminal output management and structured logging with customizable severity levels. It combines ANSI color codes and a toggle flag to control colored messages, while supporting type-safe formatted logging at debug, info, warn, error, and result levels. Operations include level-based message filtering, pretty-printed document rendering, and output redirection to streams or custom handlers. You can use it to generate colored diagnostic logs, format structured analysis results, or direct log output to files with indentation and rich text formatting.",
      "description_length": 582,
      "index": 1884,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CompareCIL.VarinfoSet",
      "library": "goblint.incremental",
      "description": "This module provides functional set operations for managing collections of CIL variable information (`Varinfo.t`), including union, intersection, membership checks, and transformations like filtering or partitioning. It supports ordered iteration and conversion to/from sequences, enabling integration with analysis workflows that require variable tracking, such as dataflow analysis or optimization passes in CIL-based compilers. The immutable set structure ensures efficient handling of variable sets during static analysis tasks.",
      "description_length": 532,
      "index": 1885,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CompareCIL.GlobalMap",
      "library": "goblint.incremental",
      "description": "This module implements an ordered associative map structure with keys based on a specific comparison logic and polymorphic values, supporting comprehensive operations for key-value manipulation. It enables ordered traversal (including reverse and range-based iteration), structural transformations (mapping, filtering, partitioning), and conversions to/from lists and sequences, with specialized handling for merging and keyed lookups. The design facilitates use cases like hierarchical data aggregation, ordered key-value reconciliation, and sequence-driven map construction in CIL file analysis workflows.",
      "description_length": 607,
      "index": 1886,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "CompareCFG.NH",
      "library": "goblint.incremental",
      "description": "This module offers imperative hash table operations for managing key-value pairs with `Node.t` keys and arbitrary value types, supporting insertion, replacement, iteration, and bulk initialization from sequences of bindings. It is designed for scenarios requiring efficient data structure manipulation during control flow graph analysis, such as tracking node relationships or aggregating statistics. The interface emphasizes mutation and traversal capabilities, making it suitable for tasks like dependency tracking or intermediate state management in graph comparison algorithms.",
      "description_length": 581,
      "index": 1887,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "CilMaps.VarinfoOrdered",
      "library": "goblint.incremental",
      "description": "Maps keys of type `GoblintCil.varinfo` using structural comparison. Provides standard map operations like `find`, `add`, and `iter` for working with variable information in CIL-based analyses. Useful for tracking variable properties during static analysis passes.",
      "description_length": 263,
      "index": 1888,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CompareCIL.GlobalColMap",
      "library": "goblint.incremental",
      "description": "This module implements a map structure for associating polymorphic values with `CompareCIL.global_col` keys, supporting insertion, deletion, traversal, and combinatorial operations like merging and filtering. It provides sequence-based bulk updates, conversions to and from lists, and idiomatic key-value pair handling via `Stdlib.Seq`. Designed for scenarios requiring structured association management, such as tracking column mappings during CIL file comparisons or aggregating per-column metadata efficiently.",
      "description_length": 513,
      "index": 1889,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CilMaps.FundecForMap",
      "library": "goblint.incremental",
      "description": "Maps functions over CIL function declarations (`fundec`) using a comparison function for key ordering. It supports operations like `map`, `iter`, and `fold` on collections of function declarations. Useful for analyzing or transforming C functions during static analysis passes.",
      "description_length": 277,
      "index": 1890,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "CompareAST.StringMap",
      "library": "goblint.incremental",
      "description": "This module offers insertion, deletion, lookup, and combination operations for maps with string keys and arbitrary value types, alongside transformations via mapping, folding, and filtering. It supports conversions between maps and sequences or lists, enabling efficient iteration and reconstruction. Such functionality is useful for managing hierarchical data, symbol tables, or analysis tasks requiring keyed associations in AST comparisons.",
      "description_length": 443,
      "index": 1891,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Serialize.Cache",
      "library": "goblint.incremental",
      "description": "This module caches intermediate analysis data in memory before disk storage, supporting operations to update, retrieve, and reset solver, analysis, version, and CIL file data. It works with optional and polymorphic data queries to manage mutable fields of type `Obj.t`, `MaxIdUtil.max_ids`, and `GoblintCil.file`. Concrete use cases include managing state during incremental analysis runs and maintaining cached data for server mode operations.",
      "description_length": 444,
      "index": 1892,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CilMaps.VarinfoMap",
      "library": "goblint.incremental",
      "description": "This module provides a map implementation for associating values with CIL variable identifiers, supporting key operations like insertion, deletion, merging, and conditional queries. It facilitates functional transformations through mapping, filtering, and folding, while enabling safe access via optional lookups and ordered iteration. Designed for analyses requiring efficient variable binding management, such as dataflow analysis or optimization passes, it bridges structured key-value relationships with sequence-based processing for CIL's intermediate representation.",
      "description_length": 572,
      "index": 1893,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "CilMaps.FundecMap",
      "library": "goblint.incremental",
      "description": "This module provides associative operations for mapping function declarations to arbitrary data, supporting ordered traversal, bulk sequence updates, and specialized transformations like filtered aggregation or key-based merging. It works with keys derived from Cil's function declaration representations and values of polymorphic type, enabling use cases like static analysis of code structures or incremental updates during compilation. Key features include ordered iteration, set-theoretic comparisons, and efficient conversion between maps and sequences for staged processing.",
      "description_length": 580,
      "index": 1894,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CompareAST",
      "library": "goblint.incremental",
      "description": "This module enables structural comparison of CIL AST components\u2014such as variables, types, expressions, and statements\u2014by recursively checking equality while tracking identifier renamings and type equivalences through context-aware mappings. It directly operates on AST nodes like `varinfo`, `compinfo`, and `enuminfo`, supporting tasks like code refactoring validation and semantic equivalence detection. A child module provides map operations for managing keyed associations, facilitating efficient symbol table handling and hierarchical data transformations during AST comparisons. Together, these components allow precise analysis and manipulation of AST structures across different representations.",
      "description_length": 702,
      "index": 1895,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "CilMaps",
      "library": "goblint.incremental",
      "description": "This module implements specialized associative structures for mapping variable and function declarations in CIL's intermediate representation, using structural or custom key comparisons. It supports efficient insertion, lookup, iteration, and transformation operations over keys like `varinfo` and `fundec`, enabling precise tracking and analysis of variable properties or function-level data during static analysis. Examples include aggregating variable bindings, transforming function declarations, or performing incremental updates with ordered traversal and safe access patterns.",
      "description_length": 583,
      "index": 1896,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CompareCFG",
      "library": "goblint.incremental",
      "description": "This module compares control flow graphs and CIL structures for structural equivalence under variable renaming, using a `rename_mapping` to track renaming relationships during comparisons of nodes, edges, blocks, expressions, and function declarations. It includes a child module for imperative hash tables keyed by CFG nodes, enabling efficient storage and manipulation of node-associated data during graph analysis. The combined interface supports tasks like verifying program equivalence after renaming or analyzing CFG transformations while preserving semantics. Example uses include checking \u03b1-equivalence of functions and tracking node mappings during iterative graph comparison.",
      "description_length": 685,
      "index": 1897,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MaxIdUtil",
      "library": "goblint.incremental",
      "description": "This module tracks and updates the maximum statement and variable IDs (sids and vids) used in CIL files. It provides functions to update ID counters based on CIL global declarations and to retrieve the maximum IDs from a CIL file. It is used during CIL processing to ensure unique ID assignment when merging or transforming CIL structures.",
      "description_length": 339,
      "index": 1898,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MakefileUtil",
      "library": "goblint.incremental",
      "description": "This module handles file manipulation and command execution for build processes. It provides functions to locate files by suffix, execute shell commands with optional paths, remove specific files, and integrate with tools like Cilly for preprocessing and combining source files. Concrete use cases include automating build steps, managing temporary files, and invoking external compilers or linters.",
      "description_length": 399,
      "index": 1899,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Serialize",
      "library": "goblint.incremental",
      "description": "This module provides serialization and deserialization of incremental analysis data, handling arbitrary OCaml values and file paths with `Fpath.t`, and determines directory locations based on save or load mode. It supports persisting analysis results between runs and retrieving saved intermediate data for incremental processing, while its child module caches intermediate data in memory, allowing updates, queries, and resets for solver, analysis, version, and CIL file data. Operations include managing mutable fields like `Obj.t`, `MaxIdUtil.max_ids`, and `GoblintCil.file`, with support for optional and polymorphic data queries. Use cases include maintaining state during analysis runs and serving cached data in server mode.",
      "description_length": 731,
      "index": 1900,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CompareCIL",
      "library": "goblint.incremental",
      "description": "The module enables structural equivalence checks across CIL AST components and control flow graphs, using variable renaming mappings to accurately compare entities that may have been locally or globally renamed. It directly supports operations on `fundec`, `varinfo`, and edge lists, while its submodules provide set operations for variable tracking, ordered associative maps for key-value reconciliation, and specialized maps for handling `global_col` keys. These tools allow precise detection of renamed variables, CFG differences, and global definition changes, integrating with analysis workflows through immutable sets, ordered maps, and sequence-driven operations. Use cases include comparing function bodies for structural equivalence, tracking variable usage across code versions, and aggregating metadata during CIL file reconciliation.",
      "description_length": 845,
      "index": 1901,
      "embedding_norm": 1.0
    },
    {
      "module_path": "UpdateCil",
      "library": "goblint.incremental",
      "description": "This module combines CIL files based on comparison results, updating identifiers and locations to avoid dependency cycles. It maps nodes to source code locations and updates CIL structures with new IDs and location information. Used during incremental analysis to merge changed CIL files while preserving node identity and source position tracking.",
      "description_length": 348,
      "index": 1902,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_std.GobQCheck.Gen",
      "library": "goblint.std",
      "description": "Provides functions for composing and manipulating QCheck generators. Works with QCheck's `Gen` type to create complex test data generators from simpler ones. Enables generation of structured test cases like lists of arbitrary values where each element is produced by a specified generator.",
      "description_length": 289,
      "index": 1903,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_std.GobList.Syntax",
      "library": "goblint.std",
      "description": "This module provides applicative and monadic operations for working with lists, enabling concise list transformations and combinations. It defines operators like `let+`, `and+`, `let*`, `and*`, and `>>=` to apply functions within the list context, pair elements across lists, and sequence list computations. Concrete use cases include generating combinations of values, filtering and mapping in a single step, and writing list-based computations in a more readable, monadic style.",
      "description_length": 480,
      "index": 1904,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Goblint_std.GobOption.Syntax",
      "library": "goblint.std",
      "description": "This module provides applicative and monadic operators for the `option` type, enabling concise composition of computations that may fail. It includes operators like `let+`, `and+`, `let*`, `and*`, and `>>=` to chain and combine optional values. Use it to safely sequence operations on `option` values, such as parsing or lookup steps where any failure short-circuits the computation.",
      "description_length": 383,
      "index": 1905,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_std.GobQCheck.Arbitrary",
      "library": "goblint.std",
      "description": "This module defines arbitrary value generators for use with QCheck, including 64-bit integers, arbitrary-precision integers, and sequences of arbitrary values. It enables property-based testing by producing random instances of these types for test cases. These generators are useful for testing functions that handle numeric operations or process sequences of values with specific structural constraints.",
      "description_length": 404,
      "index": 1906,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_std.GobResult.Syntax",
      "library": "goblint.std",
      "description": "This module provides applicative and monadic operators for working with `result` values, enabling concise composition of computations that may fail. It includes functions like `let+`, `and+`, `let*`, `and*`, and `>>=` to map, combine, and chain results sequentially. Concrete use cases include parsing, validation pipelines, and error-propagating computations where intermediate results determine subsequent steps.",
      "description_length": 414,
      "index": 1907,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_std.GobQCheck.Iter",
      "library": "goblint.std",
      "description": "This module creates finite iterators from QCheck generators or arbitrary values, producing a fixed number of test values. It works with QCheck's `Gen.t` and `arbitrary` types, yielding `Iter.t` sequences. Use it to generate concrete test cases for property-based testing, such as validating parser outputs or checking function behavior across a range of inputs.",
      "description_length": 361,
      "index": 1908,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_std.GobQCheck.Shrink",
      "library": "goblint.std",
      "description": "Performs shrinking on lists of values by applying a list of shrinkers to an input list, producing an iterator of shrunk results. Works with lists and QCheck shrinkers. Useful for property-based testing when reducing complex list inputs to simpler forms.",
      "description_length": 253,
      "index": 1909,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_std.GobSys",
      "library": "goblint.std",
      "description": "This module provides system-level operations for directory manipulation, process signals, and time formatting. It works with file paths (`Fpath.t`) and system signals, offering functions like recursive directory removal, directory creation with parent paths, and signal handling. Concrete use cases include managing temporary directories, handling process termination signals, and logging timestamps.",
      "description_length": 400,
      "index": 1910,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_std.GobOption",
      "library": "goblint.std",
      "description": "This module enhances working with `option` values by providing direct operations like `exists`, `for_all`, and `map2` to check conditions and combine optional data without explicit unwrapping. Its child module adds applicative and monadic operators such as `let+`, `and+`, `let*`, and `>>=` for composing sequences of optional computations, where failures automatically terminate the chain. Together, they enable precise, safe manipulation of optional data, such as validating and combining the results of multiple lookups or parsing steps. Specific examples include using `map2` to apply a function to two optional values or `let*` to chain dependent parsing operations.",
      "description_length": 671,
      "index": 1911,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_std.GobResult",
      "library": "goblint.std",
      "description": "This module enhances working with `result` types by offering applicative and monadic combinators that streamline error handling and sequential computation. It introduces operators like `let+`, `and+`, `let*`, `and*`, and `>>=` to map, combine, and chain result values, enabling clean, readable pipelines for tasks like parsing or validation. These operations allow developers to express complex, error-prone workflows in a succinct and composable way. For example, you can use `let*` to chain parsing steps where each depends on the previous, or `and+` to validate multiple fields in parallel.",
      "description_length": 593,
      "index": 1912,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_std.GobRef",
      "library": "goblint.std",
      "description": "This module provides operations for temporarily modifying the contents of a reference during the execution of a function. It supports working with standard OCaml references (`'a ref`) and allows setting a reference to a specific value while executing a given function, then restoring its original value. This is useful for scenarios like temporarily overriding configuration values or state within a controlled scope.",
      "description_length": 417,
      "index": 1913,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_std.GobFpath",
      "library": "goblint.std",
      "description": "This module provides operations for manipulating file paths, including equality checks, comparison, and string conversion. It supports working with absolute and relative paths, enabling tasks like path concatenation, prefix removal, and current working directory resolution. Concrete use cases include normalizing paths during file system traversal or constructing output directories in build systems.",
      "description_length": 401,
      "index": 1914,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Goblint_std.GobUnix",
      "library": "goblint.std",
      "description": "This module extends OCaml's Unix module with additional operations for process status conversion and time handling. It provides `string_of_process_status` to convert process exit statuses into human-readable strings, and `localtime` to get the current local time as a formatted string. These functions are useful for logging and debugging purposes when dealing with process execution and time-sensitive operations.",
      "description_length": 414,
      "index": 1915,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_std.GobHashtbl",
      "library": "goblint.std",
      "description": "Implements hash tables with efficient insertion, lookup, and iteration over key-value pairs. Works with arbitrary key and value types, supporting customizable hash functions and equality comparisons. Useful for tracking analysis results per function or variable in static analysis passes.",
      "description_length": 288,
      "index": 1916,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_std.GobZ",
      "library": "goblint.std",
      "description": "This module provides operations for working with arbitrary-precision integers via the `Z.t` type. It includes functions for equality checking, comparison, hashing, JSON serialization, range validation, and pretty-printing. These are useful in contexts like formal verification, symbolic computation, or any domain requiring precise integer manipulation beyond machine-word limits.",
      "description_length": 380,
      "index": 1917,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_std.GobArray",
      "library": "goblint.std",
      "description": "This module extends array operations with indexed variants of common predicates. It provides functions to check existence, universal satisfaction, and count elements based on a predicate that considers both index and value. These functions are useful for precise array analysis and validation where position-dependent conditions must be efficiently evaluated.",
      "description_length": 359,
      "index": 1918,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_std.GobPretty",
      "library": "goblint.std",
      "description": "This module provides functions for converting structured document values into string representations, primarily working with `GoblintCil.Pretty.doc` and format strings. It supports operations like rendering documents directly, applying formatting functions, and handling generalized printf-style conversions. Concrete use cases include pretty-printing abstract syntax trees or structured data to strings for logging, debugging, or output generation.",
      "description_length": 449,
      "index": 1919,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_std.GobGc",
      "library": "goblint.std",
      "description": "Handles garbage collection statistics and memory management metrics. Provides `print_quick_stat` to output concise GC statistics to a given channel. Works with OCaml's `Gc.stat` type and standard output channels. Useful for monitoring memory usage in long-running applications or profiling performance-critical code.",
      "description_length": 316,
      "index": 1920,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_std.GobList",
      "library": "goblint.std",
      "description": "This module enhances list manipulation by combining standard list operations with applicative and monadic extensions. It supports safe zipping, conditional folding, and element association with custom equality, while its child module enables expressive list transformations using operators like `let+`, `and+`, `let*`, and `>>=`. You can merge parallel lists, accumulate state conditionally, generate value combinations, and sequence list computations in a readable style. Specific examples include splitting lists based on predicates, mapping and filtering in one pass, and pairing elements across multiple lists.",
      "description_length": 614,
      "index": 1921,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_std.GobQCheck",
      "library": "goblint.std",
      "description": "This module enhances property-based testing by extending QCheck with advanced generators, iterators, and shrinking strategies. It supports the creation of structured test data through combinators that build complex generators from simpler ones, such as generating lists where each element is produced by a specified generator. The module includes specific generators for 64-bit integers, arbitrary-precision integers, and sequences, enabling robust testing of numeric and sequence-processing functions. It also provides tools to generate finite test sets from these generators and to shrink complex list inputs into simpler forms for clearer failure diagnostics.",
      "description_length": 662,
      "index": 1922,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_std.GobYojson",
      "library": "goblint.std",
      "description": "This module provides functions to merge JSON values recursively, print JSON to an output stream, and convert JSON to a pretty-printed document. It operates on Yojson.Safe.t values, supporting both associative lists and nested lists. Use cases include configuration file updates, JSON serialization, and structured logging.",
      "description_length": 322,
      "index": 1923,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_std.GobYaml",
      "library": "goblint.std",
      "description": "This module enables type-safe traversal and transformation of YAML structures through operations like key/value extraction, object composition, and typed value conversion (e.g., string, bool, float). It works directly with `Yaml.value` trees and leverages combinators such as `let*`, `list_map`, and `option_map` to chain result-bearing operations for robust error handling. Typical applications include parsing configuration files, building YAML data pipelines, or validating structured data with precise type conversions and functional transformation sequences.",
      "description_length": 563,
      "index": 1924,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_std",
      "library": "goblint.std",
      "description": "This library extends OCaml with utilities for system operations, data structure manipulation, and structured data handling. It provides data types like `Fpath.t` for path manipulation, `Z.t` for arbitrary-precision integers, and enhanced support for `option`, `result`, lists, and hash tables with applicative and monadic combinators for clean, safe composition of operations. You can manage file paths, handle process signals, temporarily modify state, validate and combine optional or result values, perform property-based testing, and manipulate JSON and YAML structures with type-safe transformations. Examples include chaining dependent parsing steps with `let*`, normalizing file paths during traversal, generating test data for complex types, and merging or pretty-printing JSON configurations.",
      "description_length": 801,
      "index": 1925,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_tracing.Strs",
      "library": "goblint.tracing",
      "description": "This module provides set-like operations for managing collections of strings (union, intersection, difference, membership checks) and sequence transformations (iteration, mapping, filtering, folding) over ordered elements like characters or substrings. It centers around two core structures: a string set-like type for uniqueness-preserving manipulations and a sequence type for ordered data processing, with utilities to convert between strings, sequences, and lists. These features are particularly useful for tasks like parsing character streams, analyzing ordered string data, or building complex string transformations from iterative operations.",
      "description_length": 650,
      "index": 1926,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_tracing",
      "library": "goblint.tracing",
      "description": "This module implements a hierarchical tracing system that manages debug output through structured controls, source locations, and indentation-aware message formatting. It combines core tracing operations\u2014like conditional logging by category and scoped trace activation\u2014with string and sequence manipulation capabilities from its child modules to process and filter debug data efficiently. Users can trace specific analysis phases by defining keys, format complex data flows with pretty-printed documents, or dissect source code regions using precise location tracking. The integration of set-like string operations and ordered sequence transformations enables precise debug output filtering, trace customization based on dynamic conditions, and structured analysis of textual program elements.",
      "description_length": 793,
      "index": 1927,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_timing.S",
      "library": "goblint.timing",
      "description": "This module manages hierarchical timing sections with start, stop, and reset operations, supporting nested timing through enter and exit, and provides structured output via print. It works with timing trees and custom tracing arguments to capture detailed performance profiles. Concrete use cases include profiling specific code regions in Goblint analyses and generating structured timing reports for optimization insights.",
      "description_length": 424,
      "index": 1928,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_timing.Make",
      "library": "goblint.timing",
      "description": "This module creates a hierarchical timing system with start, stop, and reset controls for performance profiling. It supports entering and exiting nested timed sections, wrapping functions to measure execution time, and printing the timing tree structure. It works with string-labeled sections and structured timing data, suitable for profiling complex workflows or nested computations.",
      "description_length": 385,
      "index": 1929,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_timing.Name",
      "library": "goblint.timing",
      "description": "This module defines a named hierarchical timing structure used for profiling. It provides a `name` value that identifies the timing section in output and tracking tools. It is used to organize and label performance metrics in complex, nested profiling scenarios.",
      "description_length": 262,
      "index": 1930,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_timing",
      "library": "goblint.timing",
      "description": "This module enables hierarchical profiling through timed sections that can be nested, started, stopped, and reset, forming a tree structure for detailed performance tracking. It supports labeling sections with names, wrapping functions for timed execution, and printing structured timing reports in TEF format. Direct operations include manual control of timing nodes, while submodules enhance functionality with automatic wrapping and labeled metrics. Example uses include profiling Goblint analysis phases and exporting timing data for performance optimization.",
      "description_length": 563,
      "index": 1931,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lattice.HashCached.LazyHash",
      "library": "goblint.domain",
      "description": "Implements lazy hashing with caching for lattice elements. Wraps a lattice value with a lazy hash, computing and storing the hash only when needed via the `force` function. Useful for optimizing repeated hash computations in lattice-based analyses where values may be large or expensive to hash upfront.",
      "description_length": 303,
      "index": 1932,
      "embedding_norm": 1.0
    },
    {
      "module_path": "PartitionDomain.ExpPartitions.E",
      "library": "goblint.domain",
      "description": "This module provides lattice-based operations (join, meet, widen, narrow) and set-theoretic manipulations (union, intersection, filtering) on a polymorphic type that represents either a collection of partitioned expressions or an unbounded `Top` element. It operates on immutable, set-like structures containing elements from a domain-specific hierarchy of partitioned expressions, supporting functional transformations and queries. These capabilities are particularly useful in abstract interpretation frameworks where precise tracking and merging of partitioned expression states are required.",
      "description_length": 595,
      "index": 1933,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "PartitionDomain.ExpPartitions.B",
      "library": "goblint.domain",
      "description": "This module offers lattice-based set operations for managing partitions of expressions, combining standard lattice primitives (`join`, `meet`, `widen`) with functional set abstractions (`union`, `filter`, `fold`) over `CilType.Exp.t` elements. It works with immutable sets of expressions structured as a lattice, enabling precise representation of expression partitions in static analysis tasks like dataflow inference or program optimization. Key use cases include tracking disjoint expression groups under abstract interpretation or merging partitions via lattice combinations.",
      "description_length": 579,
      "index": 1934,
      "embedding_norm": 1.0
    },
    {
      "module_path": "PartitionDomain.SetSet.B",
      "library": "goblint.domain",
      "description": "This module supports lattice-based abstract interpretation and set-theoretic operations on collections of elements with type `Base.t` or `B.elt`, structured as sets adhering to lattice properties. It provides transformations like partitioning, mapping, and extremal element extraction alongside order-aware utilities for comparison, serialization, and random generation. Designed for scenarios requiring precise set manipulation in abstract domains, it enables tasks like static program analysis or symbolic reasoning over partitioned data.",
      "description_length": 540,
      "index": 1935,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "SetDomain.FiniteSet.E",
      "library": "goblint.domain",
      "description": "This module represents finite sets of a fixed, enumerated element type, providing operations to create, compare, and manipulate sets using standard set-theoretic functions. It supports concrete data types through a list-based enumeration of all possible elements, enabling precise set membership checks, union, intersection, and complement operations. Use cases include symbolic execution, constraint solving, and finite state modeling where exact set manipulation is required.",
      "description_length": 477,
      "index": 1936,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "TrieDomain.Make.Trie",
      "library": "goblint.domain",
      "description": "This module implements lattice operations over trie structures, supporting equality checks, ordering relations, and domain transformations through join/meet combinators with witness tracking for change detection. It operates on trie nodes containing typed values and hierarchical child maps, enabling precise analysis of nested data with diagnostic diff visualization. Key applications include static analysis of hierarchical data and symbolic computation where structured value lattices with traceable state transitions are required.",
      "description_length": 534,
      "index": 1937,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "MapDomain.PrintGroupable.GroupMap",
      "library": "goblint.domain",
      "description": "This module provides operations for manipulating ordered maps with keys of type `Group.t` and polymorphic values, supporting insertion, deletion, ordered traversal, merging, and transformations via functions like `map` and `fold`. It facilitates sequence-based data conversion, filtering, and key-grouped aggregation, making it suitable for structured data processing tasks that require ordered traversal, grouped output generation, or merging hierarchical data.",
      "description_length": 462,
      "index": 1938,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lattice.HConsed.HC",
      "library": "goblint.domain",
      "description": "Implements hash-consing for lattice elements using a customizable hash table. It ensures canonical representation of keys by interning values through the `hashcons` function, which returns a unique representative for equivalent inputs. Useful for efficient equality checks and memory optimization in lattice-based analyses where key deduplication is critical.",
      "description_length": 359,
      "index": 1939,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "HoareDomain.HoarePO.B",
      "library": "goblint.domain",
      "description": "Implements list-based combination operations for abstract domains with Hoare ordering. It provides `join`, `widen`, `meet`, and `merge_element` to combine elements of lists or maps according to domain-specific merge strategies. Useful for merging abstract states in static analysis where each list entry represents a state or constraint.",
      "description_length": 337,
      "index": 1940,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "TrieDomain.Make.ChildMap",
      "library": "goblint.domain",
      "description": "This module implements an associative map structure binding keys to trie nodes, supporting both standard operations like insertion, iteration, and transformation, as well as lattice-based abstractions such as `join`, `meet`, and widening. It operates on hierarchical mappings where values are trie substructures, enabling domain-specific analysis through precision-controlled merging and comparison strategies. Key use cases include abstract interpretation of hierarchical data, structural equivalence checks, and combining partial maps with customizable merge semantics.",
      "description_length": 571,
      "index": 1941,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MapDomain.PrintGroupable.Group",
      "library": "goblint.domain",
      "description": "This module defines a grouping mechanism for map domains, where keys are organized into named groups. It supports comparing and categorizing groups, primarily working with the `Group.t` type that represents distinct key groups. Concrete use cases include structuring output by key categories and enabling grouped display or processing of map entries.",
      "description_length": 350,
      "index": 1942,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "SetDomain.SensitiveConf.Elt",
      "library": "goblint.domain",
      "description": "This module defines operations for handling pairs of base and user elements, including equality, comparison, hashing, and string representation. It supports structured data pairing with `type t = Base.t * User.t` and provides functions like `equal`, `compare`, `show`, and `pretty` for element manipulation and display. Concrete use cases include managing combined analysis states in path-sensitive dataflow analyses.",
      "description_length": 417,
      "index": 1943,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lattice.UnitConf",
      "library": "goblint.domain",
      "description": "This module provides a lattice structure for the unit type, implementing standard operations like `leq`, `join`, `meet`, and `widen` that all collapse to trivial computations due to the singleton nature of `unit`. It includes utility functions for comparison, serialization, and pretty-printing, alongside abstract interpretation primitives such as `bot`, `is_bot`, and `pretty_diff`. The implementation serves as a degenerate lattice instance, useful in scenarios requiring placeholder or base-case lattices where no meaningful state variation exists.",
      "description_length": 552,
      "index": 1944,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "PartitionDomain.Make",
      "library": "goblint.domain",
      "description": "This module provides set and partition operations with a focus on lattice-based manipulations, including joins, meets, and closure computations. It works with sets (implemented via balanced trees) and partition structures, supporting abstract interpretation tasks like equivalence class identification and inclusion checks. Use cases include program analysis frameworks requiring precise set semantics and testing environments needing serialization and arbitrary instance generation.",
      "description_length": 483,
      "index": 1945,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lattice.NoBotTop",
      "library": "goblint.domain",
      "description": "Implements lattice operations for types without distinguished bottom or top elements. Provides `top`, `is_top`, `bot`, and `is_bot` functions that allow clients to define and check extremal values explicitly. Useful for custom lattice structures where bounds are not predefined, such as interval or abstract domains in static analysis.",
      "description_length": 335,
      "index": 1946,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "BoolDomain.StdNames",
      "library": "goblint.domain",
      "description": "Implements standard naming conventions for boolean domains, defining string representations for true and false values. Uses the `name`, `true_name`, and `false_name` values to customize output formatting. Useful for generating user-facing labels or serializing boolean states in a configurable way.",
      "description_length": 298,
      "index": 1947,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lattice.Prod",
      "library": "goblint.domain",
      "description": "This module combines lattice operations with product types, supporting meet, join, and comparison operations over pairs of elements from two distinct base lattices. It provides utilities for projecting components, serializing values to formats like XML/JSON, and comparing composite lattice structures. Typical use cases involve analyzing program properties that require tracking independent yet combined abstractions, such as value ranges paired with permission states.",
      "description_length": 470,
      "index": 1948,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "MapDomain.MapBot_LiftTop",
      "library": "goblint.domain",
      "description": "This module combines map manipulation with lattice-based abstractions, offering standard associative operations like `add`, `remove`, and `map`, alongside lattice combinators such as `join`, `meet`, and `widen` for abstract interpretation. It operates on finite maps parameterized by key and value types, supporting bulk updates, structural queries, and serialization. Key use cases include program analysis tasks requiring both key-value transformations and lattice-theoretic reasoning, such as merging abstract domains or tracking hierarchical state properties.",
      "description_length": 563,
      "index": 1949,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lattice.Reverse",
      "library": "goblint.domain",
      "description": "This module provides lattice operations that invert the structure of a base lattice, including join/meet duality, widened/narrowed sequences, and reversed ordering predicates. It operates on base lattice elements (`Base.t`) and their structured representations (`t`), supporting use cases like reverse program analysis, abstract interpretation with inverted hierarchies, and testing through arbitrary value generation. Key utilities include XML serialization, difference visualization, and comparison operators for analyzing lattice elements in their inverted configuration.",
      "description_length": 574,
      "index": 1950,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "DisjointDomain.PairwiseMap",
      "library": "goblint.domain",
      "description": "This module supports standard map operations (insertion, removal, iteration, filtering) and lattice operations (join, meet, widening) over a structure where keys are partitioned into buckets via a congruence relation, with each bucket represented as a sub-map. It works with keys of type `E.t`, values of type `R.t`, and bucketing logic defined by `C`, organizing data into a hierarchy of maps (`B`) that follow lattice semantics, including handling bottom values. It is particularly useful in abstract interpretation scenarios requiring disjoint domain management, such as path-sensitive analysis or tracking memory addresses with partitioned state representations.",
      "description_length": 666,
      "index": 1951,
      "embedding_norm": 1.0
    },
    {
      "module_path": "DisjointDomain.ProjectiveSetPairwiseMeet",
      "library": "goblint.domain",
      "description": "This module provides lattice and set operations for abstract domains where elements are partitioned into disjoint buckets, supporting pairwise combinations of values within a structured hierarchy. It works with sets of elements (`elt`/`E.t`) organized into a lattice (`t`), enabling operations like join/meet for domain refinement and set algebra (union, intersection, difference) with bucket-aware semantics. It is particularly useful in static analysis for tracking path-sensitive or address-based data, where maintaining separation between distinct value categories is critical.",
      "description_length": 581,
      "index": 1952,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "SetDomain.LiftTop",
      "library": "goblint.domain",
      "description": "This module provides a lattice structure for sets augmented with top and bottom elements, enabling precise abstract interpretation in static analysis. It supports standard set operations like membership, union, and intersection, along with lattice-specific operations such as join, meet, widen, and narrow over a type that represents either a concrete set, a universal set (top), or an undefined state (bottom). Designed for domains requiring approximation, it is particularly useful in static analysis frameworks where tracking potential over-approximations (top) or failures (bottom) is critical.",
      "description_length": 598,
      "index": 1953,
      "embedding_norm": 1.0
    },
    {
      "module_path": "SetDomain.HeadlessSet",
      "library": "goblint.domain",
      "description": "This module implements a domain for sets with standard operations like creation, membership testing, and algebraic manipulations (union, intersection, difference), alongside lattice operations (join, meet, widen, narrow) and serialization utilities. It operates on sets of elements from a base domain (`Base.t`), structured using a `BatSet.Make`-derived implementation, supporting transformations like mapping, filtering, and folding. These capabilities are particularly useful in abstract interpretation or data flow analysis, where hierarchical",
      "description_length": 546,
      "index": 1954,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "MapDomain.HashCached",
      "library": "goblint.domain",
      "description": "This module offers map manipulation capabilities centered on three axes: bulk update operations and higher-order transformations over hash-consed finite maps with typed keys and values, lattice-based approximation for domain analysis, and serialization/conversion utilities for external representations. It supports use cases requiring precise map manipulation (e.g., batch insertion, predicate filtering), abstract interpretation (via join/meet operations), and data interchange (XML/Yojson encoding). The hash-consed map structure ensures efficient equality checks and memory usage while enabling arbitrary instance generation for testing.",
      "description_length": 641,
      "index": 1955,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "HoareDomain.Set_LiftTop",
      "library": "goblint.domain",
      "description": "This module provides lattice operations and set algebra enhanced with Hoare-style approximations for domains lifted with distinguished bottom and top elements. It operates on sets of values from a base domain `B.t`, supporting precise union, intersection, difference, and subset checks alongside widening/narrowing for iterative analysis. Designed for static program analysis, it enables tracking hierarchical relationships and verifying safety properties by combining abstract interpretation with structured set transformations.",
      "description_length": 529,
      "index": 1956,
      "embedding_norm": 1.0
    },
    {
      "module_path": "DisjointDomain.ProjectiveSet",
      "library": "goblint.domain",
      "description": "This domain organizes elements of type `E.t` into buckets determined by a relation `R`, with each bucket represented using a lattice-structured domain `B`. It supports lattice operations (join, meet, widening) and set-like manipulations (union, intersection, filtering) while managing bottom values at the bucket level. Designed for static analysis, it enables precise path-sensitive reasoning and memory address tracking by partitioning elements via `R`-induced congruences.",
      "description_length": 475,
      "index": 1957,
      "embedding_norm": 1.0
    },
    {
      "module_path": "DisjointDomain.RepresentativeCongruence",
      "library": "goblint.domain",
      "description": "This module defines equivalence classes of elements using a congruence relation, where each class has a unique representative. It supports operations like equality checking, hashing, comparison, and serialization, all based on the representative of the congruence class. Concrete use cases include managing path-sensitive values or symbolic addresses where equivalent elements must share a common identifier for analysis precision.",
      "description_length": 431,
      "index": 1958,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lattice.Unit",
      "library": "goblint.domain",
      "description": "This module specializes in lattice operations over the unit type, offering comparisons (`leq`), joins, meets, widening/narrowing, and extremal elements (`top`, `bot`). It includes utilities for checking bottom elements (`is_bot`) and visualizing state differences (`pretty_diff`), alongside serialization and testing support. The trivial unit type lattice, with only one value, serves scenarios requiring minimal or default lattice representations, such as foundational components in abstract interpretation or testing frameworks.",
      "description_length": 530,
      "index": 1959,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "SetDomain.Joined",
      "library": "goblint.domain",
      "description": "This module implements a lattice-based abstraction for sets where all elements are represented through a single joined value, supporting standard set operations (union, intersection, difference) and element-wise queries (membership, addition, removal) over a type `t` that encapsulates abstract sets with elements of type `elt`. The representation leverages HConsed values for efficient equality checks and memory sharing, with lattice operations (join, meet, widen) enabling analysis of possible element combinations in scenarios like static analysis or symbolic execution. It is particularly suited for contexts requiring compact set approximations, such as tracking potential values in program analysis where precise element distinctions are relaxed in favor of performance.",
      "description_length": 777,
      "index": 1960,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "PartitionDomain.Collapse",
      "library": "goblint.domain",
      "description": "Implements domain collapse operations for partitioning, determining whether one partition can be collapsed into another. Works with the abstract type `t` representing partitioned domains, using equality, comparison, and hashing to manage identity and ordering. Useful for merging overlapping or redundant partitions during static analysis to reduce complexity.",
      "description_length": 360,
      "index": 1961,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "DisjointDomain.PairwiseSet",
      "library": "goblint.domain",
      "description": "This module provides lattice and set operations\u2014such as union, intersection, difference, and bucket-aware joins/meets\u2014on collections of elements partitioned into disjoint buckets via a congruence or projection. It works with elements of type `E.t` grouped into buckets by `C`, where each bucket is represented as a set structure from `B` (e.g., joined sets or Hoare-style sets). It is particularly useful for path-sensitive program analysis or tracking address sets, where operations must respect bucket boundaries to maintain domain-specific invariants.",
      "description_length": 554,
      "index": 1962,
      "embedding_norm": 1.0
    },
    {
      "module_path": "BoolDomain.FlatBool",
      "library": "goblint.domain",
      "description": "This module implements a three-element lattice structure for boolean abstraction, supporting operations like partial ordering, joins, meets, and approximation refinement. It manipulates values of an abstract type encapsulating boolean states with dedicated bottom and top elements, enabling precise representation of unknown or universally true conditions. The design facilitates static analysis tasks such as symbolic computation and abstract interpretation where boolean values require domain-specific approximation.",
      "description_length": 518,
      "index": 1963,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "SetDomain.ToppedSet",
      "library": "goblint.domain",
      "description": "This module implements a lattice structure with operations like `join`, `meet`, `widen`, and `narrow`, alongside standard set functionalities such as union, intersection, and membership checks. It operates on a sum type combining a distinguished `Top` element with a set domain derived from a base type, enabling representation of either all possible values (via `Top`) or precise subsets. It is particularly useful in abstract interpretation for static analysis, where approximations of value sets (e.g., tracking possible program variable states) balance precision and efficiency.",
      "description_length": 582,
      "index": 1964,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MapDomain.MapBot",
      "library": "goblint.domain",
      "description": "This module implements finite maps with domain-specific keys and range values, supporting functional transformations, structural queries (e.g., cardinality checks, element extraction), and lattice operations like join/meet with widening/narrowing. It enables merging maps, bulk insertions, and safe key lookups while providing serialization to formats like XML or JSON. These capabilities are tailored for symbolic reasoning tasks requiring ordered map compositions and domain-specific extremal value analysis, such as program analysis or abstract interpretation.",
      "description_length": 563,
      "index": 1965,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MapDomain.PMap",
      "library": "goblint.domain",
      "description": "This module implements polymorphic maps with `Domain.t` keys and `Range.t` values, supporting operations to add, remove, and find entries, as well as merge, filter, fold, and iterate over key-value pairs. It provides utilities for comparison, hashing, serialization, and generating arbitrary values, along with a unique tagging mechanism. These features make it suitable for managing associative data structures requiring complex transformations, combining maps with custom logic, or enabling testing and persistent storage scenarios.",
      "description_length": 534,
      "index": 1966,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "DisjointDomain.ProjectiveMap",
      "library": "goblint.domain",
      "description": "This module provides map-like operations for bucketed key-value data where keys (`E.t`) are partitioned into buckets via a relation `R`, with each bucket\u2019s values stored in a map structure `B` mapping to `V.t`. It supports lattice operations (join, meet, widen) over these bucketed values, incorporating `Lattice.BotValue` to handle domain-specific bottom elements and custom combination logic for solvers. Typical applications include path-sensitive analysis and address set management, where bucket-closure constraints ensure operations respect domain-specific partitioning.",
      "description_length": 576,
      "index": 1967,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MapDomain.LiftBot",
      "library": "goblint.domain",
      "description": "This module provides map operations over keys from `M.key` and values of `Range.t`, supporting standard manipulations like `add`, `filter`, and `fold`, alongside bulk updates via `add_list` and merging with `map2`. It integrates lattice operations (`join`, `widen`) for abstract interpretation tasks, enabling analysis of value combinations and domain transformations. Use cases include program analysis scenarios requiring precise key-value tracking and abstract domain reasoning, with utilities for serialization and structural comparison.",
      "description_length": 541,
      "index": 1968,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "MapDomain.Joined",
      "library": "goblint.domain",
      "description": "This module provides operations for managing key-value maps with joined keys (`E.t`) and values (`R.t`), supporting standard manipulations like insertion, deletion, and transformation, as well as lattice-based combination and approximation operations (`join`, `meet`, `widen`). It operates on a parameterized map structure (`t`) and includes functions for merging maps, inspecting their properties (e.g., cardinality, equality), and serializing their contents. These features are particularly useful in abstract interpretation scenarios requiring joined key domains and customizable lattice operations for merging or analyzing symbolic states.",
      "description_length": 643,
      "index": 1969,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lattice.HashCached",
      "library": "goblint.domain",
      "description": "This module combines lattice operations with hash-caching to enable efficient equality checks, comparisons, and structural analysis of lattice elements. It supports key operations like join, meet, widening, and narrowing on values of type `t`, which wrap `M.t` with a lazily computed hash to minimize redundant computations. Submodules handle hash caching mechanics, allowing operations such as `force` to compute hashes on demand, which is critical for performance in static analysis tasks involving large or complex lattice values. Example usage includes optimizing repeated comparisons in dataflow analysis or detecting structural differences between lattice elements with minimal overhead.",
      "description_length": 693,
      "index": 1970,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lattice.PD",
      "library": "goblint.domain",
      "description": "Implements a lattice structure with a partial order relation. Provides operations to compute least upper bounds and greatest lower bounds for elements, supporting analysis of hierarchical relationships. Works with tagged, comparable data types where a partial order is defined. Useful in static analysis for representing program states with ordering constraints.",
      "description_length": 362,
      "index": 1971,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MapDomain.PrintGroupable",
      "library": "goblint.domain",
      "description": "This module enables structured output generation for maps with grouped keys, offering functions to convert grouped map data into XML, Yojson, and formatted string representations. It works with `GroupMap.t` structures, where keys are organized into `Group.t` categories, supporting operations like insertion, ordered traversal, merging, and transformation. Use it to produce categorized configuration dumps, formatted logs, or hierarchical reports with grouped entries. The `Group` submodule handles key categorization while `GroupMap` provides ordered, group-based map manipulation.",
      "description_length": 583,
      "index": 1972,
      "embedding_norm": 1.0
    },
    {
      "module_path": "BoolDomain.MakeBool",
      "library": "goblint.domain",
      "description": "Implements boolean values with standard operations like equality, comparison, and hashing. Provides string conversion, pretty printing, XML serialization, and QCheck arbitrary generation. Useful for representing and manipulating boolean states in analysis or testing contexts.",
      "description_length": 276,
      "index": 1973,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lattice.Chain",
      "library": "goblint.domain",
      "description": "This module implements lattice operations for integers, including join, meet, widening, narrowing, and extremal element checks (like bottom/top validation) alongside their creation. It operates on integer values structured as a lattice, with support for comparison, pretty-printing, and test case generation via QCheck. These capabilities are critical in static analysis and program verification workflows where tracking numeric ranges or merging data flow states is required.",
      "description_length": 476,
      "index": 1974,
      "embedding_norm": 1.0
    },
    {
      "module_path": "SetDomain.FiniteSetElem",
      "library": "goblint.domain",
      "description": "This module represents elements of a finite set domain with operations for equality, hashing, comparison, and serialization. It works with a concrete type `t` that forms a finite list of elements, supporting precise identity checks, ordering, and unique tagging. Use it to define and manipulate finite, hash-consed elements in set abstractions, such as program analysis values or symbolic identifiers.",
      "description_length": 401,
      "index": 1975,
      "embedding_norm": 1.0
    },
    {
      "module_path": "PartitionDomain.ExpPartitions",
      "library": "goblint.domain",
      "description": "This module combines set-theoretic and lattice-based operations to manipulate partitions of expressions, supporting both union/intersection/difference and meet/join/widen on a lifted sum type that includes a maximal value. It directly provides operations on partitions grouped into equivalence classes, enabling refinement and combination of expression sets under abstract interpretation. The child modules extend this with polymorphic lattice primitives and set manipulations over immutable expression partitions, supporting transformations like filtering, folding, and merging for static analysis tasks. Example uses include tracking disjoint expression groups, merging analysis states, and refining partitions during dataflow inference.",
      "description_length": 739,
      "index": 1976,
      "embedding_norm": 1.0
    },
    {
      "module_path": "HoareDomain.SetEM",
      "library": "goblint.domain",
      "description": "This module provides lattice and set operations on a domain of elements abstracted by their maximal elements under a Hoare ordering. It works with sets of elements from a base lattice `E.t`, where operations like join, meet, widen, and narrow are computed using the Egli-Milner widening strategy to ensure convergence even when maximal element counts diverge. It is particularly useful in abstract interpretation for static program analysis, where tracking maximal elements suffices to reason about properties like upper bounds of program states.",
      "description_length": 546,
      "index": 1977,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "MapDomain.Timed",
      "library": "goblint.domain",
      "description": "This module provides associative operations for timed maps, including insertion, deletion, transformation, and folding over key-value pairs parameterized by the `M` module. It supports lattice operations like join and meet to combine or approximate values, which are critical for program analysis tasks requiring temporal data abstraction. The structure also facilitates bulk updates, merging, and serialization, making it suitable for managing dynamic, time-aware state in domains like caching or event stream processing.",
      "description_length": 522,
      "index": 1978,
      "embedding_norm": 1.0
    },
    {
      "module_path": "HoareDomain.Set",
      "library": "goblint.domain",
      "description": "This module provides lattice operations (join, meet, widen) and set manipulations (union, intersection, filtering) over collections of Lattice.S elements, structured under Hoare ordering that tracks only maximal elements. It employs extrapolation heuristics to ensure convergence in abstract interpretation scenarios where traditional widening fails, particularly for powerset domains in static program analysis. The design prioritizes efficiency by focusing on maximal elements, with utilities for structural queries (cardinality, element retrieval) and domain-specific transformations relevant to fixpoint computations.",
      "description_length": 621,
      "index": 1979,
      "embedding_norm": 1.0
    },
    {
      "module_path": "DisjointDomain.CombinedSet",
      "library": "goblint.domain",
      "description": "This module provides set operations (union, intersection, difference, filtering) and lattice operations (join, meet, widening) on elements grouped into buckets via a relation `RC`, where each bucket is a set of type `B` containing elements of type `E.t`. It supports both element-wise transformations and bucket-wise queries, enabling efficient analysis of partitioned domains. Specific use cases include path-sensitive program analysis and managing disjoint address sets, where elements are processed according to their bucket congruence or projection.",
      "description_length": 553,
      "index": 1980,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "MapDomain.Groupable",
      "library": "goblint.domain",
      "description": "This module groups values of type `t` into equivalence classes based on structural equality, using the `compare` and `equal` functions. It provides operations to compare, display, and serialize these groups, enabling efficient handling of grouped domain elements. Concrete use cases include partitioning abstract domain values for analysis or optimization passes that require equivalence classification.",
      "description_length": 403,
      "index": 1981,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lattice.Prod3",
      "library": "goblint.domain",
      "description": "This module supports lattice operations on triplets of elements from three distinct base lattices, enabling element-wise computation of meets, joins, and comparisons while preserving the product structure. It provides utilities for serializing lattice states to XML/YoJSON, pretty-printing values and differences, and generating arbitrary test instances. Such functionality is useful in program analysis for combining multiple abstract domains, such as tracking numeric ranges, sign information, and parity constraints simultaneously in a data flow analysis.",
      "description_length": 558,
      "index": 1982,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MapDomain.Bindings",
      "library": "goblint.domain",
      "description": "This module provides operations to fold over and iterate through key-value pairs in a structured domain representation. It works with abstract data types `t`, `key`, and `value`, representing the domain structure, keys, and associated values. Concrete use cases include traversing and printing domain elements or accumulating values based on keys during analysis passes.",
      "description_length": 370,
      "index": 1983,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MapDomain.HConsed",
      "library": "goblint.domain",
      "description": "This module provides operations for creating, querying, and transforming finite maps with HConsed values, supporting standard manipulations like insertion, lookup, filtering, and bulk updates alongside lattice-based combinations such as join and widen. It operates on a map type `t` that associates keys with HConsed values, ensuring structural identity uniqueness via tagging, and includes utilities for comparison, serialization, and arbitrary instance generation. These features are particularly useful in formal analysis tools requiring efficient equality checks, structural sharing, or lattice-driven dataflow computations.",
      "description_length": 628,
      "index": 1984,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "PartitionDomain.SetSet",
      "library": "goblint.domain",
      "description": "This module combines set-theoretic operations with lattice semantics to model partitions over a base element type, supporting union, intersection, difference, joins, meets, and widening. It manipulates a set-like structure that can represent concrete collections or a symbolic top element, enabling filtering, mapping, and cardinality checks. The child module extends this with order-aware utilities, partitioning, and extremal element extraction, supporting tasks like static analysis and symbolic reasoning. Together, they allow precise manipulation of abstract domains, such as tracking possible values of variables in program analysis or computing fixed-point approximations over structured data.",
      "description_length": 700,
      "index": 1985,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lattice.PO",
      "library": "goblint.domain",
      "description": "Implements a lattice with partial order operations, providing `leq`, `join`, `meet`, `widen`, and `narrow` for combining and comparing elements. Works with a base type `t` equipped with equality, comparison, and pretty-printing. Useful for abstract interpretation tasks like program analysis where elements represent approximations of program states.",
      "description_length": 350,
      "index": 1986,
      "embedding_norm": 1.0
    },
    {
      "module_path": "DisjointDomain.MayEqualSetDomain",
      "library": "goblint.domain",
      "description": "This module combines lattice and set operations to model abstract values where elements are partitioned into disjoint buckets, supporting equality checks via a custom `may_be_equal` predicate. It provides set algebra, bucket-aware transformations, and cardinality analysis for polymorphic element types, with lattice combinators like `join` and `widen` enabling iterative fixed-point computations. It is particularly suited for program analysis scenarios requiring path-sensitive reasoning or tracking relationships between disjoint data domains, such as memory address sets partitioned by allocation context.",
      "description_length": 609,
      "index": 1987,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lattice.ProdConf",
      "library": "goblint.domain",
      "description": "This module combines two lattice structures into composite lattice pairs, supporting standard lattice operations like meet, join, and widening while incorporating expansion controls via `expand_fst`/`expand_snd` flags and a `relift` function for reapplying transformations. It operates on product types (`Base1.t * Base2.t`), providing serialization to string/XML/JSON formats, pretty-printing, and arbitrary value generation for testing. Use cases include static analysis domains requiring combined abstract interpretations (e.g., tracking numerical ranges and pointer relationships simultaneously) with customizable lattice behavior and debug output.",
      "description_length": 652,
      "index": 1988,
      "embedding_norm": 1.0
    },
    {
      "module_path": "BoolDomain.Names",
      "library": "goblint.domain",
      "description": "This module defines named representations for boolean domains, including identifiers for true and false values. It works with string and boolean data types to associate domain-specific names with boolean states. Useful for scenarios like configuration systems or domain-specific languages where boolean values need semantic labels.",
      "description_length": 331,
      "index": 1989,
      "embedding_norm": 1.0
    },
    {
      "module_path": "SetDomain.Elements",
      "library": "goblint.domain",
      "description": "This module provides operations to retrieve and iterate over elements of a set domain. It works with abstract set types `t` and their element types `elt`. Concrete use cases include enumerating set contents for printing or applying side-effecting functions to each element during traversal.",
      "description_length": 290,
      "index": 1990,
      "embedding_norm": 1.0
    },
    {
      "module_path": "BoolDomain.MakeMayBool",
      "library": "goblint.domain",
      "description": "This module provides lattice operations for a boolean domain extended with top and bottom elements, supporting comparisons, joins, meets, and approximation via widening/narrowing. It works with a type representing boolean values enriched with extremal elements, offering checks for top/bottom states and domain-specific utilities like serialization and test generation. The structure is suited for static analysis contexts requiring precise tracking of boolean approximations, such as abstract interpretation frameworks.",
      "description_length": 520,
      "index": 1991,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "TrieDomain.Make",
      "library": "goblint.domain",
      "description": "This module orchestrates trie-based abstract domains with lattice semantics, enabling hierarchical data aggregation and structural analysis through nodes that hold values and keyed child subtries. It supports core operations like equality checks, serialization, and lattice transformations such as meet and widen, facilitating static analysis of complex state spaces and compositional reasoning over nested structures. The first child module enhances these capabilities with lattice operations that track witnesses for change detection, supporting precise analysis and diff visualization across nested data hierarchies. The second child module extends this with a key-based associative map structure over trie nodes, offering insertion, iteration, and lattice-merged transformations to model domain-specific hierarchies and perform precision-controlled analysis of structured data.",
      "description_length": 881,
      "index": 1992,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lattice.LiftTop",
      "library": "goblint.domain",
      "description": "This module combines lattice operations like join, meet, widen, and narrow with utilities for equality, comparison, and serialization to handle values that are either elements of a base lattice or a distinguished top element. It supports abstract interpretation by enabling approximation through widening and narrowing, while predicates like `is_top` and `is_bot` identify extremal values. The module also facilitates debugging and analysis by formatting differences between lifted values for display.",
      "description_length": 501,
      "index": 1993,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lattice.LiftConf",
      "library": "goblint.domain",
      "description": "This module provides lattice operations for a type extended with explicit bottom (`Bot`) and top (`Top`) elements, supporting comparisons (`leq`), joins/meets, widening/narrowing, and conversion between tagged representations. It works with values of an underlying type `Base.t` wrapped in polymorphic variants (`Lifted`, `Bot`, `Top`), enabling hierarchical reasoning in abstract domains. Use cases include static analysis frameworks requiring precise handling of extremal elements and difference tracking via `pretty_diff` for debugging lattice state transitions.",
      "description_length": 565,
      "index": 1994,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lattice.LiftBot",
      "library": "goblint.domain",
      "description": "This module provides lattice operations for combining a bottom element with values from a base lattice, supporting structural manipulation, order comparisons, and approximation techniques like widening and narrowing. It operates on a sum type consisting of `Bot` (denoting an undefined value) and `Lifted` wrappers around a base lattice type, enabling abstract interpretation tasks such as merging analysis states or refining bounds. Typical use cases include static program analysis, where tracking lifted values with a bottom element models partial or conditional information flow.",
      "description_length": 583,
      "index": 1995,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "SetDomain.ToppedSetNames",
      "library": "goblint.domain",
      "description": "This module provides a single value `topname` representing the name of the top element in a set domain. It works with string data to identify the distinguished top value. Concrete use cases include labeling the universal set element in abstract interpretations.",
      "description_length": 261,
      "index": 1996,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lattice.S",
      "library": "goblint.domain",
      "description": "This structure provides core lattice operations including element comparison, join/meet composition, and extremal value handling via `top` and `is_top`. It manipulates an abstract type `t` representing lattice elements, supporting algebraic transformations and extremal state checks. These capabilities are particularly useful in static analysis frameworks where tracking maximal/minimal states or convergence bounds is required.",
      "description_length": 429,
      "index": 1997,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lattice.FakeSingleton",
      "library": "goblint.domain",
      "description": "This module provides lattice operations for a minimal, singleton-like structure where all elements are effectively equivalent, built over a base type. It supports standard lattice functions like join, meet, widen, and narrowing, along with utilities for comparison, serialization, and analysis-specific debugging via pretty-printing. Designed for contexts requiring a trivial lattice abstraction, such as placeholder implementations or simplified static analysis frameworks where element identity is irrelevant.",
      "description_length": 511,
      "index": 1998,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MapDomain.S",
      "library": "goblint.domain",
      "description": "This module type provides operations for manipulating key-value associations with transformations, queries, and structural combinations, alongside lattice-based abstractions for program analysis. It works with a map-like structure `t` parameterized by key and value types, supporting advanced operations like custom merging, filtering, and lattice joins, meets, and widening. Use cases include abstract interpretation of program states modeled as maps\u2014where merging, comparison, and extremal value detection are critical\u2014and serialization scenarios for data persistence or API integration.",
      "description_length": 589,
      "index": 1999,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MapDomain.LiftTop",
      "library": "goblint.domain",
      "description": "This module provides operations for managing maps with keys from a module `M` and values as abstract domains (`Range.t`), supporting standard manipulations (insertion, lookup, iteration), structural queries (cardinality, emptiness checks), and value transformations (mapping, filtering, merging). It includes lattice operations (join, meet, widening) for combining or comparing map values, enabling use in abstract interpretation tasks like program analysis, where maps represent environments or state abstractions. Functions also support serialization, pretty-printing, and structural equality checks for practical integration into analysis tools.",
      "description_length": 648,
      "index": 2000,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "Lattice.Lift2Conf",
      "library": "goblint.domain",
      "description": "This module implements lattice operations for a combined domain that merges two distinct base lattices into a single structure with explicit bottom and top elements. It supports operations like join, meet, widening, and narrowing on a lifted sum type that encapsulates values from either base lattice or extremal elements, along with comparison, serialization, and difference visualization. The design is particularly useful in static analysis for unifying separate abstract domains while preserving their individual properties and handling extremal cases.",
      "description_length": 556,
      "index": 2001,
      "embedding_norm": 1.0
    },
    {
      "module_path": "SetDomain.SensitiveConf",
      "library": "goblint.domain",
      "description": "This module implements a path-sensitive set domain that merges analyses when user elements match, using a custom set type over user-defined values. It supports standard set operations like union and intersection, along with domain-specific joins, meets, and comparisons, all without a top element. The core functionality pairs with a submodule that handles structured base-user element pairs, enabling precise state tracking across execution paths. For example, it can merge integer value sets when corresponding analysis contexts match, refining static analysis precision.",
      "description_length": 573,
      "index": 2002,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lattice.HConsed",
      "library": "goblint.domain",
      "description": "This module provides hash-consing for lattice elements using a customizable hash table, ensuring canonical representation of values through the `hashcons` function, which guarantees a unique representative for equivalent inputs. It supports efficient equality checks and memory optimization in lattice-based analyses by deduplicating keys. Submodule HConsedTable implements the underlying hash table with customizable hashing and equality, while HConsedValue provides utilities for working with interned values. Example usage includes interning abstract syntax trees or type representations to optimize comparison and storage in compilers or static analysis tools.",
      "description_length": 664,
      "index": 2003,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MapDomain.Print",
      "library": "goblint.domain",
      "description": "This module provides functions for converting map domain structures into various output formats. It supports pretty-printing to a document format, generating string representations, writing XML output, and serializing to Yojson. These operations are useful for logging, debugging, and exporting map domain data in human-readable or machine-processable forms.",
      "description_length": 358,
      "index": 2004,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lattice.Flat",
      "library": "goblint.domain",
      "description": "This module implements a three-tiered lattice structure with operations for combining and comparing values across a bottom element, a top element, and a wrapped base type. It provides join/meet operations with widening/narrowing, equality checks, and serialization to XML/JSON, working with data structures that represent values as either `Bot`, `Lifted` of a base type, or `Top`. The design supports scenarios like static analysis frameworks where hierarchical value abstraction is needed, enabling precise tracking of program states through lattice-based approximations.",
      "description_length": 572,
      "index": 2005,
      "embedding_norm": 1.0
    },
    {
      "module_path": "BoolDomain.MustBool",
      "library": "goblint.domain",
      "description": "This module provides lattice-theoretic operations for boolean domains, including join, meet, widen, narrow, and comparisons like `leq`, alongside domain-specific utilities such as `bot` (bottom) and `top` (top) element management. It works with a boolean lattice structure represented by an abstract type `t`, which extends the base `bool` type with HConsed tags to ensure unique value identification and efficient equality checks. It is designed for use in abstract interpretation frameworks where boolean values model approximated or symbolic states, enabling precise static analysis of program properties through standard domain-theoretic patterns.",
      "description_length": 651,
      "index": 2006,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lattice.ProdSimple",
      "library": "goblint.domain",
      "description": "This module provides lattice operations on pairs of values from two distinct lattice types, combining their structure through component-wise joins, meets, and comparisons. It supports dataflow analysis use cases by enabling composition of independent lattice properties, such as tracking numerical ranges and pointer relationships simultaneously, while offering serialization and testing utilities for structured data representation.",
      "description_length": 433,
      "index": 2007,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lattice.Num",
      "library": "goblint.domain",
      "description": "Implements numeric lattice operations for integers, including `join` and `meet` functions for combining values under a lattice structure. Works directly with the `int` type, supporting concrete use cases such as tracking upper and lower bounds in static analysis domains. Useful in abstract interpretation where integer ranges or sign information must be merged or compared.",
      "description_length": 374,
      "index": 2008,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "PartitionDomain.CollapseSet",
      "library": "goblint.domain",
      "description": "This module combines lattice operations for abstract domain elements with set-like manipulations, enabling comparison, merging, and partitioning of structured data. It works with abstract values in a partitioning domain and sets of elements, supporting use cases like abstract interpretation, dataflow analysis, and set-based reasoning where collapsing conditions (e.g., subset equivalence) or extremal element extraction are required. Key operations include lattice joins/meets, set union/intersection, and the `collapse` function to merge partitions under domain-specific criteria.",
      "description_length": 583,
      "index": 2009,
      "embedding_norm": 1.0
    },
    {
      "module_path": "FlagHelper.LatticeFlagHelperArg",
      "library": "goblint.domain",
      "description": "This module defines a lattice structure with operations for comparing, combining, and transforming values of type `t`. It supports concrete use cases such as static analysis of program states, where values are merged, diffed, or checked for inclusion using functions like `join`, `meet`, `leq`, and `pretty_diff`. The type `t` represents domain-specific values with a partial order and bounded lattice properties.",
      "description_length": 413,
      "index": 2010,
      "embedding_norm": 1.0
    },
    {
      "module_path": "SetDomain.FiniteSet",
      "library": "goblint.domain",
      "description": "This module provides lattice and set algebra operations over finite sets, supporting operations like join, meet, union, and intersection, along with domain-specific utilities such as pretty-printing and serialization. It works with sets of type `t` over elements of type `E`, offering cardinality checks, extremal element selection, and a \"top\" value for universal sets, tailored for abstract interpretation and formal verification. A child module enhances it with concrete, enumerated element support, enabling precise membership checks and standard set-theoretic manipulations using a fixed list of elements. Together, they allow tasks like modeling finite states, symbolic execution, and iterative refinement in abstract domains.",
      "description_length": 732,
      "index": 2011,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "SetDomain.Make",
      "library": "goblint.domain",
      "description": "This module provides lattice operations (e.g., `join`, `meet`, `widen`), set transformations (e.g., `map`, `filter`, `partition`), and membership/relational queries (e.g., `mem`, `subset`, `disjoint`) for sets constructed from a base type. It operates on a purely functional set structure (`t`) built using `BatSet.Make` over `Base.t`, with no top element, ensuring strict domain semantics. It is particularly suited for applications like static analysis or formal verification where explicit handling of all cases is required, and precise set manipulations are critical for correctness.",
      "description_length": 587,
      "index": 2012,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "SetDomain.Print",
      "library": "goblint.domain",
      "description": "This module provides functions for converting set domain values into various output formats, including pretty-printed documents, JSON, XML, and string summaries. It operates on set domain structures defined by the `S` module and their element types from `E`. Use this to generate human-readable or machine-consumable representations of sets for logging, serialization, or user interfaces.",
      "description_length": 388,
      "index": 2013,
      "embedding_norm": 1.0
    },
    {
      "module_path": "HoareDomain.HoarePO",
      "library": "goblint.domain",
      "description": "This module provides lattice operations and transformation utilities for maps that associate integers with lists of elements, supporting operations like join, meet, widen, and narrow. It enables custom merging strategies and order comparisons on `E.t list Map.t` structures, with capabilities for domain-specific set operations, serialization to JSON/XML, and difference visualization. The child module extends these operations with list-based combination methods tailored for abstract domains under Hoare ordering, allowing precise merging of abstract states in static analysis. Together, they facilitate analysis and combination of hierarchical state representations useful in abstract interpretation and complex dataflow debugging.",
      "description_length": 734,
      "index": 2014,
      "embedding_norm": 1.0
    },
    {
      "module_path": "HoareDomain.MapBot",
      "library": "goblint.domain",
      "description": "This module provides map-like structures with keys of type `SpecD.t` and values of type `R.t`, supporting key-value manipulations under Hoare ordering, including bulk updates, merging, and domain-specific algebraic operations like join, widen, and leq. It offers functionalities for emptiness checks, equality, and transformations crucial for abstract interpretation tasks, such as combining and comparing map entries with widening. Designed for static analysis scenarios, it enables precise tracking of key-value relationships in legacy systems where deprecated map-based domains are maintained.",
      "description_length": 596,
      "index": 2015,
      "embedding_norm": 1.0
    },
    {
      "module_path": "SetDomain.Reverse",
      "library": "goblint.domain",
      "description": "This module provides standard set operations (union, intersection, difference, membership checks) and lattice operations (join, meet, widening, narrowing) on a set-like structure with an inverted lattice hierarchy. It operates on elements of a base domain, preserving set functionality while reversing order semantics, enabling use cases like analyzing dual properties or computing with complemented sets in program analysis. Key features include extremal element access, cardinality tracking, and lattice-specific functions adjusted for reversed ordering.",
      "description_length": 556,
      "index": 2016,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MapDomain.MapTop",
      "library": "goblint.domain",
      "description": "This module implements a parameterized map structure that associates keys from a domain with values from a range, supporting standard associative operations like insertion, lookup, iteration, and transformation, alongside advanced lattice-based combinators for merging and analyzing values. It works with finite maps parameterized over key and value types, offering structural queries (cardinality, emptiness checks), bulk updates (list-based additions), and algebraic operations (join, meet, widen) tailored for abstract interpretation scenarios. The design enables use cases such as symbolic state analysis, where maps model variable environments with lattice-structured properties, and program transformations requiring precise value combination logic.",
      "description_length": 755,
      "index": 2017,
      "embedding_norm": 1.0
    },
    {
      "module_path": "HoareDomain.SetS",
      "library": "goblint.domain",
      "description": "This module provides lattice operations (join, meet, widen, narrow) and set abstractions (union, intersection, membership, filtering) over a parametric type `t` representing sets of elements. It combines Hoare domain semantics for abstract interpretation with functional set processing, enabling tasks like static analysis of program value ranges or symbolic state manipulation. The type supports debugging through serialization, witness generation, and predicate-based analysis of set properties like subset relations or disjointness.",
      "description_length": 535,
      "index": 2018,
      "embedding_norm": 1.0
    },
    {
      "module_path": "DisjointDomain.Representative",
      "library": "goblint.domain",
      "description": "This module represents elements of a domain projected into disjoint buckets, providing operations to compare, hash, and display these representatives. It works with abstract elements grouped by a congruence relation, using a projection function to map each element to its bucket representative. Concrete use cases include tracking path-sensitive values and managing address sets in static analysis.",
      "description_length": 398,
      "index": 2019,
      "embedding_norm": 1.0
    },
    {
      "module_path": "SetDomain.S",
      "library": "goblint.domain",
      "description": "This module provides lattice and set-theoretic operations on polymorphic sets, supporting both structural analysis (via `join`, `meet`, `widen`, `narrow`, `leq`) and standard set manipulations (union, intersection, difference, subset checks). It works with a generic set type `t` containing elements of type `elt`, enabling iteration, mapping, and extremal element retrieval. Designed for program analysis or abstract interpretation tasks, it facilitates reasoning about set domains with customizable equality, pretty-printing, and difference-explaining utilities.",
      "description_length": 564,
      "index": 2020,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lattice.ProdList",
      "library": "goblint.domain",
      "description": "This module provides lattice operations for product domains over lists of `Base.t` elements, including join, meet, widen, and narrow combinators essential for abstract interpretation. It supports list-specific utilities like prefix/suffix detection and structural comparisons, enabling analysis of composite data where each list position represents a distinct abstract domain. The implementation derives standard typeclass operations and serialization for integration with broader analysis frameworks.",
      "description_length": 501,
      "index": 2021,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lattice.LiftPO",
      "library": "goblint.domain",
      "description": "This module supports lattice operations like join, meet, widen, and narrow over a structure with extremal elements (`Bot`, `Top`) and wrapped base values (`Lifted of Base.t`), alongside utilities for comparison, serialization (XML/JSON), and difference visualization via `pretty_diff`. It is designed for scenarios requiring precise partial-order reasoning with bottom and top elements, such as static analysis frameworks or dataflow optimization, where merging, refining, or testing lattice-based abstractions demands explicit handling of extremal cases and structured value inspection.",
      "description_length": 587,
      "index": 2022,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "FlagHelper.FlagHelper",
      "library": "goblint.domain",
      "description": "This module operates on pairs of optional values from two distinct domains, supporting comparisons, hashing, and transformations. It provides unary and binary operations that apply functions to these pairs, along with serialization and pretty-printing capabilities. Concrete use cases include handling runtime flag combinations and structuring conditional logic based on the presence or absence of values from each domain.",
      "description_length": 422,
      "index": 2023,
      "embedding_norm": 1.0
    },
    {
      "module_path": "FlagHelper.FlagError",
      "library": "goblint.domain",
      "description": "This module represents errors related to runtime flag configurations, carrying a message and a flag name. It works with string values to identify and describe invalid or unsupported flag states. Concrete use cases include signaling mismatches between expected and provided flag values or missing required flags during configuration parsing.",
      "description_length": 340,
      "index": 2024,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lattice.Fake",
      "library": "goblint.domain",
      "description": "This module provides foundational lattice operations including ordering (leq), combination (join/meet), and approximation (widen/narrow), alongside structural utilities for equality, hashing, and comparison. It manipulates abstract lattice values of type `t` and polymorphic data of type `'a`, incorporating specialized support for representing extreme values (bot/top), detecting extremal states, and visualizing differences between elements. The design facilitates applications in abstract interpretation, program analysis, and property testing where symbolic reasoning over hierarchical data requires customizable lattice semantics and serialization capabilities.",
      "description_length": 666,
      "index": 2025,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lattice.Lift2",
      "library": "goblint.domain",
      "description": "This module combines two base lattices into a new lattice structure augmented with explicit bottom (`Bot`) and top (`Top`) elements, supporting operations like comparison, equality checks, and lattice joins/meets. It handles values wrapped in `Lifted1` or `Lifted2` constructors alongside extremal elements, providing widening/narrowing for fixpoint approximation in abstract interpretation. Use cases include analyzing disjunctive/conjunctive properties across dual lattices while preserving precision through explicit extremal markers.",
      "description_length": 537,
      "index": 2026,
      "embedding_norm": 1.0
    },
    {
      "module_path": "BoolDomain.Bool",
      "library": "goblint.domain",
      "description": "This module implements boolean values with standard operations like equality, comparison, and hashing. It provides functions for string representation, pretty printing, and XML serialization of boolean values. It supports use cases such as boolean domain analysis, value comparison, and data serialization in static analysis contexts.",
      "description_length": 334,
      "index": 2027,
      "embedding_norm": 1.0
    },
    {
      "module_path": "DisjointDomain.Congruence",
      "library": "goblint.domain",
      "description": "This module defines equivalence classes of elements using a congruence relation, where operations are performed within each class independently. It works with elements of type `elt`, grouped into buckets such that all elements in a bucket are congruent to each other. A concrete use case is partitioning program values into equivalence classes for abstract interpretation, such as tracking path-sensitive values or memory addresses with indistinguishable behavior.",
      "description_length": 464,
      "index": 2028,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "PartitionDomain.Set",
      "library": "goblint.domain",
      "description": "This module provides set-based partitioning operations for abstract domains, supporting creation, modification, and algebraic manipulation of sets (union, intersection, difference) alongside lattice operations like narrowing and widening. It works with abstract sets of elements (`elt`) and includes domain-specific lifting, serialization (XML/JSON), and extremal element retrieval, enabling use cases in program analysis where precise partitioning of state spaces or symbolic value tracking is required. Functions like `collapse`, `join`, and `meet` facilitate domain-specific transformations while maintaining efficient membership checks and cardinality tracking.",
      "description_length": 665,
      "index": 2029,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "MapDomain.MapTop_LiftBot",
      "library": "goblint.domain",
      "description": "This module provides associative map operations for finite maps with keys of type `Domain.t` and values in a lattice structure defined by `Range.t`. It supports lattice-specific operations like join, meet, widening, and narrowing for abstract interpretation tasks, alongside standard map manipulations such as merging, filtering, and bulk updates. Use cases include static analysis of programs where maps model environments or state spaces requiring monotonic fixpoint computations over lattice-ordered values.",
      "description_length": 510,
      "index": 2030,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "TrieDomain",
      "library": "goblint.domain",
      "description": "This module organizes trie-based abstract domains with lattice semantics, enabling hierarchical data aggregation and structural analysis through nodes that hold values and keyed child subtries. It supports core operations like equality checks, serialization, and lattice transformations such as meet and widen, with additional capabilities for tracking witnesses to detect changes and visualize diffs across nested structures. A key-based associative map structure over trie nodes allows insertion, iteration, and lattice-merged transformations, enabling precise, precision-controlled analysis of domain-specific hierarchies. For example, it can model program state hierarchies, track value changes across analysis passes, and merge subtries under lattice rules to analyze structured data flows.",
      "description_length": 795,
      "index": 2031,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lattice",
      "library": "goblint.domain",
      "description": "This module defines core lattice operations\u2014comparisons, joins, meets, widening, and narrowing\u2014over a range of data types including unit, integers, products, and lifted structures with explicit bottom and top elements. It supports combining lattices through product constructions, inversion, and sum types, enabling hierarchical and composite state representations essential for abstract interpretation and static analysis. Submodules optimize performance via hash-consing and caching, and provide utilities for serialization, pretty-printing, and testing, allowing efficient manipulation of complex lattice elements in dataflow analysis and program verification. Example uses include tracking numeric ranges with sign information, merging abstract states in reverse analysis, and managing disjunctive domains with explicit extremal elements.",
      "description_length": 842,
      "index": 2032,
      "embedding_norm": 1.0
    },
    {
      "module_path": "FlagHelper",
      "library": "goblint.domain",
      "description": "This module manages domain alternatives selected by runtime flags, using lattice structures and flag configurations to determine active domains during execution. It supports feature toggles and variant selection through operations like `join`, `meet`, and `leq` on type `t`, while handling pairs of optional values across domains with comparison and transformation functions. Error handling for invalid or missing flags is provided through dedicated types that capture flag names and messages. Use cases include static analysis of program states, conditional logic based on runtime flags, and safe configuration parsing with descriptive error reporting.",
      "description_length": 653,
      "index": 2033,
      "embedding_norm": 1.0
    },
    {
      "module_path": "PartitionDomain",
      "library": "goblint.domain",
      "description": "This module manages domain partitioning through operations like splitting, merging, and collapsing sets of values, working with abstract domains and sets to enable precise manipulation of value partitions. It supports lattice-based manipulations such as joins, meets, and closure computations, along with set-theoretic operations including union, intersection, and difference, all tailored for abstract interpretation tasks like equivalence class identification, domain refinement, and fixed-point approximation. The module handles structured data and expression partitions using lifted sum types and maximal elements, supporting transformations like filtering, folding, and merging under domain-specific criteria. Use cases include optimizing static analysis by reducing partition complexity, tracking disjoint value subsets, and refining analysis states during dataflow inference.",
      "description_length": 882,
      "index": 2034,
      "embedding_norm": 1.0
    },
    {
      "module_path": "DisjointDomain",
      "library": "goblint.domain",
      "description": "This module organizes elements into disjoint buckets via congruence or projection, enabling bucket-wise set and lattice operations that preserve domain-specific invariants. It supports key data types like sets and maps partitioned by relations or equivalence classes, with operations including join, meet, union, and filtering applied independently within each bucket. Submodules extend this structure with map-like and set-like interfaces, lattice combinators, and congruence-based equivalence for path-sensitive analysis and address tracking. Examples include modeling program states under different execution paths or partitioning memory addresses by allocation context, ensuring operations respect bucket boundaries and domain semantics.",
      "description_length": 741,
      "index": 2035,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "BoolDomain",
      "library": "goblint.domain",
      "description": "This module provides boolean domains with abstract lattices for modeling truth values under approximation, supporting operations like conjunction, disjunction, and negation. It includes submodules that define naming conventions, standard operations, and lattice extensions with top and bottom elements, enabling precise static analysis of boolean expressions. Main data types include abstract boolean lattices with hconsed tags, three-element domains for may/must approximations, and named boolean representations for configurable output. Examples include verifying program properties through abstract interpretation, serializing boolean states with custom labels, and refining boolean approximations using widening and narrowing.",
      "description_length": 730,
      "index": 2036,
      "embedding_norm": 1.0
    },
    {
      "module_path": "SetDomain",
      "library": "goblint.domain",
      "description": "This module provides set domains with rich support for finite and infinite sets, leveraging lattice structures to enable abstract interpretation and static analysis. It offers core data types like sets with top/bottom elements, joined sets for union operations, and finite sets with ordering, alongside operations for membership, union, intersection, and lattice-specific joins, meets, and widenings. Examples include tracking symbolic values with approximations, merging path-sensitive analyses, and enumerating set contents for analysis or serialization. Submodules enhance these capabilities with structured elements, inverted lattice semantics, and utilities for pretty-printing and conversion to output formats.",
      "description_length": 716,
      "index": 2037,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MapDomain",
      "library": "goblint.domain",
      "description": "This module organizes map-like structures with domain-specific keys and lattice-backed values, enabling efficient key-value operations alongside abstract interpretation combinators. It supports core operations like insertion, lookup, and transformation, while submodules extend functionality with lattice joins/meets, bulk updates, hash-consed equality, and serialization to XML/Yojson. You can merge program environments, analyze symbolic state with widening, or generate structured logs from grouped keys. Specific capabilities include time-aware maps, equivalence grouping, and HConsed value maps for efficient structural comparisons in formal analysis.",
      "description_length": 656,
      "index": 2038,
      "embedding_norm": 1.0
    },
    {
      "module_path": "HoareDomain",
      "library": "goblint.domain",
      "description": "This module implements abstract domains using Hoare ordering, focusing on set-based value abstractions and partial orders for static analysis tasks like interval analysis and constraint propagation. It supports domains of maximal elements, maps with list values, and key-value structures, offering lattice operations, set algebra, and transformations tailored for convergence in fixpoint computations. Operations include join, meet, widen, union, and intersection, with specific utilities for tracking upper bounds, merging abstract states, and analyzing hierarchical dataflows. Examples include analyzing program value ranges, combining symbolic states, and debugging dataflow through structured set transformations.",
      "description_length": 717,
      "index": 2039,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 2103,
    "meaningful_modules": 2040,
    "filtered_empty_modules": 63,
    "retention_rate": 0.9700427960057061
  },
  "statistics": {
    "max_description_length": 1146,
    "min_description_length": 106,
    "avg_description_length": 504.73970588235295,
    "embedding_file_size_mb": 7.409370422363281
  }
}