{
  "package": "goblint",
  "embedding_model": "Qwen/Qwen3-Embedding-8B",
  "embedding_dimension": 4096,
  "total_modules": 1655,
  "creation_timestamp": "2025-08-19T11:30:43.225354",
  "modules": [
    {
      "module_path": "GobConfig.ValidatorRequireAll",
      "library": "goblint.config",
      "description": "Validates that all fields in a JSON schema are present in a given configuration value. Works with JSON schema representations and configuration data structured as `JsonSchema.JE.repr_value`. Used to enforce completeness of configuration inputs against a defined schema during validation steps.",
      "description_length": 293,
      "index": 0,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "JsonSchema.JS",
      "library": "goblint.config",
      "description": "Converts JSON schemas to and from Yojson values. Handles schema serialization and deserialization using the `Json_schema.schema` type. Useful for loading validation rules from JSON files or converting existing schemas to JSON format for storage or transmission.",
      "description_length": 261,
      "index": 1,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "GobConfig.Validator",
      "library": "goblint.config",
      "description": "Validates JSON configuration values against a predefined schema encoding. Uses `schema_encoding` to define the expected structure and `validate_exn` to perform validation, raising exceptions on errors. Designed for enforcing correct configuration formats during setup or critical execution paths where invalid input must immediately fail.",
      "description_length": 338,
      "index": 2,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "JsonSchema.JE",
      "library": "goblint.config",
      "description": "This module provides functions to convert values to and from JSON representations using encodings, supporting schema-based validation. It works with `Json_repr.Yojson.value` and typed encodings to handle structured data parsing and serialization. Concrete use cases include validating JSON input against a schema during API request processing and generating JSON output from typed values with optional field handling.",
      "description_length": 417,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "GobConfig.Impl",
      "library": "goblint.config",
      "description": "This module directly manipulates a path-based, untyped JSON configuration tree using string paths to access and modify values of specific types such as integers, booleans, strings, and lists. It supports loading, merging, and writing configurations from files or raw JSON, with strict schema enforcement on writes and failure via `failwith` on errors. Typical use includes setting and retrieving typed configuration values, merging external JSON files into the current configuration, and temporarily disabling configuration changes during evaluation.",
      "description_length": 550,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "JsonSchema.Validator",
      "library": "goblint.config",
      "description": "Performs JSON schema validation using a provided schema module. It encodes and validates JSON values against the schema, ensuring correctness for use cases like API input validation or configuration parsing. The module works directly with JSON representations and schema definitions to enforce structure and types.",
      "description_length": 314,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "JsonSchema.JQ",
      "library": "goblint.config",
      "description": "This module provides functions to query, insert, replace, and merge JSON values using JSON Query paths. It operates directly on `Json_repr.Yojson.value` structures, enabling precise manipulation of JSON data trees. Use cases include extracting specific fields from JSON documents, updating nested values, and merging JSON objects recursively.",
      "description_length": 342,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "GobConfig",
      "library": "goblint.config",
      "description": "This module enables path-based manipulation of an untyped JSON configuration tree with typed operations for reading/writing integers, booleans, strings, and lists at specific paths. It enforces strict schema validation through submodules, merges configurations from files or JSON objects, and restricts modifications during execution using immutability checks. The system tracks global configuration state with `Yojson.Safe.t` for JSON data and `Fpath.t` for file paths, supporting use cases like runtime configuration enforcement and schema-compliant merging with internal state tracking via values like `earlyglobs` and `jobs`.",
      "description_length": 629,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "JsonSchema",
      "library": "goblint.config",
      "description": "Handles JSON schema validation, conversion, and manipulation with structured data. Provides functions to serialize/deserialize schemas, validate JSON against schemas, and query/update JSON trees. Used for API request validation, JSON configuration parsing, and structured JSON transformation workflows.",
      "description_length": 302,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Options",
      "library": "goblint.config",
      "description": "This module directly exposes the JSON schema for configuration options, providing functions to access default values, validate required fields, and generate completions for option names and paths. It operates on JSON schemas and parsed JSON trees, enabling introspection and structured output of configuration metadata. Concrete use cases include printing configuration help, validating option correctness, and supporting command-line auto-completion.",
      "description_length": 451,
      "index": 9,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "AfterConfig",
      "library": "goblint.config",
      "description": "This module manages a list of callback functions that execute once the runtime configuration is fully loaded. It provides operations to register new callbacks, store them in a mutable list, and run all registered callbacks. Use this module to perform initialization tasks that depend on fully loaded configuration data, such as setting up services or validating configuration values.",
      "description_length": 383,
      "index": 10,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_sites",
      "library": "goblint.sites",
      "description": "This module defines file path lists for organizing library and configuration resources. It includes separate paths for library stubs, runtime components, and configuration files, all using the `Fpath.t` type. These paths are used to locate and manage source and include files during analysis or build processes.",
      "description_length": 311,
      "index": 11,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MessageCategory.Behavior.Undefined.ArrayOutOfBounds",
      "library": "goblint.common",
      "description": "This module defines operations for handling array out-of-bounds conditions in message categories. It provides functions to create and classify out-of-bounds errors, including past-end, before-start, and unknown cases, and supports conversion from string lists and path representation. It works directly with `MessageCategory.array_oob` and `MessageCategory.category` types. Use cases include error categorization in array access operations and message routing based on out-of-bounds contexts.",
      "description_length": 492,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MyCFG.CfgEdgeH.Labels",
      "library": "goblint.common",
      "description": "This module manipulates edge labels in a control-flow graph, providing operations to add, replace, filter, and transform labeled edges based on their keys and associated data. It supports concrete tasks such as modifying edge annotations during analysis passes, filtering edges by label properties, and merging labeled edge data from multiple graph instances. Use cases include static analysis optimizations, path-sensitive tracking of control flow, and transformation of graph-based intermediate representations.",
      "description_length": 513,
      "index": 13,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MyCFG.CfgEdgeH.Exceptionless",
      "library": "goblint.common",
      "description": "This module provides operations to safely query and update a hash table mapping control-flow graph edges to values, using standard key-based lookups and in-place modifications. It works with `MyCFG.CfgEdgeH.t`, a hash table specialized for CFG edges as keys, and supports retrieving values via `find` and applying transformations via `modify`, which returns a result type to handle potential errors. Concrete use cases include tracking and updating edge-specific metadata during static analysis passes without raising exceptions on failed lookups or updates.",
      "description_length": 558,
      "index": 14,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MyCFG.NodeH.Exceptionless",
      "library": "goblint.common",
      "description": "This module provides operations to safely access and modify a hash table mapping control-flow graph nodes to values, using `find` to retrieve values by key and `modify` to apply transformations while handling potential exceptions. It works with `MyCFG.NodeH.t`, a hash table structure keyed by control-flow graph nodes, and returns results in a `BatPervasives.result` type to distinguish success from error states. Concrete use cases include tracking and updating node-specific data during static analysis passes where exception safety is required.",
      "description_length": 548,
      "index": 15,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Printable.HConsed.HC",
      "library": "goblint.common",
      "description": "Implements hash-consing for efficient storage and comparison of structured values, using a hash table to ensure each unique value has a single canonical representation. Works with elements of type `key` and hash-consed objects of type `BatHashcons.hobj`. Useful for managing large collections of immutable data where deduplication and fast equality checks are critical, such as abstract syntax trees or symbolic representations.",
      "description_length": 428,
      "index": 16,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Printable.HashCached.LazyHash",
      "library": "goblint.common",
      "description": "This module implements lazy hashing for printable elements, deferring hash computation until needed. It works with any type `t` that conforms to the `Printable` interface, caching the computed hash value after the first evaluation. Useful when dealing with expensive hash computations or when delaying hash calculation improves performance in data structures like hash tables or persistent collections.",
      "description_length": 402,
      "index": 17,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "MyCFG.NodeH.Infix",
      "library": "goblint.common",
      "description": "This module provides direct access to node values in a control-flow graph using key-based lookups and updates. It supports operations to retrieve a value from a node key and to assign a value to a node key. These functions are used when analyzing or transforming control-flow graphs, such as during dataflow analysis or optimization passes.",
      "description_length": 340,
      "index": 18,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Messages.Table.MH",
      "library": "goblint.common",
      "description": "This module enables mapping analysis messages to arbitrary data using a mutable hash table, supporting imperative operations like insertion, lookup, and in-place transformations alongside bulk processing via iteration, folding, and sequence-based initialization. It works with `Messages.Message.t` keys and generic values, facilitating efficient association of metadata, counts, or diagnostic details with specific program analysis messages. Typical use cases include tracking message occurrences, aggregating warning details, or attaching contextual data during static analysis workflows.",
      "description_length": 589,
      "index": 19,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "MessageCategory.Behavior.Undefined",
      "library": "goblint.common",
      "description": "This module defines concrete error categories for undefined behavior in memory and array operations. It provides direct constructors for specific error types like null pointer dereference, use-after-free, and memory leaks, along with utilities to convert error paths to string representations and classify errors from string lists. Use cases include precise error categorization in static analysis tools and message routing in diagnostic systems.",
      "description_length": 446,
      "index": 20,
      "embedding_norm": 1.0
    },
    {
      "module_path": "RichVarinfo.BiVarinfoMap.Make",
      "library": "goblint.common",
      "description": "This module implements a bidirectional mapping between a custom type `t` and `GoblintCil.varinfo`, supporting lookup, conversion, and serialization operations. It maintains a registry of associations, enabling retrieval of either the custom value or corresponding variable info, and provides descriptive string generation for debugging. Concrete use cases include tracking extended variable metadata across CIL transformations and persisting analysis state tied to specific variables.",
      "description_length": 484,
      "index": 21,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MyCFG.NodeH.Labels",
      "library": "goblint.common",
      "description": "This module manages labeled data associated with nodes in a control-flow graph, providing operations to add, replace, filter, and transform node labels based on their keys and values. It supports hash tables indexed by node keys, enabling precise manipulation of per-node metadata such as analysis results or annotations. Concrete use cases include tracking variable states at specific nodes, annotating nodes with optimization hints, and filtering nodes based on dynamic analysis data.",
      "description_length": 486,
      "index": 22,
      "embedding_norm": 1.0
    },
    {
      "module_path": "RichVarinfo.BiVarinfoMap.Collection",
      "library": "goblint.common",
      "description": "Implements operations for managing collections of bi-directional variable information maps. Provides functions to add, remove, and query variable mappings while ensuring consistency across both directions of the map. Useful for tracking relationships between variables in program analysis, such as aliasing or equivalence.",
      "description_length": 322,
      "index": 23,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MyCFG.CfgEdgeH.Infix",
      "library": "goblint.common",
      "description": "This module provides infix operators for manipulating control-flow graph edges. It supports adding edges with the `<--` operator and looking up edges with the `-->` operator, working directly with `CfgEdgeH.t` and `CfgEdgeH.key` types. Concrete use cases include constructing and querying CFG structures during static analysis of CIL code.",
      "description_length": 339,
      "index": 24,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CilType.Attribute",
      "library": "goblint.common",
      "description": "This module defines operations for working with CIL attributes, including equality checks, hashing, comparison, and string/XML/Yojson serialization. It supports the `attribute` type from GoblintCil, providing functions to inspect, compare, and uniquely identify attributes. Concrete use cases include attribute normalization, comparison in analysis passes, and exporting attribute data for external consumption or logging.",
      "description_length": 422,
      "index": 25,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CilType.Wstring_type",
      "library": "goblint.common",
      "description": "This module provides operations for handling wide string types in CIL, including equality checks, hashing, comparison, and pretty-printing. It works with the `wstring_type` type, which represents wide string data structures in C programs. Concrete use cases include analyzing and transforming C code that involves wide character strings, such as handling `wchar_t*` types in function signatures or string literals.",
      "description_length": 414,
      "index": 26,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Printable.Prod3",
      "library": "goblint.common",
      "description": "Handles equality, comparison, hashing, and serialization for 3-tuples of structured values. Provides string formatting, XML printing, JSON conversion, and QCheck arbitrary instance generation for tuples. Useful for composite data validation, structured logging, and multi-field comparisons.",
      "description_length": 290,
      "index": 27,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CilType.Binop",
      "library": "goblint.common",
      "description": "This module represents binary operations in CIL (C Intermediate Language) with concrete values like addition, subtraction, and logical operations. It provides equality checks, hashing, comparison, and string/XML/JSON representations for these operations. It is used to analyze or transform C code by manipulating binary expressions in the abstract syntax tree.",
      "description_length": 360,
      "index": 28,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CilType.Typeinfo",
      "library": "goblint.common",
      "description": "This module provides operations for comparing, hashing, and serializing CIL type information values, including equality checks, string representation, JSON conversion, and XML printing. It works with the `t` type, which represents CIL type information. Concrete use cases include persisting type data in various formats, comparing type identities in analyses, and generating unique identifiers for type discrimination in contexts like witness generation.",
      "description_length": 454,
      "index": 29,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MyCFG.CfgEdgeH",
      "library": "goblint.common",
      "description": "This component provides hash table operations for mapping control-flow graph edges to arbitrary values, supporting imperative updates (insertion, removal, in-place filtering) and functional transformations (merging, key-value mapping, bulk restructuring) with both eager and lazy evaluation. It operates on hash tables indexed by control-flow graph edge identifiers, enabling use cases like tracking edge-specific metadata (e.g., weights, execution counts), analyzing flow dependencies, or converting structured data to sequences/lists for visualization and analysis. The design accommodates scenarios requiring efficient key-based lookups, iterative table modification, and structured enumeration of edge-value relationships.",
      "description_length": 726,
      "index": 30,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "CilType.Exp",
      "library": "goblint.common",
      "description": "This module provides operations for comparing, hashing, and serializing CIL expressions, including equality checks, string and XML representations, and JSON conversion. It works directly with `GoblintCil.exp` values, which represent expressions in the C Intermediate Language. Concrete use cases include normalizing expressions during analysis, generating unique identifiers for expression nodes, and exporting expression data for logging or external processing.",
      "description_length": 462,
      "index": 31,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cilfacade.StmtH",
      "library": "goblint.common",
      "description": "This implementation provides operations for managing hash tables where CIL statements act as keys, enabling efficient lookups, insertions, deletions, and in-place transformations using higher-order functions like `fold` and `iter`. It supports bulk operations to initialize or update tables from sequences of key-value pairs, making it suitable for compiler-related tasks such as tracking statement-specific analysis results, metadata, or transformation states during code processing.",
      "description_length": 484,
      "index": 32,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Messages.Severity",
      "library": "goblint.common",
      "description": "This module defines a set of severity levels for program analysis messages, including operations to compare, serialize, and convert severities to and from integers and JSON. It supports filtering by providing a `should_warn` function that determines if a given severity should trigger a warning. Use cases include categorizing static analysis output and controlling message verbosity in command-line tools.",
      "description_length": 406,
      "index": 33,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Printable.ProdConf",
      "library": "goblint.common",
      "description": "Implements comparison, hashing, and serialization for product types combining two base types. Provides operations to check equality, format values as strings or XML, and generate arbitrary values for testing. Useful for structured data representations like configuration pairs or dual-component identifiers.",
      "description_length": 307,
      "index": 34,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Printable.Failwith",
      "library": "goblint.common",
      "description": "This module defines a type `t` that represents values which can be compared, hashed, and converted to human-readable or structured formats like strings, XML, and Yojson. It includes operations for equality checking, comparison, pretty-printing, and generating arbitrary values for testing. Concrete use cases include representing tagged, serializable data with a unique identifier, such as error messages or structured logs.",
      "description_length": 424,
      "index": 35,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MessageCategory.Cast",
      "library": "goblint.common",
      "description": "Handles conversions between string representations and typed categories for message classification. It supports creating typed categories from string lists, converting cast types to categories, and generating string paths from cast values. This module is used to ensure correct categorization of messages based on predefined type hierarchies.",
      "description_length": 342,
      "index": 36,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "CilType.Ikind",
      "library": "goblint.common",
      "description": "This module directly supports operations on integer kind types (`ikind`) from CIL, including equality checks, hashing, comparison, string conversion, and serialization to XML and JSON. It provides concrete utilities for pretty-printing, generating arbitrary values for testing, and managing unique identifiers for context-sensitive analysis. Use cases include type analysis in C programs, witness generation for verification, and integration with external tools requiring structured data formats.",
      "description_length": 496,
      "index": 37,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MyCFG.NodeH",
      "library": "goblint.common",
      "description": "This module provides imperative and functional operations for mapping control-flow graph nodes to arbitrary values, supporting key-based existence checks, value transformations, and in-place modifications. It includes utilities for converting between hash tables and lists/sequences, as well as safe access patterns and label management for structured analysis. The structure is particularly suited for static analysis tasks like dataflow analysis or program property propagation, where node-centric data mapping is critical.",
      "description_length": 525,
      "index": 38,
      "embedding_norm": 1.0
    },
    {
      "module_path": "IntOps.BigIntOps",
      "library": "goblint.common",
      "description": "This module offers arithmetic, bitwise, and comparison operations for arbitrary-precision integers, supporting operations like GCD computation, modular arithmetic, bit shifting, and logical operations (AND/OR/XOR/NOT). It works with a wrapped type representing big integers, enabling conversions to and from native integers, strings, and structured formats like JSON or XML. These capabilities are particularly useful in cryptographic algorithms requiring precise large integer manipulation, numerical libraries handling unbounded values, or systems needing robust serialization of numeric data.",
      "description_length": 595,
      "index": 39,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Printable.LiftTop",
      "library": "goblint.common",
      "description": "This module defines a type `t` that represents either a lifted value of type `Base.t` or a distinguished `Top` element. It provides operations to compare, hash, and convert these values, along with functions to lift and relift values into and within this structure. Concrete use cases include modeling partial or optional values with a distinguished top element, enabling precise equality checks, ordering, and serialization for lifted types.",
      "description_length": 442,
      "index": 40,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Printable.HConsed",
      "library": "goblint.common",
      "description": "This module implements hash-consing for structured values, ensuring efficient storage and fast equality checks by maintaining a canonical representation for each unique value. It works with hash-consed objects of type `BatHashcons.hobj` and their underlying key types, supporting operations like `lift`, `unlift`, and `relift` to convert between representations, and provides specialized functions for comparison, hashing, serialization, and pretty-printing. Concrete use cases include optimizing memory usage and equality testing for large collections of immutable data such as abstract syntax trees or symbolic expressions.",
      "description_length": 625,
      "index": 41,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Printable.Z",
      "library": "goblint.common",
      "description": "This module implements equality, comparison, and serialization operations for arbitrary-precision integers. It provides functions for converting values to strings, XML, and JSON, along with hashing, pretty-printing, and generating arbitrary test values. It supports use cases like symbolic computation, program analysis, and data serialization where precise integer handling and external representation are required.",
      "description_length": 416,
      "index": 42,
      "embedding_norm": 1.0
    },
    {
      "module_path": "UpdateCil0.NodeMap",
      "library": "goblint.common",
      "description": "This module implements a hash table with `Node0.t` keys and polymorphic values, offering imperative operations like insertion, deletion, traversal, and batch updates from sequences. It manages mappings between nodes and arbitrary data, supporting efficient bulk initialization or modification of entries through sequential key-value pairs. Typical applications include processing node-centric data structures where dynamic associations and iterative transformations are required, such as dependency tracking or graph attribute management.",
      "description_length": 538,
      "index": 43,
      "embedding_norm": 1.0
    },
    {
      "module_path": "IntOps.BigIntOpsBase",
      "library": "goblint.common",
      "description": "This module supports arithmetic and bitwise operations on arbitrary-precision integers, represented by the unbounded type `t` (Zarith's `Z.t`), including addition, multiplication, division, modulus, bitwise logic, and shifting. It provides comparison operators, conversions to and from native integers and strings, and utilities for handling values exceeding machine-word limits. Such functionality is essential for domains requiring exact arithmetic on very large numbers, such as cryptographic algorithms or precise financial calculations.",
      "description_length": 541,
      "index": 44,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CilType.Attrparam",
      "library": "goblint.common",
      "description": "Handles attribute parameters in CIL type representations, providing equality checks, hashing, comparison, and serialization to string and XML formats. Works with `GoblintCil.attrparam` values, supporting operations like pretty-printing, JSON conversion, and generating arbitrary values for testing. Useful for analyzing or transforming C code attributes during static analysis or code generation tasks.",
      "description_length": 402,
      "index": 45,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Printable.SimpleFormat",
      "library": "goblint.common",
      "description": "This module implements string conversion, pretty-printing, XML output, and JSON serialization for values of type `P.t`. It provides `show` for human-readable strings, `pretty` for structured document formatting, `printXml` for XML serialization, and `to_yojson` for JSON representation. Useful for logging, debugging, and data interchange where structured output is required.",
      "description_length": 375,
      "index": 46,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CilType.Varinfo",
      "library": "goblint.common",
      "description": "This module provides operations for comparing, hashing, and pretty-printing CIL variable information, including functions to retrieve unique identifiers, serialize to JSON, and generate arbitrary values for testing. It works directly with `GoblintCil.varinfo` values, which represent variables in the C Intermediate Language. Concrete use cases include tracking variable identities during analysis, logging variables in a human-readable format, and supporting serialization for inter-process communication or storage.",
      "description_length": 517,
      "index": 47,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Basetype.RawStrings",
      "library": "goblint.common",
      "description": "This module implements operations for handling raw string values with support for equality checks, hashing, comparison, and conversion to various output formats like JSON, XML, and pretty-printed documents. It works directly with the `string` type, providing functions for serialization, arbitrary value generation, and context identification via unique tags. Concrete use cases include managing string-based identifiers, normalizing string inputs, and supporting witness generation in testing frameworks.",
      "description_length": 505,
      "index": 48,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CilType.Encoding",
      "library": "goblint.common",
      "description": "This module defines operations for encoding and comparing CIL type representations, including serialization to strings, XML, and JSON, as well as generating unique identifiers and hash values. It works directly with the `GoblintCil.encoding` type, supporting equality checks, ordering, and pretty-printing. Concrete use cases include type comparison for analysis consistency, serializing type information for logging or external output, and generating stable identifiers for context tracking in witness generation.",
      "description_length": 514,
      "index": 49,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Basetype.CilExp",
      "library": "goblint.common",
      "description": "This module provides operations for manipulating and analyzing CIL expressions, including variable occurrence checks, substitution, and extraction of variable lists. It supports concrete tasks like replacing variables within expressions, identifying unique expression identifiers, and generating string or JSON representations. These functions are used in static analysis phases for tracking expression semantics and variable dependencies during program analysis.",
      "description_length": 463,
      "index": 50,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Printable.HashCached",
      "library": "goblint.common",
      "description": "This module wraps a printable type with lazy hashing, deferring hash computation until first needed and caching the result. It provides direct access to the underlying value, equality, comparison, and string representation, all while maintaining the lazy hash behavior. Concrete use cases include optimizing performance in hash tables or persistent data structures where hash computation is expensive.",
      "description_length": 401,
      "index": 51,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LazyEval.Make",
      "library": "goblint.common",
      "description": "Implements lazy evaluation for a given module's values, computing results only when forced. Works with any data type through the parameterized module's `t` and `result` types. Use to defer expensive computations until necessary, ensuring values are evaluated at most once.",
      "description_length": 272,
      "index": 52,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MyCFG.CfgEdge",
      "library": "goblint.common",
      "description": "This module represents control-flow graph edges as tuples of source nodes, edge types, and destination nodes. It provides equality and hashing operations for these edges, enabling use in sets and maps. Concrete use cases include tracking branch instructions and analyzing control flow between nodes in a CFG.",
      "description_length": 308,
      "index": 53,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Messages.MultiPiece",
      "library": "goblint.common",
      "description": "Handles structured messages composed of single pieces or groups with associated text, location, and multiple message pieces. Supports serialization to and from JSON, equality checks, comparison, and hashing for efficient storage and transmission. Used to organize and manage multi-part diagnostic messages like warnings with precise source locations and structured data.",
      "description_length": 370,
      "index": 54,
      "embedding_norm": 1.0
    },
    {
      "module_path": "IntOps.Int64Ops",
      "library": "goblint.common",
      "description": "This module provides arithmetic, bitwise, and comparison operations for 64-bit integers, including addition, multiplication, shifts, logical operations, and GCD computation. It supports conversions between 64-bit integers and types like strings, OCaml's native `int`/`int64`, and arbitrary-precision integers (`Z.t`), along with utilities for pretty-printing, XML serialization, and arbitrary value generation. It is useful in systems requiring precise numeric manipulation, such as cryptographic algorithms, low-level system programming, or data format conversions where 64-bit precision is critical.",
      "description_length": 601,
      "index": 55,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Timing.Default",
      "library": "goblint.common",
      "description": "This module tracks hierarchical timing information for nested computations, supporting start, stop, and reset operations. It measures execution time within named sections using enter and exit, or wraps functions to automatically time their execution. The timing data is structured as a tree and can be printed to visualize the hierarchy of timed sections.",
      "description_length": 355,
      "index": 56,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LoopUnrolling0.CopyOfHashTable",
      "library": "goblint.common",
      "description": "This module implements imperative hash tables with `GoblintCil.stmt` keys and polymorphic values, supporting standard operations like insertion, lookup, iteration, and in-place transformations via filtering and folding. It extends functionality to sequence-driven workflows, enabling bulk population or modification of tables using key-value sequences. Designed for loop unrolling analysis, it facilitates tracking statement-associated data and efficient updates from sequential collections of analysis results.",
      "description_length": 511,
      "index": 57,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CilType.Lval",
      "library": "goblint.common",
      "description": "This module provides operations for comparing, hashing, and converting CIL lvalue representations to strings or JSON. It supports data types used in CIL's abstract syntax tree, particularly for tracking memory locations and variables. Concrete use cases include equality checks between lvalues, generating string representations for debugging, and serializing lvalues for external output or analysis.",
      "description_length": 400,
      "index": 58,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Printable.Std",
      "library": "goblint.common",
      "description": "This module provides placeholder implementations for tagging values and generating arbitrary values. It works with any type, producing values without specific structure or meaning. Useful for testing interfaces or stubbing out components during development.",
      "description_length": 257,
      "index": 59,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "CilType.Stmt",
      "library": "goblint.common",
      "description": "This module provides operations for comparing, hashing, and serializing CIL statements, including equality checks, string and XML representations, and JSON conversion. It works with `GoblintCil.stmt` values, which represent statements in CIL (C Intermediate Language). Concrete use cases include normalizing and diffing CIL code, generating unique identifiers for statements, and supporting analysis tools that require structured representations of C code.",
      "description_length": 456,
      "index": 60,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Timing.Program",
      "library": "goblint.common",
      "description": "This module tracks execution time within nested program sections, enabling precise profiling of function calls and code blocks. It supports starting, stopping, and resetting global timing, as well as entering and exiting named timed sections or wrapping functions to measure their execution. Use cases include performance analysis of compiler passes, benchmarking specific computations, and generating hierarchical timing reports.",
      "description_length": 430,
      "index": 61,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CfgTools.SCC",
      "library": "goblint.common",
      "description": "This module represents and manipulates strongly connected components (SCCs) in a control flow graph. It stores nodes and tracks inter-component edges using hash tables, enabling efficient updates and lookups during SCC computation. Concrete use cases include identifying loops and analyzing control flow dependencies in program analysis tasks.",
      "description_length": 343,
      "index": 62,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Printable.SimpleShow",
      "library": "goblint.common",
      "description": "This module provides functions to format and output values as pretty-printed documents, XML, or Yojson strings. It operates on values of type `P.t`, leveraging the `Pretty` module for structured formatting and standard output mechanisms. Concrete use cases include generating human-readable logs, serializing data to XML streams, or converting values to JSON for inter-process communication.",
      "description_length": 391,
      "index": 63,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Messages.Message",
      "library": "goblint.common",
      "description": "Handles structured messages with tags, severity levels, and multipiece content. Provides serialization to and from JSON, equality checks, comparison, and hashing for message instances. Used to represent and manipulate user-facing analysis warnings or notifications with structured metadata.",
      "description_length": 290,
      "index": 64,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "IntOps.IntOpsDecorator",
      "library": "goblint.common",
      "description": "This module provides arithmetic operations (addition, multiplication, division, modulus, GCD), bitwise manipulations (shifts, AND, OR, XOR, NOT), and logical operations (AND, OR, XOR, NOT) for a custom integer type `t`. It supports conversions between `t` and standard integer types (`int`, `int64`, `Z.t`), string representations, and serialization formats (XML, Yojson), while enabling comparison, hashing, and arbitrary value generation. Use cases include numeric computation, data serialization, and cross-type interoperability in contexts requiring precise integer manipulation.",
      "description_length": 583,
      "index": 65,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Printable.EitherConf",
      "library": "goblint.common",
      "description": "This module defines a sum type with `Left` and `Right` constructors wrapping values of types `Base1.t` and `Base2.t`. It provides comparison, hashing, and conversion to string, XML, and Yojson for structured data representation. It supports use cases like handling dual-type results or tagged unions in configuration or serialization contexts.",
      "description_length": 343,
      "index": 66,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Printable.Either3",
      "library": "goblint.common",
      "description": "This module defines a sum type with three possible values, each wrapping a distinct type, and provides operations for comparison, hashing, pretty-printing, and serialization to XML and JSON. It supports concrete use cases like representing tri-state values, handling multiple result types from computations, and structured logging or serialization of heterogeneous data. Functions include equality checks, pretty-printing with formatting, and converting values to standard representations like strings or JSON.",
      "description_length": 510,
      "index": 67,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Cilfacade.VarinfoH",
      "library": "goblint.common",
      "description": "This module implements a hash table for mapping CIL variable descriptors to arbitrary values, supporting imperative operations like insertion, lookup, and in-place updates alongside bulk initialization from key-value sequences. It specializes in handling variable-centric data associations, enabling efficient management of metadata or analysis results tied to program variables. Applications include tracking variable lifetimes, type annotations, or analysis-specific properties during static analysis workflows.",
      "description_length": 513,
      "index": 68,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Printable.StdLeaf",
      "library": "goblint.common",
      "description": "This module provides minimal default implementations for leaf types that do not contain nested structures requiring relifting. It includes operations for tagging values, generating arbitrary values, and identity relifting, specifically targeting primitive and CIL types. Use this module when defining printables for simple types like integers, booleans, or low-level CIL constructs.",
      "description_length": 382,
      "index": 69,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Messages.Tag",
      "library": "goblint.common",
      "description": "This module defines operations for handling tags associated with messages, such as categories and CWE identifiers. It supports equality checks, comparison, hashing, pretty-printing, and JSON serialization/deserialization. These functions are used to manage and persist message metadata, particularly for analysis warnings.",
      "description_length": 322,
      "index": 70,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CilType.Fundec",
      "library": "goblint.common",
      "description": "This module provides operations for comparing, hashing, and serializing function definitions, specifically working with `GoblintCil.fundec` values. It supports concrete use cases such as tracking function identity via unique tags, pretty-printing for debugging, and generating JSON representations for external consumption. Functions like `equal`, `compare`, and `arbitrary` enable use in sets, maps, and property-based testing.",
      "description_length": 428,
      "index": 71,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Printable.PrefixName",
      "library": "goblint.common",
      "description": "This module implements comparison, hashing, and serialization operations for a type `t` derived from `Base.t`, including pretty-printing, XML output, and QCheck arbitraries. It works with types that support equality, ordering, and conversion to strings, such as symbols or identifiers. Concrete use cases include generating readable representations of abstract syntax elements and supporting testing through arbitrary value generation.",
      "description_length": 435,
      "index": 72,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Messages.Piece",
      "library": "goblint.common",
      "description": "This module defines a data structure for representing individual messages, such as warnings, with optional location information, text content, and contextual data. It provides operations for comparing, hashing, and serializing message instances to and from JSON, using `Yojson`. The module supports concrete use cases like logging analysis results with structured context or transmitting diagnostic messages between systems.",
      "description_length": 424,
      "index": 73,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "CilType.Attributes",
      "library": "goblint.common",
      "description": "This module provides operations for comparing, hashing, and serializing CIL attributes, including functions for equality checks, string representation, XML and JSON output, and generating arbitrary values for testing. It works with the `attributes` type, which represents structured metadata in CIL. Concrete use cases include attribute manipulation during CIL analysis, serialization for storage or communication, and generating test cases for attribute handling.",
      "description_length": 464,
      "index": 74,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Printable.Either",
      "library": "goblint.common",
      "description": "This module implements a sum type with two tagged variants, supporting equality checks, ordering, and string/XML/JSON output. It works with two distinct data types encapsulated as `Left` and `Right`, each drawn from the provided base modules. Useful for representing dual-result computations, such as parsing alternatives or error/value outcomes.",
      "description_length": 346,
      "index": 75,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CilType.Fkind",
      "library": "goblint.common",
      "description": "This module provides operations for comparing, hashing, and serializing function kind values from the CIL library. It supports concrete use cases like checking equality of function types, generating unique identifiers for context-sensitive analysis, and converting values to human-readable or machine-exchangeable formats such as JSON and XML. The data type it works with is `GoblintCil.fkind`, primarily used in static analysis to represent function type information.",
      "description_length": 468,
      "index": 76,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CilType.Typ",
      "library": "goblint.common",
      "description": "This module provides operations for comparing, hashing, and pretty-printing CIL type representations, including serialization to JSON and XML. It works directly with `GoblintCil.typ` values, which represent CIL types with structural equivalence. Concrete use cases include type equality checks in analysis, generating human-readable type representations for debugging, and persisting type information in external formats.",
      "description_length": 421,
      "index": 77,
      "embedding_norm": 1.0
    },
    {
      "module_path": "IntOps.Int32Ops",
      "library": "goblint.common",
      "description": "This module provides arithmetic operations (addition, multiplication, division with remainder, GCD), bitwise manipulations (shifts, AND/OR/XOR/NOT), and comparison functions (equality, ordering) for 32-bit integers. It operates on 32-bit integer values and supports conversions to and from strings, integers of different widths (e.g",
      "description_length": 332,
      "index": 78,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CilType.Std",
      "library": "goblint.common",
      "description": "Handles transformations and representations of CIL type expressions. Provides functions to tag, lift, and generate arbitrary CIL types for analysis and manipulation tasks. Useful in static analysis tools for extracting and processing type information from CIL code.",
      "description_length": 265,
      "index": 79,
      "embedding_norm": 1.0
    },
    {
      "module_path": "RichVarinfo.BiVarinfoMap",
      "library": "goblint.common",
      "description": "Implements bidirectional mappings between a custom type `t` and `GoblintCil.varinfo`, supporting lookup, conversion, and serialization. Maintains a registry for retrieving either the custom value or corresponding variable info, along with generating descriptive strings for debugging. Used to track extended variable metadata across CIL transformations and persist analysis state tied to specific variables.",
      "description_length": 407,
      "index": 80,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "MessageCategory.Integer",
      "library": "goblint.common",
      "description": "This module handles integer-specific message categories, providing operations to create categories from integer values and predefined categories for overflow and division-by-zero errors. It works with integer values and string lists, converting between them and category types. Use cases include handling arithmetic error conditions and serializing integer paths for logging or debugging.",
      "description_length": 388,
      "index": 81,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Printable.Either3Conf",
      "library": "goblint.common",
      "description": "This module defines a sum type with three possible values, each wrapping a distinct type, supporting equality checks, comparison, and pretty-printing. It provides operations to convert values to strings, XML, or Yojson, and includes hash and arbitrary value generation for testing. Useful for representing tri-state values like parsing outcomes with distinct error, warning, and success cases.",
      "description_length": 393,
      "index": 82,
      "embedding_norm": 1.0
    },
    {
      "module_path": "FloatOps.CFloat",
      "library": "goblint.common",
      "description": "This module offers precise floating-point arithmetic, mathematical functions, and configurable rounding modes for operations like addition, square root, and trigonometric calculations. It operates on a concrete float type, supporting conversions to and from big integers, JSON, and strings, enabling applications requiring strict numerical control such as financial computations or scientific simulations. Key features include equality checks, comparisons, and hashing for reliable numerical analysis.",
      "description_length": 501,
      "index": 83,
      "embedding_norm": 1.0
    },
    {
      "module_path": "IntOps.NIntOps",
      "library": "goblint.common",
      "description": "This module provides arithmetic, bitwise, and logical operations on a wrapped integer representation, supporting operations like addition, multiplication, shifts, XOR, comparisons, and boolean logic (e.g., negation, conjunction) that return the same integer type. It works with an abstract type `t` that encapsulates integers, offering conversions to and from native integers, strings, and other representations, alongside utilities for bounds, absolute values, and serialization. Use cases include low-level bit manipulation, arithmetic-heavy computations, and scenarios requiring unified integer handling with customizable type conversions or logical operations expressed as integer values.",
      "description_length": 692,
      "index": 84,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Printable.Unit",
      "library": "goblint.common",
      "description": "This module implements equality, comparison, and pretty-printing operations for the unit type, enabling structured output and testing. It provides functions to convert unit values to strings, XML, and Yojson, along with utilities for QCheck property testing. Use cases include simplifying unit value handling in tests and output generation where unit is used to represent absence of data.",
      "description_length": 388,
      "index": 85,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Printable.Liszt",
      "library": "goblint.common",
      "description": "This module implements operations for working with lists of comparable and outputtable elements, supporting equality checks, comparison, and serialization to JSON. It provides utilities for string and XML formatting, prefix/suffix analysis, and pretty-printing of lists. Concrete use cases include structured data logging, list differencing, and generating human-readable output for list-based computations.",
      "description_length": 407,
      "index": 86,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CilType.Constant",
      "library": "goblint.common",
      "description": "This module implements operations for comparing, printing, and serializing CIL constants, including equality checks, hashing, string conversion, and XML and JSON output. It works directly with the `GoblintCil.constant` type, providing support for structured logging, testing via QCheck, and integration with analysis tools requiring persistent or human-readable representations. Use cases include constant value tracking in static analysis and witness generation for verification tasks.",
      "description_length": 486,
      "index": 87,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Messages.Table",
      "library": "goblint.common",
      "description": "This module manages a mutable collection of analysis messages using imperative operations for insertion, membership testing, and traversal. It associates `Messages.Message.t` keys with arbitrary data through a hash table, supporting use cases like tracking unique warnings, aggregating diagnostic metadata, or maintaining a dynamic list of emitted messages during static analysis. Key operations include adding messages with optional hooks, checking existence, and converting the collection to lists or JSON for reporting.",
      "description_length": 522,
      "index": 88,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Printable.SimplePretty",
      "library": "goblint.common",
      "description": "This module implements string conversion, XML printing, and Yojson serialization for values of type `P.t`. It provides `show` for human-readable strings, `printXml` for structured XML output, and `to_yojson` for JSON-compatible representations. Useful for logging, configuration, or data interchange scenarios where structured and readable formats are required.",
      "description_length": 361,
      "index": 89,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cilfacade.FunLocH",
      "library": "goblint.common",
      "description": "This module offers imperative hash table operations for associating CIL function definitions (`Fundec.t`) with arbitrary values, supporting efficient lookups, modifications, and bulk initialization from sequences. It facilitates tasks like tracking function-specific metadata or analysis results during CIL processing, with utilities for filtering and summarizing table contents. Use cases include static analysis passes requiring persistent mappings between functions and computed properties, such as alias analysis or optimization flags.",
      "description_length": 539,
      "index": 90,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Printable.Option",
      "library": "goblint.common",
      "description": "This module implements equality, comparison, and pretty-printing for optional values, allowing them to be displayed as strings, XML, or Yojson. It operates on `Base.t option` values, providing concrete operations like `show`, `printXml`, and `to_yojson` for serialization. Use it to format and compare optional data structures in logs, configuration handling, or data export workflows.",
      "description_length": 385,
      "index": 91,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Messages.Tags",
      "library": "goblint.common",
      "description": "Handles operations for comparing, serializing, and formatting lists of message tags. Works with `Messages.Tag.t` lists, providing equality checks, JSON conversion with Yojson, pretty-printing, and warning evaluation. Used to manage tag-based filtering or categorization of analysis messages presented to users.",
      "description_length": 310,
      "index": 92,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cilfacade.IntH",
      "library": "goblint.common",
      "description": "This module implements a hash table with integer keys and arbitrary value types, supporting imperative operations like insertion, deletion, lookup, iteration, folding, and in-place updates. It enables bulk manipulation through sequence-based functions for adding or replacing multiple entries and constructing tables from sequences, facilitating efficient initialization or transformation of integer-indexed data collections. Such capabilities are particularly useful for managing large datasets or performing batch operations on integer-keyed mappings.",
      "description_length": 553,
      "index": 93,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Messages.Location",
      "library": "goblint.common",
      "description": "This module represents and manipulates source code locations for warnings and messages in program analysis. It supports two forms of locations\u2014node-based and CIL-based\u2014and provides conversions to and from CIL locations and JSON representations. It is used to accurately track and report the origin of analysis results within the source code.",
      "description_length": 341,
      "index": 94,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Basetype.CilStmt",
      "library": "goblint.common",
      "description": "This module directly supports operations on CIL statements, including equality checks, hashing, comparison, and string representation. It provides functionalities for pretty-printing, XML serialization, and generating arbitrary instances for testing. Concrete use cases include statement analysis, transformation passes, and witness generation in a CIL-based static analysis framework.",
      "description_length": 385,
      "index": 95,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CilType.Unop",
      "library": "goblint.common",
      "description": "This module represents and manipulates unary operations in CIL (C Intermediate Language), such as logical negation, bitwise negation, and address-of. It provides operations to compare, hash, and serialize these unary operators, along with utilities for pretty printing and XML output. Concrete use cases include analysis and transformation of C code in static analysis tools like Goblint.",
      "description_length": 388,
      "index": 96,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CilType.Typsig",
      "library": "goblint.common",
      "description": "This module provides operations for comparing, hashing, and converting CIL type signatures to strings or XML. It supports data types used in CIL (C Intermediate Language) for representing type information, such as function types and composite types. Concrete use cases include type equality checks during analysis, generating unique identifiers for types, and serializing types for logging or external representation.",
      "description_length": 417,
      "index": 97,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cilfacade.StringH",
      "library": "goblint.common",
      "description": "This module implements a hash table for efficient key-value storage and retrieval using `Printable.Strings.t` as keys, offering standard operations like insertion, lookup, deletion, and in-place updates, along with traversal via iteration and folding. It supports bulk manipulation through sequence-based additions, replacements, and table construction, enabling streamlined data population from iterable sources. Use cases include managing dynamic string-keyed data with high-performance access patterns, tracking string-based identifiers with associated metadata, and scenarios requiring bulk initialization or transformation of hash tables.",
      "description_length": 643,
      "index": 98,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Printable.PQueue",
      "library": "goblint.common",
      "description": "Implements a priority queue with elements ordered by a base type's comparison function. Provides operations to insert, remove, and retrieve elements while maintaining priority order. Supports concrete use cases like task scheduling, event processing, and resource allocation where prioritization is essential.",
      "description_length": 309,
      "index": 99,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CilType.Enuminfo",
      "library": "goblint.common",
      "description": "Handles enumeration information with operations for equality, hashing, comparison, and serialization. Works with `GoblintCil.enuminfo` type, which represents CIL enumeration data. Used for managing and manipulating enum definitions and their associated values in CIL-based analyses.",
      "description_length": 282,
      "index": 100,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Printable.DefaultConf",
      "library": "goblint.common",
      "description": "Defines default configuration parameters for printable elements, including names for bottom and top values and expansion flags. It provides boolean flags to control output behavior at different levels. Used to standardize print settings across data structures like sets, maps, and lattices.",
      "description_length": 290,
      "index": 101,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Printable.UnitConf",
      "library": "goblint.common",
      "description": "This module defines operations for a unit type, including equality, comparison, hashing, and pretty-printing. It provides functions to convert values to strings, XML, and Yojson, along with QCheck arbitrary value generation. Use cases include representing empty or singleton values in configurations where only the presence or absence of a value matters, and serving as a placeholder in functors or combinators expecting a structured type.",
      "description_length": 439,
      "index": 102,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CilType.Compinfo",
      "library": "goblint.common",
      "description": "This module provides operations for comparing, hashing, and serializing CIL composite type information, including equality checks, string representations, and JSON/XML output. It works with the `compinfo` type, which represents structured CIL type definitions. Concrete use cases include tracking type identities in analysis, persisting type data for debugging, and generating human-readable or machine-parseable output for composite types.",
      "description_length": 440,
      "index": 103,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CilType.Fieldinfo",
      "library": "goblint.common",
      "description": "This module provides operations for comparing, hashing, and serializing CIL field information, including equality checks, string representation, and XML and JSON output. It works with the `GoblintCil.fieldinfo` type, which represents fields in CIL structures. Concrete use cases include tracking struct or union fields during analysis, identifying fields uniquely via tags, and generating readable or machine-readable output for debugging or external tools.",
      "description_length": 457,
      "index": 104,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Printable.Yojson",
      "library": "goblint.common",
      "description": "This module implements equality, comparison, and pretty-printing operations for Yojson values. It supports converting values to Yojson format, comparing and hashing them, and printing in both plain and XML formats. Concrete use cases include serializing and displaying structured data in JSON format, such as configuration values or intermediate representations.",
      "description_length": 362,
      "index": 105,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Printable.Strings",
      "library": "goblint.common",
      "description": "This module implements comparison, hashing, and serialization for strings, including JSON conversion, pretty-printing, and XML output. It supports concrete use cases like logging structured data, generating XML from string values, and building pretty-printed string representations. The module directly enhances strings with these operations without relying on external modules.",
      "description_length": 378,
      "index": 106,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "CilType.Offset",
      "library": "goblint.common",
      "description": "This module provides operations for comparing, hashing, and serializing CIL type offsets, including functions for generating unique IDs, pretty-printing, and converting to JSON. It works directly with `GoblintCil.offset` values, which represent field offsets in CIL types. Concrete use cases include tracking field positions during analysis and persisting offset information for inter-procedural context sensitivity.",
      "description_length": 416,
      "index": 107,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "RichVarinfo.Make",
      "library": "goblint.common",
      "description": "This module creates a customizable abstraction for managing `GoblintCil.varinfo` entries with support for marshaling and unmarshaling state. It provides operations to convert between custom data (`t`) and CIL variables, track variable bindings, and persist state across analyses. Concrete use cases include handling variable metadata during static analysis and enabling checkpointing of analysis results.",
      "description_length": 404,
      "index": 108,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "IntOps.NIntOpsBase",
      "library": "goblint.common",
      "description": "This module provides arithmetic operations (addition, multiplication, GCD), bitwise manipulations (AND, OR, shifting), comparisons (equality, ordering), and conversions between integer representations (strings, other numeric types) for a custom integer type `t` aliased to `int`. It supports numerical computations requiring precise bounds checks, data validation via range constraints, test-case generation, and bidirectional parsing/formatting for serialization or user-facing output.",
      "description_length": 486,
      "index": 109,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Printable.ProdSimple",
      "library": "goblint.common",
      "description": "Handles comparison, hashing, and string-based representation of pairs combining two distinct types. Provides operations like `equal`, `compare`, `show`, and `pretty` for structured output and testing, with support for XML and JSON serialization. Useful for composite data keys or combined values in sets and maps.",
      "description_length": 313,
      "index": 110,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Printable.LiftBot",
      "library": "goblint.common",
      "description": "This module defines a type `t` that represents either a bottom value (`Bot`) or a lifted value of a base type. It provides operations to compare, hash, and convert these values to strings or XML, along with utilities to lift and relift values. Concrete use cases include handling optional or extended values in a structured way, such as representing absent or transformed data in parsing or abstract interpretation tasks.",
      "description_length": 421,
      "index": 111,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Printable.Chain",
      "library": "goblint.common",
      "description": "This module implements a printable, hashable, and comparable integer type with support for pretty-printing, XML output, and Yojson serialization. It provides equality checks, arbitrary value generation for testing, and a unique tagging function for context identification. Concrete use cases include representing identifiers in a typed intermediate representation or tracking unique entities in a system requiring stable, serializable tags.",
      "description_length": 440,
      "index": 112,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Basetype.Variables",
      "library": "goblint.common",
      "description": "This module represents and manipulates variable information with operations for equality, hashing, comparison, and serialization. It works with `GoblintCil.varinfo` and a `group` type that categorizes variables into Global, Local, Parameter, or Temp. It supports use cases like variable comparison, grouping variables by scope, and generating unique identifiers or string representations for analysis and reporting.",
      "description_length": 415,
      "index": 113,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "CilType.Location",
      "library": "goblint.common",
      "description": "This module provides operations for comparing, hashing, and serializing location values, including functions like `equal`, `hash`, `compare`, and `to_yojson`. It works with the `t` type, which represents locations in the CIL abstract syntax tree. Concrete use cases include tracking source code positions during analysis and persisting location data in XML or JSON formats.",
      "description_length": 373,
      "index": 114,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MessageCategory.Behavior",
      "library": "goblint.common",
      "description": "This module directly constructs and classifies message categories tied to program behavior, using concrete types like `MessageCategory.behavior` and `MessageCategory.undefined_behavior`. It includes specific categories for implementation and machine behavior, with functions to build categories from undefined behavior types, string paths, or error lists. It is used to route diagnostics and classify runtime or static analysis errors with precision, such as identifying memory violations or undefined operations in compiled code.",
      "description_length": 530,
      "index": 115,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Printable.Prod",
      "library": "goblint.common",
      "description": "This module combines two printable types into a product type, enabling comparison, hashing, and string representation of pairs. It supports structured output through XML printing, pretty-printing, and JSON serialization, using the individual printers of each base type. Use it to create printable and comparable tuples where both components have defined printable behavior.",
      "description_length": 373,
      "index": 116,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Printable.Empty",
      "library": "goblint.common",
      "description": "This module represents an empty type with no inhabitants, used to model impossible cases or unreachable code branches. It provides comparison, hashing, and serialization functions that are vacuously defined, as no actual values of the type exist. Concrete use cases include serving as a placeholder in polymorphic data structures or signaling errors in exhaustive pattern matching.",
      "description_length": 381,
      "index": 117,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CilCfg0",
      "library": "goblint.common",
      "description": "Processes CIL files to identify and mark the last basic blocks in each function. Works with CIL's intermediate representation of C programs, specifically the `file` type. Useful for analyses requiring control flow graph information without full CFG construction.",
      "description_length": 262,
      "index": 118,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Messages",
      "library": "goblint.common",
      "description": "This module supports creating, managing, and outputting structured analysis messages with severity levels, source locations, tags, and contextual data, leveraging types like Message, Tag, and Location alongside Pretty.doc for formatted composition. It enables use cases such as static analysis warning reporting, diagnostic logging, and trace message management with features like subsystem-based filtering, indentation control, and JSON serialization. Operations also include dynamic message activation based on global state, location tracking, and runtime configuration of tracing subsystems.",
      "description_length": 594,
      "index": 119,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CfgTools",
      "library": "goblint.common",
      "description": "This module constructs, analyzes, and visualizes control flow graphs (CFGs) using node and edge types from `MyCFG`. It supports operations like computing strongly connected components (SCCs), minimizing CFGs, finding reachable nodes, and generating DOT and HTML representations of CFGs. Concrete use cases include program analysis tasks such as dead code detection, loop identification, and visualization of function control flow for debugging or reporting.",
      "description_length": 457,
      "index": 120,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Timing",
      "library": "goblint.common",
      "description": "Tracks hierarchical timing of computations with start/stop/reset operations, function wrapping, and named sections. Uses tree-structured timing data for detailed performance analysis and reporting. Useful for profiling compiler passes, benchmarking functions, and visualizing nested execution times.",
      "description_length": 299,
      "index": 121,
      "embedding_norm": 1.0
    },
    {
      "module_path": "AnalysisStateUtil",
      "library": "goblint.common",
      "description": "Handles memory safety violations by defining types for specific error categories and setting flags to track them. Works with the `mem_safety_violation` variant type to represent distinct memory errors such as invalid dereferences or frees. Used during static analysis to record and manage memory-related issues detected in code.",
      "description_length": 328,
      "index": 122,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MessageCategory",
      "library": "goblint.common",
      "description": "This module introduces polymorphic variant types for classifying program behaviors and errors, such as runtime issues, arithmetic anomalies, and type casting problems. It provides operations for structural comparison, hashing, and serialization of these categories, alongside submodules that organize error handling logic for specific domains like integer arithmetic and concurrency. These features support tasks like static analysis, error reporting, and semantic validation in compilers or runtime systems.",
      "description_length": 508,
      "index": 123,
      "embedding_norm": 1.0
    },
    {
      "module_path": "XmlUtil",
      "library": "goblint.common",
      "description": "Converts special characters in strings to their corresponding XML entities. Works with string data to ensure valid XML output. Useful for generating XML content from user input or dynamic data.",
      "description_length": 193,
      "index": 124,
      "embedding_norm": 1.0
    },
    {
      "module_path": "GobFormat",
      "library": "goblint.common",
      "description": "This module provides functions for formatting and pretty-printing values, including control over ANSI color tags and handling infinite output geometry. It works with format strings and formatters from the standard `Format` module to produce colored or unbounded output. Concrete use cases include generating colored terminal output, capturing formatted strings for logging, and printing values without bounds on line length or indentation.",
      "description_length": 439,
      "index": 125,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "LoopUnrolling0",
      "library": "goblint.common",
      "description": "Implements imperative hash tables mapping `GoblintCil.stmt` keys to optional keys, supporting insertion, lookup, and transformation. Provides direct access to copy and original statement mappings, enabling efficient tracking and resolution of duplicated loop body statements during analysis. Useful for maintaining and querying statement relationships from sequential analysis results.",
      "description_length": 385,
      "index": 126,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Cilfacade",
      "library": "goblint.common",
      "description": "This module provides utilities for manipulating and analyzing CIL abstract syntax trees, focusing on type inspection, location tracking, and control flow management. It operates on CIL constructs like statements, expressions, variables, and function definitions, enabling tasks such as type checking, attribute blending, and AST transformation. Specific applications include static analysis of variable scopes, merging ASTs during preprocessing, resolving function definitions, and handling complex control flow patterns like goto statements.",
      "description_length": 542,
      "index": 127,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CilType",
      "library": "goblint.common",
      "description": "This module offers utilities for type manipulation, structural comparison, and serialization of CIL constructs, focusing on operations like equality checks, hashing, and pretty-printing. It handles low-level CIL data types such as type expressions, lvalues, expressions, attributes, and their parameters, while supporting analysis-specific needs like tracking type properties and encoding information. These capabilities enable applications in static analysis frameworks, where precise type representation and transformation are critical for tasks like program verification and inter-procedural data flow tracking.",
      "description_length": 614,
      "index": 128,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Edge",
      "library": "goblint.common",
      "description": "This module defines the structure of control flow graph (CFG) edges representing program statements between program points. It includes operations for comparing, hashing, and converting edge data to JSON, supporting precise analysis of program behavior. Concrete use cases include tracking assignments, function calls, conditionals, and inline assembly during static analysis.",
      "description_length": 376,
      "index": 129,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MyCFG",
      "library": "goblint.common",
      "description": "This module implements a control-flow graph (CFG) representation with nodes representing statements and functions, and edges modeling control transfers, assignments, and procedure calls. It provides operations for comparing and hashing edges, mapping edges to values, and traversing the graph bidirectionally. Concrete use cases include static analysis tasks such as tracking variable assignments, analyzing function call sequences, and performing dataflow analysis across control-flow paths.",
      "description_length": 492,
      "index": 130,
      "embedding_norm": 1.0
    },
    {
      "module_path": "AnalysisState",
      "library": "goblint.common",
      "description": "This module manages global state flags used during program analysis to track conditions like overflows, memory errors, and termination. It provides mutable references to boolean and optional boolean values that are updated during analysis phases. These flags control warning generation, speculative computation handling, and verification outcomes in static analysis workflows.",
      "description_length": 376,
      "index": 131,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "ContextUtil",
      "library": "goblint.common",
      "description": "This module handles Goblint-specific C attributes and options for controlling analysis behavior. It provides functions to check for the presence of attributes or options in function declarations, and to determine whether specific analysis features should be enabled or disabled based on those attributes. Concrete use cases include controlling context sensitivity and integer domain precision on a per-function basis during static analysis.",
      "description_length": 440,
      "index": 132,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "MessageUtil",
      "library": "goblint.common",
      "description": "Determines if colors should be enabled for a given file descriptor and applies color formatting to strings based on terminal support. Works with file descriptors and strings, using ANSI escape codes for coloring. Useful for enhancing terminal output readability, such as highlighting log levels or errors in command-line tools.",
      "description_length": 327,
      "index": 133,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LazyEval",
      "library": "goblint.common",
      "description": "Implements lazy evaluation for values of any type, deferring computation until forced and ensuring evaluation happens only once. Useful for delaying expensive operations like file parsing or network requests until their results are actually needed. Works transparently with any data type through a parameterized module interface.",
      "description_length": 329,
      "index": 134,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CilLocation",
      "library": "goblint.common",
      "description": "This module provides functions to retrieve precise source code locations for CIL labels, instructions, and statements, returning both the primary and expression locations. It operates on CIL AST elements such as `label`, `instr`, and `stmt`, extracting detailed positional information. It is used to track exact source positions during analysis or transformation passes in Goblint.",
      "description_length": 381,
      "index": 135,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Cilfacade0",
      "library": "goblint.common",
      "description": "This module provides functions to retrieve expression-specific locations from CIL constructs such as labels, instructions, and statements. It works with data types like `GoblintCil.label`, `GoblintCil.instr`, and `GoblintCil.stmt`, focusing on precise location tracking for expressions. Concrete use cases include improving accuracy in static analysis by distinguishing expression locations from broader statement locations.",
      "description_length": 424,
      "index": 136,
      "embedding_norm": 1.0
    },
    {
      "module_path": "FloatOps",
      "library": "goblint.common",
      "description": "This module provides precise floating-point arithmetic, mathematical functions, and configurable rounding modes for operations like addition, square root, and trigonometric calculations. It operates on concrete float types, supporting conversions to and from big integers, JSON, and strings. Use it for applications requiring strict numerical control such as financial computations or scientific simulations.",
      "description_length": 408,
      "index": 137,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "ResettableLazy",
      "library": "goblint.common",
      "description": "This module implements a lazy value that can be reinitialized with a new computation. It supports creating a lazy value from a function, forcing evaluation, and resetting the value to use a new closure. It is useful for scenarios like memoization with controlled recomputation or managing stateful lazy values that need periodic refreshing.",
      "description_length": 340,
      "index": 138,
      "embedding_norm": 1.0
    },
    {
      "module_path": "RichVarinfo",
      "library": "goblint.common",
      "description": "This module manages `GoblintCil.varinfo` entries with support for marshaling, unmarshaling, and bidirectional mappings to custom data types. It provides functions to create and manipulate variable bindings, track metadata, and persist analysis state tied to CIL variables. Concrete use cases include handling extended variable information during static analysis and enabling checkpointing across analysis phases.",
      "description_length": 412,
      "index": 139,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Basetype",
      "library": "goblint.common",
      "description": "This module implements foundational operations for handling variables, raw strings, CIL expressions, and CIL statements. It supports precise equality, hashing, comparison, and serialization for types like `GoblintCil.varinfo`, `string`, and CIL AST nodes, with use cases including static analysis, variable grouping, expression substitution, and test witness generation. Specific functions enable variable scope analysis, string normalization, expression manipulation, and statement transformation within program analysis workflows.",
      "description_length": 532,
      "index": 140,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ControlSpecC",
      "library": "goblint.common",
      "description": "This module provides operations to manage and manipulate a top-level context for control specifications, including equality checks, hashing, comparison, and serialization. It works with the abstract type `t` representing control specification contexts, supporting concrete use cases like tracking unique identifiers for context identification and lifting context values across analyses. Functions enable pretty-printing, XML output, and integration with testing frameworks for structured validation.",
      "description_length": 499,
      "index": 141,
      "embedding_norm": 1.0
    },
    {
      "module_path": "IntOps",
      "library": "goblint.common",
      "description": "This module implements arithmetic, bitwise, and comparison operations for various integer types, including fixed-width integers (32-bit, 64-bit) and arbitrary-precision integers (using Zarith's `Z.t`). It supports conversions between these types, string parsing and formatting, and provides operations such as addition, multiplication, GCD, bitwise shifts, and logical operations. Concrete use cases include cryptographic computations, serialization of numeric data to JSON or XML, and arithmetic-heavy systems requiring precise control over integer behavior and representation.",
      "description_length": 578,
      "index": 142,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Printable",
      "library": "goblint.common",
      "description": "This module provides type classes and modules for pretty-printing, structured serialization (XML, JSON), equality, comparison, and hashing, targeting data types such as primitives, unit types, hash-consed structures, and lazy hashed values. It supports structured data handling through components like priority queues, enhanced lists, and optional/top values, enabling applications in task scheduling, data logging, abstract interpretation, and configuration management with serializable types like Yojson.",
      "description_length": 506,
      "index": 143,
      "embedding_norm": 1.0
    },
    {
      "module_path": "UpdateCil0",
      "library": "goblint.common",
      "description": "This module provides a mutable hash table for mapping `Node0.t` keys to location values, with operations for initialization, insertion, and retrieval. It works with node and location data types to associate source code locations with nodes. Used for tracking and updating node locations during analysis, supporting efficient bulk modifications and lookups.",
      "description_length": 356,
      "index": 144,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Node0",
      "library": "goblint.common",
      "description": "This module defines a polymorphic type `t` representing nodes in a control flow graph, specifically statements and functions from CIL. It provides operations for equality, comparison, hashing, and JSON serialization, along with extracting source code locations from nodes. Concrete use cases include tracking control flow between statements and function entries, and serializing nodes for analysis or logging.",
      "description_length": 409,
      "index": 145,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_logs.Logs.Batteries",
      "library": "goblint.logs",
      "description": "This module provides formatted logging operations at different severity levels such as debug, info, warn, error, and result, all accepting format strings for structured output. It works with standard format types and unit values, enabling precise control over log messages. Concrete use cases include tracking execution flow, reporting analysis progress, and emitting diagnostic messages during static analysis runs.",
      "description_length": 416,
      "index": 146,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_logs.Logs.MakeKind",
      "library": "goblint.logs",
      "description": "This module provides logging functions at various severity levels (debug, info, warn, error) that accept formatted messages tied to a specific kind. It works with the `Level.t` type for severity and leverages `Stdlib.format4` for type-safe formatted output. Concrete use cases include emitting diagnostic messages during static analysis, such as reporting potential issues, progress updates, or unexpected conditions tied to a specific analysis phase or component.",
      "description_length": 464,
      "index": 147,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_logs.Logs.FormatKind",
      "library": "goblint.logs",
      "description": "Handles logging with formatted output using OCaml's `Format.formatter`. Provides a `log` function that takes a log level and a format string, enabling type-safe formatted logging messages. Useful for emitting structured log entries during static analysis runs.",
      "description_length": 260,
      "index": 148,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_logs.Logs.Result",
      "library": "goblint.logs",
      "description": "Handles logging operations with support for result types, enabling error tracking and message accumulation. Works with `result` values and string-based log messages. Useful for debugging and tracing computations that may fail, where detailed diagnostic information needs to be captured and conditionally output based on configuration.",
      "description_length": 334,
      "index": 149,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_logs.Logs.Pretty",
      "library": "goblint.logs",
      "description": "This module provides functions for formatted logging with support for pretty-printing structured data, such as CIL documents. It includes level-specific output functions like `debug`, `info`, `warn`, and `error`, which accept format strings and values to log. The `result` function specifically formats and logs analysis results using CIL's pretty-printing infrastructure.",
      "description_length": 372,
      "index": 150,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_logs.Logs.Level",
      "library": "goblint.logs",
      "description": "This module defines a set of severity levels for logging\u2014Debug, Info, Warning, Error, and Result\u2014and provides operations to compare, convert, and manipulate these levels. It includes functions to hash, print, and serialize levels, as well as utilities to check if a level should be logged based on the current setting. Use cases include filtering log output during static analysis and representing log message importance.",
      "description_length": 421,
      "index": 151,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_logs.Logs.BatteriesKind",
      "library": "goblint.logs",
      "description": "This module implements logging functionality with support for output formatting using the `format4` type. It provides a `log` function that takes a log level and a format string, enabling structured logging to an output stream. It is used for emitting diagnostic and informational messages during program execution, specifically tailored for integration with the Goblint analysis framework.",
      "description_length": 390,
      "index": 152,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_logs.Logs.Format",
      "library": "goblint.logs",
      "description": "This module handles formatted logging output with support for different log levels like debug, info, warn, and error. It works with format strings and values of arbitrary types, enabling type-safe message formatting using OCaml's format specifiers. It is used to produce structured log messages during static analysis, including multi-line output via newline insertion and result formatting for analysis outputs.",
      "description_length": 412,
      "index": 153,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_logs.Logs.PrettyKind",
      "library": "goblint.logs",
      "description": "This module provides operations for logging structured documents using the `Pretty.doc` type, enabling formatted output with support for pretty-printing combinators. It works directly with logging levels and format strings to produce richly formatted log messages. Concrete use cases include generating indented or aligned textual output during static analysis for improved readability.",
      "description_length": 386,
      "index": 154,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_logs.AnsiColors",
      "library": "goblint.logs",
      "description": "This module defines a list of ANSI escape sequences for terminal colors and a reference indicating whether to use ANSI colors for standard error output. It works with strings and boolean references to control color output dynamically. Concrete use cases include formatting terminal output with colors for logging or enhancing readability in command-line tools.",
      "description_length": 360,
      "index": 155,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_logs.Logs",
      "library": "goblint.logs",
      "description": "This module provides logging operations at various severity levels (debug, info, warn, error, result) with support for formatted output using OCaml's type-safe format strings and pretty-printing combinators. It works with structured data types such as `format4`, `Pretty.doc`, and `result` values, enabling richly formatted and conditional log output during static analysis. Concrete use cases include emitting diagnostic messages, tracing analysis phases, and generating readable, indented output for complex data like CIL documents.",
      "description_length": 534,
      "index": 156,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_logs",
      "library": "goblint.logs",
      "description": "This module includes submodules for terminal color formatting and structured logging. AnsiColors manages ANSI escape codes and color output control, while Logs handles severity-level logging with type-safe formatting and pretty-printing. It is used for enhancing command-line output readability and emitting detailed diagnostic messages during static analysis.",
      "description_length": 360,
      "index": 157,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_tracing",
      "library": "goblint.tracing",
      "description": "This module enables hierarchical debug tracing through activation controls, indentation management, and conditional message printing filtered by context such as variables or subsystems. It operates on structured data like strings, hashtables, and CIL documents to produce formatted trace output, supporting use cases like analyzing complex program behaviors with nested diagnostic contexts. The interface includes key-based conditional tracing and unconditional message emission for structured debugging workflows.",
      "description_length": 514,
      "index": 158,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LibraryDesc.Accesses",
      "library": "goblint.library",
      "description": "This module processes lists of CIL expressions to identify and manipulate pointer argument accesses based on predefined specifications. It provides operations to find, iterate over, and fold across accesses that match specific access types or kinds within a list of expressions. Concrete use cases include analyzing function calls to extract or transform pointer arguments according to access patterns defined in a library descriptor.",
      "description_length": 434,
      "index": 159,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LibraryDesc.MathPrintable",
      "library": "goblint.library",
      "description": "This module defines operations for comparing, hashing, and converting mathematical descriptors to strings or XML. It works with the `LibraryDesc.math` type, providing concrete functionality for pretty-printing, serialization, and structural equality checks. Use this module when you need to display, log, or persist mathematical function descriptors in a readable format.",
      "description_length": 371,
      "index": 160,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "LibraryDesc.MathLifted",
      "library": "goblint.library",
      "description": "The module provides lattice operations (join, meet, widening, narrowing), comparison operators, hashing, and serialization to string, XML, and JSON formats for a polymorphic variant type encompassing bottom, top, and lifted mathematical values. These features are primarily used in abstract interpretation and pretty-printing workflows within static analysis tools.",
      "description_length": 365,
      "index": 161,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LibraryDesc.Access",
      "library": "goblint.library",
      "description": "This module defines the behavior for accessing pointer arguments in a library function descriptor. It specifies whether access is shallow or deep and determines how pointer values are traversed during analysis. Use cases include controlling the scope of pointer dereferencing in static analysis tools and defining precise memory access patterns for function parameters.",
      "description_length": 369,
      "index": 162,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LibraryDesc",
      "library": "goblint.library",
      "description": "This module defines data structures and operations for describing and manipulating library function behaviors in static analysis tools. It includes variants for mathematical operations, memory operations, and concurrency primitives, along with attributes for function properties like thread safety. The module supports concrete use cases such as modeling function semantics in CIL-based analyzers, specifying pointer access patterns for analysis precision, and serializing function descriptors for logging or external processing.",
      "description_length": 529,
      "index": 163,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "AccessKind",
      "library": "goblint.library",
      "description": "This module defines a type `t` representing different kinds of memory accesses, including read, write, free, call, and spawn operations. It provides functions for equality checking, comparison, hashing, string conversion, pretty printing, XML serialization, and JSON encoding of these access types. Concrete use cases include tracking memory usage in program analysis, enforcing memory safety constraints, and serializing access information for external tools or logging.",
      "description_length": 471,
      "index": 164,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "LibraryFunctions",
      "library": "goblint.library",
      "description": "This module maintains a hard-coded database of library function specifications and provides operations to query and manage them. It works with CIL variables and string identifiers to determine special handling, safety, and atomic properties for library functions. Concrete use cases include checking if a function requires a special transfer function, verifying if an uncalled function is safe, or retrieving a function's descriptor during analysis.",
      "description_length": 449,
      "index": 165,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LibraryDsl",
      "library": "goblint.library",
      "description": "This module enables constructing library function descriptors using a domain-specific language. It provides operations to define argument capture and access modes (read, write, free, spawn) for creating precise function behavior descriptions. It works with expressions and lists of expressions, supporting concrete use cases like specifying how a library function interacts with its arguments in static analysis, such as tracking memory accesses or function call effects.",
      "description_length": 471,
      "index": 166,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_timing.Make",
      "library": "goblint.timing",
      "description": "Implements hierarchical timing with start, stop, reset, enter, exit, and wrap operations for profiling nested sections of code. Uses string-labeled timed sections and maintains a tree structure for output. Useful for measuring performance of specific code blocks in a structured, nested manner.",
      "description_length": 294,
      "index": 167,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_timing",
      "library": "goblint.timing",
      "description": "Implements hierarchical timing with start, stop, reset, enter, exit, and wrap operations for profiling nested sections of code. Uses string-labeled timed sections and maintains a tree structure for output. Enables precise performance measurement of specific code blocks in a structured, nested manner, with support for Trace Event Format (TEF) output to visualize timing data.",
      "description_length": 376,
      "index": 168,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_std.GobQCheck.Shrink",
      "library": "goblint.std",
      "description": "Performs shrinking on lists of values by sequentially applying individual shrinkers to each element. Works with lists of arbitrary types and leverages `QCheck` shrinkers for each element. Useful for property-based testing scenarios where shrinking complex list structures is needed to find minimal counterexamples.",
      "description_length": 314,
      "index": 169,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_std.GobQCheck.Iter",
      "library": "goblint.std",
      "description": "This module creates and manipulates QCheck iterators for generating test values. It converts generators and arbitrary value specifications into finite iterators with a specified size. Concrete use cases include generating test inputs for property-based testing and sampling values for validation.",
      "description_length": 296,
      "index": 170,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_std.GobList.Syntax",
      "library": "goblint.std",
      "description": "This module provides applicative and monadic syntax for working with lists. It includes operations like `let+`, `and+`, `let*`, `and*`, and `>>=` to enable functional composition and combination of list values. These functions facilitate concise list transformations and combinations, particularly useful in scenarios involving multiple list traversals or sequential list computations.",
      "description_length": 385,
      "index": 171,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_std.GobOption.Syntax",
      "library": "goblint.std",
      "description": "This module provides applicative and monadic operators for composing computations over `option` values. It enables expressive chaining of optional values using syntax like `let+`, `and+`, `let*`, and `and*`, along with the `>>=` bind operator. Concrete use cases include safely handling sequences of operations that may fail or return missing data, such as parsing or lookup chains.",
      "description_length": 382,
      "index": 172,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_std.GobResult.Syntax",
      "library": "goblint.std",
      "description": "This module provides applicative and monadic operators for working with `result` values, enabling concise composition of error-handling computations. It includes functions like `let+`, `and+`, `let*`, `and*`, and `>>=` to map, bind, and combine results in a pipeline-friendly style. Concrete use cases include parsing, validation chains, and sequential operations where each step depends on the previous result.",
      "description_length": 411,
      "index": 173,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_std.GobQCheck.Gen",
      "library": "goblint.std",
      "description": "Provides functions for composing and manipulating QCheck generators. Works with QCheck generator types to produce random values for property-based testing. Enables generating complex data structures like lists by combining simpler generators.",
      "description_length": 242,
      "index": 174,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_std.GobQCheck.Arbitrary",
      "library": "goblint.std",
      "description": "This module defines arbitrary value generators for use with QCheck, including support for `int64` and `Z.t` (arbitrary-precision integers). It also provides a function to generate lists of arbitrary values from a list of individual arbitrary generators. These are useful for property-based testing where specific numeric types or structured inputs need to be randomly generated.",
      "description_length": 378,
      "index": 175,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_std.GobFpath",
      "library": "goblint.std",
      "description": "This module provides operations for manipulating file paths, including equality checks, comparison, and string conversion. It supports working with absolute and relative paths, enabling tasks like joining paths, finding common prefixes, and serializing paths to and from JSON. Concrete use cases include path normalization in build systems, file traversal in linters, and handling configuration file locations.",
      "description_length": 410,
      "index": 176,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_std.GobHashtbl",
      "library": "goblint.std",
      "description": "Implements hash tables with operations for insertion, lookup, and iteration over key-value pairs. Works with arbitrary key and value types, using standard equality and hashing functions. Useful for tracking mappings in analyses, such as variable environments or caching intermediate results during constraint solving.",
      "description_length": 317,
      "index": 177,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_std.GobYojson",
      "library": "goblint.std",
      "description": "Handles JSON data manipulation with operations to merge JSON objects and lists, print JSON to output streams, and format JSON into pretty-printed documents. Works directly with Yojson.Safe.t structures, supporting both associative lists and lists of values. Useful for configuration handling, data serialization, and generating human-readable JSON output.",
      "description_length": 355,
      "index": 178,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_std.GobArray",
      "library": "goblint.std",
      "description": "This module provides indexed variants of common array operations, including checking for elements that satisfy a predicate, validating all elements against a predicate, and counting matches. It works directly with OCaml arrays, enhancing iteration with access to both element indices and values. These functions are useful in scenarios where index-aware processing is required, such as implementing custom array transformations or validations that depend on positional information.",
      "description_length": 481,
      "index": 179,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_std.GobQCheck",
      "library": "goblint.std",
      "description": "This module extends QCheck with tools for generating, iterating, and shrinking test values for property-based testing. It provides functions to compose generators, create bounded iterators, and shrink lists of arbitrary values, particularly supporting numeric types like `int64` and `Z.t`. Concrete use cases include generating structured test inputs, sampling values for validation, and minimizing counterexamples in test cases.",
      "description_length": 429,
      "index": 180,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_std.GobUnix",
      "library": "goblint.std",
      "description": "This module extends OCaml's Unix library with additional operations for process status handling and time formatting. It provides `string_of_process_status` to convert process exit statuses into human-readable strings, and `localtime` to get the current local time as a formatted string. These functions are useful for logging, debugging, and user-facing output in command-line tools and system utilities.",
      "description_length": 404,
      "index": 181,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_std.GobOption",
      "library": "goblint.std",
      "description": "This module provides operations like `exists`, `for_all`, and `map2` for working with `option` values. It enables checking conditions over optional data and combining pairs of optional values with a function. Concrete use cases include validating the presence of data satisfying a predicate or merging two optional results into a single computation.",
      "description_length": 349,
      "index": 182,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_std.GobList",
      "library": "goblint.std",
      "description": "This module extends list operations with specialized functions for combining, folding, and partitioning lists. It provides `combine_short` for safely zipping lists, `assoc_eq_opt` for associative lookups with custom equality, and multi-list folds like `fold_left3` and `for_all3`. Use cases include processing parallel lists of function arguments, validating structures across multiple lists, and safely partitioning lists with `until_last_with` for tasks like splitting on the last delimiter in a sequence.",
      "description_length": 507,
      "index": 183,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_std.GobGc",
      "library": "goblint.std",
      "description": "Handles garbage collection statistics and memory management operations. Works with `Stdlib.Gc.stat` and `Stdlib.out_channel` to capture and output runtime memory metrics. Useful for profiling application memory usage and diagnosing performance issues during execution.",
      "description_length": 268,
      "index": 184,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_std.GobRef",
      "library": "goblint.std",
      "description": "This module provides operations for temporarily modifying the contents of a reference during the execution of a function. It supports working with standard OCaml references (`'a ref`) and allows setting a reference to a specific value while executing a given function, restoring its original value afterward. A concrete use case is managing dynamic scoping or temporary state changes, such as redirecting output streams or simulating context switches in a controlled computation.",
      "description_length": 479,
      "index": 185,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_std.GobResult",
      "library": "goblint.std",
      "description": "This module provides monadic and applicative combinators for composing `result`-typed values, enabling error propagation and chaining of computations that may fail. It works directly with the standard `result` type, offering operations like `map`, `bind`, and `combine` to handle success and error cases without boilerplate pattern matching. Concrete use cases include parsing input with multiple steps, validating data structures with early exits on failure, and orchestrating sequential operations where each depends on the previous outcome.",
      "description_length": 543,
      "index": 186,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_std.GobPretty",
      "library": "goblint.std",
      "description": "This module provides functions for converting structured document representations into string formats, specifically working with `GoblintCil.Pretty.doc` as the core data type. It supports operations like `show` for direct conversion, `sprint` for delayed evaluation, and formatted output with `sprintf` and `igprintf`. Concrete use cases include generating readable string outputs for abstract syntax trees or pretty-printing configuration and analysis results in Goblint.",
      "description_length": 472,
      "index": 187,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_std.GobZ",
      "library": "goblint.std",
      "description": "This module implements arithmetic and comparison operations for arbitrary-precision integers using the `Z.t` type from the Zarith library. It includes functions for checking equality, comparison, hashing, and pretty-printing integer values, as well as validating properties across integer ranges. It is used for precise integer manipulation and analysis in contexts like static analysis or formal verification.",
      "description_length": 410,
      "index": 188,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_std.GobYaml",
      "library": "goblint.std",
      "description": "This module provides utilities for parsing, transforming, and constructing YAML data structures, including operations like extracting keys and values from objects, combining objects, mapping over collections, and converting values to specific types (strings, integers, etc.) with",
      "description_length": 279,
      "index": 189,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_std.GobSys",
      "library": "goblint.std",
      "description": "This module provides system-level operations for directory manipulation, process signals, and time formatting. It works with file paths (`Fpath.t`) and system signals, offering functions like recursive directory removal, directory creation with parent paths, and signal handling. Concrete use cases include managing temporary directories, handling process termination signals, and logging timestamps.",
      "description_length": 400,
      "index": 190,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_std",
      "library": "goblint.std",
      "description": "This module provides a collection of utility functions for data structure manipulation, system operations, and external data format handling. It includes modules for working with arrays, lists, hash tables, and optional or result values, as well as system-level tasks like directory manipulation and signal handling. Specific use cases include index-aware array validation, temporary reference modification, error propagation with result types, and managing file paths or YAML/JSON data structures.",
      "description_length": 498,
      "index": 191,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lattice.HConsed.HC",
      "library": "goblint.domain",
      "description": "Implements hash-consing for lattice elements using a hash table, ensuring canonical representation of keys. Provides operations to create and manage a hash-consed lattice structure, including hashcons, iteration, folding, and counting. Useful for efficient equality checks and memory optimization in lattice-based analyses.",
      "description_length": 323,
      "index": 192,
      "embedding_norm": 1.0
    },
    {
      "module_path": "HoareDomain.HoarePO.B",
      "library": "goblint.domain",
      "description": "Implements lattice operations for list-based abstract domains, providing `join`, `widen`, `meet`, and `merge_element` to combine and refine elements within a Hoare ordering context. Works with lists of abstract values and maps of element lists. Used to merge and analyze multiple execution paths in static analysis, particularly for propagating and combining abstract states across program points.",
      "description_length": 397,
      "index": 193,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MapDomain.PrintGroupable.Group",
      "library": "goblint.domain",
      "description": "Handles grouping of map keys with comparison operations. Works with `D.group` type, providing a total ordering function for grouping map keys. Useful for organizing and comparing key groups in map domains.",
      "description_length": 205,
      "index": 194,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lattice.HashCached.LazyHash",
      "library": "goblint.domain",
      "description": "This module implements a lazy hash structure that caches the results of hash computations. It works with any type `M.t` that supports hash and equality operations, deferring the actual hash calculation until forced. Useful for optimizing performance in scenarios where hash values are needed infrequently or on-demand, such as in memoization or deferred computation contexts.",
      "description_length": 375,
      "index": 195,
      "embedding_norm": 1.0
    },
    {
      "module_path": "TrieDomain.Make.ChildMap",
      "library": "goblint.domain",
      "description": "This module implements a specialized map structure for managing hierarchical relationships in trie-based data, where keys of type `Key.t` associate with trie nodes. It supports standard map operations like insertion, traversal, and transformation, alongside lattice-oriented combinators for merging and comparing maps with domain-specific semantics. Designed for scenarios requiring structured key-value manipulation in trie domains, it facilitates tasks like symbolic computation, hierarchical state management, or semantic analysis where nested map operations and lattice consistency are critical.",
      "description_length": 599,
      "index": 196,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "PartitionDomain.ExpPartitions.B",
      "library": "goblint.domain",
      "description": "This module provides lattice operations (join, meet, widen) and set algebra (union, intersection, difference) for partitioning CIL expressions, supporting membership checks, predicate-based partitioning, and cardinality analysis. It operates on finite sets of `CilType.Exp.t` elements, offering traversal, filtering, and extremal element extraction capabilities. These features enable abstract interpretation tasks like program state modeling and data flow analysis, where tracking expression partitions informs static analysis of program behavior.",
      "description_length": 548,
      "index": 197,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "PartitionDomain.SetSet.E",
      "library": "goblint.domain",
      "description": "This module supports lattice-based computations and set manipulation over a variant domain containing boxed sets and a top element. It provides operations like join, meet, widen, and narrow for lattice structuring, alongside standard set functions (union, intersection, partitioning) for elements of type `B.t` and `E.t`, including size tracking, extremal element retrieval, and predicate-driven partitioning. It is suited for scenarios requiring hierarchical set operations or abstract interpretation frameworks where domain refinement and element classification are critical.",
      "description_length": 577,
      "index": 198,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "PartitionDomain.SetSet.B",
      "library": "goblint.domain",
      "description": "This module provides lattice operations (join, meet, widen, narrow) and standard set manipulation functions (union, map, filter, partition) on an immutable set structure. It operates on sets of elements of type `Base.t`, implemented via a parametric set type `B.t` derived from `BatSet.Make`. The design supports use cases like abstract interpretation in program analysis, where precise set-based computations and lattice-based reasoning over partitioned domains are required.",
      "description_length": 476,
      "index": 199,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MapDomain.PrintGroupable.GroupMap",
      "library": "goblint.domain",
      "description": "This module provides associative map operations for key-value pairs with keys of type `Group.t` and polymorphic values, supporting insertion, deletion, lookup, and ordered traversal. It includes transformation functions like `map`, `fold`, and `filter`, along with structural manipulation via `split`, `partition`, and sequence conversion utilities (`to_seq`, `of_seq`) for bulk data processing. Typical use cases involve managing grouped hierarchical data, maintaining ordered associative collections, and efficiently transforming or iterating over key-value pairs with conditional or sequential access patterns.",
      "description_length": 613,
      "index": 200,
      "embedding_norm": 1.0
    },
    {
      "module_path": "PartitionDomain.ExpPartitions.E",
      "library": "goblint.domain",
      "description": "This module provides lattice-based operations and set-theoretic manipulations for analyzing partitions over expressions in abstract interpretation. It works with a variant type representing lifted partitions (either a set of elements or a top value) and elements derived from a related partitioning domain, supporting operations like predicate-based partitioning, extremal element extraction, and functional set transformations. These capabilities are specifically applied to tasks requiring precise expression value tracking through abstract domains, such as program analysis scenarios where partitioning helps model data flow and state dependencies.",
      "description_length": 651,
      "index": 201,
      "embedding_norm": 1.0
    },
    {
      "module_path": "TrieDomain.Make.Trie",
      "library": "goblint.domain",
      "description": "This module implements lattice operations such as join, meet, widen, and narrow for a trie-structured abstract domain, alongside utilities for equality checks, comparison, serialization (XML/JSON), and debugging differences. It operates on trie-based representations of hierarchical data, enabling abstract interpretation tasks like state merging and refinement. The lattice structure supports program analysis by modeling properties such as symbolic heaps or dataflow values through trie-shaped partitions.",
      "description_length": 507,
      "index": 202,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "SetDomain.FiniteSet.E",
      "library": "goblint.domain",
      "description": "This module represents finite sets of a fixed, enumerable element type, supporting operations like membership testing, union, intersection, and difference. It works with elements that have comparison, hashing, and pretty-printing capabilities, and provides concrete functionality for set construction, iteration, and querying. Use cases include modeling discrete state spaces, managing symbolic values, and implementing analyses that require precise set operations over known domains.",
      "description_length": 484,
      "index": 203,
      "embedding_norm": 1.0
    },
    {
      "module_path": "SetDomain.SensitiveConf.Elt",
      "library": "goblint.domain",
      "description": "This module defines operations for handling pairs of base and user elements, including equality, comparison, hashing, and string representation. It supports structured data analysis tasks where each element is a tuple of two distinct types. The module is used to manage path-sensitive set domains in static analysis, where elements must be compared, displayed, or serialized for further processing.",
      "description_length": 398,
      "index": 204,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lattice.Flat",
      "library": "goblint.domain",
      "description": "This module implements a flat lattice structure over a base type, offering operations to combine and compare elements with three possible states: bottom (Bot), a wrapped base value (Lifted), or top (Top). It provides lattice operations (join, meet, widening/narrowing), property checks (e.g., is_bot, is_top), and serialization support, primarily used in abstract interpretation to model domains where values may be unknown, precisely known, or over-approximated.",
      "description_length": 463,
      "index": 205,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "MapDomain.MapTop_LiftBot",
      "library": "goblint.domain",
      "description": "This module provides finite map operations with lattice semantics, combining standard map algebra (insertion, deletion, traversal) with lattice-specific combinators (join, meet, widen) over values. It operates on maps with keys of type `Domain.t` and values of type `Range.t`, where the value domain forms a bounded lattice with explicit bottom (`bot`) and top (`top`) elements. The design supports use cases in abstract interpretation, enabling merge operations that combine maps using lattice joins, bulk updates for efficient value propagation, and serialization utilities for debugging or external representation.",
      "description_length": 617,
      "index": 206,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lattice.NoBotTop",
      "library": "goblint.domain",
      "description": "Implements lattice operations for types without distinguished bottom or top elements. Provides functions `top`, `is_top`, `bot`, and `is_bot` that allow clients to explicitly handle extremal values in lattice computations. Useful for analyses where lattice bounds are not naturally present in the data type, such as certain abstract interpretations or constraint systems.",
      "description_length": 371,
      "index": 207,
      "embedding_norm": 1.0
    },
    {
      "module_path": "SetDomain.Make",
      "library": "goblint.domain",
      "description": "This module provides a lattice structure for set-based abstract domains with operations like inclusion checks (`leq`), union/intersection joins/meets, and widening/narrowing for convergence in static analysis. It works with sets of elements from a `Base` module, using `BatSet.Make` for representation, and supports membership testing, cardinality, filtering, and conversion from lists. Designed for scenarios requiring precise set semantics without unbounded elements, it is suited for abstract interpretation tasks like program analysis where top elements are undefined.",
      "description_length": 572,
      "index": 208,
      "embedding_norm": 1.0
    },
    {
      "module_path": "HoareDomain.SetEM",
      "library": "goblint.domain",
      "description": "This module implements a lattice structure for sets of elements ordered under Hoare semantics, supporting element-wise operations like union, intersection, and difference alongside abstract interpretation primitives (`widen`, `narrow`, `join`). It focuses on tracking maximal elements through set abstractions, using Egli-Milner widening to ensure convergence even when maximal element counts diverge. It is particularly suited for static analysis domains where precise convergence guarantees are required for fixpoint computations over hierarchical data structures.",
      "description_length": 566,
      "index": 209,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lattice.Reverse",
      "library": "goblint.domain",
      "description": "This module implements lattice operations under a reversed ordering, providing duals of standard lattice functions such as swapped `join`/`meet` behavior, inverted `leq` comparisons, and flipped `top`/`bot` constants. It operates on lattice elements derived from `Base.t`, maintaining structural equivalence while inverting semantic hierarchies for applications like reverse data flow analysis or dual lattice visualization. The module supports testing workflows through value generation (`arbitrary`), difference diagnostics (`pretty_diff`), and XML serialization, particularly useful in compiler optimization and abstract interpretation scenarios requiring order inversion.",
      "description_length": 675,
      "index": 210,
      "embedding_norm": 1.0
    },
    {
      "module_path": "PartitionDomain.SetSet",
      "library": "goblint.domain",
      "description": "This module combines lattice and set-theoretic operations on a parametric abstract domain representing partitions or equivalence classes over elements of type `B.elt`, where `B.t` itself models sets of `Base.t`. It supports abstract interpretation tasks like dataflow analysis through join/meet operations, domain refinement, and precise set reasoning via membership checks, union/intersection, and equivalence class manipulation. Key use cases include program analysis scenarios requiring tracking of partitioned data states or hierarchical domain abstractions with cardinality and ordering constraints.",
      "description_length": 604,
      "index": 211,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MapDomain.Joined",
      "library": "goblint.domain",
      "description": "This module provides dictionary-style operations for maps with keys of type `E.t` and values of type `R.t`, including insertion, bulk updates from lists, and higher-order transformations. It supports lattice operations (join",
      "description_length": 224,
      "index": 212,
      "embedding_norm": 1.0
    },
    {
      "module_path": "BoolDomain.FlatBool",
      "library": "goblint.domain",
      "description": "This module implements standard lattice operations (join, meet, widen, narrow), comparison functions, and serialization utilities for a three-value boolean lattice composed of `Bot`, `Lifted bool`, and `Top`. It supports abstract interpretation workflows where boolean values require approximation, such as static analysis of program variables with unknown (`Top`) or invalid (`Bot`) states, and provides utilities to explicitly construct or test for extremal values. The lattice structure enables merging and comparing imprecise boolean information while preserving monotonicity guarantees.",
      "description_length": 591,
      "index": 213,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MapDomain.MapTop",
      "library": "goblint.domain",
      "description": "This module provides polymorphic map operations with domain-specific keys and range values, supporting standard manipulations like insertion, traversal, transformation, and bulk updates, alongside lattice-based combinators for join/meet operations and extremal value handling. It works with finite map structures where keys and values adhere to domain-specific types, enabling functional transformations, predicate filtering, and serialization. Key use cases include abstract interpretation tasks requiring ordered map combinations, program analysis state management, and bulk data processing with domain-constrained key-value associations.",
      "description_length": 640,
      "index": 214,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "MapDomain.LiftTop",
      "library": "goblint.domain",
      "description": "This module combines map manipulation and lattice operations, enabling functional transformations on maps with keys from `M` and values from `Range`. It supports standard map operations (insertion, iteration, filtering), advanced map merging with custom functions, and lattice-theoretic operations like join, meet, and widening for domain analysis. These capabilities are particularly useful in static analysis or abstract interpretation scenarios where maps represent structured state abstractions requiring both combinatorial and hierarchical reasoning.",
      "description_length": 555,
      "index": 215,
      "embedding_norm": 1.0
    },
    {
      "module_path": "SetDomain.Print",
      "library": "goblint.domain",
      "description": "This module provides functions to format and output set domain values as strings, JSON, and XML. It works with set domains represented by the `S.t` type and their elements via the `E` module. Concrete use cases include printing human-readable set summaries, generating JSON for serialization, and writing XML output for external tools.",
      "description_length": 335,
      "index": 216,
      "embedding_norm": 1.0
    },
    {
      "module_path": "HoareDomain.HoarePO",
      "library": "goblint.domain",
      "description": "This module provides lattice operations (join, meet, widen, narrow) and path-sensitive merging functions for maps associating integer keys with lists of abstract elements (`E.t`), designed for static analysis tasks like execution path merging and state propagation. It supports map transformations, set-like operations (union, difference), and structural queries (equality checks, cardinality) over these key-value structures. Additional utilities handle serialization (JSON/XML), pretty-printing, and difference reporting between analysis states for debugging and result comparison.",
      "description_length": 583,
      "index": 217,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lattice.Prod3",
      "library": "goblint.domain",
      "description": "The module combines three distinct lattice types into a composite structure, enabling standard lattice operations such as join, meet, and comparison across the product type. It supports serialization, pretty-printing, and test generation for this triple lattice combination, facilitating applications like program analysis where multiple abstract domains need concurrent tracking and manipulation.",
      "description_length": 397,
      "index": 218,
      "embedding_norm": 1.0
    },
    {
      "module_path": "HoareDomain.MapBot",
      "library": "goblint.domain",
      "description": "This module provides a map-like abstract domain with keys of type `SpecD.t` (or polymorphic `key`) and values in a lattice structure `R.t`, supporting standard map operations (addition, removal, filtering, union) alongside lattice-theoretic transformations (join, meet, widen, narrow) and Hoare-style ordering checks (leq, le). It integrates domain-specific utilities for abstract interpretation, including bottom/top elements, lifting operations, and structured differencing, tailored for static analysis tasks requiring precise value-set approximations and fixpoint computations. Use cases include program analysis frameworks where key-value mappings model program states or environments with lattice-ordered properties.",
      "description_length": 722,
      "index": 219,
      "embedding_norm": 1.0
    },
    {
      "module_path": "PartitionDomain.Set",
      "library": "goblint.domain",
      "description": "This module provides set algebra operations (union, intersection, difference), lattice-based computations (join, meet, widen), and element manipulation (membership checks, insertion/removal). It operates on polymorphic sets with elements of a specified type, catering to abstract interpretation and symbolic analysis where domain-specific set transformations and hierarchical approximations are required. Key functionalities include extremal element retrieval (min/max), cardinality tracking, and serialization-agnostic comparisons for structured data modeling.",
      "description_length": 561,
      "index": 220,
      "embedding_norm": 1.0
    },
    {
      "module_path": "PartitionDomain.ExpPartitions",
      "library": "goblint.domain",
      "description": "This module provides lattice operations (join, meet, widen, narrow) and set manipulations (union, intersection, difference, filtering) on partitions of CIL expressions, represented as equivalence classes. It supports cardinality analysis, predicate-based partitioning, and serialization, with utilities to query relationships between partitions or extract extremal elements. These operations are used in abstract interpretation to track expression equivalences, merge divergent program states, and analyze dataflow properties like value ranges or aliasing.",
      "description_length": 556,
      "index": 221,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "MapDomain.Timed",
      "library": "goblint.domain",
      "description": "This module provides associative map operations with temporal semantics, supporting key-value mappings over a domain with lattice structures. It combines standard map manipulations like bulk updates and filtering with lattice-based combinators (`join`, `meet`, `widen`) to merge and compare maps, using customizable value operations. Designed for scenarios requiring structured data analysis, such as program analysis tasks where maps represent evolving states with partial orders or extremal values.",
      "description_length": 500,
      "index": 222,
      "embedding_norm": 1.0
    },
    {
      "module_path": "SetDomain.FiniteSet",
      "library": "goblint.domain",
      "description": "This module implements finite, immutable sets over an enumerable element type, supporting standard set operations (union, intersection, difference) and lattice operations (join, meet) with widening/narrowing for abstract interpretation. It provides utilities for partitioning sets by predicates, extracting extremal elements, and converting between sets and lists, specifically targeting precise set-based analysis in discrete domains where exact membership and ordering are critical.",
      "description_length": 484,
      "index": 223,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lattice.UnitConf",
      "library": "goblint.domain",
      "description": "This module provides lattice operations over unit values, including standard meet/join/top/bot functions, equality checks, and pretty-printing for debugging. It supports abstract interpretation frameworks where unit-type lattices model trivial abstractions or serve as base cases in recursive domain constructions. The inclusion of serialization (XML/Yojson) and QCheck testing utilities makes it suitable for prototyping and verifying lattice-based analyses in program analysis tools.",
      "description_length": 485,
      "index": 224,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lattice.LiftTop",
      "library": "goblint.domain",
      "description": "This module extends a base lattice with a top element, offering operations like `join`, `meet`, `widen`, and `narrow` to combine or compare values that are either lifted from the base domain or the universal top element. It works with a sum type representing values as either `Lifted` (wrapping base lattice elements) or `Top`, supporting analysis scenarios where a maximal element is needed to represent over-approximations or undefined states. The inclusion of `pretty_diff` aids in debugging program analyses by visualizing differences between such extended lattice values.",
      "description_length": 576,
      "index": 225,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lattice.HConsed",
      "library": "goblint.domain",
      "description": "This module provides hash-consing functionality for lattice elements, using a hash table to enforce canonical representations of base domain values. It supports lattice operations like meet, join, and widening over hash-consed elements (represented as `BatHashcons.hobj`), enabling efficient equality checks and fixpoint computations in abstract interpretation. The design facilitates debugging, serialization, and pretty-printing of structured lattice values while maintaining optimal memory usage.",
      "description_length": 499,
      "index": 226,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lattice.FakeSingleton",
      "library": "goblint.domain",
      "description": "This module provides lattice operations including ordering checks (`leq`), extremal element tests (`is_top`, `is_bot`), and join/meet combinations, alongside structural utilities like serialization and diff visualization. It works with elements of a base type `Base.t` arranged in a bounded lattice structure, featuring distinguished top and bottom elements. The functionality supports static program analysis workflows requiring fixed-point computations with widening/narrowing and diagnostic output generation for lattice state transitions.",
      "description_length": 542,
      "index": 227,
      "embedding_norm": 1.0
    },
    {
      "module_path": "BoolDomain.StdNames",
      "library": "goblint.domain",
      "description": "This module defines standard string representations for boolean domains, including names for true and false values. It works with string and boolean data types to provide consistent naming conventions. Concrete use cases include formatting boolean outputs and parsing boolean strings in configurations or user interfaces.",
      "description_length": 321,
      "index": 228,
      "embedding_norm": 1.0
    },
    {
      "module_path": "SetDomain.ToppedSet",
      "library": "goblint.domain",
      "description": "The module provides lattice and set operations on a domain where values are either a distinguished top element or a wrapped set of a base type. It supports standard set manipulations like union, membership checks, and iteration, while incorporating lattice semantics (e.g., `join`, `meet`) to handle approximations in scenarios like static analysis, where `top` represents an overapproximation of all possible values and `bot` signifies emptiness. This structure is particularly useful for abstract domains requiring bounded set representations with explicit extremal elements.",
      "description_length": 577,
      "index": 229,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MapDomain.PMap",
      "library": "goblint.domain",
      "description": "This module provides operations for manipulating polymorphic maps with typed keys and values, supporting insertion, deletion, and lookup alongside transformations like folding, filtering, and merging. It works with key-value pairs where keys conform to `Domain.t` and values to `Range.t`, offering utilities for serialization (XML, Yojson), hashing, and generating test data via QCheck. These capabilities are particularly useful for managing structured key-value associations in scenarios requiring data persistence, combinatorial transformations, or property-based testing.",
      "description_length": 575,
      "index": 230,
      "embedding_norm": 1.0
    },
    {
      "module_path": "SetDomain.SensitiveConf",
      "library": "goblint.domain",
      "description": "This module provides path-sensitive set operations and domain-specific analysis functions for structured pairs of base and user values. It supports set-theoretic operations (union, intersection, difference), domain-specific behaviors like joining on coinciding elements, and static analysis utilities such as widen/narrow, while working with a custom set type containing elements of type `elt`. Designed for static analysis contexts, it emphasizes path-sensitive reasoning and merging of analysis states when user-defined elements match, without supporting a top element.",
      "description_length": 571,
      "index": 231,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "MapDomain.PrintGroupable",
      "library": "goblint.domain",
      "description": "This module provides functions for structured output and transformation of grouped map data, including XML and JSON serialization, pretty-printing, and string representation. It operates on map structures with grouped keys, leveraging the `Group` module's ordering to organize and process hierarchical or categorized data. Concrete use cases include generating human-readable or machine-parsable output for grouped map entries, such as reporting categorized statistics or exporting structured configurations.",
      "description_length": 508,
      "index": 232,
      "embedding_norm": 1.0
    },
    {
      "module_path": "BoolDomain.MakeMayBool",
      "library": "goblint.domain",
      "description": "This module provides lattice operations for boolean values, including join, meet, widen, and narrow, alongside predicates to check extremal states (is_bot, is_top) and constructors for bounded elements. It operates on a boolean domain structured as a bounded join-semilattice with explicit bottom and top elements, supporting difference analysis between unordered values. The design facilitates use in abstract interpretation frameworks and property-based testing scenarios requiring precise boolean state tracking.",
      "description_length": 515,
      "index": 233,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lattice.ProdSimple",
      "library": "goblint.domain",
      "description": "This module combines two lattices into a product type, enabling component-wise join, meet, widen, and other lattice operations. It operates on pairs of elements from each base lattice and includes utilities for pretty-printing, XML/JSON serialization, generating test values, and computing structural diffs. These features are particularly useful in program analysis tasks requiring combined domains with robust testing and data interchange capabilities.",
      "description_length": 454,
      "index": 234,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lattice.Lift2",
      "library": "goblint.domain",
      "description": "This module supports comparison, equality, and lattice operations like join, meet, widen, and narrow over a combined structure that merges two distinct base lattices with explicit bottom (`Bot`) and top (`Top`) elements. It works with polymorphic variants representing lifted values from two separate base types, enabling operations that handle least upper bounds, greatest lower bounds, and approximation behaviors in a unified lattice hierarchy. The design facilitates scenarios requiring composition of different lattice domains, such as program analysis frameworks that need to merge abstract interpretations or serialize lattice states for distributed computation.",
      "description_length": 669,
      "index": 235,
      "embedding_norm": 1.0
    },
    {
      "module_path": "PartitionDomain.Make",
      "library": "goblint.domain",
      "description": "This module provides lattice-theoretic operations for partitioned set domains, combining standard set manipulations (union, intersection, filtering) with domain-specific constructs like widening, narrowing, and closure computation. It operates on abstracted partitioned sets (`t`) with elements (`elt`) organized into equivalence classes, supporting both functional transformations and lattice-based analysis. These capabilities are particularly useful in static program analysis for modeling data flow and abstracting state spaces with hierarchical partitioning.",
      "description_length": 563,
      "index": 236,
      "embedding_norm": 1.0
    },
    {
      "module_path": "DisjointDomain.PairwiseMap",
      "library": "goblint.domain",
      "description": "This module implements a bucketed map structure where keys are partitioned by a congruence/projector and stored in inner maps with lattice-valued entries. It supports standard map operations like insertion, iteration, and filtering alongside lattice operations (join, meet, widen) that combine values within their respective buckets. Designed for abstract interpretation scenarios requiring modular analysis of disjoint domains, such as tracking path-sensitive state or managing hierarchical value abstractions.",
      "description_length": 511,
      "index": 237,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lattice.LiftBot",
      "library": "goblint.domain",
      "description": "This module provides lattice operations such as join, meet, widen, and narrow, alongside value manipulation (lift, relift) and predicates for extremal elements (is_bot, is_top). It operates on a base type extended with a bottom element (Bot) and wrapped in a Lifted constructor, enabling abstract interpretation workflows like static program analysis where value approximation and hierarchical combination are critical. The design supports type-directed polymorphism, allowing flexible subtyping in analysis domains.",
      "description_length": 516,
      "index": 238,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "FlagHelper.FlagHelper",
      "library": "goblint.domain",
      "description": "This module operates on pairs of optional values from two distinct domains, supporting comparisons, transformations, and structured output. It provides combinators for applying unary and binary functions to these pairs, with specific support for equality, hashing, pretty-printing, and serialization. Concrete use cases include handling dual-option configuration flags, merging or comparing left-right domain values, and generating structured diagnostics or JSON representations.",
      "description_length": 479,
      "index": 239,
      "embedding_norm": 1.0
    },
    {
      "module_path": "BoolDomain.MayBool",
      "library": "goblint.domain",
      "description": "This module supports lattice operations such as join, meet, widen, and narrow over a Boolean domain extended with top and bottom elements, using hconsed boolean values to ensure unique identity for abstract interpretation. It provides utilities for equality checks, comparison, and serialization alongside witness tracking through hconsuming tags. The structure is tailored for static analysis tasks requiring precise merging of abstract states with tracked provenance.",
      "description_length": 469,
      "index": 240,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MapDomain.LiftBot",
      "library": "goblint.domain",
      "description": "This module provides associative operations for a map-like structure binding keys to range values, supporting insertion, lookup, iteration, and transformation. It combines lattice semantics (join, meet, widen) with custom function application over these maps, enabling abstract interpretation tasks like fixpoint computation and difference analysis. The data structure accommodates serialization, structural queries, and merging operations, making it suitable for domains requiring both hierarchical data manipulation and domain-specific logic composition.",
      "description_length": 556,
      "index": 241,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lattice.Chain",
      "library": "goblint.domain",
      "description": "This module implements a total order lattice for integers, supporting operations like comparison, joining/meeting values, and checking extremal properties. It works with integer-based lattice elements where each value forms a linear chain under the standard numeric ordering. The operations are useful in static analysis scenarios requiring bounded fixed-point computations, such as tracking integer range abstractions or implementing widening/narrowing strategies for convergence.",
      "description_length": 481,
      "index": 242,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "MapDomain.MapBot",
      "library": "goblint.domain",
      "description": "This module implements finite maps with keys of type `Domain.t` and values of type `Range.t`, offering operations for functional transformations (`map`, `filter`, `fold`), bulk updates (`add_list`), and safe value access (`find_opt`). It supports advanced map manipulation through lattice operations like `join`, `meet`, and `widen`, enabling analysis of extremal values (`bot`, `top`) and custom combination logic via higher-order functions. Use cases include symbolic data-flow analysis, configuration management with hierarchical keys, and scenarios requiring precise map merging or serialization to formats like XML and JSON.",
      "description_length": 629,
      "index": 243,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lattice.LiftPO",
      "library": "goblint.domain",
      "description": "This module provides lattice operations such as join, meet, widen, and narrow on a lifted domain that includes bottom (`Bot`), top (`Top`), and wrapped (`Lifted`) values of a base type. It supports comparison, serialization, and pretty-printing for structured data analysis, with use cases in abstract interpretation and program analysis where hierarchical value domains or extremal element handling are required.",
      "description_length": 413,
      "index": 244,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lattice.Prod",
      "library": "goblint.domain",
      "description": "This module combines two base lattices into a product lattice structure, enabling operations like meet, join, widening, and narrowing on pairs of elements while supporting structural comparison and controlled expansion through dedicated utilities. It works with pairs of lattice elements, offering serialization to XML/JSON, arbitrary value generation, and diff visualization for external analysis or debugging. These capabilities are particularly useful in program analysis or verification workflows requiring precise handling of composite lattice semantics and cross-representation comparisons.",
      "description_length": 596,
      "index": 245,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lattice.ProdList",
      "library": "goblint.domain",
      "description": "This module implements lattice operations for lists of elements from the `Base` module, supporting equality checks, ordering comparisons, and structural analysis like common prefix/suffix detection. It provides product-type lattice combinators (join, meet, widen, narrow) and semantic utilities such as `bot`/`top` handling and difference visualization via `pretty_diff`. These capabilities are particularly useful for analyzing structured data where sequences of lattice values require merging, comparison, or summarization in domains like program analysis or symbolic reasoning.",
      "description_length": 580,
      "index": 246,
      "embedding_norm": 1.0
    },
    {
      "module_path": "BoolDomain.MakeBool",
      "library": "goblint.domain",
      "description": "This module represents boolean values with operations for comparison, hashing, serialization, and pretty-printing. It works directly with the `bool` type, providing concrete functionality for converting booleans to strings, XML, and Yojson, along with arbitrary value generation for testing. Use cases include handling boolean domains in symbolic execution and generating human-readable or machine-processable representations of boolean states.",
      "description_length": 444,
      "index": 247,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "DisjointDomain.ProjectiveMap",
      "library": "goblint.domain",
      "description": "This module implements a partitioned map structure where keys are grouped into buckets by a relation, with each bucket represented as a nested map of values. It supports both standard map operations like insertion, iteration, and filtering, as well as lattice operations such as join and meet that combine bucketed data while preserving domain-specific constraints. This structure is particularly useful for path-sensitive program analysis or tracking disjoint sets of addresses, where elements must be processed in congruence-defined partitions.",
      "description_length": 546,
      "index": 248,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "BoolDomain.MustBool",
      "library": "goblint.domain",
      "description": "This module provides lattice operations (join, meet, widen, narrow), domain-specific utilities (tagging, re-lifting), and serialization capabilities for working with a boolean lattice structure that includes top and bottom elements. It manipulates abstract values representing boolean states in static analysis contexts, such as tracking definite truth values or unknown conditions. Typical use cases involve analyzing program expressions where boolean precision is critical, like conditional flow analysis or invariant checking.",
      "description_length": 529,
      "index": 249,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "SetDomain.Reverse",
      "library": "goblint.domain",
      "description": "This module maintains standard set operations such as `add`, `union`, and `filter` while inverting the lattice order of the underlying domain, enabling lattice-specific operations like widened joins and narrowed meets. It operates on base set structures with arbitrary element types, providing extremum queries,",
      "description_length": 311,
      "index": 250,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lattice.FlatConf",
      "library": "goblint.domain",
      "description": "This module provides lattice operations for abstract interpretation, including join, meet, widen, and narrow, alongside comparison and extremal value checks. It operates on a three-state type combining bottom (Bot), top (Top), and lifted values (Lifted of Base.t), enabling representation of partially ordered data. Use cases include program analysis tasks requiring value merging, narrowing, and human-readable serialization via pretty-printing or JSON/XML export.",
      "description_length": 465,
      "index": 251,
      "embedding_norm": 1.0
    },
    {
      "module_path": "HoareDomain.Set",
      "library": "goblint.domain",
      "description": "This module supports lattice and set operations on a domain of `Lattice.S` elements under Hoare ordering, where abstractions focus on maximal elements to ensure convergence in iterative analyses. It provides join/meet for combining sets, widening/narrowing for fixpoint stabilization, and standard set manipulations (union, intersection, filtering) adapted to observe only maximal elements. Designed for static program analysis scenarios requiring finite-height lattices, it guarantees convergence when maximal element counts stabilize, making it suitable for abstract interpretation tasks like reachability or resource-bound inference.",
      "description_length": 636,
      "index": 252,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lattice.Unit",
      "library": "goblint.domain",
      "description": "This module implements a trivial lattice structure over the unit type, where all elements are treated as equivalent and the unit value serves as both the top and bottom element. It provides lattice operations like `leq`, `join`, `meet`, and `widen`, alongside utilities for serialization (XML/JSON), value inspection (`is_bot`), and visualizing differences between lattice states (`pretty_diff`). The design supports use cases requiring minimal lattice semantics, such as testing generic lattice algorithms or modeling scenarios where no meaningful state distinctions exist.",
      "description_length": 574,
      "index": 253,
      "embedding_norm": 1.0
    },
    {
      "module_path": "TrieDomain.Make",
      "library": "goblint.domain",
      "description": "This module provides lattice operations (join, meet, widen, narrow) and supporting utilities (equality, comparison, serialization, debugging) for abstract domains based on trie structures. It operates on hierarchical key-value data organized in trie nodes with child maps, enabling tasks like symbolic state merging, program analysis, and static property tracking through representations of extreme lattice values (bottom/top) and differential comparisons.",
      "description_length": 456,
      "index": 254,
      "embedding_norm": 1.0
    },
    {
      "module_path": "DisjointDomain.PairwiseSet",
      "library": "goblint.domain",
      "description": "This structure provides lattice and set-theoretic operations for elements partitioned into buckets via a congruence or projection relation. It manipulates sets of elements (`E.t`) organized by a bucket descriptor (`B`), supporting operations like `join`, `meet`, `union`, and `diff` while handling lattice extremal values (`bot`, `top`). It is particularly useful in static analysis for modeling path-sensitive data or disjoint memory regions, where bucketed grouping ensures domain-specific closure properties during computations.",
      "description_length": 531,
      "index": 255,
      "embedding_norm": 1.0
    },
    {
      "module_path": "FlagHelper.LatticeFlagHelper",
      "library": "goblint.domain",
      "description": "This module implements lattice operations including comparison, join, meet, widen, and narrow for pairs of optional values combining two distinct lattice domains. It operates on tuples where each element is an optional value from separate lattice types, supporting use cases that require merging or analyzing hierarchical data with presence/absence semantics, such as configuration state reconciliation or combined static analysis domains. The module also includes utilities for structured serialization, diff visualization, and XML representation tailored for these composite lattice pairs.",
      "description_length": 591,
      "index": 256,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lattice.ProdConf",
      "library": "goblint.domain",
      "description": "This module implements a product lattice structure that combines two distinct base lattices, enabling standard lattice operations like join, meet, and widening on paired values while supporting custom expansion behavior through directional control flags. It operates on tuples of elements from the two base lattices, providing serialization to string/XML/JSON formats, pretty-printing, and property-based testing utilities. The design facilitates use cases requiring compositional analysis frameworks, structured data representation with hierarchical widening strategies, and test generation for combined lattice properties.",
      "description_length": 624,
      "index": 257,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lattice.Liszt",
      "library": "goblint.domain",
      "description": "This module provides lattice operations such as join, meet, widen, and narrow on lists of `Base.t` values, complemented by list manipulation functions like `common_prefix` and `common_suffix`. It supports abstract interpretation workflows, particularly in static analysis, where structural equality and ordering help model hierarchical or sequential data approximations. Utilities like `pretty_diff` enable debugging by highlighting differences between lattice elements, while serialization and normalization tools facilitate integration with analysis frameworks.",
      "description_length": 563,
      "index": 258,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MapDomain.Print",
      "library": "goblint.domain",
      "description": "This module provides functions for formatting and outputting map domain data, including pretty-printing to documents, converting to strings, writing to XML, and serializing to Yojson. It operates on map structures defined by the `M` module, which represents domains and ranges from the `D` and `R` modules. Concrete use cases include generating human-readable output for debugging, exporting map data to XML files, and serializing maps for JSON-based data exchange.",
      "description_length": 465,
      "index": 259,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lattice.Lift2Conf",
      "library": "goblint.domain",
      "description": "This module combines two distinct lattice domains into a sum type with explicit bottom and top elements, supporting lattice operations like join, meet, widen, and narrow that handle cross-domain combinations. It provides comparison, serialization, and pretty-printing utilities for the composite type, enabling use cases in abstract interpretation where merging separate analysis domains is required. The operations respect lattice theory for handling lifted values, including interactions between base domains and extremal elements.",
      "description_length": 533,
      "index": 260,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MapDomain.MapBot_LiftTop",
      "library": "goblint.domain",
      "description": "This module provides finite maps with keys from a domain type and values from a range type, supporting operations for merging, filtering, structural inspection (e.g., cardinality checks, element extraction), and transformations with both unary and binary value functions. It introduces lattice operations\u2014join, meet, widen, and narrow\u2014alongside predicates to detect extremal elements (`bot`, `top`), enabling fixed-point computations in abstract interpretation. These features are designed for static analysis tasks, such as modeling program environments or data-flow properties, where convergence of iterative algorithms is critical.",
      "description_length": 634,
      "index": 261,
      "embedding_norm": 1.0
    },
    {
      "module_path": "DisjointDomain.CombinedSet",
      "library": "goblint.domain",
      "description": "This module provides set-theoretic and lattice operations for elements partitioned into disjoint buckets via a relation `RC`, where each bucket's elements are projected into a base domain `B`. It supports union, intersection, difference, filtering, and lattice operations like join/meet, alongside bucket-aware folding and extremal element retrieval. The structure is suited for static analysis scenarios requiring disjoint domain tracking, such as path-sensitive dataflow analysis or memory address set manipulation.",
      "description_length": 517,
      "index": 262,
      "embedding_norm": 1.0
    },
    {
      "module_path": "SetDomain.LiftTop",
      "library": "goblint.domain",
      "description": "This module provides lattice operations (join, meet, widen, narrow) and standard set manipulations (union, filter, cardinal) for a set abstraction that explicitly includes top and bottom elements. It operates on a wrapped set type `t` with elements of type `elt`, supporting use cases in abstract interpretation and formal verification where precise handling of extremal values and ordered set transformations is required. The design enables functional composition of set operations while maintaining lattice-theoretic guarantees for analysis frameworks.",
      "description_length": 554,
      "index": 263,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MapDomain.HashCached",
      "library": "goblint.domain",
      "description": "This module implements hash-consed finite maps with efficient insertion, deletion, and lookup, supporting bulk updates and algebraic combinations like union and intersection. It provides lattice structures for abstract interpretation, enabling join, meet, and widening operations over key-value pairs, while also offering serialization to XML and JSON for data interchange and integration with testing libraries through cardinality checks and structural comparisons. The design emphasizes performance-critical scenarios where hash-consing reduces memory usage, and higher-order combinators allow customizable merging and predicate evaluation.",
      "description_length": 642,
      "index": 264,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "BoolDomain.Bool",
      "library": "goblint.domain",
      "description": "This module implements boolean values with standard operations including equality, comparison, hashing, and pretty-printing. It provides concrete functions for converting booleans to strings, XML, and JSON, along with utilities for generating arbitrary boolean values and computing differences. It is used in contexts requiring precise boolean manipulation and representation, such as configuration handling, logical analysis, and serialization.",
      "description_length": 445,
      "index": 265,
      "embedding_norm": 1.0
    },
    {
      "module_path": "DisjointDomain.ProjectiveSet",
      "library": "goblint.domain",
      "description": "This module provides lattice operations (join, meet, widen) and set-theoretic operations (union, intersection, difference) on collections of elements partitioned into buckets by a relation. It manipulates data structured as elements of type `E.t` grouped into buckets via a relation `R.t`, with each bucket's contents modeled by a domain `B.t`. Designed for abstract interpretation scenarios like path-sensitive analysis or address set tracking, it supports bucket-aware transformations (e.g., `fold_buckets`) and handles lattice extremal values (bottom/top) for domains such as Hoare-style sets or joined domains.",
      "description_length": 614,
      "index": 266,
      "embedding_norm": 1.0
    },
    {
      "module_path": "SetDomain.Joined",
      "library": "goblint.domain",
      "description": "This module implements a lattice structure for sets abstracted via a single joined element, offering operations like join, meet, widen, and narrowing alongside standard set manipulations (union, intersection, filtering, mapping). It operates on an abstract type `t` representing sets of elements of type `E.t`, with HConsed-based unique tagging for structural equality and context tracking. Designed for abstract interpretation or program analysis scenarios, it supports efficient set transformations, cardinality queries, and integration with property-based testing frameworks through QCheck arbitraries and serialization primitives.",
      "description_length": 634,
      "index": 267,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lattice.LiftConf",
      "library": "goblint.domain",
      "description": "The module provides comparison, conversion, and manipulation operations for lifted lattice elements (`Bot`, `Lifted`, `Top`) over a base type `Base.t`, including checks for extremal values and ordering. It supports lattice-specific computations like least upper bounds (join), greatest lower bounds (meet), and approximation refinements (widen, narrow), with utilities to visualize differences between lattice values during static analysis of hierarchical data structures.",
      "description_length": 472,
      "index": 268,
      "embedding_norm": 1.0
    },
    {
      "module_path": "HoareDomain.Set_LiftTop",
      "library": "goblint.domain",
      "description": "This module provides lattice-based set operations including join, meet, widen, and narrow, alongside standard set manipulations like membership checks, union, intersection, and difference. It operates on sets of elements of type `B.t`, supporting conversions to and from lists, bulk element transformations via `apply_list`, and lattice-specific values such as bottom and top. It is suited for scenarios requiring abstract interpretation with set domains, such as static analysis of program variables or constraint propagation over discrete value ranges.",
      "description_length": 554,
      "index": 269,
      "embedding_norm": 1.0
    },
    {
      "module_path": "SetDomain.HeadlessSet",
      "library": "goblint.domain",
      "description": "This module supports standard set operations including union, intersection, and membership testing, alongside lattice operations such as join and meet for abstract interpretation. It manipulates pure functional sets of elements with type `Base.t`, offering functions to transform lists into sets and vice versa, while providing serialization to XML, Yojson, and string formats. This makes it suitable for static analysis frameworks requiring precise set-based domains and robust testing through QCheck arbitrary instance generation.",
      "description_length": 532,
      "index": 270,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lattice",
      "library": "goblint.domain",
      "description": "This module defines lattice structures and operations for various data types, including unit values, integers, flat domains, and lifted types with explicit top/bottom elements. It provides concrete functions for meet, join, widen, narrow, and equality checks, along with utilities for serialization, difference visualization, and testing. These components support static analysis tasks such as abstract interpretation, fixed-point computation, and program analysis where domain approximations are required.",
      "description_length": 506,
      "index": 271,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "HoareDomain",
      "library": "goblint.domain",
      "description": "This module provides lattice and set operations for abstract domains under Hoare ordering, focusing on maximal elements to ensure convergence in static analysis. It works with maps from integers to lists of abstract elements and sets of lattice elements, supporting operations like join, meet, widen, and narrow. Concrete use cases include merging execution paths, propagating analysis states, and performing precise fixpoint computations over hierarchical or finite-height domains.",
      "description_length": 482,
      "index": 272,
      "embedding_norm": 1.0
    },
    {
      "module_path": "TrieDomain",
      "library": "goblint.domain",
      "description": "Implements prefix-based data retrieval using trie structures. Provides functions for inserting, searching, and traversing key-value pairs where keys are sequences of comparable elements. Useful for auto-complete systems and dictionary implementations with efficient prefix queries.",
      "description_length": 281,
      "index": 273,
      "embedding_norm": 1.0
    },
    {
      "module_path": "SetDomain",
      "library": "goblint.domain",
      "description": "This module provides lattice-structured set domains with operations like union, intersection, inclusion checks, and widening/narrowing for abstract interpretation. It works with sets of elements from a base type, using `BatSet.Make` or finite enumerable types, supporting membership tests, filtering, and conversion from lists. Concrete use cases include program analysis tasks requiring precise set semantics, such as tracking reachable program states or analyzing data flow with bounded sets.",
      "description_length": 494,
      "index": 274,
      "embedding_norm": 1.0
    },
    {
      "module_path": "DisjointDomain",
      "library": "goblint.domain",
      "description": "This module implements abstract domains for managing collections of elements from disjoint unions, grouping them into buckets via congruence or projection relations. It supports operations like union, intersection, and mapping, all performed bucket-wise to maintain domain-specific invariants. Concrete use cases include modeling path-sensitive program analyses and tracking address sets in memory analysis.",
      "description_length": 407,
      "index": 275,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MapDomain",
      "library": "goblint.domain",
      "description": "Implements efficient finite maps with hash-consing for reduced memory usage, supporting fast insertion, deletion, lookup, and algebraic operations like union and intersection. Provides lattice-based combinators (join, meet, widen) for abstract interpretation and analysis tasks, along with XML and JSON serialization for data interchange. Useful in program analysis for tracking evolving states and performing structured data analysis with customizable merging and comparison logic.",
      "description_length": 482,
      "index": 276,
      "embedding_norm": 1.0
    },
    {
      "module_path": "PartitionDomain",
      "library": "goblint.domain",
      "description": "This module implements lattice-based partitioning operations for abstract domains, supporting set algebra and domain transformations. It works with polymorphic sets, partitioned sets, and equivalence classes over structured data like CIL expressions. Concrete use cases include static analysis tasks such as dataflow tracking, state abstraction, and predicate-based partitioning of program values or expressions.",
      "description_length": 412,
      "index": 277,
      "embedding_norm": 1.0
    },
    {
      "module_path": "FlagHelper",
      "library": "goblint.domain",
      "description": "This module implements operations for selecting and managing domain-specific alternatives based on runtime flags. It works with algebraic data structures representing flag configurations and domain choices, supporting branching logic based on flag settings. Concrete use cases include enabling feature toggles or selecting execution paths in distributed systems based on runtime configuration.",
      "description_length": 393,
      "index": 278,
      "embedding_norm": 1.0
    },
    {
      "module_path": "BoolDomain",
      "library": "goblint.domain",
      "description": "This module provides representations and operations for boolean domains with varying levels of abstraction, including standard boolean values, three-valued logics, and lattice structures extended with top and bottom elements. It supports concrete operations such as serialization to string, XML, and JSON, logical comparisons, hashing, and arbitrary value generation, tailored for use in static analysis, symbolic execution, and property-based testing. Specific submodules handle lattice merging, difference tracking, and precise state representation in contexts like conditional flow analysis and abstract interpretation.",
      "description_length": 622,
      "index": 279,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_backtrace",
      "library": "goblint.backtrace",
      "description": "This module extends exception handling with custom marks that can be attached to exceptions and later retrieved or printed. It provides operations to register mark printers, add marks to exceptions, and protect code blocks while attaching marks to any raised exceptions. The module works directly with exceptions and mark values, supporting use cases like tracing error contexts in complex analyses or debugging by associating structured metadata with exceptions.",
      "description_length": 463,
      "index": 280,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "ConstrSys.GlobSolverFromEqSolver.VH.Labels",
      "library": "goblint.constraint",
      "description": "This module provides labeled argument versions of standard `Hashtbl` operations, enhancing readability and safety when working with `VH.t` hashtables. It supports key-based manipulation, iteration, filtering, mapping, and merging, with concrete use cases such as managing labeled key-value pairs in constraint systems or incremental solvers where argument clarity is critical. Functions like `add`, `modify`, and `merge` enable precise, label-driven interactions with hash tables backed by `VH.key` and `VH.t`.",
      "description_length": 510,
      "index": 281,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ConstrSys.GlobSolverFromEqSolver.VH.Infix",
      "library": "goblint.constraint",
      "description": "This module defines infix operators for working with a hash table (`BatHashtbl`). The `-->` operator retrieves the current value bound to a key, while `<--` adds a new binding that can be undone by removing the key. These operations support incremental constraint solving where temporary bindings can be efficiently managed and rolled back.",
      "description_length": 340,
      "index": 282,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ConstrSys.GlobSolverFromEqSolver.EqSys.Var",
      "library": "goblint.constraint",
      "description": "This module defines operations for handling variables in a constraint system, supporting equality checks, hashing, comparison, and pretty-printing. It works with a variant type `t` representing either global or local variables from an underlying solver. Concrete use cases include tracking variable identities, comparing variables for ordering, and generating human-readable or XML representations of variables for debugging or output.",
      "description_length": 435,
      "index": 283,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ConstrSys.GlobConstrSolFromEqConstrSol.VH.Labels",
      "library": "goblint.constraint",
      "description": "This module provides operations for manipulating hash tables with keys of type `VH.key` and arbitrary data values. It supports adding, replacing, modifying, and filtering key-value pairs, as well as mapping, folding, and merging operations over the table entries. These functions are used to construct and transform constraint system solutions by associating labels with intermediate values during constraint resolution.",
      "description_length": 420,
      "index": 284,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ConstrSys.GlobConstrSolFromEqConstrSol.S2.Var",
      "library": "goblint.constraint",
      "description": "This module defines operations for handling variables in a constraint system solution, specifically supporting equality checks, hashing, identification, and pretty-printing. It works with a variant type representing global and local variables. Concrete use cases include tracking variable identities during constraint solving and enabling structured output for debugging or analysis tools.",
      "description_length": 389,
      "index": 285,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ConstrSys.GlobConstrSolFromEqConstrSol.VH.Exceptionless",
      "library": "goblint.constraint",
      "description": "This module provides operations to safely query and update values in a hash table-like structure, specifically working with the `VH.t` type, which represents a variable-indexed mapping. It includes `find` for retrieving optional values by key and `modify` for applying transformations to existing keys with error handling. These operations are used to manipulate constraint solutions during the conversion from equality-based to global constraint systems.",
      "description_length": 455,
      "index": 286,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "ConstrSys.GlobSolverFromEqSolver.EqSys.Dom",
      "library": "goblint.constraint",
      "description": "This module provides lattice operations\u2014join, meet, widening, narrowing, and comparison\u2014on a lifted domain type that combines two underlying domains (`S.G.t` and `S.D.t`) into a single structure with four states (`Bot`, `Lifted1`, `Lifted2`, `Top`). It supports abstract interpretation in static analysis by enabling fixpoint computations over merged global and dataflow value domains, with utilities for serialization and pretty-printing to aid in debugging and result visualization.",
      "description_length": 484,
      "index": 287,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ConstrSys.GlobConstrSolFromEqConstrSol.VH.Infix",
      "library": "goblint.constraint",
      "description": "This module provides functions to convert a solution of an equality constraint system into a solution for a global constraint system. It operates on constraint system data structures, specifically splitting and mapping solutions between different constraint representations. Use cases include solving type inference problems where equality constraints are derived from a larger, more complex constraint system.",
      "description_length": 410,
      "index": 288,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ConstrSys.GlobConstrSolFromEqConstrSol.S2.Dom",
      "library": "goblint.constraint",
      "description": "This module provides lattice operations (join, meet, widen, narrow) and extremal value handling for a sum type combining two distinct abstract domains (`S.G.t` and `S.D.t`) into a unified hierarchy with `Bot`, `Lifted1`, `Lifted2`, and `Top` tags. It supports static analysis workflows requiring precise merging of abstract values from separate domains, particularly in fixpoint iterations where convergence is enforced via widening/narrowing approximations.",
      "description_length": 458,
      "index": 289,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ConstrSys.GlobSolverFromEqSolver.VH.Exceptionless",
      "library": "goblint.constraint",
      "description": "This module provides safe lookup and modification operations for hash tables, returning optional values and result types instead of raising exceptions. It works with hash tables (`Hashtbl`) where keys and values have specific types. Use cases include safely retrieving values without handling exceptions and updating hash table entries in a controlled manner.",
      "description_length": 359,
      "index": 290,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ConstrSys.GlobSolverFromEqSolver.Sol'",
      "library": "goblint.constraint",
      "description": "This module represents solutions of a constraint system built from an equation solver. It supports operations to copy or relift solution data structures and to compute local solutions for variables given initial values. The `solve` function produces a hash map of solutions for specified variables along with serialization data for incremental updates.",
      "description_length": 352,
      "index": 291,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ConstrSys.GlobConstrSolFromEqConstrSol.S2",
      "library": "goblint.constraint",
      "description": "This module computes solutions for a constraint system by transforming assignments from a combined variable and domain representation into a structured format. It operates on variables tagged as either global or local and domains merged from two distinct abstract domains, supporting precise fixpoint computations. Concrete use cases include resolving interdependent constraints in static analysis tools where global and local variable behaviors must be disambiguated during solution refinement.",
      "description_length": 495,
      "index": 292,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ConstrSys.GlobSolverFromEqSolver.Splitter",
      "library": "goblint.constraint",
      "description": "Splits a solution map into two parts using a given function, handling various tagged values. Works with maps of tagged values (`VH.t`) and produces two separate maps (`LH.t` and `GH.t`). Useful for separating constraint solutions based on tags like `Lifted1` or `Lifted2` during constraint system solving.",
      "description_length": 305,
      "index": 293,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ConstrSys.GlobSolverFromEqSolver.VH",
      "library": "goblint.constraint",
      "description": "This module provides a hash table implementation for managing key-value associations with keys of type `EqSys.v`, supporting imperative operations like insertion, lookup, and in-place modification, as well as functional transformations such as mapping, filtering, and merging. It facilitates incremental constraint solving by enabling temporary, reversible bindings and integrates utilities for safe iteration, conversion to/from sequences, and exception-handling. Use cases include scenarios requiring efficient, scoped state management during constraint system resolution.",
      "description_length": 574,
      "index": 294,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ConstrSys.CurrentVarEqConstrSys.S",
      "library": "goblint.constraint",
      "description": "This module implements a constraint system where variables are associated with values through equality constraints, and the `current_var` tracks the variable being evaluated. It provides operations to compute incremental changes to the system based on an existing solution and to query the current state of constraints. Use cases include incremental solving of variable dependencies and maintaining consistent value assignments during constraint propagation.",
      "description_length": 458,
      "index": 295,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ConstrSys.GlobSolverFromEqSolver.EqSys",
      "library": "goblint.constraint",
      "description": "This module represents a constraint system where variables are mapped to values in a combined lattice domain, supporting operations to query and update variable bindings. It works with variables of type `v` and domain values of type `d`, structured as a variant with `Bot`, `Lifted1`, `Lifted2`, and `Top`. Concrete use cases include solving systems of equations in static analysis, where variable assignments are iteratively refined using lattice operations to reach a fixed point.",
      "description_length": 482,
      "index": 296,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ConstrSys.GlobConstrSolFromEqConstrSol.VH",
      "library": "goblint.constraint",
      "description": "This module provides hash table operations for managing variable-to-value mappings with support for efficient lookups, transformations, and merging. It operates on a polymorphic hash table type (`VH.t`) where keys are variables (`S2.Var.t`) and values can be arbitrary, including lists to handle multiple entries per key. These capabilities are particularly useful for decomposing constraint system solutions, enabling tasks like tracking variable assignments or intermediate states during constraint splitting workflows.",
      "description_length": 521,
      "index": 297,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ConstrSys.GlobConstrSolFromEqConstrSol",
      "library": "goblint.constraint",
      "description": "This module transforms a solution from a combined constraint system into separate local and global solutions by splitting variable assignments based on domain tags. It processes hash tables mapping variables to merged domain values and produces distinct solution structures for local and global constraints. Useful in static analysis for separating variable behaviors when refining solutions across interdependent constraint systems.",
      "description_length": 433,
      "index": 298,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ConstrSys.CurrentVarEqConstrSys",
      "library": "goblint.constraint",
      "description": "This module tracks the variable currently being evaluated in a constraint system with equality constraints. It provides direct access to the `current_var` reference and leverages the underlying constraint system module `S` to support incremental updates and state queries. It is used to maintain and propagate variable assignments during constraint solving.",
      "description_length": 357,
      "index": 299,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ConstrSys.GlobSolverFromEqSolver",
      "library": "goblint.constraint",
      "description": "Implements a solver that transforms a system of equations into a global constraint solution by leveraging an existing incremental equation solver. It operates on variable-value mappings with combined lattice domains, using imperative hash tables for efficient updates and scoped state management. This module is used to separate and manage local and global variable bindings during static analysis, refining solutions through iterative constraint application.",
      "description_length": 459,
      "index": 300,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ConstrSys.EqConstrSysFromGlobConstrSys",
      "library": "goblint.constraint",
      "description": "Translates a global constraint system into an equation-based constraint system using variable and domain mappings. It provides a functional representation of the system and computes incremental changes based on an existing solution. Useful for constraint solving where domain updates need to be propagated efficiently through equations.",
      "description_length": 336,
      "index": 301,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ConstrSys.Var2",
      "library": "goblint.constraint",
      "description": "This module combines two variable types, `LV` and `GV`, into a single type `t` to support mixed-variable constraint systems. It provides equality, hashing, comparison, and pretty-printing operations, along with utilities to extract variable identifiers, associated CFG nodes, and XML serialization. It is used in constraint systems that require distinguishing between local and global variables, such as dataflow analysis engines.",
      "description_length": 430,
      "index": 302,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ConstrSys.GlobConstrSolFromEqConstrSolBase",
      "library": "goblint.constraint",
      "description": "This module splits a solution from an equality constraint system into a global constraint system solution using a provided hash table implementation. It operates on tagged values within a constraint system context, producing separate solutions for lifted and non-lifted components. A concrete use case is extracting and separating solution components when solving mixed global and equality constraint systems in program analysis.",
      "description_length": 429,
      "index": 303,
      "embedding_norm": 1.0
    },
    {
      "module_path": "VarQuery",
      "library": "goblint.constraint",
      "description": "This module represents constraint variables tied to global variables or analysis nodes, enabling precise queries for semantic elements. It supports comparing variable queries and resolving global variable references from names using CIL file data. Typical use cases include tracking global variable constraints during analysis and handling node-specific variable queries in incremental analyses.",
      "description_length": 395,
      "index": 304,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ConstrSys",
      "library": "goblint.constraint",
      "description": "This module implements constraint system translations and variable tracking for incremental constraint solving. It transforms global constraint systems into equation-based representations and maintains the current variable state during evaluation. Concrete use cases include propagating domain updates through equation constraints and managing variable assignments during iterative solving processes.",
      "description_length": 400,
      "index": 305,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_solver.SLR.TwoPhased.W.XY.HPM.Exceptionless",
      "library": "goblint.solver",
      "description": "This module provides `find` and `modify` operations for a key-value store structure backed by a heap-passing monad (HPM), working with typed keys and values. It supports exception-free access and in-place updates of values associated with keys, returning result types to handle failure explicitly. Concrete use cases include managing per-thread or per-lock state in static analysis of concurrent programs, where precise heap modifications and lookups are required without raising exceptions.",
      "description_length": 491,
      "index": 306,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.TwoPhased.N.XY.HPM.Labels",
      "library": "goblint.solver",
      "description": "This module implements a labeled map structure for managing key-value pairs with thread-safe operations in constraint-solving contexts. It supports precise value manipulation through functions like `add`, `replace`, `modify`, and both filtered and mapped transformations such as `filter_map` and `map_inplace`. Typical use cases include tracking and updating per-label state during static analysis of multi-threaded programs, particularly for global variable contributions in Goblint.",
      "description_length": 484,
      "index": 307,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.TwoPhased.N.XY.HPM.Infix",
      "library": "goblint.solver",
      "description": "This module defines bidirectional operations between a value and a key in a mutable map structure. It provides the `(-->)` function to retrieve a value by key and `(<--)` to bind a key-value pair, enabling direct manipulation of map entries. These operations are used for efficiently managing per-key state in constraint-solving contexts, such as tracking thread-local contributions in multi-threaded program analysis.",
      "description_length": 418,
      "index": 308,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_solver.SLR.TwoPhased.N.XY.HPM.Exceptionless",
      "library": "goblint.solver",
      "description": "Implements exception-safe operations for modifying and querying a hierarchical key-value structure. Works with `'a N.XY.HPM.t`, a nested map-like type indexed by `N.XY.HPM.key`. Used to safely update and retrieve values in a multi-threaded analysis context where global contributions are aggregated without raising exceptions.",
      "description_length": 326,
      "index": 309,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.TwoPhased.W.XY.HPM.Labels",
      "library": "goblint.solver",
      "description": "This module implements a labeled map structure with efficient modification and traversal operations for handling per-key data transformations and aggregations. It supports key-value operations like insertion, filtering, mapping, and folding, where keys are typed and values can be arbitrary. It is used for tracking and manipulating thread-local contributions in constraint-solving contexts, such as merging and comparing analysis results across program points.",
      "description_length": 461,
      "index": 310,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.TwoPhased.W.XY.HPM.Infix",
      "library": "goblint.solver",
      "description": "This module defines bidirectional operations for mapping and retrieving values associated with keys in a specialized constraint system solver. It provides the `(-->)` and `(<--)` operators for accessing and updating key-value pairs within a solver state. These operations are used to manipulate contributions of global variables during the analysis of multi-threaded C programs.",
      "description_length": 378,
      "index": 311,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_solver.SLR.Make.XY.HPM.Exceptionless",
      "library": "goblint.solver",
      "description": "This module provides operations to safely query and update a map-like structure where values are associated with keys. It supports retrieving values by key and modifying them in place, handling potential errors without raising exceptions. It is used for managing global state contributions in constraint-solving contexts, such as tracking thread-local or shared variable states during static analysis.",
      "description_length": 401,
      "index": 312,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_solver.SLR.TwoPhased.N.H.HeapCompare",
      "library": "goblint.solver",
      "description": "Implements a heap comparison mechanism for variable keys in a priority queue, using a custom ordering function. It operates on types defined by `S.Var.t` and `HM.key`, which represent variables and heap-manipulated keys in constraint systems. This module is used to prioritize variables during constraint solving, particularly in multi-threaded analysis scenarios where efficient heap state management is critical.",
      "description_length": 414,
      "index": 313,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.Make0.XY.HPM.Exceptionless",
      "library": "goblint.solver",
      "description": "This module provides operations for safely querying and modifying a map-like structure that tracks global contributions in a constraint-solving context. It works with polymorphic map (`'a XY.HPM.t`) and key types, supporting exception-free retrieval and transformation of values. Concrete use cases include managing per-key state changes during static analysis of multi-threaded C programs, where updates must handle potential failures without raising exceptions.",
      "description_length": 463,
      "index": 314,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.TwoPhased.W.XY.P",
      "library": "goblint.solver",
      "description": "Implements equality and hashing operations for pairs of variables used in global contribution analysis. Works with tuples of `S.Var.t` types to support tracking inter-procedural data flow. Enables efficient comparison and storage of variable pairs during constraint solving in multi-threaded program analysis.",
      "description_length": 309,
      "index": 315,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.Make0.XY.HPM.Infix",
      "library": "goblint.solver",
      "description": "This module provides direct access and mutation operations for a map-like structure where values are associated with keys of type `XY.HPM.key`. It supports concrete operations such as retrieving a value using the `-->` operator and updating a value with the `<--` operator. It is used for efficiently managing and querying per-key state in constraint solving processes, particularly in the context of analyzing multi-threaded C programs.",
      "description_length": 437,
      "index": 316,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.Make.XY.HPM.Infix",
      "library": "goblint.solver",
      "description": "This module provides direct access to global contribution values using the `(-->)` and `(<--)` operators. It works with key-value pairs where keys are of type `XY.HPM.key` and values are polymorphic. Concrete use cases include querying and updating global state during constraint solving in multi-threaded analysis.",
      "description_length": 315,
      "index": 317,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.TwoPhased.N.XY.P",
      "library": "goblint.solver",
      "description": "This module defines a type `t` as a pair of variables and provides equality and hashing operations for these pairs. It is used to represent and manipulate global contribution values in constraint systems. Concrete use cases include tracking relationships between variables during analysis of multi-threaded programs.",
      "description_length": 316,
      "index": 318,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_solver.SLR.JustWiden.XY.HPM.Infix",
      "library": "goblint.solver",
      "description": "This module defines two operations: `(-->)` for retrieving values associated with keys in a global contribution map, and `(<--)` for updating the map with new key-value pairs. It works with a map structure parameterized over keys of type `XY.HPM.key` and arbitrary values. These operations are used to manage and query per-key contributions in constraint-solving contexts, such as tracking thread-local or global state changes during static analysis.",
      "description_length": 450,
      "index": 319,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.TwoPhased.W.H.HeapCompare",
      "library": "goblint.solver",
      "description": "This module implements a comparison function for heap-managed keys within a priority queue, specifically used in the analysis of multi-threaded C programs. It operates on `HM.key` values, which represent variables in the constraint system, and defines their ordering to prioritize processing during fixed-point iterations. The comparison logic is crucial for efficiently resolving dependencies between variables in the solver's worklist management.",
      "description_length": 448,
      "index": 320,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_solver.Td3.Base.CurrentVarS.S.Dom",
      "library": "goblint.solver",
      "description": "This lattice domain supports standard abstract interpretation operations like join, meet, widen, and narrow over abstract values representing program states, with utilities for comparison, serialization, and domain-specific transformations. It works with abstract domain values (`CurrentVarS.S.Dom.t`) structured to enable efficient incremental analysis and caching within a top-down solver framework. The domain is particularly suited for static analysis tasks requiring iterative refinement of program state approximations, such as detecting runtime errors or optimizing code through path-sensitive dataflow analysis.",
      "description_length": 619,
      "index": 321,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.TwoPhased.W.XY.HPM",
      "library": "goblint.solver",
      "description": "This module implements a polymorphic hash table with key-value maps backed by a heap-passing monad (HPM), supporting operations like insertion, lookup, filtering, and functional transformations over keys of type `W.XY.P.t`. It provides specialized tools for constraint solving in concurrent program analysis, including exception-safe access, infix operators for solver state manipulation, and labeled map transformations. The data structures are optimized for static analysis tasks requiring efficient key-value enumeration, merging, and iterative refinement in multi-threaded contexts.",
      "description_length": 586,
      "index": 322,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.Td3.Base.CurrentVarS.S.Var",
      "library": "goblint.solver",
      "description": "This module represents and manipulates variables within a constraint system, specifically tracking variable states during analysis. It provides operations for equality checks, hashing, comparison, and pretty-printing variables, along with extracting associated CFG nodes and variable identifiers. It is used to manage variable identities and properties in the context of incremental constraint solving and abstract interpretation.",
      "description_length": 430,
      "index": 323,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.Make.XY.HPM.Labels",
      "library": "goblint.solver",
      "description": "This module provides operations for manipulating key-value maps with efficient in-place modifications and functional transformations. It supports associative operations like `add`, `replace`, `modify`, and `merge`, along with iteration, filtering, and folding over labeled entries. Concrete use cases include tracking and updating per-label analysis results in constraint solvers for multi-threaded program analysis.",
      "description_length": 416,
      "index": 324,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.TwoPhased.N.XY.HPM",
      "library": "goblint.solver",
      "description": "This module implements a hash-based key-value map structure with keys of type `N.XY.P.t`, offering operations for creation, modification, iteration, and analysis of mappings. It supports both pure functional transformations and in-place updates, with utilities for merging, filtering, and converting between data representations like sequences and lists. Designed for multi-threaded static analysis, it includes thread-safe value manipulation, exception-safe access patterns, and syntactic extensions for bidirectional map operations, catering to constraint system resolution and global state tracking in concurrent contexts.",
      "description_length": 625,
      "index": 325,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.JustWiden.XY.HPM.Exceptionless",
      "library": "goblint.solver",
      "description": "This module provides `find` and `modify` operations for safely accessing and updating values associated with keys in a map structure. It works with map-like structures parameterized over values and keys, handling potential errors during modification without raising exceptions. Concrete use cases include managing thread-local state or propagating constraints in static analysis where safe key-value manipulations are critical.",
      "description_length": 427,
      "index": 326,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.Make0.XY.HPM.Labels",
      "library": "goblint.solver",
      "description": "This module provides operations for manipulating key-value maps with efficient in-place and functional transformations. It supports associative operations like `add`, `replace`, `modify`, and `merge`, as well as traversal and filtering functions that allow conditional updates or selective iteration over entries. It is used for tracking and combining per-key data in constraint-solving contexts, such as aggregating thread-local contributions or propagating global state changes.",
      "description_length": 480,
      "index": 327,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.JustWiden.XY.HPM.Labels",
      "library": "goblint.solver",
      "description": "This module provides operations for manipulating key-value maps with efficient in-place updates and functional transformations. It supports associative operations like `add`, `replace`, and `modify`, along with higher-order functions such as `map`, `filter`, `fold`, and `merge`, all working on maps parameterized over keys of type `XY.HPM.key` and arbitrary data types. These operations are used to track and transform global contributions in constraint-solving contexts, particularly during widening in multi-threaded analysis.",
      "description_length": 529,
      "index": 328,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.SLR3.HPM.Infix",
      "library": "goblint.solver",
      "description": "This module provides two primary operations: `(-->)` for retrieving values associated with a key from a hash pointer map (HPM), and `(<--)` for inserting or updating a key-value pair in the map. It works with the `HPM.t` type, which represents a hash-based pointer map, and `HPM.key`, which serves as the key type for indexing into the map. These operations are used to efficiently manage and query pointer-based mappings in constraint solving scenarios, particularly in the context of analyzing multi-threaded C programs.",
      "description_length": 522,
      "index": 329,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_solver.SLR.TwoPhased.N.XY",
      "library": "goblint.solver",
      "description": "This module manages global contribution values in constraint systems using a hash-based map with variable-pair keys. It supports operations for storing, retrieving, and modifying analysis results during multi-threaded program analysis. Direct use cases include tracking variable relationships and maintaining global state in static analysis passes.",
      "description_length": 348,
      "index": 330,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.SLR3.VS.Labels",
      "library": "goblint.solver",
      "description": "This module provides operations for manipulating sets of labels, including iteration, folding, filtering, mapping, and partitioning. It works with the `VS.t` type representing sets of label elements. Concrete use cases include processing and analyzing sets of thread-local or global labels in constraint systems for multi-threaded program analysis.",
      "description_length": 348,
      "index": 331,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_solver.SLR.TwoPhased.N.D",
      "library": "goblint.solver",
      "description": "This module provides lattice operations (join, meet, widen, narrow, top), comparison functions (equality, ordering), and pretty-printing utilities for a domain structured as `N.D.t`, derived from `S.d`. It supports abstract interpretation in static analysis of multi-threaded C programs, enabling constraint system solving through domain-specific value manipulation like top checks and least upper bound computations. These operations facilitate solver integration and domain-specific reasoning in frameworks such as Goblint.",
      "description_length": 525,
      "index": 332,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.PostSolver.MakeList.S.Dom",
      "library": "goblint.solver",
      "description": "This module provides lattice operations (join, meet, widen, narrow, leq) and domain value manipulations (equality, hashing, ordering, serialization) for abstract domain values of type `S.Dom.t`. It supports static analysis tasks requiring precise comparison and combination of program states, such as constraint system evaluation, pruning, and verification, with utilities for debugging via string/XML/Yojson representations. The lattice semantics and top element checks enable analyses that track abstract values through iterative solving and post-processing phases.",
      "description_length": 567,
      "index": 333,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_solver.SLR.TwoPhased.W.X",
      "library": "goblint.solver",
      "description": "This module manages value and priority associations for constraint solving, using hash maps to store domain-specific values and keys. It provides direct access and mutation operations for keyed values, supporting efficient lookups and updates. Concrete use cases include tracking and retrieving analysis results during the solving of multi-threaded C program constraints.",
      "description_length": 371,
      "index": 334,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.TwoPhased.W.D",
      "library": "goblint.solver",
      "description": "This module implements lattice operations for a domain used in constraint system analysis, including join, meet, widen, and narrow operations alongside comparison and serialization utilities. It works with abstract values of type `W.D.t` (aliased from `S.d`), structured as a lattice with support for both analysis and debugging workflows. The domain is specifically designed for static analysis of multi-threaded programs, enabling precise handling of concurrency-related constraints through its algebraic and topological properties.",
      "description_length": 534,
      "index": 335,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.TwoPhased.N.X",
      "library": "goblint.solver",
      "description": "This module manages value and priority associations for constraint solving, using hash maps to store and retrieve domain-specific values and keys. It provides direct access to values via keys, key indexing, and snapshot capabilities for solver states. Concrete use cases include tracking variable assignments and priorities during iterative fixed-point computations in multi-threaded analysis.",
      "description_length": 393,
      "index": 336,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_solver.SLR.SLR3.VS.Exceptionless",
      "library": "goblint.solver",
      "description": "This module provides functions for querying and selecting elements from a set-like structure `VS.t`, including retrieving minimum, maximum, and arbitrary elements. It supports operations like `find` to locate a specific element and `choose`/`any` to pick an element non-deterministically. These functions are used in constraint solving to handle value set analysis without exceptions, enabling precise and efficient exploration of possible values in static analysis of multi-threaded C programs.",
      "description_length": 495,
      "index": 337,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLRterm.SLR3term.VS.Exceptionless",
      "library": "goblint.solver",
      "description": "This module provides operations for querying and selecting elements from a set structure, including retrieving minimum, maximum, and arbitrary elements. It works with sets of type `VS.t` and individual elements of type `VS.elt`, supporting lookup and non-deterministic selection without raising exceptions. Concrete use cases include analyzing constraint systems where element presence and extremal values must be determined safely and efficiently.",
      "description_length": 448,
      "index": 338,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_solver.SLR.TwoPhased.W.XY",
      "library": "goblint.solver",
      "description": "This module manages global contributions in constraint solving for multi-threaded program analysis. It uses a polymorphic hash table (HPM) with variable pairs (P.t) as keys to track inter-procedural data flow, supporting efficient key-value operations, default lookups, and value updates. Concrete use cases include storing and retrieving analysis results for variable pairs during iterative constraint solving in concurrent C programs.",
      "description_length": 436,
      "index": 339,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.TopDown_term.WP.VS.Exceptionless",
      "library": "goblint.solver",
      "description": "This module provides operations for querying and selecting elements from a set-like structure `VS.t`, including retrieving minimum, maximum, and arbitrary elements. It supports concrete use cases such as extracting representative values or boundary elements from a solution set during constraint solving. Functions like `find` enable lookup by specific elements, while `any` and `choose` support non-deterministic selection.",
      "description_length": 424,
      "index": 340,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLRphased.Make.HPM.Labels",
      "library": "goblint.solver",
      "description": "This module provides hash-preserving map operations for labeled data in a two-phased solver context. It supports key-based addition, modification, filtering, and merging of map entries, where each entry is associated with a key of type `HPM.key` and data of a generic type `'a`. These operations are designed for efficiently managing and transforming constraint system data during fixed-point computations in a phased solver.",
      "description_length": 425,
      "index": 341,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_solver.Td3.Base.CurrentVarS.S",
      "library": "goblint.solver",
      "description": "This module implements a constraint system solver interface for incremental abstract interpretation, providing operations to query and update variable bindings in a lattice domain. It supports variable resolution through the `sys_change` function, which tracks changes to variable assignments, and the `system` function, which retrieves constraint definitions for specific variables. Designed for use in static analysis workflows where program state abstractions must be efficiently recomputed after small code changes, such as in interactive or iterative analysis tools.",
      "description_length": 571,
      "index": 342,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.PrintInfluence.S1.X",
      "library": "goblint.solver",
      "description": "Implements influence analysis for constraint systems using a specialized SLR solver. It tracks variable dependencies through hash maps (`HM.t`) and provides functions to print influence graphs based on keyed variables. Useful for analyzing data flow and side effects in multi-threaded C programs during static analysis.",
      "description_length": 319,
      "index": 343,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.TopDown.WP.HPM.Exceptionless",
      "library": "goblint.solver",
      "description": "This module implements a top-down solver for constraint systems that avoids exception handling in its operations. It provides functions like `find` for retrieving values associated with keys and `modify` for updating values in a thread-safe, exceptionless manner. It works with constraint stores represented as HPM (hash-based polymorphic maps) structures, where keys are typically variables or expressions and values represent constraint information. Use cases include incremental analysis of program variables where constraints are propagated top-down without requiring full recomputation or handling of exceptions during modification.",
      "description_length": 637,
      "index": 344,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.Worklist.Make.VS.Exceptionless",
      "library": "goblint.solver",
      "description": "This module implements a worklist solver for constraint systems using a set-like structure `VS.t`, providing operations to select elements for processing. It supports concrete tasks like retrieving the minimum, maximum, or any arbitrary element from the worklist, as well as finding a specific element. These functions enable efficient traversal and modification of constraint states in solver algorithms.",
      "description_length": 405,
      "index": 345,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLRterm.SLR3term.VS.Labels",
      "library": "goblint.solver",
      "description": "This module provides operations for manipulating sets of variables (represented as `VS.t`) within a constraint-solving context. It includes functions for iteration, folding, filtering, mapping, and partitioning variable sets based on boolean conditions. These operations are used to analyze and transform variable labels during the execution of the SLR3 solver, particularly in tracking and processing variable dependencies in constraint systems.",
      "description_length": 446,
      "index": 346,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.EffectWConEq.Make.VS.Labels",
      "library": "goblint.solver",
      "description": "This module provides operations for manipulating sets of labels, including iteration, folding, filtering, and partitioning. It works with label sets using functions that transform, select, or combine elements based on boolean conditions. Concrete use cases include tracking control-flow labels in static analysis and managing sets of program points during constraint solving.",
      "description_length": 375,
      "index": 347,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLRterm.SLR3term.HPM.Infix",
      "library": "goblint.solver",
      "description": "This module defines infix operators for accessing and updating values in a hierarchical property map (`HPM.t`). The `-->` operator retrieves a value using a key, while `<--` assigns a value to a key. These operations support concise manipulation of nested data structures in constraint-solving contexts, such as tracking and updating analysis results during fixed-point computations.",
      "description_length": 383,
      "index": 348,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLRterm.SLR3term.HPM.Labels",
      "library": "goblint.solver",
      "description": "This module provides operations for manipulating hash-based polymorphic maps (HPM) with typed keys and values. It supports key-value transformations, filtering, iteration, and merging with custom functions applied per entry. Concrete use cases include tracking and updating constraint labels during analysis, efficiently modifying solver state, and merging intermediate results with key-specific logic.",
      "description_length": 402,
      "index": 349,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_solver.TopDown_space_cache_term.WP.VS.Exceptionless",
      "library": "goblint.solver",
      "description": "This module provides operations for querying and selecting elements from a set structure (`VS.t`), including retrieving minimum, maximum, arbitrary, and specific elements. It works with sets of elements that support comparison and membership operations. Concrete use cases include efficiently extracting representative or extremal values from solution spaces during constraint solving.",
      "description_length": 385,
      "index": 350,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.TopDown.WP.HPM.Labels",
      "library": "goblint.solver",
      "description": "This module provides operations for manipulating hash-based persistent maps (HPM) with labeled keys, supporting imperative updates and transformations. It includes functions for adding, replacing, filtering, mapping, and folding over key-value pairs, as well as in-place modifications and conditional updates. Concrete use cases include tracking and transforming analysis state during constraint solving, such as propagating labels through a top-down analysis or refining value abstractions based on key-specific logic.",
      "description_length": 519,
      "index": 351,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.Td3.Base.VS.Labels",
      "library": "goblint.solver",
      "description": "This module provides standard set-like operations such as iteration, folding, filtering, and mapping over a collection of elements. It supports operations to inspect, transform, and partition the collection based on predicates applied to individual elements. These functions are used to manipulate sets of labels during constraint solving, enabling precise control over value propagation and tracking in the analysis.",
      "description_length": 417,
      "index": 352,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.PostSolver.MakeList.S.Var",
      "library": "goblint.solver",
      "description": "This module provides operations for comparing, hashing, and pretty-printing variable identifiers, along with utilities to check variable properties and extract associated CFG nodes. It works with the abstract variable type `S.Var.t`, which represents variables in the constraint system. Concrete use cases include tracking variable identities across analyses, generating readable debug output, and supporting XML serialization for external tools.",
      "description_length": 446,
      "index": 353,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_solver.SLR.JustWiden.XY.P",
      "library": "goblint.solver",
      "description": "This module defines a type `t` as pairs of variables and provides equality and hashing operations for these pairs. It is used to represent and manipulate global contribution values in constraint systems. Concrete use cases include tracking variable interactions and managing symbolic representations in static analysis of multi-threaded programs.",
      "description_length": 346,
      "index": 354,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.TopDown_deprecated.TD3.HPM.Exceptionless",
      "library": "goblint.solver",
      "description": "This module implements a top-down constraint-solving strategy based on a modified SLR3 algorithm, operating on constraint systems represented in HPM structures. It provides `find` to retrieve values associated with keys and `modify` to update them, returning results in a wrapped type that handles potential errors. These operations are used to manipulate constraint environments during analysis, particularly in contexts where exceptions are avoided in favor of explicit error handling.",
      "description_length": 487,
      "index": 355,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.TwoPhased.W.L",
      "library": "goblint.solver",
      "description": "Implements operations for maintaining and querying influence lists, which track dependencies between variables in constraint systems. It provides functions to add an element to a variable's influence list, subtract (retrieve) all elements for a variable, and remove a specific item from a variable's list. Used during fixed-point computations to efficiently manage variable dependencies and re-evaluation triggers.",
      "description_length": 414,
      "index": 356,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_solver.SLR.Make.XY.P",
      "library": "goblint.solver",
      "description": "Implements equality and hashing operations for pairs of variables used in constraint systems. Works with tuples of type `S.Var.t * S.Var.t`, where `S.Var.t` represents variables in a solver context. Useful for tracking and comparing global contributions in multi-threaded analysis scenarios.",
      "description_length": 291,
      "index": 357,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.TwoPhased.N.P",
      "library": "goblint.solver",
      "description": "This module provides operations to manage a set of keys within a hash table (`HM.t`), where each key represents a dependency or element in a constraint system. It supports concrete use cases like tracking dependencies for global variables and maintaining stable sets during constraint solving. Key functions include inserting, removing, checking existence, and converting the set to a list.",
      "description_length": 390,
      "index": 358,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.TwoPhased.W.T",
      "library": "goblint.solver",
      "description": "This module tracks variable dependencies and enforces constraints during analysis of multi-threaded C programs. It provides direct access to variable mappings via `sub`, updates mappings with `update`, and maintains a global set of variable dependencies through `set`. Concrete use cases include managing interference between threads and resolving memory accesses in static analysis.",
      "description_length": 383,
      "index": 359,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.Make0.XY.HPM",
      "library": "goblint.solver",
      "description": "This module provides imperative hash map operations for managing key-value pairs with keys of type `XY.P.t` and polymorphic values, supporting constraint system analysis in static program verification. It includes functionalities for insertion, lookup, iteration, filtering, merging, and structural transformations, alongside exception-safe value handling and infix syntax for direct access. Designed for analyzing multi-threaded C programs, it enables efficient manipulation of dynamic constraint data and label-based key-value transformations in solver algorithms.",
      "description_length": 566,
      "index": 360,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.TwoPhased.N.H",
      "library": "goblint.solver",
      "description": "This module implements a priority queue with efficient insertion and extraction of minimal elements, using a heap structure ordered by variable keys. It supports operations like merging queues, adding elements, and retrieving or removing the smallest element, all tailored for constraint system variables (`S.Var.t`) and heap keys (`HM.key`). It is used in multi-threaded static analysis to manage priority-based processing of variables during constraint solving.",
      "description_length": 463,
      "index": 361,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLRphased.Make.HPM.Exceptionless",
      "library": "goblint.solver",
      "description": "This module provides a two-phased SLR3 solver for constraint systems using a box abstraction, focusing on handling modifications and lookups in a hash-based pointer map (HPM). It supports operations like `find` for retrieving values by key and `modify` for updating values with functions, returning a result type to handle potential errors. It is used in static analysis to solve constraints over abstract domains with boxed values, particularly in contexts requiring precise fixpoint computations without exceptions.",
      "description_length": 517,
      "index": 362,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.Make.XY.HPM",
      "library": "goblint.solver",
      "description": "This module provides imperative hash map operations and functional transformations over key-value stores where keys are of type `XY.P.t` and values are polymorphic. It supports constraint-solving workflows by enabling efficient updates, conditional modifications, and merging of global state contributions, with utilities for structured iteration, custom formatting, and safe access in multi-threaded analysis contexts.",
      "description_length": 419,
      "index": 363,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.TwoPhased.N.T",
      "library": "goblint.solver",
      "description": "This module tracks variable dependencies and relationships during constraint solving. It uses hash maps (HM.t) to store and update variable bindings, supporting operations to set, update, and query variable values. It is used to manage variable state and dependencies in multi-threaded constraint systems.",
      "description_length": 305,
      "index": 364,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.TwoPhased.W.H",
      "library": "goblint.solver",
      "description": "This module implements a priority queue for managing heap-allocated keys in a constraint solver, using a heap structure ordered by a custom comparison function. It supports operations like insertion, extraction of the minimum element, merging of heaps, and conversions to and from lists and enumerations. It is used to prioritize variables during fixed-point analysis of multi-threaded C programs, ensuring efficient resolution of dependencies.",
      "description_length": 444,
      "index": 365,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.Make0.XY.P",
      "library": "goblint.solver",
      "description": "This module defines a data structure representing pairs of variables and provides equality and hashing operations for them. It works with tuples of type `S.Var.t`, where `S.Var` represents variables in a constraint system. Concrete use cases include tracking and comparing variable pairs in global contribution analysis during constraint solving.",
      "description_length": 346,
      "index": 366,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_solver.EffectWConEq.Make.VS.Exceptionless",
      "library": "goblint.solver",
      "description": "This module provides operations for querying and selecting elements from a set-like structure `VS.t`, including retrieving minimum, maximum, arbitrary, and specific elements. It works with ordered element types `VS.elt` and set representations `VS.t` that support comparison and traversal. Concrete use cases include extracting representative values from abstract domains during constraint solving, such as selecting a concrete integer from a range or a memory address from a points-to set.",
      "description_length": 490,
      "index": 367,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.TwoPhased.N.L",
      "library": "goblint.solver",
      "description": "This module provides operations to manipulate influence lists stored in a hash map. It supports adding an element to a list associated with a key, removing a specific element from a list, and retrieving the list after removal. These functions are used to track dependencies or influences in constraint systems, particularly during fixed-point computations in program analysis.",
      "description_length": 376,
      "index": 368,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_solver.SLR.TwoPhased.W.P",
      "library": "goblint.solver",
      "description": "This module provides operations for managing a set of keys within a constraint system, specifically supporting insertion, removal, membership checks, and conversion to a list. It works with a hidden map (`HM`) structure where keys represent variables or constraints. Concrete use cases include tracking dependencies during constraint solving and maintaining a stable set of variables in global analysis phases.",
      "description_length": 410,
      "index": 369,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.Worklist.Make.VS.Labels",
      "library": "goblint.solver",
      "description": "Implements a worklist solver for constraint systems using a set of labels, where each label represents a constraint or equation. It provides operations to iterate, fold, filter, and map over the labels, enabling precise control over constraint processing. Useful for solving dataflow analyses where dependencies between labeled constraints must be tracked and resolved in a specific order.",
      "description_length": 389,
      "index": 370,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_solver.TopDown_deprecated.TD3.VS.Labels",
      "library": "goblint.solver",
      "description": "This module provides set operations for label values, including iteration, folding, filtering, mapping, and partitioning. It works with sets of label elements (`VS.t`) to support analysis tasks like tracking variable assignments or control flow paths. Concrete use cases include managing label sets during static analysis to determine reachability or data flow properties.",
      "description_length": 372,
      "index": 371,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_solver.TopDown.WP.HPM.Infix",
      "library": "goblint.solver",
      "description": "This module provides infix operators for constraint propagation in a top-down solver. It works with constraint systems represented as maps from keys to values. The `-->` operator retrieves a value for a key, while `<--` adds a constraint to the system, enabling concise manipulation of constraints during analysis.",
      "description_length": 314,
      "index": 372,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_solver.PostSolver.MakeList.VH.Labels",
      "library": "goblint.solver",
      "description": "This module provides operations for manipulating hash tables with keys of type `VH.key` and values of a fixed type `Label.t`. It supports standard imperative operations like `add`, `replace`, `modify`, and `filter_inplace`, as well as functional transformations like `map`, `filter_map`, and `fold`. Concrete use cases include tracking and transforming constraint labels during postsolving, such as pruning redundant constraints or generating warnings based on label properties.",
      "description_length": 478,
      "index": 373,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.TopDown_deprecated.TD3.HPM.Infix",
      "library": "goblint.solver",
      "description": "This module provides imperative get and set operations for a constraint system solver, using a top-down approach. It manipulates a map-like structure indexed by keys to store and retrieve values during constraint resolution. Concrete use cases include tracking and updating variable bindings or intermediate results in a deprecated top-down solver implementation.",
      "description_length": 363,
      "index": 374,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.TopDown.WP.VS.Labels",
      "library": "goblint.solver",
      "description": "This module implements a set of label manipulation operations for constraint solving, including iteration, folding, filtering, and partitioning over a value set (`VS.t`). It supports concrete operations like applying a function to each label, accumulating values across labels, checking predicate conditions, and transforming or splitting label sets based on user-defined functions. Typical use cases include tracking and processing constraint labels during top-down analysis, such as filtering relevant constraints or mapping labels to new values during solver iterations.",
      "description_length": 573,
      "index": 375,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_solver.SLRterm.SLR3term.HPM.Exceptionless",
      "library": "goblint.solver",
      "description": "This module provides operations for safely querying and modifying values in a constraint system's map, specifically handling key-based access and updates without raising exceptions. It works with `'a HPM.t`, a map type indexed by keys, and supports result-typed modifications where changes can fail. Concrete use cases include updating constraint values during analysis while gracefully handling missing keys or invalid states.",
      "description_length": 427,
      "index": 376,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.TopDown_term.WP.VS.Labels",
      "library": "goblint.solver",
      "description": "This module provides operations for manipulating sets of labels in the context of a top-down constraint solver. It supports iteration, folding, filtering, mapping, and partitioning over label sets with specialized functions that enable precise control over constraint propagation. Typical use cases include tracking variable assignments and managing symbolic execution paths in static analysis.",
      "description_length": 394,
      "index": 377,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.SLR3.HPM.Exceptionless",
      "library": "goblint.solver",
      "description": "This module provides operations for safely querying and modifying values in a constraint system's map structure, specifically using `find` to retrieve values by key and `modify` to apply transformations with error handling. It works with polymorphic maps (`'a HPM.t`) and keys (`HPM.key`), supporting precise manipulation of constraint states during analysis. Concrete use cases include updating variable bindings and propagating constraints in static analysis of multi-threaded C programs.",
      "description_length": 490,
      "index": 378,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.SLR3.HPM.Labels",
      "library": "goblint.solver",
      "description": "This module provides operations for manipulating hash-based property maps with labeled keys, supporting insertion, modification, iteration, and transformation of key-value pairs. It works directly with `HPM.t` structures, which are typed maps using `HPM.key` as identifiers, and supports both pure and in-place updates. Concrete use cases include tracking and transforming analysis state in constraint solvers, such as managing per-label data during static analysis of multi-threaded programs.",
      "description_length": 493,
      "index": 379,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLRphased.Make.HPM.Infix",
      "library": "goblint.solver",
      "description": "This module provides imperative get and set operations for a phased constraint solver's heap-like structure, using the `-->` and `<--` operators. It works with polymorphic heap path maps (`HPM.t`) and their associated keys and values. Concrete use cases include efficiently propagating and storing intermediate constraint solutions during the two-phased SLR3 solving process.",
      "description_length": 375,
      "index": 380,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLRphased.Make.VS.Labels",
      "library": "goblint.solver",
      "description": "Implements label set operations for constraint solving with a two-phased SLR3 algorithm. Works with `VS.t` sets of labels, providing iteration, folding, filtering, mapping, and partitioning functions. Used to manipulate and analyze label sets during static analysis of programs with side-effecting constraints.",
      "description_length": 310,
      "index": 381,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_solver.TopDown_deprecated.TD3.HPM.Labels",
      "library": "goblint.solver",
      "description": "This module provides hash table operations for managing key-value pairs with specialized functions for iteration, filtering, mapping, and in-place modifications. It works with hash tables (`HPM.t`) that use `HPM.key` as the key type and arbitrary data types for values. Concrete use cases include efficiently updating constraint system entries, filtering or transforming solver state data, and merging hash tables during analysis phases of program verification.",
      "description_length": 461,
      "index": 382,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_solver.PostSolver.MakeList.VH.Infix",
      "library": "goblint.solver",
      "description": "This module provides infix operators `(-->)` and `(<--)` for accessing and updating values in a hash table-like structure `VH.t`. It works directly with the `VH.t` type, which represents a map from keys to values, supporting key-based lookups and assignments. These operations are used to manipulate constraint system variables during postsolving passes, such as retrieving or setting analysis results for specific keys in a concise manner.",
      "description_length": 440,
      "index": 383,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.PostSolver.MakeList.VH.Exceptionless",
      "library": "goblint.solver",
      "description": "This module implements a list-based postsolver that processes constraint systems for tasks like warning generation or result pruning. It operates on value hierarchies (`VH.t`) with key-based access, supporting lookup and modification operations. Use it to apply a sequence of analysis passes after constraint solving, where each pass may transform values or raise exceptions.",
      "description_length": 375,
      "index": 384,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.TopDown_space_cache_term.WP.VS.Labels",
      "library": "goblint.solver",
      "description": "This module operates on sets of labels used in the context of a top-down constraint solver, providing functions to iterate, fold, filter, and map over these sets. It supports operations like checking membership conditions, partitioning sets, and applying transformations to elements. These functions are used to manipulate label sets during the solving process, such as tracking or filtering constraints based on specific label criteria.",
      "description_length": 437,
      "index": 385,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.TopDown_deprecated.TD3.VS.Exceptionless",
      "library": "goblint.solver",
      "description": "This module provides operations for querying and selecting elements from a set-like structure `VS.t`, including retrieving minimum, maximum, and arbitrary elements. It supports concrete use cases such as extracting representative values from constraint solution sets or selecting pivot elements during analysis refinement. The functions operate on `VS.t` collections and return optional elements, enabling safe handling of empty inputs.",
      "description_length": 436,
      "index": 386,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.TopDown.WP.VS.Exceptionless",
      "library": "goblint.solver",
      "description": "This module provides operations for querying and selecting elements from a set-like structure `VS.t`, including retrieving minimum, maximum, and arbitrary elements. It supports concrete use cases such as extracting representative values or boundary elements from a solution set during constraint solving. Functions like `find` enable direct lookups, while `any` and `choose` support non-deterministic selection strategies.",
      "description_length": 422,
      "index": 387,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_solver.SLRphased.Make.VS.Exceptionless",
      "library": "goblint.solver",
      "description": "This module provides operations for querying and selecting elements from a set structure `VS.t`, including retrieving minimum, maximum, and arbitrary elements. It supports concrete use cases like iterating over set elements in specific orders or extracting representative values during constraint solving. Functions like `find` and `choose` enable direct element access without exceptions, facilitating robust set manipulation in solver algorithms.",
      "description_length": 448,
      "index": 388,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.JustWiden.H.HeapCompare",
      "library": "goblint.solver",
      "description": "This module defines a comparison function for keys used in a priority queue, specifically tailored for constraint system solving in multi-threaded C analysis. It operates on `HM.key` values, which represent variables in the constraint system. The comparison is used to prioritize variables during the widening phase of the solver.",
      "description_length": 330,
      "index": 389,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_solver.SLR.Make0.H.HeapCompare",
      "library": "goblint.solver",
      "description": "Implements a comparison function for heap keys used in priority queues during constraint solving. Works with `S.Var.t` types representing variables in constraint systems. Used to prioritize variables based on heap properties in the box solver's SLR algorithm.",
      "description_length": 259,
      "index": 390,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.Td3.Base.VS.Exceptionless",
      "library": "goblint.solver",
      "description": "This module provides operations for querying and selecting elements from a set-like structure `VS.t`, including retrieving minimum, maximum, arbitrary, or specific elements. It works with abstract element types `VS.elt` that are members of sets `VS.t`, typically representing values in a constraint system. Concrete use cases include extracting representative values during constraint solving or analysis, such as selecting a value to propagate or checking for the presence of a specific element in a solution state.",
      "description_length": 516,
      "index": 391,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.Make.H.HeapCompare",
      "library": "goblint.solver",
      "description": "Implements a heap comparison mechanism for priority queues using variable keys. It provides a `compare` function that orders heap elements based on their underlying variable identifiers. This module is used to prioritize variables during constraint solving in multi-threaded analysis.",
      "description_length": 284,
      "index": 392,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.JustWiden.X",
      "library": "goblint.solver",
      "description": "This module manages value and priority associations for constraint solving, using hash maps to store and retrieve domain-specific values and keys. It provides direct access and mutation operations for keyed entries, supporting dynamic analysis tasks like fixed-point computations. Concrete use cases include tracking and updating variable states during iterative solver runs.",
      "description_length": 375,
      "index": 393,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_solver.SLR.Make0.H",
      "library": "goblint.solver",
      "description": "This module implements a priority queue with operations for adding, merging, and removing elements based on a custom comparison function defined in `HeapCompare`. It works with elements of type `S.Var.t`, prioritizing variables during constraint solving in the box solver's SLR algorithm. Concrete use cases include managing variable processing order and efficiently extracting minimum-priority elements during iterative constraint resolution.",
      "description_length": 443,
      "index": 394,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.Make0.P",
      "library": "goblint.solver",
      "description": "This module provides operations for managing a set of keys within a hash table structure, specifically supporting insertion, removal, membership checks, and conversion to a list. It works with a hash table (`HM.t`) where values are units, effectively representing a set of keys. It is used for tracking dependencies in the solver\u2019s stable set and global variable handling.",
      "description_length": 372,
      "index": 395,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.TopDown_deprecated.TD3.P",
      "library": "goblint.solver",
      "description": "This module defines a data type `t` as a pair of variables and provides equality and hashing operations for it. It supports key manipulations for constraint solving in a deprecated top-down solver implementation. Used specifically for managing variable pairs in the context of modified SLR3-based analysis.",
      "description_length": 306,
      "index": 396,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.Make0.L",
      "library": "goblint.solver",
      "description": "Implements operations for maintaining and manipulating influence lists, which track dependencies between constraints during fixed-point computations. It provides functions to add an element to a list associated with a key, retrieve and remove a list associated with a key, and remove a specific item from a key's list. Used in constraint solvers to efficiently manage dependencies and re-evaluate affected constraints when values change.",
      "description_length": 437,
      "index": 397,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.JustWiden.D",
      "library": "goblint.solver",
      "description": "This module implements lattice operations for a domain type `D.t`, including comparison, join (least upper bound), meet, widening, and narrowing, which are essential for solving constraint systems in abstract interpretation. It provides foundational utilities like top element creation, equality checks, and serialization, supporting analyses in multi-threaded environments. These operations enable scalable and precise static analysis of concurrent programs, particularly for frameworks requiring iterative fixed-point computations with domain-specific abstractions.",
      "description_length": 567,
      "index": 398,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.Make0.T",
      "library": "goblint.solver",
      "description": "This module tracks variable dependencies and manages variable assignments in constraint systems. It uses hash maps (`HM.t`) to store and update variable values, supporting operations to set, update, and retrieve variable bindings. Concrete use cases include managing variable states during constraint solving in static analysis of multi-threaded C programs.",
      "description_length": 357,
      "index": 399,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.PrintInfluence.S1",
      "library": "goblint.solver",
      "description": "Implements influence analysis for constraint systems using a specialized SLR solver. It tracks variable dependencies through hash maps (`HM.t`) and provides functions to print influence graphs based on keyed variables. Useful for analyzing data flow and side effects in multi-threaded C programs during static analysis.",
      "description_length": 319,
      "index": 400,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.Make0.XY",
      "library": "goblint.solver",
      "description": "This module manages global contributions in a constraint system using a hash map structure keyed by variable pairs. It provides operations to retrieve and update values associated with these pairs, supporting static analysis of multi-threaded C programs. Concrete use cases include tracking variable interactions during constraint solving and enabling efficient lookups with default values.",
      "description_length": 390,
      "index": 401,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_solver.Td3.Base.CurrentVarS",
      "library": "goblint.solver",
      "description": "Maintains and updates the current variable context during constraint system solving. It provides direct access to the current variable being processed via `current_var` and interacts with the constraint system interface defined in `S` to resolve variable bindings and track changes. Useful in incremental abstract interpretation for efficiently recomputing analysis results when analyzing small code modifications interactively.",
      "description_length": 428,
      "index": 402,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLRphased.Make.VS",
      "library": "goblint.solver",
      "description": "This module provides ordered set operations for manipulating collections of variables (`S.Var.t`) with support for set-theoretic operations (union, intersection, difference), ordered traversal (iteration, folding, partitioning), and structural conversions to/from lists, arrays, and sequences. It emphasizes efficient element selection (min, max, arbitrary) and rank-based access, alongside label-specific transformations for static analysis tasks like constraint system solving. These capabilities are particularly useful in phased solver contexts where ordered variable sets must be processed incrementally or partitioned during analysis stages.",
      "description_length": 647,
      "index": 403,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.Make.XY",
      "library": "goblint.solver",
      "description": "Implements equality, hashing, and efficient key-value operations for pairs of solver variables in constraint systems. Works with tuples of `S.Var.t` variables and polymorphic values in imperative hash maps. Used to track and update global contributions during multi-threaded analysis, enabling precise state merging and conditional modifications.",
      "description_length": 346,
      "index": 404,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_solver.TopDown_space_cache_term.WP.P",
      "library": "goblint.solver",
      "description": "This module defines a data structure for representing pairs of variables and provides equality and hashing operations. It works with tuples of type `S.Var.t * S.Var.t`, where `S.Var.t` represents variables in a constraint system. Concrete use cases include tracking variable relationships in constraint solving, such as in alias analysis or dependency tracking, where efficient comparison and hashing of variable pairs are required.",
      "description_length": 432,
      "index": 405,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.JustWiden.XY",
      "library": "goblint.solver",
      "description": "This module tracks global contributions in constraint systems using a hash table (`HPM`) that maps variable pairs (`P.t`) to domain values (`S.Dom.t`). It provides direct access and mutation operations (`get_value`, `set_value`) with default handling (`hpm_find_default`) for efficient symbolic analysis of multi-threaded C programs. Use cases include managing variable interactions and resolving side-effecting constraints during static analysis.",
      "description_length": 447,
      "index": 406,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLRphased.Make.HPM",
      "library": "goblint.solver",
      "description": "This module implements imperative hash tables for key-value pairs with keys of type `P.t`, enabling efficient insertion, lookup, and in-place updates while supporting bulk transformations via higher-order operations like filtering, merging, and optional value handling. It provides utilities for converting between sequences, lists, and hash-based maps (`HPM.t`), with specialized iteration and formatted output capabilities. These operations are tailored for managing dynamic constraint state in the two-phased SLR3 solver's static analysis pipeline, particularly during phased propagation and resolution of side-effecting constraints.",
      "description_length": 636,
      "index": 407,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_solver.TopDown_deprecated.TD3.VS",
      "library": "goblint.solver",
      "description": "The module provides a comprehensive suite of set-theoretic operations, transformations, and conversions for manipulating ordered collections of `S.Var.t` variables represented as `VS.t` sets. It supports advanced static analysis workflows through functionalities like safe element selection (`Exceptionless`), label-aware set manipulation (`Labels`), and structural decomposition (e.g., `split`, `partition`), alongside conversions to sequences and extremal element retrieval. These capabilities are tailored for constraint solving and data flow tracking tasks, where precise variable set management and ordered semantics are critical.",
      "description_length": 635,
      "index": 408,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLRterm.SLR3term.HPM",
      "library": "goblint.solver",
      "description": "This module provides imperative hash table operations for polymorphic key-value maps with efficient associative manipulation, supporting in-place updates, iteration, and higher-order transformations. It works with `HPM.t` structures\u2014hash tables mapping `P.t` keys to arbitrary values\u2014enabling operations like merging, filtering, and sequence conversion while maintaining exception safety and label-specific adaptations. Designed for constraint system analysis, it facilitates hierarchical data traversal, incremental updates, and complex query pipelines where dynamic key-value relationships require efficient resolution.",
      "description_length": 621,
      "index": 409,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_solver.Td3.Base.VS",
      "library": "goblint.solver",
      "description": "This component provides set operations (union, symmetric difference, subset checks) and transformations (map, filter, fold) over variable sets (VS.t) containing symbolic variables (S.Var.t), with utilities for safe retrieval, extremal",
      "description_length": 234,
      "index": 410,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.TopDown.WP.VS",
      "library": "goblint.solver",
      "description": "This module provides set-theoretic operations and conversions for constraint-solving tasks involving variable sets and labeled values. It manipulates immutable sets of variables (`S.Var.t`) and structured sets (`VS.t`) with ordered elements, supporting operations like union, filtering, and element selection while enabling transformations between set-like structures and collections (lists, sequences). Designed for static analysis workflows, it facilitates tasks such as tracking variable dependencies, querying labeled constraints, and enumerating solution candidates through safe selection primitives and customizable output.",
      "description_length": 629,
      "index": 411,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_solver.SLR.Make.P",
      "library": "goblint.solver",
      "description": "This module provides operations for managing a set of keys within a hash table structure, specifically supporting insertion, removal, membership checks, and conversion to a list. It works with types involving `HM.key` and a hash table `HM.t` mapping keys to unit values. Concrete use cases include tracking dependencies for global variables and maintaining stable sets during constraint solving in multi-threaded analysis.",
      "description_length": 422,
      "index": 412,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLRphased.Make.P",
      "library": "goblint.solver",
      "description": "Implements equality and hash operations for constraint variable pairs used in the two-phased SLR3 solver. Works directly with tuples of constraint variables (`S.Var.t`). Enables efficient comparison and hashing of variable pairs during constraint system solving.",
      "description_length": 262,
      "index": 413,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.Make.H",
      "library": "goblint.solver",
      "description": "This module implements a priority queue with operations for adding, merging, and removing elements based on variable keys from the `HeapCompare` submodule. It supports concrete data structures like heaps and lists, enabling efficient management of constraint variables in multi-threaded analysis. Use cases include tracking and prioritizing variables during iterative constraint solving to optimize convergence and precision.",
      "description_length": 425,
      "index": 414,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.Make.T",
      "library": "goblint.solver",
      "description": "Implements variable dependency tracking for constraint solvers using hash maps. Provides sub, update, and set operations to manage variable relationships. Useful for analyzing data flow and dependencies in multi-threaded C programs during static analysis.",
      "description_length": 255,
      "index": 415,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.SLR3.VS",
      "library": "goblint.solver",
      "description": "This module implements a rich set abstraction for manipulating ordered collections of variables (`S.Var.t`) with operations spanning membership checks, set algebra (union, intersection, difference), functional transformations (`map`, `filter`), ordered traversal, and conversion to/from sequences/lists. It supports static analysis tasks like constraint solving and value set analysis in multi-threaded C programs through exception-safe variants and label-specific utilities. The ordered set structure enables precise tracking and manipulation of variable domains during program analysis.",
      "description_length": 588,
      "index": 416,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.Make.L",
      "library": "goblint.solver",
      "description": "This module implements operations for maintaining and querying influence lists, which track dependencies between variables in constraint systems. It provides functions to add an element to a variable's influence list, retrieve and remove elements associated with a variable, and remove a specific item from a variable's influence list. These operations are used during fixed-point computations to efficiently manage variable dependencies and propagate changes in multi-threaded analysis.",
      "description_length": 487,
      "index": 417,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.JustWiden.T",
      "library": "goblint.solver",
      "description": "This module tracks variable dependencies using a nested hash table structure where each variable points to a set of related variables. It provides direct access to dependency information via `sub`, updates dependencies with `update`, and maintains a global mapping of variable relationships in `set`. Concrete use cases include managing inter-variable dependencies during static analysis of multi-threaded C programs to track how changes propagate through shared variables.",
      "description_length": 473,
      "index": 418,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.Make0.D",
      "library": "goblint.solver",
      "description": "This module supports lattice manipulation for abstract domains in static analysis, offering operations like join, meet, widen, and narrowing to compute fixed points in constraint systems. It works with a domain type `D.t` structured as a lattice, including elements like top and bottom, and provides equality checks, ordering comparisons, and pretty-printing for domain values. These capabilities enable efficient analysis of multi-threaded programs by resolving side-effecting constraints through iterative solver methods.",
      "description_length": 523,
      "index": 419,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.EffectWConEq.Make.VS",
      "library": "goblint.solver",
      "description": "This module provides set algebra operations (union, intersection, difference) and element manipulation (membership checks, extremal element retrieval) for variable tracking in constraint systems. It operates on ordered collections of variables (`S.Var.t`) and elements (`VS.elt`), supporting conversions to/from lists, arrays, and sequences. These capabilities enable tasks like abstract domain traversal, control-flow analysis, and imperative constraint solving where precise variable set management is critical.",
      "description_length": 513,
      "index": 420,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.TwoPhased.W",
      "library": "goblint.solver",
      "description": "This module combines variable mapping and dependency tracking with lattice operations to solve constraint systems in multi-threaded program analysis. It provides functions for direct value access, priority-based heap management, influence list manipulation, and global contribution handling, working with hash maps, variable sets, and lattice domains. Concrete use cases include resolving memory accesses, prioritizing variable evaluation, and managing inter-thread dependencies during static analysis of concurrent C programs.",
      "description_length": 527,
      "index": 421,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.PostSolver.MakeList.S",
      "library": "goblint.solver",
      "description": "This module evaluates constraint systems using a list of postsolvers to perform non-incremental analysis tasks such as warning generation, result verification, and state pruning. It operates on variable-value mappings where variables are of type `S.Var.t` and values belong to a lattice domain `S.Dom.t`. Concrete use cases include final constraint resolution after incremental solving, checking analysis results against expected invariants, and generating analysis diagnostics based on computed fixpoints.",
      "description_length": 506,
      "index": 422,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.JustWiden.L",
      "library": "goblint.solver",
      "description": "This module provides operations to manipulate influence lists stored in a hash map, where each key maps to a list of values. It supports adding a value to a list, replacing a list with a new value, and removing a key entirely. These operations are used to track and update dependencies or influences in constraint systems during analysis.",
      "description_length": 338,
      "index": 423,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_solver.SLR.JustWiden.P",
      "library": "goblint.solver",
      "description": "This module provides operations for managing a set of keys within a hash table structure, specifically supporting insertion, removal, membership checks, and conversion to a list. It works with types involving `HM.key` and a hash table `HM.t` that maps keys to unit values. Concrete use cases include tracking dependencies for global variables and maintaining stable sets during constraint system solving.",
      "description_length": 404,
      "index": 424,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.Worklist.Make.VS",
      "library": "goblint.solver",
      "description": "The module provides ordered set operations (union, membership checks, extremal element selection) and conversions to/from lists, arrays, and sequences for managing variable collections of type `S.Var.t`. It supports constraint propagation and dataflow analysis through worklist-driven iteration, enabling functional transformations, relational queries, and traversal-order customization on variable sets. Operations include safe (optional-returning) and unsafe (exception-raising) modifications, alongside structured enumeration and solver-specific processing hooks.",
      "description_length": 566,
      "index": 425,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.JustWiden.H",
      "library": "goblint.solver",
      "description": "This module implements a priority queue with operations for adding elements, merging queues, extracting the minimum element, and converting between lists and queues. It works with elements of type `H.elem`, which are keys representing variables in a constraint system. The queue prioritizes elements using a comparison function defined in `HeapCompare`, enabling efficient variable selection during the widening phase of constraint solving for multi-threaded C analysis.",
      "description_length": 470,
      "index": 426,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.Make0.X",
      "library": "goblint.solver",
      "description": "This module manages value and priority associations for constraint solving, using hash maps to store domain-specific values and keys. It provides direct access and mutation operations for keyed values, along with key generation and indexing. Concrete use cases include tracking and updating constraint variables during analysis of multi-threaded C programs.",
      "description_length": 357,
      "index": 427,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLRterm.SLR3term.P",
      "library": "goblint.solver",
      "description": "Implements equality and hash operations for pairs of variables in the SLR3 solver. Works directly with the `t` type, which represents variable pairs. Used to support efficient comparison and hashing in constraint system solving processes.",
      "description_length": 238,
      "index": 428,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.TopDown_term.WP.VS",
      "library": "goblint.solver",
      "description": "This module provides a comprehensive suite of set operations for ordered collections of variables (`S.Var.t`), emphasizing functional transformations and order preservation. It supports standard manipulations like union, intersection, and difference, along with advanced patterns such as folding, filtering, and cardinality-aware processing, all operating on `VS.t` structures. These capabilities are particularly useful in constraint-solving workflows for static analysis, where precise variable set management, exception-safe element queries, and structured conversion to sequences or arrays are required.",
      "description_length": 607,
      "index": 429,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.PostSolver.MakeList.VH",
      "library": "goblint.solver",
      "description": "This module provides imperative and functional hash table operations for managing key-value associations where keys are analysis variables (`IncrArg.S.v`) and values represent constraint-solving results. It supports dictionary transformations like merging, filtering, and in-place modifications, along with conversions between hierarchical value structures and sequences (lists/enums). These capabilities are used in post-solving phases to process intermediate analysis data, enabling tasks like warning filtering, constraint pruning, and result aggregation through customizable traversal strategies.",
      "description_length": 600,
      "index": 430,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_solver.PostSolver.MakeList.IncrArg",
      "library": "goblint.solver",
      "description": "Implements incremental argument handling for postsolvers in a constraint system evaluation pass. Works with variable heaps (`VH.t`) and lists of postsolver modules. Used to initialize reachable variable heaps and apply a sequence of postsolvers incrementally during constraint system analysis.",
      "description_length": 293,
      "index": 431,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.TwoPhased.N",
      "library": "goblint.solver",
      "description": "This module implements a two-phased solver for constraint systems, combining fixed-point computation with priority-based refinement. It uses hash maps and priority queues to manage variable assignments, dependencies, and influence tracking during iterative analysis. Concrete use cases include solving interprocedural constraints and refining analysis results in multi-threaded C program analysis.",
      "description_length": 397,
      "index": 432,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_solver.SLR.SLR3.P",
      "library": "goblint.solver",
      "description": "This module defines a data type `t` as a pair of variables and provides equality and hashing operations for it. It supports efficient comparison and storage of variable pairs in contexts like constraint systems. Concrete use cases include tracking relationships between variables in static analysis of multi-threaded C programs.",
      "description_length": 328,
      "index": 433,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.TopDown_term.WP.P",
      "library": "goblint.solver",
      "description": "Implements weakest precondition (WP) computations for top-down constraint solving. Operates on pairs of variables representing preconditions and postconditions. Used to propagate constraints backward through program paths in static analysis.",
      "description_length": 241,
      "index": 434,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.Make.D",
      "library": "goblint.solver",
      "description": "This module supports constraint system solving via lattice-theoretic operations on an abstract domain `D.t`, including join (`cup`), meet, widening, and narrowing, with utilities for equality checks and pretty-printing. It works with abstract values representing program states in dataflow analysis, particularly for multi-threaded C programs. Its design enables scalable analysis of concurrent systems by combining domain-specific abstractions with generic solver frameworks.",
      "description_length": 476,
      "index": 435,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.SLR3.HPM",
      "library": "goblint.solver",
      "description": "This module supports imperative and functional manipulation of polymorphic hash tables (`HPM.t`) with keys of type `P.t`, offering operations like insertion, lookup, iteration, and higher-order transformations (e.g., filtering, merging, and label-based updates). It works with thread-local state in concurrent static analysis tasks, particularly for managing constraint systems in multi-threaded C programs, where polymorphic values represent abstract analysis domains and keys correspond to program entities like variables or control-flow points. Use cases include incremental constraint solving, safe in-place modifications during fixpoint iterations, and merging thread-local states via algebraic operations on hash table entries.",
      "description_length": 733,
      "index": 436,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.TopDown_deprecated.TD3.HPM",
      "library": "goblint.solver",
      "description": "This module offers imperative hash table operations and higher-order functions for creating, transforming, and iterating over polymorphic maps (HPM.t) that associate keys of type `P.t` with arbitrary values. It supports in-place modifications, merging of maps, conditional filtering, and conversions to sequences, lists, and enumerations, enabling efficient key-value association management. These capabilities are applied in constraint system solving and program analysis tasks within a deprecated top-down solver framework.",
      "description_length": 525,
      "index": 437,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.Make.X",
      "library": "goblint.solver",
      "description": "This module manages value and priority associations for constraint solving, using hash maps to store domain-specific values and keys. It provides direct access and mutation operations for keyed values, supporting efficient lookups and updates. Concrete use cases include tracking and retrieving constraint values during solver iterations.",
      "description_length": 338,
      "index": 438,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLRterm.SLR3term.VS",
      "library": "goblint.solver",
      "description": "This module provides a comprehensive suite of set-theoretic operations for manipulating collections of variables (`S.Var.t`) within constraint-solving workflows, including standard operations like union, intersection, and difference, as well as order-based transformations, extremal element selection, and conversion to/from lists, arrays, and sequences. It centers on the `VS.t` set-like structure, supporting both structural and ordinal manipulations while ensuring exception-safe querying and label-preserving transformations. Key use cases include managing variable dependencies, tracking active constraints, and enabling efficient iterative or phased solver operations in the SLR3 framework.",
      "description_length": 696,
      "index": 439,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.TopDown.WP.P",
      "library": "goblint.solver",
      "description": "Implements equality and hashing for constraint system variables used in top-down solving. Works with pairs of variables from the constraint system. Enables efficient comparison and storage of variable pairs during constraint resolution.",
      "description_length": 236,
      "index": 440,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.PostSolver.Warn",
      "library": "goblint.solver",
      "description": "This module emits warnings during a post-processing pass over a constraint system by analyzing variable relationships and domain states. It operates on constraint variables and domains provided by the `S` and `VH` modules, tracking and reporting inconsistencies or notable conditions. Concrete use cases include detecting unreachable code, unused variables, and potential type mismatches after constraint solving.",
      "description_length": 413,
      "index": 441,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_solver.SLR.JustWiden",
      "library": "goblint.solver",
      "description": "This module implements a widening strategy for constraint solving using hash maps to track influence lists, widening points, and restart modes. It provides direct access to these structures for managing variable dependencies and iteration control during fixed-point computations. Concrete use cases include optimizing convergence in static analysis of multi-threaded C programs by dynamically adjusting widening thresholds and tracking variable influences.",
      "description_length": 456,
      "index": 442,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.Generic.SolverStats",
      "library": "goblint.solver",
      "description": "This module provides statistics tracking for constraint system solvers, featuring counters and event hooks to monitor variable operations, evaluations, and updates. It works with solver variables, domain values, and histogram maps to collect and analyze solver behavior, supporting optional CSV logging for detailed diagnostics. The functionality is used to profile performance and debug constraint resolution processes in abstract interpretation frameworks.",
      "description_length": 458,
      "index": 443,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.Make",
      "library": "goblint.solver",
      "description": "This module implements a constraint solver for multi-threaded analysis with operations for managing variable dependencies, priority queues, and hash-based value storage. It works with constraint variables, domain values, and imperative hash maps to support efficient updates, lookups, and fixed-point computations. Concrete use cases include tracking global contributions, prioritizing variables during iteration, and maintaining influence lists for precise state merging in static analysis of concurrent C programs.",
      "description_length": 516,
      "index": 444,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.Generic.LoadRunSolver",
      "library": "goblint.solver",
      "description": "Solves constraint systems by computing a hash-map solution for specified variables starting from initial values. Uses data types from modules S (for variables and domain values) and H (for hash-maps). Useful for static analysis tasks like points-to analysis or dataflow optimization where local solutions are derived from initial constraints.",
      "description_length": 342,
      "index": 445,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.PrintInfluence",
      "library": "goblint.solver",
      "description": "Implements influence analysis for constraint systems using a specialized SLR solver. It tracks variable dependencies through hash maps (`HM.t`) and provides functions to print influence graphs based on keyed variables. Useful for analyzing data flow and side effects in multi-threaded C programs during static analysis.",
      "description_length": 319,
      "index": 446,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLRphased.Make",
      "library": "goblint.solver",
      "description": "This module provides instrumentation for tracking solver behavior through metrics like counters and histograms, alongside core operations for solving constraint systems via variable set manipulation, domain narrowing, and imperative state management. It works with constraint systems represented using hash maps, pair equality logic, and partitioned variable sets, supporting static analysis tasks such as incremental processing and domain refinement. Specific use cases include optimizing solver performance by analyzing logged statistics and resolving complex constraints in phased iterations.",
      "description_length": 595,
      "index": 447,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.Td3.Basic",
      "library": "goblint.solver",
      "description": "Implements an incremental, terminating top-down solver that supports space-efficient constraint solving with optional caching at widening points. It operates on constraint systems represented by variables (`S.v`), domains (`S.d`), and hash tables (`H.t`), and allows serialization and resumption of solver states via the `marshal` type. Concrete use cases include reanalyzing program abstractions interactively and efficiently after small changes, such as in iterative static analysis tools.",
      "description_length": 491,
      "index": 448,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.PostSolver.Compose",
      "library": "goblint.solver",
      "description": "This module implements sequential composition of two postsolvers, applying one after the other. It processes constraint systems using variable mappings and domains, propagating results through the composed postsolvers. It is used to chain analysis post-processing steps such as warning generation or value pruning.",
      "description_length": 314,
      "index": 449,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.Td3.Base",
      "library": "goblint.solver",
      "description": "The module provides operations for incremental constraint solving with dependency tracking, side-effect management, and space-efficient caching of intermediate results. It works with symbolic variables, abstract domains, and variable sets, using histograms to monitor solver events and manage solver state transitions during widening/narrowing phases. This enables interactive analysis scenarios like reanalyzing program changes with minimal recomputation and precise convergence control in abstract interpretation workflows.",
      "description_length": 525,
      "index": 450,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.TwoPhased",
      "library": "goblint.solver",
      "description": "This module implements a two-phased solver that combines fixed-point computation with priority-based refinement for constraint systems. It uses hash maps and priority queues to manage variable assignments, dependencies, and influence tracking during iterative analysis. Concrete use cases include solving interprocedural constraints and refining analysis results in multi-threaded C program analysis.",
      "description_length": 400,
      "index": 451,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.Generic.SoundBoxSolverImpl",
      "library": "goblint.solver",
      "description": "This module combines profiling capabilities with a hash table-based constraint resolution strategy, offering operations to track variable events, manage solver state depth, and log statistics through histograms and CSV outputs. It works with constraint systems defined over solver variables (`S.Var.t`) and domains (`S.Dom.t`), using hash tables to store intermediate results during stateful propagation. The implementation supports performance analysis of constraint-solving workflows while enabling customizable domain-specific computations through safe lookup primitives and iterative solving strategies.",
      "description_length": 607,
      "index": 452,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.PostSolver.MakeIncr",
      "library": "goblint.solver",
      "description": "This module creates an incremental postsolving function from a given incremental postsolver module. It provides the `post` function, which evaluates constraint systems by processing a list of variable-data pairs, a list of variables, and a hash table mapping variables to domain values. It is used to generate warnings, verify constraints, or prune results after solving.",
      "description_length": 371,
      "index": 453,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.Generic.SoundBoxSolver",
      "library": "goblint.solver",
      "description": "Solves constraint systems by computing a local solution for specified variables based on initial value mappings. Uses a hash-map to track variable-value associations during the solving process. Useful for analyzing program constraints where variables must be resolved under specific starting conditions.",
      "description_length": 303,
      "index": 454,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.Generic.LoadRunIncrSolver",
      "library": "goblint.solver",
      "description": "This module implements an incremental solver for constraint systems, supporting operations to copy and relift marshaled solver states. It works with variables (`S.v`), constraint domains (`S.d`), and hash maps (`H.t`) to store and manage solutions. It is used to compute local solutions for specific variables from initial values while enabling serialization for incremental solving.",
      "description_length": 383,
      "index": 455,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.PostSolver.Prune",
      "library": "goblint.solver",
      "description": "This module prunes constraint system solutions based on reachability analysis by processing individual constraints and variable relationships. It operates on variable handlers (VH) and constraint system domains (S) to track and eliminate unreachable states during post-solving. Concrete use cases include reducing false positives in static analysis by removing impossible paths or values after initial solving.",
      "description_length": 410,
      "index": 456,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.LocalFixpoint.Make",
      "library": "goblint.solver",
      "description": "Implements fixpoint iteration for a given transfer function, starting from an optional initial value. Works with data type `D.t`, applying a function `(D.t -> D.t)` until a fixed point is reached. Useful for iterative analysis of program properties within a single function, such as dataflow analysis or abstract interpretation.",
      "description_length": 328,
      "index": 457,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLRterm.SLR3term",
      "library": "goblint.solver",
      "description": "This module combines constraint-solving operations with detailed solver instrumentation, offering iterative resolution via `narrow` and `solve` functions alongside statistics tracking for variable updates and evaluation steps. It operates on constraint domains using imperative hash tables (HPM) to map variable pairs, variable sets (VS), and pair equality logic, enabling efficient state management during fixed-point computations. Its features are particularly suited for static analysis scenarios requiring termination guarantees and performance monitoring, such as program verification tasks with side-effecting constraints.",
      "description_length": 628,
      "index": 458,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.PostSolver.MakeIncrList",
      "library": "goblint.solver",
      "description": "This module constructs an incremental postsolving function from a list of postsolvers, executing them in sequence if the list is non-empty. It operates on constraint system solutions represented as lists of variables and values, using a hash table to map variables to their computed values. It is used to apply postprocessing steps like warning generation or result pruning after constraint system solving.",
      "description_length": 406,
      "index": 459,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_solver.SLR.SLR3",
      "library": "goblint.solver",
      "description": "The module combines solver instrumentation for tracking operations and generating statistics with constraint solving for static analysis. It manipulates variables (S.Var.t), domains (S.Dom.t), and hash tables mapping variables or variable pairs (P) to abstract values, enabling analysis of multi-threaded C programs through iterative domain updates and constraint resolution. Histograms, event tracing, and CSV output support performance profiling and debugging of the solving process.",
      "description_length": 485,
      "index": 460,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_solver.TopDown_deprecated.TD3",
      "library": "goblint.solver",
      "description": "This module combines profiling infrastructure with constraint system solving capabilities, offering operations to track performance metrics like variable evaluations and constraint updates through counters and histograms, while also providing set-theoretic manipulations of variable domains and imperative key-value mappings. It works with variable sets (VS), hash maps (HPM), and pair-based keys (P) to process domain constraints, culminating in a `solve` function that generates domain mappings. Its features support both performance analysis via CSV output and solving side-effecting constraint systems in a top-down manner.",
      "description_length": 627,
      "index": 461,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.TopDown_space_cache_term.WP",
      "library": "goblint.solver",
      "description": "This module combines profiling and constraint-solving capabilities for static analysis tasks. It tracks statistics like variable usage and event counts using solver variables (`S.Var.t`) and domains (`S.Dom.t`), while solving variable-domain assignments through a `solve` function that handles widening/narrowing phases. The design supports efficient constraint system analysis with caching and space-efficient top-down traversal, particularly useful for large-scale program analysis where termination and resource management are critical.",
      "description_length": 539,
      "index": 462,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.PostSolver.SaveRun",
      "library": "goblint.solver",
      "description": "This module performs a postsolver pass to handle the `save_run` option by tracking and saving constraint system evaluations. It operates on constraint variables and domains from the `S` and `VH` modules, specifically processing individual constraints and variable assignments. It is used to capture and store intermediate solver states for later analysis or replay.",
      "description_length": 365,
      "index": 463,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.Td3.DepVals",
      "library": "goblint.solver",
      "description": "This module implements a dependency-driven value analysis for constraint systems, using a top-down solver that skips re-evaluation of unchanged dependencies. It operates over variable-domain pairs with a hash-based structure for tracking dependencies and supports incremental solving with caching and space efficiency. Concrete use cases include incremental abstract interpretation of programs where only affected variables are reanalyzed after changes.",
      "description_length": 453,
      "index": 464,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SolverBox.Warrow",
      "library": "goblint.solver",
      "description": "Implements a box operator for warrowing solvers that combines two values of type `D.t` into a single value of the same type. The `box` function is used to merge intermediate results during constraint system solving, particularly in scenarios where side effects must be managed. This module is useful when aggregating partial solutions in fixed-point computations or constraint propagation algorithms.",
      "description_length": 400,
      "index": 465,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.Generic.DirtyBoxSolver",
      "library": "goblint.solver",
      "description": "This module provides a `solve` function that computes a local solution for a set of variables given initial constraints, using a hash-map to track results. It operates on values and constraints represented by the `S` module's types and stores intermediate states in a hash-map from the `H` module. It is useful for solving constraint systems where a join operation combines variable states, starting from specified initial values.",
      "description_length": 430,
      "index": 466,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_solver.PostSolver.ListArgFromStdArg",
      "library": "goblint.solver",
      "description": "This module defines a list of standard post-solvers used for evaluating constraint systems after the main solving phase. It works with modules S, VH, and Arg to process solver results, typically for tasks like generating warnings, verifying properties, or pruning unnecessary constraints. The `postsolvers` value provides a list of post-processing modules that each implement a specific evaluation pass.",
      "description_length": 403,
      "index": 467,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.PostSolver.EqIncrSolverFromEqSolver",
      "library": "goblint.solver",
      "description": "This module converts a non-incremental solver into one that simulates incremental behavior by solving from scratch each time. It works with constraint systems represented as variable-data pairs, producing local solutions for specified variables along with optional serialization data. Concrete use cases include running solvers in contexts requiring incremental interfaces but where true incremental state management isn't available.",
      "description_length": 433,
      "index": 468,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.PostSolver.MakeList",
      "library": "goblint.solver",
      "description": "This module combines a list of postsolvers into a single non-incremental postsolving function that processes final constraint results. It operates on variable heaps (`VH.t`) mapping variables to lattice values, applying each postsolver in sequence to generate warnings, verify results, or prune states. Concrete use cases include final analysis pass processing, invariant validation, and diagnostic generation after constraint system solving completes.",
      "description_length": 452,
      "index": 469,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_solver.SolverBox.NarrowOption",
      "library": "goblint.solver",
      "description": "Implements a narrowing operator for constraint solvers, combining two values of type `D.t` to produce a more precise result. Works with lattice elements representing program analysis states. Useful for refining fixpoint computations in static analysis by restricting the search space.",
      "description_length": 284,
      "index": 470,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_solver.Selector.Make",
      "library": "goblint.solver",
      "description": "This module implements a runtime-configurable solver that selects its behavior based on the `\"solver\"` configuration value. It operates on constraint systems involving variables (`S.v`) and their domains (`S.d`), using marshaled state (`marshal`) for solver-specific data. It supports solving with variable dependencies and optional initial state, returning both domain mappings and resulting state.",
      "description_length": 399,
      "index": 471,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.Worklist.Make",
      "library": "goblint.solver",
      "description": "This module enables worklist-based constraint solving through operations like solving systems of equations and equality constraints, and managing variable sets. It works with variables, domain values, hash maps for variable-to-domain mappings, and variable sets, supporting use cases such as dataflow analysis with customizable traversal and functional transformations, as well as performance monitoring with detailed statistics output in CSV format.",
      "description_length": 450,
      "index": 472,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.PostSolver.EqConstrSysFromStartEqConstrSys",
      "library": "goblint.solver",
      "description": "This module modifies constraint systems by incorporating start values into right-hand sides of equations, simplifying start value handling. It operates on constraint systems defined over variables (`v`) and data values (`d`), where the system is represented as a function mapping variables to their constraints. A concrete use case is refining constraint systems during analysis initialization to improve solver convergence behavior.",
      "description_length": 433,
      "index": 473,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_solver.PostSolver.Verify",
      "library": "goblint.solver",
      "description": "This module performs demand-driven verification of constraint system solutions by checking individual constraints or variable relationships. It works with constraint systems defined over variables of type `S.v` and domains `S.Dom.t`, using variable heaps `VH` to track and verify values. Concrete use cases include validating that specific variables satisfy their constraints after solving, such as ensuring that a variable's computed value meets expected bounds or properties.",
      "description_length": 477,
      "index": 474,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_solver.Generic.PreciseSideEffectBoxSolver",
      "library": "goblint.solver",
      "description": "Solves constraint systems with side effects by computing a local solution for specified variables from given starting values. Uses a hash-map to store and track variable-value associations during the solving process. Useful for static analysis tasks where precise value propagation and dependency tracking are required.",
      "description_length": 319,
      "index": 475,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.PostSolver.Unit",
      "library": "goblint.solver",
      "description": "Implements a base postsolver for analyzing constraint systems after initial solving. It tracks variable relationships and constraints using domains from the `S` and `VH` modules, enabling precise value propagation and dependency tracking. Used to refine results, detect unreachable variables, and generate verification feedback based on solved constraints.",
      "description_length": 356,
      "index": 476,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.EffectWConEq.Make",
      "library": "goblint.solver",
      "description": "This module combines profiling and constraint-solving capabilities for abstract interpretation tasks. It tracks solver events and statistics using variables (`S.Var.t`), domains (`S.Dom.t`), and hash maps (`HM`), while providing imperative constraint resolution through set algebra operations on variable sets (`VS`). These features support control-flow analysis and precise domain value computation in static program analysis scenarios.",
      "description_length": 437,
      "index": 477,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.TopDown.WP",
      "library": "goblint.solver",
      "description": "This module combines profiling and constraint-solving capabilities for analyzing variable relationships in static analysis. It tracks statistics like variable operations and context usage via counters and CSV output, while providing set-theoretic operations (e.g., unions, equalities) over variables and domain mappings to resolve constraints through symbolic reasoning. Key applications include performance monitoring of solver execution and modeling variable interactions in abstract domains.",
      "description_length": 494,
      "index": 478,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SolverBox.Widen",
      "library": "goblint.solver",
      "description": "Implements a widening operator that combines two values of type `D.t` to approximate their upper bound, typically used to accelerate fixpoint convergence in abstract interpretation. Works directly with the data type `D.t` defined in the parameter module. Useful for enforcing termination in iterative analysis of programs with infinite ascending chains, such as numerical domains.",
      "description_length": 380,
      "index": 479,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLR.Make0",
      "library": "goblint.solver",
      "description": "This module implements a box solver for constraint systems using hash maps, priority queues, and influence lists to manage variable dependencies and priorities during fixed-point computation. It provides operations for value retrieval with defaults, dependency tracking, variable prioritization, and lattice-based updates, working with variables, constraints, and domain values. Concrete use cases include solving side-effecting constraint systems arising from static analysis of multi-threaded C programs, where variables are processed in priority order and dependencies dictate re-evaluation.",
      "description_length": 594,
      "index": 480,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.TopDown_term.WP",
      "library": "goblint.solver",
      "description": "The module supports weakest precondition (WP) computation and performance profiling for constraint solvers. It operates on solver variables (`S.Var.t`), domains (`S.Dom.t`), and variable sets (`VS`), using hash maps (`HM`) to track histograms and solver events like variable updates. These features enable static analysis tasks such as program verification, where backward constraint propagation and performance optimization are critical.",
      "description_length": 438,
      "index": 481,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SLRphased",
      "library": "goblint.solver",
      "description": "Implements a two-phased SLR3 solver that ensures termination for constraint systems with side effects. It operates on constraint graphs with nodes representing variables and edges representing dependencies. Useful for static analysis tasks like points-to analysis or dataflow optimization where precise and terminating solutions are required.",
      "description_length": 342,
      "index": 482,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.Td3",
      "library": "goblint.solver",
      "description": "Implements an incremental, terminating top-down solver that supports space-efficient constraint solving with optional caching at widening points. It operates on constraint systems represented by variables (`S.v`), domains (`S.d`), and hash tables (`H.t`), and allows serialization and resumption of solver states via the `marshal` type. Use cases include reanalyzing program abstractions interactively and efficiently after small changes, such as in iterative static analysis tools.",
      "description_length": 482,
      "index": 483,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.TopDown_term",
      "library": "goblint.solver",
      "description": "Solves constraint systems using a top-down, terminating approach. It processes constraints by recursively evaluating dependencies, ensuring termination through cycle detection. Useful for static analysis tasks where constraints form a directed acyclic graph and precise, one-time solving is required.",
      "description_length": 300,
      "index": 484,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_solver.TopDown",
      "library": "goblint.solver",
      "description": "Implements a top-down solver for constraint systems using a worklist algorithm. Operates on constraint graphs with nodes representing variables and edges representing dependencies. Useful for solving dataflow analysis problems where constraints propagate from known to unknown variables.",
      "description_length": 287,
      "index": 485,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_solver.SolverBox",
      "library": "goblint.solver",
      "description": "Implements box, widening, and narrowing operators for combining and approximating values of type `D.t` in constraint solving. These functions merge intermediate results, accelerate fixpoint convergence, and refine analysis states in static program analysis. Used in fixed-point computations and constraint propagation algorithms where side effects and precision management are critical.",
      "description_length": 386,
      "index": 486,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.Selector",
      "library": "goblint.solver",
      "description": "This module manages dynamic selection among multiple constraint system solvers. It provides operations to register solvers by name, store them in a global list, and dynamically choose a solver at runtime based on the registered name. It works with constraint systems that implement the `ConstrSys.GenericEqIncrSolver` module type, enabling runtime switching between different solving strategies.",
      "description_length": 395,
      "index": 487,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_solver.SLRterm",
      "library": "goblint.solver",
      "description": "Implements a terminating SLR3 solver for constraint systems with side effects. Works directly on constraint graphs using a simplified phased approach without explicit phase tracking. Useful for solving dataflow analysis problems where constraints form a directed graph with potential cycles.",
      "description_length": 291,
      "index": 488,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.EffectWConEq",
      "library": "goblint.solver",
      "description": "Implements a constraint solver for effect systems with conditional equality constraints. It handles operations like unification, entailment checking, and substitution in the presence of effects and guards. This module is used to solve constraints arising from effect inference and refinement type systems in language analysis.",
      "description_length": 326,
      "index": 489,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.SolverStats",
      "library": "goblint.solver",
      "description": "Tracks solver performance metrics like variable counts, evaluation steps, and reuse of narrowing operations. Provides functions to print and reset these statistics. Useful for analyzing constraint system solving efficiency in side-effecting contexts.",
      "description_length": 250,
      "index": 490,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.Worklist",
      "library": "goblint.solver",
      "description": "Implements a worklist algorithm for solving constraint systems by iteratively processing nodes whose constraints have changed. It maintains a queue of nodes to revisit when their dependencies are updated, ensuring convergence to a fixed point. This module is used to efficiently compute solutions in dataflow analyses where constraints propagate through a control-flow graph.",
      "description_length": 375,
      "index": 491,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.TopDown_space_cache_term",
      "library": "goblint.solver",
      "description": "This module implements a terminating top-down solver that prioritizes space efficiency and result caching during constraint resolution. It operates on constraint systems with side effects, using memoization to avoid redundant computations and reduce memory overhead. It is suitable for analyses where constraints are solved in a demand-driven way, and intermediate results must be preserved efficiently.",
      "description_length": 403,
      "index": 492,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.PostSolver",
      "library": "goblint.solver",
      "description": "This module implements post-processing passes over solved constraint systems to refine results, generate diagnostics, and enforce verification conditions. It provides functions to prune unreachable states, verify constraint satisfaction, emit warnings for inconsistencies, and save solver states, operating on variable heaps and domain values. Concrete use cases include reducing false positives in static analysis, validating variable bounds, detecting unreachable code, and capturing intermediate solver evaluations for replay.",
      "description_length": 529,
      "index": 493,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.Generic",
      "library": "goblint.solver",
      "description": "This module implements generic constraint system solvers that compute local solutions for variables using hash-maps to track value associations. It supports operations such as incremental solving, relifting marshaled states, and side-effecting computations, working with variables, domains, and hash-maps from the `S` and `H` modules. Concrete use cases include points-to analysis, dataflow optimization, and static analysis requiring precise value propagation and dependency tracking.",
      "description_length": 485,
      "index": 494,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.LocalFixpoint",
      "library": "goblint.solver",
      "description": "Implements fixpoint iteration for a transfer function over values of type `D.t`, applying the function repeatedly until a fixed point is reached. Designed for iterative analysis within a single function, such as dataflow or abstract interpretation, where the analysis does not require a global constraint system. Useful for computing program properties like constant propagation or liveness within a function body.",
      "description_length": 414,
      "index": 495,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver.TopDown_deprecated",
      "library": "goblint.solver",
      "description": "This module implements a deprecated top-down solver for constraint systems, using a worklist algorithm to propagate constraints and compute fixed points. It operates on constraint variables and domains, resolving dependencies in reverse order. Use this when solving dataflow problems where constraints are processed from exit to entry points.",
      "description_length": 342,
      "index": 496,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_solver.SLR",
      "library": "goblint.solver",
      "description": "Implements fixed-point solvers using narrowing operators for constraint systems with side effects. Works with abstract domains that support narrowing, such as numeric or shape domains, to iteratively refine solutions. Useful for interprocedural analysis and invariant generation in static program analysis.",
      "description_length": 306,
      "index": 497,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_solver",
      "library": "goblint.solver",
      "description": "This module implements a variety of constraint system solvers, including top-down, SLR, and worklist-based algorithms, each tailored for specific analysis requirements such as termination, space efficiency, or demand-driven solving. It operates on constraint graphs with variables, domains, and hash tables, supporting side effects and incremental solving with caching, serialization, and narrowing. Concrete use cases include points-to analysis, dataflow optimization, effect inference, and interprocedural analysis where precise and terminating constraint resolution is required.",
      "description_length": 581,
      "index": 498,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ConcDomain.ThreadCreation.ParentThreadSet",
      "library": "goblint_cdomain_value",
      "description": "This module provides lattice and set operations for managing collections of thread parent identifiers, including subset checks, union, intersection, and widening, along with utilities for comparison, hashing, and serialization. It works with sets of thread identifiers (`ThreadIdDomain.Thread.t`) to model parent-child relationships in concurrency analysis, enabling static tracking of thread creation contexts through abstract interpretation. Specific applications include analyzing thread uniqueness and verifying safety properties in multithreaded programs.",
      "description_length": 560,
      "index": 499,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "ConcDomain.ThreadCreation.DirtyExitNames",
      "library": "goblint_cdomain_value",
      "description": "Handles thread naming and identity tracking in concurrent domains, providing direct access to raw thread names for debugging and diagnostics. Works with thread identifiers and string labels to distinguish between logical and physical thread names. Useful for tracing execution paths and correlating thread behavior across low-level system logs.",
      "description_length": 344,
      "index": 500,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "ConcDomain.ThreadCreation.Uniqueness",
      "library": "goblint_cdomain_value",
      "description": "This module provides a boolean lattice abstraction to model thread creation uniqueness, offering standard lattice operations like join, meet, widen, and narrow alongside top element checks (`is_top`). It operates on a two-state domain (`true` for unique creation, `false` for non-unique, and `top` as the unknown/least-constrained state) to support static analysis of concurrency behavior. The design enables program analysis frameworks to track whether thread creation sites are guaranteed to produce unique threads, ambiguous, or definitively non-unique.",
      "description_length": 556,
      "index": 501,
      "embedding_norm": 1.0
    },
    {
      "module_path": "AddressDomain.AddressLatticeRepr.VariableRepr",
      "library": "goblint_cdomain_value",
      "description": "This module represents variables within a memory address lattice, specifically handling values without mvalue offsets. It provides operations for equality checking, hashing, comparison, and string representation, along with support for serialization and arbitrary value generation. It is used to manage and identify unique variable instances in abstract interpretation contexts involving pointer analysis.",
      "description_length": 405,
      "index": 502,
      "embedding_norm": 1.0
    },
    {
      "module_path": "NullByteSet.MaySet.M",
      "library": "goblint_cdomain_value",
      "description": "This module provides lattice operations (join, meet, widen) and set manipulations (union, intersection, folding) to model possible null byte positions in C arrays using arbitrary-precision integer sets. It represents data as either explicit index sets (`Lifted`) or an overapproximated `Top` value, enabling static analysis tasks like buffer overflow detection and memory safety verification. Utilities for testing, serialization, and XML output further support integration into analysis frameworks.",
      "description_length": 499,
      "index": 503,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ThreadIdDomain.FlagConfiguredTID.D",
      "library": "goblint_cdomain_value",
      "description": "This module provides lattice-based abstractions for thread ID analysis with flag configurations, supporting operations like comparison, join/meet aggregation, and top/bottom element checks. It works with a tagged thread ID type that encodes configuration flags within a lattice structure, enabling precise state tracking. These capabilities are used in static analysis of concurrent programs to model thread behavior, verify synchronization properties, and detect race conditions through abstract interpretation.",
      "description_length": 512,
      "index": 504,
      "embedding_norm": 1.0
    },
    {
      "module_path": "NullByteSet.MustSet.M",
      "library": "goblint_cdomain_value",
      "description": "This module implements set operations and lattice manipulations for big integers representing positions of `NULL` bytes in C arrays, supporting abstract interpretation tasks. It uses a lifted set structure with a `Top` element to model unbounded or unknown states, enabling applications like buffer overflow detection and string termination analysis. Key operations include membership checks, set transformations, and domain-specific lattice utilities for static program analysis.",
      "description_length": 480,
      "index": 505,
      "embedding_norm": 1.0
    },
    {
      "module_path": "AddressDomain.AddressLatticeRepr.UnitOffsetRepr",
      "library": "goblint_cdomain_value",
      "description": "This module represents address lattice elements without mvalue offset indices, providing equality, comparison, and serialization operations. It works with a single abstract type `t` that identifies address units uniquely, primarily used for tracking memory locations in static analysis. Concrete use cases include managing and comparing abstract addresses in pointer analysis where offset details are irrelevant.",
      "description_length": 412,
      "index": 506,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "NullByteSet.MustMaySet.Set",
      "library": "goblint_cdomain_value",
      "description": "This module implements a specialized set abstraction for tracking potential NULL byte positions in C arrays using arbitrary-precision integers. It supports standard set operations like union, intersection, difference, and subset checks, along with lattice operations (join/meet) for static analysis frameworks. The data structure is optimized for functional transformations, filtering, and aggregation over sets of integer positions, enabling precise analysis of null-terminated string behavior in C programs during compilation or static verification tasks.",
      "description_length": 557,
      "index": 507,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "ThreadIdDomain.Unit.D",
      "library": "goblint_cdomain_value",
      "description": "This module provides lattice operations (join, meet, widen, narrow, leq) and comparison utilities for a thread ID domain, along with serialization and semantic diffing capabilities. It works with abstract values representing thread identities, structured as a lattice with explicit top and bottom elements to model concurrency states. These features support static analysis tasks like abstract interpretation, where precise merging and comparison of thread ID states are critical for reasoning about concurrent program behavior.",
      "description_length": 528,
      "index": 508,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "ConcDomain.ThreadCreation.DirtyExit",
      "library": "goblint_cdomain_value",
      "description": "This module provides a boolean lattice structure with standard order comparisons, joins, and meets to model thread exit states in concurrency analysis. It operates on a binary type representing clean or dirty thread termination, supporting abstract interpretation of thread creation effects through widening/narrowing operations. The lattice's top element signifies maximal uncertainty about exit states, enabling analysis of concurrent programs where threads may exit abruptly without synchronization.",
      "description_length": 502,
      "index": 509,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Offset.Index.Unit",
      "library": "goblint_cdomain_value",
      "description": "This module implements a unit index domain with operations for equality checking, hashing, comparison, and conversion to integers. It works with the unit type to represent arbitrary indices in contexts like arrays or structures. Concrete use cases include serving as a placeholder index when the actual value is irrelevant, enabling semantic comparisons with integers, and supporting witness generation through unique tagging.",
      "description_length": 426,
      "index": 510,
      "embedding_norm": 1.0
    },
    {
      "module_path": "AddressDomain.AddressSet.Addr",
      "library": "goblint_cdomain_value",
      "description": "This module provides operations for representing and manipulating abstract pointer values, supporting conversions between addresses and strings, CIL expressions, or variables, along with lattice-based analysis through equality checks, ordering relations, and join/meet operations. It works with address abstractions (`Addr.t`) combined with memory values (`Mval.t`), variable identifiers, and string domains to model pointer behaviors in static analysis. Specific use cases include tracking pointer definiteness, applying offset modifications, and performing abstract interpretation over pointer states in program analysis.",
      "description_length": 623,
      "index": 511,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "PreValueDomain.AD.Addr",
      "library": "goblint_cdomain_value",
      "description": "This abstract domain provides lattice-based operations\u2014such as join, meet, widen, and narrow\u2014alongside offset arithmetic and type information retrieval for abstract address values. It",
      "description_length": 183,
      "index": 512,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ValueDomain.ValueInvariant.VS",
      "library": "goblint_cdomain_value",
      "description": "This module provides set operations and transformations for tracking collections of program variables, supporting membership queries, bulk updates, and ordered traversals. It works with sets of variables (`Basetype.Variables.t`) and sequences/iterators over elements, enabling efficient analysis of variable relationships in program contexts. Typical applications include static analysis tasks like variable dependency tracking, liveness analysis, or collecting variable occurrences during code inspection.",
      "description_length": 506,
      "index": 513,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Offset.Index.Exp",
      "library": "goblint_cdomain_value",
      "description": "This module represents and manipulates index expressions as CIL expressions, providing equality checks, conversion to integers, and special index values for unknown or all indices. It supports operations like semantic comparison with integers, pretty printing, and serialization, working directly with `GoblintCil.exp` values. It is used to handle array index domains in analyses, such as tracking weak or strong array updates during assignments.",
      "description_length": 446,
      "index": 514,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Offset.Index.Z",
      "library": "goblint_cdomain_value",
      "description": "This module defines operations for working with definite integer indices represented as `Z.t`, including equality checks, comparison, conversion to integers, and serialization. It supports data types like `Z.t` and integrates with testing and pretty-printing libraries. Concrete use cases include representing and manipulating array indices or struct field offsets with precise integer values.",
      "description_length": 393,
      "index": 515,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ConcDomain.ThreadCreation.UNames",
      "library": "goblint_cdomain_value",
      "description": "This module manages unique thread identifiers, providing operations to generate, track, and compare thread names within a concurrency domain. It works with string-based thread identifiers and supports creating fresh names that are distinct from predefined constants like `true_name` and `false_name`. Concrete use cases include ensuring thread name uniqueness in concurrent programs and safely generating new thread identifiers during dynamic thread creation.",
      "description_length": 459,
      "index": 516,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ThreadIdDomain.History.D",
      "library": "goblint_cdomain_value",
      "description": "This module provides lattice-theoretic operations for analyzing thread ID histories, including join/meet for merging states, widen/narrow for convergence control, and top/bottom element checks. It manipulates `D.t` values representing abstracted thread execution traces with HConsed identifiers and structured difference explanations. Designed for static analysis of concurrent programs, it enables tracking thread interactions, detecting race conditions, and generating human-readable divergence reports between execution paths.",
      "description_length": 529,
      "index": 517,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "JmpBufDomain.LocallyModifiedMap.VarSet",
      "library": "goblint_cdomain_value",
      "description": "This module provides lattice operations (join, meet, widen, narrow) and set algebra (union, intersection, difference) for tracking modified program variables in static analysis. It operates on sets of `CilType.Varinfo.t` elements, representing variables from CIL code, with specialized functions for membership testing, transformation, and aggregation. The operations are used to model variable modifications in `setjmp`/`longjmp` contexts, enabling precise analysis of buffer states across control flow jumps.",
      "description_length": 510,
      "index": 518,
      "embedding_norm": 1.0
    },
    {
      "module_path": "PreValueDomain.Offs",
      "library": "goblint_cdomain_value",
      "description": "This module provides operations for manipulating index-based memory offsets within an abstract domain, supporting arithmetic transformations, lattice operations (join, meet, widen), and comparisons. It works with abstract offset values tied to index domains, represented alongside CIL expressions (`GoblintCil.exp`) and types (`GoblintCil.typ`), enabling precise static analysis of memory accesses. Key use cases include modeling pointer arithmetic, integrating with CIL-based analyses, and maintaining offset relationships during abstract interpretation.",
      "description_length": 555,
      "index": 519,
      "embedding_norm": 1.0
    },
    {
      "module_path": "NullByteSet.MustMaySet",
      "library": "goblint_cdomain_value",
      "description": "This module combines definite and possible NULL byte tracking through lattice operations like `join` and `meet`, alongside set manipulations such as union, intersection, and interval handling, to model null byte positions in C arrays. It operates on structured tuples integrating arbitrary-precision integers with must/may sets, enabling precise static analysis to detect potential NULL byte vulnerabilities in low-level code. Utility functions for membership checks, element filtering, and format conversions (XML/Yojson) further support integration into security analysis tools.",
      "description_length": 580,
      "index": 520,
      "embedding_norm": 1.0
    },
    {
      "module_path": "PreValueDomain.Addr",
      "library": "goblint_cdomain_value",
      "description": "This module provides a lattice-based abstract domain for analyzing memory addresses, supporting operations like offset arithmetic, string conversion, and lattice-theoretic comparisons (join, meet, widen). It models addresses as variants including pointers, null, and string references, enabling static analysis tasks such as tracking dynamic memory relationships or detecting pointer aliasing in program verification. The domain adheres to abstract interpretation principles, offering semantic equality checks and arbitrary value generation for analysis precision tuning.",
      "description_length": 571,
      "index": 521,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ConcDomain.ThreadSet",
      "library": "goblint_cdomain_value",
      "description": "This domain manages sets of thread identifiers with operations for creation, membership checks, union, intersection, and difference, alongside lattice functions like join, meet, widen, and narrow to combine or compare thread sets. It utilizes ThreadSet.t structures to represent concurrent analysis states, supporting queries for extremal elements, custom set merging, and lattice-based abstraction. Serialization and pretty-printing capabilities aid in debugging",
      "description_length": 463,
      "index": 522,
      "embedding_norm": 1.0
    },
    {
      "module_path": "FloatDomain.F32Interval",
      "library": "goblint_cdomain_value",
      "description": "This module provides arithmetic, interval manipulation, and lattice operations (join, meet, widen) for 32-bit floating-point intervals, supporting static analysis tasks like range checking and constraint propagation. It operates on bounded floating-point ranges represented as intervals, with functions for arithmetic operations, comparison predicates, and conversions from integers, strings, or constants. Specific use cases include abstract interpretation for program analysis, where precise tracking of floating-point ranges and classification of values (e.g., NaN, infinity) is required.",
      "description_length": 591,
      "index": 523,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ValueDomainQueries.ID",
      "library": "goblint_cdomain_value",
      "description": "This module defines a lattice structure with bottom (`Bot`), top (`Top`), and lifted values (`Lifted`) to represent abstract integer domains with constraints like intervals, congruences, or excluded values. It supports lattice operations (`join`, `meet`, `leq`), approximation techniques (widening/narrowing), and conversions between concrete integers/booleans and their abstract representations. Designed for static analysis tasks such as program value range inference or invariant detection, it enables reasoning about integer properties under abstraction.",
      "description_length": 558,
      "index": 524,
      "embedding_norm": 1.0
    },
    {
      "module_path": "IntDomain.Reverse",
      "library": "goblint_cdomain_value",
      "description": "This module supports abstract integer domains with reversed order semantics, offering lattice operations (join, meet, widen) alongside arithmetic and bitwise manipulations on intervals and congruences. It works with abstract values of type `t` representing integer constraints, enabling static analysis tasks like reverse propagation of value ranges or inverse condition reasoning in program analysis. Specific use cases include backward dataflow analysis and deriving invariants from expressions using reversed domain transformations.",
      "description_length": 535,
      "index": 525,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Offset.Index",
      "library": "goblint_cdomain_value",
      "description": "This module provides domains for representing and manipulating offset indices, such as array indices and struct field offsets. It includes submodules for handling indices as unit values, CIL expressions, and arbitrary-precision integers, supporting operations like equality, comparison, and conversion to integers. Concrete use cases include tracking array index domains during static analysis, enabling semantic comparisons, and serving as placeholder indices where the actual value is irrelevant.",
      "description_length": 498,
      "index": 526,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Offset_intf.Index",
      "library": "goblint_cdomain_value",
      "description": "This module defines an index for addressing elements in a fixed-size container, supporting operations to create, compare, and convert indices. It works with integer-based index types and ensures valid range operations for data structures like arrays or sequences. Concrete use cases include safe indexing into containers and iterating over elements with precise position control.",
      "description_length": 379,
      "index": 527,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "MutexAttrDomain.MutexKind",
      "library": "goblint_cdomain_value",
      "description": "This module defines and manipulates mutex kinds, specifically supporting operations to compare, hash, and serialize `NonRec` and `Recursive` mutex types. It provides concrete functionality for converting mutex kinds to strings, pretty-printing, and XML or JSON serialization. Use cases include attribute handling in concurrency libraries and configuration serialization in analysis tools.",
      "description_length": 388,
      "index": 528,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "IntDomain.IntDomTuple",
      "library": "goblint_cdomain_value",
      "description": "This module provides lattice operations (join/meet with widening/narrowing), arithmetic/bitwise manipulations, and precision-aware comparisons for integer tuples in an abstract domain. It works with Cil-type parameterized integer abstractions that track bounds, intervals, congruences, and overflow properties. The operations enable static analysis of C programs to infer value ranges, detect overflows, and verify integer invariants through abstract interpretation.",
      "description_length": 466,
      "index": 529,
      "embedding_norm": 1.0
    },
    {
      "module_path": "IntDomain.IntDomLifter",
      "library": "goblint_cdomain_value",
      "description": "This module provides lattice operations (join, meet, widen, narrow), arithmetic (addition, multiplication, division), bitwise manipulations (AND, OR, shifts), and comparison operators for an abstract integer domain representing sets of possible integer values. It works with abstract values (`t`) that encode intervals, congruences, or exclusion lists, supporting static analysis tasks like overflow detection, constraint propagation, and type conversion handling in C programs. The domain also includes precision-aware projections, extremal value checks, and serialization utilities for integrating with analysis frameworks or generating diagnostics.",
      "description_length": 651,
      "index": 530,
      "embedding_norm": 1.0
    },
    {
      "module_path": "WrapperFunctionAnalysis0.ThreadCreateUniqueCount",
      "library": "goblint_cdomain_value",
      "description": "This module provides lattice operations (join, meet, widen) and thread-local state management for tracking unique thread creation counts. It operates on integer-based values representing monotonic counters, with thread-specific state stored in a type `t` that supports comparison, serialization, and diff generation. The functionality is particularly useful for concurrency analysis frameworks requiring precise version tracking across thread lifecycles or distributed computations needing idempotent state merges.",
      "description_length": 514,
      "index": 531,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ThreadIdDomain.Unit",
      "library": "goblint_cdomain_value",
      "description": "This module handles abstract thread identifiers for concurrency analysis, supporting lattice operations, hashing, comparison, and serialization to model thread lifecycle events (initialization, entry points) and hierarchical relationships. It operates on thread ID types and domain states to enable static analysis tasks like tracking thread creation, uniqueness, and parent-child associations in concurrent programs. Key operations include spawning threads with contextual metadata and querying existing thread instances for domain-specific reasoning.",
      "description_length": 552,
      "index": 532,
      "embedding_norm": 1.0
    },
    {
      "module_path": "AddressDomain.AddressPrintable",
      "library": "goblint_cdomain_value",
      "description": "This module defines an abstract pointer type `t` encompassing string literals, null pointers, and symbolic unknowns, with operations for equality checks, offset arithmetic, string conversion, and definiteness analysis. It bridges CIL's concrete memory representations by converting between abstract addresses and constructs like variables, expressions, and memory values, supporting both precise and approximate translations. The type is particularly useful in static analysis for tracking pointer provenance, handling string interning, and modeling memory states where pointers may be partially known or symbolic.",
      "description_length": 614,
      "index": 533,
      "embedding_norm": 1.0
    },
    {
      "module_path": "StructDomain.Sets",
      "library": "goblint_cdomain_value",
      "description": "This module provides lattice-theoretic operations (join, meet, widen) and set-based representations for modeling structured data, where individual fields of C structs map to abstract values. It supports static analysis of compound data types by enabling abstraction refinement, field-level value tracking, and comparison of struct states during program analysis.",
      "description_length": 362,
      "index": 534,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "ValueDomain.Blob",
      "library": "goblint_cdomain_value",
      "description": "This component provides lattice operations (join, meet, widen, narrow) and analysis utilities (top/bot elements, comparison, serialization) for a composite data structure representing blob values. It operates on tuples combining a value domain, size domain, and zero-initialization status, enabling precise tracking of memory blob properties in static analysis. Key applications include data flow analysis for memory operations and abstract interpretation of low-level code where blob state characteristics need formal verification.",
      "description_length": 532,
      "index": 535,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ArrayDomain.AttributeConfiguredAndNullByteArrayDomain",
      "library": "goblint_cdomain_value",
      "description": "This module provides abstract interpretation operations for analyzing byte arrays with null-terminated string semantics. It combines lattice operations (join/meet/widen) with memory manipulation functions to model array state changes, while tracking null byte positions when the \"ana.base.arrays.nullbytes\" flag is enabled. The domain specializes in handling C-style string operations like strcpy, strcat, and substring comparisons, making it suitable for static analysis of programs that manipulate null-terminated character arrays with variable-length encodings.",
      "description_length": 564,
      "index": 536,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ThreadIdDomain.History",
      "library": "goblint_cdomain_value",
      "description": "This module manages thread identity tracking and execution trace analysis in concurrent programs, offering equality checks, hashing, and comparison operations for thread identifiers alongside conversions to string-based representations. It manipulates hierarchical thread histories to model creation relationships and parent-child dependencies, using lattice operations to merge abstract execution states for static analysis tasks. Key applications include detecting data races and divergence patterns by analyzing thread spawning events and maintaining creation lineage metadata.",
      "description_length": 580,
      "index": 537,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "ArrayDomain.AttributeConfiguredArrayDomain",
      "library": "goblint_cdomain_value",
      "description": "This module provides abstract domain operations for analyzing arrays by dynamically selecting between partitioned, trivial, and unrolled representations based on context. It manipulates arrays through element access/modification, folding, mapping, and domain-specific joins/widening, working with indices and values structured as lattices with safety-aware access controls. The design supports static analysis of C arrays where representation strategies adapt to variables, types, or flags to balance precision and performance.",
      "description_length": 527,
      "index": 538,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ValueDomain.Offs",
      "library": "goblint_cdomain_value",
      "description": "This module supports arithmetic and lattice operations on structured offset values, handling tasks like index containment checks, offset transformations, and semantic comparisons. It operates on lattice-structured offset values (`Offs.t`) that integrate with CIL representations through conversion utilities and type-aware manipulations. Key use cases include static analysis of memory accesses and type-safe offset tracking in program verification workflows.",
      "description_length": 459,
      "index": 539,
      "embedding_norm": 1.0
    },
    {
      "module_path": "AddressDomain.AddressSet",
      "library": "goblint_cdomain_value",
      "description": "This module implements a lattice-structured set abstraction for analyzing pointer values, combining abstract addresses (`Addr.t`) with memory value domains (`Mval.t`) and variable IDs to model dynamic pointer states. It supports precise static analysis of memory operations through lattice operations (join, meet, widen, narrow), set-theoretic queries (union, intersection, membership), and domain-specific predicates to track properties like nullness or definiteness. The structure enables symbolic representation of pointer aliases, memory states, and dataflow relationships in programs, with conversions to integers, strings, and mvalues for integration into broader analysis frameworks.",
      "description_length": 690,
      "index": 540,
      "embedding_norm": 1.0
    },
    {
      "module_path": "IntDomain.Congruence",
      "library": "goblint_cdomain_value",
      "description": "This module provides abstract integer values with congruence (modular) relations, supporting arithmetic operations (addition, multiplication, division), bitwise manipulations (AND/OR/XOR, shifts), and lattice operations (join, meet, widening). It works with C integer types (via `ikind`) and represents values through constraints like equality, intervals, inclusion/exclusion lists, and modular equivalences. Designed for static analysis, it enables precise invariant generation and precision-controlled domain refinements in abstract interpretation tasks like program verification.",
      "description_length": 582,
      "index": 541,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ConcDomain.MustThreadSet",
      "library": "goblint_cdomain_value",
      "description": "This module provides set-theoretic operations (union, intersection, difference, filtering) and lattice-based abstractions (widen, narrow, join/meet) for modeling thread sets in concurrency analysis. It manipulates `ThreadSet.t` structures containing thread identifiers, supporting conversions to lists, extremal element extraction, and domain-specific comparisons/hashing. Designed for abstract interpretation, it enables reasoning about thread interactions in static analysis of concurrent programs through set-based modeling and domain-specific lattice theory.",
      "description_length": 562,
      "index": 542,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mval.Exp",
      "library": "goblint_cdomain_value",
      "description": "This module represents mvalues with expressions as indices in their offsets, combining a CIL variable and an offset structure. It supports operations like comparing, hashing, and converting mvalues to CIL lvalues or expressions, as well as checking prefix relationships and appending offsets. Concrete use cases include tracking memory locations with dynamic offsets during static analysis and generating precise type or XML representations of these locations.",
      "description_length": 460,
      "index": 543,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "ThreadIdDomain.FunNode",
      "library": "goblint_cdomain_value",
      "description": "This module represents abstract thread IDs with operations for equality, comparison, and serialization. It supports concrete use cases like tracking thread creation and parent-child relationships in concurrent programs, where each thread ID can be uniquely identified and compared. Functions like `threadinit` and `threadenter` model thread initialization and entry points, while `is_must_parent` and `may_create` analyze thread creation relationships.",
      "description_length": 452,
      "index": 544,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Offset.Unit",
      "library": "goblint_cdomain_value",
      "description": "Supports operations such as equality checks, prefix verification, and mapping over unit indices for manipulating offsets. Works with `Offset.Unit.t` values and CIL/Goblint offsets/expressions, supporting type derivation from base types. Used in CIL-based analysis to represent and transform array indices and struct fields, including zero offset checks and offset composition during static analysis.",
      "description_length": 399,
      "index": 545,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lval.Set",
      "library": "goblint_cdomain_value",
      "description": "This module provides a set domain for managing collections of CIL lvalues with support for both standard set operations (union, intersection, subset checks) and lattice-oriented manipulations (join, meet, widening). It operates on concrete CIL lvalue elements, offering transformations like filtering, partitioning, and extremal value extraction, which are particularly useful for static analysis tasks involving memory locations or variable tracking in program control flow graphs. The interface supports both functional set construction and iterative processing, enabling use cases such as dataflow analysis state representation and constraint propagation.",
      "description_length": 658,
      "index": 546,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ArrayDomain.Trivial",
      "library": "goblint_cdomain_value",
      "description": "This module provides lattice operations (join, meet, widen) and array manipulations (set, get, map) that treat arrays as a single abstract cell, ignoring index distinctions. It operates on abstract values of type `t` paired with CIL expressions/variables, using a phantom index type only for type system compatibility. This representation simplifies array analysis in static verification scenarios where per-element precision is unnecessary, such as tracking array partitioning invariants or coarse-grained value domains.",
      "description_length": 521,
      "index": 547,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mval.MakeLattice",
      "library": "goblint_cdomain_value",
      "description": "This module provides lattice operations for combining and comparing memory values represented as variable-offset pairs (`GoblintCil.varinfo` with `idx Offset.t`), supporting static analysis tasks like abstract interpretation. It enables operations such as join, meet, and widening over these structures while offering utilities for semantic equivalence checks and hierarchical comparisons. The lattice framework is particularly suited for analyzing memory accesses with offset-based abstractions in pointer-sensitive dataflow analysis.",
      "description_length": 535,
      "index": 548,
      "embedding_norm": 1.0
    },
    {
      "module_path": "StructDomain.FlagConfiguredStructDomain",
      "library": "goblint_cdomain_value",
      "description": "This module provides lattice operations and structural transformations for abstract domains modeling compound data with field-value mappings. It works with parameterized types representing structured data (e.g., C structs) and supports context-sensitive analysis through operations like field replacement, domain folding, and lattice-specific widening/join. It is particularly suited for analyzing hierarchical data structures where fields map to abstract values, enabling precise tracking of structural relationships in programs.",
      "description_length": 530,
      "index": 549,
      "embedding_norm": 1.0
    },
    {
      "module_path": "IntDomain.IntervalSet",
      "library": "goblint_cdomain_value",
      "description": "This module provides lattice operations (e.g., `leq`, `bot`, `top`), bitwise arithmetic (AND, OR, XOR), logical operations (negation, conjunction, disjunction), and arithmetic operations (addition, subtraction, multiplication) with overflow tracking, alongside refinement mechanisms for interval sets. It operates on integer intervals represented as `t` values, which model ranges of integers constrained by C integer kinds (`ikind`), and supports conversions to inclusion/exclusion lists, precision control, and invariant generation. These capabilities enable static analysis tasks such as overflow detection, value-range analysis, and symbolic reasoning over integer variables in C programs.",
      "description_length": 693,
      "index": 550,
      "embedding_norm": 1.0
    },
    {
      "module_path": "WrapperFunctionAnalysis0.MallocUniqueCount",
      "library": "goblint_cdomain_value",
      "description": "This module implements a lattice structure over integers to track unique memory allocation counts in static analysis, providing standard lattice operations (join, meet, widen, narrow) alongside equality checks, hashing, and serialization. It specifically handles uninitialized states via a dedicated top element, enabling precise analysis of dynamic memory usage patterns in wrapper functions where allocation counts must be aggregated and compared across program paths.",
      "description_length": 470,
      "index": 551,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ValueDomain.CArrays",
      "library": "goblint_cdomain_value",
      "description": "This module provides abstract operations for analyzing C arrays and strings, including string manipulation (copying, concatenation, comparison), lattice operations (join, meet, widening), and array transformations (element setting, folding, projection). It works with abstract values representing arrays (`t`) and index/length values (`idx`), modeling compound elements, variable dependencies, and array partitioning. It is used in static analysis to track array content properties, enforce invariants, and reason about length constraints or substring relationships in low-level code.",
      "description_length": 584,
      "index": 552,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "ValueDomainQueries.LS",
      "library": "goblint_cdomain_value",
      "description": "This module implements a lattice-based set structure for values of type `Mval.Exp.t`, supporting set operations like union, intersection, membership testing, and lattice-theoretic functions such as join, meet, widening, and narrowing. It also provides utilities for cardinality tracking, extremal element retrieval (`min_elt`, `max_elt`), predicate-driven partitioning, and conversion to ordered collections, enabling precise static analysis of program value domains where abstract interpretation or set-based reasoning is required.",
      "description_length": 532,
      "index": 553,
      "embedding_norm": 1.0
    },
    {
      "module_path": "AddressDomain.AddressLattice",
      "library": "goblint_cdomain_value",
      "description": "This module provides lattice operations for abstract addresses grouped into disjoint categories, supporting analysis of pointers, string literals, and offsets. It works with a type `t` representing structured address values with semantic properties, enabling comparisons, combinations, and serialization for static analysis tasks. Specific use cases include tracking pointer relationships and handling address arithmetic in memory models.",
      "description_length": 438,
      "index": 554,
      "embedding_norm": 1.0
    },
    {
      "module_path": "IntDomain.Flattened",
      "library": "goblint_cdomain_value",
      "description": "This module provides a flattened integer abstraction with three states: unknown (Top), unreachable (Bot), and concrete 64-bit values (Lifted), supporting lattice operations (join, meet, widen), arithmetic (addition, multiplication, division), comparisons (less-than, greater-equal), bitwise operations (AND, XOR), and conversions between integers, booleans, and intervals. It represents integer sets using inclusion/exclusion lists for precise modeling of ranges and conditions, while handling overflow during type casts and enabling exact boolean interpretation. Designed for constant propagation in static analysis, it integrates with expression evaluators like GoblintCil to infer invariants, track reachable constants, and optimize program analysis by collapsing complex integer constraints into manageable symbolic representations.",
      "description_length": 836,
      "index": 555,
      "embedding_norm": 1.0
    },
    {
      "module_path": "IntDomain.Lifted",
      "library": "goblint_cdomain_value",
      "description": "This module provides lattice operations (join, meet, widen) and arithmetic/comparison operators for bounded integer abstractions that can represent ranges, excluded values, or single points. It works with tagged integer types (`t`) that model C integer semantics, including overflow-aware operations and set-like representations through constructors like `Top`, `Bot`, and `Lifted int64`. The domain supports abstract interpretation tasks like value range analysis, invariant generation, and program verification where precise modeling of integer constraints and symbolic execution is required.",
      "description_length": 594,
      "index": 556,
      "embedding_norm": 1.0
    },
    {
      "module_path": "PreValueDomain.Mval",
      "library": "goblint_cdomain_value",
      "description": "The module provides operations for manipulating abstract memory values represented as variable-offset pairs, supporting offset composition, type inspection, and conversions to CIL expressions/lvalues. It implements lattice-theoretic operations like join, meet, and widen for combining abstract program states, alongside utilities for semantic comparison and state differencing. These capabilities enable program analysis tasks such as memory state tracking, abstract interpretation, and analysis of data-flow properties through structured value transformations.",
      "description_length": 561,
      "index": 557,
      "embedding_norm": 1.0
    },
    {
      "module_path": "IntDomain.IntervalSetFunctor",
      "library": "goblint_cdomain_value",
      "description": "This module provides lattice operations, arithmetic with overflow tracking, and bitwise/logical operations for analyzing integer intervals parameterized over C integer kinds (`ikind`). It represents values as intervals with inclusion/exclusion constraints and supports precision-controlled refinements, projections, and conversions between concrete and abstract forms. Designed for static analysis, it enables reasoning about integer ranges, overflow safety, and bitwise behavior in C programs through abstract interpretation and interval-based domain modeling.",
      "description_length": 561,
      "index": 558,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "ArrayDomain.Partitioned",
      "library": "goblint_cdomain_value",
      "description": "This module provides lattice operations (join, meet, widen) and partition-aware manipulations (get, set, map, fold) for arrays divided into three segments relative to an index expression. It operates on partitioned arrays represented by triplets of values (left, at, right) combined with index expressions (`Basetype.CilExp.t option`) and indices (`idx`), supporting bounds-checked access and dynamic partition adjustments. These capabilities enable static analysis of C arrays with variable partitioning, such as tracking element value ranges across loop iterations or merging array states from divergent control-flow paths.",
      "description_length": 625,
      "index": 559,
      "embedding_norm": 1.0
    },
    {
      "module_path": "AddressDomain.AddressLatticeRepr",
      "library": "goblint_cdomain_value",
      "description": "This module provides lattice operations (join, meet, widen) and conversions to variables, strings, and CIL expressions for abstract memory addresses. It operates on a variant pointer type (Addr, NullPtr, StrPtr) with submodules handling equality, serialization, and string representation, specifically supporting pointer analysis in static analysis through precise offset manipulation and property tracking.",
      "description_length": 407,
      "index": 560,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "JmpBufDomain.BufferEntryOrTop",
      "library": "goblint_cdomain_value",
      "description": "This module represents either a specific buffer entry or all possible targets in `setjmp`/`longjmp` analysis. It provides comparison, hashing, and serialization operations for the `t` type, which includes `AllTargets` and `Target` of a concrete buffer entry. It is used to track or abstract jump targets during static analysis of C code with setjmp/longjmp constructs.",
      "description_length": 368,
      "index": 561,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mval.Z",
      "library": "goblint_cdomain_value",
      "description": "Handles mvalues with precise integer indices in offsets, providing operations to compare, hash, and convert between mvalues and CIL lvalues. Works with `GoblintCil.varinfo` and `Offset.Z.t` structures to represent and manipulate memory locations. Used for tracking memory accesses with exact offset information in static analysis.",
      "description_length": 330,
      "index": 562,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mval.MakePrintable",
      "library": "goblint_cdomain_value",
      "description": "This module creates printable mvalues by combining a CIL variable with an offset structure from the `Offs` module, enabling operations like appending offsets, checking prefix relationships, and converting to CIL lvalues or expressions. It supports concrete use cases such as generating human-readable representations of mvalues, comparing and hashing mvalues for analysis, and producing XML or JSON output for external tools or debugging. Key functions include `show`, `pretty`, `to_cil`, `add_offset`, and `prefix`, which facilitate precise manipulation and inspection of mvalues in static analysis contexts.",
      "description_length": 609,
      "index": 563,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Offset.MakePrintable",
      "library": "goblint_cdomain_value",
      "description": "This module enables the creation, conversion, and structural manipulation of hierarchical offset values derived from index-based representations, supporting operations like equality checks, ordering, and serialization. It works with a composite type `t` that encodes structured offsets with both definite and indefinite indexing, allowing integration with CIL type systems through zero-comparison, type inference, and CIL-compatible format transformations. Specific use cases include analyzing memory layouts of arrays and structs, or validating offset relationships in type-aware static analysis tools.",
      "description_length": 603,
      "index": 564,
      "embedding_norm": 1.0
    },
    {
      "module_path": "IntDomain.Flat",
      "library": "goblint_cdomain_value",
      "description": "This module implements a flat abstract domain for integer analysis with three states: concrete values wrapped in `Lifted`, unbounded uncertainty (`Top`), and invalid states (`Bot`). It supports arithmetic operations that propagate uncertainty, lattice operations for domain combination, and conversions from intervals or congruences while discarding ordering relationships. The design enables static analysis of C programs to track integer values with explicit handling of unknowns and errors through abstract interpretation.",
      "description_length": 525,
      "index": 565,
      "embedding_norm": 1.0
    },
    {
      "module_path": "JmpBufDomain.LocallyModifiedMap",
      "library": "goblint_cdomain_value",
      "description": "This module provides a map structure that associates jump buffer entries with sets of modified variables, supporting operations to combine, compare, and transform these associations through lattice operations (meet, join, widen) and standard map manipulations. It works with keys representing jump buffer identifiers and values as sets of CIL variables, enabling precise tracking of variable modifications across non-local control flow transfers. The structure is used in abstract interpretation to model the effects of `setjmp`/`longjmp` on program state, particularly for analyzing how variable values propagate and diverge at jump targets.",
      "description_length": 642,
      "index": 566,
      "embedding_norm": 1.0
    },
    {
      "module_path": "UnionDomain.Field",
      "library": "goblint_cdomain_value",
      "description": "This module models C union fields as an abstract lattice domain with three states\u2014bottom, top, and lifted field information\u2014to support static analysis. It offers lattice operations (join, meet, widening, narrowing), comparison functions, and serialization utilities, enabling abstract interpretation of C programs to track and approximate field states during dataflow analysis.",
      "description_length": 377,
      "index": 567,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ThreadIdDomain.Thread",
      "library": "goblint_cdomain_value",
      "description": "This module provides operations to manage and analyze thread identifiers (TIDs) within thread ID domains, including equality checks, hashing, comparison, and serialization. It works with thread and domain data structures to model hierarchical relationships, track creation events, and capture entry/spawn behavior during static analysis. These capabilities are particularly useful for analyzing concurrent programs, enabling inspection of thread creation histories, parent-child relationships, and dynamic thread spawning patterns.",
      "description_length": 531,
      "index": 568,
      "embedding_norm": 1.0
    },
    {
      "module_path": "JmpBufDomain.JmpBufSet",
      "library": "goblint_cdomain_value",
      "description": "This module implements a lattice-structured set domain for analyzing `setjmp` buffer entries, supporting standard set operations (union, intersection, membership checks) alongside lattice operations (join, meet, widening) over elements that include a distinguished top value. It works with sets of `BufferEntryOrTop.t` values, where the lattice structure captures approximations of buffer states across program paths, particularly in static analysis of control flow changes induced by `longjmp`. The domain enables tracking potential buffer entries and merging analysis states from divergent execution paths, ensuring soundness in scenarios where `setjmp` buffers may hold indeterminate or top-like values.",
      "description_length": 706,
      "index": 569,
      "embedding_norm": 1.0
    },
    {
      "module_path": "JmpBufDomain.ActiveLongjmps",
      "library": "goblint_cdomain_value",
      "description": "This module provides lattice operations (join, meet, widen) and data representation utilities for a domain tracking active `longjmp` targets as pairs of jump buffer sets (`JmpBufSet.t`) and control flow node sets (`NodeSet.t`). It supports abstract interpretation of `setjmp`/`longjmp` behavior in C programs by modeling reachable jump targets and buffer states across control flow graph nodes. The domain enables static analysis of non-local gotos, with serialization and diffing tools for debugging and testing.",
      "description_length": 513,
      "index": 570,
      "embedding_norm": 1.0
    },
    {
      "module_path": "JmpBufDomain.NodeSet",
      "library": "goblint_cdomain_value",
      "description": "This module provides lattice and set-theoretic operations for analyzing collections of control-flow graph nodes, combining standard domain primitives (`join`, `meet`, `widen`) with set manipulation functions (`union`, `filter`, `map`). It operates on a hybrid type alternating between concrete sets of `Node.t` elements and an abstract top value, enabling precise tracking of node sets in static analysis. The functionality supports abstract interpretation of programs with non-local jumps, such as `setjmp`/`longjmp`, by modeling possible control-flow paths through set operations and extremal element extraction.",
      "description_length": 614,
      "index": 571,
      "embedding_norm": 1.0
    },
    {
      "module_path": "IntDomain.Interval",
      "library": "goblint_cdomain_value",
      "description": "This module offers logical and arithmetic operations on integer intervals and exclusion sets, including comparisons, bitwise manipulations, and overflow-aware arithmetic, alongside lattice operations like join, meet, and widening. It supports abstract interpretation for C integer analysis by enabling type-specific range determination, overflow detection, and refinement of intervals through congruence or exclusion constraints. Key use cases include static analysis of C programs to infer integer value ranges and handle domain-specific type behaviors under arithmetic or bitwise transformations.",
      "description_length": 598,
      "index": 572,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Offset.Poly",
      "library": "goblint_cdomain_value",
      "description": "Transforms indexing functions over polymorphic offset domains, enabling structured access pattern modifications. Works with any indexable data structure through its offset representation. Useful for adapting array or record field accessors to different index types without altering the underlying data layout.",
      "description_length": 309,
      "index": 573,
      "embedding_norm": 1.0
    },
    {
      "module_path": "NullByteSet.MaySet",
      "library": "goblint_cdomain_value",
      "description": "This module supports lattice operations, set manipulations, and element selection for tracking potential null byte positions in C arrays using arbitrary-precision integer sets. It works with abstract data structures that represent either a finite set of indices (as `IntOps.BigIntOps.t` elements) or an overapproximated top value, enabling precise static analysis of buffer boundaries. The operations are specifically designed for use cases like detecting out-of-bounds writes by modeling possible null terminator locations in memory buffers during program analysis.",
      "description_length": 566,
      "index": 574,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ValueDomain.Unions",
      "library": "goblint_cdomain_value",
      "description": "This module provides lattice-theoretic operations for union domains combining field identifiers with compound value domains, supporting analysis of variant data structures. It manipulates union-typed values through standard domain operations (`join`, `meet`, `widen`), enforces invariants via propagation to compound values at specific offsets, and handles hierarchical representations of union states. The implementation works with tagged union domains, offset-based access paths, and compound value abstractions, primarily serving static analysis of languages with union types (e.g., C/C++ `union` constructs) to track active fields and memory layout constraints.",
      "description_length": 665,
      "index": 575,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Invariant.ExpLat",
      "library": "goblint_cdomain_value",
      "description": "This module provides lattice operations (join, meet, widen, narrow) and structural manipulation for symbolic CIL expressions, enabling syntactic reasoning about program invariants. It operates on `GoblintCil.exp` nodes to support abstract interpretation tasks like expression generalization and refinement, with utilities for comparison, hashing, and serialization. The functionality is particularly useful in static analysis for approximating program behavior through symbolic expression transformations.",
      "description_length": 505,
      "index": 576,
      "embedding_norm": 1.0
    },
    {
      "module_path": "IntDomain.Size",
      "library": "goblint_cdomain_value",
      "description": "Handles integer value ranges and type conversions for abstract interpretation. Works with C integer types and arbitrary-precision integers (`Z.t`). Used to determine safe casting between types and compute bounds for integer operations.",
      "description_length": 235,
      "index": 577,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mval.Unit",
      "library": "goblint_cdomain_value",
      "description": "This module represents mvalues with unit indices in their offset structure, combining a CIL variable with an offset. It supports operations like equality checks, hashing, comparison, string conversion, and XML/YOJSON serialization, along with utilities for offset manipulation, prefix checks, and CIL conversion. It is used to track and manipulate simplified lvalues during pointer analysis, particularly when dealing with variables and their offsets in a structured, comparable form.",
      "description_length": 484,
      "index": 578,
      "embedding_norm": 1.0
    },
    {
      "module_path": "PreValueDomain.IndexDomain",
      "library": "goblint_cdomain_value",
      "description": "This module provides lattice operations (join, meet, widen, narrow) and arithmetic/bitwise operations (add, sub, mul, div, shifts) for an abstract domain representing integer indices with domain-specific behaviors like intervals, congruences, and exclusion lists. It works with abstract values that encode integer ranges, boolean states, or symbolic expressions, supporting static analysis tasks such as invariant derivation, precision control, and overflow tracking in program analysis. The domain enables reasoning about index properties through comparisons (lt, gt), logical operators (logand, logor), and conversions between abstract and concrete integer representations.",
      "description_length": 675,
      "index": 579,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "IntDomain.IntervalFunctor",
      "library": "goblint_cdomain_value",
      "description": "This module provides lattice operations, arithmetic, and bitwise manipulations for integer intervals represented as optional bounds of `Ints_t.t` values, parameterized by integer kinds (`ikind`) like signed or unsigned types. It supports abstract interpretation tasks such as overflow tracking, inequality analysis, and precision-aware value refinement through functions like interval joins, meets, and narrowing/widening. Specific use cases include static analysis of C integer behaviors, generating human-readable inequality diagnostics, and handling edge cases in bit-level operations or range constraints.",
      "description_length": 609,
      "index": 580,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Invariant.N",
      "library": "goblint_cdomain_value",
      "description": "This module enforces invariants for witness values through functions that validate and manipulate named witnesses. It operates on boolean flags and string identifiers, ensuring correctness during witness transformations. Use it to maintain consistency when working with witness-based abstractions that require runtime validation.",
      "description_length": 329,
      "index": 581,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Offset.Exp",
      "library": "goblint_cdomain_value",
      "description": "This module handles structured offsets with expression-based indices, enabling equality checks, hashing, conversion between CIL representations, and structural transformations like appending or removing indices. It operates on `Offset.Exp.t` values paired with `GoblintCil.exp` expressions and CIL types, supporting static analysis of C arrays and structs by modeling dynamic index behavior and facilitating type-aware offset manipulations. Key applications include symbolic execution and abstract interpretation tasks where precise offset tracking and transformation are critical.",
      "description_length": 581,
      "index": 582,
      "embedding_norm": 1.0
    },
    {
      "module_path": "IntDomain.IntDomWithDefaultIkind",
      "library": "goblint_cdomain_value",
      "description": "This module provides lattice-theoretic operations (join, meet, widen, narrow) and arithmetic/bitwise manipulations for abstract integer domains represented as type `t`, which models integers through intervals, exclusion sets, and congruences. It handles domain-specific constructions like bounded intervals with overflow tracking, precision adjustments via projection, and invariant extraction, supporting static analysis tasks such as value range tracking and overflow detection in C programs. The type `t` interacts with integer kinds (`ikind`) for casting and domain-specific comparisons, enabling precise abstract interpretation in scenarios like Goblint's static analyzer.",
      "description_length": 677,
      "index": 583,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "IntDomain.Interval32",
      "library": "goblint_cdomain_value",
      "description": "This module supports lattice operations (join, meet, widen) and arithmetic/bitwise manipulations (addition, shifts, logical ops) on 32-bit integer intervals, with explicit handling of overflow warnings and precision control. It operates on abstract intervals represented by type `t` and interacts with concrete 64-bit integers (`int_t`) for precise conversions, while providing utilities for invariants extraction and overflow-aware interval construction. Designed for static analysis tasks like abstract interpretation, it models C-like integer behavior, enabling rigorous analysis of integer ranges, overflow conditions, and domain-specific transformations in low-level code.",
      "description_length": 677,
      "index": 584,
      "embedding_norm": 1.0
    },
    {
      "module_path": "NullByteSet.MustSet",
      "library": "goblint_cdomain_value",
      "description": "This module provides a set abstraction for tracking positions of `NULL` bytes in C arrays using big integers (`Z.t`) and a lifted domain with `Top` and `Lifted` tags to model unbounded or precise states. It supports standard set operations (union, intersection, difference, membership) alongside lattice-based manipulations like `join`, `meet`, and widening/narrowing for static analysis tasks such as buffer overflow detection and string termination verification. The domain also includes utilities for serialization, comparison, and element-level queries (e.g., `min_elt`, `interval_mem`) to enable precise abstract interpretation in program analysis workflows.",
      "description_length": 663,
      "index": 585,
      "embedding_norm": 1.0
    },
    {
      "module_path": "FloatDomain.FloatDomTupleImpl",
      "library": "goblint_cdomain_value",
      "description": "This module implements abstract domain operations for C floating-point numbers, encompassing arithmetic (addition, multiplication, trigonometric functions), comparisons (ordering, equality), lattice operations (join, meet, widening), and domain transformations (interval construction, type conversions to/from integers). It operates on abstract values represented as intervals or domain tuples parameterized by floating-point kinds, supporting static analysis tasks like program verification, range analysis, and symbolic reasoning about floating-point behaviors, including handling of special values (NaN, infinity) and domain-specific predicates (signbit, normality checks).",
      "description_length": 676,
      "index": 586,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ThreadIdDomain.Lift",
      "library": "goblint_cdomain_value",
      "description": "This module provides lattice operations for tracking thread identity states using a three-level hierarchy (`Bottom`, `Lifted` of thread values, `Top`), enabling abstract interpretation of concurrent programs. It supports join/meet combinations, widening/narrowing for convergence, and ordering comparisons to model thread state approximations during static analysis. These capabilities are specifically used to reason about thread lifecycle and synchronization in concurrent systems while allowing integration with analysis frameworks via string/XML/Yojson representations.",
      "description_length": 573,
      "index": 587,
      "embedding_norm": 1.0
    },
    {
      "module_path": "IntDomain.PtrDiffIkind",
      "library": "goblint_cdomain_value",
      "description": "Handles pointer difference operations and integer kind selection for abstract integer domains. Works with C integer types and pointer arithmetic expressions. Used to model differences between pointers in memory and determine appropriate integer representations for analysis.",
      "description_length": 274,
      "index": 588,
      "embedding_norm": 1.0
    },
    {
      "module_path": "AddressDomain.AddressBase",
      "library": "goblint_cdomain_value",
      "description": "This module defines a type `t` representing abstract pointers, including addresses, null pointers, unknown pointers, and string literals. It provides operations for equality checking, hashing, comparison, conversion to and from strings, and extracting string lengths, primarily used for analyzing pointer values in memory. Concrete use cases include tracking string literal pointers in C code and determining pointer equivalence in static analysis.",
      "description_length": 448,
      "index": 589,
      "embedding_norm": 1.0
    },
    {
      "module_path": "IntDomain.BISet",
      "library": "goblint_cdomain_value",
      "description": "This module provides lattice operations (join, meet, widen, narrow) and set algebra (union, intersection, difference) for bounded integer sets, alongside membership checks, element manipulation, and traversal functions. It operates on sets of arbitrary-precision integers (`Z.t`), structured as `IntDomain.BISet.t`, with explicit support for lattice semantics like top/bottom elements. Designed for static analysis, it enables precise tracking of integer ranges and value sets in program variables, particularly for domain-specific constraints and solver-driven analyses.",
      "description_length": 571,
      "index": 590,
      "embedding_norm": 1.0
    },
    {
      "module_path": "WrapperFunctionAnalysis0.MakeUniqueCount",
      "library": "goblint_cdomain_value",
      "description": "This module provides lattice operations and utility functions for managing integer-based unique count values, including equality checks, ordering, serialization, and lattice combinators like join, meet, and widen. It works with a type `t` representing counts in a lattice structure, supporting extremal value checks (`is_bot`, `is_top`, `top`) for data flow analysis. It is used to track unique call counts in wrapper function analysis while avoiding circular dependencies through context-aware tagging and modular composition.",
      "description_length": 527,
      "index": 591,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ConcDomain.ThreadCreation",
      "library": "goblint_cdomain_value",
      "description": "This module provides lattice-based operations (join, meet, widen, narrow) to model thread creation properties like uniqueness, parent-child hierarchies, and exit states, alongside utilities for identity tracking and static analysis of concurrent programs. It operates on composite data structures that bundle uniqueness identifiers, parent thread sets, and dirty exit flags, enabling precise representation of thread relationships and lifecycle states. The module also supports serialization to formats like XML and JSON, along with diff generation for tracking behavioral changes, making it suitable for concurrency analysis tools requiring robust state comparison and persistence.",
      "description_length": 682,
      "index": 592,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "ConcDomain.ThreadStringSet",
      "library": "goblint_cdomain_value",
      "description": "This module provides lattice operations (join, meet, widening) and standard set manipulations (union, intersection, membership checks) for thread-safe string sets, with atomic modification and query capabilities. It operates on sets of strings (`Printable.Strings.t`) designed for concurrent access, supporting transformations like filtering, cardinality tracking, and serialization. These abstractions are particularly useful in concurrent programming scenarios requiring shared state management and static analysis tasks such as data flow tracking across threads.",
      "description_length": 565,
      "index": 593,
      "embedding_norm": 1.0
    },
    {
      "module_path": "StructDomain.Simple",
      "library": "goblint_cdomain_value",
      "description": "This module provides lattice-based operations (join, meet, widen, leq) and structural manipulation functions (creation, field access, folding) for analyzing hierarchical data. It operates on associative maps that associate field names with abstract values, modeling structured data like C structs. These capabilities enable use cases such as static analysis of program states, invariant generation for composite data structures, and merging divergent execution paths through domain-specific value functions.",
      "description_length": 507,
      "index": 594,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "ThreadIdDomain.ThreadLiftNames",
      "library": "goblint_cdomain_value",
      "description": "Lifts thread names into a domain with boolean flags controlling expansion behavior. It uses string values to represent bottom and top states, applying logical operations based on the expansion settings. This supports abstract interpretation tasks where thread names are symbolically manipulated under domain constraints.",
      "description_length": 320,
      "index": 595,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ArrayDomain.NullByte",
      "library": "goblint_cdomain_value",
      "description": "This module implements a lattice-based abstract domain for tracking null bytes in C-style arrays, focusing on analyzing null-terminated strings and detecting buffer overflow risks. It operates on abstract arrays parameterized by index and element types, tracking null byte positions and array sizes while supporting operations like string copy, concatenation, substring extraction, and comparison. The domain integrates variable dependencies and invariants through smart join/widen operations, enabling precise analysis of string manipulation routines that could violate buffer bounds.",
      "description_length": 585,
      "index": 596,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "ThreadIdDomain.FlagConfiguredTID",
      "library": "goblint_cdomain_value",
      "description": "This module provides lattice operations and flag-based abstractions for analyzing thread IDs with tagged configurations, enabling precise modeling of thread creation hierarchies, synchronization states, and lifecycle transitions. It works with domain-specific thread ID types and configurations to track concurrency relationships, such as identifying newly created threads via the `created` function, which extracts active thread identifiers from domain values. The abstractions support static analysis of multi-threaded programs by capturing synchronization dependencies and ensuring thread uniqueness through abstract interpretation.",
      "description_length": 635,
      "index": 597,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ArrayDomain.PartitionedWithLength",
      "library": "goblint_cdomain_value",
      "description": "This module provides lattice-theoretic operations (join, meet, widen, narrow) and semantic-aware array manipulations for abstract interpretation of C arrays with explicit length tracking. It operates on partitioned array structures that associate elements with indices and maintain length metadata, enabling precise analysis of array bounds and element relationships. Key use cases include static analysis of C programs where array length propagation and element value constraints are critical, such as buffer overflow detection and memory safety verification using CIL representations.",
      "description_length": 586,
      "index": 598,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Offset.MakeLattice",
      "library": "goblint_cdomain_value",
      "description": "This module implements lattice operations (join, meet, widen, narrow) and semantic conversions for symbolic offset tracking in static analysis. It operates on offset values represented with indices and types from GoblintCil, enabling precise manipulation of array indices and struct fields through lattice-based abstractions. Key applications include symbolic reasoning about memory layouts and flow-sensitive analysis of low-level code constructs.",
      "description_length": 448,
      "index": 599,
      "embedding_norm": 1.0
    },
    {
      "module_path": "IntDomain.Lift",
      "library": "goblint_cdomain_value",
      "description": "This module implements a lattice-structured abstract domain for integers with three states: bottom, top, and lifted base values, supporting arithmetic, bitwise, and comparison operations while preserving ordering. It provides utilities to analyze integer ranges, congruences, and invariants through interval construction, exclusion sets, and overflow-aware type conversions. The design enables static analysis tasks like value tracking, constant extraction, and test generation by combining lattice operations (join/meet/widen) with domain-specific predicates and XML/Yojson serialization.",
      "description_length": 589,
      "index": 600,
      "embedding_norm": 1.0
    },
    {
      "module_path": "IntDomain.SOverflowUnlifter",
      "library": "goblint_cdomain_value",
      "description": "This module supports arithmetic (addition, multiplication, division), bitwise (shifts, logical operations), and lattice operations (join, meet) on abstract integer domains that track overflow states using intervals, congruences, and exclusion lists. It provides precision-controlled overflow handling through type casting, narrowing/widening, and overflow-aware comparisons to model integer ranges and constraints in static analysis. These capabilities are applied to verify C programs where overflow behavior impacts correctness, such as buffer length calculations or arithmetic safety checks.",
      "description_length": 594,
      "index": 601,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ValueDomain.Blobs",
      "library": "goblint_cdomain_value",
      "description": "This module provides lattice operations (join, meet, widen) and transformations for abstract blobs composed of values, sizes, and zero-initialization flags. It supports static analysis tasks like memory state modeling, type-driven invalidation, and difference tracking in abstract interpretation. Key operations include value extraction, lattice constants (bot/top), and predicates for domain analysis, with applications in type-based memory invalidation and state comparison.",
      "description_length": 476,
      "index": 602,
      "embedding_norm": 1.0
    },
    {
      "module_path": "JmpBufDomain.JmpBufSetTaint",
      "library": "goblint_cdomain_value",
      "description": "This module combines a set of `setjmp` buffers with a boolean taint abstraction into a lattice-based domain, enabling static analysis of taint propagation through `longjmp` operations. It provides standard abstract domain operations like join, meet, and widening, alongside utilities for serialization, differential state comparison, and structured data extraction. The domain is particularly suited for tracking potential taint in `setjmp` buffer states across non-local control flows in C programs.",
      "description_length": 500,
      "index": 603,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ValueDomain.Compound",
      "library": "goblint_cdomain_value",
      "description": "This module supports manipulation of compound data structures in abstract interpretation, handling polymorphic abstract values that represent base types, composites (structs, unions, arrays), and concurrency primitives. It provides lattice operations (join, meet, widen) alongside type-aware transformations for offset evaluation, array length tracking, and cast safety checks, operating on CIL expressions and GoblintCil types. Designed for static analysis of memory and type states, it enables precise modeling of complex data layouts in C programs, particularly for tracking structured data flow and concurrency-related properties.",
      "description_length": 634,
      "index": 604,
      "embedding_norm": 1.0
    },
    {
      "module_path": "WrapperFunctionAnalysis0.NodeFlatLattice",
      "library": "goblint_cdomain_value",
      "description": "This module implements a flat lattice structure with three distinct states\u2014bottom, top, and lifted node values\u2014to support abstract interpretation in static analysis. It provides core lattice operations like join, meet, widen, and narrow, alongside utilities for comparing, serializing, and generating test values, all operating on elements that encapsulate `Node.t` in a hierarchical abstraction. These capabilities enable precise dataflow analysis for wrapper function queries while resolving circular dependency constraints in the module hierarchy.",
      "description_length": 550,
      "index": 605,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "ValueDomain.ValueInvariant",
      "library": "goblint_cdomain_value",
      "description": "This module generates invariants for analyzing program values by tracking variable relationships through set operations and transformations. It works with variable sets (`Basetype.Variables.t`), lvalues, offsets, and domain-specific values like `AD.t`, `Blobs.t`, and `CArrays.value`. It is used to enforce constraints during static analysis tasks such as liveness detection, dependency tracking, and memory access validation.",
      "description_length": 426,
      "index": 606,
      "embedding_norm": 1.0
    },
    {
      "module_path": "IntDomain.FlatPureIntegers",
      "library": "goblint_cdomain_value",
      "description": "This module provides lattice operations (join, meet, top, bot) with strict equality constraints, precise arithmetic (addition, multiplication, division), and bitwise operations (shifts, logical AND) on 64-bit integers. It operates on abstract values structured in a flattened lattice, representing constants, exclusion sets, or extremal states, while enforcing C-compatible integer semantics. It is used in static analysis for modeling integer ranges with exact comparisons, verifying program invariants, and handling congruence-based domains with strict ordering requirements.",
      "description_length": 577,
      "index": 607,
      "embedding_norm": 1.0
    },
    {
      "module_path": "FloatDomain.F64Interval",
      "library": "goblint_cdomain_value",
      "description": "This module provides lattice operations (join, meet, widen, narrow), arithmetic (addition, multiplication, min/max), and interval-specific utilities (bound setting, exactness checks) for representing and manipulating ranges of 64-bit floating-point values. It operates on intervals defined by lower and upper bounds, supporting mathematical transformations, comparisons, and conversions to boolean domains. Use cases include abstract interpretation for static analysis of numerical computations, such as tracking possible value ranges of floating-point variables in programs or verifying safety properties in scientific simulations.",
      "description_length": 632,
      "index": 608,
      "embedding_norm": 1.0
    },
    {
      "module_path": "PreValueDomain.AD",
      "library": "goblint_cdomain_value",
      "description": "This module provides lattice operations (join, meet, widen, narrow) for abstract address analysis with offset arithmetic and type tracking, alongside set-like manipulation of pointer values. It operates on abstract addresses (`elt`) and pointer sets (`t`), supporting functional transformations, filtering, and domain-specific queries like null checks. Designed for static analysis, it enables reasoning about pointer sets, string/integer conversions, and memory state approximations in program verification tasks.",
      "description_length": 514,
      "index": 609,
      "embedding_norm": 1.0
    },
    {
      "module_path": "IntDomain.Integers",
      "library": "goblint_cdomain_value",
      "description": "This module provides lattice operations (join, meet, widen) and arithmetic/bitwise operations (add, mul, shifts) for an abstract integer domain. It works with an abstract type representing C integers, supporting ranges, exclusion sets, and congruences, and is used for static analysis tasks like invariant generation and domain construction from intervals. Functions follow C semantics for conversions and operations, enabling precise abstract interpretation of integer variables in programs.",
      "description_length": 492,
      "index": 610,
      "embedding_norm": 1.0
    },
    {
      "module_path": "IntDomain.DefExc",
      "library": "goblint_cdomain_value",
      "description": "The module provides lattice operations, arithmetic manipulations, and exclusion set management for analyzing integer values with constrained ranges. It operates on domains representing integers augmented with excluded intervals, congruences, and bitwise properties, enabling precise tracking of value constraints in C code branches. This supports use cases like verifying conditional invariants and refining integer variable ranges during static analysis.",
      "description_length": 455,
      "index": 611,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ArrayDomain.TrivialWithLength",
      "library": "goblint_cdomain_value",
      "description": "This module provides lattice operations (join, meet, widen, narrow, leq) and array abstractions for single-cell arrays with length tracking. It works with arrays storing elements of a single abstract value type, paired with an index type representing length, and supports operations like element retrieval with bounds checks. Designed for abstract interpretation scenarios where arrays are modeled as either unknown-length or fixed-length structures in static analysis contexts.",
      "description_length": 478,
      "index": 612,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "ValueDomain.Structs",
      "library": "goblint_cdomain_value",
      "description": "This module offers lattice operations (join, meet, widen) and functional manipulation of abstract values representing structured data, such as C structs, using algebraic data types and HConsed representations. It enables precise field-level access, arbitrary value generation, and serialization for analysis workflows. Designed for static analysis, it supports modeling complex data structures and data flow transformations in domains like program verification.",
      "description_length": 461,
      "index": 613,
      "embedding_norm": 1.0
    },
    {
      "module_path": "JmpBufDomain.BufferEntry",
      "library": "goblint_cdomain_value",
      "description": "This module defines operations for handling buffer entries used in `setjmp` and `longjmp` analyses. It works with tuples consisting of a `Node.t` and a `ControlSpecC.t`, providing equality checks, comparison, hashing, string representation, and serialization functions. Concrete use cases include tracking and comparing control flow states during static analysis of programs using jump buffers.",
      "description_length": 394,
      "index": 614,
      "embedding_norm": 1.0
    },
    {
      "module_path": "UnionDomain.Simple",
      "library": "goblint_cdomain_value",
      "description": "This module provides lattice operations (join, meet, widen) and value comparison capabilities for abstract interpretation of C unions, operating on structured pairs of union fields and associated abstract values. It supports domain combination, invariant handling, and transformation workflows through XML/Yojson serialization, while pretty-printing utilities enable debugging and difference analysis in static analysis tools. Key use cases include merging union state representations during analysis and persisting domain-specific value relationships for verification tasks.",
      "description_length": 575,
      "index": 615,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ValueDomain.AddrSetDomain",
      "library": "goblint_cdomain_value",
      "description": "This module provides lattice operations (join, meet, widen, narrow) and set manipulations (union, intersection, membership checks) for handling address sets with a top state. It works with a domain represented as a sum",
      "description_length": 218,
      "index": 616,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "IntDomain",
      "library": "goblint_cdomain_value",
      "description": "This module provides abstract integer domains for static analysis, supporting arithmetic and bitwise operations with overflow tracking, lattice manipulations, and precision control. It operates on data structures such as intervals, congruences, exclusion sets, and lifted representations to model C integer semantics, enabling use cases like overflow detection, invariant generation, constant propagation, and abstract interpretation with domain-specific refinements. The domains facilitate type-aware analysis and constraint propagation for precise value range determination and pointer difference modeling.",
      "description_length": 608,
      "index": 617,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mval_intf",
      "library": "goblint_cdomain_value",
      "description": "Defines type signatures for lattice-based abstract values used in static analysis. It includes operations for comparing, combining, and printing abstract values. Suitable for implementing abstract interpretation domains like sign analysis or constant propagation.",
      "description_length": 263,
      "index": 618,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ThreadIdDomain",
      "library": "goblint_cdomain_value",
      "description": "This module implements thread ID abstractions for concurrency analysis, providing structured operations to track thread creation, parent-child relationships, and synchronization states. It includes concrete data types like `thread` (with `Thread` and `UnknownThread` variants) and supports domain-specific reasoning through lattice operations, hashing, and comparison functions. Use cases include static analysis of concurrent programs for data race detection, thread lifecycle modeling, and hierarchical execution trace analysis.",
      "description_length": 530,
      "index": 619,
      "embedding_norm": 1.0
    },
    {
      "module_path": "UnionDomain",
      "library": "goblint_cdomain_value",
      "description": "This module implements abstract interpretation domains for analyzing C unions, providing lattice operations and value comparisons for tracking field states. It works with structured pairs of union fields and abstract values, supporting serialization and pretty-printing for debugging. Used to merge and persist union state representations during static analysis and verification tasks.",
      "description_length": 385,
      "index": 620,
      "embedding_norm": 1.0
    },
    {
      "module_path": "InvariantCil",
      "library": "goblint_cdomain_value",
      "description": "This module provides functions to manipulate and analyze CIL expressions and variables during transformations, such as replacing variables with their original names, checking variable scope, and identifying temporary or heap-allocated variables. It works with CIL types like `varinfo`, `exp`, and `fundec`, along with regexps for filtering. Concrete use cases include normalizing expressions for analysis, excluding temporary variables from invariants, and handling type unrolling in transformed code.",
      "description_length": 501,
      "index": 621,
      "embedding_norm": 1.0
    },
    {
      "module_path": "WrapperFunctionAnalysis0",
      "library": "goblint_cdomain_value",
      "description": "This module defines lattice structures and operations for tracking unique call counts, memory allocations, thread creations, and node states in static analysis. It works with integer-based types and abstract node values, providing join, meet, widen, and comparison functions tailored to data flow analysis needs. Concrete use cases include resolving circular dependencies in wrapper function analysis, aggregating allocation counts, managing thread-local state, and enabling hierarchical abstract interpretation.",
      "description_length": 512,
      "index": 622,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "ValueDomain",
      "library": "goblint_cdomain_value",
      "description": "This module provides abstractions for analyzing low-level program values, including memory offsets, address sets, compound data, and arrays. It supports precise tracking of structured and union types, dynamic memory allocations, and string/array manipulations through lattice operations and type-aware transformations. Concrete use cases include static analysis of memory accesses, type state verification, and constraint enforcement in program analysis workflows.",
      "description_length": 464,
      "index": 623,
      "embedding_norm": 1.0
    },
    {
      "module_path": "WideningThresholds",
      "library": "goblint_cdomain_value",
      "description": "This module manages numeric thresholds used during abstract interpretation widening. It provides access to predefined lists of integer thresholds for general, octagon, upper, and lower bounds, as well as a resettable lazy list of CIL expressions representing those thresholds. These values are used to control precision and performance in static analysis by limiting the number of widening steps.",
      "description_length": 396,
      "index": 624,
      "embedding_norm": 1.0
    },
    {
      "module_path": "PreValueDomain",
      "library": "goblint_cdomain_value",
      "description": "This module provides abstract domains for analyzing integer indices, memory offsets, and pointer values with lattice operations, arithmetic, and type-aware transformations. It works with abstract values representing integer ranges, symbolic expressions, memory states, and CIL-typed entities to enable precise static analysis of program properties like invariants, pointer aliasing, and memory accesses. Concrete use cases include tracking index bounds, modeling pointer arithmetic, and analyzing memory states during abstract interpretation.",
      "description_length": 542,
      "index": 625,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ArrayDomain",
      "library": "goblint_cdomain_value",
      "description": "This module defines abstract domains for analyzing C arrays, including operations to determine domain selection based on variable and type attributes. It supports domains like TrivialDomain, PartitionedDomain, and UnrolledDomain, each influencing how array values and memory are abstracted during static analysis. It is used to model array behavior in different analysis contexts, such as tracking uninitialized values or handling array invalidation and null pointers.",
      "description_length": 468,
      "index": 626,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Invariant",
      "library": "goblint_cdomain_value",
      "description": "This module provides lattice operations (join, meet, widen, narrow) and logical combinators to manipulate abstract values composed of bottom (`Bot`), top (`Top`), and lifted (`Lifted`) states containing CIL expressions. It supports static analysis workflows by enabling abstraction refinement, witness validation, and difference visualization via pretty-printing utilities, particularly for symbolic expression analysis in program verification. The structure is designed to handle symbolic comparisons and serialization tasks in abstract interpretation frameworks.",
      "description_length": 564,
      "index": 627,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ValueDomainQueries",
      "library": "goblint_cdomain_value",
      "description": "This module evaluates integer expressions within abstract domains, determining properties like equality, ordering, and pointer targets through lattice operations. It works with integer expressions and abstract value domains represented using lattice structures, including sets and intervals. Concrete use cases include static analysis tasks such as value range inference, invariant detection, and pointer alias checking in program analysis.",
      "description_length": 440,
      "index": 628,
      "embedding_norm": 1.0
    },
    {
      "module_path": "FloatDomain",
      "library": "goblint_cdomain_value",
      "description": "This module provides arithmetic operations, lattice manipulations (join, meet, widen), and interval utilities for 32-bit and 64-bit floating-point intervals, along with domain-specific predicates and transformations. It works with abstract floating-point values represented as intervals or domain tuples, supporting operations such as addition, multiplication, comparisons, and handling of special values like NaN and infinity. Concrete use cases include static analysis of numerical programs for range tracking, constraint propagation, and verification of floating-point computations in safety-critical or scientific code.",
      "description_length": 623,
      "index": 629,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MutexAttrDomain",
      "library": "goblint_cdomain_value",
      "description": "This module provides lattice operations (join, meet, widen, narrow) and serialization utilities for a domain modeling mutex states, including bottom (`Bot`), concrete mutex kinds (`Lifted` with `Z.t` identifiers), and top (`Top`). It supports static analysis of concurrency by abstractly representing and combining mutex attributes, enabling reasoning about lock usage patterns in programs. The domain integrates with analysis frameworks through pretty-printing, diffing, and QCheck arbitraries for testing and verification workflows.",
      "description_length": 534,
      "index": 630,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mval",
      "library": "goblint_cdomain_value",
      "description": "This module handles memory values derived from CIL variables and offset structures, supporting precise manipulation and analysis of lvalues with pointer dereferences. It provides operations for lattice computations, offset combination, prefix checks, and conversion to CIL expressions or lvalues, tailored for pointer-sensitive static analysis. Concrete use cases include tracking memory accesses with exact or symbolic offsets, generating readable or structured representations, and performing abstract interpretation with offset-based abstractions.",
      "description_length": 550,
      "index": 631,
      "embedding_norm": 1.0
    },
    {
      "module_path": "AddressDomain",
      "library": "goblint_cdomain_value",
      "description": "This module provides operations for representing and manipulating abstract memory addresses, including pointer values, string literals, and null pointers. It supports equality checks, offset arithmetic, string conversion, and lattice operations for static analysis tasks such as tracking pointer provenance and modeling memory states. Concrete use cases include analyzing C code for pointer equivalence, handling string interning, and performing precise or symbolic address analysis.",
      "description_length": 483,
      "index": 632,
      "embedding_norm": 1.0
    },
    {
      "module_path": "JmpBufDomain",
      "library": "goblint_cdomain_value",
      "description": "This module provides domains for analyzing `setjmp` and `longjmp` behavior in C programs. It includes data structures for tracking buffer entries, jump targets, and modified variables, along with lattice operations for merging analysis states. Specific use cases include modeling control flow changes, taint propagation, and variable modifications across non-local jumps in static analysis.",
      "description_length": 390,
      "index": 633,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "NullByteSet",
      "library": "goblint_cdomain_value",
      "description": "This module implements abstract domains for tracking NULL byte positions in C arrays using precise and overapproximated sets of indices. It provides set operations, lattice manipulations, and interval queries to model null terminators for static analysis tasks such as buffer overflow detection and string termination verification. The submodules handle definite, possible, and combined null byte tracking using arbitrary-precision integers and lifted domains, supporting security analysis tools through membership checks and format serialization.",
      "description_length": 547,
      "index": 634,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Offset_intf",
      "library": "goblint_cdomain_value",
      "description": "This module defines equality, comparison, and hashing operations for index and offset types, ensuring consistent and safe manipulation of positions within fixed-size containers. It works directly with index and offset structures, enabling precise control over element addressing and iteration. Concrete use cases include validating index ranges, comparing positions in sequences, and hashing indices for efficient lookups in data structures like arrays or buffers.",
      "description_length": 464,
      "index": 635,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ConcDomain",
      "library": "goblint_cdomain_value",
      "description": "This module provides domains for modeling thread sets and string sets in concurrent program analysis. It includes operations for set manipulation, lattice-based abstraction, and thread lifecycle tracking, working with data structures like `ThreadSet.t` and composite types for thread creation properties. Concrete use cases include static analysis of thread interactions, data flow tracking across threads, and abstract interpretation of concurrent programs with shared state.",
      "description_length": 476,
      "index": 636,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Offset",
      "library": "goblint_cdomain_value",
      "description": "This module handles variable offsets for array indices and struct fields with operations like equality, comparison, and hashing over index types such as expressions, unit values, and integers. It supports concrete use cases in static analysis, including symbolic tracking of array indices, type-aware offset transformations, and lattice-based abstract interpretation for memory layouts. Specific submodules enable CIL-compatible offset modeling, structured index manipulation, and semantic analysis of low-level data access patterns.",
      "description_length": 533,
      "index": 637,
      "embedding_norm": 1.0
    },
    {
      "module_path": "AddressDomain_intf",
      "library": "goblint_cdomain_value",
      "description": "Defines operations for validating, parsing, and formatting network addresses, including IP and MAC addresses. Works with string and binary representations of addresses, supporting conversion and comparison. Used in network stack implementations and packet processing to ensure address correctness and interoperability.",
      "description_length": 318,
      "index": 638,
      "embedding_norm": 1.0
    },
    {
      "module_path": "StringDomain",
      "library": "goblint_cdomain_value",
      "description": "This module provides utilities for converting, comparing, and serializing abstract string values, alongside lattice-based operations like `join`, `meet`, and semantic ordering checks to model string constraints. It operates on abstract string representations structured as a lattice, enabling applications in static analysis where symbolic string manipulation or constraint resolution is required. Key features include canonical form extraction and support for structured output formats like JSON and XML.",
      "description_length": 505,
      "index": 639,
      "embedding_norm": 1.0
    },
    {
      "module_path": "PrecisionUtil",
      "library": "goblint_cdomain_value",
      "description": "This module provides operations to manage and query precision settings for integer and floating-point analysis in static analysis contexts. It works with global references and node-based configurations to enable/disable features like exceptions, intervals, and congruence tracking, while supporting derived precision modes from function declarations. Specific use cases include controlling analysis granularity and checking active precision constraints such as congruence requirements during program analysis.",
      "description_length": 509,
      "index": 640,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lval",
      "library": "goblint_cdomain_value",
      "description": "This module provides operations for analyzing and transforming CIL lvalues using set-based domains. It supports precise tracking of memory locations and variables through standard set operations and lattice manipulations, tailored for static analysis tasks like dataflow analysis and constraint propagation. Concrete use cases include representing program state at control flow graph nodes and performing variable usage analysis.",
      "description_length": 429,
      "index": 641,
      "embedding_norm": 1.0
    },
    {
      "module_path": "StructDomain",
      "library": "goblint_cdomain_value",
      "description": "This module implements abstract domains for analyzing C structs through lattice operations and structural manipulations. It works with associative maps and set-based representations that model struct fields as abstract values. Concrete use cases include static analysis of program states, field-level value tracking, and merging divergent execution paths in hierarchical data structures.",
      "description_length": 387,
      "index": 642,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CilMaps.VarinfoMap",
      "library": "goblint.incremental",
      "description": "This module offers a suite of map operations tailored for variable identifiers in the C Intermediate Language, enabling efficient insertion, lookup, iteration, and transformation of maps with `Varinfo` keys and arbitrary value types. It supports ordered traversal, sequence conversion, and structural queries, including functions for list-valued entries and key-based ordering, which are particularly applicable in program analysis tasks that require tracking variable-specific data or performing incremental comparisons during compilation or optimization passes.",
      "description_length": 563,
      "index": 643,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CompareCIL.VarinfoSet",
      "library": "goblint.incremental",
      "description": "This set abstraction manages collections of CIL variable information elements (`CilType.Varinfo.t`), supporting efficient membership tests, set algebra (union, intersection, difference), and structural comparisons. It facilitates iteration, transformation, and bulk conversion to/from lists and sequences, enabling workflows like analyzing variable overlaps between CIL files or tracking variable modifications during code comparison tasks.",
      "description_length": 440,
      "index": 644,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CilMaps.FundecForMap",
      "library": "goblint.incremental",
      "description": "Maps functions over CIL function declarations (`fundec`) using a comparison function for key ordering. It supports operations like `map`, `iter`, and `fold` on collections of function declarations. Useful for analyzing or transforming C functions in a structured, ordered way during static analysis.",
      "description_length": 299,
      "index": 645,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CompareCIL.GlobalColMap",
      "library": "goblint.incremental",
      "description": "This module provides a map structure for associating `CompareCIL.global_col` keys with arbitrary values, supporting insertion, deletion, lookup, and traversal operations, along with higher-order functions for merging maps, filtering entries, and transforming values. It includes utilities for converting between maps and sequences of key-value pairs, enabling incremental construction or decomposition of mappings. Such functionality is useful for tracking relationships between global variables or columns during CIL file comparisons, managing structured metadata, or processing hierarchical data with ordered key sequences.",
      "description_length": 625,
      "index": 646,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CilMaps.VarinfoOrdered",
      "library": "goblint.incremental",
      "description": "This module defines a comparison function for `GoblintCil.varinfo` values, enabling their use as keys in ordered map structures. It supports direct comparison of variable information records by their unique identifiers and attributes. This is essential for maintaining maps keyed by program variables in analyses that track variable state across code regions.",
      "description_length": 359,
      "index": 647,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CompareAST.StringMap",
      "library": "goblint.incremental",
      "description": "This module provides operations for managing maps with string keys and arbitrary-value or list-based entries, supporting addition, removal, lookup, and merging of entries. It includes specialized functions for combining maps, filtering, transforming, and iterating over key-value pairs in both standard and reverse order, along with conversions to and from sequences and lists. These capabilities are designed for tasks like tracking and comparing structured data in CIL AST analysis, such as aggregating differences or merging attributes associated with string-identified elements.",
      "description_length": 582,
      "index": 648,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CompareCFG.NH",
      "library": "goblint.incremental",
      "description": "This module offers a hash table structure mapping `Node.t` keys to polymorphic values, supporting imperative operations like insertion, lookup, iteration, and folding, alongside in-place value transformations and bulk updates from sequences. It is designed for efficient management of node-centric data in scenarios such as CFG analysis, where dynamic tracking of node attributes or relationships is required. The ability to filter and transform values during iteration makes it suitable for incremental updates and attribute propagation tasks.",
      "description_length": 544,
      "index": 649,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CilMaps.FundecMap",
      "library": "goblint.incremental",
      "description": "This module provides associative maps keyed by CIL function declarations, supporting operations for traversal, transformation, and filtering of polymorphic value mappings. It includes utilities for ordered binding extraction, incremental comparison, and bidirectional conversion to lazy sequences, enabling efficient analysis of C code structures. Typical use cases involve static analysis tools that track function-specific data or perform incremental transformations on CIL representations.",
      "description_length": 492,
      "index": 650,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Serialize.Cache",
      "library": "goblint.incremental",
      "description": "This module caches incremental analysis data in memory before persisting it to disk, supporting operations to update, retrieve, and reset cached values. It works with opaque data types like `Obj.t`, `GoblintCil.file`, and `MaxIdUtil.max_ids`, organized in a mutable record with optional fields. Concrete use cases include storing and loading solver and version data during analysis runs, and managing cached CIL file representations in server mode.",
      "description_length": 448,
      "index": 651,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CilMaps",
      "library": "goblint.incremental",
      "description": "This module implements specialized ordered map structures for working with CIL function declarations and variable identifiers. It provides operations like `map`, `iter`, `fold`, and key-based comparison to support static analysis tasks that require tracking function- or variable-specific data. Concrete use cases include incremental comparison during code analysis, ordered traversal of function or variable mappings, and transformation of CIL structures with preserved key ordering.",
      "description_length": 484,
      "index": 652,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "UpdateCil",
      "library": "goblint.incremental",
      "description": "This module combines CIL files based on comparison results, updating identifiers and locations to avoid dependency cycles. It maps nodes to source locations, initializes state, and updates CIL files with new IDs according to change information. Used during incremental analysis to merge and adjust CIL representations after code changes.",
      "description_length": 337,
      "index": 653,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CompareCFG",
      "library": "goblint.incremental",
      "description": "This module enables structural comparison of control flow graphs (CFGs) by handling variable and method renaming through bidirectional node mappings and type equivalence tracking. It operates on CIL-based CFGs using GoblintCil and MyCFG data structures, leveraging imperative hash tables for attribute management during recursive equality checks of elements like constants, expressions, and edges. Specific applications include analyzing transformed CFGs with renamed identifiers, detecting recursive type equivalences, and verifying structural consistency across refactored codebases.",
      "description_length": 585,
      "index": 654,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MakefileUtil",
      "library": "goblint.incremental",
      "description": "This module handles file manipulation and command execution for a build process using Makefiles. It provides functions to locate files by suffix, execute shell commands with optional paths, generate and combine output files, and clean up intermediate files. Specific use cases include running the Cilly compiler, combining results, and managing temporary files during the build.",
      "description_length": 378,
      "index": 655,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CompareCIL",
      "library": "goblint.incremental",
      "description": "This module enables structural equivalence checks between CIL files by comparing types, expressions, statements, and control flow graphs (CFGs) while managing renaming mappings to account for variable, function, or global entity equivalences. It utilizes data structures like `rename_mapping`, `change_info`, and specialized maps (`GlobalMap`, `VarinfoSet`) to track differences in global declarations, identify renamed entities, and determine whether changes require reanalysis, supporting precise change detection across CIL file versions.",
      "description_length": 541,
      "index": 656,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Serialize",
      "library": "goblint.incremental",
      "description": "This module handles serialization and deserialization of incremental analysis data, providing functions to save and load data to and from disk using operations like `Save` and `Load`. It works with arbitrary types through marshaling, file paths represented by `Fpath.t`, and opaque data types such as `Obj.t`, `GoblintCil.file`, and `MaxIdUtil.max_ids`. It is used to store and retrieve solver data, version information, and CIL file representations during analysis runs, particularly in server mode where caching and persistence are required.",
      "description_length": 543,
      "index": 657,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "CompareAST",
      "library": "goblint.incremental",
      "description": "This module enables structural comparison of CIL AST components, including variables, types, expressions, and statements, by accounting for renamed identifiers through custom mappings. It uses `rename_mapping` structures to track equivalent names and type equivalence accumulators to resolve recursive type relationships during comparisons. These capabilities support tasks like verifying code equivalence after refactoring, analyzing type compatibility across ASTs, or aligning variables and types between differently named but semantically equivalent programs.",
      "description_length": 562,
      "index": 658,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MaxIdUtil",
      "library": "goblint.incremental",
      "description": "This module tracks and updates the maximum statement and variable IDs (sids and vids) used in CIL files. It provides functions to update ID counters based on CIL global declarations and to retrieve the maximum IDs from a given CIL file. Concrete use cases include managing unique ID assignment during CIL transformation passes and ensuring ID consistency across merged CIL files.",
      "description_length": 379,
      "index": 659,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Control.AnalyzeCFG.CompareGlobSys.Sys.G.CSet",
      "library": "goblint.lib",
      "description": "This module provides a functional set abstraction for comparing and manipulating constraint systems in static analysis, supporting lattice operations like join and meet alongside standard set queries (union, intersection, subset checks) over elements representing program constraints. It works with constraint elements from a specification module, enabling use cases such as merging global constraint states during control flow analysis or verifying relationships between constraint sets. The inclusion of serialization, pretty-printing, and arbitrary value generation also supports debugging, testing, and persistent storage of analysis results.",
      "description_length": 646,
      "index": 660,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.YamlWitness.Validator.Locator.FileH.Exceptionless",
      "library": "goblint.lib",
      "description": "Performs key-based lookup and modification in a file handle locator structure without raising exceptions. Works with `'a Locator.FileH.t` maps and handles errors by returning `option` or `result` types. Useful for safely accessing and updating file-associated data in witness validation workflows.",
      "description_length": 297,
      "index": 661,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Control.AnalyzeCFG.CompareGlobSys.GH.Infix",
      "library": "goblint.lib",
      "description": "This module defines operations for manipulating and querying a global system (`GH.t`) that maps keys to values. It provides direct access and update operations via the `(-->)` and `(<--)` operators, enabling key-based value retrieval and in-place modifications. Concrete use cases include tracking and updating analysis state during constraint solving in abstract interpretation.",
      "description_length": 379,
      "index": 662,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Control.AnalyzeCFG.SpecSys.LHT.Labels",
      "library": "goblint.lib",
      "description": "This module provides labeled versions of standard hash table operations, enhancing readability and argument order flexibility for functions like `add`, `replace`, `iter`, `map`, `filter`, and `fold`. It works with hash tables (`Hashtbl`) where keys and data are tied to the `SpecSys.LHT` specification, supporting analysis within constraint-solving frameworks. Concrete use cases include tracking and manipulating labeled program analysis data, such as variable bindings or constraint mappings, during abstract interpretation.",
      "description_length": 526,
      "index": 663,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.YamlWitness.Validator.Locator.FileH.Labels",
      "library": "goblint.lib",
      "description": "This module operates on labeled file handles within a YAML witness structure, enabling precise manipulation of keyed data entries. It supports adding, replacing, filtering, and transforming values associated with file handles using their keys. Use cases include validating and modifying structured YAML witness data, such as tracking source file annotations or adjusting witness properties during static analysis.",
      "description_length": 413,
      "index": 664,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ExtractPthread.Codegen.AdjacencyMatrix.HashtblN.Labels",
      "library": "goblint.lib",
      "description": "This module implements a labeled adjacency matrix using a hash table with support for key-value operations, transformations, and filtering. It provides functions to add, replace, modify, and query entries based on keys, as well as higher-order operations like map, fold, and merge over labeled graph nodes. It is used to represent and manipulate control flow or state transition graphs during Pthread-to-Promela translation, where keys represent control points and values encode transitions or labels.",
      "description_length": 501,
      "index": 665,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.YamlWitness.Validator.Locator.FileH.Infix",
      "library": "goblint.lib",
      "description": "This module provides infix operators for navigating and modifying YAML witness data structures using file handles. It supports operations to get (`-->`) and set (`<--`) values at specific keys within a YAML document. These functions are used to directly manipulate YAML witness trees in memory during validation or construction.",
      "description_length": 328,
      "index": 666,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Witness.Result.ArgTool.NHT.Labels",
      "library": "goblint.lib",
      "description": "This module operates on labeled data structures within a nested hash table (NHT) context, providing functions to manipulate key-value pairs with specific label-based operations. It supports transformations, filtering, and merging of NHT instances, where each entry is associated with a key and a value. Concrete use cases include refining analysis results by labels, aggregating data across multiple NHTs, and modifying nested values in place during static analysis phases.",
      "description_length": 473,
      "index": 667,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Control.AnalyzeCFG.CompareGlobSys.Sys.LVar",
      "library": "goblint.lib",
      "description": "This module defines operations for comparing, hashing, and pretty-printing labeled variables represented as pairs of CFG nodes and constraint system values. It provides utilities to extract locations, generate XML output, and retrieve variable identifiers for analysis artifacts. These functions support constraint solving and path analysis in the context of abstract interpretation.",
      "description_length": 383,
      "index": 668,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Control.AnalyzeCFG.CompareGlobSys.Sys.G",
      "library": "goblint.lib",
      "description": "This module provides lattice operations (join, meet, widening, narrowing) and comparison utilities for combined abstract domains, specifically handling constraint systems and analysis states represented as `SpecSys.Spec.G.t` and `CSet.t`. It enables merging and comparing global constraint sets during static analysis, particularly in abstract interpretation workflows where multiple domains are composed. The functionality supports tasks like analyzing control flow paths by combining constraints from different program points or contexts.",
      "description_length": 540,
      "index": 669,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.YamlWitness.Validator.Locator.LocM.Infix",
      "library": "goblint.lib",
      "description": "This module provides infix operators for manipulating location-based monadic values in YAML witness validation. It supports operations to bind and retrieve values associated with specific keys in a structured, context-aware manner. Concrete use cases include tracking and validating nested YAML node positions during static analysis of program paths.",
      "description_length": 350,
      "index": 670,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Control.AnalyzeCFG.CompareGlobSys.LH.Infix",
      "library": "goblint.lib",
      "description": "This module provides infix operators `(-->)` and `(<--)` for mapping and retrieving values associated with keys in a `CompareGlobSys.LH.t` structure. It works with key-value pairs where keys conform to `CompareGlobSys.LH.key` and values are polymorphic. Concrete use cases include managing analysis results during CFG traversal, such as associating abstract states with specific program points or variables.",
      "description_length": 407,
      "index": 671,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.UnassumeAnalysis.Spec.Locator.LocM.Labels",
      "library": "goblint.lib",
      "description": "This module implements a key-value map for associating arbitrary data with location keys in the unassume analysis. It supports standard map operations like insertion, iteration, mapping, filtering, and folding over location-keyed entries. Use this to track and manipulate location-specific unassume annotations from YAML witnesses during analysis.",
      "description_length": 347,
      "index": 672,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.UnassumeAnalysis.Spec.Locator.FileH.Labels",
      "library": "goblint.lib",
      "description": "This module implements a labeled key-value store for managing unassume analysis events tied to file locations. It supports associative operations like insertion, modification, filtering, and merging over a typed key structure, enabling precise tracking and transformation of analysis data. Concrete use cases include propagating and refining unassume invariants across program points during static analysis.",
      "description_length": 407,
      "index": 673,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Control.AnalyzeCFG.Slvr.VH.Exceptionless",
      "library": "goblint.lib",
      "description": "This module provides operations to safely query and update a map-like structure using keys, where values are optional and modifications may fail due to exceptions. It works with polymorphic maps (`'a Slvr.VH.t`) and a corresponding key type. Concrete use cases include tracking and updating analysis state during constraint solving in a control flow graph, where partiality and failure must be explicitly handled.",
      "description_length": 413,
      "index": 674,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Control.AnalyzeCFG.SpecSys.LHT.Infix",
      "library": "goblint.lib",
      "description": "This module defines infix operators for interacting with a hash table implementation (`BatHashtbl`). The `-->` operator retrieves the current value associated with a key, while `<--` binds a new value to a key, preserving previous bindings. These operations are used to manage temporary or layered state during constraint solving in abstract interpretation analyses.",
      "description_length": 366,
      "index": 675,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.UnassumeAnalysis.Spec.Locator.ES.Exceptionless",
      "library": "goblint.lib",
      "description": "This module provides functions to query and retrieve elements from a collection of locator entries without raising exceptions. It supports operations like finding the minimum or maximum element, selecting an arbitrary element, or checking for the presence of a specific element. These functions are used to process and analyze YAML witness invariants by extracting relevant locator information in a safe and predictable manner.",
      "description_length": 427,
      "index": 676,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Control.AnalyzeCFG.CompareGlobSys.GH.Labels",
      "library": "goblint.lib",
      "description": "This module provides dictionary-like operations for manipulating keyed data structures, supporting insertion, modification, iteration, filtering, and merging based on keys and values. It works with a hash table-like structure parameterized over keys of type `CompareGlobSys.GH.key` and data of type `'a`. Concrete use cases include tracking and transforming per-node analysis results during control flow graph processing, such as aggregating or comparing abstract states at specific program points.",
      "description_length": 498,
      "index": 677,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MutexAnalysis.Spec.Arg.MakeP.P",
      "library": "goblint.lib",
      "description": "This module combines lattice operations for tracking read/write and write-only mutex states with utilities for serializing analysis results and generating structured diffs. It operates on a product domain type that merges distinct mutex state representations, enabling precise static analysis of concurrent programs. Typical use cases include verifying locking discipline in multithreaded code and debugging analysis precision through human-readable comparisons of abstract states.",
      "description_length": 481,
      "index": 678,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MutexAnalysis.Spec.Arg.MakeP.Write",
      "library": "goblint.lib",
      "description": "This module provides lattice operations (join, meet, widen, narrow) and supporting utilities (equality, hashing, pretty-printing)",
      "description_length": 129,
      "index": 679,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.UnassumeAnalysis.Spec.Locator.ES.Labels",
      "library": "goblint.lib",
      "description": "This module processes sets of elements representing unassume event labels. It provides standard collection operations like iteration, folding, filtering, and mapping over these elements. Use it to analyze or transform sets of unassume labels derived from YAML witness invariants during static analysis.",
      "description_length": 302,
      "index": 680,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.UnassumeAnalysis.Spec.Locator.LocM.Infix",
      "library": "goblint.lib",
      "description": "This module defines infix operators for manipulating location-based monadic values in the unassume analysis. It provides `-->` to extract a value associated with a key from a location monad and `<--` to insert a key-value pair into a location monad. These operations support direct manipulation of location-annotated data during invariant processing in unassume event emission.",
      "description_length": 377,
      "index": 681,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.ExtractPthread.Codegen.AdjacencyMatrix.HashtblN.Infix",
      "library": "goblint.lib",
      "description": "This module provides infix operators `(-->)` and `(<--)` for accessing and modifying values in a multi-dimensional adjacency matrix implemented with nested hashtables. It works with keys of type `Goblint_lib.ExtractPthread.Codegen.AdjacencyMatrix.HashtblN.key` and arbitrary value types `'a`. These operations are used to represent and manipulate control-flow or state-transition relationships in Promela models derived from Pthread programs.",
      "description_length": 442,
      "index": 682,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Control.AnalyzeCFG.CompareGlobSys.LH.Exceptionless",
      "library": "goblint.lib",
      "description": "This module provides operations to safely query and update a map-like structure without exceptions. It supports `find` to retrieve values by key and `modify` to apply transformations to values at specific keys, returning a result indicating success or failure. These functions are used to manage state during constraint solving in the analysis of program control flow graphs.",
      "description_length": 375,
      "index": 683,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Witness.Result.ArgTool.NHT.Exceptionless",
      "library": "goblint.lib",
      "description": "This module provides operations to safely query and update values in a nested hash table structure without raising exceptions. It works with typed nested hash tables (`ArgTool.NHT.t`) and supports key-based lookups and function-based value transformations. Concrete use cases include inspecting and modifying analysis results stored in nested hash tables during static analysis processing.",
      "description_length": 389,
      "index": 684,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MutexAnalysis.Spec.Arg.MakeP.ReadWrite",
      "library": "goblint.lib",
      "description": "Implements lattice operations (join, meet, widen) and utilities (hashing, serialization) for ReadWrite.t values, which model concurrent read/write states in static analysis. These functions enable precision control and state comparison in abstract interpretation frameworks, particularly for tracking lock-protected data access. Includes helpers to identify extremal lattice elements and metadata retrieval for analysis specification.",
      "description_length": 434,
      "index": 685,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.UnassumeAnalysis.Spec.Locator.FileH.Exceptionless",
      "library": "goblint.lib",
      "description": "Implements exception-safe lookup and modification operations for a key-value structure tied to file-based specifications. Works with typed key-value pairs stored in a file-handling context, using `find` to retrieve values and `modify` to apply transformations while handling potential errors via result types. Useful for safely updating and querying structured data from files without propagating exceptions, particularly in analysis workflows consuming YAML-based invariants.",
      "description_length": 476,
      "index": 686,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.YamlWitness.Validator.Locator.LocM.Labels",
      "library": "goblint.lib",
      "description": "This module implements a labeled location map for associating keys with data in the context of YAML witness validation. It provides operations to add, iterate, map, filter, fold, compare, and check equality over labeled location maps, where each key is a location identifier and each value is arbitrary data. These operations enable precise tracking and manipulation of structured data during witness validation.",
      "description_length": 412,
      "index": 687,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.YamlWitness.Validator.Locator.ES.Labels",
      "library": "goblint.lib",
      "description": "This module processes sets of label-based location elements in YAML witness validation. It supports operations like iteration, folding, filtering, and mapping over collections of labels to validate or transform structured witness data. Concrete use cases include checking label presence, accumulating label metadata, or partitioning labels based on validation criteria.",
      "description_length": 369,
      "index": 688,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.YamlWitness.Validator.Locator.LocM.Exceptionless",
      "library": "goblint.lib",
      "description": "This module provides operations for safely accessing and traversing keyed data structures without raising exceptions. It works with map-like structures parameterized over keys and values, supporting lookup, selection, and traversal operations. Concrete use cases include querying optional fields in YAML-based witness structures and handling sparse or partial data during validation.",
      "description_length": 383,
      "index": 689,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Control.AnalyzeCFG.SpecSys.GHT.Infix",
      "library": "goblint.lib",
      "description": "This module defines infix operators for interacting with a `BatHashtbl`, specifically `-->` to retrieve a value by key and `<--` to add a binding. It works directly with `SpecSys.GHT.t`, a hash table type, and its associated keys and values. These operators simplify hash table manipulation in the context of abstract interpretation and constraint solving, particularly when managing variable bindings during analysis.",
      "description_length": 418,
      "index": 690,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Control.AnalyzeCFG.CompareGlobSys.LH.Labels",
      "library": "goblint.lib",
      "description": "This module provides dictionary-like operations for manipulating labeled data structures, including insertion, modification, iteration, filtering, and merging based on keys and values. It works with key-value maps where keys conform to `CompareGlobSys.LH.key` and values can be of arbitrary type. Concrete use cases include tracking and transforming analysis results associated with control flow graph nodes during abstract interpretation.",
      "description_length": 439,
      "index": 691,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Control.AnalyzeCFG.CompareGlobSys.Sys.GVar",
      "library": "goblint.lib",
      "description": "This module defines operations for comparing, hashing, and pretty-printing global system variables represented as either specification variables or function declarations. It provides functions to extract identifiers, determine write-only status, and convert values to various output formats like XML or JSON. Concrete use cases include tracking and analyzing global variables during abstract interpretation and constraint solving in program analysis.",
      "description_length": 450,
      "index": 692,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.UnassumeAnalysis.Spec.Locator.FileH.Infix",
      "library": "goblint.lib",
      "description": "This module defines operations for mapping and retrieving values associated with file-based keys in a hierarchical structure. It supports binding a key to a value within a file context using `(<--)` and resolving a key to its value with `(-->)`. These operations are used to manage file-specific annotations or metadata during unassume analysis, such as tracking invariants from YAML witnesses per source file.",
      "description_length": 410,
      "index": 693,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Control.AnalyzeCFG.SpecSys.LHT.Exceptionless",
      "library": "goblint.lib",
      "description": "This module provides safe lookup and modification operations for hash tables, returning optional values or result types instead of raising exceptions. It works with hash tables (`Hashtbl`) where keys and values conform to the `SpecSys.LHT` signature. Concrete use cases include safely retrieving values by key and applying in-place transformations to entries in analysis contexts where exceptions are undesirable.",
      "description_length": 413,
      "index": 694,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Control.AnalyzeCFG.SpecSys.GHT.Exceptionless",
      "library": "goblint.lib",
      "description": "This module provides safe lookup and in-place modification operations for hash tables, returning optional values or result types to handle absence or errors without exceptions. It works with hash tables (`Hashtbl`) and their keys and values, specifically within the context of abstract interpretation and constraint solving. Concrete use cases include safely querying and updating analysis states during control flow graph traversal where missing keys indicate uninitialized or irrelevant data.",
      "description_length": 494,
      "index": 695,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ExtractPthread.Codegen.AdjacencyMatrix.HashtblN.Exceptionless",
      "library": "goblint.lib",
      "description": "This module provides operations for safely querying and modifying a nested hash table structure that maps keys to optional values. It supports retrieving values with `find` and applying in-place transformations with `modify`, returning a result type to handle potential failures. It is used to manage state transitions and adjacency relationships during Promela code generation for pthread-based concurrency analysis.",
      "description_length": 417,
      "index": 696,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.UnassumeAnalysis.Spec.Locator.LocM.Exceptionless",
      "library": "goblint.lib",
      "description": "Implements key-value mappings with operations to retrieve, select, or find entries in a map-like structure. Works with keys and values of arbitrary types, supporting lookups and traversal. Used to manage and query structured data such as configuration settings or analysis metadata without raising exceptions.",
      "description_length": 309,
      "index": 697,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.YamlWitness.Validator.Locator.ES.Exceptionless",
      "library": "goblint.lib",
      "description": "This module provides functions to retrieve elements from a set, including the minimum, maximum, arbitrary, and specific elements. It operates on sets represented by the `Locator.ES.t` type and their elements of type `Locator.ES.elt`. These functions are used to query and extract values from sets in a safe, exception-free manner during YAML witness validation.",
      "description_length": 361,
      "index": 698,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Control.AnalyzeCFG.SpecSys.GHT.Labels",
      "library": "goblint.lib",
      "description": "This module provides labeled versions of standard hash table operations, enhancing readability and argument order flexibility. It works with hash tables (`SpecSys.GHT.t`) and their keys (`SpecSys.GHT.key`), supporting common manipulations like adding, filtering, mapping, and folding with labeled functions. Concrete use cases include managing analysis state during constraint solving where key-based access clarity and safe modifications are required.",
      "description_length": 452,
      "index": 699,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Witness.Result.ArgTool.NHT.Infix",
      "library": "goblint.lib",
      "description": "This module provides infix operators for interacting with a non-thread-safe hash table (`ArgTool.NHT.t`). It allows binding a key-value pair to the table using `<--` and retrieving a value by key using `-->`. These operations are useful for managing transient state during analysis phases where direct and concise hash table manipulation is needed.",
      "description_length": 348,
      "index": 700,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Control.AnalyzeCFG.CompareGlobSys.PP.Exceptionless",
      "library": "goblint.lib",
      "description": "This module provides operations to safely query and update values associated with keys in a map-like structure, specifically working with types from `CompareGlobSys.PP.t` and `PP.key`. It supports lookup via `find` and modification via `modify`, returning results that handle potential exceptions explicitly. Concrete use cases include managing and transforming state during abstract interpretation where key-based access and mutation are required.",
      "description_length": 448,
      "index": 701,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Control.AnalyzeCFG.CompareGlobSys.Sys.D",
      "library": "goblint.lib",
      "description": "This module provides lattice operations for dataflow analysis domains, including comparison, extremal value checks, and structural manipulations. It works with an abstract domain type `t` that represents program abstractions in a lattice structure, supporting operations like `join`, `meet`, `widen`, and `narrow` to model value propagation. These capabilities are specifically used in static analysis to solve constraint systems derived from program control flow graphs, enabling precise abstract interpretation of global program properties.",
      "description_length": 542,
      "index": 702,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Control.AnalyzeCFG.CompareGlobSys.GH.Exceptionless",
      "library": "goblint.lib",
      "description": "This module provides operations to safely query and update a global system state by key, handling potential exceptions during modification. It works with typed global state containers and key-based access, ensuring modifications are applied only when keys exist. Concrete use cases include managing analysis state during constraint solving in program analysis, where safe state updates are critical.",
      "description_length": 399,
      "index": 703,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Control.AnalyzeCFG.CompareGlobSys.PP.Infix",
      "library": "goblint.lib",
      "description": "This module provides infix operators for manipulating and querying a global system of constraints during abstract interpretation. It works with constraint systems represented as maps from keys to values, supporting direct key-based access and updates. Concrete use cases include tracking and solving constraints over program variables or memory locations during static analysis.",
      "description_length": 378,
      "index": 704,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Control.AnalyzeCFG.Slvr.VH.Labels",
      "library": "goblint.lib",
      "description": "This module provides imperative hash table operations for managing key-value pairs with specialized functions for filtering, mapping, merging, and in-place modifications. It works with labeled hash tables where keys are of type `Slvr.VH.key` and values are polymorphic. Concrete use cases include efficiently tracking and transforming analysis states during constraint solving in a program analysis framework.",
      "description_length": 409,
      "index": 705,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Control.AnalyzeCFG.Slvr.EqSys.Var",
      "library": "goblint.lib",
      "description": "This module defines and manipulates variables used in the equation system for constraint solving during abstract interpretation. It supports operations like equality checking, hashing, comparison, and pretty-printing for variables, which can be either global (`G`) or local (`L`) types tied to control flow nodes. These variables are used to track and solve dataflow properties at specific points in the control flow graph during static analysis.",
      "description_length": 446,
      "index": 706,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Control.AnalyzeCFG.Slvr.VH.Infix",
      "library": "goblint.lib",
      "description": "This module provides functions for manipulating and querying a hash table-based solver structure using infix operators. It supports operations to retrieve and bind values associated with keys in a solver context. Concrete use cases include tracking variable assignments and constraint resolutions during abstract interpretation of program paths.",
      "description_length": 345,
      "index": 707,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Control.AnalyzeCFG.CompareGlobSys.PP.Labels",
      "library": "goblint.lib",
      "description": "This module provides operations for manipulating key-value maps where keys are labels from a control flow graph (CFG) and values represent abstract analysis data. It supports transformations, filtering, and folding over these maps, enabling precise tracking and modification of analysis results at specific program points. Concrete use cases include updating abstract states during fixed-point computation and comparing analysis results across different program paths.",
      "description_length": 468,
      "index": 708,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.CompareConstraints.CompareGlobSys.PP.Labels",
      "library": "goblint.lib",
      "description": "This module manages a system of constraints associated with program points, providing operations to add, replace, modify, and query constraint data indexed by keys. It supports transformations and filters over constraint sets, enabling precise control over constraint propagation and analysis. Use cases include tracking variable bindings, enforcing dataflow constraints, and maintaining analysis state during abstract interpretation.",
      "description_length": 434,
      "index": 709,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Witness.Result.ArgTool.Node",
      "library": "goblint.lib",
      "description": "This module defines operations for comparing, hashing, and converting node values, specifically working with tuples of control flow graph nodes, specification contexts, and integer identifiers. It includes functions to extract components from these tuples, check node liveness, and construct string representations. Concrete use cases include tracking and identifying nodes within an abstract reachability graph during analysis output generation.",
      "description_length": 446,
      "index": 710,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.PrivPrecCompareUtil.Util.RH.Infix",
      "library": "goblint.lib",
      "description": "This module provides infix operators `(-->)` and `(<--)` for accessing and modifying values in a `RH.t` structure using a `RH.key`. It facilitates concise key-based lookups and updates in a map-like data structure. Concrete use cases include managing precision-related state where keys correspond to specific analysis dimensions.",
      "description_length": 329,
      "index": 711,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Base.MainFunctor.VarH.Exceptionless",
      "library": "goblint.lib",
      "description": "Implements variable map operations with exception-safe modifications. Works with variable maps (`VarH.t`) for analysis domains. Used to safely update variable bindings during static analysis without propagating exceptions.",
      "description_length": 222,
      "index": 712,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.RaceAnalysis.Spec.OffsetTrie.Trie",
      "library": "goblint.lib",
      "description": "This module implements a trie-based lattice structure for managing hierarchical memory access offsets in data race analysis. It provides operations to merge, compare, and traverse nested access sets (`AS.t`) organized by offset keys, enabling efficient prefix/suffix resolution and race detection between memory locations derived from C type hierarchies. The trie supports lattice operations like join/meet on special bottom/top elements to model abstract memory states, specifically handling use cases where concurrent accesses to overlapping memory regions (e.g., struct fields or array elements) must be precisely checked for races at the most specific memo node.",
      "description_length": 666,
      "index": 713,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Control.AnalyzeCFG.Slvr.Splitter",
      "library": "goblint.lib",
      "description": "Splits a solution into two parts based on the structure of the constraint system. It operates on solution types that include bottom, lifted values, and top, producing separate results for different constraint categories. Useful for handling combined analyses where distinct constraint types need independent processing.",
      "description_length": 319,
      "index": 714,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MutexAnalysis.Spec.Arg.GProtected",
      "library": "goblint.lib",
      "description": "This module provides lattice-based operations for analyzing abstract values that map mutexes to sets of variables with associated access modes (read/write), supporting comparisons, joins, and meets to model protection state. It manages a data structure representing which variables are protected by specific mutexes, enabling queries to check protection status and generate summaries of guarded variables. The analysis is used in static concurrency verification to ensure thread-safe access patterns by tracking variable-mutex associations and enforcing consistent locking discipline.",
      "description_length": 584,
      "index": 715,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Server.Locator.ES.Labels",
      "library": "goblint.lib",
      "description": "This module processes collections of `elt` values within a structured container type `t`, supporting iteration, transformation, filtering, and logical checks. It enables operations like mapping functions over elements, selecting subsets based on predicates, and splitting collections based on conditions. These capabilities are used to manipulate labeled data during server-side processing of JSON-RPC requests.",
      "description_length": 411,
      "index": 716,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.PrecCompareUtil.Util.RH.Labels",
      "library": "goblint.lib",
      "description": "This module provides labeled argument versions of standard `Hashtbl` operations, enhancing readability and argument order flexibility. It works with hash tables (`RH.t`) where keys are of type `RH.key` and data can be any type. Concrete use cases include safely adding, replacing, filtering, and transforming key-value pairs in hash tables using explicitly labeled functions like `add`, `modify`, and `merge`, which clarify intent and reduce errors in argument ordering.",
      "description_length": 470,
      "index": 717,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Control.AnalyzeCFG.SpecSys.EQSys",
      "library": "goblint.lib",
      "description": "Implements a system for solving equality constraints over program variables during abstract interpretation. It operates on control flow graphs by analyzing paths and computing dataflow solutions using variable mappings for both local (`LVar`) and global (`GVar`) variables. This module is used to track and update variable states across program points in order to perform static analysis optimizations such as constant propagation or reaching definitions.",
      "description_length": 455,
      "index": 718,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MutexAnalysis.Spec.GM.Labels",
      "library": "goblint.lib",
      "description": "This module implements a labeled map structure for managing analysis data associated with keys in a mutex analysis context. It supports operations like adding, modifying, and removing entries, as well as filtering, mapping, and folding over key-value pairs, with both in-place and functional variants. Concrete use cases include tracking lock ownership, maintaining per-lock state during static analysis, and merging analysis results across different code paths.",
      "description_length": 462,
      "index": 719,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MutexAnalysis.Spec.Arg.D",
      "library": "goblint.lib",
      "description": "This module provides lattice operations and domain-specific utilities for analyzing concurrent programs by combining must-locksets with read/write tracking and multiplicity counts. It operates on tuples of abstract domains (`MustLocksetRW.t` and `MustMultiplicity.t`) to model lock dependencies and acquisition counts, supporting tasks like verifying correct lock usage in multithreaded code. Use cases include serializing analysis states for debugging, generating test cases with QCheck, and tracking read/write lock interactions in static analysis.",
      "description_length": 550,
      "index": 720,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.YamlWitness.Make.NH.Exceptionless",
      "library": "goblint.lib",
      "description": "This module provides operations for safely accessing and modifying values in a key-value store backed by a nested hash table structure. It supports `find` to retrieve values by key and `modify` to apply transformations to existing values, handling missing keys gracefully through a result type that returns either success or an exception. It is used in YAML witness generation to manipulate structured data without raising errors on missing fields.",
      "description_length": 448,
      "index": 721,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.YamlWitness.Make.LH.Infix",
      "library": "goblint.lib",
      "description": "This module provides infix operators for accessing and modifying values in a YAML witness structure. It allows associative-style operations where `-->` retrieves a value by key and `<--` binds a key-value pair. These operations directly manipulate `LH.t` structures, enabling concise YAML node navigation and updates. Use cases include constructing or validating YAML-based witnesses with readable syntax.",
      "description_length": 405,
      "index": 722,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.SymbLocks.Spec.A.E",
      "library": "goblint.lib",
      "description": "This module defines a sum type `t` that represents either a symbolic lock (`PLock.t`) or an integer lock (`ILock.t`), providing operations for equality, comparison, hashing, and pretty-printing. It supports concrete use cases such as tracking and comparing symbolic and integer lock values during static race detection in device drivers, enabling precise analysis of per-element locking patterns. Functions like `show`, `pretty`, and `to_yojson` facilitate debugging and serialization of lock information.",
      "description_length": 505,
      "index": 723,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ExtractPthread.Codegen.AdjacencyMatrix.HashtblN",
      "library": "goblint.lib",
      "description": "This module implements a nested hash table structure with keys of type `CilType.Location.t` (source code locations) and polymorphic values, designed for representing hierarchical mappings in control flow analysis. It supports imperative operations like insertion, lookup, and bulk modification alongside functional transformations such as filtered mapping and merging, with utilities for converting between sequences, lists, and structured enumerations. The data structure is specifically used in Promela code generation to model multi-level state transitions and adjacency relationships during Pthread program analysis.",
      "description_length": 620,
      "index": 724,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Control.AnalyzeCFG.CompareGlobSys.Sys",
      "library": "goblint.lib",
      "description": "This module coordinates the analysis of global constraint systems by defining functions to query, update, and traverse labeled and global variables in the context of abstract interpretation. It operates on constraint systems built from `LVar` (CFG node-based variables) and `GVar` (global variables), using lattice domains `D` and `G` to compute and compare abstract values. Concrete use cases include solving interprocedural dataflow constraints and tracking changes to global and local variables across control flow paths.",
      "description_length": 524,
      "index": 725,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ExtractPthread.Codegen.PmlResTbl.FunTbl",
      "library": "goblint.lib",
      "description": "Maps function names to unique integer identifiers for edge labeling in Promela code generation. Uses a hash table to store associations and provides lookups by name or integer key. Useful for translating Pthread function calls into uniquely labeled Promela edges during model extraction.",
      "description_length": 287,
      "index": 726,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.BaseDomain.CPA.M.Group",
      "library": "goblint.lib",
      "description": "This module represents and compares groups of variables within the base analysis domain. It provides a concrete data type for grouping variables and a comparison function to order or equate these groups. It is used to manage variable groupings during static analysis, such as tracking related variables in control flow or data flow computations.",
      "description_length": 345,
      "index": 727,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Base.MainFunctor.VarMap.Labels",
      "library": "goblint.lib",
      "description": "This module provides operations for manipulating variable maps with typed keys and associated data values. It supports adding entries, iterating over key-value pairs, transforming values with functions, filtering entries, folding to accumulate results, and comparing or checking equality of maps using custom functions. These operations are used to track and analyze variable bindings in static analysis contexts.",
      "description_length": 413,
      "index": 728,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Server.Locator.LocM.Infix",
      "library": "goblint.lib",
      "description": "This module provides infix operators `(-->)` and `(<--)` for accessing and updating values in a location monad. It works with the `LocM.t` monadic structure and key-value pairs where keys are of type `LocM.key`. These operations are used to manipulate location-based state in the context of a JSON-RPC server, such as retrieving or setting specific analysis results or configurations during interactive sessions.",
      "description_length": 412,
      "index": 729,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.WitnessUtil.Locator.FileH.Exceptionless",
      "library": "goblint.lib",
      "description": "This module provides operations to safely locate and modify values in a file handle structure without raising exceptions. It works with `'a FileH.t`, a map-like structure keyed by file identifiers, and returns results in a `BatPervasives.result` type to handle potential errors explicitly. Concrete use cases include querying or updating file-specific data during witness generation where missing keys or I/O issues must be handled gracefully.",
      "description_length": 443,
      "index": 730,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.YamlWitness.Make.FMap.Exceptionless",
      "library": "goblint.lib",
      "description": "Implements exceptionless find and modify operations for functional maps with result types. Works with FMap.t structures, using keys to retrieve or update values without raising exceptions. Useful for safely handling optional values and partial updates in YAML witness processing.",
      "description_length": 279,
      "index": 731,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Base.MainFunctor.VarMap.Exceptionless",
      "library": "goblint.lib",
      "description": "Implements variable map operations for exceptionless value analysis, focusing on safe lookup and selection. Works with variable maps where keys are program variables and values represent abstract analysis states. Used to query and manipulate variable bindings during static analysis without raising exceptions.",
      "description_length": 310,
      "index": 732,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Control.AnalyzeCFG.CompareGlobSys.LH",
      "library": "goblint.lib",
      "description": "This module supports imperative hash table operations for key-value storage and manipulation, where keys are constraint system variables (`SpecSys.EQSys.LVar.t`) and values are polymorphic. It provides map-like transformations, merging, and sequence conversions to manage abstract analysis data during control-flow graph traversal. These operations are used to efficiently handle global equation systems and propagate constraints in program analysis workflows.",
      "description_length": 460,
      "index": 733,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.YamlWitness.Make.FMap.Labels",
      "library": "goblint.lib",
      "description": "This module implements a labeled map structure with operations for adding, replacing, modifying, and filtering key-value pairs, where keys are of type `FMap.key` and values are polymorphic. It supports transformations with `map`, `filter_map`, and in-place updates using functions that operate on both keys and values. Use cases include managing structured YAML witness data with keyed entries, such as tracking annotations or validation results across program analysis phases.",
      "description_length": 477,
      "index": 734,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Svcomp.StackTaskResult.Arg.Node",
      "library": "goblint.lib",
      "description": "This module operates on a list of `Arg.Node.t` values, providing equality, hashing, comparison, and structural extraction functions. It enables analysis of SV-COMP task results by comparing nodes based on context, path, and CFG structure, and supports transformations like moving nodes between CFG locations. Concrete use cases include tracking and comparing abstract interpretation states during static analysis.",
      "description_length": 413,
      "index": 735,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Server.Locator.FileH.Infix",
      "library": "goblint.lib",
      "description": "This module defines operators for accessing and updating values associated with keys in a file-based locator structure. It works with typed key-value pairs where keys identify specific elements within files. Use cases include efficiently retrieving or modifying file-related data entries in a structured manner.",
      "description_length": 311,
      "index": 736,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.WitnessUtil.Locator.LocM.Labels",
      "library": "goblint.lib",
      "description": "This module operates on labeled locations within a map structure, providing functions to add, filter, map, and fold over entries based on their keys and associated data. It supports concrete operations such as selectively retaining entries with `filterv` and `filter`, transforming values with `map` and `mapi`, and aggregating data through `fold`. Use cases include managing and querying structured location-based data, such as tracking variable bindings or analysis results in program analysis.",
      "description_length": 496,
      "index": 737,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.WitnessUtil.Locator.FileH.Labels",
      "library": "goblint.lib",
      "description": "This module operates on file handles with key-value pairs, providing functions to manipulate and query data associated with file labels. It supports operations like adding, replacing, filtering, and mapping over entries, as well as in-place modifications and conditional updates. Use cases include managing per-file metadata during witness generation or tracking labeled invariants across different file sections.",
      "description_length": 413,
      "index": 738,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ThreadId.Spec.Created.Callees",
      "library": "goblint.lib",
      "description": "This module implements lattice-based operations for thread identifier analysis, including meet, join, widen, and narrow functions to combine or compare thread state abstractions. It works with thread ID representations (`t` as `TD.t`) to model concurrency behaviors, supporting static analysis tasks like tracking thread creation and synchronization. Key use cases involve reasoning about thread identity in dataflow analysis and resolving inter-thread dependencies in concurrent programs.",
      "description_length": 489,
      "index": 739,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Base.MainFunctor.VarH.Labels",
      "library": "goblint.lib",
      "description": "This module provides operations for manipulating variable-labeled hashtables with key-based access and transformation functions. It supports adding, replacing, filtering, mapping, and folding over entries, as well as in-place modifications and conditional updates based on keys and values. Concrete use cases include tracking and transforming variable bindings during static analysis, such as propagating constraints or merging analysis results across program points.",
      "description_length": 467,
      "index": 740,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.CompareConstraints.CompareGlobSys.PP.Exceptionless",
      "library": "goblint.lib",
      "description": "This module provides operations to safely query and update values in a parameterized system (`PP.t`) using keys (`PP.key`). It includes `find` for retrieving optional values and `modify` for applying transformations with exception handling. These functions are used to manage stateful constraints in analysis tasks where missing keys or errors must be explicitly handled.",
      "description_length": 371,
      "index": 741,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.CompareConstraints.CompareNode.Compare.CompareD",
      "library": "goblint.lib",
      "description": "This module defines a comparison function for constraint data structures, specifically working with type `D.t` from its associated module `D`. It supports detailed structural comparison of constraint nodes, producing both a comparison result and a pretty-printed document showing differences. Useful for debugging and analysis tools that require precise comparison of abstract constraint representations.",
      "description_length": 404,
      "index": 742,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Witness.Result.ArgTool.Query",
      "library": "goblint.lib",
      "description": "This module provides functions to query local and global analysis results within an abstract reachability graph (ARG). It operates on data types including analysis states, nodes, and query types from the `Goblint_lib.Queries` module. Concrete use cases include retrieving variable values at specific nodes or checking global properties across the entire ARG.",
      "description_length": 358,
      "index": 743,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Server.Locator.FileH.Labels",
      "library": "goblint.lib",
      "description": "This module implements a labeled key-value store for managing file-specific data in a JSON-RPC server context. It supports atomic updates, in-place modifications, and filtered transformations of stored values, using file paths as keys. Concrete use cases include tracking per-file analysis results, caching parsed ASTs, or maintaining source code annotations during server requests.",
      "description_length": 382,
      "index": 744,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MutexAnalysis.Spec.GM.Exceptionless",
      "library": "goblint.lib",
      "description": "Implements exception-safe operations for managing a lockset-based analysis state. It provides `find` to retrieve values associated with keys and `modify` to update them, returning a result type to handle failures explicitly. This module is used during static analysis to track and manipulate mutex locking behavior without propagating exceptions.",
      "description_length": 346,
      "index": 745,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.YamlWitness.Make.LH.Exceptionless",
      "library": "goblint.lib",
      "description": "This module provides operations for safely accessing and modifying values in a key-value data structure, specifically working with `LH.t` maps where keys are of type `LH.key` and values are polymorphic. It includes `find` for retrieving optional values associated with a key and `modify` for applying a transformation function to a value at a given key, returning a result indicating success or failure. These functions are useful in scenarios like parsing or transforming YAML-based witness data where key-based access and updates are required without raising exceptions.",
      "description_length": 572,
      "index": 746,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MutexAnalysis.Spec.Arg.V",
      "library": "goblint.lib",
      "description": "This module defines operations for handling a variant type representing either a variable (`Left`) or a variable with an offset (`Right`). It provides equality checks, comparison, hashing, and pretty-printing for these values, along with utilities to inspect and transform them. It is used to track mutex variables and their associated memory offsets in lockset analysis.",
      "description_length": 371,
      "index": 747,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Deadlock.Spec.Arg.G",
      "library": "goblint.lib",
      "description": "This module combines associative map operations and lattice functions to manage abstract deadlock states, using keys of type `ValueDomain.Addr.t` and values of type `Goblint_lib.Deadlock.Spec.MayLockEventPairs.t`. It supports merging lock event pairs, tracking potential deadlocks through may-lock analysis, and iterative analysis with customizable precision control via widening and narrowing. Use cases include combining abstract states during analysis, serializing results for debugging, and testing with property-based frameworks.",
      "description_length": 534,
      "index": 748,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.PrecCompare.MakeDump.CompareDump.CompareD",
      "library": "goblint.lib",
      "description": "This module compares two domain instances for precision using a structured dumping mechanism. It takes two domain values and returns a comparison result along with a formatted document showing differences. It is used to analyze and contrast abstract domain states, such as during precision tuning or debugging of static analysis results.",
      "description_length": 337,
      "index": 749,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.CompareConstraints.CompareNode.Compare.Var",
      "library": "goblint.lib",
      "description": "This module defines operations for comparing, identifying, and pretty-printing variable-like entities tied to control flow nodes. It supports equality checks, hashing, comparison, and string representations, specifically working with the `Compare.Var.t` type that encapsulates variables in the context of a control flow graph. Concrete use cases include tracking variable identities across analysis phases, managing variable comparisons in constraint solving, and generating readable or XML/Yojson-serializable output for debugging and reporting.",
      "description_length": 546,
      "index": 750,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Control.AnalyzeCFG.Result.Exceptionless",
      "library": "goblint.lib",
      "description": "This module provides operations to query and update analysis results stored in a hash table indexed by result keys, specifically handling cases where exceptions are not expected. It works with hashtables mapping result keys to arbitrary values, alongside result keys themselves. Concrete use cases include retrieving and modifying analysis data during constraint solving without exception handling overhead.",
      "description_length": 407,
      "index": 751,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.WitnessUtil.Locator.ES.Labels",
      "library": "goblint.lib",
      "description": "This module provides operations for querying and transforming sets of elements using standard set manipulations such as iteration, folding, filtering, and mapping. It works with sets represented by the `ES.t` type, where elements are of type `ES.elt`. Concrete use cases include analyzing or modifying sets of program elements during witness generation, such as extracting relevant subsets or applying transformations to elements based on specific conditions.",
      "description_length": 459,
      "index": 752,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ThreadId.Spec.Created.Current",
      "library": "goblint.lib",
      "description": "This module provides lattice operations, comparison and display functionalities, lattice theory operations (join, meet, widen), and testing capabilities for abstract thread identifiers. It works with a type `t` representing thread IDs in static concurrency analysis, which are internally based on `TD.t` to model thread states. These operations support dataflow analysis in concurrent programs, enabling merging and comparing thread states, tracking initial threads, and generating unique thread names for debugging or reporting purposes.",
      "description_length": 538,
      "index": 753,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Control.AnalyzeCFG.Slvr.VH",
      "library": "goblint.lib",
      "description": "This module provides imperative and functional manipulation of a hash table for key-value mappings, including insertion, lookup, filtering, merging, and bulk conversions to and from lists, sequences, and enumerations. It operates on a hash table type (`Slvr.VH.t`) with keys of a polymorphic equality-based type (`Slvr.EqSys.v`), emphasizing exception-safe access and labeled updates for handling partial or failure-prone operations. Designed for managing transient analysis state during constraint solving, it supports tracking variables, constraints, or intermediate results across control flow graph nodes in abstract interpretation workflows.",
      "description_length": 646,
      "index": 754,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Server.Locator.FileH.Exceptionless",
      "library": "goblint.lib",
      "description": "This module provides operations to safely locate and modify values associated with file handles in a server context. It works with file handle tables and keys, allowing for exception-safe access and updates. Concrete use cases include managing per-file state in a JSON-RPC server handling concurrent requests.",
      "description_length": 309,
      "index": 755,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ResultQuery.Make.FileCfg.Cfg",
      "library": "goblint.lib",
      "description": "Implements CFG traversal and analysis functions for querying the constraint system solution. Works with control flow graphs (`MyCFG.cfg`) and nodes, providing operations to inspect edges, skipped statements, and node relationships. Useful for analyzing program paths and identifying skipped AST elements during CFG construction.",
      "description_length": 328,
      "index": 756,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.WitnessUtil.Locator.ES.Exceptionless",
      "library": "goblint.lib",
      "description": "This module provides functions to retrieve specific elements from a set without raising exceptions. It works with sets of type `ES.t` and element type `ES.elt`, offering operations like `min_elt`, `max_elt`, `choose`, `any`, and `find` to safely extract values. Use it when handling optional set elements in witness generation or invariant analysis where exception safety is required.",
      "description_length": 384,
      "index": 757,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.YamlWitness.Make.FCMap.Infix",
      "library": "goblint.lib",
      "description": "This module provides infix operators for accessing and updating values in a functional combinator map (FCMap). It supports key-value operations where keys are of type `FCMap.key` and values are polymorphic. Concrete use cases include building and modifying structured YAML witness data incrementally using intuitive operator syntax.",
      "description_length": 332,
      "index": 758,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MutexAnalysis.Spec.GM.Infix",
      "library": "goblint.lib",
      "description": "This module provides infix operators `(-->)` and `(<--)` for accessing and modifying values associated with keys in a lockset analysis structure. It works with the `Goblint_lib.MutexAnalysis.Spec.GM.t` type, which represents a mapping from lock keys to values. These operations are used to query and update lockset state during static analysis of concurrent programs.",
      "description_length": 367,
      "index": 759,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.CompareConstraints.CompareGlobSys.PP.Infix",
      "library": "goblint.lib",
      "description": "This module defines infix operators for working with pretty-printing contexts, specifically `-->` for retrieving values by key and `<--` for binding values to keys within a `PP.t` context. It operates on `PP.t`, a type representing a pretty-printing environment, and uses `PP.key` as identifiers for values. These operators simplify the manipulation of contextual data during pretty-printing tasks, such as formatting complex data structures or managing indentation levels.",
      "description_length": 473,
      "index": 760,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.PrecCompareUtil.Util.RH.Exceptionless",
      "library": "goblint.lib",
      "description": "This module provides safe lookup and modification operations for hash tables, returning optional values or result types instead of raising exceptions. It works with hash tables (`Hashtbl`) where keys and values can be of arbitrary types. Concrete use cases include safely retrieving values with `find` and updating values in-place with `modify`, handling missing keys gracefully in both cases.",
      "description_length": 393,
      "index": 761,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.CompareConstraints.CompareNode.NH.Infix",
      "library": "goblint.lib",
      "description": "This module provides infix operators for interacting with a node handle (`NH`) structure, allowing direct value retrieval and assignment using the `-->` and `<--` syntax. It works with `NH.t`, a handle to a node, and `NH.key`, representing keys for accessing specific values. Concrete use cases include concise manipulation of node attributes in abstract interpretation contexts, such as setting or fetching constraint values during analysis.",
      "description_length": 442,
      "index": 762,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.CompareConstraints.CompareGlobal.Compare.Var",
      "library": "goblint.lib",
      "description": "This module defines operations for comparing, identifying, and pretty-printing variable-like structures in a constraint system. It works with the `t` type, representing variables, and provides concrete functionality such as `compare`, `equal`, `hash`, and `var_id` for ordering and identification. Use cases include tracking variable instances in analyses, formatting variables for debugging or output, and managing variable equality and ordering in constraint solving.",
      "description_length": 469,
      "index": 763,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.UnassumeAnalysis.Spec.Locator.FileH",
      "library": "goblint.lib",
      "description": "The module provides a hash table implementation for managing key-value associations with structured, file-related keys, supporting operations like insertion, lookup, iteration, and functional transformations. It works with data structures such as maps from `Basetype.RawStrings.t` to analysis-specific values, enabling efficient querying and modification through imperative and pure interfaces. This is used to track file-based specifications in unassume analysis, handle safe conversions between maps and sequences, and perform error-resilient lookups tied to file-annotated data.",
      "description_length": 581,
      "index": 764,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.WitnessUtil.Locator.LocM.Exceptionless",
      "library": "goblint.lib",
      "description": "This module provides operations for safely querying and extracting values from a keyed map structure without raising exceptions. It supports functions to find a value by key, select any key-value pair, or retrieve an arbitrary binding, returning `option` types to handle absence gracefully. It is used in witness generation to inspect and manipulate mappings between locations and associated data during static analysis.",
      "description_length": 420,
      "index": 765,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ArgTools.Make.NHT.Infix",
      "library": "goblint.lib",
      "description": "This module provides infix operators for interacting with a nested hash table structure, allowing values to be retrieved using a key from a chain of tables. It supports operations to get (`-->`) and set (`<--`) values associated with keys in a hierarchical table structure. Use cases include managing layered configurations or scoped environments where values are accessed or updated through a chain of keys.",
      "description_length": 408,
      "index": 766,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.YamlWitness.Make.NH.Labels",
      "library": "goblint.lib",
      "description": "This module operates on labeled hierarchical data structures, specifically `NH.t` containers with typed keys and values. It provides functions to manipulate and traverse these structures, such as adding, modifying, filtering, and merging entries based on their keys and values. Use cases include constructing and transforming YAML-based witness representations with precise label handling and structured data validation.",
      "description_length": 420,
      "index": 767,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Control.AnalyzeCFG.Slvr.Sol'",
      "library": "goblint.lib",
      "description": "This module provides functions to copy, relift, and solve constraint systems over a control flow graph using a fixed-point iteration approach. It operates on equation systems and variable domains defined in `Slvr.EqSys` and `Slvr.VH`, producing and transforming solver state marshals. Concrete use cases include analyzing program paths for abstract interpretation and refining constraint solutions during static analysis.",
      "description_length": 421,
      "index": 768,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Control.AnalyzeCFG.Result.Infix",
      "library": "goblint.lib",
      "description": "This module provides direct access to analysis results stored in a hash table keyed by control flow graph nodes. It defines operators for retrieving (`-->`) and updating (`<--`) values associated with specific nodes in the result structure. These operations are used to query or modify the abstract state at particular points in the program's control flow during or after analysis.",
      "description_length": 381,
      "index": 769,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Control.AnalyzeCFG.Slvr.EqSys",
      "library": "goblint.lib",
      "description": "This module implements an equation system solver for constraint-based abstract interpretation over a control flow graph. It processes variables (`v`) and domain values (`d`) to compute solutions for dataflow analysis by maintaining and updating constraints tied to control flow nodes. It is used to solve reaching definitions, constant propagation, and other intra-procedural analyses by evaluating equations derived from the control flow and lattice semantics.",
      "description_length": 461,
      "index": 770,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Base.MainFunctor.VarMap.Infix",
      "library": "goblint.lib",
      "description": "Implements map operations for variable bindings in value analysis. Provides infix operators for key-value lookups and updates in VarMap.t structures. Useful for tracking variable states during static analysis passes.",
      "description_length": 216,
      "index": 771,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.CompareConstraints.CompareNode.NH.Exceptionless",
      "library": "goblint.lib",
      "description": "This module provides operations to safely modify values associated with keys in a hash table, handling potential exceptions during modification. It works with hash tables (`NH.t`) and keys (`NH.key`), using a result type to signal success or failure without raising exceptions. A concrete use case is updating values in a thread-safe hash table while gracefully handling concurrent modifications or missing keys.",
      "description_length": 412,
      "index": 772,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Control.AnalyzeCFG.Result.Labels",
      "library": "goblint.lib",
      "description": "This module provides operations for manipulating hashtables keyed by result nodes, supporting transformations, filtering, and aggregation over analysis results. It works with arbitrary data types stored in hashtables mapping result keys to values, enabling precise modifications and queries during abstract interpretation. Concrete use cases include tracking variable states at specific program points, merging analysis outcomes from different paths, and applying per-node optimizations in the constraint-solving process.",
      "description_length": 521,
      "index": 773,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.YamlWitness.Make.NH.Infix",
      "library": "goblint.lib",
      "description": "This module provides infix operators for accessing and modifying values in a nested hash table structure using a specified key type. It supports operations to retrieve a value by key (`-->`) and to insert or update a key-value pair (`<--`). These operations are specifically designed for building and manipulating hierarchical YAML witness data structures with precise key-based navigation.",
      "description_length": 390,
      "index": 774,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Control.AnalyzeCFG.SpecSys.LHT",
      "library": "goblint.lib",
      "description": "This module implements a hash table-based key-value store for abstract interpretation tasks, supporting imperative and functional operations on keys of type `EQSys.LVar.t` with list-associated values. It provides structured manipulation of `SpecSys.LHT.t` hash tables through construction from sequences/lists, safe access via optional values, and transformations like merging or filtering with key-aware functions. Designed for constraint-solving and state management in program analysis, it facilitates handling variables and their mappings during control-flow graph traversal and abstract domain computations.",
      "description_length": 612,
      "index": 775,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.SymbLocks.Spec.A.PLock",
      "library": "goblint.lib",
      "description": "This module represents symbolic locks for individual elements such as struct fields or array indices, used in static race detection. It provides operations for equality checking, hashing, comparison, and pretty-printing of lock identifiers, along with generating arbitrary values for testing and serializing to various formats. It is used to track and compare locking patterns in device driver code during analysis.",
      "description_length": 415,
      "index": 776,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.CompareConstraints.CompareEqSys.Compare.Var",
      "library": "goblint.lib",
      "description": "This module defines operations for comparing, identifying, and pretty-printing variable representations in a constraint system. It works with the `t` type, which represents variables in a system, supporting equality checks, hashing, and tracing. Concrete use cases include tracking variable identities across analyses, comparing variables during constraint solving, and generating readable or XML/Yojson-formatted output for debugging or external processing.",
      "description_length": 458,
      "index": 777,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.PrecCompareUtil.Util.RH.Infix",
      "library": "goblint.lib",
      "description": "This module defines infix operators for interacting with a `BatHashtbl`. It provides `-->` to retrieve a value bound to a key and `<--` to add a binding, with the latter preserving previous values for the same key. These operations are useful when working with hashtables that require maintaining a history of assignments, such as tracking variable bindings in an interpreter or analyzer.",
      "description_length": 388,
      "index": 778,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.UnassumeAnalysis.Spec.Locator.LocM",
      "library": "goblint.lib",
      "description": "This structure provides map-like operations for managing polymorphic values indexed by source code locations, supporting functional updates, conditional lookups, and ordered traversal. It handles key-value associations with specialized functions for filtering, merging, and extracting metadata tied to CIL locations, enabling precise tracking of unassume annotations during static analysis. The design facilitates both safe and exception-driven access patterns while maintaining ordered enumeration for analysis workflows requiring location-based prioritization or combination strategies.",
      "description_length": 588,
      "index": 779,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.PrivPrecCompareUtil.Util.RH.Exceptionless",
      "library": "goblint.lib",
      "description": "This module provides operations for safely modifying values associated with keys in a map structure, where modifications may fail due to key absence or other constraints. It works with map-like structures parameterized over keys and values, supporting lookup and transformation workflows. Concrete use cases include updating privilege precision values in analysis contexts where missing keys must not raise exceptions but instead return error results.",
      "description_length": 451,
      "index": 780,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.WitnessUtil.Locator.LocM.Infix",
      "library": "goblint.lib",
      "description": "This module provides infix operators for manipulating located values in a monadic context. It supports operations to bind and unbind values associated with keys in a location-aware monad. Use cases include threading location information through computations and managing contextual data during witness generation.",
      "description_length": 313,
      "index": 781,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.BaseDomain.CPA.M.GroupMap",
      "library": "goblint.lib",
      "description": "This module provides associative map operations, transformations, and structural manipulations for group-indexed data, enabling functional and algebraic handling of key-value pairs where keys represent group identifiers. It supports polymorphic values and bidirectional traversal via conversions between maps and sequences, facilitating efficient updates and iterative processing. These capabilities are particularly useful for static analysis tasks involving grouped contexts, such as merging partitioned results or analyzing hierarchical relationships across domains.",
      "description_length": 569,
      "index": 782,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.YamlWitness.Make.FMap.Infix",
      "library": "goblint.lib",
      "description": "This module provides infix operators for functional map manipulation, specifically `-->` for key-based lookup and `<--` for inserting or updating key-value pairs. It works with immutable finite maps (`FMap.t`) and uses `FMap.key` as the key type. These operations simplify map transformations in witness generation and validation workflows involving structured data.",
      "description_length": 366,
      "index": 783,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.WitnessUtil.Locator.FileH.Infix",
      "library": "goblint.lib",
      "description": "This module provides infix operators for accessing and updating values in a file handle structure using keys. It works with `FileH.t` and `FileH.key` types, enabling direct manipulation of file-associated data. Concrete use cases include reading and writing specific fields in a file handle during witness generation or invariant tracking.",
      "description_length": 339,
      "index": 784,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.CompareConstraints.CompareNode.NH.Labels",
      "library": "goblint.lib",
      "description": "This module manages label-based constraints associated with nodes in a constraint graph. It provides operations to add, replace, modify, and filter labels based on keys and data, supporting both in-place and functional transformations. Concrete use cases include tracking variable constraints during static analysis and managing per-node metadata in a control flow graph.",
      "description_length": 371,
      "index": 785,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Server.Locator.LocM.Labels",
      "library": "goblint.lib",
      "description": "This module manages a labeled mapping structure keyed by `LocM.key`, supporting operations like adding entries, filtering by value or key and value, mapping with or without key access, and folding over key-value pairs. It works with values of arbitrary type `'a` associated with keys from the `LocM` module, maintaining a structured collection for efficient lookups and transformations. Concrete use cases include tracking source code locations with associated metadata during analysis, enabling precise updates and queries over a dynamic set of labeled data points.",
      "description_length": 566,
      "index": 786,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.CompareConstraints.CompareEqSys.Compare.CompareD",
      "library": "goblint.lib",
      "description": "This module implements precise comparison operations for constraint systems, specifically handling equality checks between two `Sys.Dom.t` domains. It provides a `compare` function that evaluates structural and semantic equivalence, returning a comparison result along with a detailed pretty-printed document. Useful for analyzing and verifying consistency between abstract domains in static analysis workflows.",
      "description_length": 411,
      "index": 787,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Server.Locator.ES.Exceptionless",
      "library": "goblint.lib",
      "description": "This module provides functions to query and retrieve elements from a set-like structure, including operations to find the minimum, maximum, any, or a specific element. It works with the `t` type representing a collection of `elt` values, supporting lookups without raising exceptions. Concrete use cases include safely selecting representative elements or checking existence in a JSON-RPC server context.",
      "description_length": 404,
      "index": 788,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Control.AnalyzeCFG.SpecSys.GHT",
      "library": "goblint.lib",
      "description": "This module provides a multi-value imperative hash table for `EQSys.GVar.t` keys, supporting operations like insertion, lookup, iteration, and bulk transformations (e.g., mapping, filtering, merging) with both key-aware and value-only variants. It facilitates managing per-variable constraints or analysis state in abstract interpretation workflows, particularly for handling multiple values per key during control flow graph traversal, constraint aggregation, and fixpoint computation. The inclusion of sequence conversions, exception-safe accessors, and labeled syntax enhances its utility in complex constraint-solving scenarios over program CFGs.",
      "description_length": 650,
      "index": 789,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Deadlock.Spec.Arg.V",
      "library": "goblint.lib",
      "description": "This module provides abstractions for pointer values used in static analysis of concurrent programs, focusing on modeling addresses, null pointers, and symbolic representations. It defines a lattice structure over these values to enable flow-insensitive analysis, supporting operations like join/meet for merging execution paths and comparisons to detect conflicting resource acquisitions. These abstractions are specifically applied to track pointer relationships in lock operations, aiding deadlock detection by identifying circular dependencies in Goblint's analysis framework.",
      "description_length": 580,
      "index": 790,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.CompareConstraints.CompareGlobal.Compare.CompareD",
      "library": "goblint.lib",
      "description": "This module defines a comparison function for global constraint states, specifically for analyzing and comparing static analysis results in terms of precision and structure. It operates on constraint data types representing global program states, producing a structured comparison result paired with a pretty-printed document for reporting differences. It is used to evaluate the impact of analysis configuration changes or to track precision improvements across analysis runs.",
      "description_length": 477,
      "index": 791,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.YamlWitness.Make.LH.Labels",
      "library": "goblint.lib",
      "description": "This module implements a labeled hash table with operations for adding, modifying, and filtering key-value pairs. It supports functions like `add`, `replace`, `modify`, and `merge`, which enable precise manipulation of entries based on keys and custom logic. Use cases include tracking and transforming structured data such as YAML witness attributes keyed by labels.",
      "description_length": 367,
      "index": 792,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.YamlWitness.Make.FCMap.Exceptionless",
      "library": "goblint.lib",
      "description": "Implements key-based lookup and modification operations for functional maps in the context of YAML witness generation. Works with `'a FCMap.t` maps and `FCMap.key` identifiers, handling modifications as transactions that return result types. Useful for safely updating witness data structures during analysis without explicit exception handling.",
      "description_length": 345,
      "index": 793,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Svcomp.StackTaskResult.Arg.Edge",
      "library": "goblint.lib",
      "description": "This module represents edges in a control flow graph for SV-COMP tasks, specifically handling the embedding of edges into a task result context. It provides operations to convert edges to string representations and to embed raw CFG edges into the appropriate task-specific edge type. It works with control flow graph edges and task result structures, enabling precise tracking and reporting of analysis outcomes tied to specific code locations.",
      "description_length": 444,
      "index": 794,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Control.AnalyzeCFG.CompareGlobSys.PP",
      "library": "goblint.lib",
      "description": "This module provides map-like and dictionary-like operations for managing key-value associations, including insertion, lookup, iteration, in-place modifications, and merging of structures. It operates on polymorphic value maps keyed by CFG nodes (`Node.t`) or symbolic labels (`CompareGlobSys.PP.key`), emphasizing key-aware transformations and efficient state updates. These capabilities are critical for abstract interpretation tasks such as tracking constraints per control flow node, merging analysis states during fixed-point computation, and applying label-based CFG transformations.",
      "description_length": 589,
      "index": 795,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Control.AnalyzeCFG.CompareGlobSys.GH",
      "library": "goblint.lib",
      "description": "This module supports imperative manipulation of key-value maps where keys are global variable identifiers (`SpecSys.EQSys.GVar.t`) and values represent abstract program states or constraints. It facilitates managing global state during abstract interpretation by enabling efficient lookups, updates, and bulk operations like merging and filtering, which are critical for tracking variable relationships and solving constraint systems. The ability to convert between hash tables, sequences, and enumerators allows seamless integration with analysis workflows that require iterative refinement or statistical analysis of program properties.",
      "description_length": 638,
      "index": 796,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MutexAnalysis.Spec.Arg.GProtecting",
      "library": "goblint.lib",
      "description": "This module's operations center on lattice manipulations (join, meet, widen, narrow) and structured protection state management for concurrency analysis. It works with abstract values tracking variable protection states (`GProtecting.t`), which encode write-protection status, recovery flags, and associated mutex locksets (`MustLockset.t`). These capabilities enable static analysis of thread safety by determining which variables are correctly guarded by specific mutexes in concurrent programs.",
      "description_length": 497,
      "index": 797,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.PrivPrecCompareUtil.Util.RH.Labels",
      "library": "goblint.lib",
      "description": "This module provides operations for manipulating hash tables with keys of type `key` and values of a generic type `'a`, including adding, replacing, modifying, and filtering entries. It supports both in-place and functional transformations, with functions that operate on key-value pairs and allow conditional updates, merging, and folding. Concrete use cases include tracking and transforming labeled data mappings, such as managing symbolic analysis states or precision settings in static analysis.",
      "description_length": 500,
      "index": 798,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.UnassumeAnalysis.Spec.Locator.ES",
      "library": "goblint.lib",
      "description": "This module implements set-based operations for managing collections of CFG nodes and symbolic identifiers, supporting membership checks, union, intersection, transformation via mapping and filtering, and structural manipulations like partitioning or symmetric difference. It provides utilities for converting sets to sequences, retrieving extremal elements (min/max), and safely querying structured data derived from YAML witness invariants. These capabilities are used in static analysis to track and emit unassume events by analyzing program invariants and locator entries from external specifications.",
      "description_length": 605,
      "index": 799,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.YamlWitness.Make.FCMap.Labels",
      "library": "goblint.lib",
      "description": "This module implements a labeled finite map with operations for adding, replacing, modifying, and filtering key-value pairs. It supports iteration, folding, and in-place transformations, along with selective merging and filtering using custom functions. It is used for structured manipulation of mappings where keys are of type `FCMap.key` and values are of arbitrary type, particularly in contexts requiring precise control over map evolution during YAML witness processing.",
      "description_length": 475,
      "index": 800,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ArgTools.Make.NHT.Labels",
      "library": "goblint.lib",
      "description": "This module provides operations for manipulating hash tables with labeled keys, including adding, replacing, and modifying entries, as well as filtering, mapping, and folding over key-value pairs. It supports data types such as hash tables (`NHT.t`) with a polymorphic value type and uses `NHT.key` for key operations. Concrete use cases include transforming and querying abstract reachability graphs during static analysis, such as updating node labels or filtering graph elements based on analysis results.",
      "description_length": 508,
      "index": 801,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Base.MainFunctor.VarH.Infix",
      "library": "goblint.lib",
      "description": "Implements variable handling for analysis domains with operations to get and set values associated with variables. Works with `VarH.t`, a hash table mapping variables to domain values. Enables direct variable access and updates during static analysis.",
      "description_length": 251,
      "index": 802,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.YamlWitnessType.ViolationSequence.Constraint.Value",
      "library": "goblint.lib",
      "description": "This module defines a polymorphic type `t` that represents either a string or an integer value, along with functions to compare values, convert them to YAML format, and parse them from YAML input. It supports direct conversion to and from YAML values, enabling seamless integration with YAML-based witness files. The module is used to handle constraint values in violation sequences, such as representing symbolic expressions or numeric thresholds in a structured format.",
      "description_length": 471,
      "index": 803,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MutexAnalysis.Spec.Arg.G",
      "library": "goblint.lib",
      "description": "This module provides lattice operations (join, meet, leq, widening, narrowing) and serialization utilities for a polymorphic variant type modeling abstract mutex",
      "description_length": 161,
      "index": 804,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MutexAnalysis.Spec.Arg.MakeP",
      "library": "goblint.lib",
      "description": "This module provides lattice operations and domain combinators for analyzing concurrent read/write and write-only mutex states, operating on product domains of `P.t` values to enable precision control, state comparison, and structured differencing. It supports use cases like verifying locking behaviors in multithreaded programs, debugging via pretty-printed diagnostics, and generating test cases or format-agnostic representations (XML, Yojson) of analysis results.",
      "description_length": 468,
      "index": 805,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.ArgTools.Make.NHT.Exceptionless",
      "library": "goblint.lib",
      "description": "This module provides operations for safely querying and modifying a nested hash table structure. It includes functions to find values by key and to apply transformations to stored values, returning results that indicate success or failure without raising exceptions. It is used in contexts where constraint system solutions are processed into analysis results, handling key-based data retrieval and updates.",
      "description_length": 407,
      "index": 806,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Server.Locator.LocM.Exceptionless",
      "library": "goblint.lib",
      "description": "This module provides operations for querying and selecting entries in a key-value structure without raising exceptions. It supports data types with keys and associated values, allowing safe lookup, selection, and retrieval of arbitrary elements. Concrete use cases include handling optional results when querying server-side data structures like client contexts or analysis states.",
      "description_length": 381,
      "index": 807,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.RaceAnalysis.Spec.OffsetTrie.ChildMap",
      "library": "goblint.lib",
      "description": "This module provides a specialized map structure for managing hierarchical memory access relationships in trie nodes, where keys represent memory offsets and values are sub-tries encoding nested memory locations. It combines standard map operations (insertion, traversal, filtering) with lattice-based combinators (meet, join) to merge and compare access sets during race analysis, specifically handling nested data structures and type-based memory partitions. The structure enables precise race detection by tracking access intersections between prefix and type suffix hierarchies, supporting efficient analysis of complex memory layouts in C programs.",
      "description_length": 653,
      "index": 808,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.YamlWitness.Validator.Locator.LocM",
      "library": "goblint.lib",
      "description": "This module implements a location-keyed map structure that supports ordered key-value associations with polymorphic values, enabling operations like conditional updates, filtered transformations, and ordered traversal. It provides utilities for handling sparse or nested data common in YAML validation scenarios, including safe accessors, structured printing, and combinators for merging or partitioning maps based on location keys. The design emphasizes both functional manipulation (via folds, maps, and iterators) and practical use cases like witness validation through exception-safe traversal and customizable data representation.",
      "description_length": 635,
      "index": 809,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Assert.Spec.P",
      "library": "goblint.lib",
      "description": "This module defines operations for managing path-representative values with support for equality, hashing, comparison, and serialization. It works with a concrete type `t` representing path identifiers, primarily used for tracking unique paths in analysis contexts. Functions like `tag`, `of_elt`, and `relift` enable path-based constraint handling and projection from domain elements.",
      "description_length": 385,
      "index": 810,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.CommonPriv.PerMutexTidCommon.LMust",
      "library": "goblint.lib",
      "description": "This module supports set and lattice operations on lock sets (`LLock.t`) augmented with a top element to model potentially unbounded states. It provides union, intersection, difference, and iteration capabilities alongside lattice primitives like `join`, `meet`, and `widen` for static analysis of concurrent programs. The type `t` enables tracking lock ownership or publication states in thread-modular analyses, particularly for scenarios requiring precise modeling of mutex interactions or global value initialization in multi-threaded contexts.",
      "description_length": 548,
      "index": 811,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.WrapperFunctionAnalysis.MallocWrapper.C",
      "library": "goblint.lib",
      "description": "This module creates and manages symbolic heap locations for dynamic memory allocations based on node and thread IDs. It works with a custom type `t` representing symbolic memory locations, supporting operations like equality checks, hashing, comparison, and pretty-printing. Concrete use cases include tracking distinct memory allocations in static analysis to improve precision when modeling heap usage in C programs.",
      "description_length": 418,
      "index": 812,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.StackTrace.Spec2.V",
      "library": "goblint.lib",
      "description": "This module implements a singleton-type specification for call stack analysis with operations to compare, hash, and uniquely identify empty stack trace values. It provides serialization to XML and JSON, pretty-printing, and support for arbitrary value generation for testing. Concrete use cases include tracking empty stack states in static analysis and generating unique identifiers for context-sensitive analysis in Goblint.",
      "description_length": 426,
      "index": 813,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.SpecLifters.DeadBranchLifter.D",
      "library": "goblint.lib",
      "description": "This module defines lattice operations for abstract interpretation, including join, meet, widen, and narrow, operating on a type `D.t` that represents abstract values with a bottom element and partial order. It supports static analysis tasks like dead branch detection by modeling domains with top and bottom elements, enabling precise dataflow optimizations. The type `D.t` is structured for use in analyses requiring lattice-theoretic reasoning, such as tracking unreachable code paths.",
      "description_length": 488,
      "index": 814,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Queries.Hashtbl.Infix",
      "library": "goblint.lib",
      "description": "This module provides infix operators for interacting with a hash table that maps keys to values within a query lattice. The `-->` operator retrieves a value for a given key, while `<--` associates a key with a value. These operations are used to efficiently manage and query lattice values in analysis contexts like static program analysis.",
      "description_length": 340,
      "index": 815,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.ArgTools.Make.NHT",
      "library": "goblint.lib",
      "description": "This module implements polymorphic hash tables mapping `Node.t` keys to arbitrary values, supporting imperative operations like insertion, deletion, and bulk transformations alongside functional manipulations such as filtering, merging, and key-value mapping. It facilitates hierarchical data modeling through nested structures and label-based access patterns, with utilities for sequence conversion, traversal, and exception-safe queries. Designed for static analysis workflows, it efficiently handles constraint system representations and labeled program state tracking in hierarchical contexts.",
      "description_length": 597,
      "index": 816,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.WrapperFunctionAnalysis.ThreadCreateWrapper.P",
      "library": "goblint.lib",
      "description": "This module defines a path-representative type `t` with operations for equality, hashing, comparison, and pretty-printing, used to track symbolic thread identifiers. It works with constraint variables and symbolic execution paths to generate unique identifiers for thread creation events based on node IDs. Concrete use cases include managing thread identity in static analysis to improve precision when reasoning about concurrent program behavior.",
      "description_length": 448,
      "index": 817,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.RecursionTermLifter.Lifter.G",
      "library": "goblint.lib",
      "description": "This module provides lattice operations (join, meet, widen, narrow, and monotonicity checks) alongside utilities for comparison, display, and random generation for a type representing analysis states in a hierarchical lattice structure. It works with values of a lattice type that includes distinguished bottom and top elements, supporting fixed-point computations and difference analysis. The operations facilitate cycle detection in dynamic function call graphs by modeling state transitions with lattice-theoretic semantics and explaining non-monotonic changes via `pretty_diff`.",
      "description_length": 582,
      "index": 818,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.BaseDomain.PartDeps.VarSet",
      "library": "goblint.lib",
      "description": "This module implements a functional set interface with operations like union, intersection, and lattice-based join/meet for sets of variables from `Basetype.Variables.t`, enabling precise manipulation of variable dependencies in dataflow analysis. It supports advanced use cases such as partitioning sets based on predicates, tracking extremal elements, and merging analysis results through widening/narrowing, while providing utilities for serialization and property-based testing. The design caters to static analysis tasks requiring efficient set manipulation and integration with analysis lattices.",
      "description_length": 602,
      "index": 819,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.SpecLifters.DeadCodeLifter.V",
      "library": "goblint.lib",
      "description": "This module defines operations for managing global constraint variables, including equality checks, hashing, comparison, and string representation. It works with a concrete type `t` representing constraint variables, each with a unique ID and contextual identity. These variables are used to track and reason about dead code during analysis, enabling precise identification of unreachable code paths and supporting constraint-based analyses.",
      "description_length": 441,
      "index": 820,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.YamlWitness.Make.WitnessInvariant",
      "library": "goblint.lib",
      "description": "This module tracks and identifies loop heads and invariant locations in the control flow graph during YAML witness generation. It provides functions to determine if a node is a loop head, an invariant location, or follows a lock operation, using node-based lookups and syntactic analysis. These operations support precise witness emission for verification by associating control flow nodes with source code locations.",
      "description_length": 417,
      "index": 821,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.WitnessConstraints.PathSensitive3.V",
      "library": "goblint.lib",
      "description": "This module defines a data type `t` representing global constraint variables with operations for equality, comparison, hashing, and pretty-printing. It supports path-sensitive analysis by providing unique identifiers via `tag` and arbitrary value generation for testing with `arbitrary`. Concrete use cases include tracking variable identities in abstract interpretation and generating witness data for analysis reports.",
      "description_length": 420,
      "index": 822,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Witness.Result.Query",
      "library": "goblint.lib",
      "description": "This module provides functions to query local and global analysis results at specific nodes or variables within an abstract reachability graph (ARG). It operates on graph structures representing program analysis states, using node identifiers and variable contexts to retrieve computed results. Concrete use cases include extracting value constraints or checking properties at specific program points during static analysis.",
      "description_length": 424,
      "index": 823,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.LoopfreeCallstring.Spec.G",
      "library": "goblint.lib",
      "description": "This module implements lattice operations and domain-specific constructors for loop-free callstrings used in static analysis to track function call contexts while eliminating recursion cycles. It provides join/meet operations, widening/narrowing for fixed-point computation, and top element handling to support abstract interpretation frameworks. These abstractions are particularly useful for improving precision in points-to analysis or thread-modular verification by collapsing recursive call cycles into sets, as described in clustered relational analysis approaches.",
      "description_length": 571,
      "index": 824,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.PrivPrecCompareUtil.Util.Dom",
      "library": "goblint.lib",
      "description": "This module provides lattice operations (join, meet, widen, narrow), equality checks, and ordering functions for a compound domain type used in precision comparison analysis. It supports values with top/bottom markers and includes utilities for pretty-printing, XML/JSON serialization, arbitrary value generation, and internal domain transformations via `relift`. These capabilities enable analyzing precision hierarchies, validating domain correctness, and debugging through structured diff outputs.",
      "description_length": 500,
      "index": 825,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.MutexEventsAnalysis.Spec.D",
      "library": "goblint.lib",
      "description": "This module provides lattice operations (join, meet, widen, narrow) and extremal elements (top, bottom) to model abstract mutex states in static analysis. It operates on a tagged lattice structure `t` that represents mutex event contexts, enabling precise tracking of lock/unlock sequences and their relationships. The structure supports comparison, serialization, and context-sensitive witness generation, primarily for analyzing concurrency in programs with complex locking patterns.",
      "description_length": 485,
      "index": 826,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Control.AnalyzeCFG.Query",
      "library": "goblint.lib",
      "description": "This module provides functions to query abstract analysis results at specific nodes or globally within a control flow graph. It supports queries over analysis states represented as dataflow facts, enabling inspection of local or global program properties derived during constraint solving. Concrete use cases include retrieving variable values at program points or checking global invariants after analysis.",
      "description_length": 407,
      "index": 827,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Witness.Result.ArgTool",
      "library": "goblint.lib",
      "description": "This module provides functions for constructing and querying bi-directional argument graphs using analysis states and control flow nodes. It works with tuples of CFG nodes, specification contexts, and integer identifiers, supporting operations like node lookup, index retrieval, and graph creation from state lists. Concrete use cases include generating GraphML output for abstract reachability graphs and analyzing variable values at specific nodes during static analysis.",
      "description_length": 473,
      "index": 828,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.LongjmpLifter.Lifter.G",
      "library": "goblint.lib",
      "description": "This module provides lattice operations for abstract interpretation, including comparison, display, and manipulation functions to handle `longjmp`/`setjmp` semantics in static analysis. It works with lattice elements representing program states, supporting merging (join/meet), ordering checks (leq), and debugging via pretty-printing and witness generation, with `top`/`is_top` for extremal value analysis.",
      "description_length": 407,
      "index": 829,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.CommonPriv.WriteCenteredD.W",
      "library": "goblint.lib",
      "description": "This module provides associative map operations (e.g., `add`, `find`, `fold`) and lattice primitives (e.g., `join`, `leq`, `widen`) for analyzing variable-to-lockset mappings, where keys represent program variables and values track minimal locksets in concurrent programs. It supports concurrency analysis by enabling lockset manipulation and abstract interpretation tasks like fixpoint computation, with utilities for serialization, comparison, and difference visualization in static analysis workflows.",
      "description_length": 504,
      "index": 830,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MemLeak.Spec.V",
      "library": "goblint.lib",
      "description": "This module defines and manipulates global constraint variables used to track memory leak states in analysis. It provides operations for equality checking, hashing, comparison, and string representation of these variables, along with utilities for serialization and generating arbitrary test values. These variables are used to represent abstract memory locations in the analysis of memory leaks, enabling precise tracking and constraint solving during static analysis.",
      "description_length": 469,
      "index": 831,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.SpecLifters.WidenContextLifterSide.DD",
      "library": "goblint.lib",
      "description": "This module implements lattice operations (join, meet, widen, narrow) and ordering primitives (leq, is_bot) for an abstract domain type DD.t, enabling approximation and comparison in static analysis. It includes domain inspection predicates like is_top, XML serialization (printXml), and utilities for state representation (show, to_yojson), targeting lattice-based program verification and abstract interpretation tasks.",
      "description_length": 421,
      "index": 832,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Signs.Spec.G",
      "library": "goblint.lib",
      "description": "This module provides lattice operations (join, meet, widen, narrow) and comparisons for analyzing integer sign information in static analysis contexts. It works with an abstract type `t` representing sign states structured as a lattice with top/bottom elements and supports serialization/testing operations. The lattice structure enables tracking possible sign values (positive, negative, zero) for variables during intraprocedural analysis of program properties.",
      "description_length": 463,
      "index": 833,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.CommonPriv.PerMutexTidCommon.GThread",
      "library": "goblint.lib",
      "description": "This module supports lattice-based analysis and comparison of thread and mutex constraints using pairs of `LMust.t` (must-have relationships) and `L.t` (may-have relationships), enabling precise thread-modular static analysis of concurrent programs. It includes utilities for serializing thread states to XML/JSON, generating test values, and producing human-readable diffs to aid debugging and verification of thread interactions. These operations are particularly useful for analyzing synchronization behavior and data flow in multi-threaded systems.",
      "description_length": 552,
      "index": 834,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.YamlWitnessType.ViolationSequence.Waypoint",
      "library": "goblint.lib",
      "description": "This module defines operations for handling waypoints in a violation sequence, specifically supporting serialization to and from YAML format. It works with a record type that includes a waypoint type from a nested module. Concrete use cases include parsing and generating YAML representations of waypoints for witness files in static analysis tools.",
      "description_length": 349,
      "index": 835,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MayLocks.Spec.D",
      "library": "goblint.lib",
      "description": "This module provides lattice operations (join, meet, widen, narrow), equality checks, and pretty-printing utilities for manipulating abstract values representing may-locksets in concurrency analysis. It operates on a type modeling sets of locks that may be held at runtime, supporting static analysis of lock states and double locking behavior. Key use cases include tracking potential lock acquisitions in threaded programs and merging analysis states from divergent control-flow paths.",
      "description_length": 487,
      "index": 836,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Queries.Set.Labels",
      "library": "goblint.lib",
      "description": "This module provides operations for transforming and analyzing sets of query elements, including mapping, filtering, and partitioning functions. It works with sets of type `Goblint_lib.Queries.Set.t` and their individual elements. Concrete use cases include selectively extracting subsets based on predicates, applying element-wise transformations, and checking logical conditions across all elements.",
      "description_length": 401,
      "index": 837,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.CommonPriv.MutexGlobals.VMutexInits",
      "library": "goblint.lib",
      "description": "This module tracks initial states of mutexes in thread-modular analysis, specifically modeling which mutexes are initialized at the start of a function. It works with unit type values to represent mutex initialization states, enabling comparisons and hashing for analysis consistency. It is used to determine if a mutex must be initialized upon function entry, guiding analysis precision in concurrent programs.",
      "description_length": 411,
      "index": 838,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MutexTypeAnalysis.Spec.P",
      "library": "goblint.lib",
      "description": "This module defines operations for managing and comparing path-representative values used in a constraint-based mutex type analysis. It provides equality checks, hashing, ordering, and string/XML/JSON representations for these values, which are essential for tracking and resolving global constraints. The module supports concrete use cases such as identifying and comparing constraint variables during analysis, and exporting constraint data for external tools or logging.",
      "description_length": 473,
      "index": 839,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ExtractPthread.Spec.V",
      "library": "goblint.lib",
      "description": "This module defines and manipulates global constraint variables used in the analysis of Pthread programs. It provides operations for equality checking, hashing, comparison, and string representation, along with support for serialization and arbitrary value generation. These variables are used to track and enforce constraints during program analysis, particularly in the context of extracting Promela models.",
      "description_length": 409,
      "index": 840,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.YamlWitnessType.ViolationSequence.Branching",
      "library": "goblint.lib",
      "description": "This module defines branching structures within violation sequences for YAML witness files. It includes functions to parse branching data from YAML and compare branching instances. It is used to represent and manipulate conditional paths in program analysis violations.",
      "description_length": 269,
      "index": 841,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.WrapperFunctionAnalysis.MallocWrapper.G",
      "library": "goblint.lib",
      "description": "This module provides lattice operations (join, meet, widen, narrow) and symbolic representation for heap-allocated memory regions in static analysis. It operates on a lattice type `t` that encodes symbolic heap locations derived from program node and thread identifiers, enabling precise tracking of dynamic memory allocations. The structure supports abstract interpretation for analyzing memory states in wrapper functions like `malloc`, particularly in scenarios involving concurrent thread execution and inter-thread memory sharing.",
      "description_length": 535,
      "index": 842,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.RecursionTermLifter.Lifter.C",
      "library": "goblint.lib",
      "description": "Implements equality, hashing, comparison, and serialization for a context type in a call graph, supporting cycle detection during analysis. Works with hashed, comparable, and serializable data structures, particularly for tracking recursive contexts. Used to lift recursion terms with unique identifiers and maintain consistent representations across analyses.",
      "description_length": 360,
      "index": 843,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ObserverAnalysis.MakeSpec.D",
      "library": "goblint.lib",
      "description": "This module supports lattice-based static analysis by defining operations for equality, ordering, and extremal values (like `join`, `meet`, `top`, `bot`) on an abstract domain `D.t`. It works with abstract values in a context-sensitive dataflow analysis, enabling precise modeling of program states through lattice theory operations and domain-specific serialization for comparison and output. Use cases include tracking dataflow properties and managing domain boundaries via widening/narrowing to ensure convergence.",
      "description_length": 517,
      "index": 844,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.MHPAnalysis.Spec.A",
      "library": "goblint.lib",
      "description": "This module implements may-happen-in-parallel (MHP) analysis for concurrent programs, determining whether memory accesses can occur in parallel and potentially race. It operates on thread identifiers and thread sets to track creation, joining, and execution states, enabling precise analysis of thread interactions. Concrete use cases include detecting data races and ensuring thread-safety in multi-threaded C programs analyzed by Goblint.",
      "description_length": 440,
      "index": 845,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.LocksetAnalysis.MakeMust.A",
      "library": "goblint.lib",
      "description": "This module implements a must-lockset analysis for concurrency safety, determining which locks must be held at each program point. It operates on control flow graphs and tracks lock acquisition and release operations to ensure consistent locking behavior. It is used to detect potential race conditions and enforce lock usage policies in multi-threaded programs.",
      "description_length": 362,
      "index": 846,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.LoopfreeCallstring.Spec.C",
      "library": "goblint.lib",
      "description": "This module defines operations for managing loop-free call strings, including equality checks, hashing, comparison, and serialization. It works with a custom type `t` representing call strings, optimized to reduce length in recursive scenarios by tracking call cycles. Concrete use cases include efficient context-sensitive analysis in abstract interpretation, particularly for detecting and managing recursive call patterns in program analysis.",
      "description_length": 445,
      "index": 847,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.CommonPriv.MutexGlobals.VMutex",
      "library": "goblint.lib",
      "description": "This module provides operations for representing and manipulating mutex variables with offset tracking, including comparisons, serialization to XML/JSON, and conversion to CIL expressions. It works with `GoblintCil.varinfo` and `Offset.t` to model mutex states in thread-modular static analysis, enabling precise reasoning about concurrent memory accesses. Key use cases include type coercion between mutex-specific and general value domains (`Mval.t`) and identifying mutex instances during concurrency analysis.",
      "description_length": 513,
      "index": 848,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ThreadAnalysis.Spec.V",
      "library": "goblint.lib",
      "description": "This module provides operations for managing thread identifiers (TIDs) and analyzing their relationships in concurrent programs, including comparisons, hashing, and tracking parent-child thread hierarchies. It works with thread IDs, function variables (`varinfo`), and analysis states (`D.t`), while also offering a utility to determine if arbitrary values meet \"write-only\" conditions. These capabilities support use cases like tracking thread creation events, resolving thread interactions, and analyzing memory or variable access patterns in multithreaded contexts.",
      "description_length": 568,
      "index": 849,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ThreadJoins.Spec.V",
      "library": "goblint.lib",
      "description": "This module manages thread identifiers (TIDs) with operations for comparison, hashing, and tracking thread creation, parent-child relationships, and spawning behavior in concurrent program analysis. It also includes a predicate to identify write-only references within abstract values, which is critical for analyzing memory effects where writes do not interfere with reads. These capabilities support clustered relational thread-modular abstract interpretation, enabling precise modeling of thread interactions and local trace properties in concurrent systems.",
      "description_length": 561,
      "index": 850,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Base.MainFunctor.V",
      "library": "goblint.lib",
      "description": "This module defines a sum type combining thread identifiers and privilege values, with operations for comparison, hashing, and pretty-printing. It supports concrete use cases like tracking thread-specific data and privilege states in concurrent analyses. Functions like `priv`, `thread`, and `relift` enable constructing and transforming values between analysis contexts.",
      "description_length": 371,
      "index": 851,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Expsplit.Spec.V",
      "library": "goblint.lib",
      "description": "This module defines and manipulates constraint variables used in path-sensitive analysis, uniquely identified by a hash and tag. It supports equality checks, comparison, string representation, and serialization to XML and JSON formats. These variables track expression values across analysis states, enabling precise constraint propagation and witness generation for verification tasks.",
      "description_length": 386,
      "index": 852,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Control.AnalyzeCFG.RT",
      "library": "goblint.lib",
      "description": "This module implements analysis of control flow graphs (CFGs) for abstract interpretation by solving constraints derived from program paths. It operates on tuples containing constraint and data specifications along with function declarations (`CilType.Fundec.t`), and provides comparison, serialization, and pretty-printing operations tailored for analysis results. Concrete use cases include tracking dataflow properties through CFG nodes and validating abstract interpretation outcomes against expected constraint solutions.",
      "description_length": 526,
      "index": 853,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.LockDomain.MustMultiplicity.Count",
      "library": "goblint.lib",
      "description": "This module supports operations for tracking and analyzing lock acquisition counts in concurrent programs using a lattice structure of integers. It provides lattice-theoretic functions like join, meet, and widening to model lock multiplicity states, alongside utilities for XML serialization and property-based testing of integer values. The design enables static analysis of lock usage patterns to detect concurrency issues such as deadlocks or inconsistent locking.",
      "description_length": 467,
      "index": 854,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Constants.Spec.P",
      "library": "goblint.lib",
      "description": "This module defines path-representative constraint variables for tracking unique identifiers in a constants analysis. It provides operations for equality checking, hashing, comparison, and pretty-printing, along with functions for serialization and arbitrary value generation. These variables are used to represent and distinguish different paths in the analysis, enabling precise context-sensitive reasoning within a single procedure.",
      "description_length": 435,
      "index": 855,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Region.Spec.V",
      "library": "goblint.lib",
      "description": "This module defines operations for handling a unit-type specification in region analysis, providing equality, comparison, and hashing functions. It supports pretty-printing, serialization to XML and Yojson, and QCheck arbitrary value generation. Concrete use cases include representing abstract memory regions in static analysis and enabling structural comparisons in concurrency race detection.",
      "description_length": 395,
      "index": 856,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Signs.Spec.C",
      "library": "goblint.lib",
      "description": "Implements a sign analysis for integers with values restricted to positive, negative, zero, or unknown. It provides comparison, hashing, and pretty-printing operations for sign values, supporting integration with analysis frameworks that require these primitives. Used in static analysis to track the sign of integer expressions within functions, enabling optimizations and correctness checks based on sign properties.",
      "description_length": 418,
      "index": 857,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.WrapperFunctionAnalysis.SpecBase.UniqueCallCounter",
      "library": "goblint.lib",
      "description": "This module provides map-based operations for tracking and merging unique call counts of symbolic analysis elements, such as heap locations or thread identifiers, associated with program control flow nodes. It works with finite maps keyed by node identifiers, supporting standard dictionary operations alongside domain-specific combinators for bulk updates and lattice-structured state merging. The data structure is particularly useful in static analysis scenarios requiring precise aggregation of dynamic allocation sites or thread creation events across different program paths.",
      "description_length": 581,
      "index": 858,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.LongjmpLifter.Lifter.C",
      "library": "goblint.lib",
      "description": "This module defines operations for manipulating and comparing a specific type `t` used in the analysis of `longjmp` and `setjmp` constructs. It includes functions for equality checking, hashing, comparison, string representation, pretty printing, XML output, and JSON serialization, along with utilities for generating arbitrary values and relifting contexts. The module supports concrete analysis tasks such as tracking control flow changes and maintaining context during program analysis.",
      "description_length": 490,
      "index": 859,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Control.AnalyzeCFG.Slvr",
      "library": "goblint.lib",
      "description": "Implements a constraint solver for abstract interpretation over control flow graphs by processing local and global variables with domain-specific operations. It maintains equation systems and hash tables for variable mappings, enabling precise dataflow analysis through iterative constraint resolution. Used to compute reaching definitions, constant propagation, and other intra-procedural analyses by solving equations derived from program structure and lattice semantics.",
      "description_length": 473,
      "index": 860,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.CompareConstraints.CompareNode.Node",
      "library": "goblint.lib",
      "description": "The module defines a `Node` type representing control-flow graph nodes derived from CIL code, offering operations for structural comparison, unique identification, pretty-printing, and serialization to JSON/XML. It interacts with function definitions (`fundec`) and identifiers to enable constraint analysis tasks like scope resolution, write-only node detection, and cross-tool integration via source code location tracking and declarative node transformations. These utilities are critical for analyzing program flow and generating diagnostics in static analysis pipelines.",
      "description_length": 575,
      "index": 861,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.YamlWitnessType.ViolationSequence.Constraint",
      "library": "goblint.lib",
      "description": "This module defines a constraint type that pairs a value with an optional format string, supporting comparison, YAML serialization, and deserialization. It operates on values that can be strings or integers, along with optional format specifiers, to represent structured constraints in violation sequences. It is used to encode and decode constraint data in YAML-based witness files, such as specifying expected numeric ranges or symbolic expressions with custom formatting.",
      "description_length": 474,
      "index": 862,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MallocFresh.Spec.A",
      "library": "goblint.lib",
      "description": "This module defines operations for analyzing unescaped heap allocations in C code, specifically tracking whether memory locations are fresh (i.e., not reachable from any global or thread-local variables). It works primarily with boolean values representing the freshness state of a memory location. Concrete use cases include determining if a `malloc` call results in a pointer that does not escape the current thread, enabling more precise race detection and optimization.",
      "description_length": 473,
      "index": 863,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.AnalysisResult.Result.Infix",
      "library": "goblint.lib",
      "description": "This module provides infix operators `(-->)` and `(<--)` for accessing and inserting values in a hash table keyed by analysis result nodes. It operates on standard hash tables from `Stdlib.Hashtbl.Make` with keys of type `Goblint_lib.AnalysisResult.ResultNode`. These operators simplify lookups and updates when processing analysis results during static analysis tasks.",
      "description_length": 369,
      "index": 864,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ThreadId.Spec.N",
      "library": "goblint.lib",
      "description": "This module implements a lattice structure for thread ID analysis with three value types: extremal bottom/top and lifted versioned identifiers. It supports join/meet operations for merging concurrent thread states, widening/narrowing for fixpoint stabilization, and comparison utilities. The domain is specifically designed for static analysis of concurrent programs, enabling precise tracking of thread identity across control flow merges and loops, with serialization capabilities for analysis result persistence.",
      "description_length": 515,
      "index": 865,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.SpecLifters.LimitLifter.V",
      "library": "goblint.lib",
      "description": "This module represents global constraint variables with operations for equality, hashing, comparison, and serialization. It works with a concrete type `t` that supports unique identification, pretty-printing, and conversion to formats like XML and Yojson. It is used to track and manage constraint variables in static analysis, particularly for limiting widenings and supporting witness generation through unique tagging.",
      "description_length": 421,
      "index": 866,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Taint.Spec.G",
      "library": "goblint.lib",
      "description": "This module provides lattice operations and utilities for a taint analysis domain, working with abstract values of type `t` that represent taint states. It supports core analysis functionality like join/meet operations, widening/narrowing for convergence, and comparison/pretty-printing for diagnostics. The design enables tracking data flow through program variables to identify potential security vulnerabilities, particularly in interprocedural contexts where taint propagation across function boundaries must be modeled.",
      "description_length": 524,
      "index": 867,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Preprocessor.FpathH.Labels",
      "library": "goblint.lib",
      "description": "This module provides hash table operations for managing key-value pairs where keys are of type `Goblint_lib.Preprocessor.FpathH.key` and values are polymorphic. It supports standard imperative operations like `add`, `replace`, `modify`, and `iter`, as well as transformations such as `map`, `filter`, and `fold`. Concrete use cases include tracking preprocessor definitions, efficiently modifying or querying stored paths, and merging hash tables during C preprocessor detection.",
      "description_length": 479,
      "index": 868,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Uninit.Spec.C",
      "library": "goblint.lib",
      "description": "This module provides lattice operations (join, meet, widen, narrow, top, bot) and domain-specific utilities to model uninitialized variable states in static analysis. It operates on an abstract domain type representing program values, where elements like top and bot denote maximal and minimal information about initialization. These operations enable dataflow analysis to track and reason about uninitialized variable uses in programs.",
      "description_length": 436,
      "index": 869,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MutexEventsAnalysis.Spec.A",
      "library": "goblint.lib",
      "description": "This module defines a data type `t` representing mutex events, including operations for equality checking, hashing, comparison, and string representation. It provides functions to determine potential race conditions between events, control their output in reports, and serialize them to JSON or XML formats. Concrete use cases include tracking and analyzing mutex lock/unlock events during static analysis to detect concurrency issues.",
      "description_length": 435,
      "index": 870,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.LocksetAnalysis.MakeMay.C",
      "library": "goblint.lib",
      "description": "This module provides lattice operations for abstract lockset analysis, including join, meet, widening, and narrowing, operating on abstract values of type `C.t` derived from a base domain `D.t`. It represents locksets using a may-analysis approach, where the top element signifies all possible lock combinations and `leq` checks partial order relationships. The structure supports static analysis of concurrent programs to track potential lock acquisitions and ensure thread safety.",
      "description_length": 482,
      "index": 871,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ThreadReturn.Spec.C",
      "library": "goblint.lib",
      "description": "This module implements a specification for thread return analysis, where each thread's state is abstracted by a boolean indicating whether it is at the topmost call stack frame. It provides operations for equality checking, hashing, comparison, string representation, and serialization to XML and JSON formats. Concrete use cases include tracking thread states during static analysis and generating unique identifiers for contexts in witness generation.",
      "description_length": 453,
      "index": 872,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ExpRelation.Spec.C",
      "library": "goblint.lib",
      "description": "This module defines a concrete specification for comparing expressions syntactically with `=_{must}`. It provides operations for equality checking, hashing, comparison, and serialization, working with a single abstract type `t`. Use cases include integrating expression relation analysis into the Goblint framework and generating witnesses for expression equivalence.",
      "description_length": 367,
      "index": 873,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.ResultQuery.NH.Exceptionless",
      "library": "goblint.lib",
      "description": "This module provides operations to safely query and modify a constraint system solution without handling exceptions explicitly. It works with key-value stores represented as `Goblint_lib.ResultQuery.NH.t` and keys of type `Goblint_lib.ResultQuery.NH.key`. Concrete use cases include retrieving and updating analysis results during static program analysis, where missing keys or invalid states are handled via result types instead of exceptions.",
      "description_length": 444,
      "index": 874,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.SpecLifters.OptEqual.D",
      "library": "goblint.lib",
      "description": "This module provides lattice operations for merging, comparing, and transforming abstract values of type `D.t`, including `join`, `meet`, `widen`, `narrow`, and semantic equivalence checks via `equal`. It works with a lattice-like domain `D.t` featuring a top element and structural equality, designed for static analysis tasks like abstract state merging or constraint propagation. Specific utilities support generating human-readable diffs, hashing, serialization, and arbitrary value generation for testing analysis logic.",
      "description_length": 525,
      "index": 875,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.RegionDomain.RegPart.S",
      "library": "goblint.lib",
      "description": "This module implements a lattice structure with operations for comparing and combining abstract values (join, meet, widen, narrow) alongside set-like functionality for region manipulation (union, intersection, membership checks). It operates on region sets (`RS.t`) and their elements (`RS.elt`), which represent disjoint heap regions in abstract interpretation frameworks. Designed for static analysis, it enables tasks like partitioning memory regions, merging abstract states, and tracking hierarchical relationships between regions while supporting standard set operations and collapse-aware comparisons.",
      "description_length": 608,
      "index": 876,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.PthreadSignals.Spec.P",
      "library": "goblint.lib",
      "description": "This module defines a data type `t` representing path-representative constraint variables for tracking signal propagation in pthread condition variable analysis. It provides operations for equality checking, hashing, comparison, string representation, and XML/YoJSON serialization, along with functions to generate arbitrary values and lift elements from another type. It is used to uniquely identify and manipulate constraint variables during static analysis of concurrent programs.",
      "description_length": 483,
      "index": 877,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.YamlWitness.Make.FMap",
      "library": "goblint.lib",
      "description": "This module provides key-based data manipulation for structured YAML witness processing, focusing on finite maps with CIL function declarations (`CilType.Fundec.t`) as keys. It supports associative operations like conditional filtering, value transformation, and map merging, along with sequence conversions and infix syntax for concise updates. Designed for static analysis tasks, it enables efficient handling of function-specific metadata in YAML representations, with safety guarantees through exceptionless lookups and labeled key-value transformations.",
      "description_length": 558,
      "index": 878,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MayLocks.Arg.G",
      "library": "goblint.lib",
      "description": "This module implements a lattice structure for abstract lock states, featuring operations like join, meet, widen, and narrowing, along with top and bottom elements. It supports equality checks, ordering, hashing, and pretty-printing for type `t`, which models may-lock analysis information. These capabilities enable static analysis of concurrent programs, particularly for dataflow analysis and debugging in lockset-based analyses.",
      "description_length": 432,
      "index": 879,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Deadlock.Spec.C",
      "library": "goblint.lib",
      "description": "This module provides lattice operations and serialization utilities for an abstract deadlock state type, supporting comparisons, hashing, and structured data formats like XML and JSON. It works with a lattice structure representing concurrency-related deadlock states, where elements form a hierarchy to model lock acquisition orders and resource dependencies. These operations enable static analysis of multithreaded programs to detect and prevent deadlocks by tracking state transitions and relationships during abstract interpretation.",
      "description_length": 538,
      "index": 880,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Queries.Set.Exceptionless",
      "library": "goblint.lib",
      "description": "This module provides functions for querying elements in a set without raising exceptions. It supports operations like finding the minimum, maximum, arbitrary, or any element matching a value, returning `None` if the set is empty or the element is not found. It works with `Goblint_lib.Queries.Set.t`, a set type parameterized over elements of type `elt`. Use this when safely extracting elements from a set is needed, such as in analysis passes where presence checks are required without exception handling overhead.",
      "description_length": 516,
      "index": 881,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.AnalysisResult.Result.Exceptionless",
      "library": "goblint.lib",
      "description": "This module provides operations to safely query and update a hash table mapping analysis result nodes to values. It includes functions to find values by key and modify them in place, returning results that handle potential exceptions. It is used for managing analysis results where operations must account for missing keys or invalid states without raising errors.",
      "description_length": 364,
      "index": 882,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.StackTrace.Spec1.P",
      "library": "goblint.lib",
      "description": "This module implements comparison, hashing, and serialization operations for a singleton type `t` used in call stack analysis. It provides concrete functions like `equal`, `compare`, `hash`, and `pretty` to support analysis and debugging of stack traces. Use cases include tracking and comparing empty stack states and serializing them for output or testing.",
      "description_length": 358,
      "index": 883,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MayLocks.Spec.A",
      "library": "goblint.lib",
      "description": "Implements equality, comparison, and hashing for a unit type used in may lockset analysis. Provides pretty-printing, serialization, and arbitrary value generation for testing. Supports checking potential race conditions and print conditions for analysis results.",
      "description_length": 262,
      "index": 884,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.RaceAnalysis.Spec.OffsetTrie",
      "library": "goblint.lib",
      "description": "This module provides trie-based lattice operations for hierarchical memory access tracking, enabling merging, traversal, and comparison of nested offset mappings to resolve overlapping memory accesses in C type hierarchies. It organizes data as tries mapping `Offset.Unit.t` keys to values, supporting difference reporting and lattice operations like `narrow` and `singleton`, while optimizing race detection by minimizing redundant checks between prefix and type suffix intersections. It is specifically used in static analysis of concurrent C programs with complex memory layouts, where precise hierarchical tracking of memory locations (e.g., struct fields, array indices) is required to identify data races at the most specific offsets.",
      "description_length": 740,
      "index": 885,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MutexAnalysis.Spec.C",
      "library": "goblint.lib",
      "description": "This module provides lattice operations for abstract interpretation in concurrent program analysis, including join, meet, widen, and narrowing combinators alongside comparison and serialization utilities. It manipulates a state type representing mutex locking behaviors, structured to support dataflow analysis over lock dependencies. These operations enable tracking protecting locksets and must-lock constraints in static analysis of thread synchronization patterns.",
      "description_length": 468,
      "index": 886,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.CommonPriv.PerMutexTidCommon.G",
      "library": "goblint.lib",
      "description": "This module provides lattice operations and variant manipulation utilities for thread-modular analysis, handling values lifted into polymorphic states representing mutexes or threads. It works with a lattice type combining bottom/top elements and two tagged variants (`GMutex.t`, `GThread.t`), supporting operations like join/meet, widening/narrowing, and serialization. Use cases include merging abstract states, comparing thread- or mutex-associated values, and converting structured analysis data to external formats during static analysis.",
      "description_length": 543,
      "index": 887,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.LoopTermination.Spec.V",
      "library": "goblint.lib",
      "description": "This module defines and manipulates global constraint variables used in termination analysis for loops and `goto` statements. It provides operations for equality checking, hashing, comparison, and string representation of these variables, along with support for serialization and arbitrary value generation. These variables are used to track and reason about loop termination conditions and context-sensitive constraints in program analysis.",
      "description_length": 441,
      "index": 888,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Taint.Spec.C",
      "library": "goblint.lib",
      "description": "This module defines a taint analysis specification with concrete operations for comparing, hashing, and displaying taint values. It works with a custom type `t` representing taint states, supporting serialization to XML and JSON, and includes functions for generating arbitrary values and unique tagging. It is used for implementing and testing taint propagation in static analysis, particularly for tracking data flow through function calls.",
      "description_length": 442,
      "index": 889,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.UseAfterFree.Spec.P",
      "library": "goblint.lib",
      "description": "This module defines and manipulates path-representative values used to track and identify unique execution paths in the use-after-free analysis. It provides operations for equality checking, hashing, comparison, and pretty-printing these path representatives, along with functions to serialize and generate arbitrary instances for testing. The module supports analysis by enabling path-sensitive tracking of memory operations through unique identifiers and structured representations.",
      "description_length": 484,
      "index": 890,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.ExtractPthread.Tbls.ThreadTidTbl",
      "library": "goblint.lib",
      "description": "This module provides a thread-local storage mechanism mapping thread names to thread IDs using a hash table. It supports operations to insert, retrieve, and convert the mapping to a list of name-ID pairs. Use cases include tracking thread identities during Pthread program analysis and correlating thread names with their unique identifiers in Promela extraction workflows.",
      "description_length": 373,
      "index": 891,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.YamlWitness.Make.FCMap",
      "library": "goblint.lib",
      "description": "This module provides operations for creating, transforming, and querying polymorphic finite maps where keys are structured from function definitions and specification systems, mapping to arbitrary values. It supports imperative-style modifications, higher-order transformations, and conversions to/from lists or sequences, with a focus on exception-safe updates and labeled merging. These maps are primarily used for structured YAML witness generation and validation tasks involving key-value pair manipulation.",
      "description_length": 511,
      "index": 892,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ObserverAnalysis.MakeSpec.A",
      "library": "goblint.lib",
      "description": "Implements analysis specifications for path-sensitive observers, defining operations like equality, hashing, and comparison for state tracking. Works with the abstract type `t` representing analysis states, supporting serialization, pretty-printing, and unique identification. Used to model and distinguish contexts during race detection and witness generation in concurrent analysis.",
      "description_length": 384,
      "index": 893,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.SpecLifters.HashconsLifter.P",
      "library": "goblint.lib",
      "description": "This module provides operations for managing globally unique constraint variables using hash-consed path representatives. It includes equality checks, hashing, comparison, and pretty-printing for these variables, along with functions to generate unique IDs, arbitrary instances, and conversions to various output formats. It is used to ensure canonical representation of constraint variables for efficient comparison and context identification in analyses.",
      "description_length": 456,
      "index": 894,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.ExpRelation.Spec.G",
      "library": "goblint.lib",
      "description": "This module implements a lattice structure for symbolic expression relations, providing operations like join, meet, widening, and equality checks to analyze syntactic relationships between expressions. It operates on a type representing equality constraints (e.g., `=_{must}`) and supports use cases in abstract interpretation where stateless symbolic reasoning is required to determine expression equivalence or combine relational information during static analysis.",
      "description_length": 467,
      "index": 895,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Base.MainFunctor.InvariantEval",
      "library": "goblint.lib",
      "description": "This module evaluates invariants during static analysis by interpreting expressions and lvalues in a given context and store. It provides operations for evaluating expressions to values, handling memory accesses, and refining variables based on computed results. Concrete use cases include tracking variable values, resolving memory addresses, and applying constraint propagation during value analysis.",
      "description_length": 402,
      "index": 896,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.WideningTokenLifter.Lifter.V",
      "library": "goblint.lib",
      "description": "This module defines globally constrained variables with operations for equality checking, hashing, comparison, and pretty-printing. It supports concrete use cases like tracking unique identifiers for context-sensitive analysis and managing variable lifetimes through relifting. The module works directly with a unique abstract type `t` representing variables, incorporating H-consed tags for efficient discrimination and identification.",
      "description_length": 436,
      "index": 897,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.LocksetAnalysis.MakeMust.D",
      "library": "goblint.lib",
      "description": "This module provides lattice operations and supporting utilities for an abstract domain representing sets of locksets in static analysis. It works with a domain type `D.t` that models possible locksets, offering standard lattice primitives like join, meet, widen, and top/bottom elements, along with serialization, comparison, and testing tools. It is specifically used in must analysis for concurrent programs to track definite lock acquisition patterns and enforce thread-safety guarantees.",
      "description_length": 492,
      "index": 898,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Malloc_null.Spec.C",
      "library": "goblint.lib",
      "description": "This module provides lattice-based abstract domain operations (join, meet, widen, narrow, top checks) and serialization utilities for a type representing memory allocation states in path-sensitive static analysis. It manipulates values of an abstract domain type designed to track potential null pointer origins from failed dynamic allocations, enabling precise analysis of memory safety. The lattice structure supports extremal value queries and domain-specific merging, critical for fixed-point computations in static analysis frameworks.",
      "description_length": 540,
      "index": 899,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.CompareConstraints.CompareNode.Compare",
      "library": "goblint.lib",
      "description": "This module compares constraint node maps by structurally analyzing their contents using `CompareD`, producing a comparison result and a pretty-printed document highlighting differences. It operates on `D.t NH.t` maps, which associate constraint nodes with their data. It is used to validate and debug constraint propagation by identifying discrepancies between expected and computed constraint states.",
      "description_length": 402,
      "index": 900,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.YamlWitness.Validator.WitnessInvariant",
      "library": "goblint.lib",
      "description": "Validates invariants at specific control flow points by checking node properties against syntactic and semantic loop characteristics. It uses hash tables to track loop heads and determines invariant validity based on node type, location, and loop context. This module is used to ensure correctness of generated YAML witnesses by confirming that invariants are only emitted at appropriate program points.",
      "description_length": 403,
      "index": 901,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ThreadReturn.Spec.G",
      "library": "goblint.lib",
      "description": "This module provides lattice operations for abstract interpretation in thread return analysis, including comparison, join/meet combinations, and widening/narrowing for convergence. It manipulates abstract values of type `t` representing thread return states, structured as a lattice with distinguished bottom and top elements. These operations enable static analysis of concurrent programs to track whether threads are at topmost call frames, aiding in detecting concurrency-related bugs through precise call stack abstraction.",
      "description_length": 527,
      "index": 902,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Server.Locator.LocM",
      "library": "goblint.lib",
      "description": "This module implements a persistent map structure for managing polymorphic values associated with CIL locations, supporting associative operations like insertion, lookup, and filtered transformations alongside ordered key traversals. It provides dictionary-like functionality for key-value pairs, including splitting, merging, and bidirectional iteration, while integrating monadic operations for safely handling state updates and structured data manipulation. Designed for contexts requiring precise location tracking, it serves use cases such as analyzing program state metadata in interactive JSON-RPC servers and maintaining key-associated lists with exception-safe access patterns.",
      "description_length": 686,
      "index": 903,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Svcomp.StackTaskResult.Arg",
      "library": "goblint.lib",
      "description": "This module represents nodes and edges in a control flow graph for SV-COMP task results, providing structural navigation and comparison operations. It works with `Arg.Node.t` and `Arg.Edge.t` types to enable analysis of abstract interpretation states and CFG transitions. Concrete use cases include tracking analysis progress through CFG nodes and comparing task results based on control flow structure and context.",
      "description_length": 415,
      "index": 904,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ObserverAnalysis.MakePathSpec.V",
      "library": "goblint.lib",
      "description": "This module defines a value type `t` representing global constraint variables in a path-sensitive analysis, equipped with standard comparison, hashing, and serialization operations. It supports tracking and distinguishing variables via unique tags and provides pretty-printing for debugging and XML/YoJSON serialization for external representation. Concrete use cases include managing variable identities in constraint systems and generating witnesses for analysis results.",
      "description_length": 473,
      "index": 905,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.SpecLifters.HashconsContextLifter.P",
      "library": "goblint.lib",
      "description": "This module defines operations for managing globally unique constraint variables using hash-consed contexts. It provides equality checks, hashing, comparison, and pretty-printing for these variables, along with serialization to XML and JSON. Concrete use cases include tracking and identifying analysis contexts in static program analysis, particularly for witness generation and constraint solving.",
      "description_length": 399,
      "index": 906,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Callstring.Spec.P",
      "library": "goblint.lib",
      "description": "This module defines path-representative values with operations for equality, hashing, comparison, and serialization. It works with a type `t` that represents abstract paths, supporting concrete use cases like tracking unique execution contexts in static analysis and enabling context-sensitive dataflow analysis with k-CFA. Functions include generating arbitrary instances for testing, converting from analysis elements, and extracting identifiers for witness generation.",
      "description_length": 471,
      "index": 907,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.WitnessConstraints.PathSensitive3.D",
      "library": "goblint.lib",
      "description": "This module provides lattice operations such as join, meet, widen, and narrow, alongside comparison, hashing, and serialization capabilities for an abstract domain modeling path-sensitive analysis states. It operates on the abstract type `D.t`, which encapsulates analysis state representations to support abstract interpretation semantics. These functionalities enable critical use cases like witness generation and constraint solving in static analysis workflows requiring path sensitivity.",
      "description_length": 492,
      "index": 908,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.ThreadId.Spec.A",
      "library": "goblint.lib",
      "description": "This module defines operations for handling optional thread identifiers, including equality checks, comparison, hashing, and pretty-printing. It works with the `ThreadLifted.t option` type to represent potentially absent thread IDs. Concrete use cases include tracking thread identity in concurrent analysis, determining potential race conditions between threads, and serializing thread information for output or debugging.",
      "description_length": 423,
      "index": 909,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MutexEventsAnalysis.Spec.V",
      "library": "goblint.lib",
      "description": "This module defines a data type `t` representing global constraint variables used in mutex events analysis. It provides operations for equality checking, hashing, comparison, and string representation, along with functions to generate arbitrary values and lift or tag variables. These capabilities support precise tracking and differentiation of mutex operations across analysis contexts.",
      "description_length": 388,
      "index": 910,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Malloc_null.Spec.P",
      "library": "goblint.lib",
      "description": "The module provides lattice operations (leq, join, meet, widen, narrow), equality checks, and serialization utilities for an abstract domain tracking failed dynamic memory allocations. It works with an abstract lattice type `t` that represents allocation states, supporting path-sensitive static analysis. This enables detecting null pointer dereferences and modeling error conditions in C programs where memory allocation may fail.",
      "description_length": 432,
      "index": 911,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MemLeak.Spec.D",
      "library": "goblint.lib",
      "description": "This module type defines lattice-based abstract domains for memory leak analysis, centered on an abstract type `t` representing analysis states. It provides lattice operations like join, meet, widen,",
      "description_length": 199,
      "index": 912,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.SpecLifters.PathSensitive2.D",
      "library": "goblint.lib",
      "description": "This module implements lattice operations like join, meet, widen, and narrow, alongside data representation capabilities such as serialization and comparison, all acting on a domain's abstract type. It supports path-sensitive static analyses by enabling precise manipulation of abstract values through standard lattice primitives (including top/bottom elements) and structural operations. These capabilities facilitate dataflow tracking, state merging, and analysis result persistence in abstract interpretation frameworks.",
      "description_length": 523,
      "index": 913,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.VarEq.Spec.C",
      "library": "goblint.lib",
      "description": "This module defines lattice-based operations for symbolic expression equality analysis, including comparisons, hashing, pretty-printing, and JSON serialization. It provides lattice primitives like join, meet, widen, and narrow for merging and approximating abstract states, alongside top/bottom element checks. These operations work on symbolic equality constraints between variables, enabling use in static analysis to track variable equivalences across program paths and optimize abstract interpretation workflows.",
      "description_length": 516,
      "index": 914,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ExtractPthread.Codegen.PmlResTbl",
      "library": "goblint.lib",
      "description": "Maps function names and thread resources to unique string identifiers for Promela edge labeling during Pthread-to-Promela translation. Uses a hash table internally to ensure uniqueness and efficient lookup by function name or thread resource. Enables precise labeling of synchronization edges in generated Promela models.",
      "description_length": 321,
      "index": 915,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ExtractPthread.Tbls.Tbl",
      "library": "goblint.lib",
      "description": "This module provides a bidirectional mapping between keys and values using a hash table. It supports insertion, lookup, and reverse lookup operations, ensuring each key maps to a unique value and vice versa. It is used to track associations between program elements during Pthread-to-Promela translation, such as mapping thread identifiers to their corresponding control flow nodes.",
      "description_length": 382,
      "index": 916,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.CommonPriv.PerMutexTidCommon.L",
      "library": "goblint.lib",
      "description": "This module provides map-like operations for managing key-value associations with `LLock.t` keys and `LD.t` values, including dictionary primitives, higher-order transformations, and lattice-based combinators for merging concurrent states. It supports thread-modular analysis by enabling precise manipulation of per-mutex, per-thread data through algebraic operations like join, meet, widen, and narrow, which are critical for abstract interpretation of concurrent programs. Use cases include tracking thread-specific state under lock constraints and combining analysis results across execution paths in shared-memory concurrency scenarios.",
      "description_length": 640,
      "index": 917,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.PthreadSignals.Spec.G",
      "library": "goblint.lib",
      "description": "This module defines a lattice structure for modeling abstract signal states in concurrent programs, with operations to compare, combine, and serialize values representing possible signaling behaviors of Pthread condition variables. It works with an abstract type `t` that captures must-received signal states through lattice-theoretic functions like join, meet, widen, and narrow, alongside top/bottom element checks. The design supports static analysis of concurrency by enabling precise tracking of signal propagation and synchronization points in multi-threaded code.",
      "description_length": 570,
      "index": 918,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Callstring.Spec.C",
      "library": "goblint.lib",
      "description": "Implements call string elements with operations for equality, hashing, comparison, and serialization. Works with abstract call string types extended through HConsed for context-sensitive analysis. Used to track and differentiate call contexts in k-CFA analyses with customizable element types.",
      "description_length": 293,
      "index": 919,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.StackTrace.Spec2.D",
      "library": "goblint.lib",
      "description": "This module provides lattice-based abstract domain operations (e.g., `join`, `meet`, `widen`) and stack manipulation primitives (`push`, `top`, `is_top`) for analyzing and transforming call stack states. It operates on two core types: `Goblint_lib.StackDomain.Dom2.t` for abstract domain values representing program states, and `Goblint_lib.StackTrace.Spec2.D.t` for structured stack trace representations. These operations enable use cases like merging divergent stack analysis results, tracking variable propagation through call stacks, and generating visualizable abstract state transitions.",
      "description_length": 594,
      "index": 920,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.WitnessUtil.Locator.FileH",
      "library": "goblint.lib",
      "description": "This module implements imperative hash tables for file-specific key-value storage, using raw strings as keys and supporting operations like insertion, deletion, lookup, and iteration. It enables advanced manipulation through mapping, filtering, merging, and conversion to sequences or lists, with a focus on handling optional values and custom transformations during witness generation. Designed for dynamic analysis workflows, it includes utilities for exception-safe access, infix notation, and label-based updates to manage file-related state and invariants efficiently.",
      "description_length": 573,
      "index": 921,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.MutexAnalysis.Spec.P",
      "library": "goblint.lib",
      "description": "This module provides lattice operations (join, meet, widen, narrow) and utilities for comparison, printing, and serialization, tailored for abstract interpretation in concurrent mutex analysis. It operates on a lattice type `t` derived from `D.t`, augmented with a distinguished top element to represent maximal states, and supports tracking mutex states through static analysis. It is specifically used in static analyzers like Goblint to model concurrency constraints, ensuring precise reasoning about lock acquisition and release patterns in multithreaded programs.",
      "description_length": 568,
      "index": 922,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ResultQuery.NH.Infix",
      "library": "goblint.lib",
      "description": "This module provides infix operators for querying and updating a constraint system solution. It works with typed query handles and keys to access or modify specific analysis results. Concrete use cases include retrieving variable values and setting analysis states during constraint solving.",
      "description_length": 291,
      "index": 923,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.CommonPriv.ConfCheck.RequireMutexPathSensOneMainInit",
      "library": "goblint.lib",
      "description": "This module enforces path-sensitive mutex initialization checks for single-main-thread scenarios. It tracks mutex states across function calls and thread operations to ensure proper initialization before use. Concrete use cases include verifying correctness of mutex handling in concurrent programs with one main thread and dynamically created threads.",
      "description_length": 352,
      "index": 924,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.StackTrace.Spec1.C",
      "library": "goblint.lib",
      "description": "This module provides lattice operations and serialization utilities for a type representing hierarchical call stack states, supporting comparisons, joins/meets, and widening/narrowing for abstract interpretation. It works with a type `t` aliased from `StackTrace.Spec1.D.t`, structured to model both bottom and top elements for domain-specific analysis. The functionality is tailored for static analysis tasks like call graph resolution or context-sensitive dataflow analysis, where precise stack trace abstractions are critical.",
      "description_length": 529,
      "index": 925,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MutexAnalysis.Spec.Arg",
      "library": "goblint.lib",
      "description": "This module implements operations to manipulate lockset states by adding or removing locks associated with memory addresses in concurrent analysis. It works with abstract domains combining must-locksets and access modes (`AddrRW.t`, `Addr.t`) to track which locks protect specific memory locations. Concrete use cases include updating lock dependencies during static analysis, enforcing correct lock acquisition order, and verifying memory access safety in multithreaded programs.",
      "description_length": 480,
      "index": 926,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.SpecLifters.DeadBranchLifter.V",
      "library": "goblint.lib",
      "description": "This module defines operations for managing global constraint variables, including equality checks, hashing, comparison, and string representation. It works with a concrete type `t` representing constraint variables, primarily used for tracking and analyzing variable states in static analysis. These variables are utilized to enforce global constraints during analysis, particularly in identifying dead branches and write-only variables.",
      "description_length": 438,
      "index": 927,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.BaseDomain.CPA.M",
      "library": "goblint.lib",
      "description": "This module provides a map-based abstract domain for static analysis, where program variables are associated with abstract values through operations like insertion, lookup, filtering, and merging. It supports lattice structures essential for fixed-point computations (e.g., widening, narrowing, joins) and includes utilities for comparing, transforming, and grouping variable-value mappings. Designed for constraint propagation and dataflow analysis, it enables tracking variable relationships and domain-specific transformations in program analysis workflows.",
      "description_length": 560,
      "index": 928,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.SpecLifters.WidenContextLifterSide.D",
      "library": "goblint.lib",
      "description": "This module combines two abstract domains into a product structure, offering lattice operations with configurable widening behavior per component and utilities for data serialization. It operates on pairs of abstract values from domains `S.D.t` and `M.t`, supporting operations like `widen`, `meet`, and `join` alongside JSON/XML encoding, difference visualization, and test-case generation. Its design enables context-sensitive abstract interpretation by allowing independent widening control for each domain component, while serialization features aid in analysis result persistence and debugging.",
      "description_length": 599,
      "index": 929,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Taint.Spec.P",
      "library": "goblint.lib",
      "description": "This module defines a path-representative type `t` with operations for equality, hashing, comparison, and pretty-printing. It supports interprocedural taint analysis by providing unique identifiers via `tag` and serialization through `to_yojson` and `printXml`. Concrete use cases include tracking taint propagation paths and generating analysis witnesses with context identification.",
      "description_length": 384,
      "index": 930,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.UseAfterFree.Spec.C",
      "library": "goblint.lib",
      "description": "This module defines operations for managing and comparing abstract values representing memory states in a use-after-free analysis. It supports data types like `t` for tracked memory locations, providing equality checks, hashing, string representations, and serialization for analysis results. Concrete use cases include tracking freed memory regions and validating safe memory accesses during static analysis.",
      "description_length": 409,
      "index": 931,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ObserverAnalysis.MakePathSpec.A",
      "library": "goblint.lib",
      "description": "This module defines a path-sensitive analysis domain with operations for comparing, hashing, and visualizing abstract states. It works with a custom type `t` representing analysis contexts, supporting operations like equality checks, pretty-printing, XML and JSON serialization, and generating unique identifiers. Concrete use cases include tracking execution paths in static analysis, identifying context-specific data races, and producing human-readable or structured output for debugging and witness generation.",
      "description_length": 514,
      "index": 932,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.LocksetAnalysis.MakeMay.P",
      "library": "goblint.lib",
      "description": "Implements a lockset analysis for tracking potential locks held during program execution. Works with abstract lock identifiers and provides operations to merge, compare, and pretty-print locksets. Used to detect concurrency issues like lock order violations or inconsistent locking patterns.",
      "description_length": 291,
      "index": 933,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Expsplit.Spec.D",
      "library": "goblint.lib",
      "description": "This module implements a lattice structure for an abstract domain type `t`, offering operations for comparison (`equal`, `compare`), ordering (`leq`, `join`, `meet`, `widen`, `narrow`), constants (`bot`, `top`), and pretty-printing to model path-sensitive expression value analysis. It is designed for static analysis tasks that track expression values across program paths, enabling reasoning about variable ranges, infeasible paths, and runtime error conditions through domain-specific abstractions.",
      "description_length": 501,
      "index": 934,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.RaceAnalysis.Spec.OneOffset",
      "library": "goblint.lib",
      "description": "This module defines operations for handling individual offset components in data race analysis, specifically supporting field and index offsets. It provides equality, comparison, and serialization functions for these offsets, along with conversions to other representations like strings and XML. Concrete use cases include tracking and comparing memory access patterns in C structures during race analysis.",
      "description_length": 406,
      "index": 935,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ThreadReturn.Spec.P",
      "library": "goblint.lib",
      "description": "This module defines and manipulates path-representative values for tracking thread return states in static analysis. It provides operations for equality checking, hashing, comparison, and pretty-printing these representatives, along with functions to convert them to JSON and XML formats. It is used to uniquely identify and manage abstract thread contexts during analysis of multi-threaded programs.",
      "description_length": 400,
      "index": 936,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Uninit.Spec.P",
      "library": "goblint.lib",
      "description": "This module supports abstract interpretation by modeling uninitialized variables using lattice operations (`join`, `meet`, `widen`, `narrow`) and top-element semantics (`top`, `is_top`) to represent partial correctness. It operates on a lattice type `t` that encodes abstract program states, tracking potential uninitialized variable states. The structure is specifically used in static analysis to detect uninitialized variable accesses and ensure safe variable usage in programs analyzed by Goblint.",
      "description_length": 501,
      "index": 937,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.RaceAnalysis.Spec.MemoSet",
      "library": "goblint.lib",
      "description": "This module provides set operations for managing collections of memory location identifiers (memos) that track root and offset pairs during data race analysis. It supports lattice-compliant set manipulations like union, intersection, and ordering checks, alongside utilities for serialization, iteration, and size measurement, all tailored for efficient trie-based traversal of hierarchical memory access patterns. These sets specifically enable race detection by grouping accesses to overlapping memory regions, handling both prefix-based (trie-structured) and type suffix-based distributions while avoiding redundant pairwise checks through precise memo intersection reporting.",
      "description_length": 679,
      "index": 938,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.ThreadJoins.Spec.D",
      "library": "goblint.lib",
      "description": "This module provides lattice operations (join, meet, widen, narrow) and comparison utilities (equal, compare, hash) for analyzing concurrent programs by combining must-thread IDs (MustTIDs) and clean exit states (CleanExit). It supports serialization to XML/JSON, difference reporting between analysis states, and arbitrary instance generation for testing, specifically enabling static analysis of thread interactions and termination behavior in abstract interpretation frameworks.",
      "description_length": 481,
      "index": 939,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ExpRelation.Spec.P",
      "library": "goblint.lib",
      "description": "This module defines a data type `t` representing path-representative constraint variables used in symbolic expression analysis. It provides operations for equality checking, hashing, comparison, and string/XML/JSON representation of these variables. It is used to track and compare symbolic constraints during the analysis of expression relationships.",
      "description_length": 351,
      "index": 940,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.PthreadSignals.Spec.C",
      "library": "goblint.lib",
      "description": "This module defines operations for handling and comparing condition variable signal specifications in the context of pthread analysis. It provides equality checks, hashing, comparison, and string representation for the type `t`, which represents condition variable signal states. These functions support precise tracking and differentiation of signal events during static analysis of concurrent programs.",
      "description_length": 404,
      "index": 941,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Callstring.Spec.G",
      "library": "goblint.lib",
      "description": "This module provides lattice operations (join, meet, widen, narrow) and extremal value checks for analyzing abstract call contexts, supporting operations like merging or comparing program state approximations. It works with HConsed tagged values of type `t` representing bounded k-CFA contexts, which encode limited-length call stack histories. These abstractions are used in static analysis to track and distinguish program execution paths for context-sensitive dataflow analysis.",
      "description_length": 481,
      "index": 942,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Region.Spec.Lvals",
      "library": "goblint.lib",
      "description": "This module provides lattice-based set operations on symbolic memory expressions (`Mval.Exp.t`), enabling precise manipulation of heap regions through union, intersection, difference, and subset checks. It supports static analysis for memory race detection by modeling disjoint heap regions as a set abstraction with lattice semantics, including widening/narrowing for convergence. The structure facilitates transformations like mapping, filtering, and partitioning, alongside utilities for testing and serialization, to analyze dynamic memory allocations in programs.",
      "description_length": 568,
      "index": 943,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Deadlock.Spec.P",
      "library": "goblint.lib",
      "description": "This module defines operations for a singleton unit type used in deadlock analysis, including equality checks, comparison, hashing, and pretty-printing. It provides functions to convert values to strings, XML, and Yojson formats, along with arbitrary value generation for testing. Concrete use cases include representing absence of data in deadlock-related computations and serving as a placeholder in generic structures requiring a unit value.",
      "description_length": 444,
      "index": 944,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.CompareConstraints.CompareNode.NH",
      "library": "goblint.lib",
      "description": "This module provides imperative and functional hash table operations for managing key-value mappings with `Node.t` keys, supporting creation, insertion, lookup, iteration, and transformations like mapping, filtering, and merging. It facilitates precise constraint manipulation in static analysis by enabling conversions to sequence-like structures (lists, enums) and integrating label-based constraint management for node-keyed data. The operations are optimized for scenarios requiring efficient tracking and comparison of constraints tied to analysis nodes.",
      "description_length": 559,
      "index": 945,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ExtractPthread.Spec.D",
      "library": "goblint.lib",
      "description": "This module provides lattice-theoretic operations for an abstract domain type `t`, including comparisons (`leq`, `is_top`), combinations (`join`, `meet`), and approximation strategies (`widen`, `narrow`), alongside utilities for serialization, pretty-printing, and testing. The type `t` represents elements in a static analysis framework, designed to model program properties with hierarchical relationships and extremal values (`bot`, `top`). It supports use cases in concurrency analysis, such as tracking thread interactions or synchronization states in Pthread programs through abstract interpretation.",
      "description_length": 606,
      "index": 946,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MayLocks.Spec.V",
      "library": "goblint.lib",
      "description": "This module defines operations for comparing, hashing, and serializing values of type `t`, which represent may-lock analysis arguments in the context of concurrency analysis. It provides concrete functionality for pretty-printing, XML output, and JSON serialization, along with supporting QCheck arbitrary value generation and equality checks. These operations enable precise tracking and debugging of potential lock dependencies and double-locking scenarios in concurrent programs.",
      "description_length": 482,
      "index": 947,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.YamlWitnessType.ViolationSequence.FunctionReturn",
      "library": "goblint.lib",
      "description": "This module defines operations for handling function return violations in a YAML witness format. It includes parsing from YAML, comparing violation instances, and specifying the violation type as a string. It works with structured data representing constraints and locations, used to validate function return behaviors in static analysis workflows.",
      "description_length": 348,
      "index": 948,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.StackTrace.Spec.C",
      "library": "goblint.lib",
      "description": "This module provides lattice operations (join, meet, widen, narrow) and structural utilities (equality, hashing, serialization) for abstract analysis values representing program states in a hierarchical context. It operates on context values (`C.t`) that model stack trace hierarchies, enabling comparisons and transformations within static analysis frameworks. These capabilities support use cases like determining context equivalence, analyzing control flow dependencies, and managing abstract state transitions during program analysis.",
      "description_length": 538,
      "index": 949,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.RaceAnalysis.Spec.G",
      "library": "goblint.lib",
      "description": "This module provides lattice operations (join, meet, widening, narrowing) over a four-level abstract domain (`Bot`, `Lifted1`, `Lifted2`, `Top`) to model hierarchical memory access patterns. It operates on trie-structured offsets (`OffsetTrie.t`) and memo sets (`MemoSet.t`) to enable precise race detection across type-based memory locations, handling both prefix-based (trie traversal) and suffix-based (type decomposition) access combinations. The design optimizes static analysis of concurrent programs by avoiding redundant race checks while ensuring accurate reporting at maximally specific memory locations where conflicting accesses intersect.",
      "description_length": 651,
      "index": 950,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ObserverAnalysis.MakeSpec.V",
      "library": "goblint.lib",
      "description": "This module defines operations for managing global constraint variables in a path-sensitive analysis, including equality checks, hashing, comparison, and serialization. It works with a concrete type `t` representing constraint variables, each assigned a unique ID for context identification. These variables are used to track and reason about program constraints across different execution paths in static analysis.",
      "description_length": 415,
      "index": 951,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Server.Locator.FileH",
      "library": "goblint.lib",
      "description": "This module provides a hash table structure mapping string-based keys (`Basetype.RawStrings.t`) to arbitrary values, supporting efficient insertion, lookup, deletion, and traversal operations. It includes advanced transformations like conditional updates, filtering, merging, and conversions to sequences/lists, tailored for managing file-associated data in Goblint's interactive server mode. The design emphasizes in-memory handling of structured file metadata with safe, labeled access patterns and functional manipulation via infix operators.",
      "description_length": 545,
      "index": 952,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ExtractPthread.Codegen.Action",
      "library": "goblint.lib",
      "description": "This module defines actions representing low-level concurrency operations like thread creation, mutex manipulation, and condition variable signaling. It works with thread identifiers, mutex IDs, and condition variable IDs to model Promela-like behavior from Pthread programs. It is used to generate string representations of these actions for Promela code output.",
      "description_length": 363,
      "index": 953,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.AccessAnalysis.Spec.C",
      "library": "goblint.lib",
      "description": "This module implements a lattice-based abstract domain for memory access analysis, featuring operations to combine and compare abstract states via join, meet, widen, and narrow, along with extremal values (top/bottom) for representing maximal or minimal precision. It works with lattice elements (`t`) that model abstract memory states, supporting transformations and structural analysis in static verification tasks like concurrency safety or memory error detection. Key use cases include tracking memory access patterns and merging state approximations during abstract interpretation.",
      "description_length": 586,
      "index": 954,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.CommonPriv.MutexGlobals.VGlobal",
      "library": "goblint.lib",
      "description": "This module represents global variables in a thread-modular analysis, providing identity comparison, hashing, and pretty-printing for `GoblintCil.varinfo` values. It supports operations for generating unique identifiers, serializing variables, and integrating with testing frameworks. Concrete use cases include tracking global variable accesses in concurrent programs and managing variable state across analysis contexts.",
      "description_length": 422,
      "index": 955,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.CommonPriv.ConfCheck.RequireThreadFlagPathSensInit",
      "library": "goblint.lib",
      "description": "This module enforces initialization of thread flags and path-sensitive analysis options during analysis setup. It ensures required configurations are set before starting the analysis, particularly for thread-modular and relation-based analyses. Use when initializing analysis states that depend on specific thread and path sensitivity settings.",
      "description_length": 344,
      "index": 956,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.SymbLocksDomain.Symbolic.S",
      "library": "goblint.lib",
      "description": "This module implements a lattice-based abstract domain for symbolic locksets, supporting operations to manipulate sets of CIL expressions (`CilType.Exp.t`) through standard set-theoretic functions (union, subset, filtering) and lattice operations (join, meet, widening). It represents locksets using a symbolic set structure with explicit `Lifted` (for concrete sets) and `Top` (for unknown/undefined) variants, enabling precise tracking of lock dependencies in static analysis. The domain is particularly suited for concurrency analysis, where symbolic expressions model lock acquisition/release patterns in program code.",
      "description_length": 622,
      "index": 957,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ExtractPthread.Tbls.CtxTbl",
      "library": "goblint.lib",
      "description": "Maps integer keys to integer values with thread context tracking during Pthread program analysis. Provides direct lookups via `get` and safe option-based access via `get_key`, along with snapshot capability through `to_list`. Used to track and extract thread-specific state such as identifiers, locks, or shared variable accesses during Promela translation.",
      "description_length": 357,
      "index": 958,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.WrapperFunctionAnalysis.SpecBase.C",
      "library": "goblint.lib",
      "description": "This structure provides lattice operations for symbolic analysis values, combining standard type manipulations with domain-specific static analysis functions like `join`, `widen`, and `narrow`. It operates on a type `C.t` (aliased from `D.t`), designed to represent abstract interpretation domains with precision-sensitive symbolic heap locations and thread identifiers. These operations enable precise tracking of dynamic memory allocations and thread creation in wrapper function analyses, particularly for contexts requiring node- and thread-aware symbolic state merging.",
      "description_length": 574,
      "index": 959,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.UseAfterFree.Spec.G",
      "library": "goblint.lib",
      "description": "This module provides lattice operations (join, meet, widen, narrow) and auxiliary utilities (comparison, serialization, context tagging) for a lattice type modeling abstract states in pointer analysis. Designed for static analysis frameworks, it enables tracking pointer validity and",
      "description_length": 283,
      "index": 960,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.LoopTermination.Spec.A",
      "library": "goblint.lib",
      "description": "This module defines and manipulates a data type `t` representing loop termination specifications. It provides operations for equality checking, hashing, comparison, and string representation, along with support for pretty printing, XML serialization, and JSON conversion. It is used to track and analyze loop termination behavior, including race detection and witness generation for termination violations.",
      "description_length": 406,
      "index": 961,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.LoopfreeCallstring.Spec.P",
      "library": "goblint.lib",
      "description": "This module defines path-representative values for global constraint variables, including operations for equality checking, hashing, comparison, and string representation. It works with the abstract type `t` representing path contexts, supporting serialization, pretty-printing, and integration with testing frameworks. Concrete use cases include managing and comparing distinct execution paths in static analysis to track and identify contexts uniquely.",
      "description_length": 454,
      "index": 962,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Base.MainFunctor.Dom",
      "library": "goblint.lib",
      "description": "This module provides lattice operations for abstract domains, including join, meet, widening, and comparison, alongside utilities for combining domain operations with variable sets and privilege handling. It operates on abstract domain values (`Dom.t`) and evaluated results (`RVEval.t`), supporting static analysis tasks like program analysis of non-relational value abstractions. Specific use cases include abstract interpretation for inferring variable ranges, constants, and approximating program behaviors through lifted map structures.",
      "description_length": 541,
      "index": 963,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.SymbLocks.Spec.A",
      "library": "goblint.lib",
      "description": "This module provides set-theoretic operations for symbolic and integer lock abstractions, including union, intersection, membership tests, and lattice manipulations over elements like `PLock.t` and `ILock.t`. It supports concurrency analysis through cardinality tracking, filtering, and race condition detection (`may_race`) while enabling serialization and pretty-printing for debugging. Designed for static analysis of device drivers, it facilitates precise lockset tracking to identify data races and inform concurrency-related decisions in symbolic execution contexts.",
      "description_length": 572,
      "index": 964,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ExtractPthread.Tbls.FunCallTbl",
      "library": "goblint.lib",
      "description": "Maintains a bidirectional mapping between function-call identifiers and unique integer keys for Pthread program analysis. It supports efficient lookups by function name and string identifier, or by integer key, and exports all entries as a list. Used during Promela extraction to track and resolve function call references in Pthread programs.",
      "description_length": 343,
      "index": 965,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.SpecLifters.OptEqual.V",
      "library": "goblint.lib",
      "description": "This module defines operations for managing global constraint variables, including equality checks, hashing, comparison, and string representation. It works with the abstract type `t` representing constraint variables, supporting serialization, pretty-printing, and integration with testing frameworks. Concrete use cases include tracking and comparing constraint variables in static analysis, generating unique identifiers for context-sensitive analysis, and supporting witness-based debugging.",
      "description_length": 495,
      "index": 966,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ThreadId.Spec.D",
      "library": "goblint.lib",
      "description": "This module provides lattice operations (join, meet, widening) and pretty-printing utilities for abstract interpretation of thread creation and propagation in concurrent programs. It operates on composite data structures combining thread identifiers, lifted thread states, and creation traces, enabling applications like QCheck-based test generation, convergence analysis in static analyzers, and visualization of thread state evolution differences. Specific use cases include modeling thread hierarchy dependencies and tracking asynchronous execution contexts in static analysis frameworks.",
      "description_length": 591,
      "index": 967,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Constants.Spec.C",
      "library": "goblint.lib",
      "description": "This module represents constant values for an intraprocedural analysis, providing operations to compare, hash, and display constants. It works with a concrete type `t` representing integer constants and supports serialization, pretty-printing, and generating arbitrary values for testing. It is used to track definite local variable values within a single function, without interprocedural propagation.",
      "description_length": 402,
      "index": 968,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Signs.Spec.P",
      "library": "goblint.lib",
      "description": "This module defines path-representative constraint variables for tracking unique contexts in a signs analysis. It provides operations for equality checking, hashing, comparison, and pretty-printing of path representatives, along with serialization to XML and JSON. These values are used to identify distinct analysis contexts during witness generation and constraint propagation in intraprocedural integer sign analysis.",
      "description_length": 420,
      "index": 969,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.WitnessUtil.Locator.ES",
      "library": "goblint.lib",
      "description": "This module provides ordered set operations for managing collections of elements with equality and ordering constraints, emphasizing efficient membership checks, union/intersection/difference calculations, and ordered partitioning via splitting and extremal element extraction. It works with sets built from ordered elements (`E.t`), supporting conversions to and from lists, arrays, and sequences while enabling structured traversal and transformation with exception-safe access patterns. Typical applications include static analysis tasks requiring precise set manipulation, such as tracking value ranges, dependency resolution, or invariant generation in program verification.",
      "description_length": 679,
      "index": 970,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MemLeak.Spec.A",
      "library": "goblint.lib",
      "description": "This module defines operations for comparing, hashing, and displaying memory leak specification instances, including equality checks, string representations, and XML/Yojson serialization. It works with the abstract type `t` representing memory leak contexts, providing identity checks via `equal`, `compare`, and `hash`, along with pretty-printing and serialization for external reporting. Concrete use cases include tracking and identifying unique memory leak contexts during analysis and generating structured output for visualization or logging.",
      "description_length": 548,
      "index": 971,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.AnalysisResult.Result.Labels",
      "library": "goblint.lib",
      "description": "This module implements a specialized hash table for managing analysis result labels, where keys are based on the `ResultNode` structure and values can be arbitrary types. It provides standard hash table operations like insertion, modification, iteration, filtering, and merging, all tailored to work with analysis result data. Concrete use cases include tracking variable bindings, function summaries, or control-flow information during static analysis.",
      "description_length": 453,
      "index": 972,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.LongjmpLifter.Lifter.P",
      "library": "goblint.lib",
      "description": "This module defines operations for managing path-representative values used in global constraint analysis. It provides equality, hashing, comparison, and serialization functions for type `t`, along with projection from analysis elements and generation of arbitrary values for testing. These operations support tracking and distinguishing execution paths in the analysis of `longjmp` and `setjmp` constructs.",
      "description_length": 407,
      "index": 973,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.WrapperFunctionAnalysis.ThreadCreateWrapper.G",
      "library": "goblint.lib",
      "description": "This module provides lattice-based symbolic thread identifiers for static analysis, supporting operations like meet, join, widen, and narrow to model thread creation contexts in concurrent programs. It works with an abstract type `t` representing symbolic thread IDs, enriched with comparison, display, and analysis utilities such as `tag` for unique identification and `pretty_diff` for debugging. These abstractions enable precise tracking of thread creation sources in static analysis, particularly when reasoning about thread-local state or synchronization dependencies.",
      "description_length": 574,
      "index": 974,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.WitnessUtil.Locator.LocM",
      "library": "goblint.lib",
      "description": "The module implements location-keyed map operations for structured manipulation of source code location data, supporting standard map primitives like insertion and lookup alongside location-specific transformations such as filtering ranges or extracting first-occurrence values. It works with ordered maps associating `CilType.Location.t` keys to arbitrary values, enabling ordered traversal, partitioning, and monadic compositions for handling optional data safely. These capabilities are particularly useful for static analysis tasks requiring precise location tracking, such as aggregating code metrics or generating contextualized analysis reports.",
      "description_length": 652,
      "index": 975,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.StackTrace.Spec2.A",
      "library": "goblint.lib",
      "description": "This module defines operations for handling unit values in call stack analyses, including comparisons, hashing, and pretty-printing. It supports data types related to stack traces and locations, providing concrete functions for equality checks, ordering, and serialization. Use cases include analyzing and comparing empty stack trace elements and generating string or XML representations for debugging and output.",
      "description_length": 413,
      "index": 976,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Control.AnalyzeCFG.CompareGlobSys",
      "library": "goblint.lib",
      "description": "This module compares local and global variable states across different analysis runs using imperative hash tables. It provides functions to compare values stored in `LH` and `GH` maps, ensuring consistency of abstract interpretation results. Concrete use cases include validating fixed-point convergence and detecting divergences in interprocedural dataflow analysis.",
      "description_length": 367,
      "index": 977,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Assert.Spec.G",
      "library": "goblint.lib",
      "description": "This module provides lattice operations and associated utilities for abstract interpretation, working with a type `t` that supports equality, comparison, hashing, and serialization to XML/JSON. It enables analysis of assert specifications by determining value relationships through operations like `join`, `meet`, and `widen`, while explaining inconsistencies in lattice orderings when comparisons fail. Useful in static analysis for modeling possible program states and their transformations under assert conditions.",
      "description_length": 517,
      "index": 978,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.CommonPriv.PerMutexTidCommon.LLock",
      "library": "goblint.lib",
      "description": "This module defines a polymorphic sum type for representing either a must-acquire lock or a global variable identifier. It provides operations for equality checking, comparison, hashing, and pretty-printing values of this type. The module is used to model lock and global variable tracking in thread-modular analysis, supporting serialization and type-safe construction through `mutex` and `global` functions.",
      "description_length": 409,
      "index": 979,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.RecursionTermLifter.Lifter.P",
      "library": "goblint.lib",
      "description": "This module defines a path-representative type `t` with operations for equality, hashing, comparison, and serialization. It works with context-sensitive function call paths, providing unique tagging and projection from analysis data via `of_elt`. Concrete use cases include tracking recursion in dynamic call graphs and managing global constraints during static analysis.",
      "description_length": 371,
      "index": 980,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.CondVars.Spec.C",
      "library": "goblint.lib",
      "description": "This module provides lattice operations (join, meet, widen, narrow, bot, top) and utilities for comparison, equality checks, and serialization. It operates on a type representing abstract values derived from symbolic variables, enabling analysis of logical equalities and constraints. These operations are specifically used in static analysis to model program behaviors and verify properties through abstract interpretation.",
      "description_length": 424,
      "index": 981,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.SpecLifters.LimitLifter.D",
      "library": "goblint.lib",
      "description": "This module provides lattice operations and domain utilities for abstract interpretation, including join, meet, widening, and top/bottom elements, operating on a domain type `D.t`. It supports static analysis by enforcing convergence through widening limits, with functions to compare, serialize, and generate arbitrary values for testing and differentiation. Use cases include fixed-point computations in static analyzers where controlled approximation ensures termination.",
      "description_length": 474,
      "index": 982,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.WideningTokenLifter.Lifter.D",
      "library": "goblint.lib",
      "description": "This module provides lattice operations (`leq`, `join`, `meet`, `widen`, `narrow`) and top-element handling (`top`, `is_top`) for abstract domains where elements (`D.t`) carry widening tokens to control when widening occurs. The token-aware operations delay widening until token sets stabilize, enabling precise analysis in scenarios like numerical or data-flow analysis where dynamic token management is critical. It also includes utilities for comparison, serialization, and testing of abstract elements.",
      "description_length": 506,
      "index": 983,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Region.Spec.A",
      "library": "goblint.lib",
      "description": "This module defines operations for analyzing and comparing optional heap region specifications derived from l-values. It provides equality, comparison, and hashing functions for these regions, along with utilities for pretty-printing, serialization, and race detection between region pairs. It is used to track and reason about disjoint memory regions during static analysis of concurrent programs.",
      "description_length": 398,
      "index": 984,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Constants.Spec.G",
      "library": "goblint.lib",
      "description": "This module provides lattice-theoretic operations for abstract values in a static analysis context, including comparisons, joins, meets, widening/narrowing, and extremal value checks. It operates on a type representing definite integer constants or their abstractions, structured as a lattice to model variable states. It is specifically used to track intraprocedural constant values of local variables in analyses that require precise but limited propagation of constant information.",
      "description_length": 484,
      "index": 985,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ThreadFlag.Spec.A",
      "library": "goblint.lib",
      "description": "This module defines operations for handling boolean thread flags, including equality checks, comparison, hashing, and pretty-printing. It supports data types like `bool` and integrates with testing frameworks via `QCheck.arbitrary`. Concrete use cases include tracking thread-local state and analyzing potential race conditions using `may_race`.",
      "description_length": 345,
      "index": 986,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Expsplit.Spec.A",
      "library": "goblint.lib",
      "description": "This module defines and manipulates abstract values for path-sensitive analysis based on expression splitting. It supports operations such as equality checking, hashing, comparison, and pretty-printing for a type `t` that represents abstract analysis states. It is used to track and reason about expression values in a context-sensitive manner, particularly in detecting and analyzing data races.",
      "description_length": 396,
      "index": 987,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ObserverAnalysis.MakePathSpec.D",
      "library": "goblint.lib",
      "description": "This domain implements lattice operations including join, meet, widen, and narrow for an abstract state type `t` representing path-sensitive analysis contexts, augmented with unique `tag` identifiers for precise state tracking. It provides serialization (XML/JSON), comparison, and standard lattice utilities like `top`/`is_top` and `bot`/`is_bot`, designed for static analysis workflows requiring context-sensitive data flow tracking through observer automata. The structure supports merging and partitioning of analysis states while maintaining distinct path identifiers, crucial for scalable path-sensitive analyses in abstract interpretation frameworks.",
      "description_length": 657,
      "index": 988,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.SpecLifters.LevelSliceLifter.P",
      "library": "goblint.lib",
      "description": "This module defines operations for managing and comparing path-representative values used in global constraint variables. It works with a concrete type `t` derived from constraint elements via the `of_elt` function, supporting equality checks, hashing, comparison, and various serialization methods including XML and JSON. These values are used to uniquely identify and track constraint contexts within analysis phases, particularly for debugging and witness generation.",
      "description_length": 470,
      "index": 989,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.CompareConstraints.CompareHashtbl.CompareD",
      "library": "goblint.lib",
      "description": "Implements a constrained comparison of two `Dom.t` values with customizable verbosity and naming, returning a structured comparison result paired with a documentation object. Works directly with `Dom.t` from the domain module and leverages `PrecCompare.Comparison.t` for result categorization. Useful for analyzing differences between abstract domain elements in a structured and documented way.",
      "description_length": 395,
      "index": 990,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.WrapperFunctionAnalysis.MallocWrapper.P",
      "library": "goblint.lib",
      "description": "This module defines a path-representative type `t` with operations for equality, hashing, comparison, and pretty-printing. It works with symbolic heap locations derived from node and thread IDs, providing unique identifiers for constraint variables. Used to track dynamic memory allocations with precision in static analysis, particularly for distinguishing different allocation sites across threads.",
      "description_length": 400,
      "index": 991,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Assert.Spec.C",
      "library": "goblint.lib",
      "description": "Implements equality, comparison, and serialization for a context type used in analyzing `assert` results. Works with a hashed and ordered context type that supports pretty-printing, XML output, and JSON conversion. Useful for tracking and comparing analysis contexts during program verification.",
      "description_length": 295,
      "index": 992,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.MutexTypeAnalysis.Spec.G",
      "library": "goblint.lib",
      "description": "This module defines a lattice structure for analyzing mutex types, offering operations like equality checks, comparison, hashing, and lattice functions (join, meet, widen, narrow) over an abstract type representing mutex states. It supports static analysis of concurrency properties by modeling mutex behavior through a lattice hierarchy, including top/bottom elements and approximation operators. The design enables use cases such as verifying thread-safety invariants and testing analysis robustness via QCheck arbitraries for automated validation.",
      "description_length": 550,
      "index": 993,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ExtractPthread.Spec.A",
      "library": "goblint.lib",
      "description": "This module defines operations for comparing, hashing, and displaying thread specification values, including checking potential race conditions between them and determining whether values should be printed in race output. It works with the abstract type `t` representing thread specifications, primarily used in the analysis of concurrent programs. Concrete use cases include identifying conflicting thread accesses and generating readable or machine-processable representations of thread states for debugging and verification.",
      "description_length": 527,
      "index": 994,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.WrapperFunctionAnalysis.ThreadCreateWrapper.C",
      "library": "goblint.lib",
      "description": "This module defines a concrete analysis for tracking thread creation in C programs by generating symbolic thread identifiers based on the node ID. It provides operations for comparing, hashing, and serializing thread identifiers, along with utilities for integration with analysis frameworks, such as pretty printing and XML output. It is used in static analysis to distinguish threads spawned at different program points for more precise concurrency analysis.",
      "description_length": 460,
      "index": 995,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.ThreadId.Spec.Created",
      "library": "goblint.lib",
      "description": "This module combines lattice operations (join, meet, widen, narrow) and comparison utilities (leq, compare) over pairs of thread state abstractions representing *current* and *callees* thread identifiers. It operates on tuples of `Current.t` and `Callees.t` types, which model hierarchical thread creation and synchronization dependencies using abstract identifiers from `TD.t`. The domain supports static concurrency analysis for tracking inter-thread relationships and is used in testing contexts with serialization (XML/JSON) and arbitrary value generation.",
      "description_length": 560,
      "index": 996,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.LocksetAnalysis.Make.C",
      "library": "goblint.lib",
      "description": "This module implements lattice operations for combining and comparing abstract lockset states in control flow analysis, including join/meet for merging divergent paths and widen/narrow for loop convergence. It operates on a lattice-based abstract domain (`C.t`) that represents locksets with hierarchical precision levels, supporting equality checks and serialization. This structure is used to track concurrent lock acquisition patterns across program paths, such as resolving conflicting lock states at branch points or collapsing iterative analyses in loops.",
      "description_length": 561,
      "index": 997,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.LoopTermination.Spec.D",
      "library": "goblint.lib",
      "description": "This module provides lattice-based abstract interpretation operations for termination analysis, including join/meet for combining abstract states, widen/narrow for convergence control, and equality/comparison primitives. It works with a bounded lattice type `t` representing termination states, featuring distinguished bottom (`bot`) and top elements to model program analysis approximations. The design supports static reasoning about loop and `goto` termination through algebraic manipulation and pretty-printing of abstract domains.",
      "description_length": 535,
      "index": 998,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Analyses.GVarG.CSet",
      "library": "goblint.lib",
      "description": "This module implements a lattice-structured set type `CSet.t` with elements of type `C.t`, supporting algebraic operations like join, meet, widen, and narrow alongside standard set manipulations such as union, intersection, and membership checks. It also includes utilities for serialization (XML/JSON), conversion between sets and lists, and element querying (e.g., cardinality, extremal elements). These capabilities are tailored for static analysis tasks involving constraint systems and dataflow analysis, where tracking and combining sets of program variables or values is critical.",
      "description_length": 587,
      "index": 999,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.SymbLocksDomain.ILock.Idx",
      "library": "goblint.lib",
      "description": "This module defines operations for handling symbolic lock indices, including equality checks, comparison, and conversion to strings or integers. It works with the `t` type, which represents lock indices as either `Unknown`, `Star`, or concrete values. These operations are used to track and compare mutex indices during static analysis of concurrent programs.",
      "description_length": 359,
      "index": 1000,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MutexEventsAnalysis.Spec.P",
      "library": "goblint.lib",
      "description": "This module defines and manipulates path-representative values for mutex events analysis. It provides equality, hashing, comparison, and serialization operations for type `t`, which represents abstract paths used in global constraint variables. These values are used to track and distinguish execution paths during analysis, particularly for identifying contexts in witness generation and constraint solving.",
      "description_length": 408,
      "index": 1001,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ObserverAnalysis.MakePathSpec.C",
      "library": "goblint.lib",
      "description": "This module defines a path specification for a context type `C.t` with operations for equality, hashing, comparison, and string representation. It supports serialization through XML and Yojson, along with generating arbitrary values for testing and re-lifting contexts. Concrete use cases include tracking unique context identifiers for witness generation and comparing or printing analysis contexts during path-sensitive analysis.",
      "description_length": 431,
      "index": 1002,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Base.MainFunctor.Invariant",
      "library": "goblint.lib",
      "description": "This module implements invariant-based value refinement for static analysis. It provides functions to apply invariants during analysis, refine compound values based on expressions or lvalues, and handle fallback cases when invariants cannot be fully resolved. These operations work with abstract values in the `ValueDomain.Compound.t` type and integrate with analysis contexts involving expressions, lvalues, and state updates. Use cases include tightening value approximations during conditional branching or loop iterations to improve precision in non-relational value analysis.",
      "description_length": 580,
      "index": 1003,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.ExtractPthread.Codegen.AdjacencyMatrix",
      "library": "goblint.lib",
      "description": "This module builds and manipulates adjacency matrices representing control flow transitions between source code locations in Pthread programs. It operates on nested hash tables where keys are source code locations and values represent edges with associated data. Use cases include tracking in-edges and out-edges for nodes during Promela code generation to model state transitions and concurrency behavior.",
      "description_length": 406,
      "index": 1004,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.WideningTokenLifter.Lifter.C",
      "library": "goblint.lib",
      "description": "This module provides operations for managing and comparing abstract elements enhanced with widening tokens, including equality checks, hashing, comparison, and string representation. It works with a type `t` that represents lifted abstract elements carrying widening token sets. Concrete use cases include delaying widening in abstract interpretation by tracking token changes across analysis states and ensuring correct fixpoint computation by controlling when elements are widened.",
      "description_length": 483,
      "index": 1005,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.BaseDomain.CPA.M0",
      "library": "goblint.lib",
      "description": "This module provides a map-like abstract domain for variable-to-value mappings with operations like `add`, `remove`, `find`, and higher-order transformations such as `map`, `filter`, and `merge`. It works with finite maps (dictionaries) where keys are program variables and values belong to an abstract domain (`VD`), while also supporting lattice operations (`join`, `meet`, `leq`) for combining and comparing analysis states. It is used in static analysis to track and merge variable states across program paths, enabling precise abstract interpretation through domain-specific lattice manipulations.",
      "description_length": 602,
      "index": 1006,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.PthreadSignals.Spec.A",
      "library": "goblint.lib",
      "description": "This module defines operations for managing and comparing abstract signal states used in Pthread condition variable analysis. It provides equality, hashing, comparison, and pretty-printing functions for the type `t`, which represents signal states in a concurrent program. These operations support precise tracking and differentiation of signal events during static analysis, particularly for detecting races and generating witness traces.",
      "description_length": 439,
      "index": 1007,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MayLocks.Arg.V",
      "library": "goblint.lib",
      "description": "This module defines a value type `t` with operations for equality, hashing, comparison, and pretty-printing. It supports serialization to XML and JSON, arbitrary value generation for testing, and provides a unique tag for context identification. It is used to represent and manipulate abstract values in may-lockset analysis, particularly for tracking lock states and write-only markers in concurrent program analysis.",
      "description_length": 418,
      "index": 1008,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.SpecLifters.DeadBranchLifter.P",
      "library": "goblint.lib",
      "description": "This module defines operations for managing path-representative values with support for equality, hashing, comparison, and serialization. It works with a concrete type `t` and integrates with D.t values via projection. Used to track and distinguish control-flow paths in static analysis, particularly for dead branch detection.",
      "description_length": 327,
      "index": 1009,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Preprocessor.FpathH.Exceptionless",
      "library": "goblint.lib",
      "description": "This module provides operations for safely modifying and querying a heterogeneous map structure where keys are file paths. It includes `find` for retrieving values associated with a key and `modify` for applying a function to a value at a key, returning an error result if the key is absent or modification fails. Concrete use cases include managing configuration settings or preprocessing rules tied to specific source files without raising exceptions on missing keys.",
      "description_length": 469,
      "index": 1010,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.WrapperFunctionAnalysis.ThreadCreateWrapper.D",
      "library": "goblint.lib",
      "description": "This module provides lattice operations and symbolic identifiers for analyzing thread creation in static analysis. It operates on an abstract type representing symbolic thread IDs, supporting comparisons, serialization, and lattice functions like join, meet, widen, and narrow. The inclusion of a maximal \"top\" element and associated checks facilitates abstract interpretation frameworks requiring precise modeling of thread states and creation sites based on node identifiers.",
      "description_length": 477,
      "index": 1011,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Server.Locator.ES",
      "library": "goblint.lib",
      "description": "This module provides ordered set operations for hierarchical data structures like trees or sequences, supporting efficient rank-based access, set algebra (union, intersection, difference), and ordered traversal. It works with structured collections of `Node.t` elements, enabling conversions to lists, arrays, and sequences while preserving order and hierarchy. Key use cases include managing dynamic, nested data in a JSON-RPC server context\u2014such as tracking hierarchical labels or handling ordered queries\u2014where precise structural manipulation and safe element retrieval are critical.",
      "description_length": 586,
      "index": 1012,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Assert.Spec.D",
      "library": "goblint.lib",
      "description": "This module provides lattice operations and domain-specific abstractions for static analysis, including equality checks, ordering relations, and serialization utilities. It operates on an abstract domain type representing analysis results, supporting key operations like `join`, `widen`, and `narrow` for fixpoint computations. These abstractions are used in Goblint's static analysis to model properties such as possible runtime values or assertion outcomes during program verification.",
      "description_length": 487,
      "index": 1013,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.ExtractPthread.Tbls.MutexMidTbl",
      "library": "goblint.lib",
      "description": "This module provides a bidirectional mapping between mutex names and unique identifiers during Pthread program analysis. It supports operations to retrieve an ID by name, find a name by ID, and list all pairs. It is used to track mutexes across Promela extraction, enabling accurate translation and analysis of concurrency primitives.",
      "description_length": 334,
      "index": 1014,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.LoopTermination.Spec.C",
      "library": "goblint.lib",
      "description": "This module defines and manipulates loop termination specifications for C code, focusing on equality, comparison, and serialization operations. It works with a concrete type `t` representing termination states, supporting precise tracking and differentiation of loop contexts using unique tags. It is used to analyze and verify termination of loops and `goto` statements in C programs during static analysis.",
      "description_length": 408,
      "index": 1015,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Taint.Spec.V",
      "library": "goblint.lib",
      "description": "This module defines operations for managing and comparing globally constrained taint variables, including equality, hashing, ordering, and pretty-printing. It works with a concrete abstract type `t` representing taint variables, each assigned a unique ID for identification. These operations support tracking and distinguishing taint sources and sinks in interprocedural analysis, particularly for generating witnesses or handling context-sensitive constraints.",
      "description_length": 461,
      "index": 1016,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.SpecLifters.LimitLifter.G",
      "library": "goblint.lib",
      "description": "This module supports lattice-based abstract interpretation by limiting the number of widenings per node during static analysis. It operates on a lattice structure of type `G.t`, providing core operations like join, meet, widen, and narrowing, along with top element manipulation and ordering comparisons. The design addresses use cases where controlling widening iterations is critical for convergence in fixpoint computations, such as program analysis frameworks requiring precise yet efficient abstract domains.",
      "description_length": 513,
      "index": 1017,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ExpRelation.Spec.V",
      "library": "goblint.lib",
      "description": "This module defines operations for comparing, hashing, and displaying global constraint variables used in symbolic expression analysis. It supports concrete use cases like checking equality between constraint variables, generating unique identifiers for context tracking, and serializing variables for output formats like XML and JSON. These capabilities enable precise syntactic analysis of expression relationships in static program analysis.",
      "description_length": 444,
      "index": 1018,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.ThreadId.Spec.C",
      "library": "goblint.lib",
      "description": "This module provides lattice-based abstractions for thread identifiers, supporting operations like comparison, hashing, and domain-specific joins/widens. It works with an abstract type `t` representing thread IDs, structured to handle undefined (\"top\") values and algebraic manipulations typical in static analysis. These abstractions are particularly useful for analyzing concurrent programs where thread identity tracking requires precise lattice semantics.",
      "description_length": 459,
      "index": 1019,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ResultQuery.NH.Labels",
      "library": "goblint.lib",
      "description": "This module implements a mutable, key-value store for labeling and manipulating constraint system solution data. It supports operations like adding, replacing, modifying, and querying entries using keys specific to the constraint system. Typical use cases include tracking variable assignments, propagating analysis results, and maintaining per-node state during constraint solving.",
      "description_length": 382,
      "index": 1020,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Constants.Spec.D",
      "library": "goblint.lib",
      "description": "This module provides lattice operations for abstract interpretation in static analysis, specifically tracking definite integer constant values of local variables. It defines a domain type with hierarchical structure (including top and bottom elements) to represent abstract values, supporting join, meet, widen, and narrowing operations to model program behavior intraprocedurally. The design enables reasoning about variable constancy without interprocedural state transfer, suitable for simple constant propagation optimizations.",
      "description_length": 531,
      "index": 1021,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.WideningTokenLifter.Lifter.G",
      "library": "goblint.lib",
      "description": "This module implements lattice-theoretic operations for abstract domain elements enhanced with widening tokens, supporting controlled convergence in fixed-point computations. It works with a lifted lattice type `G.t` that combines abstract values with dynamic token sets to delay widening until token stabilization. Key use cases include static program analysis frameworks requiring precise fixpoint iteration control, particularly in scenarios where gradual domain refinement is critical for scalability.",
      "description_length": 505,
      "index": 1022,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ObserverAnalysis.MakePathSpec.G",
      "library": "goblint.lib",
      "description": "This module defines lattice-theoretic operations (join, meet, widen, narrow) and comparison utilities for an abstract value type `G.t`, designed for path-sensitive static analysis. It supports analysis of program properties by providing structural and semantic operations to approximate value behavior in a lattice hierarchy. The type `G.t` serves as the domain for abstract interpretation, enabling precise tracking of runtime properties through its ordered structure and transformation functions.",
      "description_length": 498,
      "index": 1023,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ThreadReturn.Spec.V",
      "library": "goblint.lib",
      "description": "This module defines a specification for global constraint variables used in thread return analysis, where each variable represents a boolean abstraction of a thread's call stack position. It provides operations for equality checking, hashing, comparison, string representation, and serialization to XML and JSON formats. These variables are used to track and reason about thread return states in program analysis, particularly in constraint-based verification scenarios.",
      "description_length": 470,
      "index": 1024,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Deadlock.Spec.V",
      "library": "goblint.lib",
      "description": "This module defines operations for comparing, hashing, and serializing deadlock specification values, including equality checks, string representation, XML and JSON output, and QCheck arbitrary value generation. It works with the abstract type `t` representing deadlock analysis arguments. Concrete use cases include normalizing and persisting deadlock analysis results, generating test cases for analysis validation, and supporting pretty-printing for debugging.",
      "description_length": 463,
      "index": 1025,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Callstring.Spec.A",
      "library": "goblint.lib",
      "description": "Implements call string analysis with support for comparing, hashing, and serializing call string elements. It provides operations to check equality, generate string representations, and determine race conditions between call strings. This module is used to analyze program contexts in static analysis, particularly for tracking call chains up to a configurable length.",
      "description_length": 368,
      "index": 1026,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ArgTools.Make.Query",
      "library": "goblint.lib",
      "description": "This module provides functions to query local and global analysis results within a constraint system solution. It operates on data structures representing analysis graphs, constraint systems, and analysis domains, enabling precise queries at specific nodes or globally across the system. Concrete use cases include retrieving variable values at particular program points or obtaining aggregated results for the entire program.",
      "description_length": 426,
      "index": 1027,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.MayLocks.Spec.P",
      "library": "goblint.lib",
      "description": "This module defines operations for a unit type used in may lockset analysis, including equality, comparison, hashing, and pretty-printing. It provides concrete functions for handling abstract lock states in static analysis, specifically for tracking potential locking behaviors. Use cases include analyzing double locking scenarios and ensuring correct lock usage in concurrent code.",
      "description_length": 383,
      "index": 1028,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.IntDomainProperties.WithIkind.Ikind",
      "library": "goblint.lib",
      "description": "This module defines the integer kind (`ikind`) used to specify the size and signedness of integers in the analysis. It provides concrete type definitions and operations for working with integer types, such as `IInt`, `IShort`, `ILong`, and their signed/unsigned variants. It is used to determine the bitwidth and representation when evaluating or comparing integer domains.",
      "description_length": 373,
      "index": 1029,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.StackTrace.Spec1.A",
      "library": "goblint.lib",
      "description": "This module implements call stack analysis operations for tracking and comparing execution contexts using a unit type. It provides functions to check equality, compare, hash, and pretty-print stack trace information, along with utilities for serialization and random generation. Concrete use cases include analyzing control flow in program analysis and detecting potential race conditions during concurrency analysis.",
      "description_length": 417,
      "index": 1030,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.CommonPriv.PerMutexTidCommon.V",
      "library": "goblint.lib",
      "description": "This module defines operations for a variant type representing either a mutex-related value or a thread identifier. It includes functions for creating and converting between these variants, such as `mutex`, `global`, `thread`, and `relift`, along with standard comparison, hashing, and pretty-printing utilities. It is used to track thread-specific and mutex-related state in a thread-modular analysis.",
      "description_length": 402,
      "index": 1031,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ThreadEscape.Spec.C",
      "library": "goblint.lib",
      "description": "This module provides lattice operations such as join, meet, widen, and top element checks for a data type representing thread escape states, enabling analysis of variable flow in concurrent programs. It includes utilities for merging, comparing, and serializing these states, which are critical for static analysis of thread-local variables and escape detection in multi-threaded contexts.",
      "description_length": 389,
      "index": 1032,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ExtractPthread.Codegen.Writer",
      "library": "goblint.lib",
      "description": "Implements the generation of Promela code from intermediate representations by writing output files. Operates on strings representing file paths and Promela code content. Used during the Pthread-to-Promela translation process to produce model files for verification.",
      "description_length": 266,
      "index": 1033,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ActiveSetjmp.Spec.C",
      "library": "goblint.lib",
      "description": "This module provides lattice operations (join, meet, widen, narrow) and structural utilities (equality, hashing, serialization) for analyzing abstract program states represented by type `D.t`. It manipulates lattice elements to model constraints in static analysis, particularly for tracking active `setjmp` buffer lifetimes and control flow transitions. The lattice's top element operations enable detecting maximal abstractions, useful for summarizing unknown or unconstrained states in C program analysis.",
      "description_length": 508,
      "index": 1034,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.PoisonVariables.Spec.VS",
      "library": "goblint.lib",
      "description": "This module implements a lattice-based abstract domain for tracking sets of tainted variables, supporting standard lattice operations like `join`, `meet`, and `widen`, alongside set-like operations (union, intersection, membership checks) on CIL variable identifiers. It models variables modified between `setjmp` and `longjmp` calls, where values may become invalid due to non-local control flow, and provides utilities for static analysis of such taint propagation in C programs. The domain includes extremal states (`Top`, `Lifted`) and transformations like partitioning or size tracking to reason about variable liveness and overwriting.",
      "description_length": 641,
      "index": 1035,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.UseAfterFree.Spec.A",
      "library": "goblint.lib",
      "description": "This module defines operations for managing and comparing abstract values representing memory states in a use-after-free analysis. It supports concrete data types like `t` with functions for equality, hashing, comparison, and pretty-printing, along with utilities for serialization, generating arbitrary values, and determining race conditions. It is used to track and analyze potential use-after-free vulnerabilities by maintaining unique identifiers and context-sensitive comparisons.",
      "description_length": 486,
      "index": 1036,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.SpecLifters.LimitLifter.C",
      "library": "goblint.lib",
      "description": "This module implements a context wrapper that tracks and limits the number of widening operations per analysis node. It provides equality, comparison, and serialization functions for contexts, along with a relift function to reapply lifting logic. It is used to control precision during abstract interpretation by restricting widening iterations in static analysis.",
      "description_length": 365,
      "index": 1037,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.LoopTermination.Spec.G",
      "library": "goblint.lib",
      "description": "This module provides lattice operations (join, meet, widen, narrow, top, bot), equality checks, and serialization for an abstract context type that tracks loop and goto termination behavior using unique identifiers. It supports termination analysis by enabling comparison and combination of abstract states through standard lattice operations, specifically aiding control flow analysis in abstract interpretation to determine loop termination properties and handle goto statements.",
      "description_length": 481,
      "index": 1038,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.YamlWitnessType.InvariantSet.Invariant",
      "library": "goblint.lib",
      "description": "This module defines and manipulates invariant data structures in the context of YAML witness formats. It supports parsing and serializing invariant values to and from YAML, with specific handling for nested key-value pairs involving strings and floats. It is used to represent and work with structured invariant data in static analysis or verification workflows.",
      "description_length": 362,
      "index": 1039,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.StackTrace.SpecLoc.C",
      "library": "goblint.lib",
      "description": "This module provides lattice-based operations and symbolic value handling for abstract interpretation in static analysis. It works with an algebraic data type representing specification locations, including a distinguished \"top\" constructor for sentinel values, supporting operations like comparison, hashing, and hierarchical transformations (join/meet). These capabilities are used to model call stack relationships and symbolic state propagation in program analysis frameworks.",
      "description_length": 480,
      "index": 1040,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ObserverAnalysis.MakeSpec.P",
      "library": "goblint.lib",
      "description": "This module defines operations for managing path-representative values with a unique type `t`, including equality checks, hashing, comparison, and string representation. It supports data types like `D.t` through projection and provides serialization via XML and Yojson, along with QCheck arbitrary generation for testing. Concrete use cases include tracking unique path identifiers in constraint-based analysis and enabling precise context-sensitive comparisons in automated verification tasks.",
      "description_length": 494,
      "index": 1041,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ThreadFlag.Spec.C",
      "library": "goblint.lib",
      "description": "This module provides lattice operations (join, meet, widen, narrow) and associated utilities for a thread flag type `t` (an alias for `D.t`), designed to model thread creation and execution states in static analysis. It supports comparisons, hashing, XML/JSON serialization, and arbitrary value generation for testing, alongside handling bottom (`bot`, `is_bot`) and top (`top`, `is_top`) elements to represent undefined or maximal states. These features enable precise abstract interpretation of multi-threaded program behavior, such as tracking thread-local versus shared data access.",
      "description_length": 586,
      "index": 1042,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.CommonPriv.MutexGlobals.V",
      "library": "goblint.lib",
      "description": "This module defines a variant type `t` that represents three distinct categories of values related to mutexes and global variables in a thread-modular analysis. It provides constructors to wrap values of types `VMutex.t`, `VMutexInits.t`, and `VGlobal.t` into this variant, along with functions for equality checking, comparison, hashing, and conversion to various output formats like strings, XML, and JSON. Concrete use cases include tracking and distinguishing between mutex states, initialization points, and global variable accesses during static analysis of concurrent programs.",
      "description_length": 584,
      "index": 1043,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Region.Spec.C",
      "library": "goblint.lib",
      "description": "This module provides lattice operations for analyzing abstract heap regions, including equality checks, ordering relations (`leq`, `top`/`is_top`), and join/meet combinators for merging region states. It operates on abstract values of type `t` representing disjoint heap regions, which are used to model dynamically allocated memory in static concurrency analysis. These operations enable dataflow analyses to track potential memory races and synchronization conflicts by approximating region relationships during program execution.",
      "description_length": 532,
      "index": 1044,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.CompareConstraints.CompareHashtbl.Var",
      "library": "goblint.lib",
      "description": "This module provides hash table operations for `Var.t` values using structural equality and consistent hashing. It supports key comparisons with `equal` and `hash`, enabling efficient lookups and storage in hash tables. Use cases include tracking variable constraints in analysis passes where structural identity determines equivalence.",
      "description_length": 336,
      "index": 1045,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.SpecLifters.OptEqual.P",
      "library": "goblint.lib",
      "description": "This module defines operations for managing and comparing path-representative values with support for serialization, hashing, and pretty-printing. It works with a concrete type `t` that represents global constraint variables, providing functions like `equal`, `hash`, `compare`, and `show` for direct manipulation. Use cases include tracking and comparing constraint identifiers in analysis contexts, where each value has a unique tag for context-sensitive identification and can be projected from a domain element using `of_elt`.",
      "description_length": 530,
      "index": 1046,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.WitnessConstraints.PathSensitive3.G",
      "library": "goblint.lib",
      "description": "This module supports lattice operations like join, meet, widen, and narrow for combining and refining abstract program states, along with top/bottom checks and serialization utilities. It operates on a structured type representing path-sensitive constraints, designed for static analysis tasks like abstract interpretation and witness validation. These operations enable tracking and merging of state transitions in path-sensitive analysis workflows.",
      "description_length": 450,
      "index": 1047,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.LoopfreeCallstring.Spec.V",
      "library": "goblint.lib",
      "description": "This module defines operations for managing and comparing globally constrained variables in the context of loop-free callstring analysis. It provides equality checks, hashing, comparison, and string representations for these variables, supporting precise context identification and serialization. These functions are used to track and analyze recursive call patterns in static program analysis, particularly for distinguishing cyclic and acyclic call contexts.",
      "description_length": 460,
      "index": 1048,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ThreadAnalysis.Spec.C",
      "library": "goblint.lib",
      "description": "This module provides lattice operations and utility functions for abstract interpretation in thread analysis, working with a type `t` that represents thread-related data in a lattice structure. It supports structural equality checks, serialization, and lattice-theoretic operations like join, meet, and widening, while also enabling verification of top and bottom lattice elements. These capabilities are specifically applied to analyze thread uniqueness and track abstract thread states in static program analysis.",
      "description_length": 515,
      "index": 1049,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Base.MainFunctor.C",
      "library": "goblint.lib",
      "description": "The module provides lattice operations and data type utilities for an abstract domain, including equality checks, comparison, serialization, and standard lattice functions like join, meet, and widening. It operates on a type representing values in a lattice structure, primarily used in static analysis to model non-relational value properties.",
      "description_length": 344,
      "index": 1050,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ThreadJoins.Spec.C",
      "library": "goblint.lib",
      "description": "This module implements lattice operations and type class functionalities for analyzing thread join states in concurrent programs. It works with abstract lattice elements representing thread synchronization relationships, supporting operations like comparison, hashing, and serialization alongside domain-specific functions for join, meet, and approximation. These capabilities enable static analysis of thread interactions through relational thread-modular abstract interpretation, particularly for tracking local trace behaviors in clustered concurrency models.",
      "description_length": 562,
      "index": 1051,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Expsplit.Spec.C",
      "library": "goblint.lib",
      "description": "This module defines and manipulates abstract contexts for path-sensitive analysis based on expression values. It provides operations for equality checking, hashing, comparison, and pretty-printing of contexts, along with serialization to XML and JSON. It is used to track and distinguish execution paths in static analysis where different expression evaluations lead to different behaviors.",
      "description_length": 390,
      "index": 1052,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.TmpSpecial.Spec.Deps",
      "library": "goblint.lib",
      "description": "This module provides set operations (union, intersection, difference), lattice operations (join, meet, widening), and domain-specific utilities (top/bottom elements, pretty-printing) for managing lifted sets of CIL expressions. It works with a polymorphic variant type representing either a concrete set of expressions or an extremal `Top` value for over-approximation. These capabilities are used in static analysis to track dependencies between variables and function call arguments, enabling precise equivalence class management and change-sensitive invalidation of tracked relationships.",
      "description_length": 591,
      "index": 1053,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.ExtractPthread.Tbls.FunNameToTids",
      "library": "goblint.lib",
      "description": "Maps function names to sets of thread IDs in a thread analysis context. Provides operations to add, retrieve, and extend mappings between function names and thread IDs. Used to track which threads are associated with specific functions during static analysis of concurrent programs.",
      "description_length": 282,
      "index": 1054,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.LongjmpLifter.Lifter.V",
      "library": "goblint.lib",
      "description": "This module defines operations for managing global constraint variables, including equality checks, hashing, comparison, and string representation. It works with a concrete type `t` representing constraint variables, supporting serialization, pretty-printing, and generation of arbitrary values. Concrete use cases include tracking and comparing constraint variables during analysis lifting, particularly for handling `longjmp` and `setjmp` semantics with unique identification and context tagging.",
      "description_length": 498,
      "index": 1055,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.YamlWitnessType.ViolationSequence.FunctionEnter",
      "library": "goblint.lib",
      "description": "Handles parsing and comparison of function entry violation data in YAML witness files. Works with YAML values and converts them into structured violation records containing location and action fields. Used to represent and process function entry points in static analysis violation reports.",
      "description_length": 290,
      "index": 1056,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MemLeak.Spec.G",
      "library": "goblint.lib",
      "description": "This module defines a lattice structure with operations like `join`, `meet`, `widen`, and `narrow` on a type `t` representing abstract program states, including top and bottom elements for extremal values. It supports memory leak analysis through context-sensitive dataflow tracking via unique tags and provides utilities for comparison, serialization, and arbitrary value generation. The lattice model enables abstract interpretation to reason about memory state relationships and detect leaks in program executions.",
      "description_length": 517,
      "index": 1057,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Signs.Spec.V",
      "library": "goblint.lib",
      "description": "This module defines and manipulates constraint variables used in a sign analysis, providing operations for equality checking, hashing, comparison, and pretty printing. It works with a concrete abstract type `t` representing sign variables, supporting their unique identification, serialization, and generation for testing. Use cases include tracking variable signs during static analysis and generating witnesses for analysis results.",
      "description_length": 434,
      "index": 1058,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.PthreadSignals.Spec.D",
      "library": "goblint.lib",
      "description": "This module implements lattice operations (join, meet, widen, narrow) and abstract domain manipulations for tracking Pthread condition variable signal states in static analysis. It works with an abstract type `t` representing signal reception states, supporting equality checks, hashing, pretty-printing, and JSON serialization. The lattice structure enables modeling must-received signals in concurrent programs, particularly for analyzing synchronization guarantees in multi-threaded environments.",
      "description_length": 499,
      "index": 1059,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Assert.Spec.A",
      "library": "goblint.lib",
      "description": "This module defines operations for analyzing and comparing assertion specifications, including equality, hashing, and pretty-printing. It works with the abstract type `t` representing assertion contexts, supporting serialization, arbitrary generation for testing, and race condition checks. Concrete use cases include tracking unique assertion contexts during analysis, checking potential races between contexts, and generating human-readable or structured output for diagnostics.",
      "description_length": 480,
      "index": 1060,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.UnassumeAnalysis.Spec.D",
      "library": "goblint.lib",
      "description": "This module provides lattice and set-theoretic operations for manipulating collections of CIL expressions (`CilType.Exp.t`), supporting static analysis tasks such as tracking expressions requiring unassuming based on invariants. It implements a data structure combining lattice semantics (with `join`, `meet`, `widen`, and `narrow`) and finite set operations (union, intersection, filtering) over expressions, enabling precise state abstraction and transformation. Key applications include invariant propagation and constraint refinement in analyses consuming YAML witness annotations.",
      "description_length": 585,
      "index": 1061,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Queries.Hashtbl.Exceptionless",
      "library": "goblint.lib",
      "description": "This module provides operations for interacting with a thread-safe, exception-safe hash table structure, specifically supporting key-value lookups and modifications without raising exceptions. It works with hash tables that map keys to values of any type and returns results in a `result` type to handle potential errors explicitly. Concrete use cases include safely querying and updating shared state in concurrent analysis phases where key presence is uncertain.",
      "description_length": 464,
      "index": 1062,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.UnassumeAnalysis.Spec.Locator",
      "library": "goblint.lib",
      "description": "This module tracks unassume analysis events by associating CIL locations with sets of CFG nodes, supporting operations to add, query, and clear these associations. It uses a layered structure combining file-based key-value mappings, location-indexed metadata, and set operations for CFG node collections. It is used to emit unassume events during static analysis by resolving location-based annotations from YAML witnesses and mapping them to relevant program points.",
      "description_length": 467,
      "index": 1063,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.CommonPriv.PerMutexTidCommon.W",
      "library": "goblint.lib",
      "description": "This module provides lattice operations (join, meet, widen, narrow) and set-like manipulations (union, intersection, map, fold) for a structure representing collections of variables lifted with a Top element to denote all possible variables. It is designed for thread-mod",
      "description_length": 271,
      "index": 1064,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.WrapperFunctionAnalysis.ThreadCreateWrapper.A",
      "library": "goblint.lib",
      "description": "This module defines a data type `t` representing symbolic thread identifiers for thread creation, with operations to compare, hash, and display these identifiers. It includes functions for checking potential races between threads, generating unique IDs, and determining whether a thread identifier should be included in race output. These capabilities are used to track and analyze thread creation events with precision in concurrent program analysis.",
      "description_length": 451,
      "index": 1065,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ExtractPthread.Spec.C",
      "library": "goblint.lib",
      "description": "This module defines operations for manipulating and analyzing Pthread specification elements in C programs, including equality checks, hashing, comparison, and string representation. It works with the abstract type `t` representing Pthread specification constructs, enabling precise identification and serialization via unique tags and Yojson conversion. Concrete use cases include tracking thread contexts during Promela extraction and generating structured output for analysis witnesses.",
      "description_length": 489,
      "index": 1066,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.WrapperFunctionAnalysis.SpecBase.D",
      "library": "goblint.lib",
      "description": "This module provides a product domain combining node identifiers and unique call counters to enable symbolic tracking of heap locations and thread identifiers in wrapper function analyses. It supports lattice operations for approximation control, along with serialization and structured output capabilities. The domain is used to contextualize symbolic values based on both the program node and invocation count, enhancing precision in static analysis scenarios involving dynamic memory allocation and thread creation.",
      "description_length": 518,
      "index": 1067,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.CommonPriv.Locksets.MinLocksets",
      "library": "goblint.lib",
      "description": "This module provides lattice operations (join, meet, widen) and set-based manipulations (union, subset checks, element transformations) for managing minimal locksets. It operates on sets of `MustLockset.t` elements, enabling precise analysis of lock dependencies and concurrency control in programs. These functions are used to verify thread-modular safety properties, such as lock ordering constraints and disjoint lockset invariants, during static",
      "description_length": 449,
      "index": 1068,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.YamlWitnessType.ViolationSequence.Segment",
      "library": "goblint.lib",
      "description": "This module represents a segment of a violation sequence in a YAML witness format, specifically handling lists of waypoints. It provides functions to convert segments to and from YAML representations and compare segments for equality. This is used to serialize and deserialize violation paths for analysis tools that require structured error traces.",
      "description_length": 349,
      "index": 1069,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.ResultQuery.Make.FileCfg",
      "library": "goblint.lib",
      "description": "Implements file-level control flow graph (CFG) queries for analyzing program paths and skipped statements during constraint system solution analysis. Works with `MyCFG.cfg` structures and associated nodes, providing operations to inspect edges, node relationships, and skipped AST elements. Useful for identifying unreachable code, analyzing traversal paths, and examining CFG construction artifacts in CIL-based programs.",
      "description_length": 422,
      "index": 1070,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.YamlWitnessType.InvariantSet.InvariantType",
      "library": "goblint.lib",
      "description": "This module defines and manipulates invariant types in a YAML-based witness format, supporting operations to compare invariants, retrieve their type as strings, and parse them from YAML values. It works with a variant type `t` that represents either location or loop invariants, each defined in corresponding submodules. Concrete use cases include parsing and handling invariants from YAML configuration files for static analysis tools.",
      "description_length": 436,
      "index": 1071,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.RecursionTermLifter.Lifter.V",
      "library": "goblint.lib",
      "description": "This module defines globally unique constraint variables with operations for equality, hashing, comparison, and serialization. It works with a concrete variable type `t` that carries a unique integer tag and supports pretty-printing, XML output, and JSON conversion. These variables are used to represent and manage constraints in a context-sensitive analysis, particularly for tracking recursion and cycles in dynamic function call graphs.",
      "description_length": 440,
      "index": 1072,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.SymbLocks.Spec.C",
      "library": "goblint.lib",
      "description": "This module provides lattice operations and utilities for symbolic lockset analysis, including join/meet for combining abstract states and serialization/testing helpers. It operates on a symbolic lock state lattice (`t`) representing per-element locking patterns, where elements track field- or index-level lock dependencies. Designed for static race detection in concurrent device drivers, it enables abstract interpretation of synchronization behavior to verify correctness of fine-grained locking protocols.",
      "description_length": 510,
      "index": 1073,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Base.MainFunctor.G",
      "library": "goblint.lib",
      "description": "This module supports lattice operations (join, meet, leq, pretty) and manipulation of polymorphic sum types with lifted values, including widening/narrowing for approximation. It operates on a four-way lattice structure combining `Priv.G` and `VD` with `Bot`/`Top` bounds, alongside GADT-style variants representing abstracted program states or values. These capabilities enable abstract interpretation for value analysis, handling private and thread-specific data, and iterative approximation of program behavior.",
      "description_length": 514,
      "index": 1074,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.PrivPrecCompareUtil.Util.Key",
      "library": "goblint.lib",
      "description": "This module provides comparison, equality, and serialization operations for a type `t` derived from `Goblint_lib.PrivPrecCompareUtil.LV.t`. It includes functions for hashing, pretty-printing, XML and JSON output, and QCheck arbitraries, primarily supporting key-based identity and ordering. Concrete use cases include tracking and comparing abstract values in static analysis with structured output for debugging and external consumption.",
      "description_length": 438,
      "index": 1075,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.LocksetAnalysis.MakeMust.P",
      "library": "goblint.lib",
      "description": "This module implements a must-alias analysis for locksets, determining when locks must be held together. It operates on unit-typed values, leveraging equality, comparison, and pretty-printing functions to represent and analyze lock relationships. It is used to enforce precise lockset constraints in concurrent program analysis.",
      "description_length": 328,
      "index": 1076,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Expsplit.Spec.G",
      "library": "goblint.lib",
      "description": "This module provides lattice-like operations (join, meet, widen, narrow, top/bot elements) for an abstract domain used in static analysis, working with values of a type `t` that incorporates HConsed identifiers to track contextual witnesses. It supports context-sensitive analysis by enabling precise merging and comparison of abstract states while maintaining distinctions between different execution contexts. The operations facilitate fixed-point computations and value-set approximations in path-sensitive dataflow analyses.",
      "description_length": 528,
      "index": 1077,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.SpecLifters.HashconsLifter.D",
      "library": "goblint.lib",
      "description": "This module provides lattice operations such as joins, meets, widening, and narrowing for a hash-consed abstract domain, along with utilities for equality, hashing, comparison, and managing top elements. It operates on a canonicalized type optimized for static analysis contexts requiring efficient structural sharing and precise handling of hierarchical domain elements like top and bottom.",
      "description_length": 391,
      "index": 1078,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Constants.Spec.A",
      "library": "goblint.lib",
      "description": "Implements a specification for tracking definite integer constant values of local variables within a single procedure. It provides operations for equality checking, hashing, comparison, and pretty-printing of constant values, along with utilities for serialization, arbitrary value generation, and race detection. This module is used to represent and manipulate constant integer expressions during intraprocedural analysis, specifically for identifying and comparing known constant values in variable assignments.",
      "description_length": 513,
      "index": 1079,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.WitnessConstraints.PathSensitive3.C",
      "library": "goblint.lib",
      "description": "This module defines operations for managing path-sensitive analysis contexts, including equality checks, hashing, comparison, and serialization. It works with the abstract type `t` representing analysis states, supporting concrete use cases like tracking execution paths in static analysis and generating unique identifiers for context differentiation. Functions such as `tag`, `show`, and `to_yojson` enable integration with witness generation and external representation.",
      "description_length": 473,
      "index": 1080,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Callstring.Spec.D",
      "library": "goblint.lib",
      "description": "This module provides lattice-theoretic operations for abstract domains used in context-sensitive static analysis, including comparison, merging (join/meet), approximation (widen/narrow), and extremal value checks (bot/top). It operates on structured data types representing abstract values (`t` for call strings and `D.t` for domain elements) within a lattice framework, supporting k-limited call context tracking (k-CFA) and infinite call string analysis. These operations enable precise value merging, difference diagnostics, and witness generation in static analysis workflows requiring hierarchical context sensitivity.",
      "description_length": 623,
      "index": 1081,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.YamlWitnessType.InvariantSet.LoopInvariant",
      "library": "goblint.lib",
      "description": "This module defines and parses loop invariants in a YAML witness format, specifically handling their location, value, and formatting. It provides comparison operations and conversion from YAML values, ensuring structured representation of loop invariants. It is used to process and validate loop invariant data in static analysis witnesses.",
      "description_length": 340,
      "index": 1082,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.SpecLifters.LevelSliceLifter.V",
      "library": "goblint.lib",
      "description": "This module defines operations for managing and comparing globally constrained variables, including equality, hashing, comparison, and pretty-printing. It works with a concrete type `t` representing constraint variables, each assigned a unique ID for context identification. Useful for tracking and analyzing variable constraints within a program's analysis, particularly in debugging and witness generation scenarios.",
      "description_length": 418,
      "index": 1083,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.MemLeak.Spec.C",
      "library": "goblint.lib",
      "description": "This module defines operations for managing and comparing memory leak analysis contexts, including equality checks, hashing, comparison, and string representation. It works with the abstract type `t` representing memory leak contexts, supporting serialization, pretty-printing, and XML output. Concrete use cases include tracking unique context identifiers for witness generation and providing arbitrary values for testing analysis behavior.",
      "description_length": 441,
      "index": 1084,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.VarEq.Spec.D",
      "library": "goblint.lib",
      "description": "This module implements a set-like abstract domain for managing symbolic equality relationships between variables, supporting operations like union, intersection, difference, membership checks, and conversions to ordered lists. It operates on symbolic expressions (`B.t`) grouped into equivalence classes, enabling static analysis tasks such as merging equality constraints from divergent code paths or identifying redundant variable substitutions. The domain also integrates with lattice operations to refine variable relationships during fixed-point computations.",
      "description_length": 564,
      "index": 1085,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.StackTrace.Spec1.D",
      "library": "goblint.lib",
      "description": "This module provides lattice operations (join, meet, widen, narrow) and structural manipulations (equality, hashing, serialization) for abstract call stack states represented by type `t`, which models hierarchical stack traces with a \"top\" sentinel and variable-pushing behavior. It supports static analysis tasks like merging divergent execution paths, tracking stack evolution during function calls, and comparing abstract stack configurations for precision tuning in program analysis.",
      "description_length": 487,
      "index": 1086,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Deadlock.Spec.Arg",
      "library": "goblint.lib",
      "description": "This module tracks lock acquisition events and their relationships using address-based keys and node identifiers, integrating with static analysis contexts to detect potential deadlocks. It provides operations to add or remove locks, process access patterns, and analyze lock event pairs for circular dependencies. Concrete use cases include modeling concurrent lock usage during static analysis and identifying conflicting resource acquisitions in multithreaded programs.",
      "description_length": 472,
      "index": 1087,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.YamlWitnessType.ViolationSequence.WaypointType",
      "library": "goblint.lib",
      "description": "This module defines operations for handling waypoint types in a violation sequence, including parsing from YAML and comparing values. It works with a variant type representing different kinds of waypoints such as assumptions, targets, function entries and returns, and branching points. Concrete use cases include validating and processing witness traces in a static analysis tool.",
      "description_length": 381,
      "index": 1088,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.CompareConstraints.CompareGlobSys.PP",
      "library": "goblint.lib",
      "description": "This module supports operations for managing polymorphic key-value mappings where keys are analysis-specific nodes, enabling insertion, lookup, and transformation of values tied to program points or constraints. It provides utilities to convert between these mappings and sequential data structures while offering labeled access patterns and syntactic conveniences for constraint manipulation. The structure is particularly suited for tasks requiring precise association of analysis data with control-flow nodes or symbolic constraints in static analysis workflows.",
      "description_length": 565,
      "index": 1089,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MutexTypeAnalysis.Spec.A",
      "library": "goblint.lib",
      "description": "This module defines operations for analyzing and comparing mutex types in a concurrent program, including equality, hashing, comparison, and pretty-printing functions. It works with the abstract type `t` representing mutex types, such as `pthreadMutexType`, and supports operations like `may_race` to determine potential race conditions between mutexes. Concrete use cases include tracking mutex type states during static analysis and generating unique identifiers or XML/YoJSON representations for logging and witness generation.",
      "description_length": 530,
      "index": 1090,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ExtractPthread.Spec.G",
      "library": "goblint.lib",
      "description": "This module provides lattice operations for concurrency analysis, including equality checks, comparison, hashing, and JSON serialization, primarily working with an abstract type representing thread synchronization states. It supports static analysis of concurrent programs by enabling context identification and arbitrary value generation for synchronization domains. Specific use cases include determining lattice top elements to model unconstrained thread states and serializing analysis contexts for debugging or external processing.",
      "description_length": 536,
      "index": 1091,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.CompareConstraints.CompareGlobal.Compare",
      "library": "goblint.lib",
      "description": "This module compares global constraint states between two analyses, producing a structured result and a formatted document detailing differences. It operates on global constraint data types, using functions like `compare` to assess precision and structural changes. Concrete use cases include evaluating the impact of analysis configuration changes and tracking precision improvements across different analysis runs.",
      "description_length": 416,
      "index": 1092,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.WrapperFunctionAnalysis.MallocWrapper.V",
      "library": "goblint.lib",
      "description": "This module defines a data type `t` representing symbolic heap locations for dynamic memory allocations, with operations to compare, hash, display, and serialize these locations. It supports precise tracking of memory by associating each allocation with a unique identifier derived from node and thread IDs. Used in static analysis to distinguish between different memory allocations and model their behavior accurately.",
      "description_length": 420,
      "index": 1093,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.StackTrace.Spec2.C",
      "library": "goblint.lib",
      "description": "This module provides lattice operations (join, meet, widening) and structural manipulations for analyzing call stack traces in static program analysis. It works with an abstract type representing call stack states, supporting comparisons, serialization (XML/JSON), and detection of top-level call stacks. Key use cases include tracking hierarchical stack relationships, merging analysis results, and generating human-readable or machine-processable representations of stack traces with arbitrary value handling.",
      "description_length": 511,
      "index": 1094,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.ArgTools.Make.Node",
      "library": "goblint.lib",
      "description": "This module implements operations for manipulating and analyzing abstract reachability graph (ARG) nodes, including equality, comparison, hashing, and string conversion. It works with tuples of control flow graph nodes, specification contexts, and integer identifiers to represent nodes in the ARG. It supports checking node liveness, moving between nodes, and comparing nodes based on both structure and context.",
      "description_length": 413,
      "index": 1095,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.UseAfterFree.Spec.D",
      "library": "goblint.lib",
      "description": "The module provides lattice operations like `join`, `meet`, `widen`, and `narrow` to manipulate an abstract domain type representing memory states in static analysis. It includes functions to compare, hash, and serialize these states, supporting precise tracking of pointer validity and deallocation events. This structure is used to detect use-after-free vulnerabilities by modeling memory lifetime properties during program analysis.",
      "description_length": 435,
      "index": 1096,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.WrapperFunctionAnalysis.ThreadCreateWrapper.V",
      "library": "goblint.lib",
      "description": "This module defines a data type `t` representing symbolic thread identifiers for wrapper functions in a static analysis context. It provides operations for equality checking, hashing, comparison, string representation, and serialization to XML and JSON formats. These identifiers are used to track thread creation nodes uniquely, enabling precise analysis of concurrent programs.",
      "description_length": 379,
      "index": 1097,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.YamlWitness.ValidationResult.ChainParams",
      "library": "goblint.lib",
      "description": "Handles validation of chain parameters in YAML witness files, ensuring correct structure and values. Works with integers and strings to validate parameter counts and names. Used during witness validation to check that chain parameters match expected specifications.",
      "description_length": 265,
      "index": 1098,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.StackTrace.Spec2.P",
      "library": "goblint.lib",
      "description": "This module provides operations for handling unit-type values in the context of call stack analysis, including equality checks, comparison, hashing, and pretty-printing. It supports data types related to stack traces and locations, enabling concrete use cases like normalizing and comparing stack trace elements. Functions like `tag`, `relift`, and `of_elt` facilitate value conversion and tagging, while `pretty` and `show` support readable output formatting.",
      "description_length": 460,
      "index": 1099,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Assert.Spec.V",
      "library": "goblint.lib",
      "description": "This module defines and manipulates globally unique constraint variables used in assertion analysis. It supports equality checks, hashing, comparison, and string/XML/JSON representations for debugging and serialization. These variables are used to track and identify constraints in program analysis, particularly for handling `assert` statements and generating verification witnesses.",
      "description_length": 384,
      "index": 1100,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.SpecLifters.DeadCodeLifter.P",
      "library": "goblint.lib",
      "description": "This module defines operations for handling path-representative values with a focus on uniqueness and comparison. It works with the abstract type `t` representing path identifiers, supporting equality checks, hashing, ordering, and serialization. Concrete use cases include tracking unique paths in static analysis for dead code detection and providing stable identifiers for constraint variables in witness generation.",
      "description_length": 419,
      "index": 1101,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Control.AnalyzeCFG.PostSolverArg",
      "library": "goblint.lib",
      "description": "Implements post-analysis operations for control flow graphs after constraint solving. It processes results from `MCP.Path` solutions, applying pruning, verification, warning, and run-saving logic based on configuration flags. Works directly with control flow graph data structures and analysis results to perform final processing steps.",
      "description_length": 336,
      "index": 1102,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.SpecLifters.WidenContextLifterSide.P",
      "library": "goblint.lib",
      "description": "This module defines operations for a context type `t` derived from `S.P.t`, including equality, hashing, comparison, and pretty-printing functions. It supports serialization through XML and Yojson, along with generating arbitrary values for testing. It is used to lift and identify contexts with unique tags, primarily in static analysis scenarios involving context-sensitive data.",
      "description_length": 381,
      "index": 1103,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.StackDomain.Dom1.Var",
      "library": "goblint.lib",
      "description": "This module provides lattice operations (join, meet, widen, narrow) for a type representing lifted variable lattice values with explicit bottom and top elements, combining them with a base variable lattice (`VarLat.t`). It supports abstract interpretation in static analysis by enabling precise yet efficient combinations of variable states, ensuring convergence during fixed-point computations. The design is particularly suited for modeling program variable behaviors in scenarios like call stack analysis where hierarchical approximations are required.",
      "description_length": 555,
      "index": 1104,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Taint.Spec.D",
      "library": "goblint.lib",
      "description": "This module implements a lattice-based domain for taint analysis, featuring operations to combine (join, meet, widen, narrow), compare (leq, equal), and serialize abstract values representing data flow sensitivity. It operates on an abstract type structured as a lattice, where elements denote taint states, and includes standard domain primitives like top/bottom checks for static analysis. Designed for interprocedural information flow tracking, it enables reasoning about tainted data propagation across function boundaries in program analysis.",
      "description_length": 547,
      "index": 1105,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.LoopfreeCallstring.Spec.A",
      "library": "goblint.lib",
      "description": "This module defines operations for a loop-free callstring analysis, including equality, hashing, comparison, and serialization functions for its core type `t`. It supports detecting and managing call cycles in recursive function calls, uniquely identifying contexts via `tag` and determining race conditions between callstrings with `may_race`. Concrete use cases include improving precision in static analysis by reducing call string lengths and tracking context-sensitive program behaviors in the presence of recursion.",
      "description_length": 521,
      "index": 1106,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.LocksetAnalysis.MakeMust.C",
      "library": "goblint.lib",
      "description": "This module provides lattice operations (join, meet, widen, narrow) and extremal element checks (top, bot) for the `C.t` type, which models abstract lockset domains in static analysis. These operations enable merging and comparing lock ownership states across concurrent program paths to infer potential lock acquisitions and exclusions. They are specifically applied in concurrency analyses to detect data races and validate thread-safe resource access patterns.",
      "description_length": 463,
      "index": 1107,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.SpecLifters.OptEqual.G",
      "library": "goblint.lib",
      "description": "This module implements lattice operations such as equality checks, ordering, and join/meet combinations for an abstract type `G.t`, alongside utilities for difference visualization, hashing, and serialization to XML/Yojson. It is designed for static analysis scenarios where abstract domain values require precise comparison, combination, and structured representation.",
      "description_length": 369,
      "index": 1108,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.WitnessConstraints.PathSensitive3.P",
      "library": "goblint.lib",
      "description": "This module defines a path-representative type `t` with operations for equality, hashing, comparison, and pretty-printing. It supports conversion to XML and Yojson formats, along with generating arbitrary values for testing. The type is used to track unique path identifiers in constraint transformations, with `of_elt` projecting analysis data into path representatives.",
      "description_length": 371,
      "index": 1109,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.YamlWitness.Make.NH",
      "library": "goblint.lib",
      "description": "This module provides imperative hash table operations for managing mutable keyed collections with `Node.t` keys, supporting insertion, lookup, traversal, and in-place transformations like merging and filtering. It works with nested hash tables (`NH.t`) and facilitates structured data manipulation through conversions to sequences, lists, and hierarchical YAML representations. Designed for hierarchical data construction, it enables use cases like safe access to nested fields, label-based operations, and bulk processing of keyed collections during YAML witness generation.",
      "description_length": 575,
      "index": 1110,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.StackDomain.Dom1.VarLat",
      "library": "goblint.lib",
      "description": "This module implements lattice operations (leq, join, widen, meet, narrow, top, bot) and utility functions (comparison, hashing, JSON serialization, pretty-printing) for variables represented as `Basetype.Variables.t`, structured within a call stack domain. It includes predicates like `is_bot` to identify bottom elements and `pretty_diff` to visualize differences between lattice states (`VarLat.t`), enabling applications in static analysis for dataflow evaluation and debugging variable domains.",
      "description_length": 499,
      "index": 1111,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Signs.Spec.A",
      "library": "goblint.lib",
      "description": "This module defines a concrete analysis domain for tracking integer signs in an intraprocedural context. It provides operations for comparing, hashing, and displaying sign values, along with utilities for serialization, pretty-printing, and checking whether a sign value should be included in race output. The module supports arbitrary value generation for testing and includes functionality for determining potential race conditions between sign states.",
      "description_length": 454,
      "index": 1112,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.MayLocks.Arg.D",
      "library": "goblint.lib",
      "description": "This module provides lattice operations (join, meet, widening) and domain constructors (top, empty) for an abstract domain representing lock states in static analysis. It works with a lattice structure that supports differencing and arbitrary value generation, enabling precise tracking of potential lock sets and detection of concurrency issues like double locking. The operations are used to model and query lock acquisition patterns during program analysis.",
      "description_length": 460,
      "index": 1113,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MemLeak.Spec.P",
      "library": "goblint.lib",
      "description": "This module defines operations for managing path-representative values used in global constraint analysis. It supports equality checks, hashing, comparison, and string representation, along with serialization to XML and Yojson formats. These values are used to track and identify memory leak paths in the analysis.",
      "description_length": 314,
      "index": 1114,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.SpecLifters.PathSensitive2.P",
      "library": "goblint.lib",
      "description": "This module defines a path-representative type `t` with operations for equality, hashing, comparison, and pretty-printing. It supports concrete path-sensitive analysis by providing unique identifiers via `tag` and serialization through `to_yojson` and `printXml`. Use cases include tracking distinct execution paths in static analysis and enabling context-sensitive constraint propagation.",
      "description_length": 389,
      "index": 1115,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Control.AnalyzeCFG.Result",
      "library": "goblint.lib",
      "description": "This module provides specialized hash table operations for mapping control flow graph nodes to analysis results, supporting both functional and imperative transformations like filtering, merging, and indexed mapping. It works with hashtables keyed by CFG nodes to store and manipulate intermediate or final results of abstract interpretation tasks, such as tracking program states and solving constraints. These operations enable deterministic output generation, structured data handling during analysis, and integration with program state tracking workflows in static analysis pipelines.",
      "description_length": 588,
      "index": 1116,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Deadlock.Spec.LockEventPair",
      "library": "goblint.lib",
      "description": "This module represents pairs of lock events and provides operations to compare, hash, and serialize these pairs. It works with tuples of two `LockEvent.t` values, primarily for analyzing potential deadlocks by examining ordered lock acquisitions. Functions like `equal`, `compare`, and `show` enable precise equality checks, ordering, and human-readable output for lock event pairs in deadlock detection scenarios.",
      "description_length": 414,
      "index": 1117,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.WrapperFunctionAnalysis.MallocWrapper.A",
      "library": "goblint.lib",
      "description": "This module creates and manages symbolic heap locations for dynamic memory allocations based on node and thread IDs, providing unique identifiers and comparison operations. It supports precise tracking of memory allocations in static analysis by distinguishing between different allocation sites and threads. Use cases include detecting memory races and tracking heap-allocated data flow across threads.",
      "description_length": 403,
      "index": 1118,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.CommonPriv.PerMutexTidCommon.D",
      "library": "goblint.lib",
      "description": "This module implements a composite lattice structure for abstract interpretation in thread-modular static analysis, combining three component lattices (`W.t`, `LMust.t`, and `L.t`) to model states tied to synchronization primitives and thread identifiers. It provides standard lattice operations (join, meet, widen, etc.), comparison utilities, and serialization mechanisms, alongside testing tools for generating arbitrary domain values and visualizing discrepancies between lattice elements. The domain is specifically designed for verifying concurrent programs where precise tracking of mutex states and thread interactions is essential.",
      "description_length": 640,
      "index": 1119,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.CommonPriv.ConfCheck.RequireMutexActivatedInit",
      "library": "goblint.lib",
      "description": "This module enforces that mutexes are activated during initialization by validating configuration settings related to mutex handling. It operates on internal configuration structures that define analysis parameters for thread-modular value analysis. A concrete use case is ensuring that the analysis does not proceed unless mutex initialization constraints are explicitly enabled in the configuration.",
      "description_length": 401,
      "index": 1120,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MutexTypeAnalysis.Spec.V",
      "library": "goblint.lib",
      "description": "This module defines a data type `t` representing global constraint variables used to track unique identifiers and states in a mutex type analysis. It provides operations for equality checking, hashing, comparison, and string representation, along with functions to serialize to XML and JSON, generate arbitrary values for testing, and determine if a variable is write-only. These capabilities support precise constraint tracking and analysis of mutex usage patterns in concurrent programs.",
      "description_length": 489,
      "index": 1121,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.ExtractPthread.Spec.P",
      "library": "goblint.lib",
      "description": "This module defines a data type `t` representing global constraint variables used in the analysis of Pthread programs. It provides operations for equality checking, hashing, comparison, and string representation, as well as functions for XML and JSON serialization, generating unique tags, and creating arbitrary values for testing. It is used to manage and identify constraints during the Promela extraction process, particularly for tracking path representatives in the analysis.",
      "description_length": 481,
      "index": 1122,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.YamlWitness.Make.LH",
      "library": "goblint.lib",
      "description": "This module provides hash table manipulations for structured data handling, featuring dictionary operations, key-value transformations, merging, filtering, and conversion to sequences. It works with hash tables (`",
      "description_length": 213,
      "index": 1123,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.YamlWitnessType.ViolationSequence.Assumption",
      "library": "goblint.lib",
      "description": "This module represents assumptions in a violation sequence within a YAML witness format. It includes operations to parse assumptions from YAML values and compare them, working with structured data that includes location, action, and constraint fields. It is used to model and validate specific program analysis assumptions during witness processing.",
      "description_length": 349,
      "index": 1124,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.SpecLifters.OptEqual.C",
      "library": "goblint.lib",
      "description": "This module implements equality-based lifting operations for a context type `C.t`, providing functions to compare, hash, and serialize contexts. It supports data structures like lifted contexts in static analysis, enabling precise identification and comparison through unique tags and structural equality. Concrete use cases include tracking and equating analysis contexts during abstract interpretation or witness generation.",
      "description_length": 426,
      "index": 1125,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ExpRelation.Spec.D",
      "library": "goblint.lib",
      "description": "This module provides lattice operations such as join, meet, widen, and narrow on a domain modeling syntactic equality constraints between expressions, represented by a dedicated type for abstract relations. It enables analyses to determine must-equality between expressions through purely structural comparison, without tracking program state, and is particularly useful in static analysis for optimizing or verifying expression equivalences in a framework-integrated manner. The domain's top element signifies unconstrained relations, supporting standard abstract interpretation workflows.",
      "description_length": 590,
      "index": 1126,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ThreadFlag.Spec.P",
      "library": "goblint.lib",
      "description": "This module provides lattice-theoretic operations and state management primitives for abstract analysis of thread flags, including join/meet for merging states, widening/narrowing for convergence control, and top/bottom element checks. It works with an abstract type representing thread-local or shared state annotations, supporting static analysis of multi-threaded programs. These operations enable tracking variable ownership and synchronization properties in concurrent code analysis.",
      "description_length": 488,
      "index": 1127,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Control.AnalyzeCFG.SpecSys",
      "library": "goblint.lib",
      "description": "This module implements a system for solving equality constraints over program variables during abstract interpretation. It operates on control flow graphs by analyzing paths and computing dataflow solutions using variable mappings for both local (`LVar`) and global (`GVar`) variables. Used for static analysis optimizations like constant propagation and reaching definitions, it leverages `LHT` and `GHT` for efficient state management and constraint aggregation during fixpoint computation.",
      "description_length": 492,
      "index": 1128,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Control.AnalyzeCFG.LT",
      "library": "goblint.lib",
      "description": "This module implements a lattice structure for abstract interpretation in static analysis, supporting operations like join, meet, widen, and narrow for control flow graph (CFG) analysis. It works with sets of `RT.t` elements, providing set-like utilities such as membership checks, union/intersection, filtering, and extremal element retrieval. These capabilities are used to model and solve constraints over program paths, enabling analyses like data flow tracking and domain-specific property verification within Goblint's abstract interpretation framework.",
      "description_length": 559,
      "index": 1129,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Constants.Spec.V",
      "library": "goblint.lib",
      "description": "This module defines operations for managing global constraint variables used in an intraprocedural constants analysis. It supports equality checks, hashing, comparison, and pretty-printing of constraint variables, along with utilities for serialization, arbitrary value generation, and context identification via unique tags. These operations enable precise tracking and manipulation of variable constraints within a single function scope during static analysis.",
      "description_length": 462,
      "index": 1130,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.LocksetAnalysis.MakeMay.D",
      "library": "goblint.lib",
      "description": "This module provides lattice operations for an abstract domain representing sets of possible lock states, supporting operations like join, meet, widen, and narrowing to model concurrency-related program behavior. It works with a lattice structure inherited from `Arg.D.t`, where elements represent abstract lock environments with standard domain primitives (`top`, `is_top`, `empty`) and serialization utilities. The domain is specifically used in static analysis to track may-happen concurrency properties, such as potential lock acquisitions in multithreaded code.",
      "description_length": 566,
      "index": 1131,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Expsplit.Spec.P",
      "library": "goblint.lib",
      "description": "This module defines and manipulates path representatives used in path-sensitive analysis, providing equality, hashing, comparison, and serialization operations. It works with a concrete type `t` representing path identifiers, supporting operations like projection from another type `D.t`, extracting unique tags, and generating arbitrary values for testing. Use cases include tracking distinct execution paths during static analysis and enabling precise context-sensitive constraint handling.",
      "description_length": 492,
      "index": 1132,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ThreadReturn.Spec.D",
      "library": "goblint.lib",
      "description": "This module provides lattice operations (meet, join, widen, narrow) and analysis utilities (tagging, difference reporting) for abstract thread return states. It operates on a boolean-like lattice type `t` that models whether a thread resides at the topmost call frame during static analysis. These abstractions enable tracking and comparing thread execution contexts in concurrent program analyses, particularly for call stack-sensitive optimizations.",
      "description_length": 451,
      "index": 1133,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ThreadAnalysis.Spec.P",
      "library": "goblint.lib",
      "description": "This module implements lattice-based abstract analysis for thread states, offering operations like join, meet, widen, and narrow alongside extremal elements (top, bottom) to model hierarchical relationships. It operates on an abstract type `t` representing thread analysis values, providing equality checks, ordering relations, and pretty-printing utilities for debugging concurrent program states. Designed for static analysis of multithreaded systems, it enables tracking thread uniqueness and enforcing safety guarantees in concurrent execution contexts.",
      "description_length": 557,
      "index": 1134,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.WitnessUtil.InvariantExp.ES",
      "library": "goblint.lib",
      "description": "This module supports manipulation of sets of CIL expressions (`CilType.Exp.t`) with standard set operations (union, intersection, subset checks) and lattice-oriented combinators. It enables static analysis tasks like invariant representation, merging expression sets, and filtering or partitioning based on predicates, while providing utilities for conversion to lists, size tracking, and extraction of extremal elements. Key use cases include managing expression-based invariants during analysis and transforming sets for witness generation or subsumption checks.",
      "description_length": 564,
      "index": 1135,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Deadlock.Spec.D",
      "library": "goblint.lib",
      "description": "This module provides lattice operations such as join, meet, widen, and narrow, alongside comparison, display, and testing utilities for an abstract type `t` derived from `Arg.D.t`. Designed for deadlock analysis in concurrent systems, it supports domain-specific constructions like top, empty, and bottom elements to model states and constraints within a lattice-based abstract interpretation framework.",
      "description_length": 403,
      "index": 1136,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ExtractPthread.Tbls.SymTbl",
      "library": "goblint.lib",
      "description": "Maintains a bidirectional mapping between keys and values using a hash table, allowing efficient lookups in both directions. It supports operations to retrieve values by key, find keys by value, and convert the table to a list of key-value pairs. This structure is used to track symbol mappings during Pthread program analysis, enabling accurate resolution of identifiers and their associated data.",
      "description_length": 398,
      "index": 1137,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ThreadEscape.Spec.ThreadIdSet",
      "library": "goblint.lib",
      "description": "This module provides union, intersection, and difference operations alongside lattice-based analysis functions like join and meet for tracking sets of thread identifiers. It operates on a specialized set structure built over a lifted thread ID domain, enabling precise manipulation of thread escape states in concurrent programs. These capabilities are particularly useful for static analysis of thread-local variable access patterns and escape propagation in multi-threaded contexts.",
      "description_length": 484,
      "index": 1138,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MemOutOfBounds.Spec.C",
      "library": "goblint.lib",
      "description": "The module provides lattice operations and serialization capabilities for an abstract domain tracking memory bounds states. It works with a core type `t` (aliasing `D.t`) that represents memory access constraints, supporting comparisons, joins/meets, widening/narrowing, and conversion to XML/JSON formats. This functionality is used in static analysis to detect memory safety violations like buffer overflows by modeling valid/invalid memory regions during program execution.",
      "description_length": 476,
      "index": 1139,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ExtractPthread.Tbls.CondVarIdTbl",
      "library": "goblint.lib",
      "description": "This module implements a bidirectional mapping between condition variable names and unique identifiers, supporting efficient lookups and conversions. It provides operations to retrieve an ID by name, find a name by ID, and list all name-ID pairs. This is used to track and resolve condition variables during the analysis of Pthread programs, enabling accurate translation and representation of synchronization primitives in the extracted Promela model.",
      "description_length": 452,
      "index": 1140,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MutexAnalysis.Spec.A",
      "library": "goblint.lib",
      "description": "This module offers set-theoretic operations (union, subset checks, filtering) and lattice manipulations (widening, narrowing, join/meet) on lifted domains of `MustLockRW` values, which represent either concrete lock sets or abstract top elements. It supports static analysis tasks like race condition detection and lockset propagation by enabling precise manipulation of must-locksets, including membership queries, lock addition/removal, and conversion between abstract domains. The inclusion of comparison, serialization, and extremum extraction functions facilitates integration with analysis frameworks requiring fixpoint stabilization and dependency tracking.",
      "description_length": 664,
      "index": 1141,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ExtractPthread.Tbls.NodeTbl",
      "library": "goblint.lib",
      "description": "Maps integer keys to control flow graph nodes and provides direct lookups. Uses a hash table to store associations between node identifiers and `MyCFG.node` values. Enables retrieving nodes by ID, finding node IDs, and listing all mapped node entries for analysis during control flow processing.",
      "description_length": 295,
      "index": 1142,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MayLocks.Spec.C",
      "library": "goblint.lib",
      "description": "This module provides lattice-based operations for over-approximating lock behavior in concurrent programs, including join, meet, widen, and narrowing to model possible lock states. It works with an abstract type representing may-lock analysis states, enabling use cases like detecting double locking errors, and includes utilities for comparison, serialization, and human-readable output to support static analysis frameworks.",
      "description_length": 426,
      "index": 1143,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.SpecLifters.DeadBranchLifter.G",
      "library": "goblint.lib",
      "description": "This module provides lattice operations and extremal value management for a type `G.t`, supporting comparisons (`equal`, `compare`), lattice theory functions (`join`, `meet`, `widen`, `narrow`, `leq`), and top/bottom element handling (`top`, `bot`, `is_top`, `is_bot`). It works with abstract domains represented as `G.t`, enabling static analysis tasks like dead branch tracking by modeling hierarchical or conditional program states. The type also includes serialization and testing utilities (`show`, `arbitrary`) for integration with analysis frameworks.",
      "description_length": 558,
      "index": 1144,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Deadlock.Spec.MayLockEventPairs",
      "library": "goblint.lib",
      "description": "This module provides a set-based abstraction for managing potential lock event pairs in concurrent program analysis, focusing on deadlock detection. It operates on collections of `LockEventPair.t` elements with standard set operations like union, intersection, and membership checks, alongside lattice operations for fixed-point computations. Designed for deadlock analysis, it tracks possible lock acquisition orders to identify conflicting pairs that could lead to deadlocks during program execution.",
      "description_length": 502,
      "index": 1145,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ActiveSetjmp.Spec.P",
      "library": "goblint.lib",
      "description": "This module provides lattice operations (join, meet, widen, narrow), comparison functions (equal, compare), and conversion utilities (of_elt, to_yojson) for managing abstract analysis states tracking active `setjmp` buffers. It operates on an abstract type representing control flow sensitivity to non-local jumps, structured to model `setjmp`/`longjmp` semantics in C programs. The functionality supports static analysis of programs with dynamic control flow, particularly for detecting buffer invalidation and state transitions caused by exception-like behavior.",
      "description_length": 564,
      "index": 1146,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.SpecLifters.LimitLifter.P",
      "library": "goblint.lib",
      "description": "This module defines a path-representative type `t` with operations for equality, hashing, comparison, and pretty-printing. It supports global constraint variables by providing unique tagging, serialization, and arbitrary instance generation for testing. Concrete use cases include tracking context identifiers in analysis witnesses and projecting constraint data into path representatives.",
      "description_length": 389,
      "index": 1147,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Taint.Spec.A",
      "library": "goblint.lib",
      "description": "This module defines a taint analysis specification with operations for comparing, hashing, and displaying taint values. It works with a concrete taint type that includes identity tracking via unique tags and supports arbitrary value generation for testing. Use cases include implementing and validating interprocedural taint analyses with a focus on race detection and witness generation.",
      "description_length": 388,
      "index": 1148,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ObserverAnalysis.MakeSpec.C",
      "library": "goblint.lib",
      "description": "This module defines a specification for analysis contexts used in path-sensitive analysis with observer automata. It provides operations for equality checking, hashing, comparison, and string/XML/JSON representation of contexts, along with generating arbitrary values for testing and relifting existing contexts. The module works with a concrete type `t` representing analysis contexts, supporting concrete use cases like context-sensitive dataflow analysis and witness generation using unique identifiers.",
      "description_length": 506,
      "index": 1149,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.YamlWitness.Validator.Locator",
      "library": "goblint.lib",
      "description": "This module tracks and validates location-based mappings in YAML witness files by associating CIL locations with specification system variables. It supports precise lookups, additions, and resets of these associations, ensuring consistency during witness validation. Concrete use cases include validating function contract locations and matching specification variables to their corresponding source code positions.",
      "description_length": 415,
      "index": 1150,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.AccessAnalysis.Spec.V",
      "library": "goblint.lib",
      "description": "This module provides operations for representing and manipulating control flow graph (CFG) nodes using a variant type that captures CIL statements and functions, with support for comparison, pretty-printing, serialization, and metadata extraction (e.g., location tracking). It works with identifiers, values, and function definitions to enable analyses like variable access tracking, write-only variable detection, and CFG-based program analysis. Specific use cases include generating human-readable traces for debugging, serializing analysis results for external consumption, and integrating with static analysis tools to reason about memory accesses and data flow.",
      "description_length": 666,
      "index": 1151,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.RecursionTermLifter.Lifter.D",
      "library": "goblint.lib",
      "description": "The lattice structure supports abstract interpretation by enabling core operations such as join, meet, widen, and narrow over a domain `D.t`, which represents context-sensitive abstract elements in static analysis. This type includes top/bottom values and utilities for comparison, serialization, and arbitrary value generation, specifically targeting cycle detection and recursive call handling in dynamic function call graphs. Its design facilitates precise fixed-point computations in analyses tracking context-dependent behaviors.",
      "description_length": 534,
      "index": 1152,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.IntDomainProperties.IntegerSet.Base",
      "library": "goblint.lib",
      "description": "This module provides lattice operations (join, meet, widen), arithmetic and bitwise manipulations (addition, shifts, logical operations), and domain construction utilities (interval/congruence-based sets) for abstract integer domains. It operates on `Base.t` values representing integer sets via arbitrary-precision integers (`IntOps.BigIntOps.t`), supporting scalar values, ranges, and excluded-value sets. Specific use cases include abstract interpretation for static analysis tasks like overflow detection, bit-level invariant generation, and symbolic reasoning about integer expressions in program verification.",
      "description_length": 615,
      "index": 1153,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.SpecLifters.WidenContextLifterSide.M",
      "library": "goblint.lib",
      "description": "This module provides associative map operations and lattice-based abstractions for variable-indexed data domains, combining dictionary manipulation with analysis-specific utilities. It works with finite maps from variables to values of type `DD.t`, supporting bulk updates, merging, and lattice operations like widening, joining, and comparison. These features are particularly useful in static analysis contexts where efficient propagation of abstract values and convergence control via widening are required.",
      "description_length": 510,
      "index": 1154,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ThreadId.Spec.P",
      "library": "goblint.lib",
      "description": "This module defines lattice operations for thread identifiers, including equality, hashing, lattice operations (join, meet, widen, narrow), and string/XML/JSON representations. It works with thread ID values of type `t`, which represent abstract thread states in static analysis. These operations enable merging and comparing thread identifiers during abstract interpretation, supporting precise tracking of concurrency in program analysis.",
      "description_length": 440,
      "index": 1155,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.MutexEventsAnalysis.Spec.G",
      "library": "goblint.lib",
      "description": "This module provides lattice-based abstract interpretation operations for modeling mutex states, including join/meet for combining abstract values, widen/narrow for convergence control, and comparison/conversion utilities. It works with tagged abstract mutex states (`t`) that track context-specific locking behavior. These capabilities enable static analysis of concurrent programs to verify correct usage of mutexes and identify potential synchronization issues like deadlocks or race conditions.",
      "description_length": 498,
      "index": 1156,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.LoopfreeCallstring.Spec.D",
      "library": "goblint.lib",
      "description": "This module provides lattice-based abstract domain operations including join, meet, widen, narrow, and top/bottom element handling, along with serialization and comparison utilities. It operates on loop-free call strings that collapse recursive cycles into sets, enabling efficient static analysis of recursive programs by reducing analysis complexity while preserving precision in detecting call string cycles.",
      "description_length": 411,
      "index": 1157,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.WrapperFunctionAnalysis.SpecBase.NodeFlatLattice",
      "library": "goblint.lib",
      "description": "This module provides a flat lattice structure with `Bot`, `Lifted of Node.t`, and `Top` elements, supporting lattice operations like join, meet, widen, and narrow to model symbolic heap locations and thread identifiers in static analysis. It works with `Node.t` values derived from program nodes, where lifted states represent symbolic identifiers tied to allocation or thread creation sites. The lattice is used in abstract interpretation to track context-sensitive heap and thread states from wrapper functions like `mallocWrapper`, enabling precise analysis of dynamic memory and concurrency behaviors.",
      "description_length": 605,
      "index": 1158,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.PrivPrecCompareUtil.Util.RH",
      "library": "goblint.lib",
      "description": "This module provides hash table operations, transformations, and sequence conversions for a parameterized map structure with keys of type `RH.key` and polymorphic values. It supports both in-place and functional manipulation of key-value pairs, including multi-value entries, conditional updates, and statistical extraction. Designed for static analysis workflows, it facilitates precision tracking in privilege comparison scenarios through safe value modification and labeled operations.",
      "description_length": 488,
      "index": 1159,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.TmpSpecial.Spec.D",
      "library": "goblint.lib",
      "description": "This module provides map-based dependency tracking and lattice operations for analyzing math library function call relationships in static analysis. It works with dictionaries mapping expressions (`Mval.Exp.t`) to dependency metadata (`MLDeps.t`), supporting bulk updates, equivalence management, and lattice transformations like join/widen. Specific use cases include tracking variable equivalences tied to function call arguments and maintaining abstract domain states during Goblint's analysis of mathematical computations.",
      "description_length": 526,
      "index": 1160,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.LongjmpLifter.Lifter.D",
      "library": "goblint.lib",
      "description": "This module implements lattice operations for abstract interpretation in static analysis, focusing on handling C's `longjmp` and `setjmp` constructs. It manipulates abstract states represented as tagged values (`t`), supporting comparisons, extremal value checks (`top`, `bot`), and lattice transformations (`join`, `meet`, `widen`). These operations enable tracking and merging of control-flow contexts during analysis to model non-local jumps accurately.",
      "description_length": 456,
      "index": 1161,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.TmpSpecial.Spec.MLDeps",
      "library": "goblint.lib",
      "description": "This module provides lattice operations for combining and comparing analysis states that track math library call results alongside their dependencies, using a composite data structure of two interrelated sets. It enables static analysis tasks like dependency tracking and equivalence maintenance by offering meet/join operations for merging states and serialization utilities for persistence or testing. The design supports scenarios where precise propagation of mathematical function call relationships is required, such as optimizing compiler analyses that eliminate redundant computations or verify numerical stability.",
      "description_length": 622,
      "index": 1162,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.PthreadSignals.Spec.V",
      "library": "goblint.lib",
      "description": "This module defines and manipulates global constraint variables used in the analysis of Pthread condition variable signaling. It provides operations for equality checking, hashing, comparison, and pretty-printing these variables, along with utilities for serialization, generating arbitrary instances, and determining variable properties like write-only status. These variables are used to track and constrain signal and wait operations across different analysis contexts.",
      "description_length": 472,
      "index": 1163,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Signs.Spec.D",
      "library": "goblint.lib",
      "description": "The module provides lattice operations (join, meet, widen, narrow), equality checks, hashing, and serialization utilities for an abstract sign type that models integer sign information in static analysis. It operates on a lattice structure where elements represent possible sign states (e.g., positive, negative, zero) to enable intraprocedural reasoning about variable values. This supports use cases like detecting division-by-zero errors, optimizing sign-dependent code paths, and verifying arithmetic safety in programs.",
      "description_length": 524,
      "index": 1164,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.PrecCompare.MakeDump.CompareDump",
      "library": "goblint.lib",
      "description": "This module compares two domain instances for precision by generating a structured dump of their differences. It works with abstract domain states represented as `Util.Dom.t Util.RH.t` values, producing a precision comparison result and a formatted document highlighting discrepancies. It is used to analyze and debug static analysis states, such as during precision tuning or regression testing.",
      "description_length": 396,
      "index": 1165,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Base.MainFunctor.VarMap",
      "library": "goblint.lib",
      "description": "This module offers operations for polymorphic maps keyed by `CilType.Varinfo.t` (CIL variable metadata), supporting standard map manipulations (insertion, lookup, removal) alongside specialized variants like merging, partitioning, and filtered enumeration. It works with `VarMap.t` structures that associate program variables with abstract analysis states or value lists, enabling functional and imperative-style transformations during static analysis. Specific use cases include tracking variable-specific abstract domains, combining analysis results across variable scopes, and implementing exception-safe lookups with customizable pretty-printing for debugging.",
      "description_length": 664,
      "index": 1166,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.StackTrace.Spec1.V",
      "library": "goblint.lib",
      "description": "This module implements a singleton-type specification for call stack analysis, providing identity operations, comparisons, and serialization for an empty stack trace type. It supports concrete use cases like tracking unique identifiers for context-sensitive analysis and generating XML or JSON representations of stack traces. The module is used to model empty stack states in analyses requiring discriminable, hashable, and printable values.",
      "description_length": 442,
      "index": 1167,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.SpecLifters.DeadBranchLifter.C",
      "library": "goblint.lib",
      "description": "This module defines operations for lifting and comparing abstract contexts with support for serialization, pretty-printing, and generating arbitrary values. It works with a concrete type `C.t` that represents analysis contexts, including functions for equality checking, hashing, ordering, and conversion to various output formats. It is used in static analysis to manage and manipulate abstract contexts during program analysis, particularly in scenarios requiring context-sensitive analysis and witness generation.",
      "description_length": 516,
      "index": 1168,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.MayLocks.Spec.G",
      "library": "goblint.lib",
      "description": "This module provides lattice operations (join, meet, widen, narrow) and utility functions (equality, hashing, JSON serialization) for analyzing sets of potential locks, represented as an abstract type. It supports abstract interpretation to track possible lock states in concurrent programs, enabling static analysis of lock usage patterns and detection of concurrency issues like double locking. The lattice structure includes bottom and top elements to model precise approximations of lockset behaviors during program execution.",
      "description_length": 530,
      "index": 1169,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.WrapperFunctionAnalysis.MallocWrapper.D",
      "library": "goblint.lib",
      "description": "This module provides lattice-based abstract domain operations for symbolic heap location identifiers, which are parameterized by node and thread IDs. It supports abstract interpretation by defining operations like join, meet, widen, and narrow to model dynamic memory allocation states in static analysis. The domain manipulations enable tracking of symbolic heap allocations from wrapper functions, aiding in precise analysis of programs with dynamic memory management.",
      "description_length": 470,
      "index": 1170,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.RaceAnalysis.Spec.V",
      "library": "goblint.lib",
      "description": "This module defines a polymorphic variant type `t` that represents either a memory root (`Left`) or a variable info (`Right`), primarily used to distinguish between different kinds of memory entities during race analysis. It provides comparison, hashing, and serialization functions tailored to this type, enabling efficient memoization and precise race detection across memory locations. These operations support concrete use cases such as tracking and comparing memory accesses in C code during static analysis to detect data races.",
      "description_length": 534,
      "index": 1171,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.CompareConstraints.CompareEqSys.Compare",
      "library": "goblint.lib",
      "description": "This module compares constraint systems by evaluating the equality of variable-to-domain mappings, using structural and semantic checks. It works with `Sys.Dom.t VH.t` structures, which represent variable-to-domain assignments in a constraint system. Concrete use cases include verifying consistency between different constraint system states during static analysis and generating detailed comparison reports for debugging or validation.",
      "description_length": 437,
      "index": 1172,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ObserverAnalysis.MakeSpec.G",
      "library": "goblint.lib",
      "description": "This module provides lattice-theoretic operations for manipulating abstract state representations in path-sensitive analysis, including join, meet, widen, and narrow for fixpoint computation, alongside equality checks and serialization. It operates on the abstract type `G.t`, which models lattice elements representing program states with path-sensitive constraints. These operations enable static analysis tasks like differencing explanations and convergence detection in abstract interpretation frameworks.",
      "description_length": 509,
      "index": 1173,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.PrecCompare.MakeHashtbl.CompareD",
      "library": "goblint.lib",
      "description": "This module implements a hash table for storing and comparing precision data using a custom equality and ordering function derived from the `PrecCompare` module. It works with data structures that conform to the `D` module type, enabling efficient lookups and comparisons of precision values. Concrete use cases include caching results of precision comparisons and managing equivalence classes of precision-related data during static analysis.",
      "description_length": 443,
      "index": 1174,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.LoopTermination.Spec.P",
      "library": "goblint.lib",
      "description": "This module defines operations for managing and comparing path-representative values used in termination analysis, including equality checks, hashing, comparison, and string representation. It works with a concrete type `t` representing paths, supporting serialization to JSON and XML, and providing a unique identifier for each value. These functions enable precise tracking and differentiation of loop paths during termination analysis.",
      "description_length": 438,
      "index": 1175,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.MallocFresh.Spec.C",
      "library": "goblint.lib",
      "description": "This module supports lattice-based abstract interpretation for analyzing unescaped heap allocations by offering operations like `leq`, `join`, `meet`, `widen`, and `narrow` to model value relationships, alongside equality checks (`equal`, `compare`) and normalization (`hash`, `tag`). It works with an abstract type `t` representing thread-local heap locations derived from `mallocFresh`, enabling static analysis of memory that remains confined to individual threads. The module is particularly useful in concurrency analysis to track non-escaping allocations and in abstract interpretation frameworks for approximating program behavior while ensuring soundness.",
      "description_length": 663,
      "index": 1176,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.UseAfterFree.Spec.V",
      "library": "goblint.lib",
      "description": "This module defines and manipulates globally unique constraint variables used in tracking potential use-after-free vulnerabilities. It supports operations such as equality checking, hashing, comparison, and pretty-printing, along with serialization to XML and JSON formats. These variables are used to represent abstract memory locations in the analysis, enabling precise tracking of allocation and deallocation events across program paths.",
      "description_length": 440,
      "index": 1177,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Preprocessor.FpathH.Infix",
      "library": "goblint.lib",
      "description": "This module provides infix operators for accessing and modifying values in a hash table that maps file paths to arbitrary data. The `-->` operator retrieves a value using a key, while `<--` updates or inserts a key-value pair. These operations are useful for efficiently managing file path\u2013based mappings, such as tracking preprocessor definitions or file-specific analysis data during C code processing.",
      "description_length": 404,
      "index": 1178,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ThreadReturn.Spec.A",
      "library": "goblint.lib",
      "description": "This module defines and manipulates an abstract type `t` representing thread return states in a concurrent analysis. It provides operations for equality checking, hashing, comparison, and pretty-printing, along with utilities for serialization, generating arbitrary values, and determining race conditions between thread states. Concrete use cases include tracking whether a thread is at the top of its call stack for precise race detection and witness generation.",
      "description_length": 464,
      "index": 1179,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MutexEventsAnalysis.Spec.C",
      "library": "goblint.lib",
      "description": "This module defines a data type `t` representing mutex events with operations for equality checking, hashing, comparison, and string representation. It supports serialization through XML and Yojson, and provides a unique ID tagging mechanism for context identification. Used to track and analyze mutex lock and unlock events in concurrent programs.",
      "description_length": 348,
      "index": 1180,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.ObserverAnalysis.MakePathSpec.P",
      "library": "goblint.lib",
      "description": "This module defines a path-representative type `t` with operations for equality, hashing, comparison, and pretty-printing. It supports conversion to JSON and XML, arbitrary value generation for testing, and provides a unique identifier for context tracking. It is used to represent and manipulate paths in a path-sensitive analysis, specifically for tracking constraints and witnesses.",
      "description_length": 385,
      "index": 1181,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.LocksetAnalysis.MakeMay.A",
      "library": "goblint.lib",
      "description": "This module implements a may-lockset analysis for concurrency-related operations, determining potential race conditions between execution states. It works with abstract lock states and thread identifiers to track possible synchronization conflicts during program analysis. Concrete use cases include detecting concurrent memory accesses that may lead to data races in multithreaded programs.",
      "description_length": 391,
      "index": 1182,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Base.MainFunctor.VarH",
      "library": "goblint.lib",
      "description": "This module provides variable-indexed hash tables (`VarH.t`) mapping CIL variable identifiers (`VarH.key`) to arbitrary values, supporting both imperative and functional manipulation. It offers operations for insertion, lookup, iteration, filtering, merging, and conversions to/from lists/sequences, alongside utilities for exception-safe updates, infix-based access, and label-aware transformations. Designed for static analysis tasks, it enables precise tracking and manipulation of variable-associated data in non-relational contexts, such as value analysis or binding transformations.",
      "description_length": 588,
      "index": 1183,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.WideningTokenLifter.Lifter.P",
      "library": "goblint.lib",
      "description": "This module defines path-representative tokens for tracking and comparing unique identifiers in abstract domains. It supports operations like equality checks, hashing, comparison, and serialization, working with a concrete type `t` that represents tokens. These tokens are used to manage and delay widening in abstract interpretation by associating them with abstract elements.",
      "description_length": 377,
      "index": 1184,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.SpecLifters.HashconsLifter.V",
      "library": "goblint.lib",
      "description": "This module provides operations for managing globally unique constraint variables with hashing, equality, and serialization. It works with a hashed and globally unique type `t`, supporting comparisons, pretty-printing, XML and JSON output, and QCheck arbitrary generation. Concrete use cases include tracking and identifying constraints in analyses where uniqueness and efficient equality checks are critical, such as in symbolic execution or constraint solving.",
      "description_length": 462,
      "index": 1185,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MutexAnalysis.Spec.GM",
      "library": "goblint.lib",
      "description": "This module provides dictionary operations for a mutable map structure that associates lock identifiers (`MustLock.t`) with arbitrary values, supporting traversal, merging, and conversion to sequences or lists. It enables modeling concurrent program analysis states where locks protect data, offering both functional and in-place transformations to track lock dependencies, ownership, and usage patterns. Utilities for exception-safe access and labeled key handling further facilitate precise static analysis of mutex-protected regions in multithreaded code.",
      "description_length": 558,
      "index": 1186,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ExpRelation.Spec.A",
      "library": "goblint.lib",
      "description": "This module defines a specification for comparing expressions based on syntactic equality (`=_{must}`) without tracking runtime state. It provides operations for checking equality, generating hashes, comparing and printing values, as well as serialization to XML and JSON. It is used to determine whether two expressions must be equal at compile time and whether they may race, with applications in static analysis for concurrency and value tracking.",
      "description_length": 450,
      "index": 1187,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Callstring.Spec.V",
      "library": "goblint.lib",
      "description": "This module defines and manipulates globally unique constraint variables used in call string analysis. It supports operations for equality checking, hashing, comparison, and pretty-printing, along with serialization to XML and JSON. These variables are used to represent and track distinct analysis contexts with unique identifiers, primarily in constraint-based analyses like k-CFA.",
      "description_length": 383,
      "index": 1188,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.YamlWitnessType.ViolationSequence.Target",
      "library": "goblint.lib",
      "description": "This module defines a target in a violation sequence with a location and an action string. It includes functions to compare targets, parse them from YAML, and a constant for the waypoint type. It is used to represent specific points of interest in a violation sequence, such as steps in a security analysis path.",
      "description_length": 312,
      "index": 1189,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Queries.Hashtbl.Labels",
      "library": "goblint.lib",
      "description": "This module provides labeled versions of standard hash table operations such as insertion, modification, iteration, filtering, and merging, all working with hash tables that use `Goblint_lib.Queries.Hashtbl.key` as keys and arbitrary data values. It supports precise in-place and functional transformations based on key-value pairs, including conditional updates, mapping with key exposure, and combining tables with custom merge logic. Concrete use cases include managing analysis state in static analysis queries, where keys represent program points or variables and values represent abstract domain elements.",
      "description_length": 611,
      "index": 1190,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Deadlock.Spec.A",
      "library": "goblint.lib",
      "description": "This module defines operations for a singleton type `t` used in deadlock analysis, including equality, comparison, and hashing functions. It provides utilities for pretty-printing, serialization to JSON, and XML output, along with properties like `may_race` and `should_print` for analysis purposes. Concrete use cases include representing abstract deadlock states and facilitating comparison and output in analysis reports.",
      "description_length": 424,
      "index": 1191,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.YamlWitnessType.InvariantSet.LocationInvariant",
      "library": "goblint.lib",
      "description": "This module defines operations for parsing and comparing location-based invariants from YAML input. It works with a record type containing location, value, and format fields, all tied to loop invariant data. It supports concrete use cases like validating loop invariants in static analysis by parsing YAML representations and comparing invariant data during analysis runs.",
      "description_length": 372,
      "index": 1192,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.SpecLifters.HashconsContextLifter.V",
      "library": "goblint.lib",
      "description": "This module provides operations for managing globally constrained variables with a focus on efficient equality checking, hashing, and serialization. It works with a single abstract type `t` representing constraint variables, supporting concrete use cases like tracking unique identifiers for contexts in analysis witnesses and comparing or printing these variables in a consistent manner. Key functions include `equal`, `hash`, `compare`, `show`, `tag`, and `to_yojson`, enabling integration with data structures and formats that rely on these operations.",
      "description_length": 555,
      "index": 1193,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.CommonPriv.WriteCenteredD.P",
      "library": "goblint.lib",
      "description": "This module implements a map-like structure for associating variables with minimal locksets, offering standard associative operations (insertion, lookup, iteration) alongside lattice-theoretic combinators (join, meet, widening) to model concurrent program states. It supports specialized use cases in thread-modular static analysis by tracking lockset constraints for variable accesses, enabling precise abstract interpretation of concurrent memory behaviors through operations parameterized on value types and difference-aware pretty-printing.",
      "description_length": 544,
      "index": 1194,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.WideningTokenLifter.TS",
      "library": "goblint.lib",
      "description": "This module supports lattice and set operations on token sets that control widening delays in abstract interpretation. It works with a lattice type `t` representing token sets as either `Lifted` (containing `Token.t` elements) or `Top`, enabling comparisons, joins, and widening/narrowing decisions based on token set inclusion. Its set manipulation functions (union, intersection, filtering) and derived operations (partitioning, extremal element extraction) facilitate precise analysis state management where token sets dynamically delay convergence during fixed-point computations.",
      "description_length": 584,
      "index": 1195,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Analyses.Var",
      "library": "goblint.lib",
      "description": "This module represents and manipulates variables within an analysis, primarily working with the `Node.t` type to identify and compare variables. It provides operations for equality checking, comparison, hashing, and relifting variables, along with extracting variable identifiers and printing variable information in XML format. Concrete use cases include tracking variable identities during constraint solving and supporting variable-based analyses in a points-to or dataflow analysis.",
      "description_length": 486,
      "index": 1196,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.AbortUnless.Spec",
      "library": "goblint.lib",
      "description": "This module provides operations for manipulating control flow and tracking state transitions during abstract interpretation, particularly for functions that conditionally abort execution. It operates on abstract domains (`D.t`), analysis contexts (`ctx`), and CIL constructs such as expressions, function definitions, and lvalues. These capabilities are used to model environment interactions, thread state changes, and control-flow-sensitive behavior in static analysis scenarios.",
      "description_length": 481,
      "index": 1197,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Analyses.UnitV",
      "library": "goblint.lib",
      "description": "This module defines operations for a unit value analysis, including equality, comparison, and hashing functions. It provides pretty-printing, serialization, and arbitrary value generation for unit-type values. Concrete use cases include representing empty or singleton states in abstract interpretations and constraint systems.",
      "description_length": 327,
      "index": 1198,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.MusteqDomain.F",
      "library": "goblint.lib",
      "description": "This module implements symbolic offset manipulation and equality tracking for static analysis of C programs, focusing on operations like joining, meeting, and transforming offset expressions derived from CIL AST nodes. It works with symbolic offset values (`t`) and CIL types such as expressions, offsets, and memory access paths, enabling precise analysis of pointer equalities and memory access patterns. Key use cases include detecting equivalent lvalue expressions, resolving type information for offsets, and optimizing domain transitions during abstract interpretation of low-level code.",
      "description_length": 593,
      "index": 1199,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.LockDomain.MustMultiplicity",
      "library": "goblint.lib",
      "description": "This module provides operations for managing a lattice-based map structure that tracks multiplicities of must-locked addresses in concurrent programs, where keys represent addresses requiring strict locking and values model integer-based count abstractions. It supports standard map manipulations (insertion, removal, iteration), lattice operations (join, meet, widening), and domain-specific utilities like preorder comparisons (`leq`) and refinement. The structure is used for static analysis tasks such as verifying lock acquisition patterns, detecting deadlocks, or ensuring consistent lock usage across threads.",
      "description_length": 616,
      "index": 1200,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MCPRegistry.DomVariantLattice",
      "library": "goblint.lib",
      "description": "This module provides lattice operations for a variant type combining bottom, top, and lifted domain values, supporting abstract interpretation tasks like join/meet computations and iterative fixpoint analysis. It works with serialized, comparable, and pretty-printable structures that wrap an underlying domain lattice's elements in a `Bot | Top | Lifted` variant. The design enables dynamic analysis composition in abstract interpretation frameworks where domains must handle partial information and convergence tracking through widening/narrowing.",
      "description_length": 549,
      "index": 1201,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.DomainProperties.Join",
      "library": "goblint.lib",
      "description": "This module defines QCheck tests for join operations on a lattice domain, ensuring properties like associativity, commutativity, idempotence, and absorption. It works with elements of type `D.t`, where `D` is a lattice module, and includes functions for generating arbitrary values and comparing them under join operations. Concrete use cases include verifying correctness of lattice implementations and testing domain-specific join behavior in static analysis.",
      "description_length": 461,
      "index": 1202,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.SarifType.Message",
      "library": "goblint.lib",
      "description": "This module defines a simple data structure for representing messages in the SARIF format, specifically encapsulating a `text` field as a string. It provides functions to convert message instances to Yojson representations for serialization. This is used to generate human-readable diagnostic messages in SARIF output, such as error descriptions or analysis results.",
      "description_length": 366,
      "index": 1203,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.UseAfterFree.HeapVars",
      "library": "goblint.lib",
      "description": "This module offers lattice-based abstract domain operations and set-like manipulations for tracking heap-allocated variables in static analysis. It works with `CilType.Varinfo.t` elements, providing membership checks, algebraic set operations, and functional transformations to model variable lifetimes. These capabilities support use-after-free detection by enabling precise tracking of heap variable states and their access patterns during program execution.",
      "description_length": 460,
      "index": 1204,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.SpecLifters.DeadBranchLifter",
      "library": "goblint.lib",
      "description": "This module specializes in static analysis for identifying dead branches by employing abstract interpretation over lattice-based domains (`D`, `G`) and context-sensitive state transformations (`C`, `V`, `P`) to model program behavior. It operates on control flow graphs and CIL-derived program representations, addressing use cases like dead code elimination, concurrency analysis, and constraint enforcement in C programs through precise tracking of control flow and variable states.",
      "description_length": 484,
      "index": 1205,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Server.Function",
      "library": "goblint.lib",
      "description": "This module defines operations for handling function identifiers in the interactive server, including equality checks, comparison, hashing, and JSON serialization. It works with a record type representing functions, containing their names and source locations. Used to filter and list functions from CIL globals, enabling precise function identification and communication over JSON-RPC.",
      "description_length": 386,
      "index": 1206,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.StackTrace.SpecLoc",
      "library": "goblint.lib",
      "description": "This module provides operations for manipulating control flow and program states during static analysis, focusing on function calls, assignments, and concurrency events. It works with abstract analysis contexts, CIL expressions and statements, and symbolic execution data structures like specification locations and abstract interpretation lattices. These tools are used to track call stacks, handle thread transitions, and propagate symbolic states in analyses requiring precise control flow modeling.",
      "description_length": 502,
      "index": 1207,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.ExtractPthread.Tasks",
      "library": "goblint.lib",
      "description": "This module provides set-theoretic and lattice operations for managing task sets in static analysis of concurrent programs, focusing on Pthread task tracking. It operates on sets of elements composed of pointer addresses paired with thread identifiers, supporting operations like union, subset checks, partitioning, and lattice joins/meets to model thread interactions and task state transitions. The structure is particularly useful for abstract interpretation tasks such as merging task contexts, filtering thread-specific data, and analyzing concurrency patterns during program analysis.",
      "description_length": 590,
      "index": 1208,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Analyses.DefaultSpec",
      "library": "goblint.lib",
      "description": "This module provides default implementations for analysis specification functions, handling context initialization, state transitions, and query responses. It operates on generic analysis contexts and state types, offering concrete behavior for operations like variable declarations, assembly handling, and synchronization. Use this to quickly scaffold analyses without writing boilerplate for state management or context propagation.",
      "description_length": 434,
      "index": 1209,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Timeout.Unix",
      "library": "goblint.lib",
      "description": "Implements time-limited execution of functions with support for cancellation. Works with functions of type `'a -> 'b`, input values of type `'a`, and cancellation callbacks. Useful for enforcing timeouts on computations like network requests or long-running analyses.",
      "description_length": 267,
      "index": 1210,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MutexTypeAnalysis.Spec",
      "library": "goblint.lib",
      "description": "This module implements a static analysis framework for tracking mutex types (`pthreadMutexType`) in concurrent programs using lattice-based domains (`G`), constraint variables (`V`), and path representations (`P`). It operates on abstract states (`D.t`) and global states (`G.t`) to model program behavior across function calls, thread creation, and mutex operations, enabling verification of thread-safety properties and detection of concurrency issues like race conditions.",
      "description_length": 475,
      "index": 1211,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.AutoTune.FunctionCallMap",
      "library": "goblint.lib",
      "description": "This module manages associations between function identifiers (`CilType.Varinfo.t`) and polymorphic data, offering operations for insertion, lookup, traversal, and transformation with support for both safe and unsafe access patterns. It includes specialized functions for list-valued entries and bidirectional conversion to ordered sequences, enabling incremental updates and structured analysis of function call relationships. Typical applications involve aggregating function-specific metadata, tracking syntactic heuristics for autotuning, or dynamically refining configurations during static analysis.",
      "description_length": 605,
      "index": 1212,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.WitnessUtil.InvariantExp",
      "library": "goblint.lib",
      "description": "This module processes CIL expressions to extract and manipulate logical conjuncts, focusing on identifying common subexpressions that can be factored out. It operates on `CilType.Exp.t` values, using set operations provided by the `ES` submodule to manage collections of expressions. Concrete use cases include simplifying complex invariants by removing redundant conjuncts and preparing expressions for witness generation or subsumption checks in static analysis.",
      "description_length": 464,
      "index": 1213,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.CommonPriv.NoAtomic",
      "library": "goblint.lib",
      "description": "This module controls handling of atomic blocks in SV-COMP benchmarks during thread-modular value analysis. It provides a mutable flag `handle_atomic` that enables or disables atomic block processing. Used specifically in `BasePriv` and `RelationPriv` analyses to toggle experimental support for concurrency-related atomic sections.",
      "description_length": 331,
      "index": 1214,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.CondVars.Spec",
      "library": "goblint.lib",
      "description": "This module provides symbolic variable analysis and control flow modeling for static program analysis. It operates on symbolic variables, abstract values via a lattice, and analysis states to track logical equalities, pointer relationships, and state transitions in C code. Key use cases include resolving branching conditions, function call effects, and thread-spawning behavior while maintaining constraints across variable assignments and memory operations.",
      "description_length": 460,
      "index": 1215,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MCPRegistry.PrintableOfLatticeSpec",
      "library": "goblint.lib",
      "description": "This module maps integer keys to printable domains, allowing dynamic association and retrieval of analysis domains. It provides operations to associate a domain with an integer key and list all registered domain associations. It is used to manage multiple analysis domains in a dynamic product setting, where each domain is identified by a unique integer key.",
      "description_length": 359,
      "index": 1216,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.SarifType.Run",
      "library": "goblint.lib",
      "description": "Handles serialization of SARIF run data to JSON format. Works with structured SARIF types including tool, artifact, and result records. Used to generate SARIF output files from analysis results.",
      "description_length": 194,
      "index": 1217,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.SymbLocks.PS",
      "library": "goblint.lib",
      "description": "This module provides a lattice-based symbolic lockset domain with set-theoretic operations for analyzing concurrent programs. It works with structured sets of symbolic lock primitives (`LP.t`) and parametric collections of elements (`PS.t`), enabling precise tracking of per-field/index locking patterns. Its operations support static race detection in device drivers by modeling lock acquisition/release behaviors and reasoning about disjointness, containment, and transformations of lock-protected data.",
      "description_length": 505,
      "index": 1218,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.ThreadId.Spec",
      "library": "goblint.lib",
      "description": "This module provides lattice-based abstractions (join, meet, widen, narrow) for analyzing thread identifiers, with operations to handle control flow transitions, merge thread states during synchronization, and model thread creation or termination events. It works with thread identifiers and their states represented via `Thread.t`, `Thread.D.t`, and `GoblintCil.varinfo`, structured through domain-specific models (D, N, C, P) for concurrency behaviors. These capabilities enable static analysis of concurrent programs, supporting tasks like fixpoint stabilization, context-sensitive data flow tracking, and debugging thread interactions through marshaled state representations.",
      "description_length": 679,
      "index": 1219,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.SarifType.Result",
      "library": "goblint.lib",
      "description": "This module defines a SARIF result type with fields for rule ID, kind, level, message, locations, and related locations. It provides functions to convert result values to Yojson for serialization. Used to represent and output analysis findings in SARIF format.",
      "description_length": 260,
      "index": 1220,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.CompareConstraints.CompareEqSys",
      "library": "goblint.lib",
      "description": "This module compares constraint systems by evaluating the equality of variable-to-domain mappings using structural and semantic checks. It operates on `Sys.Dom.t VH.t` structures, which represent variable assignments in a constraint system. Concrete use cases include verifying consistency between constraint system states during static analysis and generating detailed comparison reports for debugging or validation.",
      "description_length": 417,
      "index": 1221,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.IntDomainProperties.IntegerSet",
      "library": "goblint.lib",
      "description": "This module provides lattice operations (join, meet, widen), set manipulations (union, intersection, subset checks), arithmetic and bitwise transformations (addition, shifts, logical operations), and comparison queries over sets of abstract integers. It operates on a set type `t` containing elements of `Base.t`, which represents abstract integer values, enabling static analysis tasks like tracking integer expressions, invariants, and low-level bitwise behavior in programs. The inclusion of C-style bitwise and arithmetic operations supports precise modeling of integer manipulations common in systems programming contexts.",
      "description_length": 627,
      "index": 1222,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.PrecCompare.MakeHashtbl",
      "library": "goblint.lib",
      "description": "This module implements a hash table for storing and comparing precision data using custom equality and ordering derived from the `PrecCompare` module. It works with data structures conforming to the `D` module type, enabling efficient lookups and comparisons of precision values. Concrete use cases include caching results of precision comparisons and managing equivalence classes of precision-related data during static analysis.",
      "description_length": 430,
      "index": 1223,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Analyses.IdentitySpec",
      "library": "goblint.lib",
      "description": "This module provides operations for managing program analysis contexts, including variable declarations, control flow handling (branching, function entry/exit), and environment manipulation, alongside thread-aware capabilities for spawning and synchronizing concurrent execution paths. It operates on abstract analysis contexts, CIL expressions, and function definitions, using state transformation patterns to model program behavior. These capabilities are particularly useful for static analysis of concurrent programs, where tracking interactions between threads and maintaining precise state across control flow merges is critical.",
      "description_length": 635,
      "index": 1224,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.TaintPartialContexts.VS",
      "library": "goblint.lib",
      "description": "This module provides lattice and set operations for abstract interpretation in taint analysis, tracking variables modified within functions. It uses a lifted set structure with a top element and a polymorphic set-like ADT for variable collections, enabling data flow analysis via set algebra, lattice joins/meets, and dependency modeling during static analysis.",
      "description_length": 361,
      "index": 1225,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.RegionDomain.VFB",
      "library": "goblint.lib",
      "description": "This module provides operations for managing region constraints and domain values through a variant type that combines equality constraints and base region representations. It supports domain-specific manipulations like merging regions (`join`), removing variables (`kill`), and substituting expressions, while working with variables, memory offsets, and abstract regions. The functionality is used in static analysis to track heap region relationships and distinguish concrete memory regions from symbolic or temporary ones during abstract interpretation.",
      "description_length": 556,
      "index": 1226,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.DomainProperties.Meet",
      "library": "goblint.lib",
      "description": "Implements QCheck property tests for meet operations in lattice structures. Works with any lattice module D, verifying correctness of meet against identity, commutativity, associativity, and absorption with join. Useful for validating lattice implementations in static analysis domains.",
      "description_length": 286,
      "index": 1227,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.VectorMatrix.ArrayMatrix",
      "library": "goblint.lib",
      "description": "This module provides array-based matrix operations focused on normalization to reduced row echelon form (RREF), enabling efficient row/column manipulation, matrix appending, and structural reductions. It works with matrices represented as arrays of vectors and supports operations like column reduction, index-aware mapping, zero row removal, and coverage validation, leveraging RREF properties for optimized computations. These capabilities are particularly useful in symbolic computation, linear system solving, or formal verification scenarios where maintaining and exploiting RREF structures ensures algorithmic efficiency.",
      "description_length": 627,
      "index": 1228,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.AccessAnalysis.Spec",
      "library": "goblint.lib",
      "description": "This module provides lattice-based abstract domain operations (join, meet, widen, narrow) and transfer functions to model memory accesses (e.g., `access`, `do_access`) during static analysis. It operates on control flow graph nodes, abstract memory states, and CIL-level program elements like variables and expressions, with specialized handling for concurrency and interprocedural analysis. These capabilities enable detecting memory errors, enforcing thread safety, and analyzing data races in multi-threaded programs with complex control flow.",
      "description_length": 546,
      "index": 1229,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Graphml.ArgNodeGraphMlWriter",
      "library": "goblint.lib",
      "description": "This module writes GraphML files by streaming output, supporting incremental construction of directed graphs with labeled nodes and edges. It handles low-level GraphML structure, including keys, metadata, and graph elements, using user-defined node and metadata types. Concrete use cases include exporting analysis results or control flow graphs to GraphML for visualization or further processing.",
      "description_length": 397,
      "index": 1230,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.SarifType.SarifLog",
      "library": "goblint.lib",
      "description": "Handles serialization of SARIF log data to JSON format. Works with SARIF log records containing version, schema, and run data. Used to output analysis results in SARIF format for external tool consumption.",
      "description_length": 205,
      "index": 1231,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.UnitAnalysis.Spec",
      "library": "goblint.lib",
      "description": "This module provides abstract interpretation operations for unit domain analysis, handling program constructs like assignments, branches, function calls, and concurrency primitives through state transitions and context management. It operates on abstract domain values (`D.t`), CIL expressions/statements, and analysis contexts to model control flow and thread interactions. Use cases include static analysis of imperative programs with concurrency, where precise tracking of state effects and thread spawning is required.",
      "description_length": 522,
      "index": 1232,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Analyses.GVarG",
      "library": "goblint.lib",
      "description": "This module provides lattice operations (join, meet, widen, narrow) and comparisons for a four-state abstract domain used in static analysis, handling values lifted from two distinct contexts. It operates on program variables (`G.t`) and constraint sets (`CSet.t`), enabling dataflow analysis to track variable properties across program paths. Its structure supports merging and refining abstract states during fixed-point computations in constraint-based analyses.",
      "description_length": 465,
      "index": 1233,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.CommonPriv.MutexGlobals",
      "library": "goblint.lib",
      "description": "This module manages thread-modular analysis of mutex and global variable states through dedicated types and operations. It provides precise tracking of mutex variables with offset information, initialization states, and global variable identities, supporting comparisons, serialization, and integration with analysis frameworks. Concrete use cases include modeling mutex-specific value domains, determining required mutex initializations, and tracking global variable accesses across concurrent contexts.",
      "description_length": 504,
      "index": 1234,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MCPRegistry.ContextListSpec",
      "library": "goblint.lib",
      "description": "Implements a list-based context specification for analysis domains, providing operations to associate domain indices with printable modules and retrieve domain lists. Works with integers as domain identifiers and modules conforming to the Printable.S signature. Used to manage and query dynamically activated analysis domains in a product configuration.",
      "description_length": 353,
      "index": 1235,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.YamlWitnessType.Entry",
      "library": "goblint.lib",
      "description": "This module defines operations for converting entry values to and from a structured YAML format, primarily used for serializing and deserializing witness data. It works with the `t` type, which includes an `entry_type` and `metadata`, both of which are specific to the witness format. Concrete use cases include parsing YAML input into typed entry structures and generating YAML output for analysis results.",
      "description_length": 407,
      "index": 1236,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.EvalAssert.EvalAssert",
      "library": "goblint.lib",
      "description": "This module transforms a program by inserting computed invariants as `assert` statements at specific points, using provided query functions. It operates on CIL files and modifies their structure to include runtime checks based on analyzed properties. Use cases include enforcing value ranges, pointer validity, or concurrency constraints directly in the instrumented code.",
      "description_length": 372,
      "index": 1237,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.PrecCompare.Comparison",
      "library": "goblint.lib",
      "description": "This module represents and manipulates precision comparison results between two analyses. It provides operations to construct and combine comparison outcomes, such as equal, more precise, less precise, or incomparable, using count-based aggregation. Use cases include summarizing and comparing the precision of different static analysis configurations or domains.",
      "description_length": 363,
      "index": 1238,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.PthreadDomain.Pred",
      "library": "goblint.lib",
      "description": "This module provides lattice and set operations for tracking predecessor nodes in control flow graphs, working with a domain of sets containing elements of type `Base.t`. It supports abstract interpretation tasks like control flow analysis and concurrency-related reasoning in Pthread programs by enabling set manipulation, extremal element extraction, and conversions between lists and node-based sets. Specific use cases include analyzing thread synchronization points and determining reachable predecessors during static analysis of parallel code.",
      "description_length": 550,
      "index": 1239,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.BaseDomain.DomFunctor",
      "library": "goblint.lib",
      "description": "This module provides lattice operations (meet, join, widen, narrow), comparison utilities, and serialization for an abstract domain modeling program states or properties. It supports merging analysis components (e.g., control-flow, dependencies, weak updates) through customizable strategies, enabling tasks like fixed-point stabilization and abstract state combination in static analysis. The generalized merge scheme adapts to internal structures like CPA and private data, facilitating precise value tracking across program paths.",
      "description_length": 533,
      "index": 1240,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.PthreadDomain.D",
      "library": "goblint.lib",
      "description": "This module enables abstract interpretation of concurrent programs through lattice operations (join, meet, widen, narrow), comparison functions, and conversion utilities for manipulating abstract thread states represented by the `D.t` type. It supports static analysis tasks like modeling thread interactions, tracking state transitions, and verifying correctness properties in Pthread-based concurrency by constructing and analyzing domain instances from thread IDs and contexts.",
      "description_length": 480,
      "index": 1241,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Queries.Hashtbl",
      "library": "goblint.lib",
      "description": "This module implements a specialized hash table for managing key-value associations where keys are analysis-specific identifiers (`Goblint_lib.Queries.Any.t` or `key`), supporting both imperative and functional transformations. It offers operations for precise key-based manipulation, including merging, filtering, and mapping with side-effect control, as well as sequence conversion and exception-safe access. Designed for static analysis workflows, it enables efficient tracking and modification of analysis states tied to structured keys, with utilities for handling duplicates, optional lookups, and labeled argument-driven updates.",
      "description_length": 636,
      "index": 1242,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.YamlWitnessType.PreconditionLoopInvariantCertificate",
      "library": "goblint.lib",
      "description": "This module defines and processes certificate data for loop invariants in YAML witness files. It includes functions to parse certificates from YAML and compare them, working with structured data containing targets and certification details. It is used to validate and handle precondition loop invariant certificates during static analysis.",
      "description_length": 339,
      "index": 1243,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Access.A",
      "library": "goblint.lib",
      "description": "This module represents and manipulates memory access descriptions, including their configuration, kind, associated node, and expression. It provides operations for equality checking, comparison, hashing, and pretty-printing of access values. Concrete use cases include tracking and analyzing memory accesses during static analysis, such as identifying read/write operations on specific variables or expressions.",
      "description_length": 411,
      "index": 1244,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.VarEq.Spec",
      "library": "goblint.lib",
      "description": "This module implements symbolic variable equality analysis with lattice operations (join, meet, widen, narrow) and control flow merge handling over set-like structures and symbolic expressions. It operates on abstract analysis states (D.t) to support static analysis tasks like constraint merging, fixed-point refinement, and dataflow analysis of variable relationships in programs with pointers and function calls, including tracking equivalences during assignments and interprocedural transitions.",
      "description_length": 499,
      "index": 1245,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.LoopTermination.Spec",
      "library": "goblint.lib",
      "description": "The module provides abstract interpretation techniques for analyzing loop and `goto` termination in C programs, utilizing lattice-based abstract states (`D`, `G`, `C`, `V`, `P`) to model termination conditions, execution contexts, and path-sensitive information. It includes transfer functions for control-flow operations\u2014such as assignments, branches, function calls, and thread creation\u2014as well as context manipulation and serialization, enabling static analysis to infer termination properties through algebraic and flow-sensitive reasoning. This supports verification of loop termination in C code during static analysis, particularly for handling complex control structures and interprocedural contexts.",
      "description_length": 708,
      "index": 1246,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MCPRegistry.DomListRepresentative",
      "library": "goblint.lib",
      "description": "This module represents a list of domain elements with associated integer tags, providing equality, hashing, comparison, and serialization operations. It works with tuples of integers and OCaml objects, supporting conversion to strings, XML, and JSON formats. It is used to identify and compare analysis contexts in dynamic product configurations, where each element represents a domain-specific analysis state.",
      "description_length": 410,
      "index": 1247,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MemLeak.Spec",
      "library": "goblint.lib",
      "description": "This module implements lattice-based abstract interpretation components for tracking dynamic memory states and detecting leaks in C programs. It operates on abstract domains for memory blocks (D), global constraints (G), execution contexts (C), variables (V), and path representatives (P), with transfer functions handling control flow constructs like function calls, returns, thread spawning, and inline assembly. The analysis specializes in identifying untracked deallocations across complex program paths by comparing memory state transitions and maintaining context-sensitive allocation sites.",
      "description_length": 597,
      "index": 1248,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Analyses.GVarF",
      "library": "goblint.lib",
      "description": "This module defines a polymorphic sum type for representing either a value of type `V.t` or a CIL function declaration. It provides operations for comparison, hashing, pretty-printing, and serialization to XML and Yojson formats. Concrete use cases include tracking variable and function identifiers in static analysis contexts, distinguishing between variable and function references in constraint systems, and supporting analysis-specific data flow operations.",
      "description_length": 462,
      "index": 1249,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Callstring.Callstring",
      "library": "goblint.lib",
      "description": "This module represents call strings for context-sensitive analysis, supporting operations like equality checks, hashing, comparison, and conversion to string or XML. It works with function call sequences to track context during analysis. Used to implement call string-based analyses with customizable length limits and context identification via unique tags.",
      "description_length": 358,
      "index": 1250,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.AbstractionDomainProperties.Monotone",
      "library": "goblint.lib",
      "description": "Implements QCheck property tests for monotonicity of abstract domain operations. Verifies that increasing the input value in the abstract domain results in a corresponding increase in the output value. Uses concrete data (CD), abstract domains (AD), and abstract functions (AF) to generate and validate test cases. Useful for ensuring correctness of abstract interpretation frameworks where monotonicity is required.",
      "description_length": 416,
      "index": 1251,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ModifiedSinceSetjmp.Spec",
      "library": "goblint.lib",
      "description": "This module provides operations for context-based abstract interpretation to track variables modified since `setjmp`, including state initialization/finalization, control-flow processing, and environment transitions. It operates on CIL constructs like expressions (`exp`), variable identifiers (`varinfo`), and function definitions (`fundec`), alongside abstract domains (`D.t`) for static analysis of program behavior. Its design supports use cases in static analysis where precise tracking of variable modifications across non-local jumps (`longjmp`) is required, such as ensuring correctness in setjmp/longjmp scenarios.",
      "description_length": 623,
      "index": 1252,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.UseAfterFree.StackAndHeapVars",
      "library": "goblint.lib",
      "description": "This analysis combines stack-allocated and heap-allocated variable tracking into a unified abstract domain for detecting memory safety violations. It provides lattice operations to merge and compare variable states alongside utilities for structured data representation, testing, and human-readable diagnostics. The domain operates on pairs of allocation-specific types (`AllocaVars.t` for stack and `HeapVars.t` for heap), enabling precise modeling of variable lifetimes in static analysis workflows.",
      "description_length": 501,
      "index": 1253,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.AbstractionDomainProperties.AbstractTest",
      "library": "goblint.lib",
      "description": "Implements QCheck property tests for abstract domains using concrete and abstract state modules. Provides equality checking (`@=`), arbitrary value generation (`arb`), and test configuration (`make`). Used to validate correctness of abstract interpretation operations like widening or meet under varying conditions.",
      "description_length": 315,
      "index": 1254,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.StackTrace.Spec2",
      "library": "goblint.lib",
      "description": "This component enables manipulation of abstract call stack states through operations for combining contexts (`combine_assign`, `combine_env`), handling function calls and thread synchronization (`threadspawn`, `threadenter`), and managing stack transitions (`startstate`, `exitstate`). It operates on abstract domain values and structured stack traces, leveraging lattice operations and analysis utilities to model context-sensitive program behavior during static analysis. These capabilities are particularly useful for tracking call stack evolution across function boundaries, concurrency primitives, and integrating with reporting tools via XML/JSON serialization.",
      "description_length": 667,
      "index": 1255,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.VectorMatrix.ArrayVector",
      "library": "goblint.lib",
      "description": "This module implements array-backed vector operations with support for element access, in-place modifications, and functional transformations. It works with vectors of elements from a base type `A.t`, offering conversions to and from lists/arrays, indexed mapping, filtering, and vector combination. This is suited for numerical algorithms or data processing tasks requiring efficient indexed access, bulk transformations, or hybrid functional/imperative workflows.",
      "description_length": 465,
      "index": 1256,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Queries.Set",
      "library": "goblint.lib",
      "description": "This module implements a set abstraction for query elements with a focus on functional transformations, structural manipulation, and safe element access. It operates on parameterized sets of elements, supporting algebraic operations like union, intersection, and difference, as well as predicate-based filtering, extremal value extraction, and conversion to sequences or collections. Designed for robust analysis workflows, it enables exception-safe querying, custom-formatted output, and selective processing through combinators that preserve set invariants during iteration or bulk transformations.",
      "description_length": 600,
      "index": 1257,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ThreadAnalysis.Spec",
      "library": "goblint.lib",
      "description": "This module provides operations for analyzing concurrency-related program constructs\u2014such as assignments, synchronization events, and thread creation\u2014while managing abstract thread states within a lattice structure. It works with thread identifiers (TIDs), analysis states (`D.t`), and concurrency constructs to enforce thread uniqueness, track memory access patterns, and resolve hierarchical relationships between threads. These capabilities are applied in static analysis to verify correctness properties in concurrent programs, such as ensuring thread-local data isolation or detecting synchronization errors.",
      "description_length": 613,
      "index": 1258,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.SpecLifters.WidenContextLifterSide",
      "library": "goblint.lib",
      "description": "This module provides context-sensitive abstract interpretation operations combining lattice-based domains, focusing on widening strategies, state transitions, and context manipulation for static analysis. It works with product domains, variable-indexed maps, and context-aware abstract types to handle control-flow merging, function call tracking, and thread synchronization in concurrent programs. The design supports precise analysis of programs with dynamic contexts, such as recursive or interprocedural code, by lifting domain operations to maintain context-specific state during fixed-point computations.",
      "description_length": 610,
      "index": 1259,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Svcomp.Result",
      "library": "goblint.lib",
      "description": "Handles SV-COMP result values with conversion to string. Works with the `t` sum type representing result states: `True`, `False` (with optional specification), and `Unknown`. Used to format analysis outcomes for reporting or comparison in SV-COMP tasks.",
      "description_length": 253,
      "index": 1260,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Analyses.StdV",
      "library": "goblint.lib",
      "description": "Implements standard value analyses for constraint systems, focusing on operations like variable assignment tracking and dependency resolution. Works with abstract syntax trees and constraint graphs to identify write-only variables and resolve indirect references. Used in static analysis passes to optimize and validate variable usage in parsed programs.",
      "description_length": 354,
      "index": 1261,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.SymbLocksDomain.Symbolic",
      "library": "goblint.lib",
      "description": "This module provides a lattice-based abstract domain for symbolic locksets with standard set operations (union, subset, filter) and lattice operations (join, meet, widen, narrow), designed for static concurrency analysis to track lock acquisition and release patterns. It manipulates symbolic lock sets represented as `S.t` values\u2014collections of CIL expressions (`CilType.Exp.t`)\u2014supporting symbolic states via `Lifted` and `Top` variants. Functionality includes element addition, removal, folding, and utilities for XML printing, comparison, and QCheck arbitraries, facilitating analysis of thread synchronization and lock contention scenarios.",
      "description_length": 645,
      "index": 1262,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ObserverAnalysis.MakePathSpec",
      "library": "goblint.lib",
      "description": "This module implements path-sensitive static analysis operations for tracking program states with precise path and constraint dependencies. It operates on lattice-based abstract domains (for data, contexts, variables, and path constraints) and employs transfer functions to model state transitions during program execution. Key use cases include analyzing C programs with complex control flow, thread interactions, and inline assembly, where unique state identifiers and observer automaton transitions enable accurate tracking of path-sensitive behaviors.",
      "description_length": 555,
      "index": 1263,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.LocksetAnalysis.MakeMust",
      "library": "goblint.lib",
      "description": "This module provides a must-lockset analysis for concurrency safety by tracking definite lock acquisition patterns in control flow graphs, determining which locks must be held at each program point. It operates on abstract lockset types `D.t` and `C.t`, using lattice operations like join and widen to combine environments and enforce precise lock constraints. Key applications include detecting race conditions, analyzing thread spawns, and ensuring required locks are held across function calls, returns, and branching logic.",
      "description_length": 527,
      "index": 1264,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Queries.Any",
      "library": "goblint.lib",
      "description": "This module defines operations for comparing, ordering, and hashing abstract queries, along with pretty-printing. It works directly with the `any_query` type, which represents a polymorphic query in the analysis framework. Concrete use cases include managing query identities in caches, enforcing evaluation order, and generating readable representations of queries for debugging or output.",
      "description_length": 390,
      "index": 1265,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Server.ParamParser",
      "library": "goblint.lib",
      "description": "Parses JSON-RPC structured input into a result containing server parameters or an error message. Works directly with `Jsonrpc.Structured.t` and `R.params` types. Used to validate and convert JSON-RPC requests into typed server configurations during client interactions.",
      "description_length": 269,
      "index": 1266,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.LockDomain.MvalRW",
      "library": "goblint.lib",
      "description": "This module represents a domain for tracking lock values combined with read/write permissions. It provides operations for equality, comparison, hashing, and pretty-printing of lock-value pairs, along with arbitrary value generation for testing. It is used in static analysis to model concurrent access to shared resources, where each value is associated with a lock and its access mode.",
      "description_length": 386,
      "index": 1267,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.DomainProperties.AllNonAssoc",
      "library": "goblint.lib",
      "description": "Implements QCheck property tests for lattice operations of a domain module D. Works with lattice structures to validate properties like associativity, commutativity, and absorption. Used to verify correctness of lattice implementations in static analysis domains.",
      "description_length": 263,
      "index": 1268,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.SarifType.Artifact",
      "library": "goblint.lib",
      "description": "Handles artifact data in SARIF format, specifically managing artifact locations through conversion to and from JSON using Yojson. Works with the `t` record type containing an `ArtifactLocation.t` field. Used for serializing and deserializing artifact location information in SARIF output files.",
      "description_length": 294,
      "index": 1269,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ThreadFlagDomain.Simple",
      "library": "goblint.lib",
      "description": "This module supports analysis of multi-threaded programs by tracking thread states through a lattice structure that explicitly distinguishes the main thread. It operates on thread flags (`type t`) representing execution contexts, offering lattice operations (join, meet, widen) and predicates to check states like `is_main` or `is_multi`, alongside serialization and diff reporting. Useful in static analysis for scenarios requiring precise handling of thread-specific behavior, such as concurrency models where the main thread has unique semantics.",
      "description_length": 549,
      "index": 1270,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MayLocks.Arg",
      "library": "goblint.lib",
      "description": "This module provides functions to manipulate abstract lock states by adding or removing locks based on analysis context. It operates on lock state domains defined by submodules, specifically handling lock acquisition and release operations during static analysis. These functions are used to track potential lock sets and detect concurrency issues such as double locking in program code.",
      "description_length": 387,
      "index": 1271,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MyARG.InlineEdge",
      "library": "goblint.lib",
      "description": "This module represents edges in an abstract reachability graph specialized for inline function calls. It provides operations to embed control flow edges into this structure and convert them to string representations. It is used to model and analyze call relationships in program analysis.",
      "description_length": 288,
      "index": 1272,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Signs.Spec",
      "library": "goblint.lib",
      "description": "This module provides lattice-based abstract interpretation operations for tracking integer sign properties through intraprocedural and interprocedural control flow. It manipulates abstract sign states structured as lattices, handling variables, expressions, and function contexts to analyze effects of assignments, branches, function calls, and concurrency primitives. The analysis supports error detection in arithmetic operations, optimization opportunities, and race condition identification by propagating sign information across program paths.",
      "description_length": 548,
      "index": 1273,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ExtractPthread.Edges",
      "library": "goblint.lib",
      "description": "Tracks and manipulates control-flow edges between resources in Pthread programs during Promela extraction. It stores edges in a hash table mapping resources to sets of edges, supports adding edges with optional destination nodes and domain data, and provides functions to retrieve edges, filter actions, and find functions associated with threads. Used to build and analyze inter-thread communication and synchronization in concurrent C programs.",
      "description_length": 446,
      "index": 1274,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.MyARG.InlineEdgePrintable",
      "library": "goblint.lib",
      "description": "This module defines operations for comparing, hashing, and converting inline edges to strings or XML representations. It works with the `inline_edge` type, which represents edges in an abstract reachability graph. It supports use cases such as printing edges for debugging, serializing edges to XML or JSON, and generating arbitrary edge values for testing.",
      "description_length": 357,
      "index": 1275,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.SarifType.ArtifactLocation",
      "library": "goblint.lib",
      "description": "This module defines a single type `t` representing an artifact location in the SARIF format, containing a `uri` field. It provides functions to serialize the type to Yojson and compare instances for equality. This is used to model file paths or URIs in SARIF output, enabling structured reporting of analysis results.",
      "description_length": 317,
      "index": 1276,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.AbstractionDomainProperties.ValidTest",
      "library": "goblint.lib",
      "description": "This module defines QCheck test cases to validate correctness properties of abstract domains by comparing concrete and abstract computations. It supports operations like equality checks on abstract values, arbitrary input generation, and test case construction with customizable failure handling and size constraints. Concrete use cases include verifying that abstract interpretations of functions preserve expected invariants or behave consistently with their concrete counterparts under various input conditions.",
      "description_length": 514,
      "index": 1277,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.SpecLifters.PathSensitive2",
      "library": "goblint.lib",
      "description": "This module enables path-sensitive static analysis by defining lattice operations, path tracking mechanisms, and transfer functions for program statements (e.g., assignments, branches) and interprocedural/threaded interactions. It operates on abstract domains (`D.t`), analysis contexts (`C.t`), and program constructs from `GoblintCil`, supporting precise modeling of control flow, function calls, and concurrency (e.g., thread spawning, event handling) in complex programs.",
      "description_length": 475,
      "index": 1278,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.UnassumeAnalysis.EH",
      "library": "goblint.lib",
      "description": "This module provides efficient hash table and map-like data structures for managing associations between keys derived from CIL expressions (`CilType.Exp.t`) and generic values. It supports fine-grained mutation operations (insertion, removal, querying) alongside bulk transformations from sequences, enabling scalable handling of dynamic invariant data. These structures are particularly useful for tracking and applying unassume constraints during static analysis, where YAML-defined invariants are processed into transient state modifications.",
      "description_length": 545,
      "index": 1279,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.YamlWitnessType.Target",
      "library": "goblint.lib",
      "description": "This module defines operations for comparing, serializing, and deserializing target data in a YAML witness format. It works with a record type containing UUID, type identifier, and file hash fields. It is used to handle target-specific metadata in static analysis workflows, ensuring consistent parsing and representation of analysis targets.",
      "description_length": 342,
      "index": 1280,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.LockDomain.MustLockRW",
      "library": "goblint.lib",
      "description": "This module represents a lock domain that combines a must-lock set with read-write (RW) state, providing operations to compare, hash, and pretty-print these combined values. It supports checking equality, ordering, and arbitrary generation for testing, along with serialization via XML and Yojson. Concrete use cases include tracking precise locking behavior in concurrent programs, particularly where read and write access must be distinguished and enforced.",
      "description_length": 459,
      "index": 1281,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ExtractPthread.Variable",
      "library": "goblint.lib",
      "description": "This module provides functions to analyze and construct variable information from lvalues and lhosts, specifically handling `varinfo` types from GoblintCil.Cil. It includes predicates to check variable properties such as being integral, global, or memory-related, and utilities to convert lvalue components into variable info. It is used during Pthread Promela extraction to process and represent C variables in the analysis.",
      "description_length": 425,
      "index": 1282,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.YamlWitnessType.Location",
      "library": "goblint.lib",
      "description": "This module defines operations for handling source code location information in YAML format. It provides functions to convert location data to and from YAML, supporting structured representation of file names, line and column numbers, file hashes, and function names. Concrete use cases include serializing and deserializing location metadata for analysis reports or witness files.",
      "description_length": 381,
      "index": 1283,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.CompareConstraints.CompareNode",
      "library": "goblint.lib",
      "description": "This module structurally compares constraint node maps to validate constraint propagation states in static analysis. It converts labeled constraint contexts into node-keyed maps and checks discrepancies between them, producing human-readable diffs. Used for debugging analysis precision and ensuring consistency across constraint tracking phases.",
      "description_length": 346,
      "index": 1284,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Malloc_null.Spec",
      "library": "goblint.lib",
      "description": "This module provides path-sensitive analysis operations for tracking dynamic memory allocation failures and null pointer usage in C programs. It manipulates abstract domain states (`D.t`, `P.t`) and CIL structures (`lval`, `exp`, `fundec`) to perform lattice operations, value comparisons, and memory safety checks. The analysis handles control flow branches, function calls, and assignments while generating warnings for potential null dereferences and allocation-related errors.",
      "description_length": 480,
      "index": 1285,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.SpecLifters.OptEqual",
      "library": "goblint.lib",
      "description": "This module provides lattice operations\u2014merging, comparison, and serialization\u2014alongside structural equality checks for abstract analysis domains. It operates on abstract value types (`D`, `G`, `C`, `V`, `P`) and CIL AST elements (e.g., function declarations, expressions) to enable context-sensitive state tracking and domain-specific transfer functions like function call semantics or thread management. These capabilities support static analysis tasks such as abstract interpretation, constraint propagation, and handling complex control flow scenarios in program verification.",
      "description_length": 580,
      "index": 1286,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.SarifType.ToolComponent",
      "library": "goblint.lib",
      "description": "This module defines the structure and serialization for a tool component in the SARIF format. It includes fields such as name, version, and rules, and provides functions to convert the structure to JSON. It is used to represent and output metadata about analysis tools in SARIF-compliant reports.",
      "description_length": 296,
      "index": 1287,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.WrapperFunctionAnalysis.SpecBase",
      "library": "goblint.lib",
      "description": "This module provides symbolic execution-based analysis for wrapper functions in C code, focusing on dynamic memory allocation and concurrency. It employs abstract domains and lattice structures to track symbolic heap locations (derived from program nodes and thread IDs) and symbolic thread identifiers (based on nodes), enabling context-sensitive state transitions and precision-controlled merging. Key use cases include analyzing `malloc`-like allocations and thread creation patterns with path-sensitive precision through unique symbolic identifiers tied to program structure.",
      "description_length": 579,
      "index": 1288,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.EscapeDomain.EscapedVars",
      "library": "goblint.lib",
      "description": "This module provides lattice operations (join, meet, widen, narrow) and set operations (union, intersection, membership checks, modification) for tracking escaped thread-local variables in concurrent static analysis. It works with an abstract type `t` representing either a set of variables (`Lifted`) or a top element (`Top`), where variables are of type `Basetype.Variables.t`. It is specifically used to analyze variable escape in concurrent programs, enabling tasks like determining which variables escape threads or propagating escape states across analysis contexts.",
      "description_length": 572,
      "index": 1289,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.CondVars.Domain",
      "library": "goblint.lib",
      "description": "This module provides map-based and lattice operations for managing associations between symbolic expressions and their values, specialized for tracking logical equalities and conditional constraints in static analysis. It operates on a domain type that maps keys of symbolic expressions (`Mval.Exp.t`) to abstract values (`V.t`), supporting operations like merging, filtering, and taint-aware queries. It is particularly used in program analysis to model variable relationships and condition propagation through control-flow and data-flow reasoning.",
      "description_length": 549,
      "index": 1290,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.YamlWitness.ValidationResult",
      "library": "goblint.lib",
      "description": "This module provides operations for representing and analyzing validation outcomes using a lattice structure, enabling comparison, combination, and hierarchical analysis of results. It defines a `result` type with distinct validation states and an integer-based `t` type, alongside utilities for structured validation of YAML witness chain parameters. These components support use cases like merging divergent analysis states in static analysis and validating hierarchical witness data.",
      "description_length": 486,
      "index": 1291,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.DomainProperties.Connect",
      "library": "goblint.lib",
      "description": "Implements QCheck property tests for lattice structures, specifically verifying operations like `leq`, `join`, and `meet` for a given domain module `D`. Works directly with lattice elements and their associated ordering and combination functions. Useful for testing correctness of lattice implementations in static analysis domains.",
      "description_length": 332,
      "index": 1292,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ArgTools.Dot",
      "library": "goblint.lib",
      "description": "This module generates DOT graph representations of abstract reachability graphs (ARGs). It provides functions to format nodes and edges with specific styling, and outputs the full graph structure. It is used to visualize analysis results by converting constraint system solutions into graphical form.",
      "description_length": 300,
      "index": 1293,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.CompareConstraints.CompareGlobSys",
      "library": "goblint.lib",
      "description": "This module implements comparison operations for constraint systems in static analysis, specifically handling global and local variable mappings tied to program points. It provides functions to compare constraint states between different analysis contexts, using labeled mappings from the `PP` module and hash tables for global variables. Concrete use cases include verifying equivalence of analysis results across different runs or configurations, such as checking consistency of inferred constraints between two versions of an analyzer.",
      "description_length": 538,
      "index": 1294,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MHPAnalysis.Spec",
      "library": "goblint.lib",
      "description": "This module provides operations for analyzing program constructs like assignments, branches, and function calls within an abstract interpretation framework, using an analysis state `D.t` to model memory accesses. It includes functionality for tracking thread creation, synchronization, and execution flows in concurrent programs, leveraging thread identifiers and sets to determine potential parallel execution paths. These capabilities enable detecting data races by identifying memory accesses that may occur in parallel across threads.",
      "description_length": 538,
      "index": 1295,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.WitnessUtil.YamlInvariant",
      "library": "goblint.lib",
      "description": "This module controls the emission of invariant annotations in YAML witness files by determining which nodes qualify as loop heads, after lock operations, or other categories. It works with control flow nodes (`MyCFG.node`) and locations (`GoblintCil.location`) to identify syntactic loop heads, stub nodes, and nodes relevant for invariant generation. Concrete use cases include filtering nodes for invariant annotation in witness generation and classifying control flow points based on loop and lock semantics.",
      "description_length": 511,
      "index": 1296,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.DomainProperties.DomainTest",
      "library": "goblint.lib",
      "description": "This module defines QCheck tests for lattice properties using an arbitrary domain `D`. It provides functions to create and configure property tests, including equality checks and test generation parameters. Concrete use cases include validating lattice operations like meet and join through randomized testing.",
      "description_length": 310,
      "index": 1297,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.UnassumeAnalysis.FH",
      "library": "goblint.lib",
      "description": "The module implements a hash table for CIL function declarations, supporting operations like insertion, lookup, removal, and bulk transformations over collections of function-value pairs. It works with polymorphic values indexed by function declarations, offering efficient access and batch processing for scenarios such as tracking invariants or unassume events tied to specific functions. This facilitates use cases in static analysis where per-function data needs to be dynamically managed and queried during invariant propagation or witness validation.",
      "description_length": 556,
      "index": 1298,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ExtractPthread.Env",
      "library": "goblint.lib",
      "description": "Maintains environment state during Promela extraction of Pthread programs, tracking analysis data, control flow nodes, and resource usage. Provides direct access to analysis context, current CFG node, and resource information for transformation tasks. Used to extract thread behavior into Promela models by mapping Pthread operations to corresponding Promela constructs.",
      "description_length": 370,
      "index": 1299,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.BaseDomain.BaseComponents",
      "library": "goblint.lib",
      "description": "This module provides lattice-based abstract domain operations (join, meet, widen, narrow) and extremum checks (bot, top, is_bot, is_top) for analyzing program values through combinations of component domains. It operates on structured abstract elements built from PrivD.t and related components like CPA, PartDeps, and WeakUpdates, enabling unified analysis of privilege states, dependency tracking, and weak update semantics. The design supports static analysis tasks requiring value comparison, merging, and difference explanation across multiple domain aspects.",
      "description_length": 564,
      "index": 1300,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ThreadId.VNI",
      "library": "goblint.lib",
      "description": "This module represents thread identifiers composed of a variable info, a node, and an optional thread creation count. It provides equality checks, ordering, hashing, string conversion, and serialization functions for these identifiers. Concrete use cases include tracking thread creation points and analyzing thread-specific behavior in concurrent programs.",
      "description_length": 357,
      "index": 1301,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MCPRegistry.PrintableOfRepresentativeSpec",
      "library": "goblint.lib",
      "description": "This module maps analysis domains to printable representations using a registry system. It provides `assoc_dom` to retrieve a domain's printable module by index and `domain_list` to list all registered domains. Used for dynamically associating analysis domains with their string representations during runtime.",
      "description_length": 310,
      "index": 1302,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MusteqDomain.P",
      "library": "goblint.lib",
      "description": "This module represents pairs of symbolic lvalues and provides operations for equality checking, comparison, hashing, and pretty-printing. It supports concrete data types like `V.t` for symbolic values and includes functions for serialization, testing, and XML/YoJSON output. Use cases include tracking and comparing equalities between symbolic memory locations during static analysis.",
      "description_length": 384,
      "index": 1303,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.YamlWitnessType.LocationInvariant",
      "library": "goblint.lib",
      "description": "This module defines and manipulates location-invariant records in the YAML witness format, specifically handling parsing from YAML and comparison operations. It works with the `t` type, which pairs a location with an invariant, and uses `Yaml.value` for deserialization. It is used to process and validate structured witness data in YAML files, particularly for static analysis tools that require precise location and invariant information.",
      "description_length": 440,
      "index": 1304,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Graphml.XmlGraphMlWriter",
      "library": "goblint.lib",
      "description": "This module writes GraphML documents to an output channel, supporting structured graph serialization with nodes, edges, and metadata. It operates on strings for node identifiers and attributes, enabling concrete use cases like exporting control flow graphs or data flow analysis results to GraphML format. Key operations include defining keys, writing nodes and edges with attributes, and managing graph structure with start and stop markers.",
      "description_length": 442,
      "index": 1305,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.AnalysisResult.Result",
      "library": "goblint.lib",
      "description": "This module provides hash table operations for manipulating, transforming, and merging ResultNode-keyed data structures, supporting in-place modifications and new structure creation with generic value types. It handles analysis results such as ranges and bindings, enabling traversal, sequence conversion, pretty-printing, and integration with CIL files through lazy evaluation. Utilities for safe access (via exceptionless operations) and label-based processing further support use cases in static analysis result management and transformation workflows.",
      "description_length": 555,
      "index": 1306,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Queries.ThreadNodeLattice",
      "library": "goblint.lib",
      "description": "This module provides lattice operations for combining thread-node analysis states, structured as pairs of `NFL.t` and `TC.t` types. It supports standard lattice manipulations like widening, narrowing, and comparisons, while enabling customizable expansion behavior for each component during analysis. The operations are designed for static program analysis scenarios requiring precise state merging, with additional utilities for serialization, testing, and human-readable diagnostics.",
      "description_length": 485,
      "index": 1307,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ThreadFlagDomain.Trivial",
      "library": "goblint.lib",
      "description": "This module supports abstract interpretation in multi-threaded analysis by defining lattice operations (join, meet, widen, narrow) and state checks over a type `t` representing thread flags like single, multi, and main thread states. It provides constructors for flag values and utilities for comparison, serialization, and boolean queries to determine specific thread contexts during program analysis. The operations are optimized for static analysis of concurrent programs where tracking thread interactions is critical.",
      "description_length": 522,
      "index": 1308,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.YamlWitnessType.ViolationSequence",
      "library": "goblint.lib",
      "description": "This module represents a violation sequence in a YAML witness format, organizing a list of segments containing waypoints that model program analysis violations. It provides functions to parse violation sequences from YAML, compare them, and access their content as lists of waypoints. It is used to structure and validate error traces in static analysis tools, particularly for encoding paths leading to violations in program execution.",
      "description_length": 436,
      "index": 1309,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MutexEventsAnalysis.Spec",
      "library": "goblint.lib",
      "description": "This module provides operations for tracking mutex lock and unlock events in concurrent programs using lattice-based abstract interpretation to model mutex states and execution paths. It works with abstract domains (`D.t`, `G.t`) for state representation, constraint systems (`C.t`, `P.t`), and event data (`A.t`) to analyze synchronization behavior across threads. Its primary use case is detecting race conditions and verifying thread safety by resolving lock/unlock dependencies in C code during static analysis.",
      "description_length": 515,
      "index": 1310,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.BaseInvariant.Make",
      "library": "goblint.lib",
      "description": "This module implements refinement logic for analysis invariants, focusing on value domain operations like `is_some_bot` and `apply_invariant`. It works with analysis contexts, lvals, and expressions to refine variable values during static analysis. Concrete use cases include adjusting variable domains based on conditional branches and applying expression-based invariants during flow analysis.",
      "description_length": 395,
      "index": 1311,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Constants.Spec",
      "library": "goblint.lib",
      "description": "This analysis tracks definite integer constants for local variables using intraprocedural abstract domains, providing lattice operations and transfer functions to model control-flow effects of assignments, branches, and function bodies. It operates on structured abstract states combining variable values (D), path constraints (C), and global state (G), while handling context-sensitive updates for returns, calls, and concurrency. The specification enables constant propagation optimizations and unreachable code detection in single-function scopes without interprocedural communication.",
      "description_length": 588,
      "index": 1312,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ObserverAutomaton.KMP",
      "library": "goblint.lib",
      "description": "Implements a finite automaton for detecting infeasible abstract reachability graph paths using a KMP-like algorithm. It processes transition sequences from a graph representation defined by the KMPArg module, tracking states as integers. Useful for efficiently identifying loops or invalid paths in static analysis workflows.",
      "description_length": 325,
      "index": 1313,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.AnalysisResult.ResultNode",
      "library": "goblint.lib",
      "description": "This module represents nodes in a control flow graph (CFG) for analysis results, providing operations to compare, hash, and serialize nodes. It supports data types like `MyCFG.node` and includes functionality for generating unique IDs, pretty-printing, XML output, and JSON serialization. Concrete use cases include tracking control flow during static analysis and exporting analysis results for external tools.",
      "description_length": 411,
      "index": 1314,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.LongjmpLifter.Lifter",
      "library": "goblint.lib",
      "description": "This module enables static analysis of non-local control flow in C programs involving `setjmp`/`longjmp` by defining transfer functions and context operations that model state transitions across function boundaries, thread creation, and inline assembly. It manipulates abstract domains (`D`, `G`) and analysis contexts (`ctx`) combining global state, function context, and value analysis to propagate constraints through control flow graphs. Key use cases include tracking value dependencies and synchronization points in programs with abrupt control transfers or concurrency primitives.",
      "description_length": 587,
      "index": 1315,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Callstring.Callsite",
      "library": "goblint.lib",
      "description": "This module represents individual call sites in the call string analysis, providing operations to create, compare, and serialize call site instances. It works with function definitions and analysis contexts to track calling locations during abstract interpretation. Concrete use cases include identifying unique call sites for context-sensitive analysis and generating unique identifiers for witness validation.",
      "description_length": 411,
      "index": 1316,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Graphml.DeDupGraphMlWriter",
      "library": "goblint.lib",
      "description": "This module writes deduplicated GraphML files by managing node and edge attributes with unique identifiers. It operates on custom node types and attribute maps, producing structured XML output for visualizing program analysis results. Use it to generate compact GraphML files where nodes and edges have consistent labels and metadata.",
      "description_length": 334,
      "index": 1317,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.WitnessUtil.NS",
      "library": "goblint.lib",
      "description": "This structure provides a set-like abstraction for managing collections of `Node.t` elements with support for standard operations like union, intersection, difference, and membership testing, alongside ordered traversal and transformation via mapping, filtering, and folding. It integrates sequence and list conversions while preserving uniqueness and order, with safety-conscious variants returning optional results for partial operations. Designed for scenarios requiring precise node set manipulation, such as tracking program points in witness generation or analyzing control-flow structures with guaranteed element distinctness.",
      "description_length": 633,
      "index": 1318,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Analyses.VarinfoV",
      "library": "goblint.lib",
      "description": "This module implements equality, hashing, comparison, and serialization operations for `GoblintCil.varinfo` values, primarily used to track and identify variables in constraint systems. It provides utilities to convert variable information to strings, XML, or JSON, and includes a function to check if a variable is write-only. These operations support analysis passes that require variable tracking, such as dataflow analysis or witness generation.",
      "description_length": 449,
      "index": 1319,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.WitnessUtil.YamlInvariantValidate",
      "library": "goblint.lib",
      "description": "This module controls and validates the emission of invariants in YAML witness files based on node types and locations in the control flow graph. It provides flags to enable or disable emitting invariants at loop heads, after lock operations, or other locations, and includes functions to check if a node is a loop head or located after a lock. It works directly with control flow graph nodes and location data to determine invariant placement during witness generation.",
      "description_length": 469,
      "index": 1320,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Analyses.UnitA",
      "library": "goblint.lib",
      "description": "This module defines a unit analysis with trivial equality, comparison, and hashing operations. It provides functions for pretty-printing, serialization to XML and Yojson, and includes support for QCheck arbitrary value generation. Concrete use cases include serving as a placeholder or default analysis in constraint systems where no meaningful data is required.",
      "description_length": 362,
      "index": 1321,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Uninit.Spec",
      "library": "goblint.lib",
      "description": "This module provides static analysis operations for tracking uninitialized variable states across program paths using lattice-based abstract domains. It operates on CIL expressions, function definitions, and memory-related data (like lvals, variables, and offsets) to model initialization propagation through control flow and data dependencies. Key applications include detecting unsafe uninitialized accesses, merging analysis environments, and resolving assignments or function calls within a dataflow framework.",
      "description_length": 514,
      "index": 1322,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.CompareConstraints.CompareGlobal",
      "library": "goblint.lib",
      "description": "This module compares global constraint states between two analyses, producing structured results and formatted documents that detail differences in precision and structure. It operates on global constraint data types using the `compare` function, which takes labeled analysis results and outputs a comparison report. Concrete use cases include evaluating the impact of configuration changes on analysis precision and tracking improvements across different analysis runs.",
      "description_length": 470,
      "index": 1323,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Violation.UnknownFeasibility",
      "library": "goblint.lib",
      "description": "This module checks the feasibility of a path in an abstract reachability graph (ARG) represented as a list of node-edge-node triples. It returns whether the path is feasible, infeasible (with the violating segment), or unknown. Used to validate paths during static analysis when verifying program properties.",
      "description_length": 308,
      "index": 1324,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.BaseDomain.WeakUpdates",
      "library": "goblint.lib",
      "description": "This module maintains sets of variables requiring weak updates, using a lattice-based domain to track potential duplicates during static analysis. It provides set operations like union, filtering, and membership checks over `Basetype.Variables.t`, alongside lattice combinators for merging and approximating variable states. Designed for scenarios where multiple reachable copies of variables exist, it ensures proper merging of analysis states in domains like `Base` by resolving conflicts during joins or widenings.",
      "description_length": 517,
      "index": 1325,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.MCPRegistry.PrintableOfSysVarSpec",
      "library": "goblint.lib",
      "description": "Implements analysis domains for system variables in dynamic product configurations. Uses an integer key to associate with first-class modules implementing the `Printable.S` interface. Supports querying all registered domains with their identifiers.",
      "description_length": 248,
      "index": 1326,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.YamlWitness.Validator",
      "library": "goblint.lib",
      "description": "Validates YAML witness files by checking invariants at control flow points and managing location-to-variable mappings. It ensures invariants are placed correctly relative to loops and function contracts, and confirms that specification variables correspond to valid source code locations. Used during witness validation to enforce correctness of generated witness files against program structure.",
      "description_length": 396,
      "index": 1327,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ThreadJoins.Spec",
      "library": "goblint.lib",
      "description": "This module supports operations for modeling thread lifecycle events (creation, joining, termination), synchronization primitives, and lattice-based state transitions in concurrent programs. It works with thread identifiers (TIDs), abstract domain states structured as lattices, and program constructs like expressions and function definitions to analyze synchronization effects and control flow. Its design enables clustered relational thread-modular analysis, particularly for tracking local execution traces and inter-thread dependencies in programs with dynamic thread creation and complex synchronization patterns.",
      "description_length": 619,
      "index": 1328,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.CommonPriv.ThreadDigest",
      "library": "goblint.lib",
      "description": "This module implements a thread-modular analysis digest that tracks local contributions within a thread's data structure, enabling precise join operations between thread-local states. It provides operations for equality, comparison, hashing, and serialization, along with functions to check whether one digest has fully accounted for another's contributions. It is used in relational thread-modular abstract interpretation to manage local trace information and support witness generation through unique tagging.",
      "description_length": 511,
      "index": 1329,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Analyses.Dom",
      "library": "goblint.lib",
      "description": "This module introduces a lattice structure for abstract interpretation with operations like join, meet, and widening, alongside utilities for handling lifted domains that distinguish dead code (`Bot`) and maximal information (`Top`). It manipulates a sum type encapsulating abstract values through lifting, unwrapping, and XML serialization, enabling precise static analysis of program properties. Key applications include data flow analysis and constraint system resolution where tracking value absence or extremal states is critical.",
      "description_length": 535,
      "index": 1330,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.DomainProperties.Top",
      "library": "goblint.lib",
      "description": "Implements QCheck property tests for top element behavior in lattice structures. Works with any lattice module D that includes a top value and comparison operations. Useful for verifying that D.top satisfies universal bounds and idempotent meet properties.",
      "description_length": 256,
      "index": 1331,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Signs.Signs",
      "library": "goblint.lib",
      "description": "This module represents and manipulates integer signs with three possible states: negative, zero, and positive. It provides operations for comparison, equality, conversion from integers, and ordering relations between signs. Concrete use cases include tracking the sign of variables in static analysis and determining the outcome of arithmetic comparisons in abstract interpretation.",
      "description_length": 382,
      "index": 1332,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.DomainProperties.All",
      "library": "goblint.lib",
      "description": "Implements QCheck property tests for lattice structures provided by the `D` module. Focuses on verifying core lattice operations like `leq`, `join`, and `meet` against algebraic laws. Useful for testing correctness of lattice-based abstract domains in static analysis.",
      "description_length": 268,
      "index": 1333,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.UseAfterFree.AllocaVars",
      "library": "goblint.lib",
      "description": "This module implements a lattice-based abstract domain for tracking stack-allocated variables (`alloca` variables) in C programs, primarily for use-after-free vulnerability detection. It provides lattice operations (join, meet, widen, narrow) and set-theoretic operations (union, intersection, difference) over a type representing either a set of `CilType.Varinfo.t` variables or an unbounded top element, enabling precise static analysis of variable lifetimes. The structure supports operations like membership testing, element iteration, and set partitioning, which are critical for modeling the allocation and invalidation of stack variables during analysis of pointer usage patterns.",
      "description_length": 687,
      "index": 1334,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Queries.VI",
      "library": "goblint.lib",
      "description": "The module provides lattice operations including widening, narrowing, and meet/join for a polymorphic variant type that combines bottom (`Bot`), top (`Top`), and lifted variables (`Lifted` of `Basetype.Variables.t`). It works with abstract values in static analysis contexts, enabling dataflow approximations over variable domains. This supports use cases like program analysis where abstract interpretation requires tracking variable properties through lattice-based symbolic execution.",
      "description_length": 487,
      "index": 1335,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Constraints.FromSpec",
      "library": "goblint.lib",
      "description": "Implements constraint system generation from analysis specifications by interpreting symbolic variables and CFG structures. It operates on `LVar.t` and `GVar.t` variables, producing constraint systems using analysis results from `D.t` and `G.t`. Used to build and modify global constraint systems during static analysis initialization.",
      "description_length": 335,
      "index": 1336,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.YamlWitnessType.Certification",
      "library": "goblint.lib",
      "description": "This module defines operations for parsing and serializing certification data to and from YAML format. It works with a record type containing string, type, and format fields, supporting validation and transformation of YAML values. Concrete use cases include reading certification information from YAML files and converting internal data structures to YAML for output.",
      "description_length": 368,
      "index": 1337,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.BaseDomain.DomWithTrivialExpEval",
      "library": "goblint.lib",
      "description": "This module supports lattice-based abstract interpretation with operations like join, meet, widen, and narrowing for combining and comparing abstract values. It works with a composite domain type `t` built from `PrivD.t` components, providing standard lattice primitives, equality checks, and serialization to JSON. The design enables static analysis tasks requiring hierarchical domain combinations, with utilities for debugging, testing, and XML/JSON output.",
      "description_length": 460,
      "index": 1338,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.YamlWitnessType.LoopInvariant",
      "library": "goblint.lib",
      "description": "This module defines and manipulates loop invariant data structures in the context of YAML witness files. It provides functions to parse loop invariants from YAML values and compare them, working with types that include location and invariant information. Concrete use cases include validating and processing loop invariants during static analysis of C code.",
      "description_length": 357,
      "index": 1339,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.CommonPriv.Protection",
      "library": "goblint.lib",
      "description": "This module determines variable protection status in concurrent analysis. It checks whether variables are unprotected, protected by specific locks, or unprotected except under certain conditions, using query contexts and lock domain information. Use cases include verifying thread safety of variable accesses and identifying missing lock usage in concurrent code.",
      "description_length": 363,
      "index": 1340,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.StackDomain.Dom1",
      "library": "goblint.lib",
      "description": "This module provides list manipulation utilities and lattice-theoretic operations for analyzing hierarchical variable domains in call stacks. It works with structured lists of program variables (`Var.t`) and their lattice-ordered abstractions, supporting operations like merging common prefixes/suffixes, widening/narrowing for convergence, and domain-specific joins/meets. These capabilities enable static analysis tasks such as tracking variable states across call contexts, comparing abstract program executions, and resolving variable relationships in interprocedural analysis.",
      "description_length": 581,
      "index": 1341,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.CommonPriv.WriteCenteredD",
      "library": "goblint.lib",
      "description": "This module coordinates write operations for centered difference abstractions in concurrent program analysis, managing variable-to-lockset mappings with specialized combinators for lattice joins, widening, and difference tracking. It operates on structured maps from variables to minimal locksets, integrating serialization and comparison for fixpoint stabilization in thread-modular static analysis. Concrete use cases include tracking lockset constraints during abstract interpretation and visualizing state differences across analysis iterations.",
      "description_length": 549,
      "index": 1342,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.PrivPrecCompareUtil.LV",
      "library": "goblint.lib",
      "description": "This module defines operations for comparing, hashing, and serializing location-variable pairs. It supports precise equality checks, ordering via comparison functions, and conversion to string or XML formats. Use cases include tracking variable occurrences at specific code locations during static analysis.",
      "description_length": 307,
      "index": 1343,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ArgTools.Make",
      "library": "goblint.lib",
      "description": "This module constructs bidirectional argument graphs from constraint system solutions, providing operations to create and manipulate graph structures that link program nodes with analysis results. It works with tuples of control flow graph nodes, specification contexts, and integer identifiers to represent graph nodes, and supports precise value retrieval and index queries at specific program points. Concrete use cases include building hierarchical state representations for static analysis and tracking labeled program values across interprocedural contexts.",
      "description_length": 563,
      "index": 1344,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MCPRegistry.DomListLattice",
      "library": "goblint.lib",
      "description": "This module implements lattice operations for a list of tagged domain elements, where each element is a pair of an integer tag and a polymorphic value (`(int * Obj.t) list`. It provides core lattice functionality like comparison (`leq`), combination (`join`, `meet`), approximation (`widen`, `narrow`), and extremal values (`bot`, `top`), alongside utilities for serialization, testing, and debugging structural differences. It is designed for abstract interpretation tasks involving dynamic analysis domains, enabling precise state merging and domain-specific reasoning in program analysis.",
      "description_length": 591,
      "index": 1345,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ExtractPthread.Tbls",
      "library": "goblint.lib",
      "description": "This module provides bidirectional hash tables for mapping identifiers such as thread names to IDs, mutex names to identifiers, and function calls to unique keys. It supports efficient insertion, lookup, and reverse lookup operations tailored for Pthread-to-Promela translation tasks like tracking concurrency primitives and control flow associations. Specific use cases include resolving thread identities, correlating function calls with CFG nodes, and maintaining synchronization object mappings during static analysis.",
      "description_length": 522,
      "index": 1346,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.CommonPriv.Locksets",
      "library": "goblint.lib",
      "description": "This module provides operations to retrieve the current lockset context during analysis and manage minimal locksets using lattice and set operations. It works with `MustLockset.t` values, which represent sets of locks held at a program point, and supports precise tracking of lock dependencies. These capabilities are essential for enforcing thread-modular correctness properties, such as ensuring consistent lock acquisition order and verifying that operations occur under the correct synchronization context.",
      "description_length": 510,
      "index": 1347,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.PthreadSignals.Spec",
      "library": "goblint.lib",
      "description": "This module provides static analysis functionality for tracking Pthread condition variable signal states in concurrent programs using lattice-based abstract domains (`D`, `G`) and associated constraint systems (`C`, `V`). It operates on abstract states representing signal propagation, synchronization effects, and thread interactions, with transfer functions handling control flow, thread creation, and signal events. The analysis supports verifying correctness properties like absence of missed signals or deadlocks in multi-threaded applications by modeling synchronization dependencies across function boundaries and concurrency primitives.",
      "description_length": 644,
      "index": 1348,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.IntDomainProperties.WithIkind",
      "library": "goblint.lib",
      "description": "This module provides lattice operations (leq, join, meet, widen, narrow), arithmetic (addition, division), bitwise manipulations (AND, OR, shifts), and conversions between integers, booleans, and exclusive lists. It operates on an abstract integer type `t` with HConsed-based unique tagging, emphasizing algebraic and bit-level precision. These capabilities are tailored for static analysis of C programs, enabling rigorous modeling of fixed-width integers and their overflow behavior, bitwise operations, and type-specific semantics under varying signedness and bitwidth constraints defined by the `Ikind` module.",
      "description_length": 614,
      "index": 1349,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.PrecCompare.MakeDump",
      "library": "goblint.lib",
      "description": "This module loads analysis results from files and compares abstract domain states to identify precision differences. It works with abstract domain instances stored in `Util.Dom.t Util.RH.t` structures, producing precision comparison results and formatted output. It is used for debugging and tuning static analysis precision by comparing dumped states from different analysis runs.",
      "description_length": 381,
      "index": 1350,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.SpecLifters.HashconsLifter",
      "library": "goblint.lib",
      "description": "This module provides hash-consed abstract domains with lattice operations and transfer functions for static analysis, handling program semantics like assignment, branching, and interprocedural control flow. It operates on canonicalized types for abstract values (`D.t`), variables (`V.t`), and paths (`P.t`), enabling efficient equality checks and structural sharing. Use cases include analyzing variables, expressions, and concurrency primitives while managing state transitions across function calls and thread creation.",
      "description_length": 522,
      "index": 1351,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Analyses.EmptyV",
      "library": "goblint.lib",
      "description": "This module implements an analysis value type for an empty lattice, providing equality, hashing, comparison, and serialization operations. It works with the empty type `Printable.Empty.t` and supports use cases like representing placeholder or initial states in constraint systems. Functions like `tag`, `to_yojson`, and `printXml` enable integration with external tools and analysis frameworks requiring unique identifiers or structured output.",
      "description_length": 445,
      "index": 1352,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Deadlock.Spec",
      "library": "goblint.lib",
      "description": "This module models lock acquisition events and their relationships to detect circular dependencies that could lead to deadlocks in concurrent systems. It employs data structures like `LockEventPair` for representing event pairs, `MayLockEventPairs` for managing potential lock interactions, and `Arg` for tracking lock relationships, alongside abstract domains for state management during static analysis. These components enable operations such as thread spawning, event handling, and domain-specific queries to ensure safe concurrency.",
      "description_length": 537,
      "index": 1353,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.WitnessUtil.NH",
      "library": "goblint.lib",
      "description": "This module provides imperative hash table operations for managing mappings from abstract syntax tree nodes (`Node.t`) to arbitrary values, supporting bulk modification and initialization from key-value sequences. It enables efficient data association with AST nodes, such as tracking witness invariants or intermediate analysis results, through standard operations like insertion, lookup, iteration, and in-place transformation. Use cases include aggregating node-specific metadata during static analysis or maintaining dynamic mappings for witness generation workflows.",
      "description_length": 571,
      "index": 1354,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Analyses.IdentityP",
      "library": "goblint.lib",
      "description": "This module implements lattice operations and identity-tracking utilities for abstract analysis, including join/meet combinators, widening/narrowing for convergence, and equality/hash primitives. It operates on tagged values of type `t` that preserve identity through transformations, supporting bounded lattice semantics with bottom/top elements. The design enables use cases like scalar value analysis and points-to tracking where maintaining value origins during dataflow merging is critical.",
      "description_length": 495,
      "index": 1355,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.RegionDomain.RS",
      "library": "goblint.lib",
      "description": "This module provides set-theoretic and lattice operations for managing disjoint heap regions in static analysis, supporting union, intersection, difference, and domain-specific transformations like variable elimination (`kill`) and substitution (`replace`). It operates on region sets represented as `t` values composed of `VFB` elements, which model memory regions, and maintains mappings between variables and these regions. Key use cases include tracking memory state changes during program analysis, resolving region relationships via lattice joins/meets, and handling special markers like `bullet` for region differentiation in abstract interpretation.",
      "description_length": 657,
      "index": 1356,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MyARG.CFGEdge",
      "library": "goblint.lib",
      "description": "This module represents edges in an abstract reachability graph derived from a control flow graph. It provides operations to embed control flow edges into the abstract graph and convert them to string representations. It is used to track and manipulate control flow transitions in program analysis.",
      "description_length": 297,
      "index": 1357,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.AnalysisResult.ResultType2",
      "library": "goblint.lib",
      "description": "This module defines a result type combining context, data, and function definitions, with operations for comparison, serialization, and pretty-printing. It works with tuples of types from modules `S.C`, `S.D`, and `CilType.Fundec`. Concrete use cases include representing and manipulating analysis results for C functions during static analysis.",
      "description_length": 345,
      "index": 1358,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.YamlWitnessType.Invariant",
      "library": "goblint.lib",
      "description": "This module defines and manipulates invariant data structures in a YAML-compatible format. It provides functions to convert invariant values to and from YAML representations, supporting direct serialization and deserialization. The module works with a record type containing string, type, and format fields, enabling precise handling of invariant metadata in configuration or analysis workflows.",
      "description_length": 395,
      "index": 1359,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MyARG.InterestingArg",
      "library": "goblint.lib",
      "description": "Implements analysis of abstract reachability graphs by identifying nodes of interest based on a given criterion. It traverses the graph from a main entry point using a successor function to explore reachable nodes and edges. This module is used to extract specific paths or nodes in the graph that satisfy the interestingness condition defined by the `IsInteresting` module.",
      "description_length": 374,
      "index": 1360,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.YamlWitnessType.EntryType",
      "library": "goblint.lib",
      "description": "This module defines a variant type for different kinds of entries in a YAML witness, such as location invariants, loop invariants, and violation sequences, along with operations to compare them and extract their type names. It provides functions to convert YAML values into these entry types and retrieve their string representations. It is used to parse and distinguish between various structured witness formats in YAML for program analysis.",
      "description_length": 443,
      "index": 1361,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.MCPRegistry.DomVariantPrintable",
      "library": "goblint.lib",
      "description": "This module implements a dynamically tagged analysis domain with HConsed-based unique identifiers, providing equality, hashing, comparison, and serialization operations. It works with a pair type consisting of an integer tag and a polymorphic object, enabling context-sensitive analysis tracking. Concrete use cases include managing context-identifiable analysis states in witness generation and dynamic analysis products.",
      "description_length": 422,
      "index": 1362,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ActiveLongjmp.Spec",
      "library": "goblint.lib",
      "description": "This module provides operations for tracking active `longjmp` targets in CIL code by analyzing control flow events such as function calls, returns, assignments, and branches. It operates on CIL expressions, function declarations, and lvalues, leveraging abstract domains like `D.t` and `JmpBufDomain.ActiveLongjmps.t` to model longjmp behavior. These capabilities enable interprocedural and path-sensitive static analysis of C programs, particularly for reasoning about non-local jumps during function entry/exit transitions.",
      "description_length": 525,
      "index": 1363,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Signs.SL",
      "library": "goblint.lib",
      "description": "This lattice structure supports standard lattice operations (join, meet, widen, narrow, leq), comparison, and utilities for serialization (XML, Yojson) alongside QCheck arbitraries, operating on a variant type encompassing bottom, top, and lifted integer sign values. It is designed for abstract interpretation in static analysis, particularly intraprocedural integer sign tracking, enabling program behavior reasoning through sign abstraction. The structure adheres to a lifted lattice",
      "description_length": 486,
      "index": 1364,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.DomainProperties.Equal",
      "library": "goblint.lib",
      "description": "Implements QCheck property tests for equality in lattice structures. Works with any module D that defines a lattice with an equality operation. Useful for verifying that equality behaves correctly with respect to lattice operations like join and meet.",
      "description_length": 251,
      "index": 1365,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.LocksetAnalysis.MakeMay",
      "library": "goblint.lib",
      "description": "This module provides concurrency analysis operations that track potential lock acquisitions and synchronization conflicts using abstract lock and thread identifiers. It operates on abstract domains `D` and `C`, which model sets of lock states via lattice operations, to detect race conditions and lock order violations in multithreaded programs. Key functions analyze assignments, branches, function calls, and thread spawning to reason about may-happen-before relationships and unsafe lock interactions.",
      "description_length": 504,
      "index": 1366,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Access.MemoRoot",
      "library": "goblint.lib",
      "description": "This module represents memory access roots with two variants: variables and type signatures. It provides comparison, hashing, and pretty-printing operations for these roots. Concrete use cases include tracking memory locations in static analysis and generating human-readable or machine-processable representations of access points.",
      "description_length": 332,
      "index": 1367,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ExtractPthread.Variables",
      "library": "goblint.lib",
      "description": "Tracks thread-local and global variables during Pthread program analysis. It identifies top-level variables, adds variables to thread-specific sets, and validates variable usage within threads. Used to extract Promela variables from CIL code by analyzing variable scope and thread association.",
      "description_length": 293,
      "index": 1368,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.CompareConstraints.CompareHashtbl",
      "library": "goblint.lib",
      "description": "This module implements a hash table for `Var.t` keys with structural equality and consistent hashing, optimized for constraint tracking in analysis passes. It enables efficient storage and retrieval of variable constraints using structural identity, specifically supporting operations where constraint comparisons depend on key equivalence. The table is tailored for use cases like caching or comparing abstract domain elements tied to variables in static analysis.",
      "description_length": 465,
      "index": 1369,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.UseAfterFree.ThreadIdToJoinedThreadsMap",
      "library": "goblint.lib",
      "description": "This module implements a map structure that associates thread identifiers with sets of threads requiring synchronization, enabling precise tracking of thread joining behavior in concurrent programs. It supports standard map operations, bulk updates, and lattice functions like merging and comparison, which are essential for abstract interpretation in static analysis. The structure is specifically used to model and analyze thread dependencies in OCaml programs, helping identify potential use-after-free vulnerabilities by ensuring safe memory access across thread executions.",
      "description_length": 578,
      "index": 1370,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MCPRegistry.PrintableOfMCPASpec",
      "library": "goblint.lib",
      "description": "Implements analysis domain associations for dynamic product analyses. Maps integer keys to printable domain modules and provides lookup operations. Used to register and retrieve analysis domains by identifier during static analysis execution.",
      "description_length": 242,
      "index": 1371,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.IntDomainProperties.AllNonAssoc",
      "library": "goblint.lib",
      "description": "This module defines QCheck property tests for an integer domain implementation `D`. It verifies correctness of operations like addition, subtraction, and comparison under non-associative interpretations. Use this to test algebraic consistency of custom integer abstractions in Goblint analyses.",
      "description_length": 294,
      "index": 1372,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Analyses.ValueContexts",
      "library": "goblint.lib",
      "description": "Implements value contexts for analysis by initializing and managing analysis states using a provided domain. It operates on the data type `D.t`, which represents the analysis domain. This module is used to establish initial contexts for static analysis phases, where `startcontext` creates a fresh initial state for analyzing program values.",
      "description_length": 341,
      "index": 1373,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Queries.ES",
      "library": "goblint.lib",
      "description": "This module provides set-theoretic operations and lattice manipulations for domains containing CIL expressions (`CilType.Exp.t`), supporting both concrete set operations (union, intersection, difference) and lifted lattice semantics (join, meet, widen, narrow) with extremal values (`Top`). It works with sets of expressions in a lifted domain that combines standard set structures with static analysis necessities like bottom/top elements, enabling use cases such as tracking expression membership in dataflow analysis or constraint propagation. The module also includes utilities for serialization, comparison, and generating test values, tailored for static analysis contexts requiring precise set-based reasoning.",
      "description_length": 717,
      "index": 1374,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.SymbLocksDomain.ILock",
      "library": "goblint.lib",
      "description": "This module handles symbolic lock indices and pointer values in static analysis, offering operations for equality checks, comparison, offset arithmetic, and conversions between CIL variables/expressions and symbolic representations. It works with indexed symbolic locks tied to variable metadata and memory offsets, integrating with CIL structures to model lock states in program memory. Key use cases include analyzing concurrency primitives and tracking symbolic lock ownership in abstract interpretation frameworks.",
      "description_length": 518,
      "index": 1375,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.LockDomain.AddrRW",
      "library": "goblint.lib",
      "description": "This module represents a lock domain element combining an address with read/write permissions. It supports equality checks, comparison, hashing, and pretty-printing for analysis of concurrent programs. Concrete use cases include tracking lock acquisitions and releases in static analysis of threaded code.",
      "description_length": 305,
      "index": 1376,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.RegionDomain.RegPart",
      "library": "goblint.lib",
      "description": "This module provides set-based and lattice operations for managing abstract memory regions, including union, intersection, difference, subset checks, and lattice-specific transformations like `join` and `widen`. It operates on region sets (`RS.t`) and their elements (`RS.elt`), which represent disjoint heap partitions in static analysis. The domain supports use cases such as tracking heap region equivalence classes, merging fragmented allocations, and analyzing memory safety properties through abstract interpretation.",
      "description_length": 523,
      "index": 1377,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Witness.Result",
      "library": "goblint.lib",
      "description": "This module determines and writes analysis results for specific nodes and contexts in an abstract reachability graph. It works with tuples of CFG nodes, specification contexts, and arbitrary data, producing result values and writing them to output. Concrete use cases include finalizing and exporting analysis outcomes such as value constraints or property checks at program points.",
      "description_length": 382,
      "index": 1378,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.DomainProperties.Bot",
      "library": "goblint.lib",
      "description": "Implements QCheck tests for lattice properties of a domain, including operations like `is_less`, `is_meet`, and `is_join`, ensuring correctness of bottom elements and other lattice axioms. Works directly with abstract domains that implement lattice structures, providing concrete validation for analysis domains. Useful for testing static analysis domains like integer ranges or pointer aliasing.",
      "description_length": 396,
      "index": 1379,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.StackDomain.Dom2",
      "library": "goblint.lib",
      "description": "This module provides set-like operations and lattice manipulations for tracking variable sets in abstract interpretation, supporting union, intersection, difference, and iteration over elements of type `Var.t`. It combines standard collection transformations with stack-aware functionality like predicate-based partitioning, cardinality tracking, and element selection, tailored for call stack analysis scenarios. The domain handles hierarchical relationships through lattice operations (join, meet, widen) while preserving variable set semantics in a top-lifted structure.",
      "description_length": 573,
      "index": 1380,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Server.Locator",
      "library": "goblint.lib",
      "description": "This module tracks hierarchical node data associated with CIL locations across files, supporting efficient insertion, lookup, and clearing of structured location-node mappings. It works with nested combinations of hash tables, persistent maps, and ordered sets over CIL locations and `Node.t` elements. Concrete use cases include maintaining structured program analysis data in an interactive JSON-RPC server, where precise, hierarchical node associations per source location must be dynamically updated and queried.",
      "description_length": 516,
      "index": 1381,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MyARG.CfgIntra",
      "library": "goblint.lib",
      "description": "Implements intra-procedural abstract reachability graph traversal operations. Provides functions to retrieve outgoing edges and successor nodes from a given node in the control flow graph. Useful for static analysis passes requiring local control flow exploration, such as liveness analysis or forward dataflow computations.",
      "description_length": 324,
      "index": 1382,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.RegionDomain.B",
      "library": "goblint.lib",
      "description": "This module represents a singleton domain for heap regions with only a unit value, used to model absence of region distinctions. It provides comparison, hashing, and serialization operations for this unit-based domain. Concrete use cases include serving as a placeholder or fallback region domain when region distinctions are irrelevant or unavailable.",
      "description_length": 352,
      "index": 1383,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.WitnessUtil.Locator",
      "library": "goblint.lib",
      "description": "This module manages nested key-value storage for witness generation, using file handles, source code locations, and ordered sets. It supports operations to create storage, add elements keyed by location, find optional sets by location, and clear stored data. Concrete use cases include tracking and aggregating analysis results at specific code locations across multiple files during static analysis.",
      "description_length": 400,
      "index": 1384,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.SarifType.Location",
      "library": "goblint.lib",
      "description": "This module defines a SARIF location record that includes a physical location component. It provides JSON serialization via `to_yojson`, structural equality checking with `equal`, and an alias for JSON conversion. It is used to represent and serialize source code locations in SARIF output, such as those generated during static analysis error reporting.",
      "description_length": 354,
      "index": 1385,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.StackDomain.Loc",
      "library": "goblint.lib",
      "description": "This module implements stack domain operations for location-based call stacks, providing list manipulations specific to CIL locations. It supports equality checks, comparison, hashing, and JSON serialization for location lists, along with utilities like common prefix/suffix detection and dummy list creation. Concrete use cases include tracking and comparing call paths in static analysis and generating readable or XML-formatted output for debugging.",
      "description_length": 452,
      "index": 1386,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ExpressionEvaluation.ExpEval",
      "library": "goblint.lib",
      "description": "Performs expression evaluation during static analysis by transforming CIL files based on provided queries. It processes expressions in CIL structures, applying transformations to evaluate and simplify them according to analysis results. Useful for optimizing or simplifying code during static analysis passes.",
      "description_length": 309,
      "index": 1387,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Access.TSH",
      "library": "goblint.lib",
      "description": "This module offers thread-safe hash table operations for managing key-value pairs where keys are CilType.Typsig.t signatures, supporting atomic updates, bulk insertion from sequences, and in-place transformations. It provides typed hash tables (`TSH.t`) optimized for efficient memory access tracking during static analysis, with combinators for iteration, folding, and filtered rewrites. Designed for concurrent analysis phases, it enables scalable aggregation of memory access patterns across program components.",
      "description_length": 514,
      "index": 1388,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.YamlWitness.Make",
      "library": "goblint.lib",
      "description": "This module builds and manages hierarchical YAML witnesses using imperative hash tables, function-keyed maps, and control-flow annotations. It tracks loop heads and invariant locations, manipulates nested data through node-keyed structures, and writes final YAML output. Used for generating structured verification witnesses during static analysis, enabling precise mapping between program nodes and witness metadata.",
      "description_length": 417,
      "index": 1389,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.AccessDomain.Event",
      "library": "goblint.lib",
      "description": "This module represents events related to memory accesses, capturing variable information, offsets, and access kinds. It provides operations for equality checking, comparison, hashing, and pretty-printing of access events. Concrete use cases include tracking and analyzing memory access patterns during static analysis of C code.",
      "description_length": 328,
      "index": 1390,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.VectorMatrix.ConvenienceOps",
      "library": "goblint.lib",
      "description": "This module defines infix operators for arithmetic and comparison operations on values of type `A.t`, including addition, subtraction, multiplication, division, and equality checks. It works with any data type `A.t` that supports these operations, typically numerical types. These operators improve code readability when performing calculations within modules that include `RatOps` functionality.",
      "description_length": 396,
      "index": 1391,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.AutoTune.VariableSet",
      "library": "goblint.lib",
      "description": "This module provides a set structure for handling C variables with operations like membership testing, filtering, mapping, and folding. It supports conversion between sets and sequences, enabling efficient variable tracking and transformation in autotuning scenarios that rely on syntactic heuristics for configuration optimization.",
      "description_length": 332,
      "index": 1392,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.UseAfterFree.Spec",
      "library": "goblint.lib",
      "description": "This module provides abstract interpretation techniques for detecting invalid pointer uses by analyzing memory state transitions and pointer validity. It operates on abstract data structures representing memory states, value abstractions, and context-sensitive program paths to track pointer lifetimes and concurrency interactions. Key applications include identifying use-after-free vulnerabilities through path-sensitive analysis of function calls, thread operations, and memory accesses.",
      "description_length": 490,
      "index": 1393,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.SymbLocksDomain.LockingPattern",
      "library": "goblint.lib",
      "description": "This module represents locking patterns as tuples of symbolic expressions, enabling precise tracking and comparison of lock usage contexts. It supports operations like equality checking, hashing, and pretty-printing for analysis of concurrent code, particularly for detecting lock order violations. Concrete use cases include modeling lock acquisition sequences and comparing them across program paths to ensure consistent synchronization.",
      "description_length": 439,
      "index": 1394,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.SymbLocks.Spec",
      "library": "goblint.lib",
      "description": "This module implements symbolic lockset analysis for concurrent programs by performing synchronization, lattice-based state manipulation, and lock invalidation operations on abstract lock states (PLock.t, ILock.t). It tracks per-element locking dependencies through set-theoretic combinations of lock environments and context-sensitive transitions, enabling static race detection in C device drivers by modeling dynamic locking patterns during abstract interpretation.",
      "description_length": 468,
      "index": 1395,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.DeadlockDomain.LockEvent",
      "library": "goblint.lib",
      "description": "This module represents events related to lock operations in a deadlock analysis, combining locks, control flow nodes, and memory access information. It provides comparison, hashing, and serialization functions for these events, enabling their use in sets, maps, and debugging output. Concrete use cases include tracking lock acquisition order and detecting potential deadlock cycles during static analysis.",
      "description_length": 406,
      "index": 1396,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.ExtractPthread.Resource",
      "library": "goblint.lib",
      "description": "This module represents and manipulates named resources in Pthread program analysis, specifically distinguishing between threads and functions. It provides operations to construct resource identifiers, access their components, and convert them to string representations. Used to track and display resource usage in Promela extraction, particularly for labeling and differentiating thread and function entities during analysis.",
      "description_length": 425,
      "index": 1397,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ResultQuery.NH",
      "library": "goblint.lib",
      "description": "This module implements a mutable hash table for storing and manipulating key-value pairs where keys are analysis nodes, supporting imperative operations like insertion, lookup, and in-place modification alongside functional transformations such as mapping and filtering. It provides utilities to convert between hash tables and sequential data structures, integrates with constraint system analysis workflows, and includes specialized operations for handling polymorphic values in static analysis contexts. The design emphasizes both direct mutation for efficiency and functional patterns for compositional queries, particularly in tracking analysis results over abstract domains.",
      "description_length": 680,
      "index": 1398,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.CommonPriv.ThreadNotStartedDigest",
      "library": "goblint.lib",
      "description": "This module tracks whether specific threads have been started during analysis, producing a digest that uniquely identifies the set of started threads. It provides comparison, hashing, and serialization operations for these digests, enabling precise context-sensitive analysis refinements. It is used to determine if one thread's execution context accounts for another's, refining value analysis based on thread creation state.",
      "description_length": 426,
      "index": 1399,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.YamlWitnessType.InvariantSet",
      "library": "goblint.lib",
      "description": "This module represents a set of invariants parsed from YAML witness files, working with a list-based structure of invariant data. It provides comparison operations, parsing from YAML values, and identifies the entry type for structured validation. It is used to process collections of invariants during static analysis, enabling precise handling and validation of complex invariant data.",
      "description_length": 387,
      "index": 1400,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.StackDomain.Dom3",
      "library": "goblint.lib",
      "description": "This module provides lattice-based abstract domain operations for tracking call stack information with location sensitivity. It works with a lattice structure augmented with location data, supporting operations like merging (join/meet), comparison (leq), approximation (widen/narrow), and stack updates (pushing values with locations). The design enables static analysis of program call stacks while preserving contextual precision through domain-specific top/bottom checks and difference reporting.",
      "description_length": 499,
      "index": 1401,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.WitnessConstraints.PathSensitive3",
      "library": "goblint.lib",
      "description": "This module enables path-sensitive abstract interpretation through lattice operations (join, meet, widen, narrow) and transfer functions for assignments, branches, and variable declarations, while managing contexts to track program paths and variables. It operates on abstract domains representing analysis states (`D`), constraints (`G`), contexts (`C`), variables (`V`), and paths (`P`), facilitating tasks like inter-procedural state propagation, thread handling, and witness generation for constraint solving in static analysis. Specific use cases include modeling function call effects, tracking value flows across control paths, and resolving path-dependent program invariants.",
      "description_length": 683,
      "index": 1402,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.PoisonVariables.Spec",
      "library": "goblint.lib",
      "description": "This module performs taint analysis to track variables invalidated by `setjmp`/`longjmp` interactions in C programs. It operates on abstract domains (`VS.t`, `AD.elt`, `D.t`) to model variable liveness and propagation of poisoned states through assignments, control flow, and function boundaries. The analysis ensures correctness by identifying variables requiring reinitialization after non-local jumps, critical for verifying safety in error-handling code.",
      "description_length": 458,
      "index": 1403,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Queries.VS",
      "library": "goblint.lib",
      "description": "This module provides lattice operations (join, meet, widen) and set-theoretic manipulations (union, intersection, difference) for analyzing lifted sets of C variables. It works with polymorphic variant types representing abstract domains (`Lifted` or `Top`) and concrete sets of `CilType.Varinfo.t` elements, supporting transformations like partitioning, filtering, and extremal element extraction. These capabilities are used in static analysis to model variable reachability, track data dependencies, or compute program invariants in abstract interpretation frameworks.",
      "description_length": 571,
      "index": 1404,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.YamlWitnessType.PreconditionLoopInvariant",
      "library": "goblint.lib",
      "description": "This module defines and processes structured data for preconditions and loop invariants in a YAML-based witness format. It supports parsing YAML input into a typed representation that includes location, loop invariant, and precondition fields, and provides comparison functionality for these records. It is used to validate and represent verification conditions tied to specific code locations in static analysis workflows.",
      "description_length": 423,
      "index": 1405,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MemLeak.ToppedVarInfoSet",
      "library": "goblint.lib",
      "description": "This module provides a lattice-based set structure for variable information elements, incorporating a top value to represent unknown or unbounded states. It supports operations like union, intersection, difference, and lattice join/meet, while handling the top element to model imprecise states in abstract interpretation. Designed for static analysis, it facilitates memory leak detection by enabling precise variable tracking and integrates with frameworks requiring algebraic structures through immutable set manipulations and serialization.",
      "description_length": 544,
      "index": 1406,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.WrapperFunctionAnalysis.ThreadCreateWrapper",
      "library": "goblint.lib",
      "description": "This module enables precise concurrency analysis by abstracting symbolic thread identifiers and handling thread state transitions through lattice-based operations. It works with CIL expressions, function declarations, and thread state data structures (`D.t`, `G.t`, `C.t`, `V.t`) to model thread creation, synchronization, and execution contexts. Specific use cases include static analysis of multithreaded C programs to track thread spawning, shared memory accesses, and program point transfers for detecting race conditions or deadlocks.",
      "description_length": 539,
      "index": 1407,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MyARG.UnCilTernaryIntra",
      "library": "goblint.lib",
      "description": "Traverses intra-procedural control flow graphs using ternary analysis, determining possible successor edges and nodes. It operates on control flow graph nodes and edges, specifically analyzing reachability within a single function. This module is used to compute abstract reachability paths for static analysis, such as tracking data flow or identifying potential execution paths in a function.",
      "description_length": 394,
      "index": 1408,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Assert.Spec",
      "library": "goblint.lib",
      "description": "This module provides abstract interpretation domains and semantic transfer functions to model and verify assertion behavior during static analysis. It operates on lattice structures, context-tracking mechanisms, constraint variables, and path identifiers to capture program states, with specialized handling for CIL expressions, function calls, and control flow transitions. Its utilities enable precise assertion outcome analysis for scenarios like branching conditions, function returns, and thread creation in low-level code verification.",
      "description_length": 541,
      "index": 1409,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.IntDomainProperties.Valid",
      "library": "goblint.lib",
      "description": "Implements QCheck property tests for integer domain operations using concrete domains (CD), abstract domains (AD), and analysis frameworks (AF). It verifies correctness of integer value manipulations and domain-specific behaviors through property-based testing. Useful for validating domain implementations against expected semantic properties.",
      "description_length": 344,
      "index": 1410,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.CommonPriv.ConfCheck",
      "library": "goblint.lib",
      "description": "This module validates configuration settings for thread-modular value analysis, enforcing constraints on mutex activation, path-sensitive initialization, and thread flag setup. It operates on internal analysis parameters and configuration structures used by `BasePriv` and `RelationPriv`. Concrete use cases include blocking analysis execution until required mutex and thread sensitivity options are properly enabled in the configuration.",
      "description_length": 438,
      "index": 1411,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.WideningTokenLifter.Lifter",
      "library": "goblint.lib",
      "description": "This module extends abstract domains with widening tokens to delay convergence during fixed-point iterations, providing lattice operations and transfer functions that manage token sets to control when widening occurs. It operates on lifted abstract states, global",
      "description_length": 263,
      "index": 1412,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MutexAnalysis.Spec",
      "library": "goblint.lib",
      "description": "This module provides concurrency analysis operations for reasoning about mutex usage in multithreaded programs, including lattice-based state manipulation, thread lifecycle management, and lockset statistics tracking. It works with abstract domains representing must-locksets and protecting locksets, combined with mutable lock maps to model shared state between threads. Specific functionalities include handling memory accesses under locks, propagating lock constraints across function calls, and quantifying lock contention metrics to verify thread safety properties like mutual exclusion and data race freedom.",
      "description_length": 614,
      "index": 1413,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.DeadlockDomain.MayLockEvents",
      "library": "goblint.lib",
      "description": "This module provides lattice operations (join, meet, widening, narrowing) and set-like manipulations (union, intersection, difference) for a data structure representing either a collection of lock events or a top element. This facilitates abstract interpretation tasks such as merging and comparing states in deadlock analysis, where tracking potential lock acquisition sequences helps identify conflicting synchronization patterns in concurrent programs.",
      "description_length": 455,
      "index": 1414,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MCPRegistry.DomVariantSysVar",
      "library": "goblint.lib",
      "description": "This module represents system variables in a dynamic analysis context, where each variable is uniquely identified by a combination of an integer tag and an abstract value. It provides operations for comparing, hashing, and serializing these variables, along with utilities for generating arbitrary instances and checking write-only status. Concrete use cases include tracking and managing variable states during abstract interpretation and analysis composition in Goblint.",
      "description_length": 472,
      "index": 1415,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.AutoTune.FunctionSet",
      "library": "goblint.lib",
      "description": "This module provides a functional set interface for managing collections of C variables (`CilType.Varinfo.t`) with operations like union, intersection, and difference, alongside transformations such as mapping and filtering. It supports sequence conversions for ordered traversal and bulk construction, enabling efficient analysis of variable interactions in autotuning scenarios. These capabilities are particularly useful for tracking variable usage patterns or dependencies in C code during static analysis-driven configuration optimization.",
      "description_length": 544,
      "index": 1416,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.LockDomain.MustLocksetRW",
      "library": "goblint.lib",
      "description": "This module implements a lattice-based domain for analyzing sets of must-read/write locks, combining standard set operations (union, intersection, difference) with lattice-specific methods (join, meet, widen) and domain utilities (top/bot elements, serialization). It operates on a polymorphic variant type representing either a concrete set of lock dependencies (`Lifted`) or an abstract top value, enabling precise static analysis of concurrency constraints. Key use cases include tracking lock acquisition patterns and enforcing thread-safety invariants within abstract interpretation frameworks.",
      "description_length": 599,
      "index": 1417,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Queries.TS",
      "library": "goblint.lib",
      "description": "This module supports lattice operations (join, meet, widen) and set manipulations (union, intersection, partition) over type sets derived from CIL types. It works with a lifted domain structure representing sets of `CilType.Typ.t` values, enabling precise tracking and transformation of type information. These capabilities are particularly useful in static analysis for querying type relationships, aggregating type possibilities, and decomposing sets for iterative analysis passes.",
      "description_length": 483,
      "index": 1418,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.YamlWitnessType.Producer",
      "library": "goblint.lib",
      "description": "This module provides functions to convert a producer record to and from YAML format. It works with the `t` type, which includes fields like name, version, and optional command line. Use this module when serializing or deserializing producer metadata to YAML, such as when reading or writing witness files.",
      "description_length": 305,
      "index": 1419,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.DomainProperties.Leq",
      "library": "goblint.lib",
      "description": "Implements QCheck property tests for lattice operations, specifically verifying the `leq` (less than or equal) relation and its interactions with `join` and `meet`. Works with lattice elements from the provided module `D`. Useful for testing correctness of lattice implementations in abstract interpretation frameworks.",
      "description_length": 319,
      "index": 1420,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ResultQuery.Query",
      "library": "goblint.lib",
      "description": "This module performs local and global queries on a constraint system solution, providing functions to retrieve results for specific variables, nodes, or the entire system. It operates on constraint graphs, variable identifiers, and node representations within a solver context. Use it to extract precise analysis results during or after constraint resolution, such as variable values at specific program points or global solution summaries.",
      "description_length": 440,
      "index": 1421,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.YamlWitnessType.FlowInsensitiveInvariant",
      "library": "goblint.lib",
      "description": "This module defines a YAML witness type for flow-insensitive invariants, including parsing from YAML values and comparison operations. It works with the `t` record type containing an `Invariant.t` value. Used to represent and validate invariants that do not depend on program flow in a YAML-based witness format.",
      "description_length": 312,
      "index": 1422,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.CommonPriv.PerMutexTidCommon",
      "library": "goblint.lib",
      "description": "This module implements thread-modular static analysis utilities for tracking mutex and thread states in concurrent programs. It provides lattice structures and operations for modeling synchronization constraints, including per-mutex and per-thread data tracking, lock set manipulations, and abstract state merging. Concrete use cases include verifying thread-specific ownership of shared resources, analyzing lock acquisition patterns, and merging abstract interpretation states during concurrent execution path analysis.",
      "description_length": 521,
      "index": 1423,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Queries.FlatYojson",
      "library": "goblint.lib",
      "description": "This module supports lattice operations (join, meet, widen, narrow) and comparisons (leq, equal) on a flat lattice structure for Yojson values, represented via Bot, Lifted, and Top constructors. It operates on polymorphic variants encoding these lattice elements, enabling abstract interpretation tasks like merging or comparing JSON-based abstract states in static program analysis. Key use cases include lifting JSON values into lattice elements, checking extremal states (bot/is_top), and converting results to JSON or string representations for analysis reporting.",
      "description_length": 568,
      "index": 1424,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.RegionDomain.Reg",
      "library": "goblint.lib",
      "description": "This module provides lattice operations (meet, join, widen, narrow) and manipulation utilities (variable removal, expression evaluation, closure computation) for region-based abstract domains. It operates on composite structures combining `RegPart.t` (region partitioning) and `RegMap.t` (region-to-value mappings), enabling analysis of heap regions and their relationships with program variables. Specific use cases include tracking ownership of disjoint heap regions and identifying global variables associated with specific regions during abstract interpretation.",
      "description_length": 566,
      "index": 1425,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MCPRegistry.GlobalDomainListSpec",
      "library": "goblint.lib",
      "description": "Implements a list-based specification for managing a collection of lattice domains indexed by integers. Provides operations to retrieve a specific domain by index and list all registered domains with their indices. Used to define and access multiple abstract domains in a dynamic analysis product configuration.",
      "description_length": 311,
      "index": 1426,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Server.Registry",
      "library": "goblint.lib",
      "description": "This module manages a registry of JSON-RPC request handlers, mapping string identifiers to modules implementing the `Request` signature. It provides operations to create a new registry and register individual request handlers. Concrete use cases include setting up an interactive server with dynamically extensible command handling, such as adding analysis control or query endpoints in a Goblint-based tool.",
      "description_length": 408,
      "index": 1427,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MyARG.StackNode",
      "library": "goblint.lib",
      "description": "This module represents stack-like paths in an abstract reachability graph, where each path is a list of nodes. It provides operations to compare, hash, and move along paths, as well as extract components like the current CFG node, context ID, and path ID. Concrete use cases include tracking call stack contexts during static analysis and enabling path-sensitive reasoning in reachability checks.",
      "description_length": 396,
      "index": 1428,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.WideningToken.Uuid",
      "library": "goblint.lib",
      "description": "This module implements UUID-based widening tokens used to track and manage unique identifiers during abstract interpretation. It provides operations for equality checking, hashing, comparison, and string representation of UUIDs, along with support for serialization to XML and Yojson formats. These tokens are used to identify and distinguish different widening contexts in the analysis, ensuring precise handling of recursive or looping structures.",
      "description_length": 449,
      "index": 1429,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Analyses.GVarFC",
      "library": "goblint.lib",
      "description": "This module defines a polymorphic sum type `t` that represents either a value of type `V.t` or a function-declaration-and-context pair. It provides operations to compare, hash, and pretty-print these values, along with utilities to extract identifiers, determine write-only status, and generate XML or JSON representations. Concrete use cases include tracking variable and function context in static analysis constraint systems.",
      "description_length": 428,
      "index": 1430,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.LockDomain.MustLock",
      "library": "goblint.lib",
      "description": "This module provides operations for a lock domain that tracks variable- and offset-indexed lock values, supporting equality checks, comparisons, and conversions to CIL representations. It establishes bidirectional mappings between abstract lock values (`MustLock.t`) and both memory values (`Mval.t`) and variable metadata, enabling precise analysis of lock acquisition and release patterns in concurrent programs. The domain is specifically designed for static analysis scenarios where tracking lock ownership and usage across threads is critical.",
      "description_length": 548,
      "index": 1431,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MCPAccess.A",
      "library": "goblint.lib",
      "description": "This module defines a list-based structure `t` for tracking memory access metadata, where each element is a pair of an integer and an object. It provides operations for equality checking, hashing, comparison, and serialization to XML and JSON formats. Key functions include `may_race` for detecting potential memory races between access lists and `unop_fold` and `binop_for_all` for folding and comparing access elements.",
      "description_length": 421,
      "index": 1432,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ExtractPthread.Codegen",
      "library": "goblint.lib",
      "description": "This module generates Promela code from Pthread program analyses by mapping control flow and concurrency operations to Promela constructs. It uses internal mappings and string transformations to produce labeled edges, control structures, and thread actions in Promela syntax. Concrete use cases include translating thread synchronization points into Promela `goto` labels, generating `if` clauses for control flow, and emitting runnable `run` statements for threads.",
      "description_length": 466,
      "index": 1433,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Access.Memo",
      "library": "goblint.lib",
      "description": "This module represents memory locations formed by pairing a root identifier with an offset. It supports operations to create, compare, hash, and pretty-print these locations, as well as convert them to other representations like strings or JSON. It is used to track and manipulate memory accesses during static analysis, particularly when reasoning about pointer values and their associated types.",
      "description_length": 397,
      "index": 1434,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Access.AS",
      "library": "goblint.lib",
      "description": "This module provides a lattice-based set structure for managing collections of memory access elements, supporting operations like union, intersection, inclusion checks, and extremal element selection. It works with ordered elements representing memory accesses, enabling efficient partitioning, cardinality queries, and conversion to ordered lists. Designed for abstract interpretation in static analysis, it facilitates tracking and merging sets of memory accesses during program verification tasks.",
      "description_length": 500,
      "index": 1435,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.SarifType.Tool",
      "library": "goblint.lib",
      "description": "This module defines a tool component within the SARIF format, specifically encapsulating a `driver` of type `ToolComponent.t`. It provides functions to convert the tool structure to a Yojson representation for serialization. This is used to represent analysis tools in SARIF output, such as Goblint itself, including metadata like name, version, and rules.",
      "description_length": 356,
      "index": 1436,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.LocksetAnalysis.Make",
      "library": "goblint.lib",
      "description": "This module provides operations for tracking lock acquisition and release patterns, analyzing thread synchronization, and resolving context-sensitive control flow in concurrent programs. It operates on abstract domains representing lock states, CIL expressions and statements, and a lattice-based structure for hierarchical precision in combining divergent execution paths. It is particularly used for static detection of concurrency bugs like deadlocks and race conditions in C programs through precise interprocedural analysis.",
      "description_length": 529,
      "index": 1437,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.RaceAnalysis.Spec",
      "library": "goblint.lib",
      "description": "This module provides hierarchical memory access tracking and race detection through trie-structured offset analysis combined with type-based suffix decomposition. It operates on memory locations (memos) composed of roots and offsets, using enriched trie structures to manage nested access patterns and lattice-based merging of access states across scopes. The implementation enables precise race reporting at intersections of prefix and type suffix hierarchies, specifically targeting static analysis of concurrent C programs where overlapping memory accesses require contextualized conflict resolution without redundant checks.",
      "description_length": 628,
      "index": 1438,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MayLocks.Spec",
      "library": "goblint.lib",
      "description": "The module provides concurrency analysis operations that track potential lock states using lattice-based abstract domains, modeling sets of locks that may be held during execution. It supports operations for thread spawning, context initialization, and lock state transitions, enabling static verification of lock usage patterns such as race detection and prevention of double locking in concurrent programs.",
      "description_length": 408,
      "index": 1439,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Analyses.UnitP",
      "library": "goblint.lib",
      "description": "This module implements a singleton analysis domain with unit type values, providing identity operations and standard type class instances. It works exclusively with the unit type, offering comparison, hashing, pretty-printing, and serialization functions. Useful for analyses that track presence or absence of properties without requiring data, such as reachability or liveness analyses.",
      "description_length": 387,
      "index": 1440,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Analyses.VarF",
      "library": "goblint.lib",
      "description": "This module pairs analysis data with control-flow graph nodes, enabling tracking of dataflow facts at specific program points. It provides operations to access node locations, generate XML output, and extract variable identifiers, supporting precise analysis of variable usage and modification. It is used for implementing and debugging dataflow analyses that require associating values with CFG nodes.",
      "description_length": 402,
      "index": 1441,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.SarifType.ReportingDescriptor",
      "library": "goblint.lib",
      "description": "This module defines a data structure for representing SARIF reporting descriptors, including fields like rule ID, name, descriptions, and help links. It provides functions to convert these descriptors to Yojson format for serialization. Used to standardize and document analysis rules in SARIF output, such as for static code analysis tools reporting specific code issues with detailed explanations.",
      "description_length": 399,
      "index": 1442,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.WitnessUtil.InvariantParser",
      "library": "goblint.lib",
      "description": "This module provides functions to parse expressions from CABS and CIL code within the context of a witness invariant. It operates on environments and global variables extracted from CIL files, supporting expression validation and transformation. It is used to process and verify invariants at specific code locations during witness generation.",
      "description_length": 343,
      "index": 1443,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Access.WarnAccs",
      "library": "goblint.lib",
      "description": "This module tracks sets of memory accesses categorized by their position in a trie structure, distinguishing between current node accesses, prefix accesses, type suffixes, and their combinations. It provides operations to compute differences between access sets, unify all accesses, check emptiness, and format access information for reporting. It is used to detect and warn about potential data races by analyzing overlapping memory access patterns in concurrent contexts.",
      "description_length": 473,
      "index": 1444,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.SarifType.PhysicalLocation",
      "library": "goblint.lib",
      "description": "Handles physical location data in SARIF format, including artifact paths and source code regions. Provides JSON serialization via `to_yojson` and equality checking via `equal`. Used to represent and compare file and region information for analysis results.",
      "description_length": 256,
      "index": 1445,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Graphml.EnumerateNodeGraphMlWriter",
      "library": "goblint.lib",
      "description": "Writes GraphML files by enumerating nodes and edges with customizable attributes. It handles node and edge data through user-provided `N` and `M` modules, supporting structured metadata and key-value pairs. Useful for exporting analysis results or control flow graphs to GraphML format for visualization or further processing.",
      "description_length": 326,
      "index": 1446,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.YamlWitnessType.Task",
      "library": "goblint.lib",
      "description": "This module defines operations for converting a task record to and from YAML format. It works with the `t` type, which includes input files, file hashes, data model, language, and an optional specification. Concrete use cases include serializing task data for storage or transmission and deserializing YAML input into structured task values for processing.",
      "description_length": 356,
      "index": 1447,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ExtractPthread.Action",
      "library": "goblint.lib",
      "description": "This module defines a polymorphic variant type `t` representing individual actions in Pthread program analysis, such as thread creation, mutex operations, condition variable waits, and function calls. It works with structured data types including `thread`, `cond_wait`, and identifiers for threads, mutexes, condition variables, and function calls. Concrete use cases include modeling control flow and synchronization primitives during Promela extraction for model checking concurrent C programs.",
      "description_length": 496,
      "index": 1448,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.IntDomainProperties.All",
      "library": "goblint.lib",
      "description": "Implements QCheck property tests for integer domain implementations, ensuring correctness of operations like addition, subtraction, and comparison. Works with integer domains that conform to the `D` module signature, validating their behavior against standard arithmetic properties. Useful for testing custom integer abstractions in static analysis tools.",
      "description_length": 355,
      "index": 1449,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Vla.Spec",
      "library": "goblint.lib",
      "description": "This interface provides operations for static analysis of variable-length arrays (VLAs) in C code, including initialization, assignment, branching, function handling, thread management, and context transitions. It operates on abstract analysis states, CIL expressions/fundecs, and environment mappings to track VLA properties across scopes and execution paths. The design supports use cases like detecting out-of-bounds accesses, tracking dynamic array sizes, and verifying safety properties in programs with stack-allocated dynamic arrays.",
      "description_length": 540,
      "index": 1450,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.TmpSpecial.Spec",
      "library": "goblint.lib",
      "description": "This module provides operations for tracking equivalences between variables and math library call results, managing expression-to-dependency mappings to enable change-sensitive invalidation. It works with CIL expressions, analysis contexts, and lattice-based dependency structures to model relationships across function calls, assignments, and control flow events. The functionality supports static analysis of numerical computations where maintaining or invalidating equivalences depends on precise tracking of variable modifications and program state transitions.",
      "description_length": 565,
      "index": 1451,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.TaintPartialContexts.Spec",
      "library": "goblint.lib",
      "description": "This module defines a specification for tracking taint propagation through program execution by managing abstract states (`D.t`) that model how values become tainted. It provides operations to handle variable assignments, function calls, control flow divergence, and thread lifecycle events, while interacting with CIL expressions and function declarations to model data flow. The analysis supports use cases like identifying tainted variable modifications in functions and tracing untrusted data flows across control structures.",
      "description_length": 529,
      "index": 1452,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.ExtractPthread.Spec",
      "library": "goblint.lib",
      "description": "This module defines abstract interpretation domains and lattice-based concurrency analysis operations for tracking thread interactions and synchronization states in Pthread programs. It manipulates specification elements, constraint variables, and hierarchical analysis states (`D.t`, `G.t`) to model program behavior during function calls, thread creation, and event handling. The operations directly support Promela translation and static detection of concurrency issues like race conditions through precise state transfer and context-sensitive analysis.",
      "description_length": 556,
      "index": 1453,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.TerminationPreprocessing.VarToStmt",
      "library": "goblint.lib",
      "description": "This module implements a dictionary mapping C variables to arbitrary values, supporting key-based operations like insertion, lookup, transformation, and bulk iteration. It provides specialized tools for managing associations between variables and statements in termination logic, such as tracking control flow dependencies or aggregating variable usage patterns. The structure enables efficient traversal, filtering, and conversion to sequences, tailored for preprocessing tasks that analyze termination conditions in program analysis.",
      "description_length": 535,
      "index": 1454,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MCPRegistry.AccListSpec",
      "library": "goblint.lib",
      "description": "Implements a list-based accumulator for analysis domains in a dynamic product setting. It provides operations to associate analysis modules with integer keys and retrieve them in a list format. Useful for managing and iterating over multiple analysis configurations in static analysis toolchains.",
      "description_length": 296,
      "index": 1455,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.CommonPriv.MustVars",
      "library": "goblint.lib",
      "description": "This module implements a set-like abstract data type for managing variables in static analysis, offering operations for creation, modification, set-theoretic manipulation, and lattice-based abstract interpretation. It operates on `MayVars.t` sets containing `MustVars.elt` elements, which represent tracked variables in thread-modular analyses, and supports transformations like widening/narrowing for data flow convergence. The utilities enable reasoning about must/may variable dependencies in concurrent programs, with applications in difference tracking, XML serialization, and property testing for analysis correctness.",
      "description_length": 624,
      "index": 1456,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Svcomp.StackTaskResult",
      "library": "goblint.lib",
      "description": "This module processes SV-COMP task results by analyzing control flow graph (CFG) structures using `Arg.Node.t` and `Arg.Edge.t` types. It provides `invariant`, `is_violation`, and `is_sink` to determine analysis states, check for property violations, and identify terminal nodes in the CFG. Use cases include validating program paths during abstract interpretation and assessing result completeness based on CFG traversal.",
      "description_length": 422,
      "index": 1457,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.LoopfreeCallstring.Spec",
      "library": "goblint.lib",
      "description": "This module provides operations for collapsing recursive call cycles into sets during context-sensitive static analysis, using lattice structures (D, G) and callstring management (C) to track function contexts. It handles control flow transfers, thread operations, and event handling through transfer functions that compute caller/callee interactions, supporting precise analyses like points-to analysis and thread-modular verification. By combining local and global state transitions, it improves efficiency in recursive or cyclic call scenarios while maintaining precision for context-sensitive program properties.",
      "description_length": 616,
      "index": 1458,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.DeadCode.RemoveDeadCode",
      "library": "goblint.lib",
      "description": "Performs dead code elimination on CIL files by removing unreachable functions and code fragments. It operates directly on CIL file structures, leveraging reachability analysis to identify and eliminate unused code. Useful for reducing binary size and improving analysis efficiency in static analysis pipelines.",
      "description_length": 310,
      "index": 1459,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MutexAnalysis.VarSet",
      "library": "goblint.lib",
      "description": "This module provides set-theoretic and lattice-based operations on collections of variables drawn from `Basetype.Variables.t`, including union, intersection, difference, and extremal element detection. It supports concurrency analysis by modeling variable interactions in mutex-related contexts, such as tracking lock-protected variables or analyzing locking discipline. The implementation leverages a specialized set structure for efficient manipulation within static analysis frameworks requiring precise variable state tracking.",
      "description_length": 531,
      "index": 1460,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MCPRegistry.DomListPrintable",
      "library": "goblint.lib",
      "description": "This module implements operations for a list of tagged abstract values, including equality, hashing, comparison, and serialization to string, XML, and JSON. It supports structured pretty-printing and context identification via unique tags. Concrete use cases include managing and comparing dynamic analysis contexts in witness generation and verification tasks.",
      "description_length": 361,
      "index": 1461,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.StackTrace.Spec1",
      "library": "goblint.lib",
      "description": "This module provides lattice operations (join, meet, widen) and context-sensitive analysis capabilities for abstract call stack states, with support for hierarchical stack trace manipulation through a core data type featuring top/bottom sentinels. It enables static analysis tasks like control flow tracking, concurrency handling via thread operations, and call graph resolution through structural transformations and context management primitives. The implementation leverages modules for equality checks, serialization, and structural manipulations to support complex analysis scenarios involving function calls and synchronization events.",
      "description_length": 641,
      "index": 1462,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.MyARG.Stack",
      "library": "goblint.lib",
      "description": "Implements a stack-based exploration of nodes in an abstract reachability graph. Provides `main_entry` as the starting point and `next` to retrieve outgoing edges and adjacent nodes. Used for traversing control flow graphs in static analysis, where each node represents a program point and edges represent control flow transitions.",
      "description_length": 331,
      "index": 1463,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.SarifType.Region",
      "library": "goblint.lib",
      "description": "This module defines a data structure for representing source code region information with start and end line and column numbers. It includes functions for converting region data to JSON format and comparing regions for equality. This is used to encode precise source locations in SARIF output for static analysis tools.",
      "description_length": 319,
      "index": 1464,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MCPRegistry.VarListSpec",
      "library": "goblint.lib",
      "description": "Implements variable list specifications for analysis domains in a dynamic product setting. It associates integer keys with analysis modules that conform to the `SpecSysVar` interface and provides access to a list of these domain associations. Useful for managing and querying multiple analysis configurations within a modular analysis framework.",
      "description_length": 345,
      "index": 1465,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Taint.Spec",
      "library": "goblint.lib",
      "description": "This module implements a taint analysis framework using lattice-based abstract domains to track data flow sensitivity across function boundaries. It operates on CIL expressions and function definitions with state representations like `D.t` and `G.t`, enabling interprocedural analysis through transfer functions for assignments, control flow, and function calls. Key applications include detecting tainted data propagation in C programs and generating analysis witnesses for verification purposes.",
      "description_length": 497,
      "index": 1466,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.SpecLifters.LimitLifter",
      "library": "goblint.lib",
      "description": "This module governs transfer functions and domain operations to restrict widening iterations during abstract interpretation, interacting with lattice structures (`G.t`), analysis contexts (`C.t`), constraint variables (`V.t`), and abstract states (`S.D.t`). It is specifically applied in static analysis scenarios requiring bounded widening, such as function call handling, thread state synchronization, and fixed-point convergence enforcement under resource constraints.",
      "description_length": 471,
      "index": 1467,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.SpecLifters.HashconsContextLifter",
      "library": "goblint.lib",
      "description": "This module supports hash-consing of analysis contexts to enable context-sensitive static analysis, managing constraint variables (`V.t`) and program states (`D.t`, `C.t`) through transfer functions for program constructs and interprocedural operations. It operates on abstract domains, global stores (`G`), and value types, providing efficient equality checks and serialization for scalable dataflow analysis in frameworks handling function calls, threads, and event-driven state transitions.",
      "description_length": 493,
      "index": 1468,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MusteqDomain.VF",
      "library": "goblint.lib",
      "description": "This module provides operations for comparing, combining, and transforming symbolic lvalue identifiers paired with field/index offsets or no offset, using typed tuples of variables (`V.t`) and offset tags (`Field`, `Index`, `NoOffset`). It supports abstract interpretation by enabling equality tracking and offset-aware modifications, useful for static analysis tasks like aliasing, memory safety, or symbolic execution where precise handling of structured data and pointer arithmetic is required.",
      "description_length": 497,
      "index": 1469,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.WideningToken.Index",
      "library": "goblint.lib",
      "description": "This module represents optional integer indices used in widening operations, providing equality checks, comparison, hashing, and serialization functions. It works with lifted integer domains to track or abstract positions in data structures like arrays or sequences. Concrete use cases include managing iteration points in abstract interpretation or symbolic execution where optional indices represent known or unknown positions.",
      "description_length": 429,
      "index": 1470,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.MyARG.Intra",
      "library": "goblint.lib",
      "description": "Implements abstract reachability graph traversal within a single function. Provides entry points and transition logic for exploring nodes connected by edges in an intra-procedural context. Useful for analyzing control flow and data dependencies in individual functions.",
      "description_length": 269,
      "index": 1471,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Control.AnalyzeCFG",
      "library": "goblint.lib",
      "description": "This module analyzes control flow graphs using abstract interpretation to solve constraints derived from program paths. It works with CFG structures, variable mappings, and analysis results to perform dataflow computations like constant propagation and reaching definitions. Concrete use cases include static analysis optimizations, post-analysis pruning, and verification of abstract interpretation outcomes.",
      "description_length": 409,
      "index": 1472,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Preprocessor.FpathH",
      "library": "goblint.lib",
      "description": "This module enables imperative and functional manipulation of hash tables mapping file paths (`Goblint_std.GobFpath.t`) to polymorphic values, supporting operations like insertion, filtering, merging, and in-place transformations. It emphasizes heterogeneous key-value handling with infix syntax for access and modification, alongside exception-safe preprocessing workflows for C file path resolution. Use cases include tracking source file dependencies, caching preprocessing results, and managing dynamic file path mappings during compiler analysis.",
      "description_length": 551,
      "index": 1473,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Timeout.Js",
      "library": "goblint.lib",
      "description": "Implements timeout handling with JavaScript-style timers. Provides functions to set and clear timeouts using system threads and clocks. Useful for enforcing time limits on computations in interactive or event-driven applications.",
      "description_length": 229,
      "index": 1474,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ThreadFlag.Spec",
      "library": "goblint.lib",
      "description": "This module provides operations for analyzing and managing multi-threaded program behavior by tracking abstract thread flag states (`D.t`) and thread state transitions (`Flag.t`) using lattice operations. It supports concurrency analysis in static frameworks by handling thread creation, synchronization, and race condition detection, with functions for managing thread IDs, thread-local states, and interactions like spawn, exit, and morph transitions. Key use cases include static analysis of concurrent code, tracking thread lifecycles, and identifying synchronization bottlenecks or data races.",
      "description_length": 598,
      "index": 1475,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.MCPRegistry.LocalDomainListSpec",
      "library": "goblint.lib",
      "description": "Implements a list-based specification for managing multiple abstract domains in a dynamic analysis product. Associates domain identifiers with lattice modules and provides operations to retrieve and iterate over these associations. Used to configure and activate combinations of analyses at runtime based on domain IDs.",
      "description_length": 319,
      "index": 1476,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.RegionDomain.RegMap",
      "library": "goblint.lib",
      "description": "This domain provides a map-based structure for associating variables with region sets, supporting precise heap region tracking through operations like insertion, lookup, and iteration alongside lattice-based merging (join/meet) and transformation. It manipulates maps where regions index abstract values, enabling static analysis workflows such as fixpoint computation, state combination, and difference visualization with specialized handling for extremal values (bottom/top) and algebraic operations. Key use cases include abstract interpretation tasks requiring disjoint heap region modeling and region-guided value propagation.",
      "description_length": 631,
      "index": 1477,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Expsplit.Spec",
      "library": "goblint.lib",
      "description": "This module enables path-sensitive static analysis by tracking expression values across program paths using abstract domains and constraint propagation. It operates on context-aware abstract states, lattices, and constraint variables to model control-flow transitions, function calls, and thread synchronization. Specific applications include context-sensitive data flow analysis, fixed-point computation for loops, and concurrency modeling through path representatives and domain-specific abstractions.",
      "description_length": 503,
      "index": 1478,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.LockDomain.MustLockset",
      "library": "goblint.lib",
      "description": "This module defines operations for analyzing must-locked locksets in concurrent programs, using a variant type that represents either a concrete set of locks (via a set domain) or an abstract top value denoting all possible locks. It provides set-theoretic manipulations (union, intersection, membership checks), lattice operations (join, meet, widening), and domain-specific utilities like pretty-printing and comparison, all tailored to track lock states in static analysis. These capabilities enable reasoning about lock acquisition patterns and enforcing thread safety guarantees in abstract interpretation frameworks.",
      "description_length": 622,
      "index": 1479,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.SarifType.Invocation",
      "library": "goblint.lib",
      "description": "Handles serialization of SARIF invocation data to JSON format. Works with the `t` record type containing `commandLine` and `executionSuccessful` fields. Used to convert tool invocation results into a structured JSON representation for SARIF output files.",
      "description_length": 254,
      "index": 1480,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ActiveSetjmp.Spec",
      "library": "goblint.lib",
      "description": "This module specifies abstract interpretation operations for tracking `setjmp`/`longjmp` control flow in C programs using lattice-based domains. It manipulates abstract states (`D.t`) to model buffer lifetimes and control transitions during static analysis of CIL code, handling concurrency and context-sensitive state combinations. The analysis supports queries and state management for active setjmp buffers in complex control flow scenarios, including function calls, branches, and thread entry/exit.",
      "description_length": 503,
      "index": 1481,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.CommonPriv.MayVars",
      "library": "goblint.lib",
      "description": "This module provides lattice and set operations for tracking variable sets in thread-modular analysis, supporting operations like union, intersection, and element selection alongside lattice joins/meets. It works with a custom abstract domain (`MayVars.t`) representing either a set of `Basetype.Variables.t` or a top element, offering utilities for cardinality queries, element iteration, and string conversion. It is particularly used in static analysis to model variables potentially affected by concurrent operations or dataflow in a thread-modular context.",
      "description_length": 561,
      "index": 1482,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.DomainProperties.Narrow",
      "library": "goblint.lib",
      "description": "Implements narrowing operations for lattice domains, generating QCheck tests to verify correctness. Works with lattice structures defined by the D module, ensuring properties like idempotence and monotonicity. Useful for validating abstract interpretation domains in static analysis.",
      "description_length": 283,
      "index": 1483,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.PrecCompareUtil.Util",
      "library": "goblint.lib",
      "description": "This module provides functions to unmarshal and compare precision results between different analysis runs using a hashmap structure. It works with marshaled data representing analysis results, specifically domain values indexed by keys, and supports dumping and comparing these results in a structured format. Concrete use cases include analyzing differences in abstract domain precision across multiple executions or configurations.",
      "description_length": 433,
      "index": 1484,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.RecursionTermLifter.Lifter",
      "library": "goblint.lib",
      "description": "Supports context-sensitive static analysis by enabling cycle detection and recursion handling in dynamic function call graphs through lattice-based fixed-point computations and constraint propagation. It operates on abstract states combining lattice domains (",
      "description_length": 259,
      "index": 1485,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.WrapperFunctionAnalysis.MallocWrapper",
      "library": "goblint.lib",
      "description": "This module models heap state changes during static analysis by generating symbolic locations for dynamic memory allocations, using node and thread identifiers to disambiguate allocation sites. It operates on abstract domains (`D.t`, `G.t`, `A`) to track memory interactions across concurrent contexts, handling program points like thread creation, function returns, and memory events. The approach enables precise analysis of heap memory in concurrent programs, particularly for tracking allocations through wrapper functions and distinguishing thread-specific heap usage.",
      "description_length": 573,
      "index": 1486,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.WitnessUtil.Invariant",
      "library": "goblint.lib",
      "description": "This module controls the emission of invariant nodes in witness graphs by determining which nodes qualify as loop heads, after lock operations, or other specific locations. It works with control flow graphs (`MyCFG.node`) and location-based keys to identify and filter nodes for invariant generation. Concrete use cases include selecting loop entry points and synchronization sites for verification witnesses in static analysis.",
      "description_length": 428,
      "index": 1487,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.PtranalAnalysis.Spec",
      "library": "goblint.lib",
      "description": "This module provides pointer analysis operations for tracking function pointer targets and control flow in CIL programs, alongside concurrency primitives for managing analysis threads and their interactions. It operates on abstract analysis contexts, thread-local states, and global data structures, enabling precise handling of function calls, branching, and state transitions. Specific use cases include sound static analysis of C programs with indirect function calls and modular reasoning about concurrent analysis tasks in a thread-aware framework.",
      "description_length": 553,
      "index": 1488,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.PrecCompare.Make",
      "library": "goblint.lib",
      "description": "Implements precision comparison between two values of type `D.t`, producing a comparison result and a formatted document. Uses optional names and verbosity to control output detail. Useful for comparing abstract values in static analysis domains with structured diagnostics.",
      "description_length": 274,
      "index": 1489,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.YamlWitnessType.Metadata",
      "library": "goblint.lib",
      "description": "This module defines metadata for YAML witness files, including format version, UUID, creation time, producer, and optional task information. It provides functions to convert metadata to and from YAML format, ensuring structured serialization and deserialization. Use this module when generating or parsing metadata in YAML witness files for analysis tools.",
      "description_length": 356,
      "index": 1490,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.UnassumeAnalysis.Spec",
      "library": "goblint.lib",
      "description": "This module provides operations to handle analysis context events (function entry/exit, thread spawning, state transitions), perform lattice-based manipulation of analysis states (join, meet, widen), and track unassume events by location. It operates on CIL expressions and CFG nodes, leveraging abstract states (`D.t`) to enable invariant propagation and constraint refinement guided by YAML witness annotations.",
      "description_length": 413,
      "index": 1491,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MyARG.UnCilLogicIntra",
      "library": "goblint.lib",
      "description": "Traverses intra-procedural control flow graphs using logical conditions to determine reachable nodes. It provides `next` and `next_opt` functions that return possible successor edges and nodes from a given node, based on the abstract reachability graph. This module is used for path-sensitive analysis within a single function, guiding exploration through logical constraints.",
      "description_length": 376,
      "index": 1492,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.ResultQuery.Make",
      "library": "goblint.lib",
      "description": "Implements file-level control flow graph (CFG) queries for analyzing program paths and skipped statements during constraint system solution analysis. Works with `MyCFG.cfg` structures and associated nodes, providing operations to inspect edges, node relationships, and skipped AST elements. Useful for identifying unreachable code, analyzing traversal paths, and examining CFG construction artifacts in CIL-based programs.",
      "description_length": 422,
      "index": 1493,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.PrivPrecCompareUtil.Util",
      "library": "goblint.lib",
      "description": "This module provides initialization and unmarshaling operations for a privilege comparison analysis. It handles marshaled data representing domain values mapped to keys, enabling reconstruction of complex privilege structures. Use cases include restoring analysis states from serialized data and initializing analysis environments.",
      "description_length": 331,
      "index": 1494,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Taint.VarinfoSet",
      "library": "goblint.lib",
      "description": "This module provides set operations and lattice manipulations for collections of CIL variable descriptors (`Varinfo`), enabling static analysis tasks like taint tracking. It supports union, intersection, difference, subset checks, and lattice-specific operations (e.g., widening, narrowing) to model variable state transitions and relationships. These sets are used to represent and analyze tainted variables in interprocedural analysis, where precise merging and comparison of variable states are critical.",
      "description_length": 507,
      "index": 1495,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.DomainProperties.Widen",
      "library": "goblint.lib",
      "description": "Implements widening operator properties for lattice domains using QCheck tests. Works with lattice structures defined by a module D that supports widening operations. Useful for verifying correctness of widening implementations in abstract domains.",
      "description_length": 248,
      "index": 1496,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Queries.Protection",
      "library": "goblint.lib",
      "description": "This module defines a type `t` with two variants, `Strong` and `Weak`, representing different levels of protection for global variables by mutexes. It provides comparison and hashing functions to support use in data structures like sets and maps. Concrete use cases include tracking and analyzing variable access protection in concurrent programs.",
      "description_length": 347,
      "index": 1497,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.LockDomain.MayLocksetNoRW",
      "library": "goblint.lib",
      "description": "This module implements a lattice and set algebra over address-based elements (`Addr.t`) to model potential locksets in static analysis, focusing on tracking which locks may be held without distinguishing read/write permissions. It supports operations like union, meet, and subset checks, alongside utilities for serialization, iteration, and integration with pointer state analysis, enabling use cases such as concurrency verification and lock consistency checking in program analysis.",
      "description_length": 485,
      "index": 1498,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.ExpRelation.Spec",
      "library": "goblint.lib",
      "description": "This module provides stateless syntactic analysis operations to determine must-equality between expressions through abstract interpretation, focusing on symbolic comparisons without program state tracking. It operates on expression relations using domains, variables, paths, and constraints, with transfer functions for control flow, function calls, and environment manipulations. Its primary use cases include static race detection and concurrency analysis by reasoning about expression equivalence in parallel execution contexts.",
      "description_length": 531,
      "index": 1499,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ThreadReturn.Spec",
      "library": "goblint.lib",
      "description": "This module provides static analysis operations for concurrent programs by modeling thread states with boolean-like lattices to determine whether threads reside at the topmost call frame. It includes lattice operations, context management, and transfer functions for handling function calls, thread creation, and state transitions, operating on abstract analysis states (`D.t`, `G.t`) and CIL expressions/fundecs. Use cases include tracking return value propagation, merging thread environments, and detecting race conditions during abstract interpretation of concurrent C programs.",
      "description_length": 582,
      "index": 1500,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.SpecLifters.LevelSliceLifter",
      "library": "goblint.lib",
      "description": "This module provides context-sensitive transfer functions for static analysis, handling program constructs like assignments, branches, function calls, and thread operations using abstract domains for data (`D.t`), control flow (`G.t`), contexts (`C.t`), and variables (`V.t`). It tracks constraints via unique variables and path representatives to enable debugging and witness generation in recursive analyses with level-based slicing. Key use cases include managing call stacks, thread state propagation, and event processing under depth-limited traversal when slicing is enabled.",
      "description_length": 581,
      "index": 1501,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.YamlWitness.Entry",
      "library": "goblint.lib",
      "description": "This module constructs individual entries in a YAML witness file, representing verification results such as invariants and certificates. It supports creation of location-specific, loop, and flow-insensitive invariants, as well as precondition and certificate entries tied to specific tasks and targets. Concrete use cases include recording proof outcomes from static analysis, attaching invariants to code locations, and certifying loop or precondition properties.",
      "description_length": 464,
      "index": 1502,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.BaseDomain.CPA",
      "library": "goblint.lib",
      "description": "This module implements a map-based abstract domain for static analysis, where program variables are associated with abstract values through a constraint propagation framework. It provides operations to combine and merge variable mappings using customizable strategies, compute lattice joins/meets, and apply transformations across entire domains, while supporting dataflow analysis tasks like value refinement and dependency tracking. The design enables efficient handling of CPA states through bulk updates, predicate-based filtering, and domain-specific utilities for serialization, comparison, and property testing.",
      "description_length": 618,
      "index": 1503,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MallocFresh.Spec",
      "library": "goblint.lib",
      "description": "This module provides abstract interpretation operations to track and propagate freshness information for unescaped heap allocations in concurrent programs. It manipulates thread-local memory abstractions using lifted `varinfo` sets to model unescaped pointers, supporting control flow analysis through normalization, comparison, and context-sensitive state transformations. The analysis enables race detection and optimization by tracking allocation lifetimes across threads and function boundaries.",
      "description_length": 499,
      "index": 1504,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MCPRegistry.PathListSpec",
      "library": "goblint.lib",
      "description": "Implements a list-based representation for analysis paths, providing operations to associate domains with integer keys and retrieve them in ordered lists. Works with disjoint domains and integer-identified analysis components. Used to manage and query dynamic analysis configurations in a product registry.",
      "description_length": 306,
      "index": 1505,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Queries.SD",
      "library": "goblint.lib",
      "description": "This module provides lattice operations for a domain combining bottom, top, and string values, supporting analysis of abstract program properties. It defines a variant lattice type with ordering relations and fixed-point computations, used to represent symbolic string information in static analysis contexts like variable tracking or value-flow analysis. The domain enables reasoning about string values under abstraction, with utilities for comparison, serialization, and testing via QCheck arbitraries.",
      "description_length": 505,
      "index": 1506,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.MCP.MCP2",
      "library": "goblint.lib",
      "description": "This module provides operations for initializing and finalizing analysis states with marshaled data, handling control flow and variable declarations, and implementing transfer functions for assignments, conditionals",
      "description_length": 215,
      "index": 1507,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MCPRegistry.DomVariantLattice0",
      "library": "goblint.lib",
      "description": "This module provides lattice operations for comparing, combining, and testing abstract domain elements structured as HConsed tagged tuples (integer + generic object), supporting static analysis tasks like merging states or approximating program behavior. It enables dynamic activation of domain variants through operations such as join, meet, widen, and narrow, while utilities like `is_bot` and `top` handle lattice bounds. Specific use cases include configuring and analyzing program abstractions in a modular static analysis framework.",
      "description_length": 538,
      "index": 1508,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.LoopTermination.Statements",
      "library": "goblint.lib",
      "description": "This module provides lattice operations (join, meet, widen) to model loop termination states by encapsulating CilType.Stmt.t values in a `Bot`/`Lifted`/`Top` hierarchy, enabling abstract interpretation of termination behavior. It supports static analysis of loops and `goto` statements by tracking termination possibilities through lifted statement contexts and combining them via lattice semantics to determine convergence during iterative analysis.",
      "description_length": 450,
      "index": 1509,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.WideningTokenLifter.Dom",
      "library": "goblint.lib",
      "description": "This module combines abstract domain operations with token-based control to delay widening, working on pairs of domain elements (`D.t`) and token sets. It provides functions like equality, comparison, and token-aware widening, where widening is suppressed if new tokens are added. This is useful in static analysis to refine precision by dynamically postponing convergence in iterative fixpoint computations.",
      "description_length": 408,
      "index": 1510,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.RegionDomain.RegionDom",
      "library": "goblint.lib",
      "description": "This module implements lattice operations for abstract heap regions with three states: bottom (no information), lifted (a mapped region), and top (all regions). It combines a region map type with polymorphic variants to model memory regions, enabling precise tracking of disjoint heap segments during static analysis. The operations support merging, comparing, and transforming region states, which are critical for analyzing memory safety and data flow in programs with dynamic memory allocation.",
      "description_length": 497,
      "index": 1511,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Callstring.Spec",
      "library": "goblint.lib",
      "description": "This module enables context-sensitive static analysis through k-limited call stack tracking (k-CFA) and infinite call string approaches, offering lattice operations, context manipulation, and transfer functions to handle function calls, returns, concurrency (thread creation/spawning), and inline assembly. It operates on abstract domain values (`D.t`), call contexts (`C.t`), constraint variables (`V.t`), and path representatives (`P.t`), supporting adjustable precision by configuring the maximum call stack depth (`callString_length`) for trade-offs between scalability and accuracy.",
      "description_length": 587,
      "index": 1512,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.YamlWitnessType.LoopInvariantCertificate",
      "library": "goblint.lib",
      "description": "This module defines and manipulates loop invariant certificates in the YAML witness format. It provides functions to parse certificates from YAML values, compare them, and access their entry type. It works with structured data containing `target` and `certification` fields, used to represent verification results for loop invariants in static analysis.",
      "description_length": 353,
      "index": 1513,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.LockDomain.MakeRW",
      "library": "goblint.lib",
      "description": "This module combines a lockset domain with read/write permissions, supporting operations like equality checks, comparison, and pretty-printing of lock and permission pairs. It works with tuples of type `P.t * RW.t`, where `P` represents a lockset domain and `RW.t` represents read/write permission states. Concrete use cases include tracking and comparing thread-specific lock acquisitions with associated access modes in static analysis.",
      "description_length": 438,
      "index": 1514,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Transform.PartialEval",
      "library": "goblint.lib",
      "description": "Performs partial evaluation of CIL expressions during transformation, reducing constant expressions and simplifying control flow based on known conditions. It operates on CIL AST structures, specifically expressions and statements, to optimize code by evaluating compile-time constants and pruning unreachable branches. This is used in static analysis to improve precision by eliminating runtime variability in known values.",
      "description_length": 424,
      "index": 1515,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Base.MainFunctor",
      "library": "goblint.lib",
      "description": "This component provides core abstractions for static analysis of C programs, focusing on non-relational value analysis through lattice-based abstract domains (`Dom`, `C`, `G`, `V`) and variable-indexed data structures (`VarH`, `VarMap`) for tracking program state. It supports arithmetic/logical evaluation, memory modeling, and invariant refinement while handling concurrency via thread-aware context management and function call analysis. Key applications include pointer tracking, value-range analysis, and context-sensitive reasoning over program expressions and memory operations.",
      "description_length": 585,
      "index": 1516,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.SpecLifters.DeadCodeLifter",
      "library": "goblint.lib",
      "description": "This module implements a dead code analysis that identifies unreachable code regions by propagating constraint variables and path-sensitive information through CIL-processed programs. It operates on abstract states (D.t), global environments (G.t), and variable/path identity modules (V, P) to model control flow, function call semantics, and thread creation, enabling program optimization and verification tasks that rely on detecting code paths that cannot be executed under any runtime scenario.",
      "description_length": 498,
      "index": 1517,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.SymbLocksDomain.Exp",
      "library": "goblint.lib",
      "description": "This module provides operations for structural comparison, hashing, and manipulation of symbolic expressions (GoblintCil.exp) within a symbolic lockset domain, focusing on variable containment checks, offset folding, and base expression replacement. It works with CIL expressions and offsets to analyze array indices, determine constant or unknown variable patterns, and support static analysis tasks like concurrency control and lockset tracking. Utilities for pretty-printing, serialization, and structural equality checks enable integration into analysis frameworks requiring precise symbolic reasoning about program expressions.",
      "description_length": 632,
      "index": 1518,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MemOutOfBounds.Spec",
      "library": "goblint.lib",
      "description": "The specification defines operations for tracking memory bounds and validating accesses during static analysis of C programs. It works with CIL expressions, lvalues, and abstract values to detect out-of-bounds accesses, enforce memory safety constraints, and handle function calls and assignments within an analysis framework.",
      "description_length": 326,
      "index": 1519,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.MusteqDomain.Equ",
      "library": "goblint.lib",
      "description": "This domain provides map-like operations for associating symbolic lvalue keys with formula values, supporting lattice-based combinations of equality constraints through joins, meets, and widening. It works with symbolic expressions and variables to model must-equality relationships, enabling static analysis tasks like tracking variable equivalences and optimizing program behavior under constraints. Key use cases include merging symbolic state transitions and evaluating expressions within abstract interpretations of program semantics.",
      "description_length": 539,
      "index": 1520,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.BaseDomain.PartDeps",
      "library": "goblint.lib",
      "description": "This module provides map-like operations and lattice manipulations on a structure associating variables with variable sets, enabling precise combination of dependency information through joins, meets, widening, and narrowing. It works with variables (`Basetype.Variables.t`) and sets of variables (`VarSet.t`), organized into a lattice-like domain for static analysis. It is particularly used in dataflow analysis to track and merge variable dependencies under abstract interpretation, supporting operations like property-based testing and domain-specific comparisons.",
      "description_length": 568,
      "index": 1521,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.AutoTune.VariableMap",
      "library": "goblint.lib",
      "description": "This module implements a specialized map for associating variable information (`CilType.Varinfo.t`) with polymorphic values, supporting insertion, lookup, traversal, and structural transformations. It handles both singular and list-based value mappings, offering operations like filtering, merging, and ordered key-based sequence conversions for efficient configuration autotuning. Designed for static analysis contexts, it enables tracking and adapting analysis parameters based on variable usage patterns in code.",
      "description_length": 515,
      "index": 1522,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Queries.Result",
      "library": "goblint.lib",
      "description": "This module handles query results within a lattice structure, providing operations to retrieve bottom and top elements for a given query type. It works with generic query result types `'a` that conform to lattice semantics. Concrete use cases include initializing or comparing results in static analysis where extremal values are required.",
      "description_length": 339,
      "index": 1523,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.YamlWitness",
      "library": "goblint.lib",
      "description": "This module generates and validates YAML witness files for static analysis verification. It constructs entries representing invariants, certificates, and validation outcomes, and writes them to YAML format. It supports precise mapping of analysis results to code locations, loop heads, and function contracts, and tracks validation statistics for confirmed, refuted, and unchecked results. Use cases include recording and validating proof outcomes from static analysis, certifying program properties, and ensuring correctness of generated witness files against control flow structures.",
      "description_length": 585,
      "index": 1524,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.VectorMatrix",
      "library": "goblint.lib",
      "description": "This module implements array-backed vectors and matrices with support for arithmetic operations, normalization to reduced row echelon form, and index-aware transformations. It works with numerical data types through infix operators and provides concrete operations like vector mapping, matrix reduction, and structural manipulations. Use cases include symbolic computation, linear system solving, and numerical algorithms requiring efficient indexed access and hybrid functional/imperative workflows.",
      "description_length": 500,
      "index": 1525,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Constraints",
      "library": "goblint.lib",
      "description": "This module builds and manipulates constraint systems from analysis specifications and control flow graphs (CFGs). It supports transformations of analysis specifications using functors, enabling modular and reusable constraint generation. Concrete use cases include constructing dataflow analysis constraints and applying specification-level transformations to adapt analyses for different CFG structures.",
      "description_length": 405,
      "index": 1526,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.SymbLocksDomain",
      "library": "goblint.lib",
      "description": "This module implements a symbolic lockset domain for static analysis of concurrent programs, providing operations to track and manipulate sets of symbolic locks using CIL expressions. It supports lattice operations like join, meet, widen, and subset checks, along with set manipulations such as add, remove, and fold over symbolic expressions representing locks. Concrete use cases include modeling lock acquisition orders, detecting inconsistent lock usage across threads, and analyzing synchronization primitives in abstract interpretation frameworks.",
      "description_length": 553,
      "index": 1527,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Queries",
      "library": "goblint.lib",
      "description": "This module provides lattice operations (join, meet, widen) and set manipulations (union, intersection) over abstract domains for types, expressions, variables, thread-node states, and strings, alongside protection-tracking utilities for concurrency analysis. It supports static analysis tasks like abstract interpretation and dataflow analysis by modeling properties such as must/may relationships, memory consistency, and escape analysis in concurrent programs. Analysis-specific data structures include algebraic sets and hash tables for efficient state tracking in complex control-flow scenarios.",
      "description_length": 600,
      "index": 1528,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.CondVars",
      "library": "goblint.lib",
      "description": "Manages symbolic variable equalities and logical constraints through map-based operations on expressions and abstract values. It supports merging, filtering, and querying based on conditional relationships, specifically for tracking variable states across control-flow branches and function calls in C code analysis. Used to resolve branching conditions, model pointer relationships, and propagate constraints through program execution paths.",
      "description_length": 442,
      "index": 1529,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Maingoblint",
      "library": "goblint.lib",
      "description": "This module orchestrates the core analysis pipeline for C code, handling front-end processing like command-line argument parsing, GCC-based preprocessing of C files, and merging CIL ASTs, followed by analysis execution. It operates on file paths, CIL representations, and analysis results to support tasks such as HTML report generation, result visualization via Gobview, and incremental analysis through CIL file diffing and renaming. Key use cases include end-to-end static analysis workflows, regression testing with incremental changes, and interactive exploration of analysis outcomes.",
      "description_length": 590,
      "index": 1530,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.ActiveLongjmp",
      "library": "goblint.lib",
      "description": "Tracks active `longjmp` targets during static analysis of C code by processing control flow events like function calls, returns, and branches. It works with CIL expressions, function declarations, and lvalues, using abstract domains to model non-local jumps. Enables precise interprocedural analysis of programs with complex control flow involving `setjmp` and `longjmp`.",
      "description_length": 371,
      "index": 1531,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MHPAnalysis",
      "library": "goblint.lib",
      "description": "Analyzes concurrent program memory accesses to determine may-happen-in-parallel (MHP) relationships between threads. It tracks thread creation, synchronization, and execution flows using thread identifiers and sets, enabling data race detection by identifying overlapping memory accesses across parallel execution paths. Works directly with abstract interpretation states and thread-aware control flow constructs.",
      "description_length": 413,
      "index": 1532,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.AccessAnalysis",
      "library": "goblint.lib",
      "description": "This module implements lattice-based abstract domain operations and transfer functions to model memory accesses during static analysis. It works with control flow graph nodes, abstract memory states, and CIL-level program elements such as variables and expressions, including support for concurrency and interprocedural analysis. It is used to detect memory errors, enforce thread safety, and analyze data races in multi-threaded C programs.",
      "description_length": 441,
      "index": 1533,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.AffineEqualityDomain",
      "library": "goblint.lib",
      "description": "Implements abstract domain operations for tracking affine equalities among variables, using a basis representation to efficiently manage constraints. Operates on variable identifiers and symbolic expressions to represent linear relationships. Useful for optimizing compiler analyses where equivalence between expressions can eliminate redundant computations.",
      "description_length": 358,
      "index": 1534,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.AnalysisResult",
      "library": "goblint.lib",
      "description": "This module handles the representation and manipulation of static analysis results, focusing on control flow nodes and combined result types. It provides structured data types for CFG nodes and result configurations, supporting operations like comparison, hashing, and serialization to formats like XML and JSON. It is used to track and export analysis outcomes for C functions, particularly in contexts like interprocedural analysis and result reporting.",
      "description_length": 455,
      "index": 1535,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ContextGasLifter",
      "library": "goblint.lib",
      "description": "Handles context-sensitive analysis by limiting function call depth with a gas variable. Provides `get_gas_lifter` to retrieve a spec transformer that enforces gas-based context sensitivity. Used to control precision in recursive or deeply nested function call analysis.",
      "description_length": 269,
      "index": 1536,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.MallocFresh",
      "library": "goblint.lib",
      "description": "This module analyzes unescaped heap allocations in concurrent programs by tracking freshness information through abstract interpretation. It uses thread-local memory abstractions and lifted `varinfo` sets to model unescaped pointers, enabling race detection and optimization by propagating allocation lifetimes across control flow and function calls. Concrete use cases include improving memory safety in multi-threaded code and optimizing garbage collection by identifying short-lived allocations.",
      "description_length": 498,
      "index": 1537,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.WideningTokenLifter",
      "library": "goblint.lib",
      "description": "This module implements widening delay mechanisms using token sets to control convergence in abstract interpretation. It provides operations for managing and combining abstract states with associated widening tokens, ensuring that widening is postponed when new tokens are introduced. Concrete use cases include refining static analysis precision by dynamically delaying fixpoint stabilization in iterative analyses.",
      "description_length": 415,
      "index": 1538,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.MayLocks",
      "library": "goblint.lib",
      "description": "This module analyzes potential lock states in concurrent programs using lattice-based abstract domains, tracking sets of locks that may be held during execution. It provides operations for modeling lock acquisition and release, thread spawning, and context initialization to detect concurrency issues like double locking. Concrete use cases include static verification of lock usage patterns to prevent race conditions and ensure correct synchronization in multi-threaded code.",
      "description_length": 477,
      "index": 1539,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.AccessDomain",
      "library": "goblint.lib",
      "description": "This module defines data structures and operations for analyzing memory accesses in C programs. It includes types for representing access events with variables, offsets, and access kinds, along with sets of such events. It supports static analysis tasks like detecting memory errors or tracking data flow by enabling precise modeling of memory interactions.",
      "description_length": 357,
      "index": 1540,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.YamlWitnessType",
      "library": "goblint.lib",
      "description": "This module defines YAML witness types for static analysis artifacts, including invariants, loop invariants, location information, and metadata. It provides direct serialization and deserialization for structured data such as producer details, task configurations, violation sequences, and certification records. Concrete use cases include parsing and generating YAML-based witness files for program analysis, enabling precise validation and exchange of verification results.",
      "description_length": 475,
      "index": 1541,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.CommonPriv",
      "library": "goblint.lib",
      "description": "This module provides utilities for thread-modular value analysis, including configuration validation, atomic block handling, variable protection checks, mutex and global variable tracking, lockset management, and digest-based thread state coordination. It operates on abstract domains for variables, locksets, and thread-local states to support static analysis of concurrent programs. Concrete use cases include enforcing mutex constraints, tracking variable access under locks, modeling thread-specific data flow, and coordinating analysis refinements based on thread creation and execution state.",
      "description_length": 598,
      "index": 1542,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Preprocessor",
      "library": "goblint.lib",
      "description": "Detects and validates C preprocessors using version checks and command generation. It works with strings for executable paths and leverages a hash table module (FpathH) to map file paths to boolean values, tracking preprocessing dependencies. Concrete use cases include resolving C file dependencies, caching preprocessing outcomes, and generating safe preprocessor commands with version compatibility checks.",
      "description_length": 409,
      "index": 1543,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Vla",
      "library": "goblint.lib",
      "description": "This module analyzes variable-length arrays in C code, providing operations for tracking their properties during static analysis. It works with abstract analysis states, CIL expressions, and environment mappings to handle VLA initialization, assignment, control flow, and interprocedural transitions. Concrete use cases include detecting out-of-bounds accesses, verifying array bounds, and tracking dynamically allocated stack array sizes across function calls and branches.",
      "description_length": 474,
      "index": 1544,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MyARG",
      "library": "goblint.lib",
      "description": "This module provides operations for modeling control flow transitions and function calls in program analysis, using specialized edge types like `inline_edge` and node representations such as `StackNode` to track abstract reachability paths. It works with control flow graphs (CFGs) and stack-based data structures to enable path-sensitive reasoning through ternary analysis and intra-procedural dataflow computations. Specific use cases include constructing call graphs, analyzing reachable code paths, and tracking data dependencies in static analysis tools.",
      "description_length": 559,
      "index": 1545,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MusteqDomain",
      "library": "goblint.lib",
      "description": "This module implements a symbolic equalities domain for static analysis of C programs, tracking must-equalities between lvalues through operations like join, meet, and substitution. It works with symbolic values (`V.t`), offset expressions, and equality constraints represented as maps from lvalues to formulas, structured with field and index offsets. Concrete use cases include resolving pointer equivalences, analyzing memory access patterns, and maintaining equality constraints during abstract interpretation of low-level code.",
      "description_length": 532,
      "index": 1546,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.LockDomain",
      "library": "goblint.lib",
      "description": "This module provides abstractions for tracking lock acquisition and release patterns in concurrent programs, with support for both must and may locksets, read/write permissions, and multiplicity-aware locking. It includes operations for set-theoretic manipulations, lattice joins and meets, equality and comparison checks, and pretty-printing, all tailored for static analysis of thread safety. Concrete use cases include enforcing lock consistency, verifying correct usage of read/write locks, and detecting concurrency-related bugs in abstract interpretation frameworks.",
      "description_length": 572,
      "index": 1547,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.WitnessUtil",
      "library": "goblint.lib",
      "description": "This module provides operations for managing node-based mappings and sets, identifying invariant locations in control flow graphs, and parsing and simplifying logical expressions for witness generation. It works with abstract syntax tree nodes, control flow graph nodes, and CIL expressions to support precise static analysis tasks. Concrete use cases include tracking loop heads, emitting YAML invariant annotations, and extracting or simplifying invariant expressions at specific code locations.",
      "description_length": 497,
      "index": 1548,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ThreadEscape",
      "library": "goblint.lib",
      "description": "Performs escape analysis to determine whether thread-local variables escape their scope. Works with variable information structures to track potential escapes through function calls or assignments. Useful for optimizing thread-local storage and ensuring variables do not inadvertently become shared across threads.",
      "description_length": 314,
      "index": 1549,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ThreadFlagDomain",
      "library": "goblint.lib",
      "description": "This module defines lattice-based thread flag domains for abstract interpretation in multi-threaded program analysis. It includes two implementations\u2014`Trivial` and `Simple`\u2014that track thread states using a `type t` representing single, multi, and main thread contexts, with operations like join, meet, widen, and state checks such as `is_main` and `is_multi`. It is used to model thread interactions in static analysis, particularly for concurrency scenarios where distinguishing the main thread or tracking thread transitions is required.",
      "description_length": 539,
      "index": 1550,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.LinearTwoVarEqualityDomain",
      "library": "goblint.lib",
      "description": "Implements a domain for tracking equalities between pairs of variables in a linear form. Provides operations to add, query, and simplify constraints involving two variables. Useful for optimizing compiler analyses by enabling precise propagation of variable relationships during abstract interpretation.",
      "description_length": 303,
      "index": 1551,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.RaceAnalysis",
      "library": "goblint.lib",
      "description": "This module performs data race analysis using tries to track memory access patterns through offset hierarchies and type-based decomposition. It works with memory locations (memos) consisting of roots and offsets, organizing them in trie structures enriched with lattice properties to propagate access information across scopes. It checks races by analyzing access sets at each trie node, combining prefix and type suffix information to report conflicts at the most precise intersecting memos, particularly useful for static analysis of concurrent C programs with complex memory access patterns.",
      "description_length": 594,
      "index": 1552,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.GoblintDir",
      "library": "goblint.lib",
      "description": "Manages intermediate data directories during analysis. Provides operations to initialize and finalize directory structures, along with retrieving paths for root and preprocessed data storage. Useful for organizing temporary file outputs in a structured manner during static analysis runs.",
      "description_length": 288,
      "index": 1553,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.PoisonVariables",
      "library": "goblint.lib",
      "description": "Tracks variables invalidated by `setjmp`/`longjmp` interactions in C programs using abstract domains (`VS.t`, `AD.elt`, `D.t`). Analyzes variable liveness and propagates poisoned states through assignments, control flow, and function calls. Identifies variables needing reinitialization after non-local jumps, ensuring correctness in safety-critical error-handling code.",
      "description_length": 370,
      "index": 1554,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ThreadFlag",
      "library": "goblint.lib",
      "description": "This module tracks multi-threaded program states using abstract thread flags and thread state transitions. It provides functions to determine if a program is currently or has ever been multi-threaded, and analyzes concurrency behavior such as thread creation, synchronization, and race conditions. Use cases include static analysis of concurrent programs, tracking thread lifecycles, and detecting synchronization issues like data races.",
      "description_length": 437,
      "index": 1555,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MutexEventsAnalysis",
      "library": "goblint.lib",
      "description": "Tracks mutex lock and unlock events in concurrent programs using lattice-based abstract interpretation. It analyzes synchronization behavior across threads by modeling mutex states and execution paths with abstract domains and constraint systems. Detects race conditions and verifies thread safety by resolving lock/unlock dependencies in C code during static analysis.",
      "description_length": 369,
      "index": 1556,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.CompilationDatabase",
      "library": "goblint.lib",
      "description": "This module processes compilation databases to extract and manipulate build commands for C files. It parses JSON compilation databases into structured command objects, splits complex commands into simpler ones, and preprocesses source files using specified flags. It works with file paths, command strings, and JSON representations to support analysis of real-world C projects.",
      "description_length": 377,
      "index": 1557,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MemLeak",
      "library": "goblint.lib",
      "description": "This module detects memory leaks in C programs through abstract interpretation, using lattice-based domains to track memory allocations and deallocations across function calls and control flow structures. It works with abstract domains for memory blocks, variables, and execution contexts, performing state transitions to identify untracked deallocations. Concrete use cases include analyzing context-sensitive memory usage in programs with dynamic allocation patterns and complex control flow.",
      "description_length": 494,
      "index": 1558,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.LongjmpLifter",
      "library": "goblint.lib",
      "description": "This module provides transfer functions and context operations to model non-local control flow from `setjmp` and `longjmp` in C programs. It manipulates abstract domains and analysis contexts to track state transitions across function calls, thread creation, and inline assembly. It is used to analyze value dependencies and synchronization in programs with abrupt control transfers.",
      "description_length": 383,
      "index": 1559,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.IntDomainProperties",
      "library": "goblint.lib",
      "description": "This module defines QCheck property tests for integer domain implementations, ensuring correctness of operations like addition, subtraction, and comparison. It works with integer domains conforming to the `D` module signature, validating their behavior against standard arithmetic properties. Use this to test algebraic consistency of custom integer abstractions in Goblint analyses.",
      "description_length": 383,
      "index": 1560,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Transform",
      "library": "goblint.lib",
      "description": "This module manages transformations applied during static analysis, handling operations like partial evaluation of expressions and control flow simplification. It works with CIL AST structures, including expressions, statements, and function definitions, alongside analysis-specific data like CFGs and node states. Concrete use cases include optimizing constant expressions, pruning unreachable code branches, and preparing code for more precise subsequent analyses.",
      "description_length": 466,
      "index": 1561,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.TerminationPreprocessing",
      "library": "goblint.lib",
      "description": "This module performs preprocessing tasks for termination analysis by mapping C variables to statements and managing control flow dependencies. It provides operations to track variable usage patterns, transform variable-statement associations, and aggregate termination-related data. Concrete use cases include analyzing loop counters, detecting variable modifications across control flow paths, and preparing data for termination proof generation.",
      "description_length": 447,
      "index": 1562,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.BaseUtil",
      "library": "goblint.lib",
      "description": "This module provides functions to check variable properties in CIL code during static analysis, such as whether a variable is global, static, volatile, or excluded from specific analysis steps. It operates on `varinfo` structures from the GoblintCil module, which represent C program variables. These checks are used to guide analysis decisions, such as tracking precision or exclusion from early global initialization.",
      "description_length": 419,
      "index": 1563,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.PrivPrecCompareUtil",
      "library": "goblint.lib",
      "description": "This module implements precision comparison operations for privilege domains, working with marshaled analysis states and location-variable pairs. It provides functions to initialize analysis contexts and reconstruct domain values from serialized data. Concrete use cases include restoring privilege comparisons during static analysis and managing variable-specific precision levels across code locations.",
      "description_length": 404,
      "index": 1564,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ArgTools",
      "library": "goblint.lib",
      "description": "Constructs bidirectional argument graphs from constraint system solutions, linking program nodes with analysis results. Works with control flow graph nodes, specification contexts, and integer identifiers to represent graph nodes, supporting precise value retrieval and index queries. Used for building hierarchical state representations and tracking labeled program values across interprocedural contexts.",
      "description_length": 406,
      "index": 1565,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.UseAfterFree",
      "library": "goblint.lib",
      "description": "This module detects use-after-free vulnerabilities by analyzing memory state transitions and tracking both stack- and heap-allocated variables through lattice-based abstract domains. It works with `CilType.Varinfo.t` variables and structured memory states to model allocation, invalidation, and access patterns in C programs. Concrete use cases include identifying invalid pointer dereferences during static analysis of function calls, pointer assignments, and thread synchronization points.",
      "description_length": 491,
      "index": 1566,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ThreadAnalysis",
      "library": "goblint.lib",
      "description": "Analyzes concurrency constructs like thread creation, synchronization, and assignments using abstract thread states in a lattice. It operates on thread IDs (TIDs), analysis states (`D.t`), and concurrency events to enforce thread uniqueness and track memory access. Used in static analysis to verify thread-local data isolation, detect synchronization errors, and resolve thread hierarchies.",
      "description_length": 391,
      "index": 1567,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.TimeUtil",
      "library": "goblint.lib",
      "description": "Converts Unix time structures to ISO 8601 strings, retrieves current time in ISO 8601 format, and parses duration strings into seconds. Operates on Unix.tm records and string inputs. Useful for logging timestamps, measuring durations, and formatting time in a standardized way.",
      "description_length": 277,
      "index": 1568,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Deadlock",
      "library": "goblint.lib",
      "description": "Models lock acquisition events and detects circular dependencies to identify potential deadlocks in concurrent systems. Uses data structures like `LockEventPair`, `MayLockEventPairs`, and `Arg` to track lock interactions and manage state during static analysis. Enables precise deadlock detection by analyzing event relationships and enforcing safe lock ordering.",
      "description_length": 363,
      "index": 1569,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MCPAccess",
      "library": "goblint.lib",
      "description": "This module implements a list-based structure `t` where each element is a pair of an integer and an object, designed for tracking memory access metadata. It supports operations such as equality checking, hashing, comparison, and serialization to XML and JSON. Key functions include `may_race` for detecting potential memory races between access lists, and `unop_fold` and `binop_for_all` for folding and comparing access elements.",
      "description_length": 430,
      "index": 1570,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ExpressionEvaluation",
      "library": "goblint.lib",
      "description": "This module evaluates expressions during static analysis by transforming CIL files based on structured queries. It processes CIL expressions and statements, applying transformations to simplify or optimize code using analysis results. Concrete use cases include evaluating constant expressions, propagating values, and simplifying conditionals directly within CIL structures.",
      "description_length": 375,
      "index": 1571,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Graphml",
      "library": "goblint.lib",
      "description": "This module writes GraphML documents to an output channel, supporting structured graph serialization with nodes, edges, and metadata. It operates on strings for node identifiers and attributes, enabling concrete use cases like exporting control flow graphs or data flow analysis results to GraphML format. Key operations include defining keys, writing nodes and edges with attributes, and managing graph structure with start and stop markers.",
      "description_length": 442,
      "index": 1572,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ProcessPool",
      "library": "goblint.lib",
      "description": "Runs a list of tasks in parallel, up to a specified number of concurrent jobs. Each task consists of a shell command and an optional working directory. Useful for executing multiple external processes, such as running analysis tools or scripts, while limiting resource usage.",
      "description_length": 275,
      "index": 1573,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.CompareConstraints",
      "library": "goblint.lib",
      "description": "This module defines operations for comparing constraint systems in static analysis, focusing on global and local variable mappings associated with program points. It works with labeled mappings and hash tables to represent and compare constraint states across different analysis contexts. It is used to verify equivalence of analysis results, such as checking consistency of inferred constraints between different analyzer runs or configurations.",
      "description_length": 446,
      "index": 1574,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.BaseDomain",
      "library": "goblint.lib",
      "description": "This module combines multiple abstract domains for static analysis, including constraint propagation, dependency tracking, and weak update handling. It operates on structured abstract elements composed of privilege states and variable mappings, supporting lattice operations like join, meet, widen, and narrow. Concrete use cases include merging analysis states during dataflow propagation, refining variable values under different execution paths, and tracking dependencies for precise program analysis.",
      "description_length": 504,
      "index": 1575,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Expsplit",
      "library": "goblint.lib",
      "description": "This module implements path-sensitive static analysis by tracking values of arbitrary expressions across program paths. It works with abstract domains, constraint variables, and lattice structures to model control flow, function calls, and concurrency. It is used for context-sensitive data flow analysis, fixed-point computation in loops, and thread synchronization modeling.",
      "description_length": 376,
      "index": 1576,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.LocksetAnalysis",
      "library": "goblint.lib",
      "description": "This module implements lockset analyses for concurrent programs using abstract domains to track lock acquisition and release patterns. It provides operations for analyzing control flow, thread synchronization, and interprocedural lock constraints with lattice-based precision. It is used to detect concurrency bugs such as deadlocks, race conditions, and lock order violations in C programs through context-sensitive static analysis.",
      "description_length": 433,
      "index": 1577,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ReturnUtil",
      "library": "goblint.lib",
      "description": "This module manages special variables representing function return values and longjmp returns in the analysis. It provides access to the return variable's store reference, varinfo, address descriptor, and lvalue through dedicated functions. Useful for tracking and manipulating return values during static analysis of C functions.",
      "description_length": 330,
      "index": 1578,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.EscapeDomain",
      "library": "goblint.lib",
      "description": "This module implements lattice and set operations for tracking escaped thread-local variables in concurrent analysis. It handles an abstract type `t` that represents either a set of variables or a top element, using `Basetype.Variables.t` for variable identities. It is used to determine variable escape across threads and propagate escape information during static analysis.",
      "description_length": 375,
      "index": 1579,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MHP",
      "library": "goblint.lib",
      "description": "This module defines a may-happen-in-parallel analysis domain for concurrency, tracking thread IDs, created threads, and threads that must have been joined. It provides operations to compare, hash, and pretty-print MHP states, along with checks for thread execution exclusion and joining guarantees. Concrete use cases include determining parallel execution possibilities between program points and analyzing thread lifecycle constraints in concurrent programs.",
      "description_length": 460,
      "index": 1580,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.MutexAnalysis",
      "library": "goblint.lib",
      "description": "Implements must-lockset and protecting lockset analyses for concurrency verification in multithreaded programs. It tracks lock-protected variables and enforces correct locking discipline using set operations on `Basetype.Variables.t` and abstract domains for lockstate propagation. Used to verify mutual exclusion, detect data races, and analyze lock contention during static analysis.",
      "description_length": 385,
      "index": 1581,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.BasePriv",
      "library": "goblint.lib",
      "description": "This module implements non-relational thread-modular value analyses for base types, providing operations to track and abstract values in a concurrent setting. It works with abstract domains that model scalar values and memory locations independently per thread. Concrete use cases include analyzing integer ranges, pointer aliasing, and thread-local state in C programs during static analysis.",
      "description_length": 393,
      "index": 1582,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ObserverAutomaton",
      "library": "goblint.lib",
      "description": "Implements a finite automaton that detects infeasible abstract reachability graph paths using a KMP-like algorithm. It processes sequences of transitions from a graph with states represented as integers, identifying invalid or looping paths. Useful for static analysis workflows that require efficient path validation in abstract reachability graphs.",
      "description_length": 350,
      "index": 1583,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.EvalAssert",
      "library": "goblint.lib",
      "description": "Transforms CIL files by inserting computed invariants as `assert` statements at specified locations, using query functions to determine placement. Works directly with CIL data structures to modify function bodies and control flow. Useful for embedding runtime checks that enforce value ranges, pointer validity, or concurrency constraints in the instrumented program.",
      "description_length": 367,
      "index": 1584,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.SarifRules",
      "library": "goblint.lib",
      "description": "This module defines and provides access to SARIF rule metadata used for static analysis reporting in Goblint. It includes structured data such as rule IDs, descriptions, and help links, and allows retrieving rule details by ID. It supports generating standardized SARIF output for analysis results.",
      "description_length": 298,
      "index": 1585,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.PtranalAnalysis",
      "library": "goblint.lib",
      "description": "This module performs pointer analysis to track function pointer targets and control flow in CIL programs. It provides concurrency primitives for managing analysis threads and their interactions. It operates on abstract analysis contexts, thread-local states, and global data structures, enabling sound static analysis of indirect function calls and modular reasoning about concurrent analysis tasks.",
      "description_length": 399,
      "index": 1586,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.TaintPartialContexts",
      "library": "goblint.lib",
      "description": "Tracks tainted variable modifications within functions using abstract interpretation. It converts taint states into variable sets to model data flow across control flow and function boundaries. Useful for identifying which variables become tainted due to untrusted inputs or specific function operations.",
      "description_length": 304,
      "index": 1587,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.PthreadDomain",
      "library": "goblint.lib",
      "description": "This module provides domains for analyzing Pthread programs through abstract interpretation. It includes `Pred` for tracking predecessor nodes in control flow graphs using sets of `Base.t` elements, and `D` for representing and manipulating abstract thread states with lattice operations. These support concrete tasks like modeling thread synchronization, analyzing control flow in concurrent code, and verifying correctness properties during static analysis of parallel programs.",
      "description_length": 480,
      "index": 1588,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MemOutOfBounds",
      "library": "goblint.lib",
      "description": "Detects out-of-bounds memory accesses in C programs during static analysis by tracking memory bounds and validating pointer and array accesses. It operates on CIL expressions, lvalues, and abstract values to enforce memory safety constraints. Used in static analysis passes to identify unsafe memory operations in C code, such as buffer overflows or invalid pointer dereferences.",
      "description_length": 379,
      "index": 1589,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.SvcompSpec",
      "library": "goblint.lib",
      "description": "This module parses and represents SV-COMP specification strings and files into structured types, supporting direct conversion between string formats and typed values. It handles individual specifications like `UnreachCall`, `NoDataRace`, and `Termination`, as well as multi-specification lists. Use it to load and process SV-COMP properties from files or command-line options, or to generate string representations of expected verification outcomes.",
      "description_length": 449,
      "index": 1590,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.PrecCompare",
      "library": "goblint.lib",
      "description": "This module compares the precision of static analysis results, producing structured outcomes like equal, more precise, or incomparable. It operates on abstract domain values and analysis state dumps, using count-based aggregation and formatted diagnostics. Concrete use cases include analyzing differences between abstract values and evaluating precision across analysis configurations.",
      "description_length": 386,
      "index": 1591,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MCPRegistry",
      "library": "goblint.lib",
      "description": "This module provides a registry system for dynamically activatable analyses, enabling registration, lookup, and retrieval of analysis modules by name or integer identifier while tracking activation states and associating domains, lattices, and system variables with printable or representative components. It operates on polymorphic values paired with integer tags, supporting lattice operations, equality, hashing, and context-sensitive abstract interpretation tasks such as join, meet, widen, and narrowing. Designed for modular static analysis frameworks, it facilitates dynamic product configurations, extensible domain composition, and context-tracking in abstract interpretation workflows.",
      "description_length": 695,
      "index": 1592,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Constants",
      "library": "goblint.lib",
      "description": "Tracks integer constant values of local variables within functions using intraprocedural abstract interpretation. It provides lattice operations, transfer functions for assignments and branches, and state updates for function bodies to enable constant propagation and dead code elimination. Useful for optimizing compiler passes where precise intra-procedural constant information improves code analysis and transformation decisions.",
      "description_length": 433,
      "index": 1593,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.PthreadSignals",
      "library": "goblint.lib",
      "description": "The module implements static analysis for Pthread condition variable signal states in concurrent programs. It uses lattice-based abstract domains and constraint systems to model signal propagation, synchronization, and thread interactions. This enables verification of correctness properties such as absence of missed signals and deadlocks in multi-threaded applications.",
      "description_length": 371,
      "index": 1594,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.TmpSpecial",
      "library": "goblint.lib",
      "description": "Tracks equivalences between variables and math library call results by maintaining expression-to-dependency mappings. It uses CIL expressions and lattice-based structures to model relationships across function calls, assignments, and control flow, enabling precise invalidation when variables are modified. Useful in static analysis of numerical code where equivalences must be updated based on program state changes.",
      "description_length": 417,
      "index": 1595,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.AbortUnless",
      "library": "goblint.lib",
      "description": "This module implements analysis logic for functions that conditionally abort execution based on input conditions, specifically modeling control flow effects of `abortUnless`-like primitives. It provides operations to refine abstract state (`D.t`) and track control dependencies during static analysis of C code. Concrete use cases include modeling assertion failures, environment interactions, and thread state transitions in a context-sensitive analysis.",
      "description_length": 455,
      "index": 1596,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Svcomp",
      "library": "goblint.lib",
      "description": "This module handles SV-COMP tasks and results, providing operations to define and evaluate analysis outcomes using a sum type with `True`, `False`, and `Unknown` states. It includes functions to check error and special functions in CIL variables and supports CFG-based analysis with invariant, violation, and sink detection. Concrete use cases include validating program paths and formatting analysis results for SV-COMP reporting.",
      "description_length": 431,
      "index": 1597,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Analyses",
      "library": "goblint.lib",
      "description": "This module provides foundational components for static analysis, including variable manipulation, abstract domains, and scaffolding mechanisms that operate on CIL program elements like variables, function declarations, and control-flow nodes. Supports constraint system formulation, dataflow analysis, and abstract interpretation with applications in concurrency tracking, domain-specific value analysis, and serialization of analysis states.",
      "description_length": 443,
      "index": 1598,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.BaseInvariant",
      "library": "goblint.lib",
      "description": "This module refines analysis invariants for the `Base` analysis by implementing value domain operations such as `is_some_bot` and `apply_invariant`. It operates on analysis contexts, lvals, and expressions to adjust variable domains during conditional branching and flow analysis. Use cases include narrowing variable ranges based on branch conditions and enforcing expression-derived constraints during static analysis.",
      "description_length": 420,
      "index": 1599,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.AutoSoundConfig",
      "library": "goblint.lib",
      "description": "This module enables analyses required for soundness based on specifications or code idioms, such as SV-COMP properties or `longjmp` usage. It provides functions to activate specific analysis options, including memory safety, termination, and general specification-based analyses, as well as predefined lists of analyses for certain idioms. Concrete use cases include automatically configuring analysis settings when processing code with known requirements, such as enabling memory safety checks for SV-COMP or activating `longjmp`-specific analyses when such constructs are present.",
      "description_length": 582,
      "index": 1600,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.SarifType",
      "library": "goblint.lib",
      "description": "This module defines core data structures and serialization routines for the SARIF (Static Analysis Results Interchange Format) standard. It includes types for representing analysis results such as source code regions, artifact locations, physical locations, messages, reporting descriptors, tools, and full SARIF logs. These types are used to construct and serialize structured static analysis output, enabling integration with tools that consume SARIF-formatted JSON, such as code review systems or CI/CD pipelines.",
      "description_length": 516,
      "index": 1601,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Signs",
      "library": "goblint.lib",
      "description": "This module represents and manipulates integer signs with three possible states: negative, zero, and positive. It provides operations for comparison, equality, conversion from integers, and ordering relations between signs. Concrete use cases include tracking the sign of variables in static analysis and determining the outcome of arithmetic comparisons in abstract interpretation.",
      "description_length": 382,
      "index": 1602,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.LoopUnrolling",
      "library": "goblint.lib",
      "description": "Performs syntactic loop unrolling on CIL functions, transforming loops by duplicating their body a specified number of times. It operates directly on CIL statements and functions, modifying control flow structures to reduce loop iterations at compile time. Useful for optimizing performance-critical code sections by minimizing loop overhead or enabling further static analysis opportunities through expanded loop bodies.",
      "description_length": 421,
      "index": 1603,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.LoopfreeCallstring",
      "library": "goblint.lib",
      "description": "This module implements a loop-free callstring analysis that collapses recursive call cycles into sets to reduce callstring length during context-sensitive static analysis. It works with callstrings, control flow graphs, and lattice structures to track function contexts and improve analysis efficiency in recursive or cyclic scenarios. Concrete use cases include enhancing points-to analysis and thread-modular verification by combining local and global state transitions while maintaining precision for context-sensitive program properties.",
      "description_length": 541,
      "index": 1604,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.AutoTune",
      "library": "goblint.lib",
      "description": "This module's operations center on autotuning analysis configurations through syntactic heuristics and static feedback, dynamically adjusting settings like analysis enablement, recursion context refinement, and domain selection. It leverages specialized data structures\u2014function and variable maps/sets\u2014to track interactions, transform parameters, and model program complexity using CIL files and variable/expressions. Use cases include termination-focused analysis, complexity-driven configuration adaptation, stub detection, and heuristic-based feature activation tailored to program structure and syntactic patterns.",
      "description_length": 618,
      "index": 1605,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.MCP",
      "library": "goblint.lib",
      "description": "This module manages the specification and registration of context-sensitive and path-sensitive analyses. It handles analysis state initialization/finalization with marshaled data, control flow operations, variable declarations, and transfer functions for assignments and conditionals. Used to implement modular analyses that track properties like value ranges, pointer aliasing, or concurrency constraints during static analysis.",
      "description_length": 429,
      "index": 1606,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.WideningToken",
      "library": "goblint.lib",
      "description": "This module combines UUID and optional integer index tokens to uniquely identify and manage widening contexts during abstract interpretation. It supports operations like equality checking, comparison, hashing, string representation, and serialization to XML and Yojson. These tokens are used to track positions in data structures or distinguish recursive contexts in static analysis.",
      "description_length": 383,
      "index": 1607,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.WitnessConstraints",
      "library": "goblint.lib",
      "description": "This module implements lattice operations and transfer functions for path-sensitive abstract interpretation, working with abstract domains for analysis states, constraints, contexts, variables, and paths. It supports inter-procedural and thread-aware state propagation, and generates witnesses for constraint solving. Concrete use cases include modeling function call effects, tracking value flows across control paths, and resolving path-dependent invariants during static analysis.",
      "description_length": 483,
      "index": 1608,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.RecursionTermLifter",
      "library": "goblint.lib",
      "description": "Implements cycle detection and recursion handling in dynamic function call graphs using lattice-based fixed-point computations and constraint propagation. Works with abstract states composed of lattice domains to track and analyze function call contexts during static analysis. Enables precise termination analysis in context-sensitive settings by lifting recursive calls through constraint-based reasoning.",
      "description_length": 407,
      "index": 1609,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.VarEq",
      "library": "goblint.lib",
      "description": "Implements symbolic variable equality analysis with lattice operations (join, meet, widen, narrow) over abstract analysis states. It tracks variable equivalences during assignments and interprocedural transitions, supporting static analysis tasks like constraint merging and fixed-point refinement. Works with symbolic expressions and set-like structures to model variable relationships in programs with pointers and function calls.",
      "description_length": 432,
      "index": 1610,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ViolationZ3",
      "library": "goblint.lib",
      "description": "This module implements path feasibility checking for abstract reachability graphs using weakest precondition calculations with the Z3 theorem prover. It operates on control flow paths and symbolic program states to determine whether a given path is feasible under the program's constraints. Concrete use cases include verifying the reachability of error states in static analysis and pruning infeasible paths during symbolic execution.",
      "description_length": 435,
      "index": 1611,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ThreadReturn",
      "library": "goblint.lib",
      "description": "This module implements a thread return analysis using a boolean abstraction to track whether threads are at the topmost call frame. It provides lattice operations, context management, and transfer functions for function calls and thread creation, working with abstract analysis states and CIL constructs. It is used to propagate return values, merge thread environments, and detect race conditions in concurrent C programs during abstract interpretation.",
      "description_length": 454,
      "index": 1612,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Taint",
      "library": "goblint.lib",
      "description": "This module implements a taint analysis framework that tracks data flow through C programs using abstract interpretation. It provides functions to identify taint sources and sinks, a special variable to model function returns, and a specification module for defining analysis behavior across function calls. It works with CIL variables and expressions, using abstract domains to represent taint states during interprocedural analysis. Concrete use cases include detecting insecure data flows, such as untrusted input reaching sensitive operations, and generating verification witnesses for taint-related bugs.",
      "description_length": 609,
      "index": 1613,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ObserverAnalysis",
      "library": "goblint.lib",
      "description": "This module implements path-sensitive static analysis using an observer automaton to track program states with precise path and constraint dependencies. It operates on lattice-based abstract domains for data, contexts, variables, and path constraints, employing transfer functions for state transitions. It is used for analyzing C programs with complex control flow, thread interactions, and inline assembly, where accurate tracking of path-sensitive behaviors requires unique state identifiers and observer transitions.",
      "description_length": 520,
      "index": 1614,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ApronDomain",
      "library": "goblint.lib",
      "description": "This module implements abstract domains for numerical analysis using APRON, providing operations for creating, combining, and refining abstract values such as intervals, octagons, and polyhedra. It works with abstract value types representing program states and constraints, supporting operations like meet, join, and widening. Concrete use cases include tracking numeric variable bounds and invariants during static analysis of imperative code.",
      "description_length": 445,
      "index": 1615,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Refinement",
      "library": "goblint.lib",
      "description": "This module implements analysis refinement by restarting the analysis with modified global state, enabling more precise results. It works with global analysis state and transfer functions, allowing dynamic activation or reconfiguration of analyses like Witness. Concrete use cases include adding context-sensitive information, enabling path-sensitive analyses, or registering new analyses during refinement steps.",
      "description_length": 413,
      "index": 1616,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ThreadId",
      "library": "goblint.lib",
      "description": "This module tracks thread identifiers and provides operations to retrieve and analyze current thread states in concurrent programs. It works with thread identifiers composed of variable info, control flow nodes, and creation counts, supporting static analysis tasks like fixpoint stabilization and context-sensitive data flow tracking. Concrete use cases include modeling thread creation and termination, merging thread states during synchronization, and debugging thread interactions using serialized state representations.",
      "description_length": 524,
      "index": 1617,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.AbstractionDomainProperties",
      "library": "goblint.lib",
      "description": "This module defines QCheck properties for verifying correctness of abstract operations. It works with abstract domains and their associated functions, ensuring they satisfy expected behaviors under abstraction. Concrete use cases include testing soundness of abstract transformers and validating domain-specific invariants during analysis.",
      "description_length": 339,
      "index": 1618,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.CilCfg",
      "library": "goblint.lib",
      "description": "Builds and analyzes control flow graphs (CFGs) for CIL-processed programs. It identifies end basic blocks, counts loops, and constructs CFGs from CIL files. Useful for static analysis tasks like control flow inspection and optimization.",
      "description_length": 236,
      "index": 1619,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.DomainProperties",
      "library": "goblint.lib",
      "description": "This module implements QCheck property tests for lattice structures, focusing on core operations like `leq`, `join`, and `meet` against algebraic laws. It works with lattice elements from a domain module `D`, ensuring correctness of properties such as associativity, commutativity, idempotence, and absorption. Concrete use cases include validating lattice-based abstract domains in static analysis, such as integer ranges or pointer aliasing, through randomized testing.",
      "description_length": 471,
      "index": 1620,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.DeadlockDomain",
      "library": "goblint.lib",
      "description": "This module provides data structures and operations for tracking lock events and their relationships in concurrent programs. It includes a representation of lock events with ordering and set manipulation capabilities, as well as a lattice structure for abstract interpretation during deadlock analysis. It is used to model potential lock acquisition sequences and detect conflicting synchronization patterns in static analysis.",
      "description_length": 427,
      "index": 1621,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.DeadCode",
      "library": "goblint.lib",
      "description": "This module implements dead code elimination by analyzing control flow graphs to identify and remove unreachable code. It provides functions to filter statements from blocks, determine execution halting points, and track live statements during traversal. Key operations include block transformation, statement filtering, and CFG-based reachability analysis, working directly with CIL blocks, statements, and control flow structures.",
      "description_length": 432,
      "index": 1622,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.LoopTermination",
      "library": "goblint.lib",
      "description": "This module analyzes loop and `goto` statement termination in C programs using abstract interpretation. It tracks loop counter variables and their associated statements, determining whether variables can be bounded to infer termination. The analysis leverages lattice-based abstract states and statement contexts to model and combine termination behavior during static analysis.",
      "description_length": 378,
      "index": 1623,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.UnassumeAnalysis",
      "library": "goblint.lib",
      "description": "Implements unassume analysis by processing YAML witness invariants and emitting corresponding unassume events for other analyses. It operates on CIL expressions and function declarations, using specialized hash tables and maps to track and propagate constraints. Used during static analysis to refine invariants and validate program properties based on external witness annotations.",
      "description_length": 382,
      "index": 1624,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Sarif",
      "library": "goblint.lib",
      "description": "This module converts Goblint analysis messages into SARIF (Static Analysis Results Interchange Format) structures. It provides functions to transform message data into SARIF reporting descriptors, locations, artifacts, and results, supporting output generation for static analysis tools. It works with message types from the `Messages` module and constructs SARIF-compliant JSON output for integration with analysis platforms.",
      "description_length": 426,
      "index": 1625,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.StackDomain",
      "library": "goblint.lib",
      "description": "This module implements call stack analysis domains with specialized data structures for variable tracking, location sensitivity, and lattice operations. It provides concrete functionality for merging hierarchical variable domains, comparing and transforming location-based call paths, and performing stack-aware set and lattice operations. Use cases include interprocedural static analysis, context-sensitive variable resolution, and precise call path comparison in abstract interpretation.",
      "description_length": 490,
      "index": 1626,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ModifiedSinceSetjmp",
      "library": "goblint.lib",
      "description": "This module tracks variables modified since `setjmp` using context-based abstract interpretation. It handles CIL expressions, variable identifiers, and function definitions, integrating with abstract domains for static analysis. It ensures correctness in scenarios involving non-local jumps (`longjmp`) by precisely modeling variable modifications across control-flow transitions.",
      "description_length": 380,
      "index": 1627,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.UnitAnalysis",
      "library": "goblint.lib",
      "description": "Performs static analysis using a unit domain to model program state transitions and concurrency effects. It handles assignments, branches, function calls, and thread operations on abstract domain values and CIL constructs. Useful for analyzing imperative programs with concurrency where tracking state changes and thread interactions is critical.",
      "description_length": 346,
      "index": 1628,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.SpecLifters",
      "library": "goblint.lib",
      "description": "This module combines multiple lifters to enhance static analysis capabilities by addressing context sensitivity, path sensitivity, and domain optimization. It provides operations for hash-consing abstract values, managing widening iterations, tracking dead code and branches, and lifting transfer functions for interprocedural and concurrent program constructs. These components work with abstract domains (`D.t`, `G.t`, `C.t`), constraint variables (`V.t`), and program paths (`P.t`) to enable precise analysis of function calls, thread synchronization, and control flow in complex C programs.",
      "description_length": 594,
      "index": 1629,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.RegionDomain",
      "library": "goblint.lib",
      "description": "This module provides lattice-based operations and data structures for modeling disjoint heap regions in static analysis, combining region partitioning and mapping functionalities. It works with abstract region sets, variables, and polymorphic variants to track memory state and relationships during abstract interpretation. Concrete use cases include analyzing memory safety, resolving region ownership, and propagating values across disjoint heap segments in the presence of dynamic memory allocation.",
      "description_length": 502,
      "index": 1630,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.PrecCompareUtil",
      "library": "goblint.lib",
      "description": "This module implements precision comparison logic for abstract domains, providing functions to compare and combine domain elements with varying precision levels. It operates on data types that conform to the `LocalizedPrintable`, `R`, and `S` signatures, which define how values are printed and compared. Concrete use cases include resolving conflicts between analysis results from different domains and determining the more precise value during fixpoint computations.",
      "description_length": 468,
      "index": 1631,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Timeout",
      "library": "goblint.lib",
      "description": "Implements time-limited execution of functions with support for cancellation, using either Unix-style signals or JavaScript-style timers. Works with functions of type `'a -> 'b`, input values of type `'a`, and cancellation callbacks. Useful for enforcing timeouts on network requests, long-running analyses, or event-driven computations.",
      "description_length": 337,
      "index": 1632,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.SymbLocks",
      "library": "goblint.lib",
      "description": "This module performs symbolic lockset analysis for concurrent programs using lattice-based domains to track per-element locking patterns. It operates on symbolic lock primitives and parametric collections, enabling precise reasoning about lock acquisition, release, and invalidation. Concrete use cases include static race detection in C device drivers by modeling dynamic synchronization behavior during abstract interpretation.",
      "description_length": 429,
      "index": 1633,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.ExpRelation",
      "library": "goblint.lib",
      "description": "This module provides abstract interpretation operations to determine must-equality between expressions based on syntactic analysis. It works with expressions, variables, paths, and constraints, using transfer functions for control flow and function calls. It is used in static race detection and concurrency analysis to reason about expression equivalence in parallel contexts.",
      "description_length": 377,
      "index": 1634,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Region",
      "library": "goblint.lib",
      "description": "This module implements region analysis for tracking disjoint heap regions in dynamic memory, supporting precise race detection. It defines operations to represent and manipulate memory regions, including merging, splitting, and comparing regions based on their disjointness. Concrete use cases include analyzing concurrent programs to identify non-overlapping memory accesses and improving static analysis precision in Goblint.",
      "description_length": 427,
      "index": 1635,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Malloc_null",
      "library": "goblint.lib",
      "description": "This module analyzes dynamic memory allocation failures and null pointer usage in C programs by tracking path-sensitive conditions through abstract domain states and CIL structures. It performs lattice operations, value comparisons, and memory safety checks to detect potential null dereferences and allocation errors during control flow analysis. Use cases include identifying unsafe pointer dereferences resulting from failed `malloc` calls and ensuring proper null checks in low-level C code.",
      "description_length": 495,
      "index": 1636,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Events",
      "library": "goblint.lib",
      "description": "This module defines event types for tracking program analysis events such as locking, unlocking, thread assignment, and expression evaluation. It works with abstract domains like address sets, thread identifiers, and expressions. Used in static analysis to model concurrency effects, branch decisions, and memory accesses during value flow tracking.",
      "description_length": 349,
      "index": 1637,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.StackTrace",
      "library": "goblint.lib",
      "description": "This module implements call stack analysis functionality for static program analysis, providing operations to track and manipulate call stacks, set and propagate stack traces, and manage specification locations during symbolic execution. It works with abstract analysis contexts, CIL statements, and symbolic execution data structures like stack traces and specification locations to model control flow and concurrency events. Concrete use cases include tracking function calls across threads, resolving call graphs, and generating precise stack traces for analysis reports.",
      "description_length": 574,
      "index": 1638,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Control",
      "library": "goblint.lib",
      "description": "Implements the core analysis loop and state management for abstract interpretation. It coordinates constraint solving over control flow graphs, handling program analysis with support for querying variable and global states during execution. Used to drive analysis passes over CIL-processed code, producing results for specific program points and variables.",
      "description_length": 356,
      "index": 1639,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Callstring",
      "library": "goblint.lib",
      "description": "This module implements context-sensitive static analysis using call string and call site tracking for precise function context identification. It provides lattice operations, context manipulation, and transfer functions for handling function calls, returns, and concurrency, operating on abstract domains, call contexts, and constraint variables. Concrete use cases include k-limited call stack tracking (k-CFA) for scalable analysis and infinite call string tracking for precision, with applications in witness validation and thread-aware analysis.",
      "description_length": 549,
      "index": 1640,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Assert",
      "library": "goblint.lib",
      "description": "This module implements abstract interpretation domains and transfer functions to analyze and verify assertions in low-level code. It works with lattice structures, constraint variables, and CIL expressions to model program states and track assertion outcomes across control flow transitions. Concrete use cases include verifying branching conditions, function return states, and thread creation points during static analysis.",
      "description_length": 425,
      "index": 1641,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.WrapperFunctionAnalysis",
      "library": "goblint.lib",
      "description": "This module analyzes wrapper functions to generate symbolic heap locations for dynamic memory allocations and symbolic thread identifiers for thread creation. It operates on abstract domains and CIL structures to track memory and thread state changes at program points like `malloc` calls and thread spawning. Concrete use cases include precise static analysis of concurrent C programs to detect memory errors and concurrency bugs by distinguishing thread-specific allocations and modeling thread creation events.",
      "description_length": 513,
      "index": 1642,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Witness",
      "library": "goblint.lib",
      "description": "This module writes analysis results and witnesses in GraphML format for SV-COMP tasks. It works with abstract reachability graphs, task results, and specification contexts. Concrete use cases include exporting verification outcomes such as value constraints or property checks at specific program points.",
      "description_length": 304,
      "index": 1643,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ThreadJoins",
      "library": "goblint.lib",
      "description": "This module implements a joined threads analysis for concurrent programs, tracking thread creation, termination, and synchronization events using thread identifiers (TIDs) and lattice-based abstract states. It supports precise modeling of thread interactions through synchronization primitives and function calls, enabling analysis of programs with dynamic threading and complex control flow. Concrete use cases include detecting race conditions and verifying thread-modular correctness properties in systems with fine-grained concurrency.",
      "description_length": 539,
      "index": 1644,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.Base",
      "library": "goblint.lib",
      "description": "This module implements non-relational value analysis by defining core operations for abstract interpretation, including value domain manipulations and transfer functions. It works with abstract values, program points, and variable environments to track dataflow information during analysis. Concrete use cases include constant propagation, interval analysis, and sign analysis for numerical variables in C code.",
      "description_length": 411,
      "index": 1645,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Access",
      "library": "goblint.lib",
      "description": "This module enables the analysis and transformation of memory access patterns in static code by tracking variable and type offsets through thread-safe hash tables and combinator-based operations. It works with memory access descriptions (`A.t`), access sets (`AS.t`), and categorized access groups (`WarnAccs.t`) to detect data races, distribute access sets across expressions, and summarize access behavior for concurrent program optimization. Key applications include static race detection and efficient handling of memory access hierarchies in multi-threaded analysis.",
      "description_length": 571,
      "index": 1646,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ExtractPthread",
      "library": "goblint.lib",
      "description": "This module provides analysis and translation capabilities for converting C programs with Pthread-based concurrency into Promela, enabling formal verification. It operates on concurrency primitives like threads, mutexes, and condition variables, while leveraging lattice-based domains to model synchronization and control flow. The generated Promela code supports model checking of thread interactions, resource contention, and safety properties in concurrent systems.",
      "description_length": 468,
      "index": 1647,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Uninit",
      "library": "goblint.lib",
      "description": "This module analyzes uninitialized local variables by tracking their states through static analysis. It uses lattice-based abstract domains to model initialization across control flow and data dependencies, specifically handling CIL expressions, function definitions, and memory-related constructs. It is used to detect unsafe uninitialized variable accesses and to merge analysis environments during dataflow analysis.",
      "description_length": 419,
      "index": 1648,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.MutexTypeAnalysis",
      "library": "goblint.lib",
      "description": "This module analyzes mutex types in concurrent programs by tracking `pthreadMutexType` through lattice domains, constraint variables, and path-sensitive abstract states. It determines whether a given mutex variable must be of a recursive type based on static analysis of function calls, thread creation, and locking patterns. A concrete use case is verifying correct mutex initialization and usage to prevent deadlocks and ensure thread-safety in multi-threaded C programs.",
      "description_length": 473,
      "index": 1649,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ResultQuery",
      "library": "goblint.lib",
      "description": "This module performs local and global queries on a constraint system solution, retrieving results for variables, nodes, or the entire system. It operates on constraint graphs, variable identifiers, and analysis nodes within a solver context. Use it to extract variable values at specific program points or generate summaries of the global solution during or after constraint resolution.",
      "description_length": 386,
      "index": 1650,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goblint_lib.Violation",
      "library": "goblint.lib",
      "description": "This module implements violation checking in abstract reachability graphs (ARGs) by determining whether paths are feasible, infeasible, or unknown. It operates on nodes and edges in an ARG, using a combination of sink detection and path feasibility analysis. Concrete use cases include validating program paths during static analysis to confirm whether a potential violation can occur.",
      "description_length": 385,
      "index": 1651,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.GobExn",
      "library": "goblint.lib",
      "description": "Provides a function `catch_all_filter` that safely filters exceptions, allowing controlled handling of exceptional cases without suppressing critical exceptions. Works directly with the `exn` type. Useful in scenarios where exception handling must be cautious, such as in analysis frameworks or robust server loops.",
      "description_length": 315,
      "index": 1652,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib.ActiveSetjmp",
      "library": "goblint.lib",
      "description": "Tracks active `setjmp` buffers and models `longjmp` control flow during static analysis of C programs. It operates on lattice-based abstract states (`D.t`) to represent buffer lifetimes and control transitions in CIL code, supporting concurrency and context-sensitive analysis. Used to detect invalid `longjmp` targets and analyze control flow anomalies in programs with non-local exits.",
      "description_length": 387,
      "index": 1653,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goblint_lib",
      "library": "goblint.lib",
      "description": "This module provides core static analysis operations for C programs, including abstract interpretation, constraint solving, concurrency tracking, and context/path-sensitive analysis. It operates on CIL-based program representations (ASTs, control flow graphs, expressions), abstract domains (numerical intervals, memory states, locks), and analysis states to detect concurrency issues (races, deadlocks), memory safety violations (null dereferences, leaks), and perform code optimization, termination verification, and precision-controlled symbolic reasoning. Key applications include verifying thread safety, generating SV-COMP-compliant witnesses, refining abstract domains via Apron comparisons, and integrating SMT solvers like Z3 for violation checking.",
      "description_length": 758,
      "index": 1654,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 1724,
    "meaningful_modules": 1655,
    "filtered_empty_modules": 69,
    "retention_rate": 0.9599767981438515
  },
  "statistics": {
    "max_description_length": 836,
    "min_description_length": 129,
    "avg_description_length": 454.38851963746225,
    "embedding_file_size_mb": 23.984189987182617
  }
}