{
  "package": "jsonxt",
  "embedding_model": "Qwen/Qwen3-Embedding-8B",
  "embedding_dimension": 4096,
  "total_modules": 35,
  "creation_timestamp": "2025-08-14T20:34:38.163656",
  "modules": [
    {
      "module_path": "Jsonxt.Strict.Compliance.Stream",
      "library": "jsonxt",
      "description": "This module constructs JSON streams with strict compliance to the JSON standard, supporting atomic values like strings, booleans, null, and numbers (including special float values and large integers via strings). It provides explicit start and end markers for structured types such as arrays, objects, tuples, and variants, ensuring valid nesting and formatting. Use cases include generating JSON for APIs, configuration files, or data interchange where strict conformance and precise control over JSON structure are required.",
      "description_length": 526,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Jsonxt.Yojson.Safe.Util",
      "library": "jsonxt",
      "description": "This module offers functions for safe, functional manipulation of polymorphic variant-based JSON structures, emphasizing field access, type conversion, and list or associative map transformations. It supports tasks like extracting nested values, filtering heterogeneous JSON arrays by type, converting JSON numbers to OCaml primitives, and recursively sorting associative lists, making it suitable for processing structured JSON data pipelines or transforming JSON into typed OCaml representations.",
      "description_length": 498,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Jsonxt.Extended.Compliance.Stream",
      "library": "jsonxt",
      "description": "This module constructs JSON streams with support for extended types like integers, tuples, and variants. It provides functions to emit JSON elements such as numbers, strings, booleans, arrays, objects, and named fields directly into a stream. Use it to build complex JSON structures incrementally, especially when handling large integers or non-standard JSON types like variants.",
      "description_length": 379,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Jsonxt.Yojson.Basic.Util",
      "library": "jsonxt",
      "description": "This module provides functional transformations and safe type extraction for navigating and manipulating JSON structures, with operations like field/index access, list mapping, and type-constrained filtering. It works with polymorphic variant types representing JSON elements (e.g., `Int`, `Bool`, `Assoc`) and emphasizes handling heterogeneous data through combinators that safely process optional values, nullable fields, or mixed-type arrays. Specific use cases include parsing nested JSON APIs, extracting typed values from dynamic configurations, and transforming JSON trees with guaranteed type correctness.",
      "description_length": 613,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Jsonxt.Basic.Compliance.Stream",
      "library": "jsonxt",
      "description": "This module constructs JSON streams using basic data types like integers, floats, strings, and booleans, while supporting non-standard JSON features such as infinity and NaN. It provides functions to emit JSON elements including objects, arrays, tuples, and variant tags, with control over stream structure via start and end markers. Use cases include generating JSON output incrementally for large data sets or streaming applications where memory efficiency is critical.",
      "description_length": 471,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Jsonxt.Basic_monad.Make",
      "library": "jsonxt",
      "description": "The module defines functions for reading and writing JSON values using an IO monad, supporting both compact and human-readable formatting. It works with the `Json.Basic.json` type, handling parsing from input sources and serializing to output streams. Concrete use cases include reading JSON from a file descriptor or network socket and writing formatted JSON to a log or configuration file.",
      "description_length": 391,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Jsonxt.Basic.Compliance",
      "library": "jsonxt",
      "description": "This module enables parsing and constructing JSON values with extended numeric representations, including integers (with precise handling up to \u00b12\u2075\u00b3), large integers encoded as strings, and non-standard JSON variants. It operates on structured data like lists, associative arrays, and tuples, while supporting memory-efficient streaming output for large datasets. The Stream submodule specifically facilitates incremental JSON generation with custom formatting for special values like infinity or NaN, ideal for processing high-volume data streams without full in-memory representation.",
      "description_length": 586,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Jsonxt.Extended_monad.Make",
      "library": "jsonxt",
      "description": "This module provides functions to read and write extended JSON values using an IO monad, handling non-standard types like integers, tuples, and variants. It works with the `Jsonxt.Extended.Compliance.json` type, offering both compact and human-readable output formats. Concrete use cases include parsing JSON streams from files or network sockets and generating formatted JSON output for logging or configuration files.",
      "description_length": 419,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Jsonxt.Basic.Process",
      "library": "jsonxt",
      "description": "This module provides functions for accessing, transforming, and filtering JSON data structured as lists and associative arrays (objects), with support for converting JSON elements to OCaml primitives like integers, floats, and strings. It handles nested structures through flattening operations and safely manages integer values beyond the JSON standard, including overflow conversion to floats for values outside 62-bit or 30-bit ranges. Specific use cases include processing JSON data with large integers, filtering typed values from collections, and restructuring nested JSON arrays or objects into flattened forms.",
      "description_length": 618,
      "index": 8,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Jsonxt.Extended.Compliance",
      "library": "jsonxt",
      "description": "This module supports parsing and constructing JSON values with non-standard types such as large integers, tuples, and variants, using low-level lexing and conversion utilities. It enables incremental JSON stream generation for handling complex or large data structures efficiently, particularly when working with extended types like tuples and variants that require streaming-friendly memory management.",
      "description_length": 403,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Jsonxt.Json.Extended",
      "library": "jsonxt",
      "description": "This module handles extended JSON representations including tuples and variants, supporting parsing and serialization of non-standard JSON constructs. It works with the `json` type, accommodating additional forms beyond strict JSON compliance. Use it to process JSON data that includes OCaml-specific extensions like tuples and polymorphic variants.",
      "description_length": 349,
      "index": 10,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Jsonxt.Json.Strict",
      "library": "jsonxt",
      "description": "This module defines a strict JSON type that adheres to the JSON standard, excluding integers. It provides functions to construct, deconstruct, and manipulate JSON values including null, boolean, float, string, associative lists, and lists. Use this module when working with JSON data that must strictly conform to the standard, such as exchanging data with web APIs or parsing JSON from external sources.",
      "description_length": 404,
      "index": 11,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Jsonxt.Json_stream.Basic",
      "library": "jsonxt",
      "description": "This module defines the basic JSON stream type with support for standard JSON values, including integers, floats, strings, booleans, null, and structural markers for arrays and objects. It provides constructors and pattern matching for building and deconstructing JSON tokens in a streaming context. Concrete use cases include parsing and generating JSON data incrementally, handling large JSON inputs efficiently, and implementing custom JSON processors without loading the entire document into memory.",
      "description_length": 503,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Jsonxt.Strict.Process",
      "library": "jsonxt",
      "description": "This module provides functional traversal, extraction, and transformation operations for strict JSON structures, focusing on safe, option-aware access to objects and arrays. It works directly with `Json.Strict.json` values to enable precise manipulation of JSON data through combinators like `map`, `filter_map`, and `to_assoc`, while supporting conversions to OCaml primitives with explicit handling of optional fields. Typical use cases include processing configuration files, API responses, or structured logs where type safety and precision in numeric representations (e.g., integers as floats within 2^53 range) are critical.",
      "description_length": 630,
      "index": 13,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Jsonxt.Extended.Process",
      "library": "jsonxt",
      "description": "This module supports traversal, extraction, and transformation of JSON structures with extended types, focusing on safe access to fields, arrays, and polymorphic variants. It operates on `Json.Extended.json` values, handling integers (with overflow-aware conversion to floats), tuples, and variant forms while enabling type-preserving operations like filtering, mapping, and recursive sorting. Typical use cases include processing JSON APIs or configuration data that leverage non-standard types, such as integers beyond JavaScript's safe range or structured variants, with robust error handling for optional or malformed fields.",
      "description_length": 629,
      "index": 14,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Jsonxt.Strict_monad.Make",
      "library": "jsonxt",
      "description": "This module provides functions to read and write strict JSON values using an IO monad, handling both compact and human-readable formatting. It works with the `Jsonxt.Strict.Compliance.json` type, which represents JSON data conforming to the standard, excluding integers. Use it to parse JSON from a byte stream or write formatted JSON to a destination, such as a file or network socket, with control over indentation and line endings.",
      "description_length": 434,
      "index": 15,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Jsonxt.Strict.Compliance",
      "library": "jsonxt",
      "description": "This module provides lexing and construction capabilities for JSON values adhering to strict standards, handling primitives like strings, booleans, null, and structured types such as arrays, objects, tuples, and variants. It enforces precise numeric representation by excluding integers entirely, instead using floats to accurately encode integer-like values within the 53-bit precision range, ensuring no loss of fidelity. It is ideal for applications requiring rigorous JSON compliance, such as API data exchange, configuration systems, and cross-platform data serialization where structural validity and numeric precision are paramount.",
      "description_length": 639,
      "index": 16,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Jsonxt.Json_stream.Strict",
      "library": "jsonxt",
      "description": "This module defines a strict JSON stream type that adheres to the JSON standard, excluding integers. It includes constructors for null, boolean, float, string, array and object markers, and object field names. Use this type to represent and process JSON data where strict compliance with the JSON specification is required, such as parsing or generating JSON from files or strings in a streaming fashion.",
      "description_length": 404,
      "index": 17,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Jsonxt.Json.Basic",
      "library": "jsonxt",
      "description": "This module defines the core JSON data type with support for standard JSON values, including integers, floats, strings, booleans, null, associative lists, and nested lists. It provides functions for constructing, inspecting, and manipulating JSON values directly. Concrete use cases include parsing and generating JSON data in applications that require precise numeric types and structured data exchange.",
      "description_length": 404,
      "index": 18,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Jsonxt.Json_stream.Extended",
      "library": "jsonxt",
      "description": "This module provides functions to parse and construct JSON values, including non-standard tuples and variants as supported by Yojson. It works with the `json` type, which represents JSON values with extended constructors for tuples and variants. Use this module when handling JSON data that requires support for these additional types, such as when interoperating with systems using Yojson's extended JSON format.",
      "description_length": 413,
      "index": 19,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Jsonxt.Strict_monad",
      "library": "jsonxt",
      "description": "This module provides functions to parse and generate JSON values using an IO monad, specifically handling the `Jsonxt.Strict.Compliance.json` type that enforces strict JSON compliance without integers. It supports reading JSON from byte streams and writing JSON to output channels, with options for compact or human-readable formatting. Concrete use cases include reading JSON from a file descriptor or sending formatted JSON over a network connection.",
      "description_length": 452,
      "index": 20,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Jsonxt.Extended_monad",
      "library": "jsonxt",
      "description": "This module provides monadic functions for parsing and writing extended JSON values, supporting non-standard types like integers, tuples, and variants. It operates on the `Jsonxt.Extended.Compliance.json` type, enabling both compact and human-readable output. Use it to handle JSON streams from files or network sockets and to generate structured JSON output for logging or configuration.",
      "description_length": 388,
      "index": 21,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Jsonxt.Strict_stream",
      "library": "jsonxt",
      "description": "This module parses and writes strict JSON streams using `Json_stream.Strict.json` values, supporting only JSON-standard types while excluding integers. It provides streaming readers for strings, channels, and custom byte functions, along with encoders for compact or human-readable output to channels or custom output functions. Use cases include processing large JSON arrays element-by-element from files or network streams and generating JSON output incrementally without building full structures in memory.",
      "description_length": 509,
      "index": 22,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Jsonxt.Basic",
      "library": "jsonxt",
      "description": "This module supports parsing and serialization of JSON data with extended numeric handling, operating on structured values like lists, objects, and numeric types that include platform-dependent integers beyond standard JSON's limits. It provides streaming processing capabilities for large datasets and safe conversions between numeric representations, with configurable formatting for compact or human-readable output. Key use cases include high-precision numerical data exchange and memory-efficient processing of extended JSON streams where integer fidelity is critical within architectural constraints.",
      "description_length": 606,
      "index": 23,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Jsonxt.Json_stream",
      "library": "jsonxt",
      "description": "This module defines a JSON stream type for representing JSON tokens as they are parsed or generated, supporting various compliance levels through its submodules. It works with the `json` type, which includes constructors for JSON primitives, structural markers, and special values. Use this module to process JSON incrementally, handle large JSON inputs efficiently, or enforce strict JSON compliance when parsing or generating JSON data.",
      "description_length": 438,
      "index": 24,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Jsonxt.Json",
      "library": "jsonxt",
      "description": "This module defines the core JSON data type with support for standard JSON values, including integers, floats, strings, booleans, null, associative lists, and nested lists. It provides functions for constructing, inspecting, and manipulating JSON values directly. Concrete use cases include parsing and generating JSON data in applications that require precise numeric types and structured data exchange.",
      "description_length": 404,
      "index": 25,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Jsonxt.Yojson",
      "library": "jsonxt",
      "description": "This module provides Yojson-compatible parsing and lexing functionality for JSON data, working with standard OCaml types and buffers. It includes lexing state management and initialization functions, supporting direct integration with existing Yojson-based workflows. Concrete use cases include parsing JSON from strings or files while maintaining compatibility with Yojson's interface and handling JSON lexing with customizable buffer and position tracking.",
      "description_length": 458,
      "index": 26,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Jsonxt.Extended_stream",
      "library": "jsonxt",
      "description": "This module parses and writes JSON streams with extended types like integers, tuples, and variants, using the `json_stream` type. It provides streaming APIs for reading JSON data from strings, channels, or custom input functions, and writing to output channels or custom consumers. Concrete use cases include processing large JSON datasets that exceed memory limits and encoding custom JSON extensions for transmission over streams.",
      "description_length": 432,
      "index": 27,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Jsonxt.Strict",
      "library": "jsonxt",
      "description": "This module provides precise JSON parsing and serialization operations for strict JSON values, handling input sources like strings, files, and streams while enforcing JSON standard compliance. It works with JSON structures that exclude integers but support lossless float representations of integers within \u00b12\u2075\u00b3, offering both error-aware result types and exception-based variants. Typical use cases include API development requiring strict schema adherence, financial data processing needing numeric precision, and streaming applications using newline-separated JSON formats.",
      "description_length": 576,
      "index": 28,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Jsonxt.Extended",
      "library": "jsonxt",
      "description": "This module provides parsing and serialization capabilities for JSON data with extended types, including high-precision integers (up to 53 bits without loss), tuples, and variants, while handling overflow by converting large integers to floats. It operates on `Json.Extended.json` values and supports input/output through strings, files, channels, lex buffers, and streaming sources, offering both compact and human-readable formatting options with error handling via exceptions or result types. Its streaming features and structured traversal modules enable efficient processing of complex data pipelines, compliance validation, and type-preserving transformations for extended JSON formats.",
      "description_length": 692,
      "index": 29,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Jsonxt.Basic_stream",
      "library": "jsonxt",
      "description": "This module parses and writes JSON streams as sequences of `json_stream` elements, supporting non-standard integers. It provides functions to create stream parsers from strings, channels, or custom read functions, and to decode or encode JSON elements incrementally. Use cases include processing large JSON inputs in a memory-efficient way, such as reading JSON lines from a network socket or writing structured logs to a file.",
      "description_length": 427,
      "index": 30,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Jsonxt.Error_info",
      "library": "jsonxt",
      "description": "This module defines a structured error type for parsing JSON input, capturing line numbers, character positions, and error messages. It includes functions to create error information from a lexing buffer and convert it to a human-readable string. It is used to report precise parsing errors when processing JSON files or strings.",
      "description_length": 329,
      "index": 31,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Jsonxt.Utilities",
      "library": "jsonxt",
      "description": "This module converts JSON trees between different type representations, including `Basic.json` and `Strict.json`, and provides functions to serialize JSON trees into string representations, either as standard JSON or as a custom textual format. It supports operations like `to_basic`, `to_strict`, `json_to_string`, and `json_to_string_repr` for type conversion and string output, along with `equal` for deep structural comparison of JSON trees. Use cases include normalizing JSON data for downstream processing, generating human-readable debug output, and validating JSON structure equality across different parsing contexts.",
      "description_length": 626,
      "index": 32,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Jsonxt.Basic_monad",
      "library": "jsonxt",
      "description": "This module provides functions for parsing JSON from input sources and serializing JSON to output streams using an IO monad. It operates on the `Json.Basic.json` type, supporting both compact and human-readable formatting. Use it to read JSON from a file descriptor or network socket and write structured JSON to logs or configuration files.",
      "description_length": 341,
      "index": 33,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Jsonxt",
      "library": "jsonxt",
      "description": "Jsonxt offers high-performance JSON parsing and writing for files, strings, and streams, supporting multiple compliance levels and numeric extensions. It operates on structured JSON values including extended integers, tuples, and variants, with modules optimized for memory-efficient streaming and strict schema adherence. Concrete use cases include processing large JSON datasets from network sockets, exchanging high-precision numerical data, and enforcing strict JSON compliance in API development.",
      "description_length": 501,
      "index": 34,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 38,
    "meaningful_modules": 35,
    "filtered_empty_modules": 3,
    "retention_rate": 0.9210526315789473
  },
  "statistics": {
    "max_description_length": 692,
    "min_description_length": 329,
    "avg_description_length": 482.62857142857143,
    "embedding_file_size_mb": 0.5074777603149414
  }
}