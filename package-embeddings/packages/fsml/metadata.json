{
  "package": "fsml",
  "embedding_model": "Qwen/Qwen3-Embedding-8B",
  "embedding_dimension": 4096,
  "total_modules": 24,
  "creation_timestamp": "2025-08-15T12:09:00.400383",
  "modules": [
    {
      "module_path": "Fsml.Tevents.Ops",
      "library": "fsml",
      "description": "Merges sequences of timed events based on clock cycles, combining events occurring at the same time. Works with lists of timed events, where each event is a tuple of an integer timestamp and a list of assignments. Useful for simulating concurrent state changes in digital circuits or scheduling systems.",
      "description_length": 303,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fsml.Simul",
      "library": "fsml",
      "description": "This module performs simulation steps on finite state machines by processing events and updating states based on transition rules. It operates on contexts containing current state, environment variables, and clock information, using functions like `step` for single transitions and `run` for full execution sequences. It supports timed event input, conditional stopping via guards, and trace generation for debugging specific simulation behaviors.",
      "description_length": 447,
      "index": 1,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fsml.Action",
      "library": "fsml",
      "description": "This module defines transition actions that manipulate state by assigning values to identifiers, using expressions evaluated in a given environment. It supports serializing actions to strings and JSON, and performing actions to produce events during simulation. Concrete use cases include updating state variables in a state machine and logging or transmitting action data in a standardized format.",
      "description_length": 398,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fsml.Dot",
      "library": "fsml",
      "description": "Handles DOT format output for finite state machines, providing customizable visualization options. It writes `.dot` files with configurable layout, node appearance, and rendering parameters, and can launch external viewers. Used to generate and display graphical representations of FSMs for debugging or documentation.",
      "description_length": 318,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fsml.Vcd",
      "library": "fsml",
      "description": "Writes and visualizes VCD files representing timed event sequences for finite state machines. Converts event data into the VCD format and supports launching external viewers to inspect signal changes over time. Useful for debugging digital circuit simulations by tracking state transitions and signal activity.",
      "description_length": 310,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fsml.Fsm_parser",
      "library": "fsml",
      "description": "This module defines a lexer and parser for a domain-specific language representing finite state machines. It processes input into tokens like identifiers, operators, and keywords, then parses them into structured FSM components such as transitions, guards, and actions. It is used to read FSM descriptions from text, enabling programmatic manipulation and execution of state machines based on custom input formats.",
      "description_length": 414,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fsml.Vhdl",
      "library": "fsml",
      "description": "This module generates VHDL code for finite state machines (FSMs) with configurable signal names and encoding options. It provides a `write` function that outputs a VHDL entity and architecture to a file, implementing a synchronous FSM with clock and reset signals. Use this module to produce synthesizable VHDL code from an FSM definition, for example, to target FPGA or ASIC implementations with customizable signal names and action semantics.",
      "description_length": 444,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fsml.Clock",
      "library": "fsml",
      "description": "This module defines a clock type as an integer and provides functions to format and display clock values. It also includes utilities to pretty-print and convert clocked values, which pair a value with a clock, into strings. These operations are useful for logging or debugging systems where events are timestamped with a discrete clock cycle.",
      "description_length": 342,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fsml.C",
      "library": "fsml",
      "description": "This module generates C code implementing a finite state machine (FSM) from a given model. It writes header and source files containing a function that steps through the FSM, handling transitions and updating state based on input values. The generated function operates on a context structure tracking inputs, outputs, and local variables, enabling direct integration into C projects for embedded or system-level FSM execution.",
      "description_length": 427,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fsml.Fsm",
      "library": "fsml",
      "description": "This module defines operations for constructing, transforming, and serializing finite state machines (FSMs). It supports FSMs composed of states, transitions, inputs, outputs, and local variables, with functions to convert between JSON and FSM representations, clean unreachable states, and transform output behavior between Mealy and Moore types. Specific use cases include defactorizing variables to expand states, adjusting output assignments, and persisting FSMs to or loading them from files or strings.",
      "description_length": 508,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fsml.Fsm_lexer",
      "library": "fsml",
      "description": "Implements a lexer for parsing FSM (Finite State Machine) descriptions. It tokenizes input using a predefined keyword table and OCaml's lexing infrastructure, converting character streams into tokens for the FSM parser. Useful for interpreting configuration files or domain-specific language inputs defining state transitions.",
      "description_length": 326,
      "index": 10,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fsml.Seqmodel",
      "library": "fsml",
      "description": "Represents a sequential finite state machine model with explicit states, inputs, outputs, and variables. It provides a structured way to define and manipulate state transitions, initial states, and signal declarations for hardware description languages like C and VHDL. This module is used to generate synthesizable sequential logic from high-level FSM specifications.",
      "description_length": 368,
      "index": 11,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fsml.Valuation",
      "library": "fsml",
      "description": "This module provides operations for managing variable-to-expression mappings as a key-value structure, supporting dictionary-style updates, lookups, and existence checks. It works with a map-like type that associates variable names with values, ensuring valuations are complete relative to a specified variable list through validation. Use cases include validating model configurations, serializing valuations to JSON for storage, and querying variable bindings in formal verification workflows.",
      "description_length": 495,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fsml.Misc",
      "library": "fsml",
      "description": "This module handles list transformations, string formatting, and basic file system checks. It provides functions for converting lists and options to strings, parsing token streams into lists, generating Cartesian products, and manipulating association lists. Use cases include formatting output for debugging, parsing structured input, and preparing data for file operations.",
      "description_length": 375,
      "index": 13,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fsml.Builtins",
      "library": "fsml",
      "description": "Contains predefined environments for type checking and evaluation. It provides `typing_env` for mapping variable names to type schemes and `eval_env` for mapping variable names to expression values. Used to set up initial contexts for type inference and runtime evaluation.",
      "description_length": 273,
      "index": 14,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fsml.Event",
      "library": "fsml",
      "description": "Handles simulation events represented as identifier-value pairs, providing functions to format and convert these events to strings. Exposes direct operations for pretty-printing and string representation of events. Useful for logging or debugging state changes in simulations where events need human-readable output.",
      "description_length": 316,
      "index": 15,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fsml.Tevents",
      "library": "fsml",
      "description": "Handles merging and transformation of timed event sequences, where each event is a timestamp paired with assignments. Provides `merge` to combine multiple event streams by clock cycles and `changes` to convert value changes into structured events. Useful for simulating synchronized state updates in hardware models or event-driven systems.",
      "description_length": 340,
      "index": 16,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fsml.State",
      "library": "fsml",
      "description": "This module defines operations for working with finite state machine (FSM) states represented as strings. It provides functions for pretty-printing, converting to strings, and serializing/deserializing states using Yojson. Concrete use cases include state representation in FSM definitions and JSON-based state persistence or communication.",
      "description_length": 340,
      "index": 17,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fsml.Expr",
      "library": "fsml",
      "description": "This module enables expression evaluation and manipulation in a typed language, supporting operations like constant checking, boolean and integer expression construction, and environment-based evaluation. It handles expressions, mutable values, and environments, with utilities for JSON serialization and string conversion, facilitating FSM state management, condition evaluation, and data persistence.",
      "description_length": 402,
      "index": 18,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fsml.Parse",
      "library": "fsml",
      "description": "This module directly constructs FSM components from string representations using Menhir parsers. It supports parsing individual guards, actions, transitions, and full FSMs, along with lists of guards, actions, and stimulus sequences. Use this module to convert textual FSM definitions into typed OCaml structures for simulation or analysis.",
      "description_length": 340,
      "index": 19,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fsml.Typing",
      "library": "fsml",
      "description": "This module performs type checking on finite state machines (FSMs), their guards, actions, and stimulus sequences. It ensures expressions and events conform to expected types, with options to enforce monomorphic types or include a clock variable. It operates on environments mapping variable names to type schemes, and integrates directly with FSMs, guards, actions, and event sequences during validation.",
      "description_length": 405,
      "index": 20,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fsml.Transition",
      "library": "fsml",
      "description": "This module defines transitions between states in a finite state machine, represented as tuples of source state, guards, actions, and target state. It provides functions to check if a transition can fire based on the current state and environment, and to serialize or display transitions. Use cases include simulating state machine behavior and debugging transitions by converting them to strings or JSON.",
      "description_length": 405,
      "index": 21,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fsml.Guard",
      "library": "fsml",
      "description": "This module represents transition guards as expressions and provides operations to evaluate them in a given environment, serialize them to JSON, and convert them to human-readable strings. It works directly with `Fsml.Expr.t` values, enforcing boolean evaluation semantics during simulation. Concrete use cases include checking conditionals for state transitions in a state machine and serializing guards for logging or debugging.",
      "description_length": 430,
      "index": 22,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fsml",
      "library": "fsml",
      "description": "This module provides operations for constructing, simulating, and transforming finite state machines through mechanisms like transition guards, event-driven execution, and clock-based timing. It works with states, transitions, expressions, timed event sequences, and variable environments to support use cases such as hardware synthesis, protocol verification, and generating implementation code (C/VHDL) or visualization outputs (DOT/VCD) from formal FSM models.",
      "description_length": 463,
      "index": 23,
      "embedding_norm": 0.9999999403953552
    }
  ],
  "filtering": {
    "total_modules_in_package": 25,
    "meaningful_modules": 24,
    "filtered_empty_modules": 1,
    "retention_rate": 0.96
  },
  "statistics": {
    "max_description_length": 508,
    "min_description_length": 273,
    "avg_description_length": 382.875,
    "embedding_file_size_mb": 0.3481616973876953
  }
}