{
  "package": "menhirSdk",
  "embedding_model": "Qwen/Qwen3-Embedding-8B",
  "embedding_dimension": 4096,
  "total_modules": 41,
  "creation_timestamp": "2025-08-15T14:30:50.235662",
  "modules": [
    {
      "module_path": "MenhirSdk.Cmly_read.FromString.Terminal",
      "library": "menhirSdk",
      "description": "This module provides operations to decode and manipulate terminal symbols from a `.cmly` file's grammar description. It supports data types representing terminals, including their names, kinds (like `REGULAR`, `EOF`), optional OCaml types, and attributes. Concrete use cases include analyzing terminal properties, mapping terminals to integers, and iterating or folding over terminal values for processing parser tables or generating code.",
      "description_length": 439,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MenhirSdk.Cmly_read.Read.Lr0",
      "library": "menhirSdk",
      "description": "This module provides operations to manipulate LR(0) states, including conversions to and from integers, hashing, equality checks, and iteration over all states. It supports data types representing LR(0) states (`t`) and works with symbols and grammar items. Concrete use cases include analyzing parser states, mapping state-specific data, and implementing custom traversal or transformation logic for each LR(0) state.",
      "description_length": 418,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MenhirSdk.Cmly_read.FromString.Nonterminal",
      "library": "menhirSdk",
      "description": "This module provides operations to work with nonterminal symbols in a grammar, including conversions between integers and nonterminal values, comparison, hashing, and iteration. It supports querying properties such as name, kind, type, position, nullability, first sets, and attributes for each nonterminal. Concrete use cases include analyzing grammar structure, generating code based on nonterminal properties, and debugging parsing logic.",
      "description_length": 441,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MenhirSdk.Cmly_read.FromString.Action",
      "library": "menhirSdk",
      "description": "This module provides functions to extract OCaml expressions and keyword lists from action values. It works with the `Action.t` type, which represents semantic actions in the grammar. Use it to analyze or transform grammar actions into executable code or keyword-based representations.",
      "description_length": 284,
      "index": 3,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "MenhirSdk.Cmly_read.Read.Lr1",
      "library": "menhirSdk",
      "description": "This module provides operations to manipulate LR(1) states, including state transitions, reduction retrieval, and mapping over states. It works with LR(1) state data structures, supporting conversions to LR(0) states and extracting transitions and reductions. Concrete use cases include analyzing parser states, inspecting possible transitions for a given state, and retrieving applicable reductions for terminals.",
      "description_length": 414,
      "index": 4,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "MenhirSdk.Cmly_read.Lift.Action",
      "library": "menhirSdk",
      "description": "This module provides functions to extract OCaml expressions and keyword lists from action values. It operates on the `Action.t` type, which represents semantic actions in the grammar. Concrete use cases include analyzing or transforming parser actions during grammar processing or code generation.",
      "description_length": 297,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MenhirSdk.Cmly_read.Read.Nonterminal",
      "library": "menhirSdk",
      "description": "This module provides operations to access and manipulate nonterminal symbols in a grammar, including their properties such as name, kind, type, and attributes. It supports iteration, folding, and tabulation over all nonterminals, and allows converting between integer and nonterminal representations. Concrete use cases include analyzing grammar structure, generating code based on nonterminal properties, and processing parsing tables.",
      "description_length": 436,
      "index": 6,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "MenhirSdk.Cmly_read.Lift.Range",
      "library": "menhirSdk",
      "description": "This module provides operations to access the start and end positions of a range in a parsed `.cmly` file. It works with the `Range.t` type, which represents a lexical range in the input file. Concrete use cases include extracting precise location information for grammar elements during analysis or error reporting.",
      "description_length": 316,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MenhirSdk.Cmly_read.FromString.Symbol",
      "library": "menhirSdk",
      "description": "This module defines operations for working with grammar symbols, which can be either terminals or nonterminals. It provides functions to retrieve symbol names, compute hashes, test for equality, and compare symbols. These operations are used when analyzing or transforming parsed grammars, such as during code generation or static analysis of language constructs.",
      "description_length": 363,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MenhirSdk.Cmly_read.Lift.Symbol",
      "library": "menhirSdk",
      "description": "This module represents grammar symbols as terminals or nonterminals and provides operations to query their names, compare them, and compute hash values. It works with the `Symbol.t` type, which distinguishes between terminal and nonterminal symbols of a grammar. Concrete use cases include symbol manipulation when processing parsed `.cmly` files, such as identifying symbol relationships or generating symbol-based analyses.",
      "description_length": 425,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MenhirSdk.Cmly_read.Lift.Grammar",
      "library": "menhirSdk",
      "description": "This module provides access to the high-level structure of a grammar, including entry points, attributes, and parameter declarations. It works with grammars read from `.cmly` files, exposing components like nonterminals, productions, and LR(1) states. Concrete use cases include analyzing or transforming grammars, extracting metadata, and generating code based on grammar definitions.",
      "description_length": 385,
      "index": 10,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "MenhirSdk.Cmly_read.FromString.Print",
      "library": "menhirSdk",
      "description": "This module provides functions to print detailed representations of grammar elements such as terminals, nonterminals, symbols, productions, and items. It supports pretty-printing these structures using OCaml's `Format.formatter`, enabling clear visualization of grammar components for debugging or analysis. Specific use cases include displaying individual grammar rules, item sets, and annotated items during parser development or inspection of generated automata.",
      "description_length": 465,
      "index": 11,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "MenhirSdk.Cmly_read.Lift.Nonterminal",
      "library": "menhirSdk",
      "description": "This module provides operations to analyze and manipulate nonterminal symbols in a grammar, including accessing their names, kinds, types, and associated attributes. It supports concrete use cases such as inspecting grammar structure, generating code based on nonterminal properties, and analyzing parsing behavior through nullable and first-set information. The module works directly with nonterminal values, offering both traversal and lookup functions.",
      "description_length": 455,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MenhirSdk.Cmly_read.Read.Print",
      "library": "menhirSdk",
      "description": "This module provides functions to print detailed representations of grammar elements such as terminals, nonterminals, symbols, productions, and items. It works with data types like `terminal`, `nonterminal`, `symbol`, `production`, and `item`, formatting them for human-readable output. Use cases include debugging parsers, inspecting grammar structures, and generating reports from parsed `.cmly` files.",
      "description_length": 404,
      "index": 13,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "MenhirSdk.Cmly_read.Lift.Production",
      "library": "menhirSdk",
      "description": "This module provides operations to inspect and manipulate grammar productions, including accessing their left-hand side, right-hand side symbols, attributes, and action code. It supports concrete use cases such as analyzing grammar rules for code generation, validating production structure, and extracting semantic actions from parsed `.cmly` files. The module works directly with production values, offering iteration, comparison, and lookup functions.",
      "description_length": 454,
      "index": 14,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MenhirSdk.Cmly_read.Read.Production",
      "library": "menhirSdk",
      "description": "This module provides operations to inspect individual grammar productions, including accessing their left-hand side, right-hand side symbols, action code, and attributes. It supports iteration, folding, and tabulation over all productions, and allows comparison, hashing, and conversion to and from integers. Concrete use cases include analyzing grammar rules for transformation, validation, or code generation based on their structure and attached attributes.",
      "description_length": 460,
      "index": 15,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MenhirSdk.Cmly_read.FromString.Grammar",
      "library": "menhirSdk",
      "description": "This module decodes a `.cmly` file from a string and provides access to the grammar's high-level structure, including entry points, attributes, and parameter declarations. It works with data types like `nonterminal`, `production`, `lr1`, and `Attribute.t`, extracted from the parsed grammar. Concrete use cases include analyzing grammar structure for tooling or extracting metadata like preludes, postludes, and entry point configurations.",
      "description_length": 439,
      "index": 16,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "MenhirSdk.Cmly_read.Lift.Lr1",
      "library": "menhirSdk",
      "description": "This module provides operations to manipulate and analyze LR(1) states, including transitions, reductions, and state properties. It works with LR(1) state data, supporting iteration, folding, and mapping over states. Concrete use cases include inspecting parser transitions, retrieving reduction actions for terminals, and converting LR(1) states to LR(0) representations.",
      "description_length": 372,
      "index": 17,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MenhirSdk.Cmly_read.Read.Grammar",
      "library": "menhirSdk",
      "description": "This module provides access to the high-level structure of a parsed `.cmly` file, including grammar components like entry points, attributes, and parameter declarations. It works with data types representing grammar elements such as nonterminals, productions, and LR1 states. Concrete use cases include analyzing or transforming grammar definitions, extracting metadata for code generation, and validating grammar attributes during parser development.",
      "description_length": 451,
      "index": 18,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MenhirSdk.Cmly_read.Read.Attribute",
      "library": "menhirSdk",
      "description": "This module provides operations to access the components of an attribute in a `.cmly` file, including retrieving its label, payload, and position. It works with the abstract type `Attribute.t`, representing attributes attached to grammar elements in the parsed grammar description. Concrete use cases include inspecting attribute metadata during grammar analysis or transformation tasks, such as extracting custom annotations or source location information for error reporting.",
      "description_length": 477,
      "index": 19,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "MenhirSdk.Cmly_read.Read.Range",
      "library": "menhirSdk",
      "description": "This module provides access to the start and end positions of a range within a `.cmly` file, using standard lexing positions. It works with the `Range.t` type, which represents a span in the input file. These positions are used to locate specific elements in the grammar description, such as tokens or rules, within the original input.",
      "description_length": 335,
      "index": 20,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MenhirSdk.Cmly_read.Read.Action",
      "library": "menhirSdk",
      "description": "This module provides functions to extract OCaml expressions and keyword lists from action values in a `.cmly` file. It works with the `Action.t` type, which represents semantic actions in the grammar. Concrete use cases include analyzing or transforming grammar rules based on their associated OCaml code and keywords.",
      "description_length": 318,
      "index": 21,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "MenhirSdk.Cmly_read.Read.Terminal",
      "library": "menhirSdk",
      "description": "This module provides operations to manipulate terminal symbols from a `.cmly` grammar file, including conversions to and from integers, comparison, hashing, and iteration. It supports data types such as `terminal` and includes functions to access properties like name, kind, OCaml type, and attributes of each terminal. Concrete use cases include analyzing or transforming parsed grammars, generating parsers, or inspecting terminal metadata during compiler or interpreter development.",
      "description_length": 485,
      "index": 22,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MenhirSdk.Cmly_read.Lift.Lr0",
      "library": "menhirSdk",
      "description": "This module provides operations to manipulate LR(0) states, including conversions to and from integers, equality and ordering comparisons, and iteration over all states. It works with the abstract type `t` representing LR(0) states, derived from the grammar's low-level description. Concrete use cases include analyzing parser states, implementing custom traversal algorithms, and mapping state-specific data during parser inspection or transformation tasks.",
      "description_length": 458,
      "index": 23,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "MenhirSdk.Cmly_read.Read.Symbol",
      "library": "menhirSdk",
      "description": "This module defines operations for working with grammar symbols, which can be either terminals or nonterminals. It provides functions to retrieve symbol names, compute hashes, test for equality, and compare symbols. These operations are used when analyzing or transforming parsed grammars, such as during compiler or interpreter implementation.",
      "description_length": 344,
      "index": 24,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MenhirSdk.Cmly_read.FromString.Range",
      "library": "menhirSdk",
      "description": "This module provides functions to access the start and end positions of a range within a `.cmly` file's content string. It works with the `Range.t` type, which represents a segment of the input string used during parsing. Concrete use cases include locating syntax errors or extracting specific grammar elements based on their position in the original file.",
      "description_length": 357,
      "index": 25,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MenhirSdk.Cmly_read.Lift.Print",
      "library": "menhirSdk",
      "description": "This module provides functions to print detailed representations of grammar elements like terminals, nonterminals, symbols, productions, and items. It works with data structures such as `terminal`, `nonterminal`, `symbol`, `production`, and `item list`, using a formatter to output human-readable or annotated textual representations. Concrete use cases include debugging parser internals, inspecting grammar structure, and generating readable output for analysis or logging.",
      "description_length": 475,
      "index": 26,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MenhirSdk.Cmly_read.FromString.Attribute",
      "library": "menhirSdk",
      "description": "This module provides operations to access attributes from a `.cmly` file's decoded grammar representation. It works with the `Attribute.t` type, offering functions to retrieve an attribute's label, check for a specific label, extract the payload, and obtain the source position. Concrete use cases include inspecting grammar annotations for tooling support or custom processing during parser generation.",
      "description_length": 403,
      "index": 27,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MenhirSdk.Cmly_read.Lift.Terminal",
      "library": "menhirSdk",
      "description": "This module provides operations to manipulate terminal symbols from a grammar, including conversions between integers and terminal values, equality and ordering checks, and iteration over all terminals. It supports data types like `terminal` and `int`, and is used to access terminal properties such as name, kind, OCaml type, and attributes. Concrete use cases include analyzing grammar terminals, mapping terminals to values, and extracting terminal metadata for code generation or inspection.",
      "description_length": 495,
      "index": 28,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MenhirSdk.Cmly_read.FromString.Lr1",
      "library": "menhirSdk",
      "description": "This module provides operations to work with LR(1) states, including state transitions, reductions, and mappings to LR(0) states. It supports data types such as `Lr1.t` for representing LR(1) states, along with symbols, terminals, and productions. Concrete use cases include analyzing parser states, inspecting transition tables, and retrieving reduction actions for specific terminals during parsing.",
      "description_length": 401,
      "index": 29,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MenhirSdk.Cmly_read.FromString.Production",
      "library": "menhirSdk",
      "description": "This module provides operations to inspect and manipulate grammar productions, including accessing their left-hand side, right-hand side, kind, action, and attributes. It supports iteration, folding, and tabulation over all productions, and offers comparison, hashing, and conversion to and from integers. Concrete use cases include analyzing grammar rules, processing semantic actions, and extracting metadata such as source code positions for tooling or debugging.",
      "description_length": 466,
      "index": 30,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "MenhirSdk.Cmly_read.FromString.Lr0",
      "library": "menhirSdk",
      "description": "This module provides operations to work with LR(0) states, including conversions to and from integers, hashing, equality checks, and iteration over all states. It supports data types such as `Lr0.t` for representing LR(0) states, and provides access to each state's incoming symbol and item list. Concrete use cases include analyzing parser states and implementing custom traversal or mapping logic over LR(0) automata.",
      "description_length": 419,
      "index": 31,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MenhirSdk.Cmly_read.Lift.Attribute",
      "library": "menhirSdk",
      "description": "This module provides operations to access the label, payload, and position of attributes in a grammar definition. It works with the `Attribute.t` type, which represents individual attributes attached to grammar elements. Concrete use cases include extracting metadata such as source locations or annotations from parsed `.cmly` files for analysis or tooling purposes.",
      "description_length": 367,
      "index": 32,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MenhirSdk.Cmly_read.Lift",
      "library": "menhirSdk",
      "description": "This module provides operations to convert low-level grammar representations into structured modules with functionality for analyzing and transforming LR(0) and LR(1) automaton states, as well as formatting grammar components. It works with grammar definitions parsed from `.cmly` files, exposing symbolic representations like terminals, nonterminals, and productions alongside metadata for tasks such as compiler development or grammar analysis. Specific capabilities include state inspection, production manipulation, and generating human-readable grammar descriptions while handling format inconsistencies through error reporting.",
      "description_length": 633,
      "index": 33,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MenhirSdk.Cmly_read.Read",
      "library": "menhirSdk",
      "description": "This component provides operations to parse and decode `.cmly` files into structured grammar representations, including terminals, nonterminals, symbols, and LR(0)/LR(1) parser states. It enables grammar analysis, code generation, and human-readable formatting through utilities for inspecting attributes, manipulating states, and transforming productions. Typical use cases include building compiler frontends, static analyzers, and pretty-printers for formal language processing.",
      "description_length": 481,
      "index": 34,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MenhirSdk.Cmly_format",
      "library": "menhirSdk",
      "description": "This module defines data structures and types for representing parsed Menhir grammar files, including terminals, nonterminals, productions, and LR states. It provides detailed definitions for grammar elements with attributes, positions, and semantic actions, supporting precise manipulation and analysis of parser specifications. Concrete use cases include building custom analysis tools, generating documentation, or transforming grammar definitions for code generation.",
      "description_length": 471,
      "index": 35,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "MenhirSdk.Version",
      "library": "menhirSdk",
      "description": "This module provides a single value `version` that holds the version string of the SDK. It works with string data to represent version information. A concrete use case is checking the SDK version at runtime for compatibility or logging purposes.",
      "description_length": 245,
      "index": 36,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MenhirSdk.Cmly_read",
      "library": "menhirSdk",
      "description": "This module reads and decodes `.cmly` files into structured grammar representations, including terminals, nonterminals, symbols, and LR(0)/LR(1) parser states. It supports grammar analysis, code generation, and pretty-printing through utilities for inspecting attributes, manipulating states, and transforming productions. Typical use cases include building compiler frontends, static analyzers, and grammar visualization tools.",
      "description_length": 428,
      "index": 37,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MenhirSdk.Cmly_api",
      "library": "menhirSdk",
      "description": "This module defines core abstractions for representing and manipulating LR grammars, including nonterminals, terminals, and production rules. It provides operations to build, traverse, and analyze grammars, such as querying symbol properties and rule dependencies. Concrete use cases include implementing custom grammar transformations, generating parsers, and performing static analysis on grammar definitions.",
      "description_length": 411,
      "index": 38,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MenhirSdk.Keyword",
      "library": "menhirSdk",
      "description": "This module defines types and functions for representing and manipulating keywords in a parser, specifically capturing their position, context, and naming. It includes a `keyword` type that combines subject, location, and flavor, along with a `posvar` function to generate string representations based on these parameters. The `KeywordSet` module provides set operations for managing collections of keywords.",
      "description_length": 408,
      "index": 39,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MenhirSdk",
      "library": "menhirSdk",
      "description": "This module provides precise representations and manipulations for LR grammars and associated parser components. It includes operations for reading and analyzing `.cmly` files, working with grammar elements like terminals and nonterminals, and handling keywords with positional and contextual data. Concrete use cases include building compiler frontends, generating parsers, and creating grammar visualization or documentation tools.",
      "description_length": 433,
      "index": 40,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 43,
    "meaningful_modules": 41,
    "filtered_empty_modules": 2,
    "retention_rate": 0.9534883720930233
  },
  "statistics": {
    "max_description_length": 633,
    "min_description_length": 245,
    "avg_description_length": 415.3170731707317,
    "embedding_file_size_mb": 0.5944747924804688
  }
}