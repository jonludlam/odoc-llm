{
  "package": "menhirSdk",
  "embedding_model": "Qwen/Qwen3-Embedding-0.6B",
  "embedding_dimension": 1024,
  "total_modules": 55,
  "creation_timestamp": "2025-07-15T23:15:21.584442",
  "modules": [
    {
      "module_path": "MenhirSdk.Cmly_read.FromString.Action",
      "library": "menhirSdk",
      "description": "This module decodes a .cmly file from a string and provides access to the grammar's action expressions and associated keywords. It works with the `Action.t` type to extract OCaml expressions and lists of keywords used in the grammar. Concrete use cases include analyzing or transforming semantic actions and inspecting keyword definitions directly from a parsed .cmly file.",
      "description_length": 373,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MenhirSdk.Cmly_read.Read.Attribute",
      "library": "menhirSdk",
      "description": "This module provides operations to access the components of an attribute, including its label, payload, and position. It works with the abstract type `t` representing attributes in a grammar definition. Concrete use cases include extracting metadata attached to grammar elements, such as semantic actions or source locations, for analysis or transformation tasks.",
      "description_length": 363,
      "index": 1,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "MenhirSdk.Cmly_read.FromString.Lr1",
      "library": "menhirSdk",
      "description": "This module provides operations to work with LR(1) states, including state traversal, reduction retrieval, and transitions. It defines state manipulation functions like `transitions`, `get_reductions`, and `default_reduction`, and supports iteration and folding over LR(1) states. It is used for analyzing and processing LR(1) automata derived from a .cmly file.",
      "description_length": 362,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MenhirSdk.Cmly_read.Lift.Attribute",
      "library": "menhirSdk",
      "description": "This module provides functions to access the components of an attribute value, including its label, payload, and position. It works with the abstract type `t` representing an attribute and the `Range.t` type for positional information. Concrete use cases include extracting metadata attached to grammar elements, such as annotations or source locations, during the analysis of parsed `.cmly` files.",
      "description_length": 398,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MenhirSdk.Cmly_read.Lift.Nonterminal",
      "library": "menhirSdk",
      "description": "This module represents nonterminal symbols in a grammar parsed from a .cmly file. It provides operations to convert between integers and nonterminal symbols, inspect properties like name, kind, and type, and analyze grammar behavior such as nullability and first sets. Use this module to process and traverse the structure of context-free grammars generated by Menhir.",
      "description_length": 368,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MenhirSdk.Cmly_read.Lift.Production",
      "library": "menhirSdk",
      "description": "This module provides operations to manipulate and inspect grammar productions, including accessing their left-hand side, right-hand side symbols, attributes, and action code. It supports concrete use cases such as analyzing production rules for parser generation, validating grammar structure, and extracting semantic actions associated with productions. The module works with production values, nonterminals, symbols, and related metadata like ranges and attributes.",
      "description_length": 467,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MenhirSdk.Cmly_read.Lift.Lr0",
      "library": "menhirSdk",
      "description": "This module provides operations for working with LR(0) states in a grammar, including state traversal, hashing, comparison, and mapping. It defines an enumerated type `t` representing LR(0) states, along with functions to convert between integers and states, iterate over states, and compute state properties such as incoming symbols and item sets. Concrete use cases include analyzing and transforming the automaton generated during parsing, such as in custom parser generators or grammar analysis tools.",
      "description_length": 505,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MenhirSdk.Cmly_read.FromString.Symbol",
      "library": "menhirSdk",
      "description": "This module defines operations for working with grammar symbols, which can be either terminals or nonterminals. It provides functions to retrieve symbol names, compute hashes, test for equality, and compare symbols, supporting precise manipulation and analysis of grammar elements. These operations are essential for tasks like generating parsers or analyzing grammar structure directly from decoded .cmly data.",
      "description_length": 411,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MenhirSdk.Cmly_read.FromString.Print",
      "library": "menhirSdk",
      "description": "This module provides functions to print detailed representations of grammar elements such as terminals, nonterminals, symbols, productions, and items. It works with data types like `terminal`, `nonterminal`, `symbol`, `production`, and `item`, formatting them for human-readable output. Use cases include debugging parsers, inspecting grammar structures, and generating reports from parsed `.cmly` files.",
      "description_length": 404,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MenhirSdk.Cmly_read.FromString.Range",
      "library": "menhirSdk",
      "description": "This module provides functions to access the start and end positions of a range within a .cmly file's decoded structure. It operates on the `t` type, representing a range, and works with `Stdlib.Lexing.position` to indicate specific locations in the input. Concrete use cases include tracking source code locations during grammar analysis or error reporting based on the parsed .cmly data.",
      "description_length": 389,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MenhirSdk.Cmly_read.Lift.Lr1",
      "library": "menhirSdk",
      "description": "This module provides operations to manipulate and analyze LR(1) states, including transitions, reductions, and state properties. It supports data types like `lr1`, `lr0`, `symbol`, `terminal`, and `production`, enabling direct access to parsing automaton details. Concrete use cases include inspecting state transitions, retrieving reduction actions for specific terminals, and converting LR(1) states to LR(0) representations.",
      "description_length": 427,
      "index": 10,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MenhirSdk.Cmly_read.Read.Lr1",
      "library": "menhirSdk",
      "description": "This module provides operations to manipulate and analyze LR(1) states, including state transitions, reductions, and mappings to LR(0) states. It works with LR(1) state data structures, offering iteration, folding, and tabulation over states, as well as access to their grammatical behavior such as transitions on symbols and associated reductions. Concrete use cases include building custom analysis passes over LR(1) automata, inspecting conflict resolution, and extracting per-state grammar rules for code generation or debugging tools.",
      "description_length": 539,
      "index": 11,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "MenhirSdk.Cmly_read.FromString.Terminal",
      "library": "menhirSdk",
      "description": "This module provides operations to decode and manipulate terminal symbols from a .cmly file's grammar description. It supports concrete terminals like `EOF`, `ERROR`, and regular tokens, each with associated metadata such as names, OCaml types, and attributes. Use cases include analyzing parser terminals, generating code based on terminal properties, and inspecting grammar structure during tooling development.",
      "description_length": 413,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MenhirSdk.Cmly_read.Read.Symbol",
      "library": "menhirSdk",
      "description": "This module defines operations for working with grammar symbols, which can be either terminals or nonterminals. It provides functions to retrieve symbol names, compute hashes, test for equality, and compare symbols, all handling both terminal and nonterminal cases. These operations are used when analyzing or transforming parsed grammars, such as during compiler front-end processing or grammar inspection tasks.",
      "description_length": 413,
      "index": 13,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "MenhirSdk.Cmly_read.FromString.Attribute",
      "library": "menhirSdk",
      "description": "This module provides operations to access attributes associated with grammar elements in a decoded .cmly file. It supports retrieving the label, payload, and position of an attribute, enabling precise analysis and transformation of grammar constructs based on their metadata. Use cases include inspecting semantic actions, tracking source locations of grammar rules, and validating attribute consistency during grammar processing.",
      "description_length": 430,
      "index": 14,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MenhirSdk.Cmly_read.Read.Nonterminal",
      "library": "menhirSdk",
      "description": "This module provides operations to access and manipulate nonterminal symbols in a grammar, including their properties such as name, kind, type, and attributes. It supports iteration, folding, and tabulation over all nonterminals, and allows converting between integer and nonterminal representations. Concrete use cases include analyzing grammar structure, generating code based on nonterminal properties, and processing parsing tables.",
      "description_length": 436,
      "index": 15,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MenhirSdk.Cmly_read.FromString.Grammar",
      "library": "menhirSdk",
      "description": "This module parses a .cmly file from a string and exposes high-level components like entry points, parameters, and attributes. It works with grammars defined in memory, returning structured data such as nonterminals, productions, and LR1 states. Use it to analyze or transform grammar definitions programmatically without reading from disk.",
      "description_length": 340,
      "index": 16,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MenhirSdk.Cmly_read.Read.Print",
      "library": "menhirSdk",
      "description": "This module provides functions to print detailed representations of grammar elements such as terminals, nonterminals, symbols, productions, and items. It works with data types like `terminal`, `nonterminal`, `symbol`, `production`, and `item`, formatting them for human-readable output. Use cases include debugging parsers, inspecting grammar structures, and generating reports from parsed `.cmly` files.",
      "description_length": 404,
      "index": 17,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MenhirSdk.Cmly_read.Read.Action",
      "library": "menhirSdk",
      "description": "This module processes the `Action.t` type, decoding semantic actions from `.cmly` files into OCaml expressions and extracting associated keywords. It provides direct access to the structure of grammar actions, enabling analysis or transformation of parser behavior. Use cases include generating documentation for semantic actions or inspecting keyword usage in grammar rules.",
      "description_length": 375,
      "index": 18,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "MenhirSdk.Cmly_read.FromString.Nonterminal",
      "library": "menhirSdk",
      "description": "This module provides operations to access and manipulate nonterminal symbols in a grammar, including their properties such as name, kind, type, and attributes. It supports iteration, folding, and tabulation over all nonterminals, and allows conversion between nonterminal values and integers. Concrete use cases include analyzing grammar structure, generating code based on nonterminal properties, and building custom tooling that processes or transforms grammars.",
      "description_length": 464,
      "index": 19,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MenhirSdk.Cmly_read.Read.Production",
      "library": "menhirSdk",
      "description": "This module provides operations to inspect individual grammar productions, including accessing their left-hand side nonterminal, right-hand side symbols, and associated attributes. It supports iteration, folding, and tabulation over all productions, and allows checking their kind (regular or start). Concrete use cases include analyzing grammar rules for code generation, validation, or transformation tasks.",
      "description_length": 409,
      "index": 20,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "MenhirSdk.Cmly_read.Read.Range",
      "library": "menhirSdk",
      "description": "This module represents a range in the source file, defined by start and end positions. It provides access to the start and end positions of the range through the `startp` and `endp` functions. It is used when analyzing or transforming grammars to track locations of symbols or productions in the original input.",
      "description_length": 311,
      "index": 21,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MenhirSdk.Cmly_read.Lift.Action",
      "library": "menhirSdk",
      "description": "This module provides functions to extract OCaml expressions and keyword lists from action values. It operates on the `Action.t` type, which represents semantic actions within a grammar specification. Concrete use cases include analyzing or transforming grammar rules by inspecting their associated OCaml code and identifying relevant keywords.",
      "description_length": 343,
      "index": 22,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MenhirSdk.Cmly_read.Read.Grammar",
      "library": "menhirSdk",
      "description": "This module provides access to the grammar's high-level structure, including entry points, parameters, and ludes. It works with lists of strings, nonterminals, productions, and LR(1) states. Concrete use cases include analyzing grammar entry points, extracting command-line parameters, and processing embedded code sections like preludes and postludes.",
      "description_length": 352,
      "index": 23,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MenhirSdk.Cmly_read.Lift.Range",
      "library": "menhirSdk",
      "description": "This module provides access to the start and end positions of ranges within a grammar definition, using standard OCaml lexing positions. It operates on the abstract type `t` representing a range, typically used to track source location information during parsing. Concrete use cases include mapping grammar elements to their original source locations for error reporting or tooling support.",
      "description_length": 390,
      "index": 24,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MenhirSdk.Cmly_read.Lift.Grammar",
      "library": "menhirSdk",
      "description": "This module provides access to the high-level structure of a grammar, including entry points with their associated nonterminals, productions, and LR(1) states, along with attributes, prelude, and postlude code snippets. It operates on data types like nonterminals, productions, and attributes, extracted from a decoded .cmly file. Concrete use cases include analyzing or transforming grammar definitions, generating parsers, or extracting metadata for tooling around parser generators.",
      "description_length": 485,
      "index": 25,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MenhirSdk.Cmly_read.Lift.Print",
      "library": "menhirSdk",
      "description": "This module provides functions to print detailed representations of grammar elements such as terminals, nonterminals, symbols, productions, and items. It supports formatted output using OCaml's `Format.formatter`, enabling precise control over how these elements are displayed. These functions are useful when inspecting or debugging the structure of a parsed grammar, especially when working with the lower-level `grammar` type.",
      "description_length": 429,
      "index": 26,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MenhirSdk.Cmly_read.FromString.Lr0",
      "library": "menhirSdk",
      "description": "This module provides operations to work with LR(0) states in a parsed grammar, including state traversal, indexing, and inspection of state properties such as incoming symbols and item sets. It defines an enumerated type `t` representing LR(0) states, along with functions to convert between integers and states, compare and hash states, and iterate or fold over all states. Concrete use cases include analyzing parser states during compilation or debugging, and building custom analysis tools that require inspecting the structure of LR(0) automata derived from a grammar.",
      "description_length": 573,
      "index": 27,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "MenhirSdk.Cmly_read.Lift.Symbol",
      "library": "menhirSdk",
      "description": "This module defines a polymorphic type `t` representing grammar symbols, either terminals or nonterminals, and provides operations to inspect and compare them. It includes functions to retrieve a symbol's name, compute its hash, test for equality, and compare symbols. These operations are used when processing grammar definitions from `.cmly` files, particularly during analysis or transformation tasks involving symbol identities and ordering.",
      "description_length": 445,
      "index": 28,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MenhirSdk.Cmly_read.Lift.Terminal",
      "library": "menhirSdk",
      "description": "This module provides operations to manipulate terminal symbols from a grammar, including conversions to and from integers, comparison, hashing, and iteration. It supports data types such as `terminal` and `ocamltype`, and includes functions to retrieve terminal properties like name, kind, type, and attributes. Concrete use cases include analyzing and processing grammar terminals during parser generation or inspection of parsed values.",
      "description_length": 438,
      "index": 29,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "MenhirSdk.Cmly_read.Read.Lr0",
      "library": "menhirSdk",
      "description": "This module provides operations to manipulate LR(0) states, including conversions to and from integers, hashing, equality checks, and iteration over all states. It supports data types representing LR(0) states (`t`) and works with symbols and grammar items. Concrete use cases include analyzing parser states, implementing state transitions, and inspecting grammar items associated with each LR(0) state.",
      "description_length": 404,
      "index": 30,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "MenhirSdk.Cmly_read.FromString.Production",
      "library": "menhirSdk",
      "description": "This module provides operations to inspect individual grammar productions, including accessing their left-hand side, right-hand side symbols, attributes, and action code. It supports iteration, folding, and tabulation over all productions, and allows checking whether a production is regular or a start production. Use cases include analyzing or transforming the grammar structure, extracting semantic actions, or generating code based on production rules.",
      "description_length": 456,
      "index": 31,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MenhirSdk.Cmly_read.Read.Terminal",
      "library": "menhirSdk",
      "description": "This module provides operations to manipulate terminal symbols of a grammar, including conversions to and from integers, comparison, hashing, and iteration. It supports data types such as `terminal` and `ocamltype`, and includes functions to inspect terminal properties like name, kind, and associated type. Concrete use cases include analyzing and processing grammar terminals during parser generation or transformation tasks.",
      "description_length": 427,
      "index": 32,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "MenhirSdk.Cmly_api.GRAMMAR-Print",
      "library": "menhirSdk",
      "description": "This module provides functions to print grammar elements such as terminals, nonterminals, symbols, productions, and items using OCaml's Format module. It supports pretty-printing of both raw and annotated item sets, commonly used for debugging or visualizing parser states and grammar structures. These operations facilitate inspecting the internal representation of grammars during parser development and analysis.",
      "description_length": 415,
      "index": 33,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MenhirSdk.Cmly_api.GRAMMAR-Symbol",
      "library": "menhirSdk",
      "description": "This module represents grammar symbols, distinguishing between terminals and nonterminals. It provides operations to retrieve symbol names, compare, hash, and check equality of symbols. Concrete use cases include symbol manipulation and analysis in parser generation and compiler design.",
      "description_length": 287,
      "index": 34,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MenhirSdk.Cmly_api.GRAMMAR-Action",
      "library": "menhirSdk",
      "description": "This module represents semantic actions in a grammar specification, providing access to their OCaml expression and associated keywords. It works with `Action.t` values, which encapsulate action logic and metadata. Concrete use cases include extracting code expressions for compilation and retrieving keywords for syntax analysis.",
      "description_length": 329,
      "index": 35,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "MenhirSdk.Cmly_api.GRAMMAR-Production",
      "library": "menhirSdk",
      "description": "This module represents and manipulates grammar productions in a parser specification. It provides operations to access production properties such as the left-hand side nonterminal, the right-hand side symbols, and associated attributes and actions. Concrete use cases include analyzing or transforming grammar rules during parser generation or inspection.",
      "description_length": 355,
      "index": 36,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "MenhirSdk.Cmly_api.GRAMMAR-Lr0",
      "library": "menhirSdk",
      "description": "This module represents and manipulates LR(0) states in a parser generator. It provides operations to convert between states and integers, compare and hash states, and iterate or fold over all states. Additionally, it supports retrieving incoming symbols and item sets associated with each state, which are essential for constructing and analyzing parsing tables.",
      "description_length": 362,
      "index": 37,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "MenhirSdk.Cmly_api.GRAMMAR-Lr1",
      "library": "menhirSdk",
      "description": "This module represents and manipulates LR(1) states in a parser generated by Menhir. It provides operations to convert between integers and LR(1) states, iterate over all states, and query state properties such as transitions, reductions, and default actions. Use cases include analyzing parser states, debugging grammars, and extracting detailed control flow information for code generation or static analysis.",
      "description_length": 411,
      "index": 38,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "MenhirSdk.Cmly_api.INDEXED",
      "library": "menhirSdk",
      "description": "This module defines a type `t` with a fixed set of values indexed by integers from `0` to `count - 1`. It provides conversions to and from integers, equality, comparison, hashing, and iteration over all values. It is used to represent and manipulate finite, ordered sets of elements with efficient indexing and traversal.",
      "description_length": 321,
      "index": 39,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "MenhirSdk.Cmly_api.GRAMMAR-Attribute",
      "library": "menhirSdk",
      "description": "This module handles attributes in a grammar definition, providing access to their label, payload, and position. It works with the `Attribute.t` type, which represents individual attributes, and `Range.t`, which describes their location in the source. Use it to inspect or process custom annotations attached to grammar elements, such as extracting metadata or validating attribute usage during parsing.",
      "description_length": 402,
      "index": 40,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MenhirSdk.Cmly_api.GRAMMAR-Terminal",
      "library": "menhirSdk",
      "description": "This module represents and manipulates terminal symbols in a grammar. It provides operations to convert between terminals and integers, compare and hash terminals, iterate and fold over all terminals, and retrieve properties such as name, kind, associated OCaml type, and attributes. It is used to analyze and process grammar terminals in parser generators or compiler components.",
      "description_length": 380,
      "index": 41,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "MenhirSdk.Cmly_api.GRAMMAR-Nonterminal",
      "library": "menhirSdk",
      "description": "This module represents nonterminal symbols in a grammar, providing operations to convert between integers and nonterminals, compare and hash nonterminals, and iterate or fold over all nonterminals. It supports data types such as integers, strings, and lists of terminals and ranges, enabling analysis of grammar properties like nullability, first sets, and symbol kinds. Concrete use cases include implementing parser generators, analyzing grammar structure, and handling symbol attributes and positions during compilation.",
      "description_length": 523,
      "index": 42,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "MenhirSdk.Cmly_api.GRAMMAR-Grammar",
      "library": "menhirSdk",
      "description": "This module represents a parsed grammar specification, providing access to core components like entry points, attributes, and code blocks. It works with grammars defined in `.mly` files, exposing their structure for analysis or transformation. Concrete use cases include extracting grammar metadata, modifying entry points, or processing embedded code sections.",
      "description_length": 361,
      "index": 43,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MenhirSdk.Cmly_read.Lift",
      "library": "menhirSdk",
      "description": "This module transforms low-level grammar data into a structured interface for parsing and analysis, exposing typed representations of symbols, productions, and automata. It provides core operations to inspect and manipulate grammar components such as terminals, nonterminals, and productions, while submodules handle advanced tasks like LR(0)/LR(1) state analysis, source range tracking, and semantic action extraction. You can use it to build custom parsers, validate grammar rules, or analyze parsing automata by working directly with rich types like nonterminal symbols, productions, and LR states. Submodules enable specific workflows such as mapping grammar elements to source locations, printing detailed grammar structures, or extracting OCaml code from semantic actions.",
      "description_length": 778,
      "index": 44,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MenhirSdk.Cmly_read.FromString",
      "library": "menhirSdk",
      "description": "This component decodes in-memory string representations of `.cmly` files into structured grammar models, exposing high-level abstractions like terminals, nonterminals, and LR(1) automata. It processes grammar definitions dynamically, enabling runtime grammar loading, validation, and transformation through data structures such as symbols, productions, and attributes. Submodules support inspecting semantic actions, traversing LR states, printing grammar elements, and manipulating terminals and nonterminals with precise metadata. For example, you can extract OCaml expressions from grammar actions, analyze LR(1) state transitions, or generate human-readable representations of productions and symbols directly from decoded data.",
      "description_length": 732,
      "index": 45,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MenhirSdk.Cmly_api.GRAMMAR-Range",
      "library": "menhirSdk",
      "description": "This module represents a range within a grammar, defined by start and end positions. It provides access to the start and end positions of the range using `startp` and `endp` functions. Useful for tracking source code locations in parser-generated data structures.",
      "description_length": 263,
      "index": 46,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MenhirSdk.Cmly_read.Read",
      "library": "menhirSdk",
      "description": "This component reads and decodes `.cmly` files into structured grammar representations, exposing terminals, nonterminals, productions, and attributes through a high-level interface. It supports analysis of LR(0) and LR(1) automata, enabling tasks like parser development, grammar validation, and tooling that requires programmatic access to grammar definitions and automaton states. The interface allows inspecting semantic actions, source ranges, and grammar metadata, while submodules provide detailed access to symbols, states, and productions. Examples include extracting semantic actions for documentation, analyzing LR(1) states for conflict resolution, and generating code based on nonterminal properties.",
      "description_length": 712,
      "index": 47,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MenhirSdk.Keyword.KeywordSet",
      "library": "menhirSdk",
      "description": "This module offers ordered set operations for managing collections of keyword values, supporting transformations like union, intersection, and difference alongside ordered iteration (ascending/descending), filtering, and sequence-based construction. It works with sets of `MenhirSdk.Keyword.keyword` elements, maintaining strict ordering during iteration and providing safe accessors (e.g., `find_first_opt`) and conversion to/from lists/sequences. It is particularly useful for scenarios requiring ordered keyword processing, such as parser generation workflows where keyword sets must be analyzed, partitioned, or serialized in a deterministic sequence.",
      "description_length": 655,
      "index": 48,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MenhirSdk.Cmly_read",
      "library": "menhirSdk",
      "description": "This module reads and decodes `.cmly` files into structured grammar representations, exposing low-level grammar data and supporting analysis of LR(0) and LR(1) automata. It provides core operations to inspect and manipulate grammar components such as terminals, nonterminals, and productions, with functions like `read_channel` for parsing from input channels. Submodules enable string-based parsing, grammar transformation, semantic action extraction, and detailed analysis of LR states and source ranges. You can use it to build custom parsers, validate grammar rules, extract OCaml code from actions, or generate human-readable grammar representations.",
      "description_length": 655,
      "index": 49,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MenhirSdk.Cmly_format",
      "library": "menhirSdk",
      "description": "This module defines data structures and types for representing parsed Menhir grammar files, including terminals, nonterminals, productions, and LR states. It provides precise definitions for grammar elements with support for attributes, positions, and OCaml-specific constructs like types and expressions. It is used to analyze and manipulate grammar representations during compilation or tooling tasks such as pretty-printing, transformation, or error reporting.",
      "description_length": 463,
      "index": 50,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MenhirSdk.Cmly_api",
      "library": "menhirSdk",
      "description": "This module provides core abstractions for working with context-free grammars, including nonterminals, terminals, and production rules, enabling precise analysis and transformation of grammar structures. It supports typed indexing and traversal of grammar elements, with operations for building custom analyzers, generating parsers, and performing static analysis. Submodules handle symbol manipulation, semantic actions, LR states, and grammar attributes, allowing tasks like pretty-printing, source location tracking, and extracting code expressions. Specific capabilities include converting between symbols and integers, inspecting item sets for parser states, and processing annotated grammar ranges for source-level analysis.",
      "description_length": 730,
      "index": 51,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MenhirSdk.Version",
      "library": "menhirSdk",
      "description": "This module provides a single value `version` representing the version string of the SDK. It works with string data to expose the current version. A concrete use case is checking the SDK version at runtime for compatibility or logging purposes.",
      "description_length": 244,
      "index": 52,
      "embedding_norm": 1.0
    },
    {
      "module_path": "MenhirSdk.Keyword",
      "library": "menhirSdk",
      "description": "This module represents and manipulates keywords in a parser, capturing their subject, location, and flavor within the `keyword` type. It provides the `posvar` function to generate string representations based on keyword attributes, enabling precise keyword identification and transformation. The `KeywordSet` submodule extends this functionality with ordered set operations, supporting union, intersection, difference, and ordered iteration over collections of keywords. These features facilitate tasks like deterministic keyword serialization, set analysis, and parser generation workflows requiring structured keyword handling.",
      "description_length": 629,
      "index": 53,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "MenhirSdk",
      "library": "menhirSdk",
      "description": "This module processes and analyzes context-free grammars, providing structured representations of terminals, nonterminals, and productions with support for LR automata and semantic actions. It enables reading `.cmly` files, inspecting grammar components, and performing transformations or static analysis on parsed grammars. You can extract OCaml code from actions, generate human-readable output, track source locations, or analyze LR states for parser validation. Additional utilities include version checking, keyword manipulation, and set operations for structured parser workflows.",
      "description_length": 586,
      "index": 54,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 56,
    "meaningful_modules": 55,
    "filtered_empty_modules": 1,
    "retention_rate": 0.9821428571428571
  },
  "statistics": {
    "max_description_length": 778,
    "min_description_length": 244,
    "avg_description_length": 442.4727272727273,
    "embedding_file_size_mb": 0.20020294189453125
  }
}