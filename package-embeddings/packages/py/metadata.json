{
  "package": "py",
  "embedding_model": "Qwen/Qwen3-Embedding-8B",
  "embedding_dimension": 4096,
  "total_modules": 22,
  "creation_timestamp": "2025-08-15T12:09:48.361422",
  "modules": [
    {
      "module_path": "Py.PyCell",
      "library": "py",
      "description": "This module implements Python cell object manipulation, supporting operations to create, retrieve, and update contained Python objects. It works directly with Python object types (`pyobject`) to manage encapsulated values, primarily used in closures and variable capture. Concrete use cases include handling free variables in function closures and managing mutable upvalues in Python-to-OCaml bindings.",
      "description_length": 402,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Py.PyType",
      "library": "py",
      "description": "This module defines a polymorphic type `t` representing Python object types and provides functions to inspect and classify Python objects. It includes predicates to check if an object is a subclass of specific Python types like `Long`, `List`, `Dict`, and others, along with utilities to retrieve type names and convert objects to their underlying representations. Concrete use cases include type validation and dynamic dispatch based on Python object types in OCaml code interfacing with Python.",
      "description_length": 496,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Py.PyBytes",
      "library": "py",
      "description": "Handles conversion and manipulation of Python byte objects from OCaml. Provides functions to create, access, and modify byte sequences, working directly with `Stdlib.Bytes.t` and Python object representations. Useful for interfacing OCaml code with Python APIs that require or return byte strings, such as file I/O or network data processing.",
      "description_length": 342,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Py.PyUnicode",
      "library": "py",
      "description": "Handles Unicode string operations between OCaml and Python. Provides functions to create, manipulate, and convert Python Unicode strings, including concatenation, slicing, and encoding/decoding. Useful for embedding Python string logic within OCaml applications or interfacing with Python APIs that require Unicode input.",
      "description_length": 321,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Py.CamlModule",
      "library": "py",
      "description": "This module creates and populates Python modules from OCaml, allowing OCaml values and functions to be exposed as module attributes. It supports adding integers, strings, arbitrary Python objects, and OCaml functions as callable Python functions within the module. Use cases include embedding OCaml logic into Python modules, exposing OCaml-implemented functions to Python code, and building hybrid Python-OCaml libraries.",
      "description_length": 422,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Py.PyWeakref",
      "library": "py",
      "description": "This module creates weak references and proxies to Python objects, allowing access without increasing reference counts. It supports operations to retrieve the referenced object and associate cleanup callbacks. Use it to manage temporary object relationships, like caching or event listeners, without preventing garbage collection.",
      "description_length": 330,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Py.PyIter",
      "library": "py",
      "description": "Handles iteration over Python objects from OCaml, providing direct access to Python iterators. It supports retrieving the next item from an iterator and mapping a function over all items, returning results as an OCaml list. Useful for processing Python iterable objects like lists, generators, or file lines directly in OCaml code.",
      "description_length": 331,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Py.PyNumber",
      "library": "py",
      "description": "This module enables creating and manipulating Python numeric objects (`float`, `int`, `int64`) and performing arithmetic, bitwise, and in-place operations (e.g., addition, modulus, shifts) directly on `pyobject` values. It mirrors Python's numeric protocols to support seamless numeric computations between OCaml and Python, handling both scalar operations and mutations. Use cases include bridging numerical computations in OCaml with Python's native types, such as in scientific computing or embedded scripting scenarios.",
      "description_length": 523,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Py.PyThreadState",
      "library": "py",
      "description": "Manages Python thread state in OCaml by saving, restoring, and swapping execution contexts. It handles operations on thread-specific data, such as retrieving and clearing state, and accessing the thread's dictionary. Useful when embedding Python in OCaml applications to ensure correct thread behavior during callbacks or multi-threaded execution.",
      "description_length": 347,
      "index": 8,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Py.PyList",
      "library": "py",
      "description": "This module implements dynamic list operations for Python objects in OCaml, supporting creation, insertion, appending, slicing, sorting, and in-place reversal. It directly manipulates `pyobject` instances that represent Python lists. Use this module when translating or interacting with Python list logic, such as building lists from OCaml values, modifying them with index-based operations, or converting them to tuples.",
      "description_length": 421,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Py.PyDict",
      "library": "py",
      "description": "This module provides operations to create and manipulate Python dictionaries from OCaml, including inserting, retrieving, and iterating over key-value pairs. It supports concrete data types like Python objects (`pyobject`) for keys and values, enabling direct interaction with Python dictionary structures. Use cases include converting OCaml key-value lists into Python dictionaries, extracting keys or values for inspection, and merging dictionaries during interoperation with Python code.",
      "description_length": 490,
      "index": 10,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Py.Object",
      "library": "py",
      "description": "This interface provides operations for interacting with Python objects through reference counting, attribute/item access, and type conversions to OCaml primitives. It handles generic Python objects represented as `t` values, supports sequence manipulation, method invocation, and comparison operations, while also enabling low-level integration with C pointers via Python capsules. Typical applications include embedding Python logic in OCaml programs, bridging data between Python and OCaml, and exposing C libraries to Python through capsule-based wrappers.",
      "description_length": 559,
      "index": 11,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Py.PyWrap",
      "library": "py",
      "description": "This module defines type wrappers for OCaml values that can be converted to or from Python, enabling type-safe interactions with Python objects. It includes functions to wrap basic types like integers, booleans, and strings, as well as compound types like lists, dictionaries, and tuples. These wrappers support defining and calling Python functions from OCaml and exposing OCaml functions to Python, handling argument and return value conversions.",
      "description_length": 448,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Py.PyByteArray",
      "library": "py",
      "description": "This module provides functions to create and manipulate Python byte arrays from OCaml. It supports operations like creating a byte array from a list of characters, getting and setting individual bytes by index, and retrieving the length or string representation of the array. Concrete use cases include handling binary data in Python from OCaml, such as reading raw network packets or processing binary file content.",
      "description_length": 416,
      "index": 13,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Py.PyBuffer",
      "library": "py",
      "description": "Handles binary data exchange between OCaml and Python by providing direct access to Python buffer objects. It allows reading from and writing to buffer contents, querying dimensions and layout through operations like `get`, `set`, `length`, `shape`, and `strides`. Useful for processing NumPy arrays or Python bytes objects directly in OCaml without copying data.",
      "description_length": 363,
      "index": 14,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Py.Numpy",
      "library": "py",
      "description": "This module provides direct interoperability between OCaml and Python's NumPy arrays. It allows conversion to and from NumPy arrays and OCaml Bigarrays, enabling efficient numerical data processing in OCaml while leveraging Python libraries. Use cases include scientific computing workflows where NumPy data must be manipulated in OCaml for performance-critical sections.",
      "description_length": 371,
      "index": 15,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Py.PySet",
      "library": "py",
      "description": "Implements operations for working with Python set objects from OCaml. Provides functions to create sets, add and remove elements, check membership, and perform set operations like union and intersection. Works directly with Python objects, enabling manipulation of Python sets while maintaining type safety. Useful for interoperability scenarios where set data needs to be shared or modified between Python and OCaml code.",
      "description_length": 422,
      "index": 16,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Py.PySlice",
      "library": "py",
      "description": "Handles Python slice objects in OCaml, providing operations to create and manipulate slices using start, stop, and step parameters. Works with Python objects representing integers and slices. Useful for implementing Python-style slicing in OCaml code that interfaces with Python sequences.",
      "description_length": 289,
      "index": 17,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Py.PyModule",
      "library": "py",
      "description": "This module defines functions to interact with Python objects from OCaml. It supports operations like importing Python modules, adding values (integers, strings, objects) to Python objects, retrieving attributes, and reloading modules. Use cases include embedding Python logic within OCaml programs, such as scripting or extending OCaml applications with Python libraries.",
      "description_length": 372,
      "index": 18,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Py.C",
      "library": "py",
      "description": "This module provides direct access to Python's C libraries through operations like `from` and `open_lib`, enabling low-level interaction with shared libraries. It works with string paths and `Dl.library` handles to manage dynamic loading of Python extensions. Concrete use cases include embedding Python interpreters, extending Python with OCaml code, and directly calling Python C API functions.",
      "description_length": 396,
      "index": 19,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Py.PyTuple",
      "library": "py",
      "description": "This module provides operations to create and manipulate Python tuples from OCaml. It works with arrays of Python objects and produces Python tuple objects. Use it to construct fixed-size, immutable sequences for interfacing with Python APIs expecting tuple arguments.",
      "description_length": 268,
      "index": 20,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Py",
      "library": "py",
      "description": "This interface enables low-level manipulation of Python objects via reference counting, attribute access, and sequence operations, alongside interpreter lifecycle management and bidirectional value conversion. It centers on the `pyobject` type and structured representations like `Py.t`, with dedicated components for handling Python-specific data (dictionaries, lists, Unicode strings, NumPy arrays) and buffer protocols. Key use cases include embedding Python in OCaml applications, bridging functions between languages, and implementing type-safe Python extensions with serialization and module interoperability.",
      "description_length": 615,
      "index": 21,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 23,
    "meaningful_modules": 22,
    "filtered_empty_modules": 1,
    "retention_rate": 0.9565217391304348
  },
  "statistics": {
    "max_description_length": 615,
    "min_description_length": 268,
    "avg_description_length": 406.54545454545456,
    "embedding_file_size_mb": 0.3192424774169922
  }
}