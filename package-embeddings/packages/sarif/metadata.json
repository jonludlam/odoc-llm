{
  "package": "sarif",
  "embedding_model": "Qwen/Qwen3-Embedding-0.6B",
  "embedding_dimension": 1024,
  "total_modules": 5,
  "creation_timestamp": "2025-07-15T23:06:08.723737",
  "modules": [
    {
      "module_path": "Sarif.Sarif_v_2_1_0_j",
      "library": "sarif",
      "description": "This module provides serialization, JSON deserialization, and structural equality operations for SARIF v2.1.0 schema components, focusing on static analysis metadata. It operates on structured types like logical/physical locations, graph traversals, artifact content models, tool configuration descriptors, and result provenance data, including specialized representations for control flow graphs, multilingual messages, and version-controlled artifacts. These capabilities enable static analysis tools to generate, validate, and exchange rich diagnostic reports while supporting programmatic manipulation of analysis results through consistent OCaml type utilities and SARIF-compliant JSON I/O.",
      "description_length": 695,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sarif.Sarif_v_2_1_0_util",
      "library": "sarif",
      "description": "This module provides validation functions for scalar values (e.g., URI strings, ranks), lists (e.g., minimum size, unique elements), and complex records (e.g., `artifact`, `result`) in SARIF v2.1.0, enforcing constraints like ISO 8601 timestamps, MIME types, GUID formats, integer bounds, and nested structure validity. These utilities ensure schema compliance for static analysis tools by validating SARIF data models such as reporting descriptors, invocations, and version control metadata during result generation or processing, while handling optional fields, regular expression patterns, and cross-referenced identifiers.",
      "description_length": 626,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sarif.Sarif_v_2_1_0_v",
      "library": "sarif",
      "description": "This module provides serialization, structural comparison, and validation operations for SARIF v2.1.0 data structures, including artifact metadata, code locations, diagnostic messages, and control flow graphs. It defines types for static analysis artifacts like `physical_location`, `result`, `graph_traversal`, and `fix`, along with utilities for constructing and validating SARIF-compliant records with optional fields and schema constraints. These capabilities enable static analysis tools to generate, process, and exchange rich diagnostic data while ensuring conformance to the SARIF standard for interoperability.",
      "description_length": 619,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sarif.Sarif_v_2_1_0_t",
      "library": "sarif",
      "description": "This module provides comprehensive facilities for modeling and manipulating SARIF v2.1.0 data structures, focusing on static analysis result representation, serialization, and metadata management. It works with rich types for artifacts, logical/physical locations, graph traversals, suppression records, tool components, code execution flows, and run metadata, including specialized constructs for version control, localization, and hierarchical relationships. These capabilities enable use cases such as structured logging of analysis diagnostics, precise reporting of code issues with contextual provenance, and interoperable exchange of static analysis results between tools.",
      "description_length": 678,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sarif",
      "library": "sarif",
      "description": "This module suite enables the creation, validation, and exchange of SARIF v2.1.0-compliant static analysis data through rich OCaml types and JSON serialization. It supports structured data such as `physical_location`, `result`, `graph_traversal`, and `artifact`, with operations for constructing, validating, and comparing these types according to the SARIF schema. Functionalities include checking scalar and composite values, handling optional and nested fields, and ensuring compliance with constraints like URI formats and ISO timestamps. Examples include serializing analysis results with precise code locations, validating tool output against schema rules, and exchanging diagnostic data across tools using standardized JSON.",
      "description_length": 731,
      "index": 4,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 5,
    "meaningful_modules": 5,
    "filtered_empty_modules": 0,
    "retention_rate": 1.0
  },
  "statistics": {
    "max_description_length": 731,
    "min_description_length": 619,
    "avg_description_length": 669.8,
    "embedding_file_size_mb": 0.018587112426757812
  }
}