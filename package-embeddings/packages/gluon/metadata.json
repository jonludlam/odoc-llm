{
  "package": "gluon",
  "embedding_model": "Qwen/Qwen3-Embedding-8B",
  "embedding_dimension": 4096,
  "total_modules": 17,
  "creation_timestamp": "2025-08-14T23:29:45.439676",
  "modules": [
    {
      "module_path": "Gluon.Sys.Event",
      "library": "gluon",
      "description": "Handles asynchronous events and callbacks. Works with event values of type `t` that represent specific occurrences or signals. Useful for implementing event-driven logic like user interface interactions or background task notifications.",
      "description_length": 236,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Gluon.Sys.Selector",
      "library": "gluon",
      "description": "This module manages I/O event monitoring using a selector, allowing registration, re-registration, and deregistration of file descriptors with specific interests. It provides operations to create a selector, register events with file descriptors, and wait for events with optional timeout and limit parameters. Concrete use cases include handling asynchronous I/O in network servers and implementing event-driven communication with file descriptors.",
      "description_length": 449,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Gluon.Net.Tcp_stream",
      "library": "gluon",
      "description": "This module implements TCP stream socket operations for asynchronous I/O, including connecting to addresses, reading and writing data with optional vectorized I/O, sending files directly from file descriptors, and converting streams to sources. It works directly with TCP stream sockets, byte buffers, and file descriptors, supporting non-blocking operations with result types that indicate progress or completion. Concrete use cases include implementing network protocols like HTTP or custom binary services that require reliable, ordered byte stream transmission over TCP.",
      "description_length": 574,
      "index": 2,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Gluon.Net.Tcp_listener",
      "library": "gluon",
      "description": "This module implements TCP server socket operations including binding to addresses, accepting incoming connections, and closing listeners. It works with TCP listener sockets, stream sockets, and network addresses. Concrete use cases include setting up HTTP servers, handling client connections, and managing network services.",
      "description_length": 325,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Gluon.Net.Socket",
      "library": "gluon",
      "description": "This module provides functions for managing network sockets, including closing and pretty-printing socket states. It works with two distinct socket types: `listen_socket` for handling incoming connections and `stream_socket` for bidirectional communication. Concrete use cases include implementing network servers that accept client connections and applications that maintain persistent network streams.",
      "description_length": 403,
      "index": 4,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Gluon.Net.Addr",
      "library": "gluon",
      "description": "This module handles network address manipulation for TCP and stream sockets, providing functions to convert between various address representations, including parsing from strings and URIs, extracting port and IP information, and converting to and from Unix socket addresses. It works with concrete data types such as `stream_addr` for network addresses and `tcp_addr` for IP versions, supporting operations like address resolution, formatting, and domain conversion. Use cases include setting up network connections, handling socket communication, and parsing network endpoints in server or client applications.",
      "description_length": 612,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Gluon.Token",
      "library": "gluon",
      "description": "This module implements a token system with opaque values that support hashing, equality checks, and pretty-printing. It allows creating tokens from arbitrary values and comparing them either by identity or a custom equality function. Tokens are useful for representing unique identifiers or abstract values in parsing and compilation tasks.",
      "description_length": 340,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Gluon.Event",
      "library": "gluon",
      "description": "This module represents and manipulates I/O events associated with tokens, providing functions to check event states such as readability, writability, and closure conditions. It works with an abstract event type `t` and a token type `Token.t`, allowing the creation of events from a state value using a module implementing the `Intf` signature. Concrete use cases include monitoring file descriptors for readiness in event loops and managing asynchronous I/O operations tied to specific tokens.",
      "description_length": 493,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Gluon.Poll",
      "library": "gluon",
      "description": "This module manages I/O event polling with operations to register, deregister, and reregister sources of events, and to wait for events on those sources. It works with sources such as file descriptors or sockets, tracking them with tokens and interest types to determine the kind of events to monitor. Concrete use cases include handling asynchronous network I/O, implementing event loops for servers, and managing multiple I/O channels efficiently.",
      "description_length": 449,
      "index": 8,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Gluon.Fd",
      "library": "gluon",
      "description": "This module wraps Unix file descriptors with operations to close, compare, and convert them to integers, along with functions to format and seek within files. It works directly with Unix.file_descr values, providing precise control over low-level file operations. Concrete use cases include managing open files in system-level applications, implementing custom file abstractions, and handling input/output redirection.",
      "description_length": 418,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Gluon.File",
      "library": "gluon",
      "description": "This module provides low-level file descriptor operations for reading, writing, and formatting, working directly with `Unix.file_descr` values. It supports standard I/O operations like `read`, `write`, `close`, and vectored I/O through `read_vectored` and `write_vectored`, with optional position and length parameters. Concrete use cases include direct file access, binary data manipulation, and integration with system-level I/O through typed byte buffers and iovecs.",
      "description_length": 469,
      "index": 10,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Gluon.Net",
      "library": "gluon",
      "description": "This module provides network communication capabilities through four submodules. Addr handles address parsing and conversion for TCP and stream sockets, working with types like `stream_addr` and `tcp_addr` for tasks such as endpoint parsing and domain resolution. Tcp_stream and Tcp_listener implement TCP client and server functionality, enabling asynchronous I/O, connection handling, and stream-based communication for services like HTTP or custom binary protocols.",
      "description_length": 468,
      "index": 11,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Gluon.Interest",
      "library": "gluon",
      "description": "This module defines a data type `t` representing interest flags for I/O operations, supporting bitwise combination and inspection. It provides functions to check if a flag includes readable or writable interest, and to add or remove interest flags. Concrete use cases include managing event subscriptions in asynchronous I/O systems, such as tracking when a socket is ready for reading or writing.",
      "description_length": 397,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Gluon.Source",
      "library": "gluon",
      "description": "This module manages event sources for asynchronous I/O operations, allowing registration, deregistration, and re-registration of file descriptors with specific interests. It works with abstract state types through a module interface and interacts with selectors and tokens to track I/O events. Concrete use cases include integrating custom I/O resources into an event loop for monitoring read/write readiness.",
      "description_length": 409,
      "index": 13,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Gluon.Sys",
      "library": "gluon",
      "description": "Manages I/O event monitoring and asynchronous event handling. Provides operations to register, re-register, and deregister file descriptors with specific interests, and to wait for events with optional timeout and limit parameters. Works with file descriptors and event values of type `t`, supporting concrete use cases such as network servers and event-driven user interfaces.",
      "description_length": 377,
      "index": 14,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Gluon.Non_zero_int",
      "library": "gluon",
      "description": "This module defines a type `t` as an alias for `int` and provides a function `make` that returns `Some n` if the input is non-zero, or `None` if it is zero. It is useful for validating integer values that must not be zero, such as divisors or indices in certain contexts.",
      "description_length": 271,
      "index": 15,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Gluon",
      "library": "gluon",
      "description": "This module provides low-level I/O management and event handling capabilities. It includes modules for working with file descriptors, tokens, interest flags, and events to support asynchronous I/O operations. Concrete use cases include implementing network servers, managing file and socket I/O with precise control, and building event-driven systems with custom I/O resources.",
      "description_length": 377,
      "index": 16,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 17,
    "meaningful_modules": 17,
    "filtered_empty_modules": 0,
    "retention_rate": 1.0
  },
  "statistics": {
    "max_description_length": 612,
    "min_description_length": 236,
    "avg_description_length": 415.70588235294116,
    "embedding_file_size_mb": 0.24682140350341797
  }
}