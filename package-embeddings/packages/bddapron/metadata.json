{
  "package": "bddapron",
  "embedding_model": "BAAI/bge-base-en-v1.5",
  "embedding_dimension": 1024,
  "total_modules": 116,
  "creation_timestamp": "2025-06-18T16:53:10.238870",
  "modules": [
    {
      "module_path": "Bddapron.Formula.O.Expr1.Bool",
      "description": "Processes logical conjunctions of boolean expressions within a typed environment, transforming and combining conditions based on domain constraints. Operates on complex typed structures including environments, conditions, and expressions with nested type definitions. Used to simplify or restructure boolean logic in constraint-based systems, such as type-checking or theorem proving.",
      "description_length": 384,
      "index": 0,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Bddapron.Formula.O.Expr0.Bool",
      "description": "Handles logical conjunctions and variable forgetting in boolean expressions, operating on typed environments and constraints. Processes expressions with domain-specific type information and returns modified boolean expressions with updated constraints. Used to simplify or transform logical conditions in symbolic reasoning systems.",
      "description_length": 332,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bdd.Expr1.O.Bool",
      "description": "Provides boolean logic operations, checks, quantification, and manipulation on abstract boolean expressions with environment constraints, including logical combinators, substitutions, and transformations. Operates on symbolic expressions and environments, enabling tasks like constraint solving and formal verification through analysis and modification of boolean logic structures.",
      "description_length": 381,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bdd.Expr1.O.Bint",
      "description": "This module provides arithmetic operations, environment extensions, and boolean comparisons for manipulating binary integer expressions, alongside symbolic boolean manipulations like substitution and subset checks. It works with typed environments, binary integers, and BDD-like structures to handle symbolic computations and constraint reasoning. Use cases include formal verification, constraint solving, and expression analysis in contexts requiring precise value embedding and extraction.",
      "description_length": 492,
      "index": 3,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Bdd.Expr1.O.Benum",
      "description": "The module offers operations for constructing, manipulating, and querying boolean enumerated types, including converting between expressions and values, extending environments, and performing logical operations like equality, substitution, and restriction. It works with environments, boolean expressions, enumerated type values, and binary decision diagrams (BDDs) to enable environment-aware logical reasoning. These capabilities support use cases such as symbolic manipulation, formal verification, and automated reasoning tasks requiring structured logical representations.",
      "description_length": 577,
      "index": 4,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Bdd.Expr1.O.List",
      "description": "Converts between environment-aware lists of expressions and their serialized forms, maintaining type and environment context. Operates on custom list types wrapped with environment and expression data, supporting extension of environments and formatted output. Used to manage and serialize expression sequences within a typed environment structure.",
      "description_length": 348,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bdd.Expr0.O.Bool",
      "description": "This module offers boolean logic operations and BDD (Binary Decision Diagram) manipulations, including logical operators, comparisons, and quantification. It works with generic boolean expression types and BDD structures to enable tasks like logical equivalence checks, circuit optimization, and symbolic reasoning. Specific use cases involve formal verification, constraint solving, and simplifying complex boolean functions through operations like cofactoring and substitution.",
      "description_length": 479,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bdd.Expr0.O.Bint",
      "description": "This module enables arithmetic and logical operations on integer-like values, including addition, multiplication, and bitwise shifts, while also supporting BDD/ADD structure manipulations like variable restriction and substitution. It works with BDD/ADD representations and generic integer-like types parameterized by environments, facilitating symbolic computation and abstract interpretation. Use cases include formal verification, logic circuit analysis, and handling complex variable mappings in constraint systems.",
      "description_length": 519,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bdd.Expr0.O.Benum",
      "description": "Provides operations to manipulate and query enumerated data structures, including variable creation, conditional expressions, equality checks, and substitution. Works with types representing enumerated values, decision diagrams, and variables. Used for symbolic manipulation of boolean expressions and constraint-based reasoning in formal verification.",
      "description_length": 352,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bdd.Expr0.O.Expr",
      "description": "Provides functions to transform atoms and terms using mapping functions, construct terms from integer and enumerated values, and convert between BDDs and logical expressions. Works with custom atom and term types, along with BDDs and minterms for logical representation. Enables printing of terms, conjunctions, and DNF forms with customizable external ID condition handlers.",
      "description_length": 375,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bdd.Domain0.O.Asssub",
      "description": "Sorts an array of integers and corresponding BDD arrays, compares BDD arrays for equality, computes post-images of BDDs with respect to index arrays, and derives postconditions from BDDs and index arrays. Operates on integer arrays and arrays of Cudd BDDs. Used to analyze state transitions and verify properties in symbolic model checking.",
      "description_length": 340,
      "index": 10,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bddapron.Expr1.O.Bool",
      "description": "The module offers boolean logic operations, including evaluation, inspection, and manipulation of boolean expressions within typed environments, alongside symbolic transformations like substitution and quantification. It works with structured environments containing type constraints and boolean expressions, enabling precise control over logical conditions. Use cases include automated theorem proving, symbolic reasoning, and logic circuit design, where structured boolean manipulation and type-aware operations are critical.",
      "description_length": 527,
      "index": 11,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Bddapron.Expr1.O.Bint",
      "description": "The module offers arithmetic, comparison, and conditional operations on integer values within environment-based contexts, working with typed environments and expressions for symbolic or abstract execution tasks. It also enables manipulation of binary decision diagrams (BDDs) annotated with integers, supporting logical transformations and constraint-based analysis for applications like formal verification.",
      "description_length": 408,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bddapron.Expr1.O.Benum",
      "description": "Converts between expression representations and a structured environment-based data type, enabling manipulation of boolean enumerated values. Operates on environments with type and type definition constraints, along with boolean decision diagrams. Supports conditional logic, substitution, and labeling for symbolic execution and verification tasks.",
      "description_length": 349,
      "index": 13,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bddapron.Expr1.O.Apron",
      "description": "The module provides operations for constructing and manipulating symbolic numerical expressions, including arithmetic operations, conditionals, and environment extensions, with a focus on constraint propagation and symbolic analysis. It works with abstract domains, typed environments, and expressions, enabling tasks like static analysis and program verification through logical conditionals and variable substitutions. Specific use cases include handling constraint propagation, restricting variables, and substituting expressions in formal verification contexts.",
      "description_length": 565,
      "index": 14,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bddapron.Expr1.O.List",
      "description": "Converts between environment-aware expression lists and internal representation structures, managing type environments and expression normalization. Operates on typed environments, expression lists, and conditional constraints with explicit type and environment constraints. Used to transform and inspect expressions within a scoped type environment, supporting environment extension and pretty-printing.",
      "description_length": 404,
      "index": 15,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bddapron.Expr0.O.Bool",
      "description": "This module handles boolean logic operations and transformations, focusing on typed boolean expressions and BDD (Binary Decision Diagram) representations. It enables tasks like evaluating logical conditions, simplifying expressions, and performing quantification or substitution within constrained environments. Use cases include formal verification, circuit design, and automated reasoning where precise manipulation of boolean functions is required.",
      "description_length": 451,
      "index": 16,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Bddapron.Expr0.O.Bint",
      "description": "The module offers arithmetic and logical operations on abstract integer-like values and Binary Decision Diagrams (BDDs), utilizing a generic type 'a t for flexible manipulation. It supports symbolic computation through environment and condition contexts, alongside BDD-specific transformations like cofactoring and variable substitution. Use cases include formal verification, constraint solving, and logic synthesis, where precise control over boolean expressions and integer constraints is required.",
      "description_length": 501,
      "index": 17,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Bddapron.Expr0.O.Benum",
      "description": "Converts between expression representations and binary decision diagrams (BDDs) for logical reasoning. Operates on BDDs with custom environments and conditions, enabling manipulation of logical expressions through substitution, restriction, and conditional operations. Supports symbolic execution and verification tasks by allowing variable mapping, expression printing, and logical equivalence checks.",
      "description_length": 402,
      "index": 18,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bddapron.Expr0.O.Apron",
      "description": "This module enables arithmetic and logical manipulations on symbolic expressions within abstract domains, supporting operations like addition, multiplication, and comparisons on values of type 'a t, while also facilitating variable substitution and expression printing. It works with abstract domains, environment configurations, and symbolic representations to handle constraints and conditions, particularly useful in static analysis or program verification tasks. Specific applications include transforming expressions, debugging symbolic computations, and managing type conversions with rounding controls.",
      "description_length": 609,
      "index": 19,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bddapron.Formula.Expr1.Bool",
      "description": "Processes logical conjunctions by decomposing boolean expressions into pairs of sub-expressions. Operates on conditional and boolean expression types within a domain-specific context. Used to simplify complex boolean constraints during symbolic execution.",
      "description_length": 255,
      "index": 20,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bddapron.Formula.Expr0.Bool",
      "description": "Processes logical conjunctions by decomposing boolean expressions into pairs of sub-expressions based on environment and condition constraints. Operates on environment, condition, and boolean expression types from the Expr0 module. Used to simplify and analyze boolean logic in constraint-solving contexts.",
      "description_length": 306,
      "index": 21,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bddapron.Formula.O.Expr0",
      "description": "Manages boolean expressions by applying logical conjunctions and removing variables, operating on typed environments to refine constraints. It processes expressions with domain-specific types and returns updated forms that reflect modified logical conditions. Operations include simplifying complex conditions and eliminating unnecessary variables. For example, it can reduce `a && b || a` to `a` or remove `b` from `a && b` when it is no longer relevant.",
      "description_length": 455,
      "index": 22,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bddapron.Formula.O.Expr1",
      "description": "Combines boolean expressions under logical conjunctions, operating on typed environments and nested structures to simplify or restructure constraints. Supports transformations that respect domain-specific type definitions and logical relationships. Can merge, split, or normalize conditions to aid in type-checking or proof automation. For example, it can combine multiple type constraints into a single unified condition or decompose complex expressions into simpler, manageable parts.",
      "description_length": 486,
      "index": 23,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bddapron.Expr2.O.Bool",
      "description": "Provides conversion between boolean expressions in different representations, including Expr0, Expr1, and Bdd.Cond.value, along with environment and condition management. Works with complex type environments and nested type definitions, supporting operations like extending environments and checking truth values. Used to transform and inspect boolean logic structures within a typed symbolic execution context.",
      "description_length": 411,
      "index": 24,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bddapron.Expr2.O.List",
      "description": "Converts between different expression representations and environments, handling conditional constraints and type environments. Operates on lists of expressions, environments, and condition objects with type and typdef constraints. Supports environment extension and serialization for debugging or logging.",
      "description_length": 306,
      "index": 25,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Bddapron.Bdddomain0.O.L",
      "description": "Provides operations to check if a value represents a bottom element, perform a meet with a cube constraint, and project out specified dimensions from a symbolic state. Works with abstract elements, environment types, and BDD variables within the Apron library. Used to analyze and manipulate symbolic representations in static analysis tools.",
      "description_length": 342,
      "index": 26,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bdd.Env.O",
      "description": "Creates and manipulates symbolic representations using BDDs (Binary Decision Diagrams) with support for custom symbols, extensions, and relational constraints. Operates on types including symbols, BDD managers, and user-defined data structures. Used to generate and format symbolic models for formal verification and logic-based analysis.",
      "description_length": 338,
      "index": 27,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bdd.Expr1.Bool",
      "description": "The module provides logical operations (not, and, or, xor, nand, nor, nxor, eq, leq), conditional branching (ite), and environment management for symbolic boolean expressions. It operates on a generic type `( 'a , 'b ) t` to represent abstract constraints, enabling manipulation through substitution, restriction, and truth-value checks. This supports use cases like constraint solving, program verification, and symbolic reasoning in formal systems.",
      "description_length": 450,
      "index": 28,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bdd.Expr1.Bint",
      "description": "The module offers arithmetic and symbolic manipulation operations on binary integers and symbolic expressions, including environment management, boolean comparisons, and conditional transformations. It works with typed environments, decision diagrams, and a generic symbolic type, enabling tasks like constraint solving and expression simplification. Specific use cases involve logical reasoning, substitution within symbolic contexts, and evaluating constraints through restriction and guard operations.",
      "description_length": 504,
      "index": 29,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bdd.Expr1.Benum",
      "description": "This module provides operations for constructing, transforming, and evaluating symbolic expressions within typed environments, with a focus on boolean logic, substitutions, and condition extraction. It works with symbolic expressions, environments, and BDDs (Binary Decision Diagrams) through a type that pairs generic values with Cudd-managed BDDs for efficient manipulation. Use cases include formal verification, symbolic reasoning, and optimization tasks requiring boolean function analysis.",
      "description_length": 495,
      "index": 30,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Bdd.Expr1.List",
      "description": "Converts between environment-aware expression lists and internal representation structures, supporting both low-level and high-level expression formats. Operates on typed environments and expression lists, enabling manipulation of symbolic data in formal verification contexts. Extends environments and provides customizable pretty-printing for structured data.",
      "description_length": 361,
      "index": 31,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bdd.Expr1.O",
      "description": "Combines boolean logic, arithmetic, and enumerated type operations with environment-aware manipulation, enabling symbolic computation, constraint solving, and formal verification. It handles boolean expressions, binary integers, enumerated values, and BDDs, supporting substitutions, comparisons, and transformations. Users can analyze logical structures, extend environments, and serialize expression lists while preserving context. Tasks include verifying logical consistency, solving constraints, and converting between symbolic and concrete representations.",
      "description_length": 561,
      "index": 32,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bdd.Enum.Minterm",
      "description": "Processes a minterm by applying a function to each element in its structure, using an environment for type resolution. Operates on environments and minterm representations from the Reg module. Used to transform or analyze logical expressions during circuit synthesis.",
      "description_length": 267,
      "index": 33,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bdd.Domain1.O",
      "description": "This module provides lattice operations such as meet, join, and condition application, along with environment manipulation and expression substitution, enabling precise analysis and transformation of abstract environments. It works with typed environments, expressions, and domain representations, maintaining type constraints during modifications. Use cases include static analysis, program verification, and code optimization tasks where abstract interpretation and type-preserving transformations are critical.",
      "description_length": 513,
      "index": 34,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Bdd.Expr0.Bool",
      "description": "The module provides boolean logic operations and value inspection on a generic type 'b t, alongside binary decision diagram (BDD) manipulations including logical comparisons, quantification, and substitution. These functions support tasks like formal verification, symbolic execution, and logic circuit design by enabling efficient handling of logical expressions and variable transformations.",
      "description_length": 393,
      "index": 35,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bdd.Expr0.Bint",
      "description": "The module offers arithmetic and logical operations\u2014such as addition, multiplication, comparison, and bitwise shifts\u2014on integer-like values and binary decision diagrams (BDDs), working with generic types and boolean conditions. It supports advanced use cases like symbolic execution, logical filtering, and variable mapping in formal verification or constraint-solving scenarios.",
      "description_length": 379,
      "index": 36,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Bdd.Expr0.Benum",
      "description": "Converts between expressions and decision diagrams, supports variable binding, conditional expressions, and equality checks. Operates on labeled decision diagrams and variable environments, enabling symbolic manipulation and transformation. Used for implementing logic constraints, symbolic execution, and formal verification tasks.",
      "description_length": 332,
      "index": 37,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bdd.Expr0.O",
      "description": "combines boolean logic, arithmetic, enumeration, and term manipulation to support symbolic reasoning and formal verification. It handles BDDs, ADDs, enumerated values, and custom terms, enabling operations like logical equivalence checks, arithmetic computations, variable substitutions, and term conversions. Users can simplify boolean functions, analyze circuits, and manage constraint systems through cofactoring, substitution, and DNF generation. It supports tasks such as verifying logical properties, optimizing circuits, and translating between different logical representations.",
      "description_length": 586,
      "index": 38,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Bdd.Reg.Minterm",
      "description": "Checks if a term is an indeterminate, converts integers to terms, converts terms to integers with signedness control, iterates over terms, and maps terms to a list of values. Works with arrays of Cudd.Man.tbool. Used for manipulating Boolean expressions in symbolic computation tasks.",
      "description_length": 284,
      "index": 39,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bdd.Domain0.O",
      "description": "Processes integer and BDD arrays to perform sorting, equality checks, post-image computations, and postcondition derivation, enabling analysis of state transitions and property verification. Key data types include integer arrays and Cudd BDD arrays, with operations for sorting, comparison, and image computation. It supports deriving postconditions by applying BDD operations to indexed state transitions. For example, it can compute the next state set of a system given a current state and transition relations.",
      "description_length": 513,
      "index": 40,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Bdd.Int.Minterm",
      "description": "Iterates over or transforms the integer indices of a minterm representation, handling signed or unsigned interpretations. It operates on a Reg.Minterm.t structure, which encodes logical terms as bit patterns. Used to process minterm data for logic synthesis or Boolean function analysis.",
      "description_length": 287,
      "index": 41,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bddapron.Env.O",
      "description": "Provides operations to construct and serialize complex data structures involving symbols, type definitions, and BDD-based representations. Works with symbolic expressions, type metadata, and BDD managers to enable efficient logical modeling. Used to generate human-readable outputs for debugging or analysis of symbolic logic systems.",
      "description_length": 334,
      "index": 42,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bddapron.Mtbdddomain0.O",
      "description": "This module provides operations for manipulating abstract domains through symbolic and static analysis, including lattice operations like meet, join, and widening, as well as constraint handling and domain transformations. It works with abstract values (`'b t`), environments, and a manager (`'a, 'b) man` to manage domain-specific logic, enabling tasks such as program analysis and refinement. Use cases include static verification, constraint propagation, and abstract interpretation techniques for program semantics.",
      "description_length": 519,
      "index": 43,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bddapron.Expr1.Bool",
      "description": "This module offers boolean logic operations and symbolic manipulation, focusing on constructing, evaluating, and transforming boolean expressions represented as `'a t`. It supports logical combinators like `not`, `and`, `or`, and advanced operations such as quantification, substitution, and cofactoring, alongside environment management for context-aware evaluations. Use cases include formal verification, automated reasoning, and systems requiring dynamic boolean expression analysis.",
      "description_length": 487,
      "index": 44,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bddapron.Expr1.Bint",
      "description": "The module provides arithmetic, logical, and BDD-based operations for manipulating integer expressions and conditions, including comparisons, cofactoring, and environment extensions. It works with BDDs represented as `'a t` and conditions of type `'a Cond.t`, supporting applications in formal verification and symbolic execution where dynamic constraint handling is critical. Specific use cases include managing symbolic variables and performing efficient logical deductions in constraint-solving contexts.",
      "description_length": 507,
      "index": 45,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Bddapron.Expr1.Benum",
      "description": "Converts between environment-aware BDD representations and expressions, supporting variable binding, conditional operations, and logical constraints. Operates on environment-aware BDD values and boolean expressions, enabling symbolic manipulation and analysis. Used for implementing decision diagrams with dynamic variable contexts, such as in formal verification or constraint solving.",
      "description_length": 386,
      "index": 46,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bddapron.Expr1.Apron",
      "description": "This module enables manipulation of abstract domains through arithmetic operations, conditionals, and constraints, alongside logical transformations like equality checks, cofactoring, and variable substitution. It works with typed environments, symbolic expressions, and abstract values represented as 'a t, facilitating symbolic and interval-based numerical analysis. Use cases include program verification, constraint solving, and static analysis where precise handling of variable relationships and numerical ranges is critical.",
      "description_length": 531,
      "index": 47,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bddapron.Expr1.List",
      "description": "Provides functions to convert between environment-aware list structures and expression representations, extend environments, and normalize or print structured data. Works with environment-value pairs and lists of expressions, supporting transformations between internal and external representations. Used to manage and manipulate expression lists within a scoped environment, such as in compiler or interpreter contexts.",
      "description_length": 420,
      "index": 48,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Bddapron.Expr1.O",
      "description": "Combines boolean, arithmetic, and symbolic operations within typed environments, enabling manipulation of expressions, constraints, and decision diagrams. It supports boolean evaluation, integer arithmetic, BDD transformations, and expression normalization, along with substitution, quantification, and constraint propagation. Users can perform symbolic execution, formal verification, and logic circuit design by working with structured environments and conditional expressions. Examples include analyzing logical conditions, simplifying arithmetic expressions, and generating constraint-based proofs.",
      "description_length": 602,
      "index": 49,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bddapron.Apronexpr.Lin",
      "description": "This module offers algebraic manipulations for linear expressions, including addition, scaling, and normalization, working with generic term containers (`'a t`) and rational coefficients (`Mpqf.t`). It supports substitution, comparison, and conversion between internal representations and Apron library types, enabling applications in symbolic computation or static analysis. The operations are designed for handling linear terms with structured coefficient management and precise arithmetic.",
      "description_length": 492,
      "index": 50,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bddapron.Apronexpr.Poly",
      "description": "This module enables algebraic manipulation of symbolic polynomials through operations like addition, multiplication, substitution, and normalization, working with structured types such as terms composed of rational coefficients and monomials, as well as polynomial lists. It supports variable-based expressions and context-specific symbolic computations, suitable for applications requiring precise algebraic transformations or symbolic mathematics. The design facilitates handling complex polynomial expressions by separating coefficients, variables, and operational patterns.",
      "description_length": 577,
      "index": 51,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bddapron.Apronexpr.Tree",
      "description": "Provides operations to manipulate symbolic trees, including substitution using variable mappings, expression conversion, and comparison based on symbols. Works with custom tree structures parameterized by a symbol type and integrates with Apron's expression types for arithmetic operations. Used to transform and analyze symbolic expressions in constraint systems.",
      "description_length": 364,
      "index": 52,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bddapron.Apronexpr.Condition",
      "description": "Provides operations to construct, manipulate, and convert constraints involving symbolic expressions, including negation, evaluation, and conversion to and from Apron constraint types. Works with symbolic expressions and constraints represented as tuples of types and expressions. Used to translate between custom constraint representations and Apron's internal linear and tree-based constraints for numerical analysis.",
      "description_length": 419,
      "index": 53,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bddapron.Cond.O",
      "description": "Creates and manipulates binary decision diagrams (BDDs) with symbolic variables, allowing for efficient representation and manipulation of logical expressions. Operates on BDD managers, symbolic variables, and conditional structures tied to a specific environment. Used to encode and evaluate complex logical constraints in formal verification and model checking.",
      "description_length": 363,
      "index": 54,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Bddapron.Expr0.Bool",
      "description": "The module offers boolean logic operations and transformations on abstract boolean expressions and binary decision diagrams (BDDs), including constructs like conditional evaluation (`ite`), negation (`dnot`), conjunction (`dand`), and quantification. It manipulates BDDs alongside environment and condition contexts, enabling tasks such as property checking (`is_true`) and circuit equivalence verification. Specific use cases include formal verification, logic synthesis, and symbolic reasoning with efficient boolean expression manipulation.",
      "description_length": 543,
      "index": 55,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bddapron.Expr0.Bint",
      "description": "The module provides arithmetic and logical operations on symbolic integer expressions, including addition, subtraction, and conditional branching, alongside BDD-based transformations for manipulating integer representations through cofactoring and variable substitution. It supports symbolic reasoning in verification tasks by handling environment and condition contexts, enabling applications like model checking and constraint analysis.",
      "description_length": 438,
      "index": 56,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Bddapron.Expr0.Benum",
      "description": "Converts between expression representations and binary decision diagrams (BDDs) for logical reasoning. Performs conditional operations, equality checks, and manipulation of BDDs using environment and condition contexts. Supports substitution, permutation, and printing of BDD structures with custom variable mappings.",
      "description_length": 317,
      "index": 57,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Bddapron.Expr0.Apron",
      "description": "This module enables arithmetic and logical operations on abstract domain elements, including expression creation, transformation, and comparison, alongside variable substitution and environment-based manipulation. It works with typed expressions, boolean conditions, and symbolic representations, leveraging structures like 'a t for abstract domain manipulations. Use cases include program analysis, constraint solving, and symbolic execution, where precise handling of arithmetic constraints and variable substitutions is critical.",
      "description_length": 532,
      "index": 58,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bddapron.Expr0.O",
      "description": "Provides boolean and arithmetic operations on symbolic expressions and BDDs, supporting evaluation, simplification, substitution, and equivalence checking. It works with abstract integer-like values and boolean functions, enabling manipulation through environments, conditions, and variable mappings. Tasks include formal verification, constraint solving, and logic synthesis, with examples like simplifying logical expressions, performing arithmetic on symbolic integers, and checking logical equivalence of BDDs. It also facilitates expression conversion, printing, and debugging within abstract domains.",
      "description_length": 606,
      "index": 59,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bddapron.ApronexprDD.Condition",
      "description": "Converts Apron expressions and conditions into BDD representations, supporting equality, subset, and substitution operations. Works with abstract domain elements, environment configurations, and condition expressions from the Apron library. Used to encode logical constraints for model checking and symbolic execution.",
      "description_length": 318,
      "index": 60,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bddapron.Formula.O",
      "description": "Combines and simplifies boolean expressions using logical conjunctions, operating on typed environments to refine and restructure constraints. It handles domain-specific types, enabling operations like variable elimination, condition merging, and normalization. For instance, it can simplify `a && b || a` to `a` or merge separate type constraints into a unified form. Key operations include expression transformation, constraint refinement, and logical restructuring.",
      "description_length": 468,
      "index": 61,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bddapron.Formula.Expr0",
      "description": "Handles logical conjunctions by breaking down boolean expressions into sub-expressions influenced by environment and condition constraints. It works with environment, condition, and boolean expression types to enable detailed analysis and simplification of logical structures. Operations include decomposition, constraint application, and logical evaluation. For example, it can split a complex condition like `x > 0 && y < 5` into separate components for independent analysis.",
      "description_length": 477,
      "index": 62,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bddapron.Formula.Expr1",
      "description": "Handles logical conjunctions by breaking down boolean expressions into component parts, enabling simplification of complex constraints during symbolic execution. It works with conditional and boolean expression types, allowing for structured manipulation and analysis. Operations include decomposition, restructuring, and evaluation of sub-expressions. For example, it can split `a && (b || c)` into `(a, b || c)` for further processing.",
      "description_length": 437,
      "index": 63,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bddapron.Domainlevel1.Make",
      "description": "This module offers abstract domain manipulation through operations like property queries, combination (meet, join, widening), and transformation (assignments, substitutions, variable forgetting), working with abstract elements, environments, and managers. It supports numerical domain handling via permutations and dimension management, applicable in static analysis tasks requiring precise state representation and transformation.",
      "description_length": 431,
      "index": 64,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bddapron.Policy.Dnf",
      "description": "Provides operations to manipulate and evaluate disjunctive normal form (DNF) expressions, including conjunction, disjunction, and simplification. Works with a type representing DNF as a list of conjunctions of boolean conditions. Used to generate and evaluate complex logical expressions in constraint satisfaction problems.",
      "description_length": 324,
      "index": 65,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Bddapron.Policy.DDDnf",
      "description": "Provides operations to manipulate and query multi-terminal binary decision diagrams (MTBDDs) representing disjunctive normal forms (DNFs), including node traversal, substitution, and equivalence checks. Works with typed MTBDDs and their associated tables, where each node holds a value of a user-defined type. Used to efficiently represent and evaluate complex logical expressions with numerical or symbolic outcomes in formal verification tasks.",
      "description_length": 446,
      "index": 66,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bddapron.Policy.DPolicy",
      "description": "Manages binary decision diagrams for dynamic policy evaluation, offering operations to construct, manipulate, and query policies represented as multi-terminal binary decision diagrams. Works with tagged values and tables that map identifiers to BDD nodes, enabling efficient policy composition and analysis. Used to enforce access control rules in systems requiring symbolic reasoning over complex policy conditions.",
      "description_length": 416,
      "index": 67,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Bddapron.Policy.PMtbdddomain0",
      "description": "Provides operations for manipulating and querying multi-terminal binary decision diagrams (MTBDDs), including node traversal, value extraction, and domain analysis. Works with MTBDDs represented as 'a DPolicy.t Cudd.Mtbdd.t and pairs of type ('a, 'b) man. Used to analyze logical constraints and compute domain-specific properties in formal verification tasks.",
      "description_length": 360,
      "index": 68,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bddapron.Policy.PDomain0",
      "description": "Provides operations to manipulate and query a structured data type representing a domain with six distinct components, including accessors, comparisons, and transformations. Works with tuples and records containing six polymorphic elements. Used to model and analyze complex domain configurations in constraint satisfaction problems.",
      "description_length": 333,
      "index": 69,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bddapron.Policy.Domain1",
      "description": "Handles condition evaluation and modification for domain-specific state transformations, using complex type parameters for environment and condition tracking. Operates on nested domain structures and expression types to apply or refine constraints in a structured manner. Supports both direct application and incremental improvement of conditions within a domain context.",
      "description_length": 371,
      "index": 70,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Bddapron.Policy.Domain0",
      "description": "Extracts a simplified manager structure from a complex domain object, processes environment and condition data to evaluate expressions, and manipulates symbolic representations for constraint analysis. Operates on nested type structures involving environments, conditions, and symbolic expressions with boolean outcomes. Used to apply and refine constraints in abstract interpretation contexts, such as static analysis of programs.",
      "description_length": 431,
      "index": 71,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bddapron.Policy.Mtbdddomain0",
      "description": "Provides operations to manage and manipulate symbolic domains using a manager structure, including creating managers, checking equality, printing, and applying/ improving conditions with boolean expressions. Works with environment and condition types from the Env and Cond modules, along with abstract interpretation policies. Used to refine and combine constraints in static analysis tools.",
      "description_length": 391,
      "index": 72,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bddapron.Expr2.O",
      "description": "Converts and manipulates boolean expressions across multiple representations, including Expr0, Expr1, and Bdd.Cond.value, while managing environments and conditions. Supports operations such as environment extension, truth value checking, and constraint handling, with emphasis on typed symbolic execution. Processes lists of expressions and condition objects, enabling transformation and inspection of logical structures. Examples include converting between expression formats, extending type environments, and serializing constraints for debugging.",
      "description_length": 550,
      "index": 73,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bddapron.Expr2.Bool",
      "description": "Converts boolean expressions between different representations, including Expr0, Expr1, and a generic expression type, while preserving environment and condition contexts. Operates on environments, conditions, and boolean expressions structured with BDD-based value types. Used to integrate boolean logic into symbolic computation workflows or constraint solving.",
      "description_length": 363,
      "index": 74,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Bddapron.Expr2.List",
      "description": "Converts lists of expression types into a structured BDD representation, supporting normalization, reduction, and environment resets. Retrieves and modifies associated conditions and environments, and serializes the structure for output. Used to manage and manipulate logical expressions within a bounded domain.",
      "description_length": 312,
      "index": 75,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bddapron.Bdddomain0.O",
      "description": "Offers operations to identify bottom elements, compute meets with cube constraints, and eliminate dimensions from symbolic states. Handles abstract elements, environment types, and BDD variables for symbolic manipulation. Allows analysis of program states by refining or simplifying their representation. For example, it can determine if a state is unsatisfiable, combine constraints, or remove irrelevant variables from analysis.",
      "description_length": 430,
      "index": 76,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Bdd.Output",
      "description": "Generates and manipulates binary decision diagrams (BDDs) and variable decision diagrams (VDDs) using condition sets and custom comparison functions. Processes node definitions and conditions through ordered iteration, extracting identifiers and structural information from diagram nodes. Constructs multi-terminal BDDs and VDDs with unique identifiers and table-based configurations.",
      "description_length": 384,
      "index": 77,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bdd.Normalform",
      "description": "This module provides functions for manipulating logical structures, including combining, transforming, and mapping operations on conjunctions, disjunctions, CNF, DNF, and labeled trees. It supports tasks like converting between normal forms, inserting terms into logical expressions, and formatting structures for output. Specific use cases include simplifying logical formulas, generating structured representations, and processing tree-based logical hierarchies.",
      "description_length": 464,
      "index": 78,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bdd.Reg",
      "description": "Manages Boolean expressions through term manipulation, including checking for indeterminates, converting between integers and terms, and iterating over term arrays. Supports signed integer conversion and mapping terms to value lists. Enables symbolic computation by handling Cudd.Man.tbool arrays. Examples include transforming integer values into symbolic terms and extracting lists of boolean results from term operations.",
      "description_length": 424,
      "index": 79,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Bdd.Env",
      "description": "Constructs and manages symbolic models using BDDs, enabling efficient representation and manipulation of logical constraints through custom symbols and relational operations. It handles core types such as symbols, BDD managers, and user-defined structures, supporting operations like constraint generation, model formatting, and logical inference. Users can define custom symbols, build relational constraints, and perform symbolic reasoning for verification tasks. Examples include modeling system states, verifying logical properties, and analyzing complex constraint relationships.",
      "description_length": 584,
      "index": 80,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Bdd.Int",
      "description": "Processes integer indices of minterm representations, supporting both signed and unsigned interpretations through transformation and iteration. Operates on Reg.Minterm.t, enabling manipulation of bit-pattern encoded logical terms. Allows tasks such as generating all possible index combinations or converting between signed and unsigned forms. Supports logic synthesis workflows by refining minterm data for Boolean function analysis.",
      "description_length": 434,
      "index": 81,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Bdd.Enum",
      "description": "Converts minterms into different forms or evaluates their properties by applying user-defined functions within a typed environment. Operates on environment maps and minterm structures from the Reg module, enabling manipulation of logical expressions. For example, it can simplify expressions by substituting variables or compute truth values based on given assignments. Key operations include mapping over minterm elements and resolving types during transformation.",
      "description_length": 465,
      "index": 82,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Bdd.Cond",
      "description": "This module handles symbolic condition management through operations like permutation, normalization, and reduction, working with BDDs and environment symbols via a generic type. It also enables serialization and deserialization of complex structures, including repositories and values, using tuple-based extraction and storage patterns. These capabilities support applications in formal verification and data persistence scenarios.",
      "description_length": 432,
      "index": 83,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bdd.Decompose",
      "description": "This module handles logical decomposition, support computation, and condition-based splitting of Binary Decision Diagrams (BDDs) and Value Decision Diagrams (VDDs), enabling operations like conversion between the two formats and sub-diagram extraction. It manipulates variable arrays, environments, and conditions to facilitate tasks such as symbolic state analysis and logic optimization. Specific applications include circuit verification and constraint satisfaction problem solving within formal methods.",
      "description_length": 507,
      "index": 84,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bdd.Expr0",
      "description": "Combines boolean, arithmetic, and symbolic operations on generic types and decision diagrams, enabling logical comparisons, variable substitutions, and expression transformations. Supports BDDs, ADDs, and enumerated values with functions for equivalence checks, arithmetic computations, and term conversions. Users can simplify boolean functions, analyze circuits, and manage constraints through cofactoring and DNF generation. Examples include verifying logical properties, optimizing symbolic expressions, and translating between logical representations.",
      "description_length": 556,
      "index": 85,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bdd.Expr1",
      "description": "Combines boolean logic, arithmetic, and symbolic manipulation with environment-aware operations, enabling constraint solving, formal verification, and symbolic reasoning. It works with typed environments, BDDs, and a generic symbolic type to perform substitutions, condition extraction, and expression evaluation. Users can construct complex logical structures, analyze boolean functions, and convert between symbolic and concrete representations. Examples include verifying logical consistency, simplifying constraints, and extending environments with new variables.",
      "description_length": 567,
      "index": 86,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bdd.Domain0",
      "description": "Processes integer and BDD arrays to sort, compare, and compute post-images, enabling state transition analysis and property verification. Key data types include integer arrays and Cudd BDD arrays, with operations for sorting, equality checks, and image computation. It supports deriving postconditions by applying BDD operations to indexed transitions, such as calculating the next state set from a current state and transition relations. This allows for precise manipulation and analysis of system behaviors through structured data transformations.",
      "description_length": 549,
      "index": 87,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bdd.Domain1",
      "description": "manages abstract environments through lattice operations like meet and join, enabling precise manipulation of typed expressions and domain states. It supports environment modifications, expression substitution, and condition application, preserving type integrity throughout transformations. Users can perform static analysis, program verification, and optimization by applying these operations to complex domain structures. For example, it allows merging two environments while respecting type constraints or substituting expressions within a given context.",
      "description_length": 558,
      "index": 88,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bddapron.Apronexpr",
      "description": "combines linear and polynomial algebra, symbolic tree manipulation, and constraint handling, enabling precise symbolic computations through structured term representations and rational coefficients. It supports operations like substitution, normalization, comparison, and conversion between internal and Apron types, with specialized handling of variables, monomials, and constraints. Users can perform algebraic transformations, analyze constraint systems, and manage complex expressions with fine-grained control over coefficients and structure. Examples include simplifying polynomial expressions, translating constraints between formats, and substituting variables in symbolic trees.",
      "description_length": 687,
      "index": 89,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Bddapron.Env",
      "description": "Constructs and serializes symbolic data structures, including type definitions and BDD representations, enabling efficient logical modeling. Supports operations on symbolic expressions, type metadata, and BDD managers to manipulate and analyze complex logical systems. Generates human-readable outputs for debugging or detailed analysis. Examples include converting symbolic expressions to string representations, managing type hierarchies, and querying BDD structures for logical properties.",
      "description_length": 492,
      "index": 90,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Bddapron.Cond",
      "description": "Manages symbolic logic through BDDs, enabling efficient handling of logical expressions via variable manipulation and conditional operations. Key data types include BDD managers, symbolic variables, and conditional nodes, with operations like encoding, simplification, and evaluation. It supports tasks such as verifying system properties by translating constraints into BDDs for rapid analysis. Examples include checking satisfiability of logical formulas and optimizing decision paths in verification workflows.",
      "description_length": 513,
      "index": 91,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Bddapron.ApronexprDD",
      "description": "Encodes Apron expressions and conditions as BDDs, enabling logical constraint manipulation through equality checks, subset relations, and substitutions. Operates on abstract domain elements, environments, and conditions to represent and transform logical states. Supports model checking and symbolic execution by translating high-level constraints into efficient binary decision diagrams. Examples include verifying property satisfaction, simplifying complex conditions, and propagating variable substitutions within abstract interpretations.",
      "description_length": 542,
      "index": 92,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bddapron.Common",
      "description": "Converts constraints into BDD representations and manipulates arrays of constraints for symbolic reasoning. Operates on Apron constraints, BDD variables, and environment objects containing type and type definition information. Enables logical condition extraction and decomposition of variables for analysis in formal verification contexts.",
      "description_length": 340,
      "index": 93,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Bddapron.ApronDD",
      "description": "This module provides operations for manipulating abstract domains through symbolic execution and static analysis, including lattice operations like joins, meets, and widening, as well as constraint intersections and dimension transformations. It works with BDD-based representations (Cudd.Mtbddc.t), abstract elements, managers, and dimension arrays, enabling tasks such as logical quantification, substitution, and constraint propagation. Key use cases involve program analysis, verification, and optimization by handling complex domain interactions and symbolic reasoning.",
      "description_length": 574,
      "index": 94,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bddapron.Expr0",
      "description": "Combines boolean and arithmetic operations on symbolic expressions and BDDs, supporting evaluation, simplification, substitution, and equivalence checking. It handles typed expressions, environments, and variable mappings, enabling tasks like formal verification, model checking, and constraint solving. Key operations include conditional evaluation, negation, conjunction, arithmetic operations, and BDD manipulation. Examples include simplifying logical expressions, verifying circuit equivalence, and performing symbolic arithmetic on abstract integers.",
      "description_length": 556,
      "index": 95,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bddapron.Expr1",
      "description": "Combines boolean, arithmetic, and symbolic operations within typed environments, enabling manipulation of expressions, constraints, and decision diagrams. It handles boolean evaluation, integer arithmetic, BDD transformations, and expression normalization, with support for substitution, quantification, and constraint propagation. Users can analyze logical conditions, simplify arithmetic expressions, and generate constraint-based proofs. Key data types include environment-aware BDDs, symbolic expressions, and abstract values, with operations spanning logical combinators, arithmetic computations, and environment management.",
      "description_length": 629,
      "index": 96,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bddapron.Expr2",
      "description": "Transforms and manipulates boolean expressions across multiple representations, including Expr0, Expr1, and BDD-based structures, while maintaining environment and condition contexts. Supports operations like environment extension, condition retrieval, and expression normalization, enabling symbolic execution and constraint management. Converts between formats, serializes structures, and resets environments to facilitate logical analysis. Examples include converting expressions for debugging, integrating logic into symbolic workflows, and managing bounded logical domains.",
      "description_length": 578,
      "index": 97,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bddapron.Descend",
      "description": "Provides operations for manipulating symbolic expressions and binary decision diagrams (BDDs), including cofactor computation, support extraction, and expression splitting. Works with arrays of expression trees, BDD variables, and abstract domain representations. Used to decompose complex expressions into sub-expressions for analysis, optimize BDD structures, and traverse expression hierarchies with custom reduction functions.",
      "description_length": 430,
      "index": 98,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Bddapron.Mtbdddomain0",
      "description": "manages abstract domains using lattice operations, constraint handling, and transformations, operating on abstract values (`'b t`), environments, and a manager (`'a, 'b) man` to support program analysis. It enables tasks like static verification, constraint propagation, and abstract interpretation by combining meet, join, and widening operations. Users can refine program semantics, track variable relationships, and enforce invariants through domain-specific logic. Examples include analyzing control flow, detecting overflow conditions, and propagating logical constraints across code paths.",
      "description_length": 595,
      "index": 99,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Bddapron.Bddleaf",
      "description": "Processes lists of labeled elements with custom equality and merging logic. Supports folding, iteration, and operations to ensure uniqueness or disjointness of elements based on their labels. Enables safe construction and combination of element lists for applications like symbolic computation or constraint management.",
      "description_length": 319,
      "index": 100,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bddapron.Bdddomain0",
      "description": "manages symbolic states through operations that find bottom elements, compute meets under cube constraints, and eliminate dimensions. it works with abstract elements, environment types, and BDD variables to manipulate and analyze program states. it can detect unsatisfiable states, merge constraints, and prune unnecessary variables. this enables precise and efficient symbolic reasoning in verification tasks.",
      "description_length": 410,
      "index": 101,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bddapron.Domain0",
      "description": "This module enables manipulation of abstract states through logical operations like meet, join, and widening, along with canonicalization and substitution, operating on structured representations such as abstract domain types and BDD/MTBDD frameworks. It facilitates interoperability between Apron-based and BDD/MTBDD domains via serialization, transformation, and management of domain-specific managers and node structures. Use cases include static analysis and symbolic reasoning, where efficient representation and conversion of logical expressions are critical for program verification and constraint solving.",
      "description_length": 613,
      "index": 102,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bddapron.Domainlevel1",
      "description": "This module provides operations for manipulating abstract domains, including lattice operations like meet, join, and widening, as well as substitutions and dimension permutations. It works with structures such as `'b t` representations, environments, and permutation arrays, interacting with Apron's abstract semantics. Use cases include static analysis tasks requiring domain transformations or variable reordering in program verification.",
      "description_length": 440,
      "index": 103,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Bddapron.Mtbdddomain1",
      "description": "This module provides operations for constructing, manipulating, and combining abstract domains that integrate boolean decision diagrams (BDDs) with numerical abstractions, enabling symbolic and numerical reasoning through environment-based representations. It handles tasks such as constraint enforcement, variable substitution, renaming, and widening, operating on data structures like environments mapping variables to abstract values and BDDs augmented with Apron numerical domains. Use cases include program analysis and verification, where precise tracking of symbolic constraints and numerical ranges is critical.",
      "description_length": 619,
      "index": 104,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Bddapron.Bdddomain1",
      "description": "This module offers operations for manipulating abstract domains through semantic joins, meets, and condition-based transformations, working with environments, Apron abstract values, and boolean expressions to model program states. It supports symbolic manipulations like variable substitution, environment updates, and domain unification, tailored for applications in static analysis and constraint solving. Key use cases include refining abstract interpretations and managing variable dependencies in verification tasks.",
      "description_length": 521,
      "index": 105,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bddapron.Domain1",
      "description": "This module facilitates abstract domain manipulations through lattice operations, environment transformations, and bidirectional conversions between symbolic representations like BDDs and structured manifolds. It works with complex data structures including abstract states, expressions, constraints, and domain-specific types such as `mtbdd`, `bdd`, and `man`, enabling symbolic reasoning and inter-domain interoperability. Key use cases involve optimizing abstract interpretations, managing environment changes, and translating between representation formats for analysis tasks.",
      "description_length": 580,
      "index": 106,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bddapron.Formula",
      "description": "combines boolean expressions through logical conjunctions, enabling constraint simplification, decomposition, and restructuring across typed environments. it operates on environment, condition, and boolean expression types, supporting variable elimination, condition merging, and normalization. it can simplify expressions like `a && b || a` to `a` or split `a && (b || c)` into `(a, b || c)`. key operations include decomposition, transformation, and evaluation of logical components.",
      "description_length": 485,
      "index": 107,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bddapron.Policy",
      "description": "combines DNF manipulation, MTBDD traversal, and policy evaluation to handle logical expressions and domain configurations. it supports operations on DNF lists, MTBDDs with user-defined node values, and structured domain tuples, enabling constraint analysis, policy composition, and symbolic reasoning. users can simplify logical expressions, check equivalence, extract values, and apply conditions to refine domain states. examples include evaluating access control policies, analyzing constraint satisfaction problems, and performing formal verification of logical properties.",
      "description_length": 577,
      "index": 108,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bddapron.Syntax",
      "description": "This module handles operations for converting, printing, and evaluating abstract syntax tree (AST) elements, including expressions, binary and unary operators, and constants, with support for type conversions and precedence checks. It works with custom types like `cst`, `unop`, `binop`, and parameterized expression structures such as `'a expr` to represent syntactic constructs. Use cases include compiler components for code analysis, transformation, or generation where structured AST manipulation is required.",
      "description_length": 514,
      "index": 109,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Bddapron.Yacc",
      "description": "Parses arithmetic expressions from a lexer input, converting tokens into an abstract syntax tree. It processes a lexing buffer and a token-producing function to build expressions according to a defined grammar. The module relies on a custom token type to represent lexical elements during parsing.",
      "description_length": 297,
      "index": 110,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Bddapron.Lex",
      "description": "Processes input streams to generate tokens according to predefined lexical rules. It operates on Lexing.lexbuf structures and outputs Yacc.token values. Used to parse source code by breaking it into meaningful syntactic components during compilation workflows.",
      "description_length": 260,
      "index": 111,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Bddapron.Parser",
      "description": "Converts strings and lexing buffers into structured expression types, including boolean expressions and lists of expressions, with options for normalization, reduction, and context resetting. Operates on environments, conditions, and various expression layers like Expr0, Expr1, and Expr2. Parses input for logical and syntactic analysis in domain-specific languages.",
      "description_length": 367,
      "index": 112,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "bddapron",
      "description": "Provides operations for manipulating abstract domains in static analysis, including widening, narrowing, and intersection of constraints. Works with polyhedra and octagons represented as sets of linear inequalities. Used to refine numerical invariants in program verification tools.",
      "description_length": 282,
      "index": 113,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bdd",
      "description": "Combines BDD and VDD operations with logical and symbolic manipulation, enabling the creation, transformation, and analysis of complex logical structures. It handles boolean, arithmetic, and symbolic expressions, supporting tasks like formula simplification, constraint generation, and state transition analysis using BDD arrays, minterms, and environment maps. Key data types include BDD managers, symbolic terms, integer arrays, and environment structures, with operations for substitution, normalization, and logical inference. Examples include verifying system properties, optimizing boolean functions, and performing symbolic reasoning on relational constraints.",
      "description_length": 667,
      "index": 114,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bddapron",
      "description": "Combines symbolic computation, BDD manipulation, and abstract domain operations to enable precise logical and algebraic reasoning. It handles data types like BDDs, abstract elements, environments, and constraints, supporting operations such as substitution, normalization, simplification, and logical evaluation. Users can translate between symbolic and BDD representations, analyze constraint systems, and perform program verification tasks. Examples include simplifying boolean expressions, verifying logical conditions, and optimizing decision diagrams for formal analysis.",
      "description_length": 576,
      "index": 115,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 116,
    "meaningful_modules": 116,
    "filtered_empty_modules": 0,
    "retention_rate": 1.0
  },
  "statistics": {
    "max_description_length": 687,
    "min_description_length": 255,
    "avg_description_length": 450.87068965517244,
    "embedding_file_size_mb": 0.4216651916503906
  }
}