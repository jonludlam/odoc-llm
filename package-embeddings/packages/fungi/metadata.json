{
  "package": "fungi",
  "embedding_model": "Qwen/Qwen3-Embedding-0.6B",
  "embedding_dimension": 1024,
  "total_modules": 96,
  "creation_timestamp": "2025-07-15T23:21:34.396892",
  "modules": [
    {
      "module_path": "Fungi.Graph.MakeGraph.Path.Compute.PathList",
      "library": "fungi",
      "description": "This module computes and manages lists of paths in a graph, where each path consists of nodes with associated measures (e.g., distances or weights). It provides operations to bind path lists to a specific ordering, compare path lists based on their order, and define a total ordering between path elements. Concrete use cases include tracking multiple shortest paths in a weighted graph and selecting optimal paths based on accumulated measures.",
      "description_length": 445,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fungi.Graph.MakeGraph.Span.EdgeDisj.BijectTbl",
      "library": "fungi",
      "description": "This module supports efficient storage and manipulation of edge mappings using bijective hash tables, where keys represent graph edges (`EdgeDisj.elt`) and values are arbitrary. It provides imperative operations for bulk updates via sequences, enabling use cases like dynamic edge filtering or batch processing in graph algorithms such as Kruskal's, where edge sets require efficient membership checks and incremental modifications during minimum spanning tree construction.",
      "description_length": 474,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fungi.Graph.MakeGraph.Path.Compute.PathSet",
      "library": "fungi",
      "description": "This module provides functions for managing and querying sets of path elements in graph structures, supporting operations like union, intersection, filtering, and traversal (depth-first, breadth-first) while maintaining efficient set-theoretic manipulations. It operates on collections of path elements (`Path.pathelt`) within graphs built using adjacency sets, enabling precise control over path discovery and analysis. Typical applications include shortest path algorithms, pathfinding in networks, and dependency resolution where ordered traversal or dynamic path set updates are required.",
      "description_length": 592,
      "index": 2,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fungi.Graph.MakeGraph.Path.Compute.PathHeap",
      "library": "fungi",
      "description": "This module provides a priority queue implementation optimized for graph path management, supporting operations like insertion, extraction, and merging of path elements based on dynamic thresholds or custom comparison logic. It works with weighted graph structures where nodes and edges are represented using the parent module's adjacency set model, tracking path measures such as cumulative weights. The heap is particularly suited for pathfinding algorithms requiring efficient exploration of shortest or lowest-cost paths with adaptive prioritization and deduplication.",
      "description_length": 572,
      "index": 3,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fungi.Graph.MakeGraph.Span.EdgeDisj.ResolvTbl",
      "library": "fungi",
      "description": "This module provides a hash table implementation for managing integer-keyed mappings to track resolved edges in disjoint set structures, primarily used during Kruskal's algorithm for minimum spanning trees. It supports standard operations like insertion, deletion, and lookup, along with batch processing of key-value pairs via sequences to efficiently construct or update edge resolution state. The tables facilitate merging disjoint sets by maintaining mappings that resolve edge connections during graph traversal and partitioning.",
      "description_length": 534,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fungi.Graph.MakeGraph.Matching.Compute",
      "library": "fungi",
      "description": "Implements the Gale-Shapley algorithm for bipartite matching in graphs. Takes an adjacency map, preference lists for two disjoint node sets, and returns a stable matching as a set of edges. Useful for solving assignment problems like matching students to schools or residents to hospitals based on mutual preferences.",
      "description_length": 317,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fungi.Graph.MakeGraph.Span.EdgeDisj",
      "library": "fungi",
      "description": "This module implements a disjoint-set data structure with union-find operations, optimized for graph algorithms like Kruskal's by using bijective and resolution tables to track component hierarchies and edge mappings. It provides core operations for merging and querying connected components, along with imperative updates over sequences for dynamic edge filtering and batch processing. The bijective tables map graph edges to identifiers, while resolution tables track edge resolutions during set merging, enabling efficient membership checks and incremental modifications. Example use cases include cycle detection in minimum spanning tree construction and maintaining dynamic edge sets with fast lookups and bulk updates.",
      "description_length": 724,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fungi.Graph.MakeGraph.Scc.SccSet",
      "library": "fungi",
      "description": "This module provides operations for managing sets of strongly connected components (SCCs) in graph algorithms, supporting standard set manipulations (union, intersection, difference), ordered traversals (preorder, postorder), and element extraction (min/max with inversion). It works with sets of `Scc.sccnode` elements derived from graph structures, enabling efficient querying and transformation of SCC relationships. Typical use cases include dependency resolution, component-based graph analysis, and hierarchical processing of cyclic subgraphs.",
      "description_length": 549,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fungi.Graph.MakeGraph.Flow.Flowtbl",
      "library": "fungi",
      "description": "This module implements a hash table for tracking flow values on directed edges, supporting insertion, lookup, and iteration while enabling bulk updates through sequence-based operations like `add_seq` and `of_seq`. It operates on key-value pairs where keys are directed node pairs (`Unique.t * Unique.t`), making it suitable for flow network algorithms that require dynamic management of edge capacities or residual flows. The structure is particularly useful in maximum flow and circulation problems where efficient flow adjustments and queries are critical.",
      "description_length": 559,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fungi.Graph.MakeGraph.Serialize.ClstrTbl",
      "library": "fungi",
      "description": "This module provides imperative hash table operations for managing cluster mappings with integer keys and generic values, supporting efficient lookups, bulk modifications, and sequence-based construction. It works with cluster tables (`ClstrTbl.t`) that store key-value pairs and enable transformations like filtering, folding, and statistical analysis over clustered data. Specific use cases include handling dynamic groupings of graph elements during serialization workflows and optimizing bulk updates from sequential data sources.",
      "description_length": 534,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fungi.Graph.MakeGraph.Scc.SccMap",
      "library": "fungi",
      "description": "This module provides a map implementation for associating integer keys with arbitrary values, supporting insertion, deletion, ordered traversal, and sequence-based transformations. It includes operations for ordered key queries, filtered value transformations, and bulk updates while maintaining key ordering and physical equality semantics. The structure is particularly useful in graph analysis scenarios requiring efficient SCC (Strongly Connected Component) tracking, where integer keys represent component identifiers and values store associated metadata or computed results.",
      "description_length": 580,
      "index": 10,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fungi.Graph.MakeGraph.Scc.SccTbl",
      "library": "fungi",
      "description": "This module provides operations to associate SCC nodes with arbitrary data using a hash table, supporting insertion, lookup, iteration, folding, and in-place filtering. It works with a hash table type (`Scc.SccTbl.t`) keyed by `Scc.sccnode`, enabling efficient bulk initialization or updates via sequence-based functions like `replace_seq` and `of_seq`. It is particularly useful in graph algorithms requiring per-SCC metadata aggregation or transformation, such as dependency analysis or component-based optimizations.",
      "description_length": 519,
      "index": 11,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fungi.Graph.MakeGraph.Serialize.AttrbTbl",
      "library": "fungi",
      "description": "This component offers hash table operations for managing string-keyed, generic-valued attributes attached to graph nodes or edges, supporting bulk updates from sequences and seamless integration with graph serialization workflows. It handles attribute tables (`AttrbTbl.t`) through standard imperative patterns, enabling efficient insertion, modification, and traversal of key-value pairs, while also providing sequence-based initialization and population. These tools are particularly useful for scenarios requiring structured metadata storage, such as exporting node/edge properties to JSON formats or synchronizing attribute state during graph persistence.",
      "description_length": 659,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fungi.Graph.MakeGraph.Serialize.StyleTbl",
      "library": "fungi",
      "description": "This module enables storage and manipulation of string-keyed metadata through a mutable hash table structure, supporting imperative operations like insertion, bulk updates, and traversal. It works with arbitrary value types paired with string keys, organizing them in a serializable format optimized for attribute-heavy data. The structure is particularly useful for attaching customizable properties to graph components during serialization workflows, where bulk initialization from key-value sequences simplifies configuration of node or edge styling attributes.",
      "description_length": 564,
      "index": 13,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fungi.Graph.MakeGraph.Path.Compute",
      "library": "fungi",
      "description": "This module orchestrates shortest path computation across diverse graph structures using algorithms like Dijkstra, A*, Bellman-Ford, and Floyd-Warshall, operating on nodes of type `Unique.t` and weighted edges wrapped in `Measure.t`. It leverages custom data structures\u2014`PathList` for managing ordered path collections, `PathSet` for efficient set operations during traversal, and `PathHeap` for priority-based path exploration\u2014to enable tasks like route planning, dependency analysis, and network optimization. Direct APIs support algorithm selection and graph manipulation, while submodules refine path handling through ordered lists, set-theoretic operations, and priority queues with dynamic prioritization. Specific capabilities include detecting negative cycles, tracking multiple shortest paths, and dynamically updating path sets during traversal.",
      "description_length": 855,
      "index": 14,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fungi.Graph.MakeGraph.EdgeSet",
      "library": "fungi",
      "description": "This module supports set-theoretic operations on edges represented as pairs of `Unique.t` values, including union, intersection, difference, filtering, and membership checks. It provides efficient traversal mechanisms like `fold`, `iter`, and ordered traversals (preorder, inorder, postorder), along with utilities for sequence conversion and extremal element extraction. These operations are particularly useful in graph algorithms requiring edge set manipulation, such as connected component detection, pathfinding, or dependency analysis.",
      "description_length": 541,
      "index": 15,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fungi.Unionfind.MakeDisjointSet.BijectTbl",
      "library": "fungi",
      "description": "This module supports imperative manipulation of bidirectional hash tables, enabling efficient key-value associations with operations like insertion, deletion, iteration, and bulk updates from sequences. It works with key-value pairs where keys are of type `elt`, maintaining bijective mappings that allow both forward and reverse lookups. The sequence-based functions facilitate bulk initialization or modification of mappings, useful in scenarios requiring batch processing of key-value relationships.",
      "description_length": 502,
      "index": 16,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fungi.Graph.MakeGraph.Vertex",
      "library": "fungi",
      "description": "This module manages vertex adjacency data in a graph structure, providing operations to create, compare, and update edges with associated weights. It works with unique identifiers (`Unique.t`) for vertices and edges, using maps (`NodeMap.t`) to track adjacency relationships and weight tables (`Weights.t`). Concrete use cases include constructing weighted edges between nodes, retrieving edge information, and ensuring consistent adjacency updates in graph algorithms like shortest path or network flow.",
      "description_length": 504,
      "index": 17,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fungi.Graph.MakeGraph.NodeMap",
      "library": "fungi",
      "description": "This module supports map operations such as insertion, modification, and combination on uniquely identified nodes (`Unique.t` keys), tailored for managing adjacency data and vertex properties in graph algorithms. It works with maps that associate node identifiers with adjacency sets or arbitrary data, supporting ordered traversal and conversion to sequences for efficient iteration. Typical use cases include dynamically updating node relationships, aggregating vertex metadata, or processing graphs with ordered node selections.",
      "description_length": 531,
      "index": 18,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fungi.Unionfind.MakeDisjointSet.ResolvTbl",
      "library": "fungi",
      "description": "This module implements a mutable hash table optimized for integer keys and generic values, offering efficient insertion, lookup, and in-place modification operations. It supports bulk initialization from key-value sequences, batch updates, and traversal via iteration or folding, making it suitable for scenarios requiring dynamic data management with integer-indexed entries. The structure is particularly effective for tasks like caching integer-mapped values, incremental table population, and stateful transformations of large datasets.",
      "description_length": 540,
      "index": 19,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fungi.Graph.MakeGraph.Matching",
      "library": "fungi",
      "description": "This module provides algorithms for finding matchings in bipartite graphs, including Hall's condition check to determine the existence of a valid matching. It supports operations on adjacency maps and uniquely labeled node sets, enabling tasks like assigning workers to tasks or students to schools. The Gale-Shapley algorithm in the child module extends this functionality by computing stable matchings based on preference lists from both sides of the bipartition. Example uses include matching residents to hospitals or students to dorm rooms, ensuring stability based on ranked preferences.",
      "description_length": 593,
      "index": 20,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fungi.Graph.MakeGraph.Span",
      "library": "fungi",
      "description": "This module computes minimum spanning trees for graphs with weighted edges using Prim's and Kruskal's algorithms, operating on adjacency maps and leveraging a measure module to define edge costs. It integrates a disjoint-set structure with union-find operations to efficiently manage connected components during tree construction, supporting imperative updates and dynamic edge filtering through bijective and resolution tables. You can compute the lowest-cost connected subgraph of a weighted network, detect cycles during edge addition, or maintain dynamic edge sets with fast membership queries and batch modifications. The interface supports both direct algorithm invocation and fine-grained control over component merging and edge resolution.",
      "description_length": 747,
      "index": 21,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fungi.Graph.MakeGraph.AdjSet",
      "library": "fungi",
      "description": "This module provides operations for managing adjacency sets in a graph structure, supporting efficient addition, membership checks, and conversion to/from lists, alongside ordered traversal and tree-based manipulations like `take_min` or `invert`. It works with sets of `Unique.t` elements, leveraging an ordered balanced tree representation to enable both structural queries and transformations of graph edges. These functions are suited for scenarios requiring precise control over adjacency relationships, such as graph traversal algorithms, edge reversal operations, or dynamic graph updates where ordered access to neighbors is critical.",
      "description_length": 642,
      "index": 22,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fungi.Graph.MakeGraph.Scc",
      "library": "fungi",
      "description": "This module implements algorithms for identifying strongly connected components (SCCs) in directed graphs using Tarjan's and Kosaraju's methods, processing graphs represented as adjacency maps and returning SCCs along with auxiliary data like discovery times and stack states. It supports direct analysis of cyclic dependencies and integrates submodules for managing SCC sets, mapping component identifiers to metadata, and associating SCC nodes with arbitrary data through hash tables. The set module enables union, intersection, and ordered traversal of SCCs, the map module maintains integer-keyed metadata with ordered operations, and the hash table module allows efficient per-node data aggregation and transformation. Example uses include tracking dependencies in program analysis, optimizing network structures, and performing component-wise computations with bulk updates and filtering.",
      "description_length": 894,
      "index": 23,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fungi.Graph.MakeGraph.Cluster",
      "library": "fungi",
      "description": "Implements algorithms for detecting cliques in graphs using the Bron\u2013Kerbosch method. It operates on adjacency maps and node sets, specifically working with graph structures built from unique node identifiers and their connected neighbors. This module is useful for analyzing social networks or biological interaction graphs where identifying tightly connected subgraphs is essential.",
      "description_length": 384,
      "index": 24,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fungi.Graph.MakeGraph.Flow",
      "library": "fungi",
      "description": "This module computes maximum flow in graphs with weighted edges using the Ford-Fulkerson and Edmonds-Karp algorithms, tracking flow state through a record that includes a flow table for residual capacities and a measure type for flow values. The flow table submodule efficiently manages directed edge capacities with operations like `add_seq` and `of_seq`, enabling bulk updates and dynamic adjustments during flow computation. It works with graphs where nodes have unique identifiers and edges carry capacity data, supporting operations like augmenting path selection and residual capacity updates. Example usage includes finding the maximum flow from a source to a sink in a network, tracking residual capacities across iterations, and updating flows in bulk using sequences of edge-value pairs.",
      "description_length": 797,
      "index": 25,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fungi.Graph.MakeGraph.Path",
      "library": "fungi",
      "description": "This module combines core pathfinding algorithms like Hierholzer's, DFS, and BFS with advanced shortest path computation using Dijkstra, A*, Bellman-Ford, and Floyd-Warshall. It operates on graphs with nodes of type `Unique.t`, supporting both unweighted traversal and weighted pathfinding with edge data wrapped in `Measure.t`. Submodules enhance path management through specialized structures\u2014`PathList`, `PathSet`, and `PathHeap`\u2014enabling efficient route planning, cycle detection, dynamic path updates, and multi-path tracking. Examples include finding Eulerian trails, computing shortest routes with custom heuristics, and analyzing dependencies in weighted graphs.",
      "description_length": 670,
      "index": 26,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fungi.Graph.MakeGraph.Serialize",
      "library": "fungi",
      "description": "This module converts graphs into structured formats like CSV and DOT, using adjacency maps and attribute tables to serialize nodes, edges, and clusters with attached metadata. It supports imperative hash table operations through submodules that manage cluster mappings, node/edge attributes, and generic metadata, enabling efficient lookups, bulk updates, and sequence-based initialization. You can export styled graphs for visualization in Graphviz, generate CSV files for analysis, or synchronize attribute state during graph persistence workflows. Specific tools include cluster grouping, attribute styling, and key-value metadata handling for customizable serialization outputs.",
      "description_length": 682,
      "index": 27,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fungi.Graph.MakeGraph.Weights",
      "library": "fungi",
      "description": "This module manages mappings from vertex identifiers to edge weights using hash table operations, supporting creation, modification, and iteration over weighted edges. It facilitates conversion between weight maps and sequences of vertex-edge pairs, enabling efficient updates and serialization of adjacency list structures. These operations are particularly useful for constructing and manipulating graphs with weighted edges, such as those representing networks or relational data.",
      "description_length": 483,
      "index": 28,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fungi.Graph.Graph-AdjSet",
      "library": "fungi",
      "description": "This module supports efficient graph traversal and transformation through ordered adjacency sets, which represent connections between nodes using either incoming or outgoing edges. It provides set-theoretic operations (union, intersection, difference, filtering) and traversal strategies (preorder, inorder, postorder) for manipulating collections of nodes or edges, with utilities for ordered extraction and inversion. These capabilities are particularly useful for graph algorithms requiring precise control over edge relationships, such as dependency resolution, pathfinding, or network flow analysis.",
      "description_length": 604,
      "index": 29,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fungi.Graph.Graph-Scc-SccMap",
      "library": "fungi",
      "description": "This module provides a total map structure with integer keys and arbitrary value types, supporting insertion, deletion, ordered traversal, and bulk updates via sequences. It includes operations for safe key handling (via `option` types), ordered transformations (like `map`, `filter`, and `fold`), and conversions between maps and sequences of key-value pairs. Designed for scenarios requiring efficient manipulation of structured data, such as graph algorithms that track relationships between integer-identified components.",
      "description_length": 525,
      "index": 30,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fungi.Graph.Graph-Path-Compute-PathHeap",
      "library": "fungi",
      "description": "This module provides a priority heap structure for managing graph nodes during path computation, supporting operations like insertion, extraction, and dynamic priority updates based on path measures. It works with graph paths and nodes, using customizable comparison functions to maintain ordering, and is optimized for algorithms requiring efficient node selection in shortest-path or heuristic-driven searches.",
      "description_length": 412,
      "index": 31,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fungi.Graph.PathImpl-NodeMap",
      "library": "fungi",
      "description": "This module supports associative maps with ordered keys, offering creation, modification, and querying operations like merging, ordered traversal, and sequence-based construction. It works with maps from ordered keys to arbitrary values or lists, enabling efficient insertion, deletion, and traversal while supporting transformations and filters over key ranges. Typical use cases include managing graph node mappings, accumulating values into lists, and converting between sequence-driven data representations.",
      "description_length": 511,
      "index": 32,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fungi.Graph.Graph-Serialize-StyleTbl",
      "library": "fungi",
      "description": "This module provides imperative hash table operations for string-keyed mappings, supporting standard manipulations like insertion, deletion, iteration, and advanced transformations such as in-place filtering, folding, and sequence conversion. It operates on `StyleTbl.t` hashtables and sequences of key-value pairs, enabling efficient bulk updates via `add_seq`/`replace_seq` and table construction from sequences with `of_seq`. Typical applications include batch processing of dynamic datasets and bidirectional conversion between associative structures and sequential representations for further processing.",
      "description_length": 609,
      "index": 33,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fungi.Graph.Graph-Serialize-AttrbTbl",
      "library": "fungi",
      "description": "This module offers hash table operations for managing attribute tables with string keys mapping to arbitrary values, supporting efficient insertion, lookup, iteration, and in-place modification. It handles batch conversions between attribute tables and sequences of key-value pairs, enabling bulk updates while preserving efficient access patterns. Designed for scenarios requiring dynamic attribute storage with statistical tracking, such as graph serialization workflows where structured metadata must be manipulated and queried programmatically.",
      "description_length": 548,
      "index": 34,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fungi.Graph.Graph-Scc",
      "library": "fungi",
      "description": "This module implements algorithms for finding strongly connected components (SCCs) in directed graphs. It provides two main functions\u2014`tarjan` and `kosaraju`\u2014which process adjacency maps representing graphs and return structured solutions containing SCCs, discovery times, and stack states. The module also includes utilities like `induced` to build subgraphs from SCC groupings, using custom map, set, and table structures optimized for SCC manipulation.",
      "description_length": 455,
      "index": 35,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fungi.Graph.Plain",
      "library": "fungi",
      "description": "This module represents a graph structure where edges are unit values, simplifying edge handling by treating connections as unweighted. It provides a total ordering function for comparing nodes and is built over a parameter module T, which defines the node type. It is useful for modeling unweighted directed or undirected graphs where edge metadata is unnecessary.",
      "description_length": 364,
      "index": 36,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fungi.Graph.PathImpl-Compute-PathHeap",
      "library": "fungi",
      "description": "This module implements a priority queue for managing graph paths with dynamic prioritization based on a `measure` type, where each heap element encapsulates path nodes, churn tracking, and successor relationships. It supports efficient insertion, extraction, and merging of paths, along with deduplication, custom comparison, and iterative path refinement, enabling use cases like shortest-path algorithms or heuristic search where paths must be dynamically reordered or combined. The structure\u2019s focus on measure-driven ordering and its ability to handle nested path dependencies make it suitable for scenarios requiring adaptive path computation with complex cost metrics.",
      "description_length": 674,
      "index": 37,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fungi.Graph.SccImpl-SccMap",
      "library": "fungi",
      "description": "This implementation provides a functional map structure for managing associations between integer keys (representing SCC identifiers) and arbitrary values, supporting ordered traversal, bulk updates from sequences, and operations like union, filtering, and bidirectional iteration. It emphasizes graph-specific utility through functions for merging component metadata, selecting extremal bindings, and converting between ordered collections, enabling efficient processing of SCCs in algorithms requiring dependency resolution or hierarchical analysis. The immutable interface and sequence-based transformations make it suitable for scenarios like topological sorting, component-based graph partitioning, or incremental graph updates where ordered access and structural sharing are critical.",
      "description_length": 790,
      "index": 38,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fungi.Graph.Measurable",
      "library": "fungi",
      "description": "This module defines arithmetic operations and comparisons for a measurable type `t`, including addition, subtraction, minimum, maximum, and negation. It also provides a way to extract a measure from an `edge` type, wrapped in a logical axiom context. Concrete use cases include implementing pathfinding algorithms like Dijkstra's or flow algorithms such as Ford-Fulkerson, where edge weights must be numerically compared and combined.",
      "description_length": 434,
      "index": 39,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fungi.Unionfind.MakeDisjointSet",
      "library": "fungi",
      "description": "This module combines a bijection table with an array-based union-find structure to manage equivalence classes efficiently, using path compression and union by size for optimal performance. It provides imperative operations for merging sets, finding canonical representatives, and bulk-updating mappings from sequences, enabling efficient handling of dynamic connected components. The bijection supports bidirectional lookups between arbitrary elements and integer keys, while the integer-keyed hash table allows fast access and modification of associated values. Example use cases include Kruskal\u2019s algorithm for minimum spanning trees and dynamic graph connectivity tracking with batch updates.",
      "description_length": 695,
      "index": 40,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fungi.Graph.Graph-Serialize",
      "library": "fungi",
      "description": "This module serializes graph structures into formats like CSV and DOT. It handles adjacency maps, attribute tables, and cluster mappings to represent graph nodes, edges, and styling. It is used to export graphs for visualization tools or data interchange.",
      "description_length": 255,
      "index": 41,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fungi.Graph.Graph-NodeMap",
      "library": "fungi",
      "description": "This module supports insertion, deletion, and merging of node entries within maps that associate graph nodes with adjacency sets and vertex metadata, offering both functional and imperative updates. It provides ordered traversal, filtering, and conversion to or from sequences, enabling efficient iteration and bulk manipulation of node relationships. These operations are particularly useful for graph algorithms requiring dynamic updates to adjacency structures or ordered exploration of node connections.",
      "description_length": 507,
      "index": 42,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fungi.Axiom.Space",
      "library": "fungi",
      "description": "This module defines a numeric abstraction with operations for comparison, addition, subtraction, and sign manipulation. It supports custom numeric types used in pathfinding and flow algorithms, such as weights or capacities on graph edges. Concrete use cases include implementing Dijkstra's algorithm with float weights or max-flow with integer capacities.",
      "description_length": 356,
      "index": 43,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fungi.Graph.Graph-Vertex",
      "library": "fungi",
      "description": "This module manages vertex adjacency information in a graph, providing operations to create and manipulate edges with weights. It works with vertices of type `elt`, adjacency maps (`adj NodeMap.t`), and edge weights (`edge Weights.t`). Concrete use cases include building weighted graph structures, querying and updating edge relationships, and maintaining adjacency lists with precise weight tracking.",
      "description_length": 402,
      "index": 44,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fungi.Graph.Biject",
      "library": "fungi",
      "description": "This module defines a set of arithmetic and comparison operations over a type `t`, including addition, subtraction, negation, and minimum/maximum functions, along with a `measure` function that wraps an edge value in a `Fungi.Axiom` structure. It is designed to work with numeric or ordered types that support these algebraic operations. A concrete use case is implementing graph algorithms like Dijkstra's shortest path, where edge weights require arithmetic manipulation and ordering.",
      "description_length": 486,
      "index": 45,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fungi.Graph.SccImpl",
      "library": "fungi",
      "description": "This module implements algorithms for identifying strongly connected components (SCCs) in directed graphs using Tarjan's and Kosaraju's algorithms. It operates on graph representations with nodes of type `elt` and adjacency lists of type `adj`, organizing intermediate and final results using structures like `sccnode`, `solution`, and `sccedge`. Concrete use cases include analyzing dependency graphs to detect cycles or partitioning a graph into its SCCs for further processing, such as topological sorting or component-based analysis.",
      "description_length": 537,
      "index": 46,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fungi.Graph.MakeGraph",
      "library": "fungi",
      "description": "This module builds and analyzes graphs using adjacency maps and unique node identifiers, supporting directed and undirected graphs with weighted edges. It provides core operations for graph construction, mutation, and traversal, along with algorithms for pathfinding, flow computation, and component analysis through specialized submodules. You can compute shortest paths with Dijkstra's algorithm, find maximum flow in a network, or detect strongly connected components in a directed graph. Submodules handle edge set operations, weighted adjacency maps, and graph serialization to formats like DOT and CSV for visualization and data exchange.",
      "description_length": 644,
      "index": 47,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fungi.Graph.Graph-EdgeSet",
      "library": "fungi",
      "description": "This structure provides ordered edge set operations for managing graph edges represented as pairs of elements, supporting standard set manipulations like union, filtering, and subset checks alongside traversal orderings (preorder, inorder, postorder). It works with edge sets where each edge is a tuple of a generic type, enabling use cases like graph traversal algorithms requiring ordered processing, edge inversion, or efficient membership queries. Specific utilities for extracting min/max edges and predicate-based searches make it suitable for dynamic graph analysis tasks where edge relationships must be iteratively refined or inspected.",
      "description_length": 645,
      "index": 48,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fungi.Graph.Graph-Cluster",
      "library": "fungi",
      "description": "Implements the Bron\u2013Kerbosch algorithm for finding all maximal cliques in an undirected graph represented as an adjacency list. The functions take a graph structure where nodes map to sets of adjacent nodes and return a list of cliques, each being a set of elements forming a complete subgraph. Useful for social network analysis, bioinformatics, and community detection in graphs.",
      "description_length": 381,
      "index": 49,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fungi.Graph.Graph-Matching",
      "library": "fungi",
      "description": "Implements graph matching algorithms including Hall's condition check for bipartite graphs. Works with node maps and adjacency sets to determine matchability. Used for solving assignment problems like pairing students to projects or workers to tasks.",
      "description_length": 250,
      "index": 50,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fungi.Graph.Graph",
      "library": "fungi",
      "description": "This module provides operations for constructing, analyzing, and transforming graphs represented as adjacency maps paired with edge/node types and weight mappings. It supports directed and undirected graphs through node/edge manipulation (insertion, pruning), structural analysis (Eulerian path detection, acyclicity checks), traversal algorithms (BFS/DFS), and matrix serialization (adjacency, incidence matrices). Key use cases include topological sorting, graph pruning, flow analysis, and converting graphs to algebraic representations for numerical processing.",
      "description_length": 565,
      "index": 51,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fungi.Unionfind.UnionFind",
      "library": "fungi",
      "description": "Implements a mutable Disjoint Set (Union-Find) structure with path compression and union by size. It uses a record containing an array for parent pointers, an array for set sizes, and a bijection table to map elements to indices. Efficiently supports dynamic connectivity queries and merging of sets, suitable for Kruskal's algorithm and percolation simulations.",
      "description_length": 362,
      "index": 52,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fungi.Treeset.TSet",
      "library": "fungi",
      "description": "This module implements a persistent set using a balanced binary search tree, supporting insertion, deletion, membership checks, ordered traversal (inorder, preorder, postorder), element selection (min,",
      "description_length": 201,
      "index": 53,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fungi.Graph.SerDe",
      "library": "fungi",
      "description": "This module provides functions to convert graph nodes and edges to and from string representations. It defines mappings for serializing and deserializing graph elements using `string_of_elt`, `string_of_wgt`, `elt_of_string`, and `wgt_of_string`. These operations support persisting graph data to text formats or parsing graphs from external inputs like configuration files or network streams.",
      "description_length": 393,
      "index": 54,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fungi.Graph.PathImpl-Compute",
      "library": "fungi",
      "description": "Implements pathfinding algorithms like Dijkstra, A*, Bellman-Ford, Johnson, and Floyd-Warshall for weighted graphs. Operates on adjacency maps with customizable measures for edge weights and paths. Used to compute shortest paths, detect negative cycles, and reweight graphs in routing or network analysis scenarios.",
      "description_length": 315,
      "index": 55,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fungi.Heap.MakeFibHeap",
      "library": "fungi",
      "description": "This module implements a priority queue structure using a list-based Fibonacci heap, supporting efficient insertion, deletion, and merging operations on node elements. It manages heap-ordered trees through `node` and `elts` records, enabling comparisons with customizable predicates and dynamic threshold adjustments for performance optimization. Typical applications include algorithmic scenarios like graph traversal or scheduling tasks where priority-based element retrieval and bulk updates are critical.",
      "description_length": 508,
      "index": 56,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fungi.Graph.Graph-Path",
      "library": "fungi",
      "description": "This module implements path-finding algorithms on graph structures, specifically providing Hierholzer's algorithm for Eulerian path detection and naive depth-first and breadth-first search strategies. It operates on node and edge data types structured through `NodeMap` and custom path elements that include optional edges. Concrete use cases include finding traversal paths in directed or undirected graphs, such as route planning or network analysis tasks where specific start or end conditions must be met.",
      "description_length": 509,
      "index": 57,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fungi.Graph.Graph-Span",
      "library": "fungi",
      "description": "Implements Kruskal's and Prim's algorithms for computing minimum spanning trees on graphs with weighted edges. Operates on adjacency maps (`adj NodeMap.t`) where nodes are mapped to their connected edges and associated measures. Useful for network design tasks like finding the lowest-cost path to connect all nodes in a weighted graph.",
      "description_length": 336,
      "index": 58,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fungi.Heap.Surject",
      "library": "fungi",
      "description": "This module implements a surjective heap structure based on an inner module's ordering. It provides `bind` to associate a heap element with an ordering value, and `compare` to order elements based on their bound orderings. It is used when elements must be prioritized according to an external key that may change independently of the element's identity.",
      "description_length": 353,
      "index": 59,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fungi.Graph.ClusterImpl",
      "library": "fungi",
      "description": "Implements algorithms for finding maximal cliques in graphs represented by adjacency maps. Uses `NodeMap` to map nodes to their adjacencies and `AdjSet` to represent sets of connected nodes. Designed for graph analysis tasks such as social network clustering or identifying tightly connected components in biological networks.",
      "description_length": 326,
      "index": 60,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fungi.Graph.Graph-Path-Compute-PathList",
      "library": "fungi",
      "description": "This module implements path list operations for graph traversal, focusing on ordered path management. It provides functions to bind paths to an ordering measure, compare paths based on their order, and define a total ordering between path elements. Concrete use cases include routing algorithms and shortest path computations where paths must be prioritized or sorted based on a specific metric.",
      "description_length": 395,
      "index": 61,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fungi.Heap.FibHeap",
      "library": "fungi",
      "description": "This module implements a priority queue with efficient merging and key adjustments, supporting operations like insertion, extraction, and node-level updates (e.g., key modification). It operates on a list-based structure of heap nodes (`elts` records) with customizable comparison logic, enabling dynamic priority management. Commonly used for graph algorithms requiring frequent decrease-key operations, such as Dijkstra's shortest path or Prim's minimum spanning tree.",
      "description_length": 470,
      "index": 62,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fungi.Graph.Graph-Weights",
      "library": "fungi",
      "description": "This module provides creation, modification, querying, and iteration capabilities for a hash table\u2013backed adjacency list where vertices map to outgoing edges with generic weight values. It operates on weight maps that support bulk updates and sequence-based initialization, enabling efficient implementations of graph algorithms like shortest path computation and weighted traversal scenarios.",
      "description_length": 393,
      "index": 63,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fungi.Graph.SccImpl-NodeMap",
      "library": "fungi",
      "description": "This module provides a comprehensive set of ordered map operations, including key-based insertion, deletion, and lookup, along with ordered traversal and aggregation. It works with polymorphic maps (`'a NodeMap.t`) keyed by ordered `elt` values, supporting transformations like filtering, mapping, and folding over key ranges. Specific use cases include sequence-driven map construction, ordered key-value iteration, and conditional binding manipulation with optional results.",
      "description_length": 476,
      "index": 64,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fungi.Graph.SccImpl-SccSet",
      "library": "fungi",
      "description": "This module provides a suite of operations for managing collections of SCC nodes, including standard set manipulations (union, intersection, difference, filtering), traversal methods (iterative and recursive folds), and order-based",
      "description_length": 231,
      "index": 65,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fungi.Graph.ClusterImpl-NodeMap",
      "library": "fungi",
      "description": "This module provides map manipulation operations for key-value associations with ordered keys, supporting insertion, deletion, merging, and conditional updates while preserving ordering. It works with key-value maps where keys are ordered, enabling ordered traversal, range-based queries, and transformations like `fold`, `filter`, and `map`, alongside sequence-based construction and iteration. Specific use cases include ordered data aggregation, predicate-driven map refinement, and bidirectional conversion between maps and sequences for efficient processing pipelines.",
      "description_length": 573,
      "index": 66,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fungi.Graph.PathImpl-EdgeSet",
      "library": "fungi",
      "description": "This module implements operations for managing and traversing directed edge sets in a graph, using an `EdgeSet.set` structure that stores pairs of elements. It supports standard set operations like union, filtering, and subset checks, alongside ordered traversal strategies (preorder, inorder, postorder), edge inversion, and extremal element extraction (e.g., `take_min`, `take_max_opt`). These capabilities are particularly useful for pathfinding algorithms, graph transformations requiring edge reversal, and scenarios demanding precise control over edge sequences and",
      "description_length": 571,
      "index": 67,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fungi.Graph.SccImpl-AdjSet",
      "library": "fungi",
      "description": "This module offers set-theoretic operations (union, intersection, difference, filtering), traversal methods (in-order, pre-order, post-order), and utilities for element selection, inversion, and ordered sequence manipulation. It",
      "description_length": 228,
      "index": 68,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fungi.Graph.Graph-Path-Compute-PathSet",
      "library": "fungi",
      "description": "This module supports efficient set operations, traversals, and order-based extractions on path element sets, focusing on functional persistence. It works with `PathSet.set` structures\u2014ordered, immutable sets of `measure Path.pathelt` elements that represent path segments with quantifiable properties. Typical applications include graph algorithms requiring path computation, such as shortest path analysis, path enumeration, or priority-driven traversal strategies.",
      "description_length": 466,
      "index": 69,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fungi.Treeset.TreeSet",
      "library": "fungi",
      "description": "This module implements ordered sets using balanced binary trees, offering operations for element insertion, membership checks, traversal (inorder/preorder/postorder), and set-theoretic manipulations (union, intersection, difference). It works with elements ordered by a type-specific comparator (`Ord.t`), enabling efficient min/max extraction and ordered sequence conversions. Typical applications include maintaining sorted collections with dynamic updates, performing hierarchical data analysis, or implementing algorithms requiring logarithmic-time access to ordered elements.",
      "description_length": 580,
      "index": 70,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fungi.Graph.Graph-Span-EdgeDisj-BijectTbl",
      "library": "fungi",
      "description": "This module implements bijective hash tables mapping `EdgeDisj.elt` keys to arbitrary values, supporting standard operations like insertion, deletion, lookup, iteration, folding, and in-place modification, alongside statistical inspection for performance analysis. It enables bulk data manipulation through sequence-driven functions such as `add_seq`, `replace_seq`, and `of_seq`, which efficiently process batches of key-value pairs to update or construct tables. These capabilities are particularly suited for scenarios requiring strict key-value uniqueness, such as managing graph edge attributes or identifier mappings in algorithms demanding injective relationships and high-performance batch updates.",
      "description_length": 706,
      "index": 71,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fungi.Graph.Graph-Span-EdgeDisj-ResolvTbl",
      "library": "fungi",
      "description": "This module provides functions for managing key-value pairs with integer keys, including insertion, lookup, deletion, iteration, folding, and in-place transformations. It operates on mutable hash tables storing integer keys and generic values, enabling bulk operations like constructing tables from sequences or updating multiple entries. These capabilities are particularly useful for dynamic data aggregation or batch processing of key-value streams where efficient, sequence-driven modifications are required.",
      "description_length": 512,
      "index": 72,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fungi.Graph.PathImpl",
      "library": "fungi",
      "description": "Implements path-finding algorithms on graph structures using nodes and edges. It supports operations like constructing paths with `mkpath`, finding Eulerian paths with `hierholzer`, and performing depth-first and breadth-first searches with `naivedfs` and `naivebfs`. Designed for directed or undirected graphs where adjacency and edge weights are mapped per node.",
      "description_length": 364,
      "index": 73,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fungi.Graph.VertexImpl-NodeMap",
      "library": "fungi",
      "description": "This module implements map operations for graph nodes (represented by `'elt` keys) and arbitrary values, emphasizing ordered, immutable structures through functions like insertion, deletion, merging, and querying with strict key ordering. It supports functional transformations, ordered traversals, and bulk manipulation via sequences, making it suitable for scenarios requiring precise node key management, such as graph algorithms or dataflow analyses where immutability and ordered iteration are critical.",
      "description_length": 508,
      "index": 74,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fungi.Graph.Graph-Span-EdgeDisj",
      "library": "fungi",
      "description": "This module implements a disjoint-set data structure with path compression and union by size, managing elements through bijective and resolution tables. It supports operations to create a set from a sequence, find the representative of an element, and merge two sets. Concrete use cases include efficiently managing connected components in graph algorithms, such as Kruskal's minimum spanning tree.",
      "description_length": 398,
      "index": 75,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fungi.Graph.ClusterImpl-AdjSet",
      "library": "fungi",
      "description": "This module provides set-theoretic operations (union, intersection, difference) and structural manipulations (inversion, root extraction) on adjacency sets representing rooted, ordered trees or graphs. It supports generic element types organized in hierarchical structures, enabling efficient traversal (pre-order, post-order), transformation (filtering, mapping), and queries (subset checks, existence tests). These capabilities are particularly useful for graph clustering algorithms requiring dynamic maintenance of adjacency relationships and hierarchical decompositions.",
      "description_length": 575,
      "index": 76,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fungi.Graph.Graph-Serialize-ClstrTbl",
      "library": "fungi",
      "description": "This implementation provides a hash table structure (`ClstrTbl.t`) mapping integers to arbitrary values, supporting imperative modifications like insertion, replacement, and filtering, alongside iterative transformations and statistics tracking. It emphasizes sequence-driven workflows through bulk operations that construct or update tables from key-value sequences, enabling efficient data aggregation and batch processing. Typical applications include building lookup tables from streamed data, managing dynamic clusters with atomic updates, and analyzing large-scale graph components.",
      "description_length": 588,
      "index": 77,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fungi.Graph.Graph-Scc-SccSet",
      "library": "fungi",
      "description": "This module offers a functional set interface for managing collections of strongly connected component (SCC) nodes in graph algorithms, supporting standard set operations like union, intersection, and filtering alongside ordered traversals (preorder, postorder) and extremal element extraction. It operates on sets of SCC nodes, enabling efficient manipulation through sequence conversions, predicate-based queries, and structural transformations like inversion or root selection. Typical applications include dependency analysis, cycle detection, and iterative graph processing where component-level relationships or hierarchical traversal orders are critical.",
      "description_length": 661,
      "index": 78,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fungi.Graph.Graph-Path-Compute",
      "library": "fungi",
      "description": "This module implements pathfinding algorithms on graphs with weighted edges, using measures to represent costs. It provides functions for Dijkstra's algorithm, A* search, Bellman-Ford, Johnson's algorithm, and Floyd-Warshall, returning shortest paths or detecting negative cycles. These operations work on adjacency maps and path structures, supporting concrete tasks like route planning or network analysis.",
      "description_length": 408,
      "index": 79,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fungi.Graph.Graph-Scc-SccTbl",
      "library": "fungi",
      "description": "This module provides hash table operations for mappings between strongly connected component (SCC) nodes and arbitrary values, including creation, modification, iteration, folding, filtering, and statistical analysis. It supports bidirectional conversion with sequences of SCC node-value pairs, enabling bulk initialization (`of_seq`) and incremental updates (`replace_seq`) for efficient table management. These capabilities are particularly useful in graph analysis tasks like tracking SCC-specific metadata, aggregating component properties, or maintaining dynamic mappings during iterative graph transformations.",
      "description_length": 616,
      "index": 80,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fungi.Graph.VertexImpl",
      "library": "fungi",
      "description": "This module defines the structure and operations for representing vertices in a graph, including managing adjacency lists, edges, and weights. It works with abstract types for elements (`elt`), adjacency entries (`adj`), edges (`edge`), and weight values (`weights`), along with a map module (`NodeMap`) for associating vertices with adjacency lists. Concrete use cases include building and modifying graph nodes with weighted edges, querying adjacency information, and ensuring consistent edge representations in graph algorithms.",
      "description_length": 531,
      "index": 81,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fungi.Graph.Graph-Matching-Compute",
      "library": "fungi",
      "description": "Implements the Gale-Shapley algorithm for bipartite graph matching. Takes an adjacency list of preferences and two disjoint sets of nodes, returning a stable set of edges between them. Useful for solving assignment problems like matching students to schools or residents to hospitals based on ranked preferences.",
      "description_length": 312,
      "index": 82,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fungi.Graph.SccImpl-SccTbl",
      "library": "fungi",
      "description": "This module implements imperative hash table operations for mapping `sccnode` identifiers to arbitrary values, supporting insertion, lookup, deletion, iteration, folding, and bulk updates via sequences. It provides a mutable table structure (`SccTbl.t`) optimized for handling dynamic associations between SCC nodes and their associated data. Typical applications include tracking component metadata during graph traversals or aggregating results from SCC-based analyses, such as dependency resolution or cycle detection in directed graphs.",
      "description_length": 540,
      "index": 83,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fungi.Graph.PathImpl-Compute-PathList",
      "library": "fungi",
      "description": "This module implements path list computations for graph traversal, handling paths represented as lists of elements with associated measures. It provides operations to bind path lists to an ordering, compare paths based on their measures, and define a total order between path elements. Concrete use cases include finding shortest paths in weighted graphs and managing ordered traversal sequences in graph algorithms.",
      "description_length": 416,
      "index": 84,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fungi.Graph.GraphElt",
      "library": "fungi",
      "description": "This module defines the core types for graph nodes and edges, providing a total ordering function for node comparison. It works with structured data types representing graph elements, enabling precise node identity and ordering. Concrete use cases include building and manipulating graph structures where node equality and ordering are critical, such as in graph algorithms like topological sorting or shortest path computation.",
      "description_length": 428,
      "index": 85,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fungi.Graph.Graph-Flow-Flowtbl",
      "library": "fungi",
      "description": "This module implements a specialized hash table for managing flow data between graph nodes, using node pairs as keys to represent directed flow relationships. It supports efficient bulk updates and initialization through sequence-based operations, enabling use cases like residual capacity tracking in flow networks or dynamic pathfinding algorithms where batch processing of flow adjustments is required. The design emphasizes in-place transformations and traversal flexibility for optimizing graph analysis workflows.",
      "description_length": 519,
      "index": 86,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fungi.Graph.PathImpl-AdjSet",
      "library": "fungi",
      "description": "This implementation provides set operations, traversal functions, and path-specific utilities like inversion and extremum extraction for managing adjacency sets in graph algorithms. It operates on adjacency sets containing elements of type `elt`, structured as `AdjSet.set`, to enable efficient path tracking and adjacency list manipulation. These tools are particularly suited for pathfinding scenarios requiring dynamic set modifications, ordered traversal, or tracking visited nodes in directed/undirected graphs.",
      "description_length": 516,
      "index": 87,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fungi.Graph.Graph-Flow",
      "library": "fungi",
      "description": "Implements Ford-Fulkerson and Edmonds-Karp algorithms for computing maximum flow in directed graphs with weighted edges. Uses a mutable state record to track flow values and a Flowtbl module to manage edge capacities and residual networks. Designed for network flow problems such as optimizing transportation routes or data flow in communication networks.",
      "description_length": 355,
      "index": 88,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fungi.Heap.Ordinal",
      "library": "fungi",
      "description": "Implements a priority queue with a custom ordering, allowing elements to be inserted and removed based on priority. It supports operations to bind a priority to an element, compare elements, and define a total ordering for priorities. Useful for scheduling tasks where elements must be processed in a specific priority-defined sequence.",
      "description_length": 336,
      "index": 89,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fungi.Unionfind",
      "library": "fungi",
      "description": "This module implements a disjoint-set data structure with path compression and union by rank or size, supporting efficient dynamic connectivity queries and set merging operations. It works with elements that can be mapped to integers, using either direct integer keys or a bijection table to manage arbitrary elements and their associated integer identifiers. The structure includes imperative operations for finding canonical representatives, merging sets, and bulk-updating mappings from sequences, making it suitable for applications like Kruskal\u2019s algorithm, percolation simulations, and dynamic graph connectivity tracking. Associated submodules enhance the core functionality with optimized equivalence class management, bidirectional lookups, and hash table-backed value storage for fast access.",
      "description_length": 802,
      "index": 90,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fungi.Treeset",
      "library": "fungi",
      "description": "This module implements a set data structure based on balanced binary trees, supporting insertion, deletion, membership testing, and ordered traversal. It uses a comparator to maintain order and balance, enabling efficient operations on integers, strings, or custom types. The module allows for set-theoretic operations such as union, intersection, and difference, and supports element selection like min and max extraction. It is suitable for applications requiring sorted collections with dynamic updates and logarithmic-time access.",
      "description_length": 534,
      "index": 91,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fungi.Heap",
      "library": "fungi",
      "description": "This module implements a priority queue with decrease-key support using a Fibonacci heap structure, working with ordered elements and indexed keys for efficient updates. It provides core operations like insertion, extraction, and key modification on `elts` records, supporting customizable comparison predicates and dynamic priority adjustments. Child modules extend this functionality with surjective heaps that bind elements to external keys, merged heaps for efficient combination of structures, and ordered queues for strict priority sequencing. Examples include optimizing Dijkstra's algorithm with dynamic edge weights, managing task schedules with changing priorities, and efficiently merging multiple heaps in graph traversal scenarios.",
      "description_length": 744,
      "index": 92,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fungi.Graph",
      "library": "fungi",
      "description": "This module provides a comprehensive graph library centered on adjacency list representation with optional edge weights, supporting both directed and undirected graphs. It enables core operations such as vertex and edge manipulation, strongly connected component detection via Tarjan's and Kosaraju's algorithms, and shortest path computation using Dijkstra's and other algorithms, all backed by efficient data structures like priority heaps, ordered maps, and hash tables. Submodules enhance functionality with specialized tools for traversal (preorder, inorder, postorder), dynamic path management, weighted edge handling, and graph serialization to formats like DOT and CSV, enabling concrete applications in network analysis, dependency resolution, and flow optimization. Users can model complex relationships, perform SCC-based partitioning, compute minimum spanning trees, and serialize graph data for visualization or external processing.",
      "description_length": 945,
      "index": 93,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fungi.Axiom",
      "library": "fungi",
      "description": "This module provides a polymorphic `wrap` type for representing values that may be numeric, infinite, undefined, or dynamically typed, enabling safe comparisons, transformations, and combinations using custom logic. It supports operations like `min`, `max`, and function application over wrapped values, while its child module introduces a numeric abstraction for arithmetic operations and sign manipulation tailored to graph algorithms. You can use it to implement Dijkstra's algorithm with float weights, max-flow with integers, or handle missing data in dynamic computations. The combination of core wrapping logic and numeric specialization allows robust handling of edge cases across different computational domains.",
      "description_length": 721,
      "index": 94,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fungi",
      "library": "fungi",
      "description": "This collection implements foundational data structures for managing dynamic connectivity, ordered collections, priority-based access, graph relationships, and flexible value representations. Key types include disjoint-sets for equivalence tracking, balanced sets for ordered elements, Fibonacci heaps for priority queues with key updates, adjacency-list graphs with traversal and pathfinding algorithms, and polymorphic wrappers for numeric and undefined values. Operations span union-find queries, set-theoretic manipulations, Dijkstra-optimized priority extraction, SCC detection, and safe value comparisons. Examples include Kruskal\u2019s MST construction, dynamic graph updates, task scheduling with changing priorities, flow network analysis, and handling missing or infinite values in algorithmic contexts.",
      "description_length": 809,
      "index": 95,
      "embedding_norm": 0.9999999403953552
    }
  ],
  "filtering": {
    "total_modules_in_package": 99,
    "meaningful_modules": 96,
    "filtered_empty_modules": 3,
    "retention_rate": 0.9696969696969697
  },
  "statistics": {
    "max_description_length": 945,
    "min_description_length": 201,
    "avg_description_length": 522.5625,
    "embedding_file_size_mb": 0.34917545318603516
  }
}