{
  "package": "fungi",
  "embedding_model": "Qwen/Qwen3-Embedding-8B",
  "embedding_dimension": 4096,
  "total_modules": 41,
  "creation_timestamp": "2025-08-15T16:20:03.404750",
  "modules": [
    {
      "module_path": "Fungi.Graph.MakeGraph.Span.EdgeDisj.BijectTbl",
      "library": "fungi",
      "description": "This module implements a bijective hash table for mapping edges in a disjoint set structure (`EdgeDisj.elt`) to arbitrary values, supporting dictionary operations like insertion, lookup, and iteration alongside functional transformations such as `fold`, `filter_map_inplace`, and sequence-driven bulk updates. It specializes in batch processing via sequence-based initialization and modification, enabling efficient handling of edge-centric data during graph algorithms. This is particularly useful in minimum spanning tree computations, where edges must be dynamically tracked and grouped in disjoint sets for Kruskal\u2019s algorithm.",
      "description_length": 631,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fungi.Graph.MakeGraph.Span.EdgeDisj.ResolvTbl",
      "library": "fungi",
      "description": "This module provides hash table operations for managing dynamic key-value mappings with integer keys and polymorphic values, optimized for Kruskal's algorithm in graph processing. It supports bulk updates via sequences of bindings, enabling efficient construction, modification, and iteration over tables that track critical data like node parent pointers or edge weights during minimum spanning tree computation. The hash tables are specifically used to resolve disjoint sets in Kruskal's union-find operations, where sequences of edge-node relationships require high-throughput updates and lookups.",
      "description_length": 600,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fungi.Graph.MakeGraph.Path.Compute.PathSet",
      "library": "fungi",
      "description": "This module provides functions for managing collections of path elements in graph structures, supporting set operations like union, intersection, and filtering, as well as traversal (iter, fold, preorder/postorder processing) and path-specific queries (e.g., root extraction). It operates on sets of `Path.pathelt` values, which represent nodes or edges in graph paths, and supports conversions between sequences and lists. Typical use cases include path analysis in directed graphs, such as tracking reachable nodes, pruning paths during traversal, or extracting ordered sequences of elements for algorithmic processing.",
      "description_length": 621,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fungi.Graph.MakeGraph.Path.Compute.PathList",
      "library": "fungi",
      "description": "Computes and manages lists of paths in a graph, supporting operations to bind path orders, compare paths, and sort based on path measures. Works with graph structures where nodes and edges are parameterized, and paths are represented as sequences of nodes with associated weights. Used in routing algorithms and path analysis where multiple paths need to be evaluated and ranked.",
      "description_length": 379,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fungi.Graph.MakeGraph.Path.Compute.PathHeap",
      "library": "fungi",
      "description": "Implements a priority heap for managing weighted paths in graph traversal, supporting operations like insertion, deduplication, and predicate-driven extraction of path elements. It works with path nodes that include measures such as weights and maintain structural metadata, facilitating efficient pathfinding tasks like shortest path calculation. This structure is particularly useful in algorithms requiring dynamic priority queues with customizable ordering, such as Dijkstra's or A* search.",
      "description_length": 494,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fungi.Graph.MakeGraph.Scc.SccMap",
      "library": "fungi",
      "description": "This module provides ordered map operations for integer-keyed maps used in strongly connected component (SCC) analysis, supporting insertions, updates, and transformations with functions like `fold`, `map`, and `split`. It handles SCC-related data through sequence-based conversions, ordered queries (`find_last`, `mem`), and predicate-driven filtering, enabling efficient aggregation and iteration over component bindings. These structures are particularly useful in graph algorithms requiring component tracking, such as dependency resolution or hierarchical aggregation.",
      "description_length": 573,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fungi.Graph.MakeGraph.Scc.SccTbl",
      "library": "fungi",
      "description": "This module provides specialized hash table operations for managing mappings from strongly connected component (SCC) nodes to arbitrary values, supporting efficient creation, bulk updates, and traversal. It works with hash tables (`Scc.SccTbl.t`) that bind `sccnode` keys\u2014representing graph components\u2014to values of any type `'a`, enabling operations like sequence-based initialization and iterative value transformation. These tools are particularly useful in SCC-based graph algorithms, such as tracking component metadata, aggregating results across SCCs, or implementing fixed-point computations in dependency analysis.",
      "description_length": 622,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fungi.Graph.MakeGraph.Serialize.StyleTbl",
      "library": "fungi",
      "description": "This module provides imperative hash table operations for managing string-keyed mappings with arbitrary value types, supporting efficient insertion, lookup, and batch transformation of key-value pairs. It specializes in converting between hash tables and sequential representations, enabling use cases like serializing graph style attributes (e.g., node colors, edge labels) into structured formats during graph persistence workflows. The structure accommodates dynamic reconfiguration of style data through bulk updates or incremental modifications.",
      "description_length": 550,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fungi.Graph.MakeGraph.Serialize.ClstrTbl",
      "library": "fungi",
      "description": "This implementation provides imperative hash table operations for integer-keyed mappings, supporting bulk updates, iteration, and in-place transformations with statistics tracking. It works with cluster tables backed by sequences for batch construction/modification, and is used to manage node clusters during graph serialization workflows. Key use cases include efficient data aggregation for graph persistence and analysis through sequence conversions.",
      "description_length": 454,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fungi.Graph.MakeGraph.Scc.SccSet",
      "library": "fungi",
      "description": "The module provides operations for managing sets of strongly connected component nodes, including set operations like union, intersection, and filtering, extremal element selection (e.g., min/max extraction), and depth-first search traversal patterns (inorder, preorder, postorder). It operates on collections of `Scc.sccnode` values, enabling efficient membership checks, element queries, and set transformations. These capabilities are essential for graph algorithms analyzing component structures, such as cycle detection, topological sorting, and dependency management.",
      "description_length": 573,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fungi.Graph.MakeGraph.Span.EdgeDisj",
      "library": "fungi",
      "description": "This module implements a disjoint-set data structure with union-find operations for edges in a graph, optimized for Kruskal\u2019s algorithm. It uses bijective and resolution hash tables to manage edge-node mappings, supporting efficient `find` and `union` operations on sets of nodes represented as integers. It is used during minimum spanning tree computation to track connected components and prevent cycles when adding edges.",
      "description_length": 424,
      "index": 10,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fungi.Graph.MakeGraph.Path.Compute",
      "library": "fungi",
      "description": "Computes and manages paths in graph structures using priority heaps, path lists, and sets to support advanced pathfinding algorithms. Implements Dijkstra's, A*, Bellman-Ford, Floyd-Warshall, and Johnson's algorithms for finding shortest paths with customizable measures such as edge weights. Used in routing, network analysis, and optimization tasks where paths must be ranked, filtered, or dynamically updated.",
      "description_length": 411,
      "index": 11,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fungi.Graph.MakeGraph.Serialize.AttrbTbl",
      "library": "fungi",
      "description": "This module provides hash table-based operations for managing attributes associated with graph nodes or edges, supporting key-value pairs where keys are strings and values are arbitrary types. It includes functionality for batch updates from sequences, efficient lookups, and serialization, enabling use cases like storing metadata (e.g., node labels, edge weights) and exporting graph attributes to external formats. The structure is optimized for integrating attribute management with graph serialization workflows.",
      "description_length": 517,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fungi.Graph.MakeGraph.Matching.Compute",
      "library": "fungi",
      "description": "Implements the Gale-Shapley algorithm for bipartite graph matching. Takes an adjacency map, two disjoint sets of nodes, and returns a stable set of edges representing matched pairs. Useful for solving assignment problems like matching students to schools or employees to teams based on preference rankings.",
      "description_length": 306,
      "index": 13,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fungi.Graph.MakeGraph.Flow.Flowtbl",
      "library": "fungi",
      "description": "This component provides a mutable table structure for tracking flow values on directed edges, with imperative operations to modify and transform entries using unique identifier pairs as keys. It centers on efficient flow management for graph algorithms, supporting bulk updates from sequences of edge-value pairs and in-place adjustments critical for dynamic flow optimization tasks like network flow computations. The design emphasizes performance-sensitive scenarios where rapid traversal and modification of edge-associated numeric values (e.g., residual capacities) are required.",
      "description_length": 583,
      "index": 14,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fungi.Graph.MakeGraph.EdgeSet",
      "library": "fungi",
      "description": "This module provides a suite of set-based operations for managing edges represented as pairs of unique identifiers, including structural manipulations like union, filtering, and inversion, as well as ordered traversal capabilities. It employs a set structure to efficiently handle edge collections in graph algorithms that require dynamic edge processing, such as iterative traversal, subset selection, or edge reversal tasks. Specific use cases include graph analysis algorithms needing efficient edge set modifications and ordered exploration, such as pathfinding or connectivity analysis.",
      "description_length": 591,
      "index": 15,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fungi.Graph.MakeGraph.Cluster",
      "library": "fungi",
      "description": "Implements algorithms for detecting cliques in undirected graphs using the Bron\u2013Kerbosch method. It operates on adjacency maps where nodes are uniquely identified and edges are represented as sets. This module is useful for analyzing social networks or biological interaction graphs to find fully connected subgraphs.",
      "description_length": 317,
      "index": 16,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fungi.Graph.MakeGraph.Span",
      "library": "fungi",
      "description": "This module implements minimum spanning tree algorithms\u2014Kruskal and Prim\u2014operating on graphs with weighted edges. It uses a disjoint-set data structure to efficiently manage connected components during Kruskal\u2019s algorithm and computes minimal spanning trees from a given start node or across disconnected components. Concrete use cases include network design optimization and clustering based on minimal total edge cost.",
      "description_length": 420,
      "index": 17,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fungi.Graph.MakeGraph.Path",
      "library": "fungi",
      "description": "Implements path construction and traversal strategies for graphs with weighted edges, including shortest path algorithms like Dijkstra's and A*. Supports operations to build paths between nodes, search using depth-first and breadth-first strategies, and find Eulerian trails. Used in network routing, path optimization, and graph analysis where specific traversal sequences or optimal routes are required.",
      "description_length": 405,
      "index": 18,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fungi.Graph.MakeGraph.Weights",
      "library": "fungi",
      "description": "This module provides hash table-based operations for managing vertex-to-edge-weight mappings, supporting insertion, deletion, lookup, and bulk transformations of weighted edges in a graph's adjacency list. It works with a hash table-like structure (`'a Weights.t`) that maps unique vertex identifiers (`Unique.t`) to edge weights of arbitrary type `'a`, and handles sequences of `(Unique.t * 'a)` pairs for constructing or updating weight mappings. It is particularly useful for implementing weighted graph algorithms (e.g., Dijkstra's shortest path, minimum spanning trees) where efficient traversal and dynamic updates of weighted adjacency lists are required.",
      "description_length": 662,
      "index": 19,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fungi.Graph.MakeGraph.Scc",
      "library": "fungi",
      "description": "This module implements algorithms for identifying strongly connected components (SCCs) in directed graphs using adjacency set representations. It provides functions like `tarjan` and `kosaraju` that take adjacency maps and return structured solutions containing SCCs, discovery times, and stacks. It works with custom data types such as `sccnode`, `solution`, and `sccedge`, enabling concrete use cases like dependency analysis, cycle detection, and component-based graph transformations.",
      "description_length": 488,
      "index": 20,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fungi.Graph.MakeGraph.Matching",
      "library": "fungi",
      "description": "Implements graph matching algorithms, including Hall's condition check for bipartite graphs and the Gale-Shapley algorithm for stable matching. Operates on adjacency maps and disjoint node sets, producing stable matchings as sets of edges. Directly supports use cases like assigning students to schools or employees to teams based on ranked preferences.",
      "description_length": 353,
      "index": 21,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fungi.Graph.MakeGraph.Vertex",
      "library": "fungi",
      "description": "This module manages vertex adjacency in a graph, providing operations to create, compare, and update edges with associated weights. It works with unique identifiers (`Unique.t`) for vertices and edges, using maps (`NodeMap.t`) to track adjacency relationships. Concrete use cases include constructing weighted edges between vertices, retrieving edge weights, and ensuring edges exist with specific properties.",
      "description_length": 409,
      "index": 22,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fungi.Graph.MakeGraph.NodeMap",
      "library": "fungi",
      "description": "This module provides map operations for managing associations between unique node identifiers (`Unique.t`) and arbitrary data, such as adjacency sets or vertex properties in graph",
      "description_length": 179,
      "index": 23,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fungi.Graph.MakeGraph.AdjSet",
      "library": "fungi",
      "description": "This module provides functions for modifying and querying adjacency sets of unique elements, including set operations, iterative traversal, and structural analysis. It works with directed graph edges represented as sets of unique identifiers, enabling tasks like neighbor management, path exploration, and graph inversion. Specific use cases include dynamic graph construction, cycle detection, and",
      "description_length": 398,
      "index": 24,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fungi.Graph.MakeGraph.Flow",
      "library": "fungi",
      "description": "Implements Ford-Fulkerson and Edmonds-Karp algorithms for computing maximum flow in directed graphs using mutable flow tables keyed by unique edge identifiers. Operates on graphs represented as adjacency maps with edge states containing flow values, and uses a measure type to quantify flow capacity. Designed for network flow optimization tasks such as bandwidth allocation or resource distribution where residual capacities must be dynamically adjusted during path augmentation.",
      "description_length": 480,
      "index": 25,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fungi.Unionfind.MakeDisjointSet.ResolvTbl",
      "library": "fungi",
      "description": "This module provides imperative hash table operations for managing mappings from integer keys to generic values, supporting bulk updates via sequences and in-place transformations. It includes utilities for iterating, filtering, and aggregating key-value pairs, along with statistical tracking and efficient batch construction from sequential data. The structure is optimized for scenarios requiring dynamic key-value management with high-throughput sequence processing, such as incremental table population or parallel data reconciliation tasks.",
      "description_length": 546,
      "index": 26,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fungi.Graph.MakeGraph.Serialize",
      "library": "fungi",
      "description": "This module serializes graphs into structured text formats like CSV and DOT, handling node attributes, edge properties, and cluster metadata. It operates on adjacency maps, attribute hash tables, and cluster mappings to persist graph structure and styling. Concrete use cases include exporting dependency graphs to DOT for visualization or saving weighted node relationships in CSV for external analysis.",
      "description_length": 404,
      "index": 27,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fungi.Heap.Surject",
      "library": "fungi",
      "description": "This module implements a surjective heap structure based on an inner module's ordering. It provides `bind` to associate a value with an ordering key, and `compare` to order values based on their bound keys, using the `order` function from the inner module. It is useful for priority queues where elements are compared indirectly through mapped keys.",
      "description_length": 349,
      "index": 28,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fungi.Heap.MakeFibHeap",
      "library": "fungi",
      "description": "This module implements a priority queue structure with efficient merging, insertion, and extremal element extraction, supporting dynamic reordering through customizable comparison logic. It operates on heap-organized nodes with metadata tracking size, node relationships, and structural transformations, enabling algorithms requiring frequent key updates or heap consolidation. Applications include graph traversal optimizations, task scheduling with priority adjustments, and scenarios demanding amortized O(1) time complexity for insertions and merges alongside O(log n) deletions.",
      "description_length": 583,
      "index": 29,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fungi.Unionfind.MakeDisjointSet",
      "library": "fungi",
      "description": "This module implements a disjoint-set data structure with path compression and union by size, using a combination of hash tables and arrays for efficient element management. It supports dynamic set creation from sequences, root finding with path compression, and merging sets with size-based balancing. Concrete use cases include incremental clustering of elements, connected component tracking in graphs, and equivalence class management during symbolic computation or constraint solving.",
      "description_length": 489,
      "index": 30,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fungi.Graph.Biject",
      "library": "fungi",
      "description": "This module defines a set of arithmetic and comparison operations for a type `t`, including addition, subtraction, negation, and minimum/maximum selection. It works with a single type `t` that supports a total ordering and numeric-like behavior, along with an `edge` type used to represent graph edges with an associated `measure` function. Concrete use cases include implementing graph algorithms like Dijkstra's shortest path, where edge weights require arithmetic manipulation and comparison.",
      "description_length": 495,
      "index": 31,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fungi.Graph.MakeGraph",
      "library": "fungi",
      "description": "This module provides operations for constructing and manipulating directed graphs with weighted edges, supporting mutations like adding nodes and edges, querying adjacency and weights, and analyzing properties such as cycles, connectivity, and Eulerian paths. It uses adjacency sets implemented via maps (`NodeMap.t`) where nodes are uniquely identified and edges store weights, with internal structures leveraging hash tables and sets for efficient traversal and modification. Typical applications include network modeling, dependency resolution, flow analysis, and algorithmic tasks like shortest path computation or topological sorting in directed graphs.",
      "description_length": 658,
      "index": 32,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fungi.Graph.Plain",
      "library": "fungi",
      "description": "This module represents a graph structure where edges are unit values, simplifying edge handling by treating connections as unweighted. It supports operations requiring a total ordering on elements, using a provided comparison function. Concrete use cases include modeling unweighted directed or undirected graphs where edge metadata is unnecessary.",
      "description_length": 348,
      "index": 33,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fungi.Treeset.TreeSet",
      "library": "fungi",
      "description": "This module implements a functional binary search tree structure for managing ordered element sets, enabling efficient insertion, deletion, and membership checks while preserving element ordering via the `Ord` module. It supports set-theoretic operations (union, intersection, difference), order-preserving traversals (inorder, preorder, postorder), and element transformations through mapping and filtering. Designed for use cases requiring sorted collection management, such as range queries, extremal element retrieval (e.g., min/max), and iterative processing with guaranteed order semantics.",
      "description_length": 596,
      "index": 34,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fungi.Unionfind",
      "library": "fungi",
      "description": "This module implements a disjoint-set data structure with path compression and union by size. It uses hash tables and arrays to efficiently manage dynamic sets of arbitrary elements, supporting operations to find set roots and merge sets. It is suitable for incremental clustering, tracking connected components in graphs, and managing equivalence classes during symbolic computation.",
      "description_length": 384,
      "index": 35,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fungi.Axiom",
      "library": "fungi",
      "description": "This module defines operations for comparing, transforming, and combining wrapped numeric or symbolic values that may represent extremes like infinity or undefined. It works with a polymorphic `wrap` type that can hold values of different types, including special markers for infinity and NaN. Functions like `wcompare`, `wmin`, and `wmax` enable precise comparisons and arithmetic manipulations in contexts such as pathfinding algorithms where values are dynamically resolved.",
      "description_length": 477,
      "index": 36,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fungi.Treeset",
      "library": "fungi",
      "description": "This module implements a functional binary search tree for managing ordered sets of elements, providing efficient insertion, deletion, and membership checks. It supports set operations like union, intersection, and difference, along with ordered traversals (inorder, preorder, postorder) and element transformations via mapping and filtering. It is ideal for applications requiring sorted collections, such as range queries, min/max retrieval, and ordered iteration.",
      "description_length": 466,
      "index": 37,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fungi.Graph",
      "library": "fungi",
      "description": "This module implements directed and undirected graphs using adjacency lists, supporting operations to add nodes and edges, query adjacency, and analyze graph properties like cycles and connectivity. It works with weighted edges using hash tables and maps for efficient traversal, suitable for network modeling, dependency resolution, and algorithmic tasks such as topological sorting or shortest path computation. Specific use cases include representing road networks with weighted edges for route planning and managing task dependencies in build systems.",
      "description_length": 555,
      "index": 38,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fungi.Heap",
      "library": "fungi",
      "description": "Implements a priority queue with efficient merging, insertion, and extremal element extraction, supporting dynamic key updates and customizable comparison logic. Operates on heap-organized nodes with tracked size and structural metadata, enabling amortized O(1) insertions and merges, O(log n) deletions. Used for graph algorithms, task scheduling with priority adjustments, and scenarios requiring frequent key updates or heap consolidation.",
      "description_length": 442,
      "index": 39,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fungi",
      "library": "fungi",
      "description": "This module provides precise comparison and transformation operations for symbolic and numeric values, including infinities and NaNs, using a polymorphic `wrap` type. It supports graph construction and analysis with weighted adjacency lists, priority queues with dynamic key updates, ordered set management via balanced trees, and efficient disjoint-set operations with path compression. Concrete applications include pathfinding algorithms, network modeling, task scheduling, symbolic computation, and incremental clustering.",
      "description_length": 526,
      "index": 40,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 42,
    "meaningful_modules": 41,
    "filtered_empty_modules": 1,
    "retention_rate": 0.9761904761904762
  },
  "statistics": {
    "max_description_length": 662,
    "min_description_length": 179,
    "avg_description_length": 481.9024390243902,
    "embedding_file_size_mb": 0.5945653915405273
  }
}