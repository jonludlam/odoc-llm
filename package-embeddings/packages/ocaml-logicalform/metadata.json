{
  "package": "ocaml-logicalform",
  "embedding_model": "Qwen/Qwen3-Embedding-0.6B",
  "embedding_dimension": 1024,
  "total_modules": 103,
  "creation_timestamp": "2025-07-15T23:22:50.821602",
  "modules": [
    {
      "module_path": "LogicalForm.Std.CNF.Clause.Literal.Id.T",
      "library": "ocaml-logicalform",
      "description": "This module implements integer-based literal identifiers for clauses in a logical formula, supporting operations to convert between integers and a specialized type `t`, validate numeric properties like positivity, and manipulate signs. It provides functions for parsing and printing, including S-expression and string conversions, as well as logical negation of identifiers. Concrete use cases include managing literal representations in SAT solvers or symbolic logic systems where signed identifiers are used to denote variables and their negations.",
      "description_length": 550,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.Std.DNF.Term.Literal.Id.T",
      "library": "ocaml-logicalform",
      "description": "This module represents and manipulates integer-based literal identifiers in a Disjunctive Normal Form (DNF) logic system. It provides conversions to and from integers, strings, and S-expressions, along with validation and sign-checking operations. Concrete use cases include constructing and validating logical literals for use in SAT solvers or formal verification systems.",
      "description_length": 374,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.Std.Term.Literal.Id.T",
      "library": "ocaml-logicalform",
      "description": "This module implements integer literal identifiers with bidirectional conversions to integers and strings, supporting arithmetic sign checks and validation. It works directly with integer values wrapped in a unique type `t`, enabling precise validation such as checking positivity or negativity, and provides standard serialization via S-expressions. Use cases include representing and validating logical term identifiers in formal systems where signed integer IDs are required.",
      "description_length": 478,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.Std.NNF.Literal.Id.T",
      "library": "ocaml-logicalform",
      "description": "This module represents and manipulates literal identifiers in negation normal form (NNF), primarily working with integers wrapped in a custom type `t`. It provides operations to validate and check the sign of these literals, convert between integers and strings, and negate literals. Concrete use cases include managing propositional logic expressions and ensuring correctness during formula transformations.",
      "description_length": 408,
      "index": 3,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "LogicalForm.Std.UnNF.Literal.Id.T",
      "library": "ocaml-logicalform",
      "description": "This module implements integer literal identifiers with support for serialization, sign validation, and arithmetic operations. It works with a concrete type `t` representing signed integers, offering functions to convert between integers and strings, check sign properties, and negate values. Use cases include managing logical literals in a solver or compiler where strict sign validation and bidirectional conversion are required.",
      "description_length": 432,
      "index": 4,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "LogicalForm.Std.CNF.Clause.Literal.Id",
      "library": "ocaml-logicalform",
      "description": "This module represents and manipulates literal identifiers in a CNF clause, using a private type `t` that combines a nonzero sign with an identifier to ensure valid logical representation. It supports conversion to and from integers, strings, and S-expressions, along with logical negation, enabling operations like parsing DIMACS clauses, generating unique literal IDs, and transforming formulas during SAT solving. The child module extends this by implementing integer-based literal identifiers, adding validation of numeric properties and enhanced manipulation of signed identifiers. Together, they provide a robust system for handling logical literals in symbolic reasoning applications.",
      "description_length": 691,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.Std.DNF.Term.Literal.Id",
      "library": "ocaml-logicalform",
      "description": "This module represents and manipulates literals in a Disjunctive Normal Form (DNF) logical expression, focusing on identifiers with non-zero signs. It supports key operations like conversion to and from strings, integers, and S-expressions, along with negation and validation. The child module extends this by providing integer-based literal manipulation, enhancing construction and validation workflows for use in SAT solvers or formal verification. Together, they enable parsing, transforming, and serializing DNF expressions with precise sign handling and format interoperability.",
      "description_length": 583,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.Std.Clause.Literal.Id.T",
      "library": "ocaml-logicalform",
      "description": "This module defines a type `t` representing literal identifiers in logical clauses, supporting operations to validate and check their numeric properties, such as positivity or negativity. It provides conversions to and from integers and strings, along with a function to compute the logical negation of a literal identifier. These operations are used to manipulate and validate literal IDs when constructing and analyzing logical formulas.",
      "description_length": 439,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.Std.NNF.Literal.Id",
      "library": "ocaml-logicalform",
      "description": "This module represents and manipulates identifiers for literals in negation normal form (NNF), using a private type `t` that wraps a signed index and an internal identifier type. It supports conversion to and from integers, strings, and S-expressions, and includes operations to negate literals and validate their structure. The module enables constructing literal IDs from strings or integers, checking their sign, and serializing or deserializing them for storage or communication. Submodule `T` provides the core integer-based identifier type and basic operations like validation and negation.",
      "description_length": 596,
      "index": 8,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "LogicalForm.Std.DNF.Term.Literal",
      "library": "ocaml-logicalform",
      "description": "This module represents logical literals in disjunctive normal form, supporting negation, positivity, and constant truth values. It provides operations to convert literals to and from strings and S-expressions, evaluate them under boolean assignments, and validate their structure, enabling symbolic logic manipulation and DNF-based reasoning. The child module extends this with integer-based literal manipulation, enhancing construction, parsing, and validation workflows for use in SAT solvers and formal verification. Together, they support precise sign handling, expression transformation, and format interoperability across string, integer, and S-expression representations.",
      "description_length": 678,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.Std.UnNF.Literal.Id",
      "library": "ocaml-logicalform",
      "description": "This module represents and manipulates literal identifiers in a logical form, using a private variant type that combines a nonzero sign with an identifier value. It supports conversion to and from integers, strings, and S-expressions, and includes operations for negating literals and validating sign properties. The child module extends this functionality with a concrete implementation for integer literal identifiers, providing serialization, arithmetic operations, and bidirectional conversion with strings. Together, they enable parsing and managing logical literals in solvers or compilers where strict sign validation and consistent integer representations are essential.",
      "description_length": 678,
      "index": 10,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.Std.Literal.Id.T",
      "library": "ocaml-logicalform",
      "description": "This module defines a type `t` as an alias for `LogicalForm.Std.Index.T.t` and provides functions for validating and inspecting the sign of these values, including checks for positivity, negativity, and bounds. It supports conversions to and from integers and strings, along with serialization to S-expressions. Typical use cases include representing and validating literal identifiers in logical expressions where sign and numeric conversion are essential.",
      "description_length": 457,
      "index": 11,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.Std.Clause.Literal.Id",
      "library": "ocaml-logicalform",
      "description": "This module represents literal identifiers in logical clauses using a private variant type that combines a nonzero sign with an identifier value. It supports operations to convert identifiers to and from integers and strings, validate their numeric properties, and compute logical negation by flipping the sign. The child module defines the core type `t` used for these identifiers and provides functions for validation, sign inspection, and negation. Examples include parsing identifiers from input strings, serializing them for storage, and manipulating logical formulas by negating literals.",
      "description_length": 594,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.Std.CNF.Clause.Literal",
      "library": "ocaml-logicalform",
      "description": "This module represents literals in Boolean formulas with support for negation, string and S-expression conversion, and evaluation under variable assignments. It uses variant types for true, false, positive, and negative literals, combined with identifier handling from its child modules. The child module introduces a private type for signed identifiers, ensuring valid logical representations and enabling tasks like DIMACS parsing, literal validation, and formula transformation. Together, they facilitate constructing and manipulating CNF clauses for logic evaluation and symbolic reasoning.",
      "description_length": 594,
      "index": 13,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.Std.Term.Literal.Id",
      "library": "ocaml-logicalform",
      "description": "This module represents and manipulates literal identifiers in a logical form, supporting conversion to and from integers and strings, negation, and S-expression serialization. It works with a private sum type that includes a nonzero sign and an identifier value, enabling precise validation and transformation of identifiers in formal systems. The child module extends this functionality by implementing integer-specific identifiers with a unique type `t`, offering operations like sign checks, arithmetic validation, and standard serialization. Together, they support tasks like managing variable references in logical expressions, ensuring correct sign handling during formula transformations, and validating signed integer IDs in formal proofs.",
      "description_length": 747,
      "index": 14,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.Std.Clause.Literal",
      "library": "ocaml-logicalform",
      "description": "This module represents logical literals with support for negation, identity, and boolean constants, while its child module defines the core type `t` for literal identifiers using a private variant that combines a nonzero sign with an identifier value. It provides operations to convert literals and identifiers to and from strings and integers, evaluate literals under boolean assignments, and manipulate their structure through negation and validation. Examples include parsing and serializing logical expressions, generating constraints for solvers, and transforming formulas in compilers or theorem provers. Key data types include `t` for identifiers and the literal type, with operations like negation, conversion, and evaluation.",
      "description_length": 734,
      "index": 15,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.Std.DNF.Term",
      "library": "ocaml-logicalform",
      "description": "This module represents logical terms in disjunctive normal form, supporting conjunction, negation, and evaluation over boolean assignments. It provides core data types for literals, boolean constants, and structured terms, with operations for parsing, conversion, validation, and pretty-printing in infix or prefix notation. The child module extends literal handling with integer-based representations, enabling advanced manipulation and integration with SAT solvers. Together, they support symbolic logic operations, truth evaluation, and format interoperability across strings, S-expressions, and integers.",
      "description_length": 608,
      "index": 16,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "LogicalForm.Std.UnNF.Literal",
      "library": "ocaml-logicalform",
      "description": "This module represents logical literals in an unnormalized form, using variants for true, false, positive, and negative literals. It supports negation, parsing from and formatting to strings and S-expressions, and evaluation under boolean assignments. The `Id` submodule handles literal identifiers with a private variant combining a nonzero sign and an identifier value, offering conversion to integers, strings, and S-expressions, along with negation and validation. A concrete implementation for integer identifiers extends this with serialization, arithmetic, and string conversion, enabling precise parsing and management of literals in logic solvers or compilers.",
      "description_length": 669,
      "index": 17,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "LogicalForm.Std.CNF.Clause",
      "library": "ocaml-logicalform",
      "description": "This module represents logical clauses in conjunctive normal form (CNF), using polymorphic variants to model literals, negations, disjunctions, and logical constants. It supports evaluation under variable assignments, pretty-printing in infix or prefix notation, and parsing from S-expressions, enabling tasks like SAT solving preprocessing and logic manipulation. The child module focuses on literals, providing negation, conversion to and from strings and S-expressions, and validation, using a private type to ensure correct signed identifier handling. Together, they allow constructing, transforming, and evaluating complex Boolean formulas while supporting DIMACS parsing and human- or machine-readable output.",
      "description_length": 715,
      "index": 18,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.PrettyPrint.Style.Prefix",
      "library": "ocaml-logicalform",
      "description": "This module defines a record type `t` for configuring prefix-based logical form formatting, including custom strings for logical operators and constants. It provides a default configuration value `default` with standard prefixes like \"var\", \"true\", \"false\", \"not\", \"and\", and \"or\". This configuration is used to customize the textual representation of logical expressions in prefix notation during pretty-printing.",
      "description_length": 414,
      "index": 19,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "LogicalForm.Std.NNF.Literal",
      "library": "ocaml-logicalform",
      "description": "This module represents propositional literals in negation normal form, using a variant type to encode truth values and atomic propositions with sign. It supports evaluation under boolean assignments, string and S-expression parsing and conversion, and logical negation, enabling tasks like model checking and input processing. The submodule handles literal identifiers via a private type wrapping signed indices, offering integer and string conversion, negation, and validation, with core identifier operations defined in `T`. Together, they allow constructing, manipulating, and serializing logical literals and their identifiers for storage or communication.",
      "description_length": 660,
      "index": 20,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "LogicalForm.PrettyPrint.Style.Infix",
      "library": "ocaml-logicalform",
      "description": "This module defines a record type `t` that configures string representations for logical operators and constants, such as conjunction, disjunction, and negation. It includes a `default` value that provides standard infix notation for logical expressions. This configuration is used to customize the formatting of logical forms during pretty-printing.",
      "description_length": 350,
      "index": 21,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.Std.Term.Literal",
      "library": "ocaml-logicalform",
      "description": "This module represents logical literals with support for negation, positivity, and boolean constants, offering operations to convert literals to and from strings and S-expressions, evaluate them under boolean assignments, and manipulate their structure. It works with a private sum type that includes a nonzero sign and an identifier value, enabling precise validation and transformation of identifiers in formal systems. The child module extends this by implementing integer-specific identifiers with a unique type `t`, supporting sign checks, arithmetic validation, and standard serialization. Together, they enable symbolic logic processing, managing variable references in logical expressions, and validating signed integer IDs in formal proofs.",
      "description_length": 749,
      "index": 22,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "LogicalForm.Std.Index.T",
      "library": "ocaml-logicalform",
      "description": "This module defines a type `t` as an integer with additional validation functions to check sign properties like positivity or non-negativity. It supports conversions to and from integers, strings, and S-expressions, along with boolean checks for sign conditions. It is used to represent and manipulate integer indices with strict sign constraints in data processing and validation contexts.",
      "description_length": 390,
      "index": 23,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.Std.Literal.Id",
      "library": "ocaml-logicalform",
      "description": "This module represents and manipulates logical literal identifiers, supporting construction, negation, and serialization of identifiers through conversions between integers, strings, and S-expressions. It defines the core type `t` for literal IDs, offering operations to inspect and validate signs, ensure numeric bounds, and convert between representations. Child modules enhance this functionality by providing specialized validation and inspection routines, such as checking positivity and handling conversions in logical expression contexts. Examples include parsing identifiers from strings, negating literals in formulas, and serializing IDs for storage or transmission.",
      "description_length": 676,
      "index": 24,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.Literal.I-Id-T",
      "library": "ocaml-logicalform",
      "description": "This module defines a type `t` representing integer values with identity and provides functions to convert between integers, strings, and S-expressions. It includes validation checks for sign properties and operations to query or invert the sign of values. Use cases include managing identifiers with numeric constraints and ensuring correct sign handling during data serialization or input validation.",
      "description_length": 402,
      "index": 25,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.Std.NNF",
      "library": "ocaml-logicalform",
      "description": "This module represents logical formulas in negation normal form, supporting conjunction, disjunction, and negation over literals, constants, and nested expressions. It enables evaluation against variable assignments, conversion to and from S-expressions, and pretty-printing in infix or prefix notation. The submodule handles propositional literals using a variant type with signed atomic propositions, supporting parsing, negation, and evaluation under assignments. Together, they allow constructing and manipulating logical expressions, validating models, and serializing formulas for storage or communication.",
      "description_length": 612,
      "index": 26,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.Literal.I",
      "library": "ocaml-logicalform",
      "description": "This module represents logical literals with support for boolean constants, positive and negative identifiers, and custom literal forms. It provides operations for negation, parsing from and converting to strings and S-expressions, and evaluating literals against boolean assignments. Use cases include symbolic logic manipulation, formula evaluation, and pretty-printing logical expressions in both infix and prefix notation.",
      "description_length": 426,
      "index": 27,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "LogicalForm.Literal.Make",
      "library": "ocaml-logicalform",
      "description": "This module represents logical literals with identifiers, supporting negation, validation, and evaluation against boolean assignments. It provides operations to convert literals to and from strings and S-expressions, format them for display, and evaluate their truth value. Use cases include symbolic logic manipulation, formula evaluation, and pretty-printing logical expressions.",
      "description_length": 381,
      "index": 28,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.DNF.I-Term-Literal-Id-T",
      "library": "ocaml-logicalform",
      "description": "This module defines a type `t` representing signed integer literals with bidirectional conversions to S-expressions, strings, and integers. It provides validation functions to check the sign of values, including positive, non-negative, negative, and non-positive constraints. Operations include negation, sign inspection, and conversions for use in logic-based systems like SAT solvers or symbolic reasoning engines.",
      "description_length": 416,
      "index": 29,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "LogicalForm.NNF.I-Literal",
      "library": "ocaml-logicalform",
      "description": "This module represents logical literals in negation normal form (NNF), supporting operations like negation, conversion to and from strings, and evaluation given a boolean assignment array. It works with boolean logic expressions structured as true, false, positive or negative literals, or labeled literals. Use cases include evaluating logical formulas, converting literals to human-readable or S-expression formats, and parsing literals from external representations.",
      "description_length": 469,
      "index": 30,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.UnNF.I",
      "library": "ocaml-logicalform",
      "description": "This module represents logical formulas in negation normal form (NNF), supporting operations like conjunction, disjunction, and negation. It provides functions to construct and manipulate logical expressions, evaluate them under variable assignments, and convert them to and from S-expressions and human-readable strings. Use cases include symbolic reasoning, automated theorem proving, and logic-based analysis tools.",
      "description_length": 418,
      "index": 31,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.DNF.I-Term-Literal-Id",
      "library": "ocaml-logicalform",
      "description": "This module defines a type `t` representing valid logical literals with nonzero signs and term identifiers. It provides functions to convert between integers, strings, and S-expressions, as well as to negate literals and extract their integer representation. Use cases include manipulating logical expressions in disjunctive normal form and handling literal identities in a term rewriting system.",
      "description_length": 396,
      "index": 32,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.CNF.I-Clause-Literal-Id-T",
      "library": "ocaml-logicalform",
      "description": "This module defines a type `t` representing literal identifiers in a CNF (Conjunctive Normal Form) context, along with functions to convert between integers, strings, and S-expressions. It provides validation and inspection functions to check the sign of a literal (positive, negative, non-negative, non-positive) and includes logical negation. Use cases include managing and validating propositional logic literals in SAT solvers or formal verification tools.",
      "description_length": 460,
      "index": 33,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.Term.I-Literal-Id-T",
      "library": "ocaml-logicalform",
      "description": "This module defines a concrete type `t` representing logical term literals, with bidirectional conversions to and from S-expressions. It provides integer and string parsing and formatting, operations to check and validate signs (positive, non-negative, negative, non-positive), and logical negation. Direct use cases include parsing and validating literal identifiers in logical formulas and manipulating their truth values.",
      "description_length": 424,
      "index": 34,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.Std.Literal",
      "library": "ocaml-logicalform",
      "description": "This module represents logical literals with support for true, false, and signed identifiers, enabling operations like negation, evaluation over boolean arrays, and conversion to and from strings and S-expressions. It integrates identifier handling through the `Id` submodule, which defines the core type `t` for literal IDs and provides functions to construct, inspect, negate, and serialize identifiers while enforcing numeric bounds and sign validity. With this combination, users can manipulate symbolic logic expressions, evaluate logical formulas efficiently, and implement custom pretty-printing or serialization formats. Example uses include parsing and negating logical terms, converting expressions to S-expressions, and evaluating propositional formulas over boolean assignments.",
      "description_length": 790,
      "index": 35,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "LogicalForm.Properties.Negatable",
      "library": "ocaml-logicalform",
      "description": "This module defines a negation operation for a type `t`, allowing values to be logically inverted. It provides a single function `not_` that takes a value of type `t` and returns its negated form. This is useful for implementing logical transformations where elements have a natural opposite, such as in propositional logic or constraint systems.",
      "description_length": 346,
      "index": 36,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "LogicalForm.CNF.I",
      "library": "ocaml-logicalform",
      "description": "This module represents logical formulas in conjunctive normal form (CNF), supporting operations like conjunction (`and_`), disjunction (`or_`), and negation (`not_`). It works with clauses\u2014disjunctions of literals\u2014organized as lists of atomic propositions or their negations. Use this module to construct, evaluate, and pretty-print CNF formulas, such as modeling logical constraints for SAT solvers or formal verification tasks.",
      "description_length": 429,
      "index": 37,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.NNF.I-Literal-Id",
      "library": "ocaml-logicalform",
      "description": "This module represents logical literals with a focus on their identity and sign, providing operations to convert between integers, strings, and internal representations. It supports negation via `not_`, and serialization through `t_of_sexp` and `sexp_of_t`. Concrete use cases include manipulating propositional logic formulas in negation normal form (NNF), where each literal is uniquely identified and signed.",
      "description_length": 411,
      "index": 38,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "LogicalForm.Index.Make",
      "library": "ocaml-logicalform",
      "description": "This module defines a logical index type that wraps a signed value and a generic type `T`, supporting operations to convert between string, integer, and S-expression representations. It provides functions to create, negate, and serialize/deserialize values, ensuring valid construction via a private type. Concrete use cases include representing and manipulating symbolic logical expressions with signed identifiers.",
      "description_length": 416,
      "index": 39,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "LogicalForm.UnNF.Make",
      "library": "ocaml-logicalform",
      "description": "This module represents and manipulates logical formulas in negation normal form (NNF), supporting construction via `and_`, `or_`, and `not_`, and validation of formula structure. It works with a custom type `t` that recursively represents literals, negations, disjunctions, and conjunctions, and integrates with S-expressions for serialization. Use cases include evaluating logical formulas against boolean assignments, pretty-printing formulas in infix or prefix notation, and parsing formulas from S-expressions.",
      "description_length": 514,
      "index": 40,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.IdBase.I",
      "library": "ocaml-logicalform",
      "description": "This module implements a type `t` with conversions to and from S-expressions, string, and integers, along with validation checks for sign properties. It provides boolean checks for positivity, negativity, and zero, and a `sign` function that returns the numeric sign as `Neg`, `Zero`, or `Pos`. Use cases include representing integer-based identifiers with strict sign validation and serializing them for storage or communication.",
      "description_length": 430,
      "index": 41,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.Properties.Conjunctable",
      "library": "ocaml-logicalform",
      "description": "This module defines a type `t` and a function `and_` that combines a list of values of type `t` into a single value, representing a logical conjunction. It is used to construct and manipulate logical expressions where multiple conditions must all hold true simultaneously. A concrete use case is building complex query filters in a system that evaluates logical constraints.",
      "description_length": 374,
      "index": 42,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.Std.Index",
      "library": "ocaml-logicalform",
      "description": "This module combines a signed index type with validated integer indices to manage logical references requiring sign-aware operations. It defines a private type `t` that pairs a nonzero sign with an index value, supporting conversion from integers, negation, and string representation, while its child module enforces sign constraints on integer indices. You can use it to safely handle signed variable indices in formal verification or convert between validated indices and external representations like strings. The combined functionality ensures correct handling of sign-sensitive data across logical and numerical domains.",
      "description_length": 625,
      "index": 43,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.Form.I",
      "library": "ocaml-logicalform",
      "description": "This module represents logical formulas using a variant type that includes literals, conjunctions, disjunctions, and negations. It provides operations to construct and manipulate logical expressions, including evaluation given a boolean assignment and validation of formula structure. Concrete use cases include symbolic reasoning, constraint solving, and boolean expression manipulation.",
      "description_length": 388,
      "index": 44,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.UnNF.I-Literal",
      "library": "ocaml-logicalform",
      "description": "This module represents logical literals with support for boolean constants, positive and negative atomic propositions, and custom literals. It provides operations for negation, parsing from and converting to strings and S-expressions, pretty-printing in infix or prefix notation, and evaluating literals against a boolean assignment array. Use cases include symbolic logic manipulation, formula evaluation, and serialization for storage or transmission.",
      "description_length": 453,
      "index": 45,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.DNF.I",
      "library": "ocaml-logicalform",
      "description": "This module represents logical formulas in disjunctive normal form (DNF), supporting operations like conjunction (`and_`), disjunction (`or_`), and negation (`not_`). It works with boolean expressions composed of terms, organized as either a single term or a disjunction of terms. Concrete use cases include evaluating logical expressions over boolean variable assignments, validating formula structure, and serializing or pretty-printing formulas in S-expressions or custom infix/prefix formats.",
      "description_length": 496,
      "index": 46,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "LogicalForm.NNF.Make",
      "library": "ocaml-logicalform",
      "description": "This module represents and manipulates logical formulas in negation normal form (NNF), supporting construction via `and_`, `or_`, and `not_`, and validation of formula structure. It works with boolean variables and formulas composed of literals, conjunctions, and disjunctions, enabling concrete use cases like logical reasoning, constraint solving, and formula transformation. It provides evaluation given a boolean assignment and pretty-printing in infix or prefix notation, with serialization to and from S-expressions.",
      "description_length": 522,
      "index": 47,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.Clause.I-Literal",
      "library": "ocaml-logicalform",
      "description": "This module represents logical literals with support for true, false, positive, negative, and labeled atoms. It provides operations for negation, string and S-expression serialization, pretty-printing in infix or prefix notation, parsing from expressions, and evaluation given a boolean assignment array. Concrete use cases include constructing and manipulating logical clauses for SAT solving or symbolic reasoning tasks.",
      "description_length": 422,
      "index": 48,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "LogicalForm.Index.I-T",
      "library": "ocaml-logicalform",
      "description": "This module implements a type `t` with conversions to and from S-expressions, integers, and strings, along with validation and sign-checking operations. It supports numeric logic with functions like `is_positive`, `sign`, and `not_`, ensuring values adhere to specific numeric constraints. Use cases include representing and validating integer-based indices or coordinates with strict sign requirements.",
      "description_length": 403,
      "index": 49,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.Literal.I-Id",
      "library": "ocaml-logicalform",
      "description": "This module represents logical literals using identifiers, supporting operations to convert between identifiers and non-zero integers, strings, and S-expressions. It provides functions to construct, negate, and serialize literals, ensuring valid indexing via `LogicalForm.Index.nonzero_sign`. Concrete use cases include encoding propositional variables in logical formulas and facilitating parsing and serialization in logic solvers or theorem provers.",
      "description_length": 452,
      "index": 50,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.Form.I-Literal-Id-T",
      "library": "ocaml-logicalform",
      "description": "This module defines a type `t` representing literal identifiers with signed integer values. It provides functions to convert between integers and strings, validate signs (positive, non-negative, negative, non-positive), and negate values. Use cases include managing logical literals in a solver or constraint system where sign and numeric identity are critical.",
      "description_length": 361,
      "index": 51,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.Term.Make",
      "library": "ocaml-logicalform",
      "description": "This module represents logical terms as either literals or conjunctions of literals, supporting construction, validation, evaluation, and pretty-printing. It works with boolean arrays for evaluation and S-expressions for serialization, enabling parsing and pretty-printing in both infix and prefix styles. Concrete use cases include building and evaluating logical expressions, converting them to readable string or S-expression formats, and validating term structures.",
      "description_length": 469,
      "index": 52,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.DNF.I-Term-Literal",
      "library": "ocaml-logicalform",
      "description": "This module represents logical literals in a disjunctive normal form (DNF), supporting operations like negation, evaluation under variable assignments, and conversion to and from string and S-expression formats. It works with boolean variables identified by a term identifier type, and supports both positive and negative literals, as well as constant true and false values. It is used to construct and manipulate individual clauses in logical formulas, particularly for evaluating and transforming DNF expressions.",
      "description_length": 515,
      "index": 53,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "LogicalForm.PrettyPrint.Sexpable",
      "library": "ocaml-logicalform",
      "description": "This module defines conversions between a structured type `t` and S-expressions for pretty-printing. It supports parsing and generating S-expressions with optional formatting styles. Use it to serialize and deserialize logical forms in a readable, structured format.",
      "description_length": 266,
      "index": 54,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.Std.Term",
      "library": "ocaml-logicalform",
      "description": "This module represents logical terms with constructors for conjunctions, negation, and propositional literals, supporting evaluation under boolean assignments and conversion to and from S-expressions and strings. It provides core operations for symbolic logic manipulation, including pretty-printing in infix or prefix notation, and managing variable references through a private sum type that encodes sign and identifier information. The child module specializes this representation by implementing integer-based identifiers with sign awareness, enabling arithmetic validation and precise identifier transformation in formal proofs. Together, they support tasks like boolean formula evaluation, logical expression serialization, and signed ID validation in symbolic systems.",
      "description_length": 775,
      "index": 55,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "LogicalForm.Std.UnNF",
      "library": "ocaml-logicalform",
      "description": "This module represents logical formulas in normalized form, supporting conjunction, disjunction, and negation over boolean literals. It provides constructors, evaluators, and converters for logical expressions, enabling symbolic manipulation and constraint evaluation. The child module handles unnormalized literals with variants for true, false, positive, and negative forms, while its `Id` submodule manages literal identifiers with signed integers, supporting parsing, serialization, and negation. Together, they enable precise construction, evaluation, and transformation of logical expressions used in automated reasoning and logic solvers.",
      "description_length": 645,
      "index": 56,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.Term.I-Literal",
      "library": "ocaml-logicalform",
      "description": "This module represents logical literals with support for boolean constants, positive and negative atomic propositions, and indexed literals. It provides operations for negation, parsing from and converting to strings and S-expressions, pretty-printing in infix or prefix notation, and evaluating literals against a boolean assignment array. Use cases include symbolic logic manipulation, formula evaluation, and serialization for storage or transmission.",
      "description_length": 454,
      "index": 57,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "LogicalForm.Index.I",
      "library": "ocaml-logicalform",
      "description": "This module defines a type `t` that represents a logical index with a sign, built from a private variant combining a nonzero sign and a value of type `T.t`. It provides functions to convert between integers, strings, and S-expressions, as well as to negate the index and extract its integer representation. Concrete use cases include handling signed identifiers in logical formulas and enabling serialization for storage or communication.",
      "description_length": 438,
      "index": 58,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.Form.I-Literal-Id",
      "library": "ocaml-logicalform",
      "description": "This module defines a type `t` representing valid logical literals with a sign and identifier. It provides functions to convert between integers, strings, and S-expressions, as well as to negate a literal. Use cases include manipulating propositional logic variables in a solver or formal verification system.",
      "description_length": 309,
      "index": 59,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "LogicalForm.Clause.I-Literal-Id-T",
      "library": "ocaml-logicalform",
      "description": "This module defines a type `t` representing literal identifiers with signed integer values, supporting conversions to and from sexp, string, and integers. It provides validation functions to check the sign of values, including checks for positive, non-negative, negative, and non-positive values, along with corresponding boolean predicates. These operations are used to manipulate and validate literal signs in logical expressions, such as in clause processing or SAT solving algorithms.",
      "description_length": 488,
      "index": 60,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "LogicalForm.Std.CNF",
      "library": "ocaml-logicalform",
      "description": "This module represents logical formulas in conjunctive normal form (CNF), supporting operations like conjunction, disjunction, and negation over boolean variables and literals arranged in clauses. It enables direct construction, evaluation, and validation of CNF expressions, with support for parsing and output in both string and S-expression formats. The child module focuses on individual clauses and literals, providing negation, conversion, and validation with polymorphic variants ensuring correct literal handling. Together, they support tasks like SAT solving preprocessing, logic manipulation, and DIMACS parsing, allowing users to build and transform complex Boolean formulas for both human and machine consumption.",
      "description_length": 725,
      "index": 61,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "LogicalForm.CNF.I-Clause",
      "library": "ocaml-logicalform",
      "description": "This module represents logical clauses in conjunctive normal form (CNF), supporting operations to construct, evaluate, and serialize clauses. It works with literals and lists of literals combined using logical OR, along with boolean arrays for evaluation. Concrete use cases include parsing and evaluating CNF expressions for SAT solving, pretty-printing logical formulas, and converting between sexp representations for storage or transmission.",
      "description_length": 445,
      "index": 62,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "LogicalForm.Std.DNF",
      "library": "ocaml-logicalform",
      "description": "This module represents logical formulas in disjunctive normal form, supporting conjunction, disjunction, and negation over literals, with evaluation against boolean assignments and conversion to and from S-expressions and readable infix or prefix formats. It includes core data types such as literals, boolean constants, and structured terms, along with operations for parsing, validation, and pretty-printing, while a child module extends literals to integer-based representations for advanced manipulation and SAT solver integration. You can construct logical expressions, evaluate their truth under specific assignments, convert them to different formats, and leverage integer encodings for performance-critical applications like automated reasoning. The combined interface enables both direct formula manipulation and low-level term processing across multiple representations.",
      "description_length": 880,
      "index": 63,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.Term.I-Literal-Id",
      "library": "ocaml-logicalform",
      "description": "Handles literal identifiers with sign information, providing conversions between integers, strings, and internal representations. Supports negation and enforces nonzero integer constraints through explicit conversion functions. Useful for encoding logical literals in SAT solvers or symbolic reasoning systems.",
      "description_length": 310,
      "index": 64,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "LogicalForm.Term.I",
      "library": "ocaml-logicalform",
      "description": "This module represents logical terms composed of literals and conjunctions, providing operations to construct, evaluate, and serialize these terms. It supports parsing and pretty-printing in both S-expression and infix/prefix formats, with validation to normalize term structure. Concrete use cases include symbolic reasoning, constraint evaluation, and generating human-readable logical expressions.",
      "description_length": 400,
      "index": 65,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.UnNF.I-Literal-Id",
      "library": "ocaml-logicalform",
      "description": "This module defines a type `t` representing valid logical literals with a sign and identifier. It provides functions to convert between integers, strings, and S-expressions, as well as to negate a literal. Use cases include manipulating propositional logic formulas during SAT solving or logical transformations.",
      "description_length": 312,
      "index": 66,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.UnNF.I-Literal-Id-T",
      "library": "ocaml-logicalform",
      "description": "This module defines a type `t` representing literal identifiers with integer-like values, supporting conversions to and from S-expressions, strings, and integers. It provides validation checks for sign properties and functions to query sign and numeric properties, ensuring values adhere to expected constraints. Use cases include parsing and validating literal identifiers in logical expressions and converting between external representations and internal types.",
      "description_length": 464,
      "index": 67,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.PrettyPrint.Style",
      "library": "ocaml-logicalform",
      "description": "The module provides two configuration types to customize the textual representation of logical expressions during pretty-printing. One configuration uses prefix notation with customizable operator and constant strings, while the other uses infix notation with standard logical symbols. Both include default values with conventional representations like \"and\", \"or\", \"not\", and boolean constants. These configurations allow users to control how logical forms are displayed in different syntactic styles.",
      "description_length": 502,
      "index": 68,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.Form.I-Literal",
      "library": "ocaml-logicalform",
      "description": "This module represents logical literals with support for boolean constants, positive and negative atomic propositions, and generic literals. It provides operations for negation, parsing from and converting to strings and S-expressions, pretty-printing in infix or prefix notation, and evaluating literals against a boolean assignment array. Concrete use cases include building and manipulating logical formulas, evaluating truth values under specific assignments, and serializing literals for storage or communication.",
      "description_length": 518,
      "index": 69,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.IdBase.Make",
      "library": "ocaml-logicalform",
      "description": "This module defines a type `t` based on the parameter module `B`, along with functions to convert values to and from S-expressions, validate numeric properties like positivity, and convert between integers and strings. It supports logical operations such as negation and provides consistent sign classification. Concrete use cases include representing and validating integer-based identifiers with logical constraints, such as in symbolic reasoning or constraint-solving systems.",
      "description_length": 479,
      "index": 70,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.DNF.I-Term",
      "library": "ocaml-logicalform",
      "description": "This module represents logical terms in disjunctive normal form (DNF), supporting operations like conjunction construction, evaluation under variable assignments, and pretty-printing in infix or prefix notation. It works with boolean literals and arrays of boolean values, organizing terms as either a single literal or an AND of multiple literals. Use cases include symbolic logic manipulation, boolean function evaluation, and generating human-readable representations of logical expressions.",
      "description_length": 494,
      "index": 71,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "LogicalForm.Properties.NeedsValidation",
      "library": "ocaml-logicalform",
      "description": "This module defines a type `t` representing logical forms that require validation. It provides a `validate` function that ensures the integrity of these logical forms by checking and enforcing constraints. Use this module when processing user input or external data to guarantee valid logical structures before further processing.",
      "description_length": 330,
      "index": 72,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.Clause.Make",
      "library": "ocaml-logicalform",
      "description": "This module represents logical clauses as either a single literal or a disjunction of literals. It provides operations to construct disjunctive clauses, evaluate their truth value under a variable assignment, and pretty-print or parse clauses in different formats. It is used to model propositional logic expressions in a form suitable for tasks like SAT solving or logical analysis.",
      "description_length": 383,
      "index": 73,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "LogicalForm.CNF.Make",
      "library": "ocaml-logicalform",
      "description": "This module represents logical formulas in conjunctive normal form (CNF), supporting operations like conjunction (`and_`), disjunction (`or_`), and negation (`not_`) on clauses. It provides evaluation of formulas against boolean assignments, pretty-printing in infix or prefix notation, and S-expression serialization. Concrete use cases include symbolic reasoning, constraint solving, and manipulation of boolean logic expressions.",
      "description_length": 432,
      "index": 74,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "LogicalForm.CNF.I-Clause-Literal",
      "library": "ocaml-logicalform",
      "description": "This module defines a polymorphic variant type representing logical literals in conjunctive normal form (CNF), including boolean constants, positive and negative literals, and indexed literals. It provides operations for negating literals, converting between strings and literals, and evaluating literals against a boolean assignment array. The module also supports serialization to and from S-expressions, with customizable pretty-printing in both infix and prefix styles.",
      "description_length": 473,
      "index": 75,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.NNF.I-Literal-Id-T",
      "library": "ocaml-logicalform",
      "description": "This module defines a type `t` representing literal identifiers with signed integer values. It provides functions to convert between integers, strings, and S-expressions, validate signs (positive, negative, non-negative, non-positive), and negate values. Use cases include managing literal truth values in logical expressions and ensuring correct sign handling during formula transformations.",
      "description_length": 392,
      "index": 76,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.PrettyPrint.Inspectable",
      "library": "ocaml-logicalform",
      "description": "This module provides a function `to_pretty_string` that converts a value of type `t` into a human-readable string representation, optionally using a specified infix style for formatting. It works with logical form structures, typically used to represent formal logic expressions or program ASTs. A concrete use case is generating readable output for debugging or displaying logical expressions in a user interface.",
      "description_length": 414,
      "index": 77,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "LogicalForm.DNF.Make",
      "library": "ocaml-logicalform",
      "description": "This module represents logical formulas in disjunctive normal form (DNF), supporting operations like conjunction (`and_`), disjunction (`or_`), and negation (`not_`). It works with terms defined by the `Term` module and evaluates formulas over boolean arrays. Functions like `to_pretty_string` and `eval` enable readable formatting and logical evaluation, useful in symbolic reasoning and constraint solving.",
      "description_length": 408,
      "index": 78,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "LogicalForm.PrettyPrint.I",
      "library": "ocaml-logicalform",
      "description": "This module provides functions to convert values of type `t` to human-readable string and S-expression representations, using configurable pretty-printing styles. It supports parsing and pretty-printing logical forms, with specific support for infix and prefix notation styles. Use this module when serializing logical expressions for debugging, logging, or structured data interchange.",
      "description_length": 386,
      "index": 79,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.IdBase.BASE",
      "library": "ocaml-logicalform",
      "description": "This module implements a base type for integer-like identifiers with strict validation and conversion routines. It supports operations to check numeric properties (positive, negative, zero), convert between integers and strings, and serialize to S-expressions. Concrete use cases include defining strongly-typed identifiers with validation in configuration systems or domain models.",
      "description_length": 382,
      "index": 80,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.NNF.I",
      "library": "ocaml-logicalform",
      "description": "This module represents logical formulas in negation normal form (NNF), supporting operations like conjunction, disjunction, and negation. It works with a recursive type composed of literals, `And`, and `Or` nodes, and provides functions to construct, validate, and evaluate these formulas. Concrete use cases include symbolic reasoning, formula manipulation, and evaluation against variable assignments.",
      "description_length": 403,
      "index": 81,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.Properties.Disjunctable",
      "library": "ocaml-logicalform",
      "description": "This module supports combining multiple logical expressions into a disjunction. It provides the `or_` function, which takes a list of logical terms and returns their logical OR as a single term. It is used to construct composite logical conditions from individual clauses.",
      "description_length": 272,
      "index": 82,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.Properties.Executable",
      "library": "ocaml-logicalform",
      "description": "This module evaluates logical form expressions using boolean arrays as input, producing an optional boolean result. It operates on a single abstract type `t` representing logical expressions, supporting their execution against variable assignments. Use it to compute truth values of logical formulas given specific variable settings.",
      "description_length": 333,
      "index": 83,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.Clause.I",
      "library": "ocaml-logicalform",
      "description": "This module represents logical clauses in disjunctive form, supporting operations to construct, evaluate, and serialize clauses. It works with boolean literals and arrays of truth values, allowing validation and pretty-printing in infix or prefix notation. Concrete use cases include building and evaluating logical expressions for theorem proving or constraint satisfaction.",
      "description_length": 375,
      "index": 84,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "LogicalForm.CNF.I-Clause-Literal-Id",
      "library": "ocaml-logicalform",
      "description": "This module defines a type `t` representing valid logical literals with a sign and identifier, supporting operations to convert between integers, strings, and S-expressions. It provides functions to negate a literal, extract its identifier, and convert it to and from integer and string representations. Concrete use cases include manipulating literals in a CNF solver, where signed identifiers track variable polarity and enable efficient clause evaluation.",
      "description_length": 458,
      "index": 85,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.Std.Clause",
      "library": "ocaml-logicalform",
      "description": "This module represents logical clauses with literals, negations, disjunctions, and boolean constants, supporting construction, evaluation, and serialization of logical expressions. It includes a core type `t` for identifiers and literals, enabling operations like negation, conversion between string and integer representations, and evaluation under boolean assignments. You can use it to build and manipulate logical formulas, generate constraints for solvers, or transform expressions in compilers and theorem provers. Examples include parsing logical expressions into s-expressions, validating formula structure, and converting clauses to readable infix or prefix string formats.",
      "description_length": 682,
      "index": 86,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.Clause.I-Literal-Id",
      "library": "ocaml-logicalform",
      "description": "This module defines a type `t` representing valid logical literals with a sign and identifier. It provides functions to convert between integers, strings, and S-expressions, as well as to negate a literal. Use cases include manipulating propositional logic clauses in SAT solvers or logic circuit representations.",
      "description_length": 313,
      "index": 87,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.NNF",
      "library": "ocaml-logicalform",
      "description": "This module transforms logical formulas into negation normal form using algebraic data types that represent logical constructs such as conjunction, disjunction, and negation. It provides core operations to convert, evaluate, and serialize logical expressions, with support for parsing and pretty-printing in multiple formats. Child modules refine this functionality by defining literal types with sign handling, identity-preserving conversions, and structured formula construction using `And`, `Or`, and `Not`. Examples include converting a formula to NNF for automated reasoning, evaluating its truth value under variable assignments, and serializing expressions to S-expressions for storage or exchange.",
      "description_length": 705,
      "index": 88,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.Index",
      "library": "ocaml-logicalform",
      "description": "This module handles symbolic indexing with signed positions through its `nonzero_sign` type and conversion functions to and from S-expressions. It includes a first-class module type `I` and a `Make` functor to build index structures with sign information, supporting operations like negation, serialization, and validation. The child modules define index types that wrap signed values with generic or integer types, offering functions to convert between strings, integers, and S-expressions, while enforcing constraints through private types. Examples include representing logical expressions with signed identifiers, validating numeric indices with strict sign requirements, and serializing signed identifiers for storage or communication.",
      "description_length": 740,
      "index": 89,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.PrettyPrint",
      "library": "ocaml-logicalform",
      "description": "This module enables customizable pretty-printing of logical forms using structured types and S-expressions, supporting both infix and prefix notation styles. It provides core operations for converting logical expressions into readable strings or serialized formats, with specific functions like `to_pretty_string` for direct output generation. The associated configurations allow fine-grained control over operator and constant representations, enabling output styles ranging from formal logic symbols to natural language keywords. Together with its submodules, it offers a complete pipeline for inspecting, serializing, and customizing the display of logical structures in various syntactic forms.",
      "description_length": 698,
      "index": 90,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.Std",
      "library": "ocaml-logicalform",
      "description": "This module provides tools for constructing and manipulating logical expressions in various normal forms, such as CNF, DNF, and NNF, using data types like terms, clauses, and literals with signed identifiers. It supports operations including negation, evaluation under boolean assignments, conversion to S-expressions, and pretty-printing in infix or prefix notation, with submodules handling identifier validation, integer-based literals, and sign-aware index manipulation. You can use it to transform logical formulas into standardized forms for automated reasoning, evaluate propositional expressions, or implement solvers with precise control over variable references and logical structure. Example tasks include parsing and negating logical terms, converting expressions for storage or communication, and validating models in formal verification contexts.",
      "description_length": 860,
      "index": 91,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "LogicalForm.UnNF",
      "library": "ocaml-logicalform",
      "description": "This module transforms logical expressions into negation normal form by eliminating implications and pushing negations inward, preparing formulas for downstream processing such as clausal conversion or tableau expansion. It operates on a hierarchy of types representing literals, negations, conjunctions, and disjunctions, with core operations including formula rewriting, evaluation under assignments, and conversion to and from S-expressions and strings. Child modules refine these structures by defining literal representations with sign and identifier semantics, supporting negation, parsing, and validation, while also enabling pretty-printing and serialization workflows. Example uses include normalizing input formulas for SAT solvers, evaluating logical expressions against variable assignments, and serializing formulas for storage or interchange.",
      "description_length": 856,
      "index": 92,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.CNF",
      "library": "ocaml-logicalform",
      "description": "This module transforms propositional logic formulas into conjunctive normal form (CNF) and simplifies them for use in SAT solvers and logic analysis. It provides core data types such as literals\u2014represented with signs and identifiers\u2014and clauses, which are disjunctions of literals, along with operations to construct, evaluate, and serialize these structures. Functions like `and_`, `or_`, and `not_` allow manipulation of logical expressions, while submodules support conversion between literals and basic types, evaluation against boolean assignments, and customizable pretty-printing. You can use it to model logical constraints, parse and evaluate CNF expressions, or prepare formulas for symbolic reasoning and constraint solving.",
      "description_length": 736,
      "index": 93,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.Properties",
      "library": "ocaml-logicalform",
      "description": "This module provides an interface for constructing and manipulating logical expressions with support for conjunction, disjunction, and negation. It defines a core type `t` representing logical forms, along with operations to combine and evaluate them under variable assignments. The negation module inverts logical values, the conjunction module combines conditions that must all hold, and the disjunction module merges clauses where at least one must be true. The validation module ensures logical forms are well-structured before evaluation, while the execution module computes results using boolean variable settings\u2014enabling use cases like query filtering, constraint validation, and logical reasoning.",
      "description_length": 706,
      "index": 94,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.Exceptions",
      "library": "ocaml-logicalform",
      "description": "Raises an exception indicating invalid S-expression input, using the provided context and S-expression value. Works with `Base.Sexp.t` values and string contexts. Useful for signaling errors during parsing or validation of S-expressions in configuration or data serialization code.",
      "description_length": 281,
      "index": 95,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "LogicalForm.Form",
      "library": "ocaml-logicalform",
      "description": "This module provides tools for constructing and evaluating logical expressions using a rich set of data types that represent literals, formulas, and quantifiers. It supports operations such as logical combination, negation, parsing, and evaluation under boolean assignments, enabling tasks like formal reasoning and constraint solving. The child modules refine these capabilities by defining specific literal representations, sign handling, and formula structures, allowing for precise manipulation of logical variables and expressions in both symbolic and evaluated forms. Examples include building a logical formula from natural language input, validating its structure, evaluating its truth under a given assignment, and serializing literals for storage or transmission.",
      "description_length": 773,
      "index": 96,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.Clause",
      "library": "ocaml-logicalform",
      "description": "This module represents logical clauses and supports operations like adding literals, resolving clauses, and checking for contradictions in propositional logic. It provides core data types for clauses and literals, with support for disjunctions, negation, and evaluation under variable assignments, enabling tasks like SAT solving and theorem proving. Child modules refine literal representations with signed identifiers, parsing, serialization, and validation, while clause-specific modules handle construction, evaluation, and formatting. Examples include building disjunctive clauses from literals, resolving contradictions during theorem proving, and serializing logical expressions for analysis or debugging.",
      "description_length": 712,
      "index": 97,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.Term",
      "library": "ocaml-logicalform",
      "description": "This module provides core operations for constructing and manipulating logical terms, including variable binding, substitution, and term comparison, working with algebraic data types that represent logical expressions and quantifiers. It supports building and analyzing first-order logic formulas through direct APIs and integrates with submodules that handle literals, conjunctions, and indexed terms, enabling tasks like parsing, evaluation, and serialization. Submodules define concrete types for literals with sign handling, boolean constants, and compound terms, supporting operations such as negation, validation, infix/prefix pretty-printing, and evaluation against boolean assignments. Specific uses include encoding logical constraints for theorem proving, validating term structures, and converting expressions between internal representations and readable or serialized formats like S-expressions.",
      "description_length": 908,
      "index": 98,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.Literal",
      "library": "ocaml-logicalform",
      "description": "This module provides a core framework for representing and manipulating logical literals, combining atomic propositions with their negations through operations like negation, comparison, and string conversion. It supports multiple literal representations via submodules, including integer-based identifiers with sign handling, customizable literal forms with boolean constants, and indexed identifiers tied to logical formulas. Users can construct, evaluate, and serialize literals in various formats, enabling applications such as theorem proving, model checking, and logical expression parsing. Specific capabilities include negating literals, validating sign properties, converting to and from S-expressions, and evaluating truth values under boolean assignments.",
      "description_length": 766,
      "index": 99,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.DNF",
      "library": "ocaml-logicalform",
      "description": "This module provides tools for constructing, simplifying, and evaluating logical formulas in Disjunctive Normal Form (DNF), using signed literals and boolean terms. It supports key operations such as conjunction, disjunction, and negation, along with conversions between literals, integers, strings, and S-expressions, enabling integration with symbolic reasoning systems and SAT solvers. The core types include signed literals for representing logical atoms and terms for building clauses, which combine into DNF formulas for evaluation or transformation. Examples include converting a boolean expression into DNF, simplifying it, and evaluating its truth under specific variable assignments using functions like `eval` or generating readable formula representations with `to_pretty_string`.",
      "description_length": 792,
      "index": 100,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.IdBase",
      "library": "ocaml-logicalform",
      "description": "This module manages unique identifier generation with customizable prefixes and integer counters, ensuring uniqueness through internal state tracking. It provides a core type for identifiers with conversions to strings, integers, and S-expressions, along with validation and sign classification operations. Submodules extend this foundation with strict sign validation, logical constraints, and type-safe conversions, enabling use in symbolic reasoning, constraint solving, and configuration systems. Examples include generating fresh variable names in compilers or validated keys in data pipelines with controlled numeric properties.",
      "description_length": 634,
      "index": 101,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "LogicalForm",
      "library": "ocaml-logicalform",
      "description": "This module system provides a comprehensive framework for constructing, transforming, and evaluating logical expressions across multiple normal forms, including NNF, CNF, and DNF. Core data types include literals with signed identifiers, logical connectives (`And`, `Or`, `Not`), clauses, and terms, supporting operations such as negation, evaluation under variable assignments, normalization, and serialization to S-expressions or strings. Users can convert formulas to normal forms for automated reasoning, validate logical structures, generate fresh identifiers for variables, and customize pretty-printing with infix or prefix notation. Example workflows include normalizing input for SAT solvers, evaluating logical constraints under assignments, and serializing expressions for storage or symbolic analysis.",
      "description_length": 813,
      "index": 102,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 103,
    "meaningful_modules": 103,
    "filtered_empty_modules": 0,
    "retention_rate": 1.0
  },
  "statistics": {
    "max_description_length": 908,
    "min_description_length": 266,
    "avg_description_length": 522.3689320388349,
    "embedding_file_size_mb": 0.3746919631958008
  }
}