{
  "package": "ocaml-logicalform",
  "embedding_model": "Qwen/Qwen3-Embedding-8B",
  "embedding_dimension": 4096,
  "total_modules": 58,
  "creation_timestamp": "2025-08-15T16:14:01.120479",
  "modules": [
    {
      "module_path": "LogicalForm.Std.CNF.Clause.Literal.Id.T",
      "library": "ocaml-logicalform",
      "description": "This module implements integer-based literal identifiers for clauses in a logical formula, supporting operations to create, convert, and validate signed integer values. It provides direct conversions to and from strings and S-expressions, along with predicates and transformations for sign manipulation, such as negation. These identifiers are used to represent propositional variables in a CNF (Conjunctive Normal Form) solver, where each literal can be positive or negative.",
      "description_length": 476,
      "index": 0,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "LogicalForm.Std.DNF.Term.Literal.Id.T",
      "library": "ocaml-logicalform",
      "description": "This module represents and manipulates integer-based literal identifiers in a Disjunctive Normal Form (DNF) logical system. It provides functions to convert between integers, strings, and S-expressions, validate numeric ranges (positive, non-negative, negative, non-positive), check and manipulate signs, and perform logical negation. These operations are used to construct and validate individual literals within a DNF expression, such as when parsing or transforming logical formulas.",
      "description_length": 486,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.Std.Clause.Literal.Id.T",
      "library": "ocaml-logicalform",
      "description": "This module defines a type `t` representing literal identifiers in logical clauses, along with functions to convert between integers, strings, and S-expressions. It provides validation checks for numeric properties like positivity and negativity, and operations to query sign, invert values, and convert to/from common formats. Concrete use cases include parsing and validating literal IDs in SAT solvers or logic engines.",
      "description_length": 422,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.Std.CNF.Clause.Literal.Id",
      "library": "ocaml-logicalform",
      "description": "This module provides functions to manage signed integer identifiers for propositional literals in a CNF solver. It supports creating, negating, and converting identifiers to and from integers, strings, and S-expressions, ensuring non-zero integer values. These identifiers represent variables in logical clauses, enabling direct manipulation and evaluation during formula processing.",
      "description_length": 383,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.Std.UnNF.Literal.Id.T",
      "library": "ocaml-logicalform",
      "description": "This module defines a type `t` representing identifiers for literals in a logical form, along with functions to convert between integers and strings, validate numeric properties like positivity, and manipulate signs. It supports operations such as negation, integer conversion with error handling, and S-expression serialization. Concrete use cases include managing literal variable identifiers in a theorem prover or logic solver where signed integer IDs are used to represent logical atoms.",
      "description_length": 492,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.Std.Term.Literal.Id.T",
      "library": "ocaml-logicalform",
      "description": "This module implements integer literal identifiers with bidirectional conversions to integers, strings, and S-expressions. It supports sign validation and checks (positive, non-negative, negative, non-positive), negation, and sign extraction. These operations are used to represent and validate logical term identifiers in formal verification tasks.",
      "description_length": 349,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.Std.DNF.Term.Literal.Id",
      "library": "ocaml-logicalform",
      "description": "This module handles integer-based literal identifiers in a DNF logical system, supporting conversions between integers, strings, and S-expressions, along with sign validation and logical negation. It works with a private type representing valid literals composed of a nonzero sign and an identifier, enabling precise construction and manipulation of DNF literals. Concrete use cases include parsing input literals, validating their numeric properties, and transforming them during logical normalization or evaluation.",
      "description_length": 517,
      "index": 6,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "LogicalForm.Std.NNF.Literal.Id.T",
      "library": "ocaml-logicalform",
      "description": "This module represents and manipulates literal identifiers in a logical formula, typically used in satisfiability or constraint-solving contexts. It provides operations for converting between integers and string representations, checking numeric properties like sign, and negating literals. The underlying type `t` is an abstract identifier for literals, supporting both positive and negative values.",
      "description_length": 400,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.Std.CNF.Clause.Literal",
      "library": "ocaml-logicalform",
      "description": "This module represents and manipulates propositional literals in a CNF solver using signed integer identifiers. It supports literal negation, evaluation against variable assignments, and conversion to and from strings and S-expressions. Concrete use cases include parsing logical formulas, evaluating clause satisfaction, and generating human-readable or machine-readable representations of literals.",
      "description_length": 400,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.Std.Term.Literal.Id",
      "library": "ocaml-logicalform",
      "description": "This module implements integer literal identifiers with bidirectional conversions to integers, strings, and S-expressions. It supports sign validation, negation, and sign extraction operations on logical term identifiers used in formal verification tasks. Concrete use cases include parsing and validating term IDs from strings or integers, converting them to and from S-expressions, and performing logical negation on term identifiers.",
      "description_length": 436,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.Std.NNF.Literal.Id",
      "library": "ocaml-logicalform",
      "description": "This module handles literal identifiers in logical formulas, particularly for satisfiability problems, by providing conversions between integers and strings, negation, and sign manipulation. It works with an abstract type `t` representing literal identifiers, supporting operations like parsing from strings, converting to and from integers, and logical negation. Concrete use cases include encoding propositional variables in SAT solvers and managing literal signs during formula transformation.",
      "description_length": 496,
      "index": 10,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "LogicalForm.Std.Clause.Literal.Id",
      "library": "ocaml-logicalform",
      "description": "This module represents literal identifiers in logical clauses with a private type `t`, supporting conversions to and from integers, strings, and S-expressions. It includes operations to negate literals, validate numeric properties, and extract or construct literal IDs. Use this module to handle literal IDs when implementing or interfacing with SAT solvers and logic engines.",
      "description_length": 376,
      "index": 11,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.Std.Literal.Id.T",
      "library": "ocaml-logicalform",
      "description": "This module defines a type `t` representing literal identifiers as integers, with functions to convert between integers, strings, and S-expressions. It provides validation checks for numeric properties like positivity and negativity, along with boolean checks and sign extraction. Use cases include managing literal identifiers in logical expressions, ensuring correct numeric ranges, and serializing/deserializing identifiers.",
      "description_length": 427,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.Std.DNF.Term.Literal",
      "library": "ocaml-logicalform",
      "description": "This module represents and manipulates individual literals in a Disjunctive Normal Form (DNF) logic system, supporting operations like logical negation, parsing from strings, conversion to and from S-expressions, and pretty-printing in infix or prefix notation. It works with a polymorphic variant type that includes boolean constants and literals composed of a sign and an identifier, along with an associated identifier module for validation and transformation. Concrete use cases include parsing and validating logical expressions, transforming literals during normalization, and evaluating literals against boolean assignments.",
      "description_length": 631,
      "index": 13,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.Std.UnNF.Literal.Id",
      "library": "ocaml-logicalform",
      "description": "This module provides functions to create, manipulate, and convert literal identifiers represented as signed non-zero integers. It supports operations such as negation, conversion to and from strings and S-expressions, and safe integer conversion with error handling. These identifiers are used to represent logical atoms in systems like theorem provers or logic solvers where signed integer IDs are required.",
      "description_length": 408,
      "index": 14,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.PrettyPrint.Style.Prefix",
      "library": "ocaml-logicalform",
      "description": "This module defines a configuration for prefix-based logical form formatting, specifying strings used to represent logical operators and constants. It includes fields for variable prefixes, truth values, and operators like negation, conjunction, and disjunction. Useful for customizing the textual representation of logical expressions in a consistent prefix notation.",
      "description_length": 368,
      "index": 15,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.Std.Index.T",
      "library": "ocaml-logicalform",
      "description": "This module defines a type `t` as an integer with additional validation and conversion functions. It supports operations to check numeric properties (positive, non-negative, etc.), convert between integers and strings, and serialize to and from S-expressions. It is used to represent and manipulate integer indices with strict sign constraints in logical expressions.",
      "description_length": 367,
      "index": 16,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "LogicalForm.Std.DNF.Term",
      "library": "ocaml-logicalform",
      "description": "This module represents logical terms in a Disjunctive Normal Form (DNF) system, supporting operations such as conjunction construction, validation, evaluation under boolean assignments, and conversion to and from S-expressions and human-readable string formats. It works with a polymorphic variant type that represents logical terms including literals, negations, boolean constants, and conjunctions, using an associated identifier module for literal management. Concrete use cases include constructing and evaluating DNF expressions, transforming logical terms during normalization, and serializing terms for storage or debugging.",
      "description_length": 631,
      "index": 17,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.Std.CNF.Clause",
      "library": "ocaml-logicalform",
      "description": "This module represents and manipulates CNF clauses in a logical formula solver using propositional literals encoded as signed integers. It supports clause evaluation against variable assignments, conversion to and from S-expressions and human-readable strings, and logical composition via disjunction. Concrete use cases include parsing and validating CNF formulas, checking clause satisfaction, and generating debug or interchange representations of clauses.",
      "description_length": 459,
      "index": 18,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.Std.Literal.Id",
      "library": "ocaml-logicalform",
      "description": "This module represents literal identifiers as integers with conversions to and from strings and S-expressions. It supports validation of numeric properties, sign extraction, and boolean negation operations. Use cases include managing identifiers in logical expressions, enforcing numeric constraints, and handling serialization/deserialization of identifier values.",
      "description_length": 365,
      "index": 19,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.Std.Term.Literal",
      "library": "ocaml-logicalform",
      "description": "This module represents logical literals with support for truth values, positive and negative term identifiers, and logical negation. It provides operations for parsing literals from strings, converting to and from S-expressions, and evaluating literals against boolean assignments. Use cases include processing logical formulas in formal verification, where literals must be validated, transformed, and evaluated efficiently.",
      "description_length": 425,
      "index": 20,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.Std.UnNF.Literal",
      "library": "ocaml-logicalform",
      "description": "This module defines a polymorphic variant type for representing logical literals, including boolean constants, positive and negative identifiers, and operations to manipulate these forms. It provides functions for converting literals to and from strings and S-expressions, negating literals, and evaluating them against a boolean array. The module is used in logic solvers and theorem provers to handle propositional logic expressions with signed integer identifiers.",
      "description_length": 467,
      "index": 21,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.Std.NNF.Literal",
      "library": "ocaml-logicalform",
      "description": "This module represents and manipulates logical literals in negation normal form, supporting operations such as negation, parsing from strings, and conversion to various string and S-expression formats. It works with an abstract type `t` that includes true, false, positive, and negative literals built from the `Id` module's identifiers. It is used to encode and evaluate logical formulas in SAT solvers and related tools, where precise literal handling and transformation are required.",
      "description_length": 486,
      "index": 22,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "LogicalForm.Std.Clause.Literal",
      "library": "ocaml-logicalform",
      "description": "This module defines and manipulates logical literals, supporting negation, parsing from and printing to strings and S-expressions, and evaluation in the context of boolean arrays. It works with a polymorphic variant type representing true, false, positive, and negative literals, along with associated identifier types. Use this module to construct and evaluate individual literals in SAT solving or logic-based computations.",
      "description_length": 425,
      "index": 23,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "LogicalForm.PrettyPrint.Style.Infix",
      "library": "ocaml-logicalform",
      "description": "This module defines a style configuration for pretty-printing logical forms using infix notation. It specifies strings for logical operators and constants, such as conjunction, disjunction, and negation. Use this to customize the textual representation of logical expressions in a readable, infix format.",
      "description_length": 304,
      "index": 24,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.Term.Make",
      "library": "ocaml-logicalform",
      "description": "This module represents logical terms composed of literals and conjunctions, supporting operations to construct, evaluate, and serialize these terms. It works with boolean arrays for evaluation and uses S-expressions for serialization, with support for both infix and prefix pretty-printing styles. Concrete use cases include building and evaluating logical expressions in symbolic reasoning systems or constraint solvers.",
      "description_length": 421,
      "index": 25,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.UnNF.Make",
      "library": "ocaml-logicalform",
      "description": "This module represents and manipulates logical formulas in a normalized form, supporting operations like conjunction, disjunction, and negation. It works with a custom type `t` that encodes logical expressions, including literals, negations, and nested logical combinations. Concrete use cases include evaluating logical expressions against boolean assignments, converting expressions to and from S-expressions, and pretty-printing formulas in infix or prefix notation for debugging or output.",
      "description_length": 493,
      "index": 26,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.Literal.Make",
      "library": "ocaml-logicalform",
      "description": "This module represents logical literals with identifiers, supporting negation, validation, and evaluation against boolean arrays. It provides direct conversions to and from strings and S-expressions, with customizable pretty-printing in both infix and prefix notation. Use cases include symbolic logic manipulation, formula evaluation, and parsing or serializing logical expressions.",
      "description_length": 383,
      "index": 27,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.Std.Term",
      "library": "ocaml-logicalform",
      "description": "This module represents logical terms including conjunctions, boolean constants, and literals with positive or negative identifiers. It supports parsing and evaluation of terms against boolean assignments, along with conversion to and from S-expressions and pretty-printed string representations. Use cases include formal verification tasks where logical expressions must be validated, evaluated, and transformed efficiently.",
      "description_length": 424,
      "index": 28,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "LogicalForm.DNF.Make",
      "library": "ocaml-logicalform",
      "description": "This module represents logical formulas in disjunctive normal form (DNF), supporting operations like conjunction (`and_`), disjunction (`or_`), and negation (`not_`). It works with terms of type `Term.t` and structured combinations of such terms using logical operators. Use cases include evaluating logical expressions over boolean variable assignments, converting formulas to readable string or S-expression representations, and parsing such representations back into logical structures.",
      "description_length": 489,
      "index": 29,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.Std.Clause",
      "library": "ocaml-logicalform",
      "description": "This module represents and processes logical clauses, including disjunctions, literals, and constants like true or false. It supports parsing from and printing to S-expressions, evaluating clauses over boolean arrays, and constructing clauses using disjunctions. Use it to build and evaluate logical expressions in SAT solvers or logic-based analysis tools.",
      "description_length": 357,
      "index": 30,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.Std.Index",
      "library": "ocaml-logicalform",
      "description": "This module defines a type `t` representing integers with strict sign constraints, supporting operations to validate numeric properties, convert between integers and strings, and serialize to and from S-expressions. It includes functions to create, inspect, and manipulate index values with guaranteed non-zero signs, primarily used to enforce correctness in logical expressions. Concrete use cases include managing variable indices in logical formulas where sign integrity must be preserved.",
      "description_length": 492,
      "index": 31,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.Std.CNF",
      "library": "ocaml-logicalform",
      "description": "This module represents and manipulates logical formulas in conjunctive normal form (CNF), using propositional literals encoded as signed integers. It provides operations for logical composition (`and_`, `or_`, `not_`), evaluation against variable assignments, validation, and conversion to and from S-expressions and human-readable strings. Concrete use cases include parsing and validating CNF formulas, checking formula satisfaction, and generating debug or interchange representations of formulas.",
      "description_length": 500,
      "index": 32,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.Std.Literal",
      "library": "ocaml-logicalform",
      "description": "This module manipulates logical literals that can represent boolean constants, identifiers, and their negations or positivity constraints. It provides operations for parsing, pretty-printing, evaluating, and validating these literals against boolean assignments. Use cases include symbolic reasoning in logical formulas, serialization to S-expressions, and string-based identifier handling with negation support.",
      "description_length": 412,
      "index": 33,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.Clause.Make",
      "library": "ocaml-logicalform",
      "description": "This module represents logical clauses as either a single literal or a disjunction of literals. It supports parsing and serialization to S-expressions, pretty-printing in infix or prefix notation, and evaluation given a boolean assignment. Use cases include building and evaluating propositional logic formulas in conjunctive normal form (CNF) solvers or symbolic reasoning systems.",
      "description_length": 382,
      "index": 34,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.Std.NNF",
      "library": "ocaml-logicalform",
      "description": "This module manipulates logical formulas in negation normal form (NNF), supporting operations like conjunction, disjunction, and negation. It works with a recursive algebraic type `t` representing logical expressions composed of literals, constants, and compound terms. It is used to construct, evaluate, and serialize logical formulas for applications such as SAT solving, formal verification, and logic-based analysis tools.",
      "description_length": 426,
      "index": 35,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.PrettyPrint.Style",
      "library": "ocaml-logicalform",
      "description": "This module provides style configurations for pretty-printing logical forms using either infix or prefix notation. It defines customizable string representations for logical operators, constants, and variables, allowing control over the formatting of logical expressions. Use it to generate human-readable or machine-parsable output for formal logic expressions in different notational styles.",
      "description_length": 393,
      "index": 36,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.Index.Make",
      "library": "ocaml-logicalform",
      "description": "This module defines a type `t` that wraps values of type `T.t` with a sign, representing logical identifiers that can be negated. It provides functions to convert between integers, strings, and these signed identifiers, along with operations to invert the sign. Use cases include representing logical variables in formulas and handling sign-sensitive indexing in formal verification tasks.",
      "description_length": 389,
      "index": 37,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.IdBase.Make",
      "library": "ocaml-logicalform",
      "description": "This module implements integer-like identifiers with support for sign validation, integer and string conversions, and logical negation. It works with a base type `B.t` that represents the underlying integer-like values. Concrete use cases include managing identifiers that require sign constraints, such as indexing or arithmetic operations with strict positivity requirements.",
      "description_length": 377,
      "index": 38,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.CNF.Make",
      "library": "ocaml-logicalform",
      "description": "This module represents logical formulas in conjunctive normal form (CNF), supporting operations to construct and manipulate formulas using conjunctions, disjunctions, and negations of clauses. It works with boolean arrays for evaluation and provides pretty-printing in both infix and prefix styles. Concrete use cases include validating CNF structures, evaluating formulas against variable assignments, and serializing/deserializing formulas for storage or communication.",
      "description_length": 471,
      "index": 39,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.Std.UnNF",
      "library": "ocaml-logicalform",
      "description": "This module represents logical formulas in a normalized form, supporting operations like conjunction, disjunction, and negation. It works with polymorphic variant types encoding logical expressions, including boolean constants, literals, and nested logical operators. Used in logic solvers and theorem provers to evaluate and manipulate propositional logic expressions using signed integer identifiers.",
      "description_length": 402,
      "index": 40,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.Std.DNF",
      "library": "ocaml-logicalform",
      "description": "This module implements a system for constructing, validating, and evaluating logical expressions in Disjunctive Normal Form (DNF), using a polymorphic variant type that supports literals, negations, boolean constants, and logical connectives. It provides operations for building conjunctions and disjunctions, evaluating expressions under boolean assignments, and serializing terms to and from S-expressions and human-readable strings. Concrete use cases include normalizing logical formulas, evaluating DNF expressions against truth assignments, and persisting or inspecting logical terms in a readable format.",
      "description_length": 611,
      "index": 41,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "LogicalForm.NNF.Make",
      "library": "ocaml-logicalform",
      "description": "This module represents and manipulates logical formulas in negation normal form (NNF), supporting construction via `and_`, `or_`, and `not_`, and evaluation given a boolean assignment. It works with a custom type `t` that encodes literals, disjunctions, and conjunctions, along with S-expressions for serialization. Concrete use cases include logical reasoning tasks, formula validation, and pretty-printing logical expressions in infix or prefix notation.",
      "description_length": 456,
      "index": 42,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.Form",
      "library": "ocaml-logicalform",
      "description": "This module defines operations for constructing and manipulating logical forms, including functions to create propositions, apply logical connectives, and evaluate truth values. It works with abstract data types representing logical expressions, variables, and truth assignments. Concrete use cases include building symbolic logic representations for theorem proving and evaluating logical expressions under specific variable assignments.",
      "description_length": 438,
      "index": 43,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.Clause",
      "library": "ocaml-logicalform",
      "description": "This module represents logical clauses as either a single literal or a disjunction of literals, supporting parsing from and serialization to S-expressions. It provides pretty-printing in infix or prefix notation and evaluates clauses under a given boolean assignment. Use cases include constructing and evaluating propositional logic formulas in CNF solvers or symbolic reasoning systems.",
      "description_length": 388,
      "index": 44,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.Literal",
      "library": "ocaml-logicalform",
      "description": "This module represents logical literals with identifiers, supporting operations for negation, validation, and evaluation against boolean arrays. It provides direct conversions to and from strings and S-expressions, with customizable pretty-printing in both infix and prefix notation. Use cases include symbolic logic manipulation, formula evaluation, and parsing or serializing logical expressions.",
      "description_length": 398,
      "index": 45,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.Std",
      "library": "ocaml-logicalform",
      "description": "This module organizes a suite of components for constructing, manipulating, and evaluating logical expressions in various normal forms, including CNF, DNF, NNF, and UnNF. Each submodule handles specific logical structures such as literals, clauses, terms, and normalized formulas, with support for evaluation, parsing, and serialization to S-expressions or strings. Use cases include building SAT solvers, performing formal verification, and implementing logic-based analysis tools where structured logical manipulation and validation are critical.",
      "description_length": 548,
      "index": 46,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.Properties",
      "library": "ocaml-logicalform",
      "description": "This module defines type classes for logical operations including conjunction, disjunction, and negation. It specifies interfaces for executable forms, validation requirements, and combinable logical structures. Use these abstractions to implement consistent logical manipulations across different expression types such as propositional formulas or constraint systems.",
      "description_length": 368,
      "index": 47,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "LogicalForm.IdBase",
      "library": "ocaml-logicalform",
      "description": "Implements integer-like identifiers with sign validation, conversion between integers and strings, and logical negation. Works with a base type `B.t` to represent underlying integer-like values. Useful for managing identifiers requiring strict sign constraints in indexing or arithmetic contexts.",
      "description_length": 296,
      "index": 48,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.PrettyPrint",
      "library": "ocaml-logicalform",
      "description": "This module implements pretty-printing functionality for logical forms using configurable styles defined in the Style submodule. It supports infix and prefix notation with customizable string representations for logical operators, constants, and variables. Use it to generate readable or structured output for formal logic expressions in different notational formats.",
      "description_length": 367,
      "index": 49,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.UnNF",
      "library": "ocaml-logicalform",
      "description": "This module represents logical formulas in normalized form with support for conjunction, disjunction, and negation operations. It works with a custom algebraic data type `t` that encodes literals, negations, and nested logical expressions. Use cases include evaluating formulas under boolean assignments, converting to and from S-expressions, and pretty-printing in infix or prefix notation.",
      "description_length": 391,
      "index": 50,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.NNF",
      "library": "ocaml-logicalform",
      "description": "This module represents and manipulates logical formulas in negation normal form (NNF), supporting construction via `and_`, `or_`, and `not_`, and evaluation given a boolean assignment. It works with a custom type `t` that encodes literals, disjunctions, and conjunctions, along with S-expressions for serialization. Concrete use cases include logical reasoning tasks, formula validation, and pretty-printing logical expressions in infix or prefix notation.",
      "description_length": 456,
      "index": 51,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.Index",
      "library": "ocaml-logicalform",
      "description": "This module defines a type `t` that wraps values of type `T.t` with a sign (`Pos` or `Neg`), enabling representation of logical identifiers that can be negated. It provides functions to convert between integers, strings, and these signed identifiers, along with operations to invert the sign. Use cases include representing logical variables in formulas and handling sign-sensitive indexing in formal verification tasks.",
      "description_length": 420,
      "index": 52,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.CNF",
      "library": "ocaml-logicalform",
      "description": "This module represents logical formulas in conjunctive normal form (CNF), supporting construction and manipulation through conjunctions, disjunctions, and negations of clauses. It operates on boolean arrays for formula evaluation and includes pretty-printing in infix and prefix formats. It is used for validating CNF structures, evaluating formulas against variable assignments, and serializing or deserializing formulas for storage or transmission.",
      "description_length": 450,
      "index": 53,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.DNF",
      "library": "ocaml-logicalform",
      "description": "This module represents logical formulas in disjunctive normal form, supporting conjunction, disjunction, and negation operations on terms of type `Term.t`. It enables evaluating formulas over boolean variable assignments and converting formulas to and from string or S-expression representations. Use cases include symbolic reasoning, logic evaluation, and parsing or printing structured logical expressions.",
      "description_length": 408,
      "index": 54,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.Exceptions",
      "library": "ocaml-logicalform",
      "description": "This module defines an exception for reporting invalid S-expressions during parsing or processing. It provides the `invalid_sexp_exception` function, which constructs an exception carrying context and the problematic S-expression. This is used to signal errors when parsing malformed logical forms.",
      "description_length": 298,
      "index": 55,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm.Term",
      "library": "ocaml-logicalform",
      "description": "This module constructs and manipulates logical terms composed of literals and conjunctions, supporting evaluation over boolean arrays and serialization via S-expressions. It enables building and evaluating logical expressions in symbolic reasoning systems or constraint solvers, with support for infix and prefix pretty-printing styles.",
      "description_length": 336,
      "index": 56,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LogicalForm",
      "library": "ocaml-logicalform",
      "description": "This module provides data structures and operations for constructing, manipulating, and evaluating logical formulas in various normal forms such as CNF, DNF, NNF, and UnNF. It works with boolean arrays, S-expressions, and custom algebraic types to represent literals, clauses, terms, and full logical expressions. Concrete use cases include implementing SAT solvers, performing formal verification, and building logic-based analysis tools that require structured manipulation and validation of propositional formulas.",
      "description_length": 517,
      "index": 57,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 58,
    "meaningful_modules": 58,
    "filtered_empty_modules": 0,
    "retention_rate": 1.0
  },
  "statistics": {
    "max_description_length": 631,
    "min_description_length": 296,
    "avg_description_length": 430.2241379310345,
    "embedding_file_size_mb": 0.8410186767578125
  }
}