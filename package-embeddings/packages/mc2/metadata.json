{
  "package": "mc2",
  "embedding_model": "Qwen/Qwen3-Embedding-8B",
  "embedding_dimension": 4096,
  "total_modules": 62,
  "creation_timestamp": "2025-08-15T15:14:16.927323",
  "modules": [
    {
      "module_path": "Mc2_backend.Dot.Make",
      "library": "mc2.backend",
      "description": "This module implements a functor for generating DOT-formatted graph representations of proofs, primarily used for visualization purposes. It takes a parameter module `A` that defines the specific graph structure and node labeling conventions. The resulting module provides a `print` function that outputs the proof graph to a formatter, compatible with Graphviz tools for rendering images.",
      "description_length": 389,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mc2_backend.Dot.Default",
      "library": "mc2.backend",
      "description": "This module provides default implementations for printing proof elements in the DOT graph format, specifically handling atomic formulas and proof tree leaves like hypotheses, lemmas, and assumptions. It works with `Mc2_core.Clause.t` and `Mc2_core.Atom.t` types, producing formatted strings suitable for DOT labels. It is used to generate visual representations of proofs using Graphviz by converting proof structures into labeled graph nodes.",
      "description_length": 443,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mc2_backend.Backend_intf",
      "library": "mc2.backend",
      "description": "This module defines the interface for proof export functionality, specifying operations required to serialize and export proofs in various formats. It works with proof data structures and output targets such as files or streams. Concrete use cases include implementing backends for different proof formats like JSON, XML, or custom binary representations.",
      "description_length": 355,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mc2_backend.Dot",
      "library": "mc2.backend",
      "description": "This module exports proof structures to the DOT graph format for visualization with Graphviz. It includes a functor `Make` that generates graph representations using custom node labeling logic, and a `Default` module that handles atomic formulas and proof tree leaves. It operates on `Mc2_core.Clause.t` and `Mc2_core.Atom.t` types to produce labeled graph nodes for proof visualization.",
      "description_length": 387,
      "index": 3,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Mc2_backend",
      "library": "mc2.backend",
      "description": "This module implements proof export backends for serializing proof data to various output formats. It includes an interface module for defining proof serialization operations and a DOT backend that generates graph visualizations of proof structures. The DOT backend specifically works with `Mc2_core.Clause.t` and `Mc2_core.Atom.t` types to produce labeled graph nodes using custom or default labeling logic.",
      "description_length": 408,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mc2_unin_sort",
      "library": "mc2.unin_sort",
      "description": "This module implements support for uninterpreted sorts in a solver-agnostic way. It provides operations to declare uninterpreted sorts, construct terms of such sorts, and compare terms for equality. These capabilities are essential for modeling abstract data types or symbolic values in formal verification tasks.",
      "description_length": 313,
      "index": 5,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Mc2_uf",
      "library": "mc2.uf",
      "description": "This module supports declaring uninterpreted symbols, applying constants to arguments, and converting constants into terms. It operates on identifiers, types, and terms within the Mc2_core framework. Concrete use cases include building and manipulating symbolic expressions during theorem proving or program analysis tasks.",
      "description_length": 323,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mc2_dimacs.Plugin_sat",
      "library": "mc2.dimacs",
      "description": "This module defines a plugin that maps DIMACS atoms to integers for SAT solving. It provides a service key `k_atom` to convert atoms to integers and a plugin factory to integrate with the core system. It is used to interface with SAT solvers by encoding logical atoms into numeric form.",
      "description_length": 286,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mc2_dimacs",
      "library": "mc2.dimacs",
      "description": "This module parses DIMACS files into logical clauses for SAT solving, converting atoms to integers via a plugin interface. It provides functions to process clauses, solve problems, and print results with options for configuration. Use cases include reading SAT benchmarks, encoding logic problems, and integrating with SAT solvers.",
      "description_length": 331,
      "index": 8,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Mc2_lra.LE.Infix",
      "library": "mc2.lra",
      "description": "This module defines infix operators for arithmetic operations on linear expressions. It supports addition, subtraction, and scalar multiplication of linear expressions represented by the type `Mc2_lra.LE.t`. These operations are useful for constructing and manipulating linear constraints in formal verification or constraint-solving contexts.",
      "description_length": 343,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mc2_lra.LE",
      "library": "mc2.lra",
      "description": "This module supports the construction, transformation, and evaluation of linear expressions composed of numeric coefficients (`Q.t`) and terms (`Mc2_core.term`), enabling arithmetic operations (addition, negation, scaling), term-level inspection, and simplification. It is designed for symbolic manipulation of linear combinations, such as in optimization or constraint-solving contexts, and includes operator-based syntax for intuitive expression building.",
      "description_length": 457,
      "index": 10,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mc2_lra",
      "library": "mc2.lra",
      "description": "This module implements linear rational arithmetic operations, including the construction and manipulation of linear expressions with rational coefficients and terms. It provides functions to build and evaluate constraints (equality, less-than-or-equal, less-than) over these expressions, supporting symbolic transformations and simplifications. Concrete use cases include constraint solving, optimization problem formulation, and formal verification tasks involving linear inequalities.",
      "description_length": 486,
      "index": 11,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mc2_propositional.F",
      "library": "mc2.propositional",
      "description": "This module represents and manipulates propositional logic formulas. It supports logical operations such as conjunction, disjunction, negation, implication, and equivalence, and allows conversion of formulas into conjunctive normal form (CNF). The module works with atomic propositions, boolean formulas, and combinators like `And`, `Or`, and `Not`, enabling concrete use cases such as logical reasoning, constraint solving, and formal verification tasks.",
      "description_length": 455,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mc2_propositional",
      "library": "mc2.propositional",
      "description": "This module provides logical operations like conjunction, disjunction, negation, implication, and equivalence for propositional formulas. It supports conversion to conjunctive normal form (CNF) via the `k_cnf` service and generation of fresh atomic propositions via `k_fresh`. Concrete use cases include formal verification, constraint solving, and logical reasoning tasks involving boolean formulas.",
      "description_length": 400,
      "index": 13,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mc2_smtlib.Typecheck.Make",
      "library": "mc2.smtlib",
      "description": "This module converts terms and statements from the input AST to the internal representation used by the SMT solver. It supports transforming logical expressions into a normalized form suitable for constraint solving. Use it when translating high-level specifications into SMT queries for verification or analysis tasks.",
      "description_length": 319,
      "index": 14,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mc2_smtlib.Make",
      "library": "mc2.smtlib",
      "description": "Implements parsing and typechecking for SMT-LIB input, converting strings or stdin into typed statement lists. Processes individual statements with configurable options for garbage collection, proof output, model printing, and resource limits. Designed for use in SMT solvers or formal verification tools where SMT-LIB compatibility is required.",
      "description_length": 345,
      "index": 15,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mc2_smtlib.Typecheck",
      "library": "mc2.smtlib",
      "description": "This module provides functions to convert terms and statements from the input AST into an internal representation suitable for SMT solving. It normalizes logical expressions, preparing them for constraint solving. Use it to translate high-level specifications into SMT queries for verification or analysis tasks.",
      "description_length": 312,
      "index": 16,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Mc2_smtlib",
      "library": "mc2.smtlib",
      "description": "This module processes SMTLib-2 input with functions to parse, type-check, and prepare logical expressions for SMT solving. It works with abstract syntax trees representing SMT statements and terms, converting them into a normalized internal form. Use it to integrate SMTLib-2 compatibility into solvers or verification tools, enabling tasks like constraint solving, model generation, or proof checking.",
      "description_length": 402,
      "index": 17,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mc2_core.Term.Watch2",
      "library": "mc2.core",
      "description": "This module implements a watchlist data structure for terms in a solver, allowing efficient tracking and updating of dependencies during constraint solving. It supports operations to create and initialize watchlists, iterate over terms, and update watches in response to term assignments. Use cases include managing clause dependencies in a SAT solver, where watchlists help efficiently propagate unit clauses and detect conflicts.",
      "description_length": 431,
      "index": 18,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mc2_core.ID.Smtlib",
      "library": "mc2.core",
      "description": "This module provides a function `pp` for pretty-printing identifiers in SMT-LIB format. It works with the abstract identifier type `Mc2_core.ID.t`. A concrete use case is generating SMT-LIB output for formal verification tools.",
      "description_length": 227,
      "index": 19,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mc2_core.Term.Term_allocator",
      "library": "mc2.core",
      "description": "Allocates and manages terms in a theory, providing functions to create (`make`) and delete terms, iterate over all terms, and perform garbage collection (`gc_all`). Works directly with term views, types, and solver-specific term representations. Useful for maintaining term lifetimes and ensuring efficient memory use in SMT solver implementations.",
      "description_length": 348,
      "index": 20,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Mc2_core.Type.TC",
      "library": "mc2.core",
      "description": "This module defines typeclass instances for solver operations, including `make` to construct a typeclass with decision, equality, and state initialization functions. It works with terms and values from the solver types, supporting lazy initialization through `lazy_make`, `lazy_from_val`, and `lazy_complete`. Concrete use cases include setting up type-specific behavior for constraint solving and term manipulation in a solver context.",
      "description_length": 436,
      "index": 21,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mc2_core.Service.Key",
      "library": "mc2.core",
      "description": "This module provides functions to create and manipulate service keys, which are used to uniquely identify and access services registered by plugins. It operates on a polymorphic type `t` that represents a service key, primarily working with strings to identify key names. Concrete use cases include generating uniquely named service keys with `make` or formatted names with `makef`, and retrieving the name of a key with `name`.",
      "description_length": 428,
      "index": 22,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Mc2_core.Type.Alloc",
      "library": "mc2.core",
      "description": "This module implements a type allocation system that maps type views to concrete type representations. It provides the `make` function to construct type instances from views, leveraging the associated `T` module for type-specific behavior. It is used to manage type instantiation in contexts like type checking or compilation pipelines where views dictate how types are resolved and represented.",
      "description_length": 395,
      "index": 23,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mc2_core.Clause.Tbl",
      "library": "mc2.core",
      "description": "This module implements a mutable hash table for efficient key-value storage and transformation, with keys restricted to a specialized type that supports imperative updates, bulk operations, and functional queries. It enables atomic modifications (increments, decrements), safe value retrieval with defaults, and seamless conversion to sequences or lists, while handling duplicate keys through customizable combination logic. Typical applications include frequency counting, dynamic state management, and scenarios requiring high-performance lookups paired with iterative refinement of key-value pairs.",
      "description_length": 601,
      "index": 24,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mc2_core.Atom.Set",
      "library": "mc2.core",
      "description": "This module implements ordered set operations for elements of type `Atom.t`, supporting creation, union, intersection, and difference alongside ordered traversal via iterators and sequences. It emphasizes safe access patterns with optional return types, predicate-based searches, and transformations to/from lists and strings, leveraging `Ord.compare` to enforce uniqueness and ordering. Typical use cases include managing sorted collections, performing set algebra, and serializing sets for configuration or analysis tasks.",
      "description_length": 524,
      "index": 25,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mc2_core.Clause.Set",
      "library": "mc2.core",
      "description": "This module implements immutable ordered collections of elements, supporting set algebra operations like union, intersection, and difference alongside predicate-driven transformations such as `filter_map` and `partition`. It works with sorted sets of homogeneous elements, providing safe accessors via `option`-typed queries and conversion utilities to and from lists, sequences, and string representations. Typical applications include managing logical clauses in formal verification systems, implementing symbolic reasoning algorithms, and handling finite domain constraints with ordered element processing.",
      "description_length": 609,
      "index": 26,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mc2_core.Solver.Sat_state",
      "library": "mc2.core",
      "description": "This module provides functions to query and manipulate the state of a SAT solver, including evaluating atoms, retrieving assignment levels, iterating through the trail of decisions, and extracting or validating a model. It operates on the solver's state type and works with atoms, terms, and assignments. Concrete use cases include checking the satisfiability of a formula, tracing the decision path, and inspecting variable assignments during or after solving.",
      "description_length": 461,
      "index": 27,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mc2_core.Term.Bool",
      "library": "mc2.core",
      "description": "This module represents boolean terms and provides operations to inspect and manipulate atomic propositions, including checking polarities, retrieving assigned atoms, and constructing equality and inequality constraints. It works with the `t` type representing boolean expressions and interacts with `atom` and `term` types from the solver's core structures. Concrete use cases include extracting positive or negative atoms from a boolean term, verifying if both polarities appear in the same clause, and creating equality or inequality atoms between terms.",
      "description_length": 556,
      "index": 28,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mc2_core.Value.TC",
      "library": "mc2.core",
      "description": "This module defines a type class for values with custom equality, pretty-printing, and hashing operations. It works with the `t` type representing value classifiers, using `Mc2_core.Value.view` as the underlying data structure. Concrete use cases include defining type-specific behaviors for values in interpreters or compilers where standard equality and hashing are insufficient.",
      "description_length": 381,
      "index": 29,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mc2_core.Service.Registry",
      "library": "mc2.core",
      "description": "This module implements a service registry for storing and retrieving services by key. It supports operations to create a registry, register a service with a specific key, and look up services either optionally or with an exception if missing. The registry works with service keys of type `'a Mc2_core.Service.Key.t` and stores services of arbitrary types indexed by these keys. A concrete use case is managing a collection of services in a dependency injection system, where services need to be dynamically registered and accessed by their unique keys.",
      "description_length": 552,
      "index": 30,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mc2_core.Proof.H",
      "library": "mc2.core",
      "description": "This module provides a high-performance hashtable implementation optimized for resolution proof analysis, using clauses as keys and supporting imperative updates, bulk operations, and value aggregation with custom combinators. It operates on a specialized clause-keyed hashtable type (`t`) designed for temporary use during proof inspection, enabling efficient tracking of clause metadata, frequency counting, and transformation of proof data through folds and iterators. Key applications include aggregating clause statistics, merging values during bulk updates, and interfacing with proof traversal pipelines where temporary key-value mappings are required.",
      "description_length": 659,
      "index": 31,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mc2_core.Plugin.Factory",
      "library": "mc2.core",
      "description": "This module defines a GADT for plugin factories that specify how plugins are constructed, including their dependencies and priority. It supports operations to create factories with custom build logic and compare them based on priority. Factories are used to instantiate plugins with unique IDs and resolved service dependencies at runtime.",
      "description_length": 339,
      "index": 32,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mc2_core.ID.Set",
      "library": "mc2.core",
      "description": "This module implements ordered set operations for elements of type `Mc2_core.ID.t`, maintaining strict ordering via `Ord.compare`. It supports set algebra (union, intersection, difference), ordered traversal (iteration, folding, mapping), and transformations (filtering, partitioning, sequence conversion), with safe access to extremal elements and string formatting. Designed for scenarios requiring ordered data processing, such as filtered set traversal, collection conversion, or ordered element retrieval in analysis pipelines.",
      "description_length": 532,
      "index": 33,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Mc2_core.Term.Set",
      "library": "mc2.core",
      "description": "This module implements immutable sets of ordered elements, supporting functional transformations like union, intersection, and difference, along with ordered iteration, filtering, and safe element access via comparison-based sorting. It works with a concrete set type `t` containing elements of type `elt`, which are organized using a total ordering function `Ord.compare`. Typical applications include managing collections of terms requiring deterministic ordering, such as static analysis data structures or symbolic computation pipelines, where immutability and precise element traversal are critical for correctness.",
      "description_length": 620,
      "index": 34,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mc2_core.Lemma.TC",
      "library": "mc2.core",
      "description": "This module defines a type `t` representing a term context used in lemma processing. It provides the `make` function to create a term context with a custom pretty-printer for terms. This context is used to manage and manipulate term representations during proof construction or term rewriting tasks.",
      "description_length": 299,
      "index": 35,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Mc2_core.Term.TC",
      "library": "mc2.core",
      "description": "This module defines typeclasses for terms in a solver, supporting operations like initialization, watch updating, deletion, subterm traversal, and evaluation. It works with terms and their views, enabling concrete behaviors for solver actions such as constraint propagation and term inspection. Use cases include defining custom term behavior in a constraint solver, such as tracking dependencies or evaluating expressions during solving.",
      "description_length": 438,
      "index": 36,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mc2_core.Solver.Unsat_state",
      "library": "mc2.core",
      "description": "This module provides operations to retrieve the unsatisfiable clause and generate a proof of contradiction from a solver state indicating unsatisfiability. It works with the solver's state type specialized to the unsat case and related proof structures. Concrete use cases include extracting conflict clauses for debugging and constructing formal proofs of inconsistency in logical formulas.",
      "description_length": 391,
      "index": 37,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mc2_core.Term.Map",
      "library": "mc2.core",
      "description": "This module supports key-based insertion, deletion, ordered traversal, and bulk transformation of polymorphic map structures ordered by Term keys, with operations like `merge`, `fold`, and `mapi` enabling functional manipulation. It provides safe accessors, conditional merging, and conversion from iterable formats (lists, sequences) to handle Term-keyed associations, including handling duplicates via user-defined logic. Such maps are suited for symbolic computation, structured data processing, or scenarios requiring ordered key-value hierarchies, like managing term-based symbol tables or hierarchical configurations.",
      "description_length": 623,
      "index": 38,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Mc2_core.ID.Map",
      "library": "mc2.core",
      "description": "This module provides functional map operations for key-value associations with `Mc2_core.ID.t` keys and arbitrary values, supporting modification, traversal, and transformations with safe variants like optional value retrieval. It enables ordered map traversal, merging with custom combination functions, and conversion between maps, sequences, and lists, making it suitable for managing ID-indexed data structures and resolving hierarchical configurations with duplicate keys.",
      "description_length": 477,
      "index": 39,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mc2_core.Tseitin.Make",
      "library": "mc2.core",
      "description": "This module implements Tseitin's algorithm to convert boolean formulas into equi-satisfiable CNF representations, working with atomic formulas provided by a parameter module. It supports construction of boolean expressions using logical connectives (And, Or, Not, Xor, Imply, Equiv) and converts them into CNF via the `cnf` function, which is suitable for input to SAT or SMT solvers. Concrete use cases include encoding constraint satisfaction problems and verifying logical equivalences in automated reasoning tools.",
      "description_length": 518,
      "index": 40,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mc2_core.Term.Watch1",
      "library": "mc2.core",
      "description": "This module implements a watchlist data structure for terms in a solver, allowing terms to track dependencies and efficiently update their state when watched terms are assigned. It supports operations to create, iterate over, and manage watchlists, with specific handling for initialization and updates triggered by term assignments. Use cases include constraint propagation in SAT or SMT solvers, where terms must react to changes in other terms they depend on.",
      "description_length": 462,
      "index": 41,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Mc2_core.Term.Tbl",
      "library": "mc2.core",
      "description": "This module implements imperative hash tables for term-keyed collections with polymorphic values, supporting efficient insertion, lookup, and in-place modification. It offers bulk operations for sequence/iterator integration, atomic counter adjustments, and customizable conflict resolution during merges, while enabling functional transformations through folds, filters, and list conversions. Typical use cases include term frequency counting, dynamic key-value aggregation from streams, and stateful processing of heterogeneous term mappings with controlled value coalescing.",
      "description_length": 577,
      "index": 42,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Mc2_core.ID.Tbl",
      "library": "mc2.core",
      "description": "This module implements a hash table specialized for keys of type `Mc2_core.ID.t`, offering operations for safe value retrieval, bulk updates from sequences, value transformations, and element counting. It supports conversions between hash tables and lists/sequences, along with utilities for key/value inspection, iteration, and customizable pretty-printing. Typical use cases include tracking identifier-to-value mappings with efficient lookups, aggregating counts from iterable sources, and transforming stored values through functional updates.",
      "description_length": 547,
      "index": 43,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mc2_core.Term",
      "library": "mc2.core",
      "description": "The module provides operations for managing terms within a solver context, including term traversal, constraint propagation, garbage collection, and metadata tracking (e.g., decision levels, ownership). It operates on data structures such as `Term.t`, solver-specific fields, and ordered collections like sets, maps, and tables, enabling use cases in SMT solving, symbolic computation, and static analysis. Key patterns involve solver state management, heuristic-driven term manipulation, and efficient imperative/functional transformations over term-structured data.",
      "description_length": 567,
      "index": 44,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mc2_core.Service",
      "library": "mc2.core",
      "description": "This module defines services as features provided by plugins, using keys to uniquely identify and access them. It supports creating and manipulating service keys with string-based identifiers and maintaining a registry to store and retrieve services of arbitrary types. Concrete use cases include dynamically registering and accessing services such as term builders or E-matching functions in a plugin-based system.",
      "description_length": 415,
      "index": 45,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mc2_core.Type",
      "library": "mc2.core",
      "description": "This module implements type representations and operations for solver-driven type manipulation, including equality, comparison, and hashing for type values, alongside utilities to construct and inspect types using views and identifiers. It supports decision procedures, term equality, and state initialization for non-boolean types, with concrete use in constraint solving and term rewriting systems. The TC submodule defines typeclass instances that specify solver behavior per type, while Alloc handles type instantiation from views, used in type resolution during compilation or analysis pipelines.",
      "description_length": 601,
      "index": 46,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mc2_core.Value",
      "library": "mc2.core",
      "description": "This module defines a concrete type `t` for values used in models, supporting boolean checks, negation, and structured views into solver-specific representations. It provides operations for equality, hashing, pretty-printing, and conversion to and from booleans, as well as constructing values from solver types. Use cases include representing and manipulating logical values in a solver or interpreter where precise value identity and transformation are required.",
      "description_length": 464,
      "index": 47,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mc2_core.ID",
      "library": "mc2.core",
      "description": "This module implements a unique identifier system with opaque `t` values, created from strings or formatted inputs, and supports identity checks, comparisons, and string/SMT-LIB representations. It provides direct access to identifier internals via `id` and `to_string`, while ensuring type-safe handling through equality, hashing, and printing functions. Concrete use cases include managing symbol tables, tracking program entities in compilers, and generating solver-friendly output for formal verification tools.",
      "description_length": 515,
      "index": 48,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Mc2_core.Statement",
      "library": "mc2.core",
      "description": "This module represents a variety of SMT solver commands and statements, including logic and option settings, type and function declarations, term definitions, and assertion clauses. It works with solver-specific types like `ty` and `term`, along with identifiers and atoms. Concrete use cases include constructing and printing SMT-LIB compliant statements for interaction with SMT solvers.",
      "description_length": 389,
      "index": 49,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Mc2_core.Bound_var",
      "library": "mc2.core",
      "description": "This module represents bound variables with identifiers and types, supporting pretty-printing with or without type annotations. It integrates bound variables into terms via a service key that converts them into terms. Useful for constructing and manipulating terms in a solver context where typed variables are bound in expressions.",
      "description_length": 332,
      "index": 50,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mc2_core.Actions",
      "library": "mc2.core",
      "description": "This module provides actions for interacting with a solver during plugin execution, enabling clause propagation, conflict generation, and backtrack handling. It operates on solver terms, atoms, clauses, and lemmas, allowing plugins to assert new constraints, explain assignments, and detect inconsistencies. Concrete use cases include implementing theory solvers that propagate term evaluations, generate conflict clauses during unsatisfiability, and respond to backtracking events.",
      "description_length": 482,
      "index": 51,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mc2_core.Proof",
      "library": "mc2.core",
      "description": "This module implements resolution proof construction and analysis with operations to build proofs from clauses, extract unsat cores, and traverse proof trees. It works with resolution proofs represented as trees of nodes, each containing a conclusion clause and a step with parent links and explanations. Concrete use cases include verifying proof steps during SAT solving, extracting minimal unsatisfiable subsets of clauses, and debugging resolution proofs through traversal and inspection of individual nodes.",
      "description_length": 512,
      "index": 52,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mc2_core.Plugin",
      "library": "mc2.core",
      "description": "This module defines plugin factories using a GADT to specify construction logic, dependencies, and priority. It supports creating and comparing factories that build plugins with unique IDs and resolved service dependencies at runtime. Use cases include instantiating solver plugins that contribute custom types or terms based on their declared dependencies and priority.",
      "description_length": 370,
      "index": 53,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mc2_core.Builtins",
      "library": "mc2.core",
      "description": "This module defines fundamental boolean terms and a plugin factory for extending core functionality. It provides direct access to `k_true` and `k_false`, which represent trivial boolean terms used in solver logic, and `plugin`, which serves as a factory for creating new plugins. These values are used to build and register custom solver components within the system.",
      "description_length": 367,
      "index": 54,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mc2_core.Clause",
      "library": "mc2.core",
      "description": "This module provides operations to construct and manage clauses with atomic propositions, tracking states like attachment and deletion while supporting garbage collection. It works with clauses containing atoms, premises, and metadata, alongside optimized mutable hash tables (`Tbl`) and ordered sets (`Set`) for efficient data manipulation. These structures are critical for formal verification tasks like SAT solving, enabling symbolic reasoning and state management in automated theorem proving workflows.",
      "description_length": 508,
      "index": 55,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mc2_core.Tseitin",
      "library": "mc2.core",
      "description": "This module implements Tseitin's algorithm to convert boolean formulas into equi-satisfiable CNF representations, working with atomic formulas provided by a parameter module. It supports construction of boolean expressions using logical connectives (And, Or, Not, Xor, Imply, Equiv) and converts them into CNF via the `cnf` function, which is suitable for input to SAT or SMT solvers. Concrete use cases include encoding constraint satisfaction problems and verifying logical equivalences in automated reasoning tools.",
      "description_length": 518,
      "index": 56,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mc2_core.Atom",
      "library": "mc2.core",
      "description": "This module provides operations for manipulating atomic values with metadata like decision levels and truth assignments, enabling stateful tracking during logical reasoning. It works with `Atom.t` values and ordered sets for efficient collection operations, supporting semantic checks such as satisfiability and absurdity. These features are used in SAT solvers for constraint propagation and clause management.",
      "description_length": 411,
      "index": 57,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mc2_core.Error",
      "library": "mc2.core",
      "description": "This module provides functions for formatting and raising error messages with contextual information. It works with format strings and custom error-handling functions to construct detailed error reports. Concrete use cases include generating type-checking errors with source location details or formatting parser errors with expected token information.",
      "description_length": 352,
      "index": 58,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mc2_core.Solver",
      "library": "mc2.core",
      "description": "This module manages a SAT solver instance with support for adding clauses, terms, and assumptions, and determining satisfiability. It works with atoms, clauses, and solver states, enabling concrete tasks like checking formula validity, extracting unsatisfiable cores, and inspecting assignments. Use cases include formal verification, constraint solving, and debugging logical inconsistencies.",
      "description_length": 393,
      "index": 59,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mc2_core.Lemma",
      "library": "mc2.core",
      "description": "This module represents and manipulates lemmas used in theorem proving, providing a structured view for lemma construction and pretty-printing. It works with term contexts and lemma views to support creating and displaying lemmas during proof processing. A concrete use case is managing intermediate proof statements in a solver that constructs or verifies logical proofs step-by-step.",
      "description_length": 384,
      "index": 60,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Mc2_core",
      "library": "mc2.core",
      "description": "This module provides operations for logical reasoning, including constraint propagation, conflict resolution, and proof construction, with stateful tracking of assignments and theory-specific extensions. It works with generalized algebraic datatypes representing atoms, terms, clauses, and semantic contexts, alongside modular type class patterns to support DPLL(T)-style solving and transformations like Tseitin encoding. Key use cases include SAT/SMT solving, formal verification, and automated theorem proving requiring precise semantic evaluation and extensible theory integration.",
      "description_length": 585,
      "index": 61,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 64,
    "meaningful_modules": 62,
    "filtered_empty_modules": 2,
    "retention_rate": 0.96875
  },
  "statistics": {
    "max_description_length": 659,
    "min_description_length": 227,
    "avg_description_length": 441.1290322580645,
    "embedding_file_size_mb": 0.8988542556762695
  }
}