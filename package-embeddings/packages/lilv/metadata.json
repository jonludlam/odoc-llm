{
  "package": "lilv",
  "embedding_model": "BAAI/bge-base-en-v1.5",
  "embedding_dimension": 1024,
  "total_modules": 12,
  "creation_timestamp": "2025-06-18T16:32:38.364695",
  "modules": [
    {
      "module_path": "Lilv.LV2.Core",
      "description": "Provides functions to retrieve and manipulate LV2 URI strings, port identifiers, and connection attributes. Works with strings representing plugin ports and metadata. Used to define audio and control signal paths in LV2 plugin implementations.",
      "description_length": 243,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lilv.Plugin.Class",
      "description": "Provides operations to retrieve the label of a plugin class. Works with the `t` type representing plugin classes. Used to identify and categorize plugins during runtime processing.",
      "description_length": 180,
      "index": 1,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lilv.Plugin.Instance",
      "description": "Handles real-time data processing by connecting float arrays to specific ports, activating, deactivating, and running instances with defined sample counts. Operates on plugin instances represented by the type `t` and interacts with Bigarray structures for efficient numerical data handling. Used to manage audio processing pipelines where precise control over data flow and execution is required.",
      "description_length": 396,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lilv.LV2",
      "description": "Handles LV2 URI manipulation, port identification, and connection attributes through string-based operations. Supports defining audio and control signal paths by processing plugin port metadata. Allows parsing, constructing, and modifying LV2 identifiers and their associated properties. Examples include extracting port symbols from URIs, validating connection setups, and generating metadata for plugin interfaces.",
      "description_length": 416,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lilv.Node",
      "description": "Provides operations to compare nodes, check their type, and convert them to primitive values like URI, string, integer, float, or boolean. Works with a generic node type that can represent various data forms. Creates and manipulates nodes for use in semantic web or graph data processing.",
      "description_length": 288,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lilv.Nodes",
      "description": "Provides operations to determine the size of a node collection, apply a function to each element, and convert the collection to a list of nodes. Works with a custom type representing a collection of nodes. Used to process node data in bulk, such as counting elements or preparing data for further processing.",
      "description_length": 308,
      "index": 5,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lilv.Port",
      "description": "Checks port classification and properties, retrieves port indices, symbols, names, and value ranges in both integer and floating-point formats. Determines if a port is input, output, audio, or control, and whether connections are optional. Extracts default, minimum, and maximum values for numerical ports.",
      "description_length": 306,
      "index": 6,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lilv.Plugin",
      "description": "manages plugin classes and instances, offering methods to extract labels and control real-time data processing. It works with the `t` type for both plugin classes and instances, enabling operations like activation, deactivation, and execution with float array inputs. It supports efficient numerical processing through Bigarray interactions, allowing precise management of audio pipelines. Examples include retrieving plugin categories and running audio processing tasks with defined sample rates.",
      "description_length": 497,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lilv.Plugins",
      "description": "Provides operations to manage a collection of plugins, including retrieving by URI, iterating over elements, and converting to a list. Works with the `Plugin.t` type and the abstract collection type `t`. Used to dynamically access and process plugins in a system.",
      "description_length": 263,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lilv.World",
      "description": "Provides functions to initialize a world, load plugins into it, and retrieve the plugin collection. Operates with a world type that encapsulates plugin data. Used to set up an environment where plugins are dynamically loaded and accessed.",
      "description_length": 238,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "lilv",
      "description": "Provides functions to load and query LV2 audio plugins, including accessing plugin ports, events, and features. Works with data types such as plugin descriptors, port ranges, and RDF triples. Used to integrate and manipulate audio processing units within OCaml-based audio applications.",
      "description_length": 286,
      "index": 10,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lilv",
      "description": "manages LV2 plugin data through a set of interrelated operations, handling URI parsing, node manipulation, port classification, and plugin lifecycle. It uses types like node, collection, and plugin to process metadata, validate connections, and execute audio tasks. Functions include extracting port symbols, converting node data, and initializing plugin environments. Examples range from parsing plugin interfaces to running real-time audio processing with defined sample rates.",
      "description_length": 479,
      "index": 11,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 12,
    "meaningful_modules": 12,
    "filtered_empty_modules": 0,
    "retention_rate": 1.0
  },
  "statistics": {
    "max_description_length": 497,
    "min_description_length": 180,
    "avg_description_length": 325.0,
    "embedding_file_size_mb": 0.04401397705078125
  }
}