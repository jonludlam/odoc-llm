{
  "package": "lilv",
  "embedding_model": "Qwen/Qwen3-Embedding-8B",
  "embedding_dimension": 4096,
  "total_modules": 11,
  "creation_timestamp": "2025-08-15T12:08:33.102428",
  "modules": [
    {
      "module_path": "Lilv.Plugin.Instance",
      "library": "lilv",
      "description": "This module manages instances of plugins, allowing them to be activated, deactivated, and run for audio processing. It provides functions to connect float ports to data buffers and control plugin execution. Concrete use cases include loading a plugin instance, connecting its input/output ports to audio buffers, and running it for a block of samples during real-time audio processing.",
      "description_length": 385,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lilv.LV2.Core",
      "library": "lilv",
      "description": "This module defines core constants and port types for LV2 plugins, including URIs for standard ports like audio, control, input, and output. It provides functions to construct prefixed URIs and access connection flags for optional ports. Use this module to configure plugin ports and manage port connections in LV2-based audio processing.",
      "description_length": 338,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lilv.Plugin.Class",
      "library": "lilv",
      "description": "This module defines the structure and label retrieval for plugin classes. It provides the `label` function to obtain the human-readable name of a plugin class. Use this module to categorize and identify plugin types within a plugin system.",
      "description_length": 239,
      "index": 2,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lilv.Port",
      "library": "lilv",
      "description": "This module provides functions to inspect and query properties of plugin ports, such as their direction (input/output), type (audio, control), and value ranges. It operates on port objects, allowing retrieval of metadata like index, symbol, name, and numerical bounds. Concrete use cases include validating port connections, configuring plugin parameters, and exposing port controls in a user interface.",
      "description_length": 403,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lilv.World",
      "library": "lilv",
      "description": "This module manages a collection of plugins within a host environment. It provides operations to create a new plugin container, load all available plugins, and retrieve the collection of plugins. It is used in audio plugin hosts to access and manage LV2 plugins.",
      "description_length": 262,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lilv.LV2",
      "library": "lilv",
      "description": "This module implements the LV2 plugin specification with core constants, port types, and URI handling for audio and control ports. It supports operations to construct URIs with prefixes and retrieve connection flags for optional ports. Use it to configure plugin ports and manage port connections in LV2-based audio processing systems.",
      "description_length": 335,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lilv.Plugin",
      "library": "lilv",
      "description": "This module provides access to plugin metadata such as URI, name, and author details, and allows inspection of plugin properties including class, feature requirements, and port information. It supports concrete operations like retrieving port details by index or symbol, checking for latency reporting, and obtaining the latency port index. The module works with plugin data structures to enable discovery and classification, serving use cases such as plugin enumeration, capability checking, and integration into audio processing systems.",
      "description_length": 539,
      "index": 6,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lilv.Plugins",
      "library": "lilv",
      "description": "This module manages a collection of plugins, providing operations to retrieve the number of plugins, find a plugin by its URI, apply a function to each plugin, and convert the collection into a list. It works with plugin collections and individual plugin instances. Concrete use cases include querying available plugins, iterating over all plugins to perform actions, and converting the collection for further list-based processing.",
      "description_length": 432,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lilv.Node",
      "library": "lilv",
      "description": "This module handles creation and manipulation of nodes representing various data types in an RDF-like graph, including URIs, blank nodes, strings, integers, floats, and booleans. It provides equality checks, type predicates, and conversion functions for these node types. Concrete use cases include constructing and inspecting nodes when working with LV2 plugin metadata or similar structured data graphs.",
      "description_length": 405,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lilv.Nodes",
      "library": "lilv",
      "description": "This module handles collections of `Lilv.Node.t` values, providing operations to determine the length of a collection, apply a function to each element, and convert the collection into a list. It works directly with the abstract type `t` representing a node collection and individual `Lilv.Node.t` elements. Concrete use cases include processing sets of LV2 plugin nodes, such as iterating over plugin ports or converting node groups for further list-based manipulation.",
      "description_length": 470,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lilv",
      "library": "lilv",
      "description": "This module implements the LV2 plugin specification with core constants, port types, and URI handling for audio and control ports. It supports operations to construct URIs with prefixes and retrieve connection flags for optional ports. Use it to configure plugin ports and manage port connections in LV2-based audio processing systems.",
      "description_length": 335,
      "index": 10,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 11,
    "meaningful_modules": 11,
    "filtered_empty_modules": 0,
    "retention_rate": 1.0
  },
  "statistics": {
    "max_description_length": 539,
    "min_description_length": 239,
    "avg_description_length": 376.6363636363636,
    "embedding_file_size_mb": 0.15984725952148438
  }
}